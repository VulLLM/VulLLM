[
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int read_is_valid ( const uint8_t * start , size_t len , const uint8_t * end ) {\n return len != 0 && len <= ( size_t ) ( end - start ) ;\n }",
        "output": "0",
        "idx": 675
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int _tiffMapProc ( thandle_t fd , void * * pbase , toff_t * psize ) {\n uint64 size ;\n tmsize_t sizem ;\n HANDLE hMapFile ;\n size = _tiffSizeProc ( fd ) ;\n sizem = ( tmsize_t ) size ;\n if ( ( uint64 ) sizem != size ) return ( 0 ) ;\n hMapFile = CreateFileMapping ( fd , NULL , PAGE_READONLY , 0 , 0 , NULL ) ;\n if ( hMapFile == NULL ) return ( 0 ) ;\n * pbase = MapViewOfFile ( hMapFile , FILE_MAP_READ , 0 , 0 , 0 ) ;\n CloseHandle ( hMapFile ) ;\n if ( * pbase == NULL ) return ( 0 ) ;\n * psize = size ;\n return ( 1 ) ;\n }",
        "output": "0",
        "idx": 4350
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int h261_decode_mb_skipped ( H261Context * h , int mba1 , int mba2 ) {\n MpegEncContext * const s = & h -> s ;\n int i ;\n s -> mb_intra = 0 ;\n for ( i = mba1 ;\n i < mba2 ;\n i ++ ) {\n int j , xy ;\n s -> mb_x = ( ( h -> gob_number - 1 ) % 2 ) * 11 + i % 11 ;\n s -> mb_y = ( ( h -> gob_number - 1 ) / 2 ) * 3 + i / 11 ;\n xy = s -> mb_x + s -> mb_y * s -> mb_stride ;\n ff_init_block_index ( s ) ;\n ff_update_block_index ( s ) ;\n for ( j = 0 ;\n j < 6 ;\n j ++ ) s -> block_last_index [ j ] = - 1 ;\n s -> mv_dir = MV_DIR_FORWARD ;\n s -> mv_type = MV_TYPE_16X16 ;\n s -> current_picture . f . mb_type [ xy ] = MB_TYPE_SKIP | MB_TYPE_16x16 | MB_TYPE_L0 ;\n s -> mv [ 0 ] [ 0 ] [ 0 ] = 0 ;\n s -> mv [ 0 ] [ 0 ] [ 1 ] = 0 ;\n s -> mb_skipped = 1 ;\n h -> mtype &= ~ MB_TYPE_H261_FIL ;\n ff_MPV_decode_mb ( s , s -> block ) ;\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 2767
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * allocString ( uint32_t length ) {\n uint32_t top = stringTop + length ;\n char * p ;\n if ( top > STRING_STORE_SIZE ) {\n fprintf ( stderr , \"gencmn: out of memory\\n\" ) ;\n exit ( U_MEMORY_ALLOCATION_ERROR ) ;\n }\n p = stringStore + stringTop ;\n stringTop = top ;\n return p ;\n }",
        "output": "0",
        "idx": 3029
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jbig2_word_stream_buf_get_next_word ( Jbig2WordStream * self , int offset , uint32_t * word ) {\n Jbig2WordStreamBuf * z = ( Jbig2WordStreamBuf * ) self ;\n const byte * data = z -> data ;\n uint32_t result ;\n if ( offset + 4 < z -> size ) result = ( data [ offset ] << 24 ) | ( data [ offset + 1 ] << 16 ) | ( data [ offset + 2 ] << 8 ) | data [ offset + 3 ] ;\n else if ( offset > z -> size ) return - 1 ;\n else {\n int i ;\n result = 0 ;\n for ( i = 0 ;\n i < z -> size - offset ;\n i ++ ) result |= data [ offset + i ] << ( ( 3 - i ) << 3 ) ;\n }\n * word = result ;\n return 0 ;\n }",
        "output": "1",
        "idx": 3589
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline dma_addr_t xhci_addr64 ( uint32_t low , uint32_t high ) {\n if ( sizeof ( dma_addr_t ) == 4 ) {\n return low ;\n }\n else {\n return low | ( ( ( dma_addr_t ) high << 16 ) << 16 ) ;\n }\n }",
        "output": "0",
        "idx": 1236
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int isoent_find_out_boot_file ( struct archive_write * a , struct isoent * rootent ) {\n struct iso9660 * iso9660 = a -> format_data ;\n iso9660 -> el_torito . boot = isoent_find_entry ( rootent , iso9660 -> el_torito . boot_filename . s ) ;\n if ( iso9660 -> el_torito . boot == NULL ) {\n archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , \"Can't find the boot image file ``%s''\" , iso9660 -> el_torito . boot_filename . s ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n iso9660 -> el_torito . boot -> file -> boot = BOOT_IMAGE ;\n return ( ARCHIVE_OK ) ;\n }",
        "output": "0",
        "idx": 4084
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ossl_inline void lh_ ## type ## _set_down_load ( LHASH_OF ( type ) * lh , unsigned long dl ) {\n OPENSSL_LH_set_down_load ( ( OPENSSL_LHASH * ) lh , dl ) ;\n }\n static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {\n OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;\n }\n LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {\n OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;\n }\n LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING )",
        "output": "1",
        "idx": 3510
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( BrowsingDataRemoverImplTest , RemoveChannelIDLastHour ) {\n RemoveChannelIDTester tester ( GetBrowserContext ( ) ) ;\n base : : Time now = base : : Time : : Now ( ) ;\n tester . AddChannelID ( kTestOrigin1 ) ;\n tester . AddChannelIDWithTimes ( kTestOrigin2 , now - base : : TimeDelta : : FromHours ( 2 ) ) ;\n EXPECT_EQ ( 0 , tester . ssl_config_changed_count ( ) ) ;\n EXPECT_EQ ( 2 , tester . ChannelIDCount ( ) ) ;\n BlockUntilBrowsingDataRemoved ( AnHourAgo ( ) , base : : Time : : Max ( ) , BrowsingDataRemover : : REMOVE_CHANNEL_IDS , false ) ;\n EXPECT_EQ ( BrowsingDataRemover : : REMOVE_CHANNEL_IDS , GetRemovalMask ( ) ) ;\n EXPECT_EQ ( BrowsingDataHelper : : UNPROTECTED_WEB , GetOriginTypeMask ( ) ) ;\n EXPECT_EQ ( 1 , tester . ssl_config_changed_count ( ) ) ;\n ASSERT_EQ ( 1 , tester . ChannelIDCount ( ) ) ;\n net : : ChannelIDStore : : ChannelIDList channel_ids ;\n tester . GetChannelIDList ( & channel_ids ) ;\n ASSERT_EQ ( 1U , channel_ids . size ( ) ) ;\n EXPECT_EQ ( kTestOrigin2 , channel_ids . front ( ) . server_identifier ( ) ) ;\n }",
        "output": "0",
        "idx": 51
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void linux_udev_hotplug_poll ( void ) {\n struct udev_device * udev_dev ;\n usbi_mutex_static_lock ( & linux_hotplug_lock ) ;\n do {\n udev_dev = udev_monitor_receive_device ( udev_monitor ) ;\n if ( udev_dev ) {\n usbi_dbg ( \"Handling hotplug event from hotplug_poll\" ) ;\n udev_hotplug_event ( udev_dev ) ;\n }\n }\n while ( udev_dev ) ;\n usbi_mutex_static_unlock ( & linux_hotplug_lock ) ;\n }",
        "output": "1",
        "idx": 1538
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void k12_close ( wtap * wth ) {\n k12_t * k12 = ( k12_t * ) wth -> priv ;\n destroy_k12_file_data ( k12 ) ;\n wth -> priv = NULL ;\n # ifdef DEBUG_K12 K12_DBG ( 5 , ( \"k12_close: CLOSED\" ) ) ;\n if ( env_file ) fclose ( dbg_out ) ;\n # endif }",
        "output": "0",
        "idx": 1565
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main ( int argc , char * * argv ) {\n char inputbuf [ 4096 ] ;\n unsigned char * buf ;\n size_t len ;\n gpg_error_t err ;\n if ( argc == 2 && ! strcmp ( argv [ 1 ] , \"--to-str\" ) ) {\n fread ( inputbuf , 1 , sizeof inputbuf , stdin ) ;\n if ( ! feof ( stdin ) ) fail ( \"read error or input too large\" ) ;\n fail ( \"no yet implemented\" ) ;\n }\n else if ( argc == 2 && ! strcmp ( argv [ 1 ] , \"--to-der\" ) ) {\n fread ( inputbuf , 1 , sizeof inputbuf , stdin ) ;\n if ( ! feof ( stdin ) ) fail ( \"read error or input too large\" ) ;\n err = ksba_dn_str2der ( inputbuf , & buf , & len ) ;\n fail_if_err ( err ) ;\n fwrite ( buf , len , 1 , stdout ) ;\n }\n else if ( argc == 1 ) {\n test_0 ( ) ;\n test_1 ( ) ;\n test_2 ( ) ;\n }\n else {\n fprintf ( stderr , \"usage: t-dnparser [--to-str|--to-der]\\n\" ) ;\n return 1 ;\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 3927
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jpc_pchglist_t * jpc_pchglist_copy ( jpc_pchglist_t * pchglist ) {\n jpc_pchglist_t * newpchglist ;\n jpc_pchg_t * newpchg ;\n int pchgno ;\n if ( ! ( newpchglist = jpc_pchglist_create ( ) ) ) {\n return 0 ;\n }\n for ( pchgno = 0 ;\n pchgno < pchglist -> numpchgs ;\n ++ pchgno ) {\n if ( ! ( newpchg = jpc_pchg_copy ( pchglist -> pchgs [ pchgno ] ) ) || jpc_pchglist_insert ( newpchglist , - 1 , newpchg ) ) {\n jpc_pchglist_destroy ( newpchglist ) ;\n return 0 ;\n }\n }\n return newpchglist ;\n }",
        "output": "0",
        "idx": 3816
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mspack_fmap_close ( struct mspack_file * file ) {\n struct mspack_handle * mspack_handle = ( struct mspack_handle * ) file ;\n if ( ! mspack_handle ) return ;\n if ( mspack_handle -> type == FILETYPE_FILENAME ) fclose ( mspack_handle -> f ) ;\n free ( mspack_handle ) ;\n }",
        "output": "0",
        "idx": 2492
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void initial_reordering_non_myanmar_cluster ( const hb_ot_shape_plan_t * plan HB_UNUSED , hb_face_t * face HB_UNUSED , hb_buffer_t * buffer HB_UNUSED , unsigned int start HB_UNUSED , unsigned int end HB_UNUSED ) {\n }",
        "output": "1",
        "idx": 3809
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ExternalProtocolHandlerTest , TestClearProfileState ) {\n base : : DictionaryValue prefs ;\n prefs . SetBoolean ( \"tel\" , true ) ;\n profile_ -> GetPrefs ( ) -> Set ( prefs : : kExcludedSchemes , prefs ) ;\n EXPECT_FALSE ( profile_ -> GetPrefs ( ) -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;\n ExternalProtocolHandler : : ClearData ( profile_ . get ( ) ) ;\n EXPECT_TRUE ( profile_ -> GetPrefs ( ) -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;\n }",
        "output": "1",
        "idx": 161
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dtap_cc_call_proceed ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_offset = offset ;\n curr_len = len ;\n is_uplink = IS_UPLINK_FALSE ;\n ELEM_OPT_TV_SHORT ( 0xd0 , GSM_A_PDU_TYPE_DTAP , DE_REPEAT_IND , \" BC repeat indicator\" ) ;\n ELEM_OPT_TLV ( 0x04 , GSM_A_PDU_TYPE_DTAP , DE_BEARER_CAP , \" 1\" ) ;\n ELEM_OPT_TLV ( 0x04 , GSM_A_PDU_TYPE_DTAP , DE_BEARER_CAP , \" 2\" ) ;\n ELEM_OPT_TLV ( 0x1c , GSM_A_PDU_TYPE_DTAP , DE_FACILITY , NULL ) ;\n ELEM_OPT_TLV ( 0x1e , GSM_A_PDU_TYPE_DTAP , DE_PROG_IND , NULL ) ;\n ELEM_OPT_TV_SHORT ( 0x80 , GSM_A_PDU_TYPE_COMMON , DE_PRIO , NULL ) ;\n ELEM_OPT_TLV ( 0x2f , GSM_A_PDU_TYPE_DTAP , DE_NET_CC_CAP , NULL ) ;\n EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n }",
        "output": "0",
        "idx": 1898
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , BackgroundThenForeground_Https ) {\n StartHttpsServer ( false ) ;\n base : : TimeDelta upper_bound = NavigateInBackgroundAndCloseInForegroundWithTiming ( https_test_server_ -> GetURL ( \"/simple.html\" ) ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 0 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 1 ) ;\n int32_t bucket_min = histogram_tester_ . GetAllSamples ( internal : : kHttpsEngagementHistogram ) [ 0 ] . min ;\n EXPECT_GE ( upper_bound . InMilliseconds ( ) , bucket_min ) ;\n EXPECT_LT ( 0 , bucket_min ) ;\n }",
        "output": "1",
        "idx": 2030
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ohci_hard_reset ( OHCIState * ohci ) {\n ohci_soft_reset ( ohci ) ;\n ohci -> ctl = 0 ;\n ohci_roothub_reset ( ohci ) ;\n }",
        "output": "0",
        "idx": 2663
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main ( int argc , char * * argv ) {\n gpg_error_t err ;\n if ( argc ) {\n argc -- ;\n argv ++ ;\n }\n if ( argc ) {\n unsigned char * buffer ;\n size_t n , buflen ;\n for ( ;\n argc ;\n argc -- , argv ++ ) {\n err = ksba_oid_from_str ( * argv , & buffer , & buflen ) ;\n if ( err ) {\n fprintf ( stderr , \"can't convert `%s': %s\\n\" , * argv , gpg_strerror ( err ) ) ;\n return 1 ;\n }\n printf ( \"%s ->\" , * argv ) ;\n for ( n = 0 ;\n n < buflen ;\n n ++ ) printf ( \" %02X\" , buffer [ n ] ) ;\n putchar ( '\\n' ) ;\n free ( buffer ) ;\n }\n }\n else {\n char * buffer ;\n size_t buflen ;\n char * result ;\n buffer = read_into_buffer ( stdin , & buflen ) ;\n result = ksba_oid_to_str ( buffer , buflen ) ;\n free ( buffer ) ;\n printf ( \"%s\\n\" , result ? result : \"[malloc failed]\" ) ;\n free ( result ) ;\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 3575
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_rawv6_getsockopt ( struct sock * sk , int level , int optname , char __user * optval , int __user * optlen ) {\n struct raw6_sock * rp = raw6_sk ( sk ) ;\n int val , len ;\n if ( get_user ( len , optlen ) ) return - EFAULT ;\n switch ( optname ) {\n case IPV6_CHECKSUM : if ( rp -> checksum == 0 ) val = - 1 ;\n else val = rp -> offset ;\n break ;\n default : return - ENOPROTOOPT ;\n }\n len = min_t ( unsigned int , sizeof ( int ) , len ) ;\n if ( put_user ( len , optlen ) ) return - EFAULT ;\n if ( copy_to_user ( optval , & val , len ) ) return - EFAULT ;\n return 0 ;\n }",
        "output": "0",
        "idx": 3407
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void nautilus_directory_get_info_for_new_files ( NautilusDirectory * directory , GList * location_list ) {\n NewFilesState * state ;\n GFile * location ;\n GList * l ;\n if ( location_list == NULL ) {\n return ;\n }\n state = g_new ( NewFilesState , 1 ) ;\n state -> directory = directory ;\n state -> cancellable = g_cancellable_new ( ) ;\n state -> count = 0 ;\n for ( l = location_list ;\n l != NULL ;\n l = l -> next ) {\n location = l -> data ;\n state -> count ++ ;\n g_file_query_info_async ( location , NAUTILUS_FILE_DEFAULT_ATTRIBUTES , 0 , G_PRIORITY_DEFAULT , state -> cancellable , new_files_callback , state ) ;\n }\n directory -> details -> new_files_in_progress = g_list_prepend ( directory -> details -> new_files_in_progress , state ) ;\n }",
        "output": "0",
        "idx": 2441
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void band_destroy ( jpc_enc_band_t * band ) {\n jpc_enc_prc_t * prc ;\n jpc_enc_rlvl_t * rlvl ;\n uint_fast32_t prcno ;\n if ( band -> prcs ) {\n rlvl = band -> rlvl ;\n for ( prcno = 0 , prc = band -> prcs ;\n prcno < rlvl -> numprcs ;\n ++ prcno , ++ prc ) {\n prc_destroy ( prc ) ;\n }\n jas_free ( band -> prcs ) ;\n }\n if ( band -> data ) {\n jas_seq2d_destroy ( band -> data ) ;\n }\n }",
        "output": "1",
        "idx": 1273
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_pcp_message_user_auth ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , int offset ) {\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \"[%s]\" , val_to_str ( PCP_PDU_USER_AUTH , packettypenames , \"Unknown Type:0x%02x\" ) ) ;\n proto_tree_add_item ( tree , hf_pcp_user_auth_payload , tvb , offset , - 1 , ENC_NA ) ;\n return tvb_reported_length ( tvb ) ;\n }",
        "output": "0",
        "idx": 3524
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void traverse_bitmap_commit_list ( show_reachable_fn show_reachable ) {\n assert ( bitmap_git . result ) ;\n show_objects_for_type ( bitmap_git . result , bitmap_git . commits , OBJ_COMMIT , show_reachable ) ;\n show_objects_for_type ( bitmap_git . result , bitmap_git . trees , OBJ_TREE , show_reachable ) ;\n show_objects_for_type ( bitmap_git . result , bitmap_git . blobs , OBJ_BLOB , show_reachable ) ;\n show_objects_for_type ( bitmap_git . result , bitmap_git . tags , OBJ_TAG , show_reachable ) ;\n show_extended_objects ( bitmap_git . result , show_reachable ) ;\n bitmap_free ( bitmap_git . result ) ;\n bitmap_git . result = NULL ;\n }",
        "output": "0",
        "idx": 2182
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline UChar * toUCharPtr ( char16_t * p ) {\n # ifdef U_ALIASING_BARRIER U_ALIASING_BARRIER ( p ) ;\n # endif return reinterpret_cast < UChar * > ( p ) ;\n }",
        "output": "1",
        "idx": 194
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "double vp9_convert_qindex_to_q ( int qindex ) {\n return vp9_ac_quant ( qindex , 0 ) / 4.0 ;\n }",
        "output": "1",
        "idx": 4110
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tile_worker_hook ( void * arg1 , void * arg2 ) {\n TileWorkerData * const tile_data = ( TileWorkerData * ) arg1 ;\n const TileInfo * const tile = ( TileInfo * ) arg2 ;\n int mi_row , mi_col ;\n for ( mi_row = tile -> mi_row_start ;\n mi_row < tile -> mi_row_end ;\n mi_row += MI_BLOCK_SIZE ) {\n vp9_zero ( tile_data -> xd . left_context ) ;\n vp9_zero ( tile_data -> xd . left_seg_context ) ;\n for ( mi_col = tile -> mi_col_start ;\n mi_col < tile -> mi_col_end ;\n mi_col += MI_BLOCK_SIZE ) {\n decode_partition ( tile_data -> cm , & tile_data -> xd , tile , mi_row , mi_col , & tile_data -> bit_reader , BLOCK_64X64 ) ;\n }\n }\n return ! tile_data -> xd . corrupted ;\n }",
        "output": "1",
        "idx": 1675
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_IsupNumber ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_IsupNumber , IsupNumber_choice , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 3492
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int parse_CCategorizationSpec ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , const char * fmt , ... ) {\n proto_item * item ;\n proto_tree * tree ;\n const char * txt ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CCategorizationSpec , & item , txt ) ;\n offset = parse_CColumnSet ( tvb , offset , tree , \"csColumns\" ) ;\n offset = parse_CCategSpec ( tvb , offset , tree , pad_tree , \"Spec\" ) ;\n offset = parse_CAggregSet ( tvb , offset , tree , pad_tree , \"AggregSet\" ) ;\n offset = parse_CSortAggregSet ( tvb , offset , tree , pad_tree , \"SortAggregSet\" ) ;\n offset = parse_CInGroupSortAggregSets ( tvb , offset , tree , pad_tree , \"InGroupSortAggregSets\" ) ;\n proto_tree_add_item ( tree , hf_mswsp_categorizationspec_cmaxres , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }",
        "output": "1",
        "idx": 3933
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileObject , ftruncate ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n long size ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"l\" , & size ) == FAILURE ) {\n return ;\n }\n if ( ! php_stream_truncate_supported ( intern -> u . file . stream ) ) {\n zend_throw_exception_ex ( spl_ce_LogicException , 0 TSRMLS_CC , \"Can't truncate file %s\" , intern -> file_name ) ;\n RETURN_FALSE ;\n }\n RETURN_BOOL ( 0 == php_stream_truncate_set_size ( intern -> u . file . stream , size ) ) ;\n }",
        "output": "1",
        "idx": 3839
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __inline __uint16_t __uint16_identity ( __uint16_t __x ) {\n return __x ;\n }",
        "output": "1",
        "idx": 615
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;\n __exctype_l ( isalpha_l ) ;\n __exctype_l ( iscntrl_l ) ;\n __exctype_l ( isdigit_l )",
        "output": "1",
        "idx": 3135
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_pseudo_header_frame6 ( wtap * wth , union wtap_pseudo_header * pseudo_header , struct frame6_rec * frame6 _U_ ) {\n switch ( wth -> file_encap ) {\n case WTAP_ENCAP_ETHERNET : pseudo_header -> eth . fcs_len = - 1 ;\n break ;\n }\n }",
        "output": "0",
        "idx": 3876
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct FrameData * fd_create ( void * buf , size_t size , vpx_codec_frame_flags_t flags ) {\n struct FrameData * const frame_data = ( struct FrameData * ) vpx_malloc ( sizeof ( * frame_data ) ) ;\n if ( frame_data == NULL ) {\n return NULL ;\n }\n frame_data -> buf = vpx_malloc ( size ) ;\n if ( frame_data -> buf == NULL ) {\n vpx_free ( frame_data ) ;\n return NULL ;\n }\n vpx_memcpy ( frame_data -> buf , buf , size ) ;\n frame_data -> size = size ;\n frame_data -> flags = flags ;\n return frame_data ;\n }",
        "output": "1",
        "idx": 1401
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline uint32_t vga_read_dword_le ( VGACommonState * vga , uint32_t addr ) {\n uint32_t offset = addr & vga -> vbe_size_mask & ~ 3 ;\n uint32_t * ptr = ( uint32_t * ) ( vga -> vram_ptr + offset ) ;\n return ldl_le_p ( ptr ) ;\n }",
        "output": "0",
        "idx": 3818
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dump_sp ( struct xfrm_policy * xp , int dir , int count , void * ptr ) {\n struct pfkey_sock * pfk = ptr ;\n struct sk_buff * out_skb ;\n struct sadb_msg * out_hdr ;\n int err ;\n if ( ! pfkey_can_dump ( & pfk -> sk ) ) return - ENOBUFS ;\n out_skb = pfkey_xfrm_policy2msg_prep ( xp ) ;\n if ( IS_ERR ( out_skb ) ) return PTR_ERR ( out_skb ) ;\n err = pfkey_xfrm_policy2msg ( out_skb , xp , dir ) ;\n if ( err < 0 ) return err ;\n out_hdr = ( struct sadb_msg * ) out_skb -> data ;\n out_hdr -> sadb_msg_version = pfk -> dump . msg_version ;\n out_hdr -> sadb_msg_type = SADB_X_SPDDUMP ;\n out_hdr -> sadb_msg_satype = SADB_SATYPE_UNSPEC ;\n out_hdr -> sadb_msg_errno = 0 ;\n out_hdr -> sadb_msg_seq = count + 1 ;\n out_hdr -> sadb_msg_pid = pfk -> dump . msg_portid ;\n if ( pfk -> dump . skb ) pfkey_broadcast ( pfk -> dump . skb , GFP_ATOMIC , BROADCAST_ONE , & pfk -> sk , sock_net ( & pfk -> sk ) ) ;\n pfk -> dump . skb = out_skb ;\n return 0 ;\n }",
        "output": "0",
        "idx": 239
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_INTEGER_1_255 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 1U , 255U , NULL , FALSE ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 3504
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "proto_item * ptvcursor_add_no_advance ( ptvcursor_t * ptvc , int hf , gint length , const guint encoding ) {\n proto_item * item ;\n item = proto_tree_add_item ( ptvc -> tree , hf , ptvc -> tvb , ptvc -> offset , length , encoding ) ;\n return item ;\n }",
        "output": "0",
        "idx": 577
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void U_CALLCONV normalizationCorrectionsLineFn ( void * context , char * fields [ ] [ 2 ] , int32_t fieldCount , UErrorCode * pErrorCode ) {\n uint32_t mapping [ 40 ] ;\n char * end , * s ;\n uint32_t code ;\n int32_t length ;\n UVersionInfo version ;\n UVersionInfo thisVersion ;\n code = ( uint32_t ) uprv_strtoul ( fields [ 0 ] [ 0 ] , & end , 16 ) ;\n if ( U_FAILURE ( * pErrorCode ) ) {\n fprintf ( stderr , \"gensprep: error parsing NormalizationCorrections.txt mapping at %s\\n\" , fields [ 0 ] [ 0 ] ) ;\n exit ( * pErrorCode ) ;\n }\n s = fields [ 1 ] [ 0 ] ;\n length = u_parseCodePoints ( s , mapping , sizeof ( mapping ) / 4 , pErrorCode ) ;\n u_versionFromString ( version , fields [ 3 ] [ 0 ] ) ;\n u_versionFromString ( thisVersion , \"3.2.0\" ) ;\n if ( U_FAILURE ( * pErrorCode ) ) {\n fprintf ( stderr , \"gensprep error parsing NormalizationCorrections.txt of U+%04lx - %s\\n\" , ( long ) code , u_errorName ( * pErrorCode ) ) ;\n exit ( * pErrorCode ) ;\n }\n if ( version [ 0 ] > thisVersion [ 0 ] || ( ( version [ 0 ] == thisVersion [ 0 ] ) && ( version [ 1 ] > thisVersion [ 1 ] ) ) ) {\n storeMapping ( code , mapping , length , USPREP_MAP , pErrorCode ) ;\n }\n setUnicodeVersionNC ( version ) ;\n }",
        "output": "0",
        "idx": 598
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vacuum_all_databases ( vacuumingOptions * vacopts , bool analyze_in_stages , const char * maintenance_db , const char * host , const char * port , const char * username , enum trivalue prompt_password , int concurrentCons , const char * progname , bool echo , bool quiet ) {\n PGconn * conn ;\n PGresult * result ;\n int stage ;\n int i ;\n conn = connectMaintenanceDatabase ( maintenance_db , host , port , username , prompt_password , progname ) ;\n result = executeQuery ( conn , \"SELECT datname FROM pg_database WHERE datallowconn ORDER BY 1;\n\" , progname , echo ) ;\n PQfinish ( conn ) ;\n if ( analyze_in_stages ) {\n for ( stage = 0 ;\n stage < ANALYZE_NUM_STAGES ;\n stage ++ ) {\n for ( i = 0 ;\n i < PQntuples ( result ) ;\n i ++ ) {\n const char * dbname ;\n dbname = PQgetvalue ( result , i , 0 ) ;\n vacuum_one_database ( dbname , vacopts , stage , NULL , host , port , username , prompt_password , concurrentCons , progname , echo , quiet ) ;\n }\n }\n }\n else {\n for ( i = 0 ;\n i < PQntuples ( result ) ;\n i ++ ) {\n const char * dbname ;\n dbname = PQgetvalue ( result , i , 0 ) ;\n vacuum_one_database ( dbname , vacopts , ANALYZE_NO_STAGE , NULL , host , port , username , prompt_password , concurrentCons , progname , echo , quiet ) ;\n }\n }\n PQclear ( result ) ;\n }",
        "output": "1",
        "idx": 3950
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dissect_h225_CryptoH323Token ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_CryptoH323Token , CryptoH323Token_choice , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 1476
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mp_flush ( MPADecodeContext * ctx ) {\n memset ( ctx -> synth_buf , 0 , sizeof ( ctx -> synth_buf ) ) ;\n ctx -> last_buf_size = 0 ;\n }",
        "output": "0",
        "idx": 3388
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int unreference_pic ( H264Context * h , Picture * pic , int refmask ) {\n int i ;\n if ( pic -> f . reference &= refmask ) {\n return 0 ;\n }\n else {\n for ( i = 0 ;\n h -> delayed_pic [ i ] ;\n i ++ ) if ( pic == h -> delayed_pic [ i ] ) {\n pic -> f . reference = DELAYED_PIC_REF ;\n break ;\n }\n return 1 ;\n }\n }",
        "output": "1",
        "idx": 4337
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int s_aos_available ( stream * s , gs_offset_t * pl ) {\n * pl = ( ( aos_state_t * ) s -> state ) -> file_sz - stell ( s ) ;\n return 0 ;\n }",
        "output": "0",
        "idx": 3505
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void txfm_rd_in_plane ( MACROBLOCK * x , int * rate , int64_t * distortion , int * skippable , int64_t * sse , int64_t ref_best_rd , int plane , BLOCK_SIZE bsize , TX_SIZE tx_size , int use_fast_coef_casting ) {\n MACROBLOCKD * const xd = & x -> e_mbd ;\n const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;\n struct rdcost_block_args args ;\n vp9_zero ( args ) ;\n args . x = x ;\n args . best_rd = ref_best_rd ;\n args . use_fast_coef_costing = use_fast_coef_casting ;\n if ( plane == 0 ) xd -> mi [ 0 ] -> mbmi . tx_size = tx_size ;\n vp9_get_entropy_contexts ( bsize , tx_size , pd , args . t_above , args . t_left ) ;\n args . so = get_scan ( xd , tx_size , pd -> plane_type , 0 ) ;\n vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , block_rd_txfm , & args ) ;\n if ( args . skip ) {\n * rate = INT_MAX ;\n * distortion = INT64_MAX ;\n * sse = INT64_MAX ;\n * skippable = 0 ;\n }\n else {\n * distortion = args . this_dist ;\n * rate = args . this_rate ;\n * sse = args . this_sse ;\n * skippable = vp9_is_skippable_in_plane ( x , bsize , plane ) ;\n }\n }",
        "output": "1",
        "idx": 231
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_usb_vid_control_info ( proto_tree * tree , tvbuff_t * tvb , int offset ) {\n static const int * capability_bits [ ] = {\n & hf_usb_vid_control_info_D [ 0 ] , & hf_usb_vid_control_info_D [ 1 ] , & hf_usb_vid_control_info_D [ 2 ] , & hf_usb_vid_control_info_D [ 3 ] , & hf_usb_vid_control_info_D [ 4 ] , & hf_usb_vid_control_info_D [ 5 ] , & hf_usb_vid_control_info_D [ 6 ] , NULL }\n ;\n DISSECTOR_ASSERT ( array_length ( capability_bits ) == ( 1 + array_length ( hf_usb_vid_control_info_D ) ) ) ;\n proto_tree_add_bitmask ( tree , tvb , offset , hf_usb_vid_control_info , ett_control_capabilities , capability_bits , ENC_NA ) ;\n return offset + 1 ;\n }",
        "output": "0",
        "idx": 4406
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST ( BuildTime , DateLooksValid ) {\n # if ! defined ( DONT_EMBED_BUILD_METADATA ) char build_date [ ] = __DATE__ ;\n # else char build_date [ ] = \"Sep 02 2008\" ;\n # endif EXPECT_EQ ( 11u , strlen ( build_date ) ) ;\n EXPECT_EQ ( ' ' , build_date [ 3 ] ) ;\n EXPECT_EQ ( ' ' , build_date [ 6 ] ) ;\n }",
        "output": "1",
        "idx": 2011
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cpu_signal ( int sig ) {\n if ( cpu_single_env ) {\n cpu_exit ( ENV_GET_CPU ( cpu_single_env ) ) ;\n }\n exit_request = 1 ;\n }",
        "output": "1",
        "idx": 1896
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static vpx_codec_err_t ctrl_set_svc_parameters ( vpx_codec_alg_priv_t * ctx , va_list args ) {\n VP9_COMP * const cpi = ctx -> cpi ;\n vpx_svc_parameters_t * const params = va_arg ( args , vpx_svc_parameters_t * ) ;\n if ( params == NULL || params -> spatial_layer < 0 || params -> spatial_layer >= cpi -> svc . number_spatial_layers ) return VPX_CODEC_INVALID_PARAM ;\n if ( params -> spatial_layer == 0 ) {\n int i ;\n for ( i = 0 ;\n i < cpi -> svc . number_spatial_layers ;\n ++ i ) {\n cpi -> svc . layer_context [ i ] . svc_params_received . spatial_layer = - 1 ;\n }\n }\n cpi -> svc . layer_context [ params -> spatial_layer ] . svc_params_received = * params ;\n return VPX_CODEC_OK ;\n }",
        "output": "1",
        "idx": 4316
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void restore_stack_limit ( lua_State * L ) {\n lua_assert ( L -> stack_last - L -> stack == L -> stacksize - EXTRA_STACK - 1 ) ;\n if ( L -> size_ci > LUAI_MAXCALLS ) {\n int inuse = cast_int ( L -> ci - L -> base_ci ) ;\n if ( inuse + 1 < LUAI_MAXCALLS ) luaD_reallocCI ( L , LUAI_MAXCALLS ) ;\n }\n }",
        "output": "0",
        "idx": 898
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static vpx_fixed_buf_t pass0 ( vpx_image_t * raw , FILE * infile , const VpxInterface * encoder , const vpx_codec_enc_cfg_t * cfg ) {\n vpx_codec_ctx_t codec ;\n int frame_count = 0 ;\n vpx_fixed_buf_t stats = {\n NULL , 0 }\n ;\n if ( vpx_codec_enc_init ( & codec , encoder -> codec_interface ( ) , cfg , 0 ) ) die_codec ( & codec , \"Failed to initialize encoder\" ) ;\n while ( vpx_img_read ( raw , infile ) ) {\n ++ frame_count ;\n get_frame_stats ( & codec , raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ;\n }\n while ( get_frame_stats ( & codec , NULL , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ) {\n }\n printf ( \"Pass 0 complete. Processed %d frames.\\n\" , frame_count ) ;\n if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed to destroy codec.\" ) ;\n return stats ;\n }",
        "output": "1",
        "idx": 327
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nb_add_time ( char * * ret_buffer , size_t * ret_buffer_len , uint16_t type , double value ) {\n uint64_t cdtime_value = ( uint64_t ) ( value * 1073741824.0 ) ;\n return ( nb_add_number ( ret_buffer , ret_buffer_len , type , cdtime_value ) ) ;\n }",
        "output": "0",
        "idx": 3308
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void U_CALLCONV _ISCIIReset ( UConverter * cnv , UConverterResetChoice choice ) {\n UConverterDataISCII * data = ( UConverterDataISCII * ) ( cnv -> extraInfo ) ;\n if ( choice <= UCNV_RESET_TO_UNICODE ) {\n cnv -> toUnicodeStatus = missingCharMarker ;\n cnv -> mode = 0 ;\n data -> currentDeltaToUnicode = data -> defDeltaToUnicode ;\n data -> currentMaskToUnicode = data -> defMaskToUnicode ;\n data -> contextCharToUnicode = NO_CHAR_MARKER ;\n data -> prevToUnicodeStatus = 0x0000 ;\n }\n if ( choice != UCNV_RESET_TO_UNICODE ) {\n cnv -> fromUChar32 = 0x0000 ;\n data -> contextCharFromUnicode = 0x00 ;\n data -> currentMaskFromUnicode = data -> defMaskToUnicode ;\n data -> currentDeltaFromUnicode = data -> defDeltaToUnicode ;\n data -> isFirstBuffer = TRUE ;\n data -> resetToDefaultToUnicode = FALSE ;\n }\n }",
        "output": "0",
        "idx": 1357
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void make_bands ( int16_t * bands , int start , int stop , int num_bands ) {\n int k , previous , present ;\n float base , prod ;\n base = powf ( ( float ) stop / start , 1.0f / num_bands ) ;\n prod = start ;\n previous = start ;\n for ( k = 0 ;\n k < num_bands - 1 ;\n k ++ ) {\n prod *= base ;\n present = lrintf ( prod ) ;\n bands [ k ] = present - previous ;\n previous = present ;\n }\n bands [ num_bands - 1 ] = stop - previous ;\n }",
        "output": "1",
        "idx": 2292
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "kadm5_ret_t kadm5_delete_policy ( void * server_handle , kadm5_policy_t name ) {\n kadm5_server_handle_t handle = server_handle ;\n osa_policy_ent_t entry ;\n int ret ;\n CHECK_HANDLE ( server_handle ) ;\n krb5_clear_error_message ( handle -> context ) ;\n if ( name == ( kadm5_policy_t ) NULL ) return EINVAL ;\n if ( strlen ( name ) == 0 ) return KADM5_BAD_POLICY ;\n ret = krb5_db_get_policy ( handle -> context , name , & entry ) ;\n if ( ret == KRB5_KDB_NOENTRY ) return KADM5_UNK_POLICY ;\n else if ( ret ) return ret ;\n if ( entry -> policy_refcnt != 0 ) {\n krb5_db_free_policy ( handle -> context , entry ) ;\n return KADM5_POLICY_REF ;\n }\n krb5_db_free_policy ( handle -> context , entry ) ;\n ret = krb5_db_delete_policy ( handle -> context , name ) ;\n if ( ret == KRB5_KDB_POLICY_REF ) ret = KADM5_POLICY_REF ;\n return ( ret == 0 ) ? KADM5_OK : ret ;\n }",
        "output": "1",
        "idx": 4282
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t u_scanf_double_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {\n int32_t len ;\n double num ;\n UNumberFormat * format ;\n int32_t parsePos = 0 ;\n int32_t skipped ;\n UErrorCode status = U_ZERO_ERROR ;\n skipped = u_scanf_skip_leading_ws ( input , info -> fPadChar ) ;\n ufile_fill_uchar_buffer ( input ) ;\n len = ( int32_t ) ( input -> str . fLimit - input -> str . fPos ) ;\n if ( info -> fWidth != - 1 ) len = ufmt_min ( len , info -> fWidth ) ;\n format = u_locbund_getNumberFormat ( & input -> str . fBundle , UNUM_DECIMAL ) ;\n if ( format == 0 ) return 0 ;\n skipped += u_scanf_skip_leading_positive_sign ( input , format , & status ) ;\n num = unum_parseDouble ( format , input -> str . fPos , len , & parsePos , & status ) ;\n if ( ! info -> fSkipArg ) {\n if ( info -> fIsLong ) * ( double * ) ( args [ 0 ] . ptrValue ) = num ;\n else if ( info -> fIsLongDouble ) * ( long double * ) ( args [ 0 ] . ptrValue ) = num ;\n else * ( float * ) ( args [ 0 ] . ptrValue ) = ( float ) num ;\n }\n input -> str . fPos += parsePos ;\n * argConverted = ! info -> fSkipArg ;\n return parsePos + skipped ;\n }",
        "output": "1",
        "idx": 413
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mark_trusted_task_thread_func ( GTask * task , gpointer source_object , gpointer task_data , GCancellable * cancellable ) {\n MarkTrustedJob * job = task_data ;\n CommonJob * common ;\n common = ( CommonJob * ) job ;\n nautilus_progress_info_start ( job -> common . progress ) ;\n mark_desktop_file_trusted ( common , cancellable , job -> file , job -> interactive ) ;\n }",
        "output": "1",
        "idx": 1662
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void setup_masks_arabic ( const hb_ot_shape_plan_t * plan , hb_buffer_t * buffer , hb_font_t * font HB_UNUSED ) {\n HB_BUFFER_ALLOCATE_VAR ( buffer , arabic_shaping_action ) ;\n const arabic_shape_plan_t * arabic_plan = ( const arabic_shape_plan_t * ) plan -> data ;\n arabic_joining ( buffer ) ;\n if ( plan -> props . script == HB_SCRIPT_MONGOLIAN ) mongolian_variation_selectors ( buffer ) ;\n unsigned int count = buffer -> len ;\n hb_glyph_info_t * info = buffer -> info ;\n for ( unsigned int i = 0 ;\n i < count ;\n i ++ ) info [ i ] . mask |= arabic_plan -> mask_array [ info [ i ] . arabic_shaping_action ( ) ] ;\n HB_BUFFER_DEALLOCATE_VAR ( buffer , arabic_shaping_action ) ;\n }",
        "output": "1",
        "idx": 3368
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ber_rewind ( BerElement * ber ) {\n ber -> ber_rwptr = NULL ;\n ber -> ber_sos_ptr = NULL ;\n ber -> ber_end = ber -> ber_ptr ;\n ber -> ber_ptr = ber -> ber_buf ;\n # if 0 ber -> ber_tag = LBER_DEFAULT ;\n ber -> ber_usertag = 0 ;\n # endif }",
        "output": "0",
        "idx": 3283
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "VirtIOS390Bus * s390_virtio_bus_init ( ram_addr_t * ram_size ) {\n VirtIOS390Bus * bus ;\n BusState * _bus ;\n DeviceState * dev ;\n dev = qdev_create ( NULL , \"s390-virtio-bridge\" ) ;\n qdev_init_nofail ( dev ) ;\n _bus = qbus_create ( & s390_virtio_bus_info , dev , \"s390-virtio\" ) ;\n bus = DO_UPCAST ( VirtIOS390Bus , bus , _bus ) ;\n bus -> dev_page = * ram_size ;\n bus -> dev_offs = bus -> dev_page ;\n bus -> next_ring = bus -> dev_page + TARGET_PAGE_SIZE ;\n * ram_size += S390_DEVICE_PAGES * TARGET_PAGE_SIZE ;\n return bus ;\n }",
        "output": "0",
        "idx": 1109
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( ProfileBrowserTest , URLFetcherUsingMainContextDuringShutdown ) {\n StartActiveFetcherDuringProfileShutdownTest ( browser ( ) -> profile ( ) -> GetRequestContext ( ) ) ;\n }",
        "output": "1",
        "idx": 3508
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int qemuMonitorJSONGetBlockJobInfo ( virJSONValuePtr reply , const char * device , virDomainBlockJobInfoPtr info ) {\n virJSONValuePtr data ;\n int nr_results , i ;\n if ( ! info ) return - 1 ;\n if ( ( data = virJSONValueObjectGet ( reply , \"return\" ) ) == NULL ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"reply was missing return data\" ) ) ;\n return - 1 ;\n }\n if ( data -> type != VIR_JSON_TYPE_ARRAY ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"urecognized format of block job information\" ) ) ;\n return - 1 ;\n }\n if ( ( nr_results = virJSONValueArraySize ( data ) ) < 0 ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"unable to determine array size\" ) ) ;\n return - 1 ;\n }\n for ( i = 0 ;\n i < nr_results ;\n i ++ ) {\n virJSONValuePtr entry = virJSONValueArrayGet ( data , i ) ;\n if ( ! entry ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"missing array element\" ) ) ;\n return - 1 ;\n }\n if ( qemuMonitorJSONGetBlockJobInfoOne ( entry , device , info ) == 0 ) return 1 ;\n }\n return 0 ;\n }",
        "output": "0",
        "idx": 1106
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( ExternalProtocolDialogBrowserTest , TestAcceptWithChecked ) {\n ShowDialog ( ) ;\n SetChecked ( true ) ;\n EXPECT_TRUE ( dialog_ -> Accept ( ) ) ;\n EXPECT_TRUE ( called_ ) ;\n EXPECT_TRUE ( accept_ ) ;\n EXPECT_FALSE ( cancel_ ) ;\n EXPECT_TRUE ( dont_block_ ) ;\n histogram_tester_ . ExpectBucketCount ( ExternalProtocolHandler : : kRememberCheckboxMetric , 1 , 1 ) ;\n histogram_tester_ . ExpectBucketCount ( ExternalProtocolHandler : : kHandleStateMetric , ExternalProtocolHandler : : CHECKED_LAUNCH , 1 ) ;\n }",
        "output": "1",
        "idx": 4277
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void decrypt ( MPI output , MPI a , MPI b , ELG_secret_key * skey ) {\n MPI t1 = mpi_alloc_secure ( mpi_get_nlimbs ( skey -> p ) ) ;\n mpi_normalize ( a ) ;\n mpi_normalize ( b ) ;\n mpi_powm ( t1 , a , skey -> x , skey -> p ) ;\n mpi_invm ( t1 , t1 , skey -> p ) ;\n mpi_mulm ( output , b , t1 , skey -> p ) ;\n # if 0 if ( DBG_CIPHER ) {\n log_mpidump ( \"elg decrypted x= \" , skey -> x ) ;\n log_mpidump ( \"elg decrypted p= \" , skey -> p ) ;\n log_mpidump ( \"elg decrypted a= \" , a ) ;\n log_mpidump ( \"elg decrypted b= \" , b ) ;\n log_mpidump ( \"elg decrypted M= \" , output ) ;\n }\n # endif mpi_free ( t1 ) ;\n }",
        "output": "1",
        "idx": 3300
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void finish_object ( struct object * obj , const struct name_path * path , const char * name , void * cb_data ) {\n struct rev_list_info * info = cb_data ;\n if ( obj -> type == OBJ_BLOB && ! has_object_file ( & obj -> oid ) ) die ( \"missing blob object '%s'\" , oid_to_hex ( & obj -> oid ) ) ;\n if ( info -> revs -> verify_objects && ! obj -> parsed && obj -> type != OBJ_COMMIT ) parse_object ( obj -> oid . hash ) ;\n }",
        "output": "1",
        "idx": 1782
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nlm_print_msgres_request ( packet_info * pinfo , proto_tree * tree , tvbuff_t * tvb ) {\n nlm_msg_res_matched_data * md ;\n md = ( nlm_msg_res_matched_data * ) g_hash_table_lookup ( nlm_msg_res_matched , GINT_TO_POINTER ( pinfo -> fd -> num ) ) ;\n if ( md ) {\n proto_tree_add_uint ( tree , hf_nlm_reply_in , tvb , 0 , 0 , md -> rep_frame ) ;\n }\n }",
        "output": "0",
        "idx": 3724
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void do_imdct ( AC3DecodeContext * s , int channels ) {\n int ch ;\n for ( ch = 1 ;\n ch <= channels ;\n ch ++ ) {\n if ( s -> block_switch [ ch ] ) {\n int i ;\n float * x = s -> tmp_output + 128 ;\n for ( i = 0 ;\n i < 128 ;\n i ++ ) x [ i ] = s -> transform_coeffs [ ch ] [ 2 * i ] ;\n s -> imdct_256 . imdct_half ( & s -> imdct_256 , s -> tmp_output , x ) ;\n s -> fdsp . vector_fmul_window ( s -> outptr [ ch - 1 ] , s -> delay [ ch - 1 ] , s -> tmp_output , s -> window , 128 ) ;\n for ( i = 0 ;\n i < 128 ;\n i ++ ) x [ i ] = s -> transform_coeffs [ ch ] [ 2 * i + 1 ] ;\n s -> imdct_256 . imdct_half ( & s -> imdct_256 , s -> delay [ ch - 1 ] , x ) ;\n }\n else {\n s -> imdct_512 . imdct_half ( & s -> imdct_512 , s -> tmp_output , s -> transform_coeffs [ ch ] ) ;\n s -> fdsp . vector_fmul_window ( s -> outptr [ ch - 1 ] , s -> delay [ ch - 1 ] , s -> tmp_output , s -> window , 128 ) ;\n memcpy ( s -> delay [ ch - 1 ] , s -> tmp_output + 128 , 128 * sizeof ( float ) ) ;\n }\n }\n }",
        "output": "0",
        "idx": 156
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t u_printf_simple_percent_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n static const UChar PERCENT [ ] = {\n UP_PERCENT }\n ;\n return handler -> write ( context , PERCENT , 1 ) ;\n }",
        "output": "1",
        "idx": 1510
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cbracket ( struct vars * v , struct state * lp , struct state * rp ) {\n struct state * left = newstate ( v -> nfa ) ;\n struct state * right = newstate ( v -> nfa ) ;\n NOERR ( ) ;\n bracket ( v , left , right ) ;\n if ( v -> cflags & REG_NLSTOP ) newarc ( v -> nfa , PLAIN , v -> nlcolor , left , right ) ;\n NOERR ( ) ;\n assert ( lp -> nouts == 0 ) ;\n colorcomplement ( v -> nfa , v -> cm , PLAIN , left , lp , rp ) ;\n NOERR ( ) ;\n dropstate ( v -> nfa , left ) ;\n assert ( right -> nins == 0 ) ;\n freestate ( v -> nfa , right ) ;\n }",
        "output": "0",
        "idx": 3964
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vpx_codec_err_t vpx_svc_set_scale_factors ( SvcContext * svc_ctx , const char * scale_factors ) {\n SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n if ( svc_ctx == NULL || scale_factors == NULL || si == NULL ) {\n return VPX_CODEC_INVALID_PARAM ;\n }\n strncpy ( si -> scale_factors , scale_factors , sizeof ( si -> scale_factors ) ) ;\n si -> scale_factors [ sizeof ( si -> scale_factors ) - 1 ] = '\\0' ;\n return VPX_CODEC_OK ;\n }",
        "output": "1",
        "idx": 2491
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static byte * i_alloc_byte_array_immovable ( gs_memory_t * mem , uint num_elements , uint elt_size , client_name_t cname ) {\n gs_ref_memory_t * const imem = ( gs_ref_memory_t * ) mem ;\n obj_header_t * obj ;\n # ifdef MEMENTO if ( Memento_failThisEvent ( ) ) return NULL ;\n # endif obj = alloc_obj ( imem , ( ulong ) num_elements * elt_size , & st_bytes , ALLOC_IMMOVABLE | ALLOC_DIRECT , cname ) ;\n if_debug6m ( 'A' , mem , \"[a%d|+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\\n\" , alloc_trace_space ( imem ) , client_name_string ( cname ) , ( ulong ) num_elements * elt_size , num_elements , elt_size , ( ulong ) obj ) ;\n return ( byte * ) obj ;\n }",
        "output": "1",
        "idx": 1346
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool fpop_ip_dp_needed ( void * opaque ) {\n X86CPU * cpu = opaque ;\n CPUX86State * env = & cpu -> env ;\n return env -> fpop != 0 || env -> fpip != 0 || env -> fpdp != 0 ;\n }",
        "output": "0",
        "idx": 1098
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void initial_reordering_syllable ( const hb_ot_shape_plan_t * plan , hb_face_t * face , hb_buffer_t * buffer , unsigned int start , unsigned int end ) {\n syllable_type_t syllable_type = ( syllable_type_t ) ( buffer -> info [ start ] . syllable ( ) & 0x0F ) ;\n switch ( syllable_type ) {\n case consonant_syllable : initial_reordering_consonant_syllable ( plan , face , buffer , start , end ) ;\n return ;\n case punctuation_cluster : initial_reordering_punctuation_cluster ( plan , face , buffer , start , end ) ;\n return ;\n case broken_cluster : initial_reordering_broken_cluster ( plan , face , buffer , start , end ) ;\n return ;\n case non_myanmar_cluster : initial_reordering_non_myanmar_cluster ( plan , face , buffer , start , end ) ;\n return ;\n }\n }",
        "output": "1",
        "idx": 2958
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( MultiBufferTest , ReadAllAdvanceFirst ) {\n multibuffer_ . SetMaxWriters ( 1 ) ;\n size_t pos = 0 ;\n size_t end = 10000 ;\n multibuffer_ . SetFileSize ( 10000 ) ;\n multibuffer_ . SetMustReadWholeFile ( true ) ;\n media : : MultiBufferReader reader ( & multibuffer_ , pos , end , base : : Callback < void ( int64_t , int64_t ) > ( ) ) ;\n reader . SetMaxBuffer ( 2000 , 5000 ) ;\n reader . SetPreload ( 1000 , 1000 ) ;\n while ( pos < end ) {\n unsigned char buffer [ 27 ] ;\n buffer [ 17 ] = 17 ;\n size_t to_read = std : : min < size_t > ( end - pos , 17 ) ;\n while ( AdvanceAll ( ) ) ;\n int64_t bytes = reader . TryRead ( buffer , to_read ) ;\n EXPECT_GT ( bytes , 0 ) ;\n EXPECT_EQ ( buffer [ 17 ] , 17 ) ;\n for ( int64_t i = 0 ;\n i < bytes ;\n i ++ ) {\n uint8_t expected = static_cast < uint8_t > ( ( pos * 15485863 ) >> 16 ) ;\n EXPECT_EQ ( expected , buffer [ i ] ) << \" pos = \" << pos ;\n pos ++ ;\n }\n }\n }",
        "output": "1",
        "idx": 2834
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gboolean proto_tracking_interesting_fields ( const proto_tree * tree ) {\n GHashTable * interesting_hfids ;\n if ( ! tree ) return FALSE ;\n interesting_hfids = PTREE_DATA ( tree ) -> interesting_hfids ;\n return ( interesting_hfids != NULL ) && g_hash_table_size ( interesting_hfids ) ;\n }",
        "output": "0",
        "idx": 35
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static hb_glyph_info_t * glyph_info_reference ( hb_glyph_info_t * g ) {\n hb_glyph_info_t * c = ( hb_glyph_info_t * ) calloc ( 1 , sizeof ( hb_glyph_info_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }",
        "output": "1",
        "idx": 1631
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void init_bit_trees ( ) {\n init_bit_tree ( cat1 , 1 ) ;\n init_bit_tree ( cat2 , 2 ) ;\n init_bit_tree ( cat3 , 3 ) ;\n init_bit_tree ( cat4 , 4 ) ;\n init_bit_tree ( cat5 , 5 ) ;\n init_bit_tree ( cat6 , 14 ) ;\n }",
        "output": "1",
        "idx": 2841
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "METHOD ( x509_t , create_crl_uri_enumerator , enumerator_t * , private_x509_cert_t * this ) {\n return this -> crl_uris -> create_enumerator ( this -> crl_uris ) ;\n }",
        "output": "0",
        "idx": 1703
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void upsample_5_4 ( float * out , const float * in , int o_size ) {\n const float * in0 = in - UPS_FIR_SIZE + 1 ;\n int i , j , k ;\n int int_part = 0 , frac_part ;\n i = 0 ;\n for ( j = 0 ;\n j < o_size / 5 ;\n j ++ ) {\n out [ i ] = in [ int_part ] ;\n frac_part = 4 ;\n i ++ ;\n for ( k = 1 ;\n k < 5 ;\n k ++ ) {\n out [ i ] = avpriv_scalarproduct_float_c ( in0 + int_part , upsample_fir [ 4 - frac_part ] , UPS_MEM_SIZE ) ;\n int_part ++ ;\n frac_part -- ;\n i ++ ;\n }\n }\n }",
        "output": "0",
        "idx": 1545
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void directory_load_state_free ( DirectoryLoadState * state ) {\n if ( state -> enumerator ) {\n if ( ! g_file_enumerator_is_closed ( state -> enumerator ) ) {\n g_file_enumerator_close_async ( state -> enumerator , 0 , NULL , NULL , NULL ) ;\n }\n g_object_unref ( state -> enumerator ) ;\n }\n if ( state -> load_mime_list_hash != NULL ) {\n istr_set_destroy ( state -> load_mime_list_hash ) ;\n }\n nautilus_file_unref ( state -> load_directory_file ) ;\n g_object_unref ( state -> cancellable ) ;\n g_free ( state ) ;\n }",
        "output": "0",
        "idx": 1679
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void free_static_shapers ( void ) {\n if ( unlikely ( static_shapers != all_shapers ) ) free ( ( void * ) static_shapers ) ;\n }",
        "output": "1",
        "idx": 2047
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE ossl_cipher_update ( int argc , VALUE * argv , VALUE self ) {\n EVP_CIPHER_CTX * ctx ;\n unsigned char * in ;\n long in_len , out_len ;\n VALUE data , str ;\n rb_scan_args ( argc , argv , \"11\" , & data , & str ) ;\n StringValue ( data ) ;\n in = ( unsigned char * ) RSTRING_PTR ( data ) ;\n if ( ( in_len = RSTRING_LEN ( data ) ) == 0 ) ossl_raise ( rb_eArgError , \"data must not be empty\" ) ;\n GetCipher ( self , ctx ) ;\n out_len = in_len + EVP_CIPHER_CTX_block_size ( ctx ) ;\n if ( out_len <= 0 ) {\n ossl_raise ( rb_eRangeError , \"data too big to make output buffer: %ld bytes\" , in_len ) ;\n }\n if ( NIL_P ( str ) ) {\n str = rb_str_new ( 0 , out_len ) ;\n }\n else {\n StringValue ( str ) ;\n rb_str_resize ( str , out_len ) ;\n }\n if ( ! ossl_cipher_update_long ( ctx , ( unsigned char * ) RSTRING_PTR ( str ) , & out_len , in , in_len ) ) ossl_raise ( eCipherError , NULL ) ;\n assert ( out_len < RSTRING_LEN ( str ) ) ;\n rb_str_set_len ( str , out_len ) ;\n return str ;\n }",
        "output": "1",
        "idx": 4385
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vp9_compute_rd_mult ( const VP9_COMP * cpi , int qindex ) {\n const int q = vp9_dc_quant ( qindex , 0 ) ;\n int rdmult = 88 * q * q / 24 ;\n if ( cpi -> oxcf . pass == 2 && ( cpi -> common . frame_type != KEY_FRAME ) ) {\n const GF_GROUP * const gf_group = & cpi -> twopass . gf_group ;\n const FRAME_UPDATE_TYPE frame_type = gf_group -> update_type [ gf_group -> index ] ;\n const int boost_index = MIN ( 15 , ( cpi -> rc . gfu_boost / 100 ) ) ;\n rdmult = ( rdmult * rd_frame_type_factor [ frame_type ] ) >> 7 ;\n rdmult += ( ( rdmult * rd_boost_factor [ boost_index ] ) >> 7 ) ;\n }\n return rdmult ;\n }",
        "output": "1",
        "idx": 881
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void existing_file_removed_callback ( GFile * file , GError * error , gpointer callback_data ) {\n DeleteExistingFileData * data = callback_data ;\n CommonJob * job ;\n GFile * source ;\n GFileType file_type ;\n char * primary ;\n char * secondary ;\n char * details = NULL ;\n int response ;\n job = data -> job ;\n source = data -> source ;\n if ( error == NULL ) {\n nautilus_file_changes_queue_file_removed ( file ) ;\n return ;\n }\n if ( job_aborted ( job ) || job -> skip_all_error ) {\n return ;\n }\n primary = f ( _ ( \"Error while copying \u201c%B\u201d.\" ) , source ) ;\n file_type = g_file_query_file_type ( file , G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS , job -> cancellable ) ;\n if ( file_type == G_FILE_TYPE_DIRECTORY ) {\n secondary = f ( _ ( \"Could not remove the already existing folder %F.\" ) , file ) ;\n }\n else {\n secondary = f ( _ ( \"Could not remove the already existing file %F.\" ) , file ) ;\n }\n details = error -> message ;\n response = run_warning ( job , primary , secondary , details , TRUE , CANCEL , SKIP_ALL , SKIP , NULL ) ;\n if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) {\n abort_job ( job ) ;\n }\n else if ( response == 1 ) {\n job -> skip_all_error = TRUE ;\n }\n }",
        "output": "0",
        "idx": 1265
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int qio_channel_websock_close ( QIOChannel * ioc , Error * * errp ) {\n QIOChannelWebsock * wioc = QIO_CHANNEL_WEBSOCK ( ioc ) ;\n trace_qio_channel_websock_close ( ioc ) ;\n return qio_channel_close ( wioc -> master , errp ) ;\n }",
        "output": "0",
        "idx": 2509
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void predict_and_reconstruct_intra_block ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) {\n struct intra_args * const args = ( struct intra_args * ) arg ;\n VP9_COMMON * const cm = args -> cm ;\n MACROBLOCKD * const xd = args -> xd ;\n struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;\n MODE_INFO * const mi = xd -> mi [ 0 ] ;\n const PREDICTION_MODE mode = ( plane == 0 ) ? get_y_mode ( mi , block ) : mi -> mbmi . uv_mode ;\n int x , y ;\n uint8_t * dst ;\n txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & x , & y ) ;\n dst = & pd -> dst . buf [ 4 * y * pd -> dst . stride + 4 * x ] ;\n vp9_predict_intra_block ( xd , block >> ( tx_size << 1 ) , b_width_log2 ( plane_bsize ) , tx_size , mode , dst , pd -> dst . stride , dst , pd -> dst . stride , x , y , plane ) ;\n if ( ! mi -> mbmi . skip ) {\n const int eob = vp9_decode_block_tokens ( cm , xd , plane , block , plane_bsize , x , y , tx_size , args -> r ) ;\n inverse_transform_block ( xd , plane , block , tx_size , dst , pd -> dst . stride , eob ) ;\n }\n }",
        "output": "1",
        "idx": 2510
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void irq_info ( Monitor * mon ) {\n }",
        "output": "0",
        "idx": 1828
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE ossl_asn1_ ## klass ( int argc , VALUE * argv , VALUE self ) \\ {\n return rb_funcall3 ( cASN1 ## klass , rb_intern ( \"new\" ) , argc , argv ) ;\n }\n OSSL_ASN1_IMPL_FACTORY_METHOD ( Boolean ) OSSL_ASN1_IMPL_FACTORY_METHOD ( Integer ) OSSL_ASN1_IMPL_FACTORY_METHOD ( Enumerated ) OSSL_ASN1_IMPL_FACTORY_METHOD ( BitString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( OctetString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( UTF8String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( NumericString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( PrintableString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( T61String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( VideotexString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( IA5String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( GraphicString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( ISO64String ) OSSL_ASN1_IMPL_FACTORY_METHOD ( GeneralString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( UniversalString ) OSSL_ASN1_IMPL_FACTORY_METHOD ( BMPString )",
        "output": "0",
        "idx": 1034
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static CodeBook unpack_codebook ( GetBitContext * gb , unsigned depth , unsigned size ) {\n unsigned i , j ;\n CodeBook cb = {\n 0 }\n ;\n if ( ! can_safely_read ( gb , size * 34 ) ) return cb ;\n if ( size >= INT_MAX / sizeof ( MacroBlock ) ) return cb ;\n cb . blocks = av_malloc ( size ? size * sizeof ( MacroBlock ) : 1 ) ;\n if ( ! cb . blocks ) return cb ;\n cb . depth = depth ;\n cb . size = size ;\n for ( i = 0 ;\n i < size ;\n i ++ ) {\n unsigned mask_bits = get_bits ( gb , 4 ) ;\n unsigned color0 = get_bits ( gb , 15 ) ;\n unsigned color1 = get_bits ( gb , 15 ) ;\n for ( j = 0 ;\n j < 4 ;\n j ++ ) {\n if ( mask_bits & ( 1 << j ) ) cb . blocks [ i ] . pixels [ j ] = color1 ;\n else cb . blocks [ i ] . pixels [ j ] = color0 ;\n }\n }\n return cb ;\n }",
        "output": "0",
        "idx": 2361
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int check_consistent_binlog_pos ( char * binlog_pos_file , char * binlog_pos_offset ) {\n MYSQL_RES * res ;\n MYSQL_ROW row ;\n int found ;\n if ( mysql_query_with_error_report ( mysql , & res , \"SHOW STATUS LIKE 'binlog_snapshot_%'\" ) ) return 0 ;\n found = 0 ;\n while ( ( row = mysql_fetch_row ( res ) ) ) {\n if ( 0 == strcmp ( row [ 0 ] , \"Binlog_snapshot_file\" ) ) {\n if ( binlog_pos_file ) strmake ( binlog_pos_file , row [ 1 ] , FN_REFLEN - 1 ) ;\n found ++ ;\n }\n else if ( 0 == strcmp ( row [ 0 ] , \"Binlog_snapshot_position\" ) ) {\n if ( binlog_pos_offset ) strmake ( binlog_pos_offset , row [ 1 ] , LONGLONG_LEN ) ;\n found ++ ;\n }\n }\n mysql_free_result ( res ) ;\n return ( found == 2 ) ;\n }",
        "output": "0",
        "idx": 3636
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static AVStream * get_subtitle_pkt ( AVFormatContext * s , AVStream * next_st , AVPacket * pkt ) {\n AVIStream * ast , * next_ast = next_st -> priv_data ;\n int64_t ts , next_ts , ts_min = INT64_MAX ;\n AVStream * st , * sub_st = NULL ;\n int i ;\n next_ts = av_rescale_q ( next_ast -> frame_offset , next_st -> time_base , AV_TIME_BASE_Q ) ;\n for ( i = 0 ;\n i < s -> nb_streams ;\n i ++ ) {\n st = s -> streams [ i ] ;\n ast = st -> priv_data ;\n if ( st -> discard < AVDISCARD_ALL && ast && ast -> sub_pkt . data ) {\n ts = av_rescale_q ( ast -> sub_pkt . dts , st -> time_base , AV_TIME_BASE_Q ) ;\n if ( ts <= next_ts && ts < ts_min ) {\n ts_min = ts ;\n sub_st = st ;\n }\n }\n }\n if ( sub_st ) {\n ast = sub_st -> priv_data ;\n * pkt = ast -> sub_pkt ;\n pkt -> stream_index = sub_st -> index ;\n if ( ff_read_packet ( ast -> sub_ctx , & ast -> sub_pkt ) < 0 ) ast -> sub_pkt . data = NULL ;\n }\n return sub_st ;\n }",
        "output": "0",
        "idx": 3176
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void pic_info ( Monitor * mon ) {\n }",
        "output": "0",
        "idx": 2442
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool pv_eoi_msr_needed ( void * opaque ) {\n X86CPU * cpu = opaque ;\n return cpu -> env . pv_eoi_en_msr != 0 ;\n }",
        "output": "0",
        "idx": 2310
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int TS_OBJ_print_bio ( BIO * bio , const ASN1_OBJECT * obj ) {\n char obj_txt [ 128 ] ;\n OBJ_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ;\n BIO_printf ( bio , \"%s\\n\" , obj_txt ) ;\n return 1 ;\n }",
        "output": "0",
        "idx": 2430
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_INTEGER_M262144_262143 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , - 262144 , 262143U , NULL , FALSE ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 3340
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PyObject * string_decode ( PyStringObject * self , PyObject * args , PyObject * kwargs ) {\n static char * kwlist [ ] = {\n \"encoding\" , \"errors\" , 0 }\n ;\n char * encoding = NULL ;\n char * errors = NULL ;\n PyObject * v ;\n if ( ! PyArg_ParseTupleAndKeywords ( args , kwargs , \"|ss:decode\" , kwlist , & encoding , & errors ) ) return NULL ;\n v = PyString_AsDecodedObject ( ( PyObject * ) self , encoding , errors ) ;\n if ( v == NULL ) goto onError ;\n if ( ! PyString_Check ( v ) && ! PyUnicode_Check ( v ) ) {\n PyErr_Format ( PyExc_TypeError , \"decoder did not return a string/unicode object \" \"(type=%.400s)\" , Py_TYPE ( v ) -> tp_name ) ;\n Py_DECREF ( v ) ;\n return NULL ;\n }\n return v ;\n onError : return NULL ;\n }",
        "output": "0",
        "idx": 336
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void idcin_decode_vlcs ( IdcinContext * s ) {\n hnode * hnodes ;\n long x , y ;\n int prev ;\n unsigned char v = 0 ;\n int bit_pos , node_num , dat_pos ;\n prev = bit_pos = dat_pos = 0 ;\n for ( y = 0 ;\n y < ( s -> frame . linesize [ 0 ] * s -> avctx -> height ) ;\n y += s -> frame . linesize [ 0 ] ) {\n for ( x = y ;\n x < y + s -> avctx -> width ;\n x ++ ) {\n node_num = s -> num_huff_nodes [ prev ] ;\n hnodes = s -> huff_nodes [ prev ] ;\n while ( node_num >= HUF_TOKENS ) {\n if ( ! bit_pos ) {\n if ( dat_pos >= s -> size ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Huffman decode error.\\n\" ) ;\n return ;\n }\n bit_pos = 8 ;\n v = s -> buf [ dat_pos ++ ] ;\n }\n node_num = hnodes [ node_num ] . children [ v & 0x01 ] ;\n v = v >> 1 ;\n bit_pos -- ;\n }\n s -> frame . data [ 0 ] [ x ] = node_num ;\n prev = node_num ;\n }\n }\n }",
        "output": "1",
        "idx": 4376
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( SafeJsonParserImplTest , Isolation ) {\n for ( int i = 0 ;\n i < 5 ;\n i ++ ) {\n base : : RunLoop run_loop ;\n ParseCallback parse_callback ( run_loop . QuitClosure ( ) ) ;\n SafeJsonParser : : Parse ( connector ( ) , \"[\\\"awesome\\\", \\\"possum\\\"]\" , base : : Bind ( & ParseCallback : : OnSuccess , base : : Unretained ( & parse_callback ) ) , base : : Bind ( & ParseCallback : : OnError , base : : Unretained ( & parse_callback ) ) ) ;\n run_loop . Run ( ) ;\n EXPECT_TRUE ( parse_callback . success ( ) ) ;\n EXPECT_EQ ( 2U + i , GetServiceStartCount ( data_decoder : : mojom : : kServiceName ) ) ;\n }\n }",
        "output": "1",
        "idx": 2525
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _pack_alloc_list_del ( void * x ) {\n resource_allocation_response_msg_t * job_info_resp_msg ;\n job_info_resp_msg = ( resource_allocation_response_msg_t * ) x ;\n job_info_resp_msg -> working_cluster_rec = NULL ;\n slurm_free_resource_allocation_response_msg_members ( job_info_resp_msg ) ;\n xfree ( job_info_resp_msg ) ;\n }",
        "output": "0",
        "idx": 3341
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_ping_group_range ( struct ctl_table * table , gid_t range [ 2 ] ) {\n gid_t * data = table -> data ;\n write_seqlock ( & sysctl_local_ports . lock ) ;\n data [ 0 ] = range [ 0 ] ;\n data [ 1 ] = range [ 1 ] ;\n write_sequnlock ( & sysctl_local_ports . lock ) ;\n }",
        "output": "0",
        "idx": 869
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int selinux_shm_associate ( struct shmid_kernel * shp , int shmflg ) {\n struct ipc_security_struct * isec ;\n struct common_audit_data ad ;\n u32 sid = current_sid ( ) ;\n isec = shp -> shm_perm . security ;\n ad . type = LSM_AUDIT_DATA_IPC ;\n ad . u . ipc_id = shp -> shm_perm . key ;\n return avc_has_perm ( sid , isec -> sid , SECCLASS_SHM , SHM__ASSOCIATE , & ad ) ;\n }",
        "output": "0",
        "idx": 1449
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( WebFrameTest , ContextMenuDataSelectAll ) {\n EXPECT_FALSE ( TestSelectAll ( \"<textarea></textarea>\" ) ) ;\n EXPECT_TRUE ( TestSelectAll ( \"<textarea>nonempty</textarea>\" ) ) ;\n EXPECT_FALSE ( TestSelectAll ( \"<input>\" ) ) ;\n EXPECT_TRUE ( TestSelectAll ( \"<input value='nonempty'>\" ) ) ;\n EXPECT_FALSE ( TestSelectAll ( \"<div contenteditable></div>\" ) ) ;\n EXPECT_TRUE ( TestSelectAll ( \"<div contenteditable>nonempty</div>\" ) ) ;\n EXPECT_TRUE ( TestSelectAll ( \"<div contenteditable>\\n</div>\" ) ) ;\n }",
        "output": "0",
        "idx": 696
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_release_unused_pictures ( MpegEncContext * s , int remove_current ) {\n int i ;\n for ( i = 0 ;\n i < s -> picture_count ;\n i ++ ) {\n if ( s -> picture [ i ] . f . data [ 0 ] && ! s -> picture [ i ] . f . reference && ( ! s -> picture [ i ] . owner2 || s -> picture [ i ] . owner2 == s ) && ( remove_current || & s -> picture [ i ] != s -> current_picture_ptr ) ) {\n free_frame_buffer ( s , & s -> picture [ i ] ) ;\n }\n }\n }",
        "output": "1",
        "idx": 171
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main ( int argc , char * * argv ) {\n using std : : string ;\n if ( argc != 2 ) {\n fprintf ( stderr , \"One argument, the input filename, must be provided.\\n\" ) ;\n return 1 ;\n }\n string filename ( argv [ 1 ] ) ;\n string outfilename = filename . substr ( 0 , filename . find_last_of ( \".\" ) ) + \".woff2\" ;\n fprintf ( stdout , \"Processing %s => %s\\n\" , filename . c_str ( ) , outfilename . c_str ( ) ) ;\n string input = woff2 : : GetFileContent ( filename ) ;\n const uint8_t * input_data = reinterpret_cast < const uint8_t * > ( input . data ( ) ) ;\n size_t output_size = woff2 : : MaxWOFF2CompressedSize ( input_data , input . size ( ) ) ;\n string output ( output_size , 0 ) ;\n uint8_t * output_data = reinterpret_cast < uint8_t * > ( & output [ 0 ] ) ;\n if ( ! woff2 : : ConvertTTFToWOFF2 ( input_data , input . size ( ) , output_data , & output_size ) ) {\n fprintf ( stderr , \"Compression failed.\\n\" ) ;\n return 1 ;\n }\n output . resize ( output_size ) ;\n woff2 : : SetFileContents ( outfilename , output ) ;\n return 0 ;\n }",
        "output": "1",
        "idx": 698
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void unlink_thd ( THD * thd ) {\n DBUG_ENTER ( \"unlink_thd\" ) ;\n DBUG_PRINT ( \"enter\" , ( \"thd: 0x%lx\" , ( long ) thd ) ) ;\n thd_cleanup ( thd ) ;\n dec_connection_count ( thd ) ;\n thd -> add_status_to_global ( ) ;\n mysql_mutex_lock ( & LOCK_thread_count ) ;\n thd -> unlink ( ) ;\n DBUG_EXECUTE_IF ( \"sleep_after_lock_thread_count_before_delete_thd\" , sleep ( 5 ) ;\n ) ;\n if ( unlikely ( abort_loop ) ) {\n delete thd ;\n thd = 0 ;\n }\n thread_count -- ;\n mysql_mutex_unlock ( & LOCK_thread_count ) ;\n delete thd ;\n DBUG_VOID_RETURN ;\n }",
        "output": "0",
        "idx": 1251
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_H245Control_item ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 368 \"./asn1/h225/h225.cnf\" tvbuff_t * h245_tvb = NULL ;\n offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , NO_BOUND , NO_BOUND , FALSE , & h245_tvb ) ;\n next_tvb_add_handle ( & h245_list , h245_tvb , ( h225_h245_in_tree ) ? tree : NULL , h245dg_handle ) ;\n return offset ;\n }",
        "output": "1",
        "idx": 4454
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_signal_assert ( void ) {\n struct event ev ;\n struct event_base * base = event_init ( ) ;\n test_ok = 0 ;\n printf ( \"Signal handler assert: \" ) ;\n signal_set ( & ev , SIGCONT , signal_cb , & ev ) ;\n signal_add ( & ev , NULL ) ;\n signal_del ( & ev ) ;\n raise ( SIGCONT ) ;\n if ( base -> sig . evsignal_caught ) test_ok = 0 ;\n else test_ok = 1 ;\n event_base_free ( base ) ;\n cleanup_test ( ) ;\n return ;\n }",
        "output": "0",
        "idx": 3017
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( WebUsbDetectorTest , UsbDeviceAddedAndRemoved ) {\n base : : string16 product_name = base : : UTF8ToUTF16 ( kProductName_1 ) ;\n GURL landing_page ( kLandingPage_1 ) ;\n scoped_refptr < device : : MockUsbDevice > device ( new device : : MockUsbDevice ( 0 , 1 , \"Google\" , kProductName_1 , \"002\" , landing_page ) ) ;\n std : : string guid = device -> guid ( ) ;\n Initialize ( ) ;\n device_client_ . usb_service ( ) -> AddDevice ( device ) ;\n message_center : : Notification * notification = message_center_ -> FindVisibleNotificationById ( guid ) ;\n ASSERT_TRUE ( notification != nullptr ) ;\n base : : string16 expected_title = base : : ASCIIToUTF16 ( \"Google Product A detected\" ) ;\n EXPECT_EQ ( expected_title , notification -> title ( ) ) ;\n base : : string16 expected_message = base : : ASCIIToUTF16 ( \"Go to www.google.com to connect.\" ) ;\n EXPECT_EQ ( expected_message , notification -> message ( ) ) ;\n EXPECT_TRUE ( notification -> delegate ( ) != nullptr ) ;\n device_client_ . usb_service ( ) -> RemoveDevice ( device ) ;\n EXPECT_TRUE ( message_center_ -> FindVisibleNotificationById ( guid ) == nullptr ) ;\n }",
        "output": "0",
        "idx": 3322
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TSReturnCode TSMimeHdrFieldValueDelete ( TSMBuffer bufp , TSMLoc hdr , TSMLoc field , int idx ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( ( sdk_sanity_check_mime_hdr_handle ( hdr ) == TS_SUCCESS ) || ( sdk_sanity_check_http_hdr_handle ( hdr ) == TS_SUCCESS ) ) ;\n sdk_assert ( sdk_sanity_check_field_handle ( field , hdr ) == TS_SUCCESS ) ;\n sdk_assert ( idx >= 0 ) ;\n if ( ! isWriteable ( bufp ) ) {\n return TS_ERROR ;\n }\n MIMEFieldSDKHandle * handle = ( MIMEFieldSDKHandle * ) field ;\n HdrHeap * heap = ( ( HdrHeapSDKHandle * ) bufp ) -> m_heap ;\n mime_field_value_delete_comma_val ( heap , handle -> mh , handle -> field_ptr , idx ) ;\n return TS_SUCCESS ;\n }",
        "output": "0",
        "idx": 1059
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vapic_prepare ( VAPICROMState * s ) {\n vapic_map_rom_writable ( s ) ;\n if ( patch_hypercalls ( s ) < 0 ) {\n return - 1 ;\n }\n vapic_enable_tpr_reporting ( true ) ;\n return 0 ;\n }",
        "output": "0",
        "idx": 2001
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int strToMatch ( const char * str , char * retstr ) {\n char * anchor = NULL ;\n const char * anchor1 = NULL ;\n int result = 0 ;\n if ( ( ! str ) || str [ 0 ] == '\\0' ) {\n return result ;\n }\n else {\n anchor = retstr ;\n anchor1 = str ;\n while ( ( * str ) != '\\0' ) {\n if ( * str == '-' ) {\n * retstr = '_' ;\n }\n else {\n * retstr = tolower ( * str ) ;\n }\n str ++ ;\n retstr ++ ;\n }\n * retstr = '\\0' ;\n retstr = anchor ;\n str = anchor1 ;\n result = 1 ;\n }\n return ( result ) ;\n }",
        "output": "0",
        "idx": 4265
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void evdns_set_log_fn ( evdns_debug_log_fn_type fn ) {\n evdns_log_fn = fn ;\n }",
        "output": "0",
        "idx": 624
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * ext_t_0_wml_10 ( tvbuff_t * tvb , guint32 value , guint32 str_tbl ) {\n char * str = wmem_strdup_printf ( wmem_packet_scope ( ) , \"Variable substitution - escaped: '%s'\" , tvb_get_const_stringz ( tvb , str_tbl + value , NULL ) ) ;\n return str ;\n }",
        "output": "0",
        "idx": 3093
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void handle_raw_ping ( struct query * q , int dns_fd , int userid ) {\n if ( check_user_and_ip ( userid , q ) != 0 ) {\n return ;\n }\n users [ userid ] . last_pkt = time ( NULL ) ;\n memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n if ( debug >= 1 ) {\n fprintf ( stderr , \"IN ping raw, from user %d\\n\" , userid ) ;\n }\n send_raw ( dns_fd , NULL , 0 , userid , RAW_HDR_CMD_PING , q ) ;\n }",
        "output": "1",
        "idx": 4037
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vmmouse_get_data ( uint32_t * data ) {\n CPUX86State * env = cpu_single_env ;\n data [ 0 ] = env -> regs [ R_EAX ] ;\n data [ 1 ] = env -> regs [ R_EBX ] ;\n data [ 2 ] = env -> regs [ R_ECX ] ;\n data [ 3 ] = env -> regs [ R_EDX ] ;\n data [ 4 ] = env -> regs [ R_ESI ] ;\n data [ 5 ] = env -> regs [ R_EDI ] ;\n }",
        "output": "1",
        "idx": 2016
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void proto_tree_set_system_id ( field_info * fi , const guint8 * value_ptr , gint length ) {\n GByteArray * bytes ;\n DISSECTOR_ASSERT ( value_ptr != NULL || length == 0 ) ;\n bytes = g_byte_array_new ( ) ;\n if ( length > 0 ) {\n g_byte_array_append ( bytes , value_ptr , length ) ;\n }\n fvalue_set_byte_array ( & fi -> value , bytes ) ;\n }",
        "output": "0",
        "idx": 1168
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _ISCIIReset ( UConverter * cnv , UConverterResetChoice choice ) {\n UConverterDataISCII * data = ( UConverterDataISCII * ) ( cnv -> extraInfo ) ;\n if ( choice <= UCNV_RESET_TO_UNICODE ) {\n cnv -> toUnicodeStatus = missingCharMarker ;\n cnv -> mode = 0 ;\n data -> currentDeltaToUnicode = data -> defDeltaToUnicode ;\n data -> currentMaskToUnicode = data -> defMaskToUnicode ;\n data -> contextCharToUnicode = NO_CHAR_MARKER ;\n data -> prevToUnicodeStatus = 0x0000 ;\n }\n if ( choice != UCNV_RESET_TO_UNICODE ) {\n cnv -> fromUChar32 = 0x0000 ;\n data -> contextCharFromUnicode = 0x00 ;\n data -> currentMaskFromUnicode = data -> defMaskToUnicode ;\n data -> currentDeltaFromUnicode = data -> defDeltaToUnicode ;\n data -> isFirstBuffer = TRUE ;\n data -> resetToDefaultToUnicode = FALSE ;\n }\n }",
        "output": "1",
        "idx": 2024
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void SetPixelIndex ( const Image * restrict image , const Quantum index , Quantum * restrict pixel ) {\n if ( image -> channel_map [ IndexPixelChannel ] . traits != UndefinedPixelTrait ) pixel [ image -> channel_map [ IndexPixelChannel ] . offset ] = index ;\n }",
        "output": "0",
        "idx": 1515
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void initATTables ( struct alltabs * at , SplineFont * sf , enum fontformat format ) {\n setos2 ( & at -> os2 , at , sf , format ) ;\n if ( at -> opentypemode ) {\n SFFindUnusedLookups ( sf ) ;\n otf_dumpgpos ( at , sf ) ;\n otf_dumpgsub ( at , sf ) ;\n otf_dumpgdef ( at , sf ) ;\n otf_dumpjstf ( at , sf ) ;\n otf_dumpbase ( at , sf ) ;\n otf_dump_math ( at , sf ) ;\n if ( at -> gi . flags & ttf_flag_dummyDSIG ) otf_dump_dummydsig ( at , sf ) ;\n }\n if ( at -> dovariations ) ttf_dumpvariations ( at , sf ) ;\n if ( at -> applemode ) {\n if ( ! at -> opentypemode ) SFFindUnusedLookups ( sf ) ;\n ttf_dumpkerns ( at , sf ) ;\n aat_dumplcar ( at , sf ) ;\n aat_dumpmorx ( at , sf ) ;\n aat_dumpopbd ( at , sf ) ;\n aat_dumpprop ( at , sf ) ;\n aat_dumpbsln ( at , sf ) ;\n }\n if ( ! at -> applemode && ( ! at -> opentypemode || ( at -> gi . flags & ttf_flag_oldkern ) ) ) ttf_dumpkerns ( at , sf ) ;\n dumpnames ( at , sf , format ) ;\n redoos2 ( at ) ;\n }",
        "output": "0",
        "idx": 4199
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void draw_char ( AVCodecContext * avctx , int c ) {\n AnsiContext * s = avctx -> priv_data ;\n int fg = s -> fg ;\n int bg = s -> bg ;\n if ( ( s -> attributes & ATTR_BOLD ) ) fg += 8 ;\n if ( ( s -> attributes & ATTR_BLINK ) ) bg += 8 ;\n if ( ( s -> attributes & ATTR_REVERSE ) ) FFSWAP ( int , fg , bg ) ;\n if ( ( s -> attributes & ATTR_CONCEALED ) ) fg = bg ;\n ff_draw_pc_font ( s -> frame . data [ 0 ] + s -> y * s -> frame . linesize [ 0 ] + s -> x , s -> frame . linesize [ 0 ] , s -> font , s -> font_height , c , fg , bg ) ;\n s -> x += FONT_WIDTH ;\n if ( s -> x >= avctx -> width ) {\n s -> x = 0 ;\n hscroll ( avctx ) ;\n }\n }",
        "output": "1",
        "idx": 3139
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mem_draw_thin_line ( gx_device * dev , fixed fx0 , fixed fy0 , fixed fx1 , fixed fy1 , const gx_drawing_color * pdcolor , gs_logical_operation_t lop , fixed adjustx , fixed adjusty ) {\n return gx_default_draw_thin_line ( dev , fx0 , fy0 , fx1 , fy1 , pdcolor , lop , adjustx , adjusty ) ;\n }",
        "output": "0",
        "idx": 3081
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void decode_transform_coeffs_ch ( AC3DecodeContext * s , int blk , int ch , mant_groups * m ) {\n if ( ! s -> channel_uses_aht [ ch ] ) {\n ac3_decode_transform_coeffs_ch ( s , ch , m ) ;\n }\n else {\n int bin ;\n if ( ! blk && CONFIG_EAC3_DECODER ) ff_eac3_decode_transform_coeffs_aht_ch ( s , ch ) ;\n for ( bin = s -> start_freq [ ch ] ;\n bin < s -> end_freq [ ch ] ;\n bin ++ ) {\n s -> fixed_coeffs [ ch ] [ bin ] = s -> pre_mantissa [ ch ] [ bin ] [ blk ] >> s -> dexps [ ch ] [ bin ] ;\n }\n }\n }",
        "output": "0",
        "idx": 54
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rds_inc_addref ( struct rds_incoming * inc ) {\n rdsdebug ( \"addref inc %p ref %d\\n\" , inc , atomic_read ( & inc -> i_refcount ) ) ;\n atomic_inc ( & inc -> i_refcount ) ;\n }",
        "output": "0",
        "idx": 2649
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int compress_bidder_bid ( struct archive_read_filter_bidder * self , struct archive_read_filter * filter ) {\n const unsigned char * buffer ;\n ssize_t avail ;\n int bits_checked ;\n ( void ) self ;\n buffer = __archive_read_filter_ahead ( filter , 2 , & avail ) ;\n if ( buffer == NULL ) return ( 0 ) ;\n bits_checked = 0 ;\n if ( buffer [ 0 ] != 0x1F || buffer [ 1 ] != 0x9D ) return ( 0 ) ;\n bits_checked += 16 ;\n return ( bits_checked ) ;\n }",
        "output": "1",
        "idx": 1595
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int create_history_entry ( krb5_context context , krb5_keyblock * hist_key , int n_key_data , krb5_key_data * key_data , osa_pw_hist_ent * hist ) {\n krb5_error_code ret ;\n krb5_keyblock key ;\n krb5_keysalt salt ;\n int i ;\n hist -> key_data = k5calloc ( n_key_data , sizeof ( krb5_key_data ) , & ret ) ;\n if ( hist -> key_data == NULL ) return ret ;\n for ( i = 0 ;\n i < n_key_data ;\n i ++ ) {\n ret = krb5_dbe_decrypt_key_data ( context , NULL , & key_data [ i ] , & key , & salt ) ;\n if ( ret ) return ret ;\n ret = krb5_dbe_encrypt_key_data ( context , hist_key , & key , & salt , key_data [ i ] . key_data_kvno , & hist -> key_data [ i ] ) ;\n if ( ret ) return ret ;\n krb5_free_keyblock_contents ( context , & key ) ;\n }\n hist -> n_key_data = n_key_data ;\n return 0 ;\n }",
        "output": "0",
        "idx": 4106
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( BookmarkBubbleSignInDelegateTest , OnSignInLinkClickedIncognito ) {\n ReplaceBlank ( browser ( ) ) ;\n Browser * incognito_browser = CreateIncognitoBrowser ( ) ;\n int starting_tab_count_normal = browser ( ) -> tab_strip_model ( ) -> count ( ) ;\n int starting_tab_count_incognito = incognito_browser -> tab_strip_model ( ) -> count ( ) ;\n scoped_ptr < BookmarkBubbleDelegate > delegate ;\n delegate . reset ( new BookmarkBubbleSignInDelegate ( incognito_browser ) ) ;\n delegate -> OnSignInLinkClicked ( ) ;\n int tab_count_normal = browser ( ) -> tab_strip_model ( ) -> count ( ) ;\n EXPECT_EQ ( starting_tab_count_normal + 1 , tab_count_normal ) ;\n int tab_count_incognito = incognito_browser -> tab_strip_model ( ) -> count ( ) ;\n EXPECT_EQ ( starting_tab_count_incognito , tab_count_incognito ) ;\n }",
        "output": "1",
        "idx": 634
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static fz_iccprofile * get_base_icc_profile ( fz_context * ctx , const fz_colorspace * cs ) {\n fz_colorspace * base ;\n fz_cal_colorspace * cal ;\n fz_iccprofile * cal_icc ;\n if ( ! cs || ! cs -> get_base ) return NULL ;\n base = cs -> get_base ( cs ) ;\n if ( base == NULL ) return NULL ;\n if ( fz_colorspace_is_icc ( ctx , base ) ) return base -> data ;\n if ( ! fz_colorspace_is_cal ( ctx , base ) ) return get_base_icc_profile ( ctx , base ) ;\n cal = base -> data ;\n cal_icc = cal -> profile ;\n if ( cal_icc && cal_icc -> cmm_handle == NULL ) fz_cmm_init_profile ( ctx , cal_icc ) ;\n return cal_icc ;\n }",
        "output": "0",
        "idx": 2387
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void add_frame_default ( AVFrame * f , const uint8_t * src , int src_stride , int linelen , int height ) {\n int i , j ;\n uint8_t * dst = f -> data [ 0 ] ;\n dst += ( height - 1 ) * f -> linesize [ 0 ] ;\n for ( i = height ;\n i ;\n i -- ) {\n for ( j = linelen ;\n j ;\n j -- ) * dst ++ += * src ++ ;\n src += src_stride - linelen ;\n dst -= f -> linesize [ 0 ] + linelen ;\n }\n }",
        "output": "0",
        "idx": 1162
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sb_has_motion ( const VP9_COMMON * cm , MODE_INFO * * prev_mi_8x8 , const int motion_thresh ) {\n const int mis = cm -> mi_stride ;\n int block_row , block_col ;\n if ( cm -> prev_mi ) {\n for ( block_row = 0 ;\n block_row < 8 ;\n ++ block_row ) {\n for ( block_col = 0 ;\n block_col < 8 ;\n ++ block_col ) {\n const MODE_INFO * prev_mi = prev_mi_8x8 [ block_row * mis + block_col ] ;\n if ( prev_mi ) {\n if ( abs ( prev_mi -> mbmi . mv [ 0 ] . as_mv . row ) > motion_thresh || abs ( prev_mi -> mbmi . mv [ 0 ] . as_mv . col ) > motion_thresh ) return 1 ;\n }\n }\n }\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 3067
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void choose_intra_uv_mode ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx , BLOCK_SIZE bsize , TX_SIZE max_tx_size , int * rate_uv , int * rate_uv_tokenonly , int64_t * dist_uv , int * skip_uv , PREDICTION_MODE * mode_uv ) {\n MACROBLOCK * const x = & cpi -> mb ;\n if ( cpi -> sf . use_uv_intra_rd_estimate ) {\n rd_sbuv_dcpred ( cpi , x , rate_uv , rate_uv_tokenonly , dist_uv , skip_uv , bsize < BLOCK_8X8 ? BLOCK_8X8 : bsize ) ;\n }\n else {\n rd_pick_intra_sbuv_mode ( cpi , x , ctx , rate_uv , rate_uv_tokenonly , dist_uv , skip_uv , bsize < BLOCK_8X8 ? BLOCK_8X8 : bsize , max_tx_size ) ;\n }\n * mode_uv = x -> e_mbd . mi [ 0 ] -> mbmi . uv_mode ;\n }",
        "output": "1",
        "idx": 1077
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static UConverter * _SCSUSafeClone ( const UConverter * cnv , void * stackBuffer , int32_t * pBufferSize , UErrorCode * status ) {\n struct cloneSCSUStruct * localClone ;\n int32_t bufferSizeNeeded = sizeof ( struct cloneSCSUStruct ) ;\n if ( U_FAILURE ( * status ) ) {\n return 0 ;\n }\n if ( * pBufferSize == 0 ) {\n * pBufferSize = bufferSizeNeeded ;\n return 0 ;\n }\n localClone = ( struct cloneSCSUStruct * ) stackBuffer ;\n uprv_memcpy ( & localClone -> mydata , cnv -> extraInfo , sizeof ( SCSUData ) ) ;\n localClone -> cnv . extraInfo = & localClone -> mydata ;\n localClone -> cnv . isExtraLocal = TRUE ;\n return & localClone -> cnv ;\n }",
        "output": "1",
        "idx": 3489
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void jpc_enc_destroy ( jpc_enc_t * enc ) {\n if ( enc -> curtile ) {\n jpc_enc_tile_destroy ( enc -> curtile ) ;\n }\n if ( enc -> cp ) {\n jpc_enc_cp_destroy ( enc -> cp ) ;\n }\n if ( enc -> cstate ) {\n jpc_cstate_destroy ( enc -> cstate ) ;\n }\n if ( enc -> tmpstream ) {\n jas_stream_close ( enc -> tmpstream ) ;\n }\n jas_free ( enc ) ;\n }",
        "output": "0",
        "idx": 2831
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void evdns_search_ndots_set ( const int ndots ) {\n if ( ! global_search_state ) global_search_state = search_state_new ( ) ;\n if ( ! global_search_state ) return ;\n global_search_state -> ndots = ndots ;\n }",
        "output": "0",
        "idx": 2380
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void xan_wc3_output_pixel_run ( XanContext * s , const unsigned char * pixel_buffer , int x , int y , int pixel_count ) {\n int stride ;\n int line_inc ;\n int index ;\n int current_x ;\n int width = s -> avctx -> width ;\n unsigned char * palette_plane ;\n palette_plane = s -> current_frame . data [ 0 ] ;\n stride = s -> current_frame . linesize [ 0 ] ;\n line_inc = stride - width ;\n index = y * stride + x ;\n current_x = x ;\n while ( pixel_count && index < s -> frame_size ) {\n int count = FFMIN ( pixel_count , width - current_x ) ;\n memcpy ( palette_plane + index , pixel_buffer , count ) ;\n pixel_count -= count ;\n index += count ;\n pixel_buffer += count ;\n current_x += count ;\n if ( current_x >= width ) {\n index += line_inc ;\n current_x = 0 ;\n }\n }\n }",
        "output": "1",
        "idx": 174
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int get_dwords ( OHCIState * ohci , dma_addr_t addr , uint32_t * buf , int num ) {\n int i ;\n addr += ohci -> localmem_base ;\n for ( i = 0 ;\n i < num ;\n i ++ , buf ++ , addr += sizeof ( * buf ) ) {\n if ( dma_memory_read ( ohci -> as , addr , buf , sizeof ( * buf ) ) ) {\n return - 1 ;\n }\n * buf = le32_to_cpu ( * buf ) ;\n }\n return 0 ;\n }",
        "output": "0",
        "idx": 3943
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const uint8_t * ff_h263_find_resync_marker ( const uint8_t * restrict p , const uint8_t * restrict end ) {\n assert ( p < end ) ;\n end -= 2 ;\n p ++ ;\n for ( ;\n p < end ;\n p += 2 ) {\n if ( ! * p ) {\n if ( ! p [ - 1 ] && p [ 1 ] ) return p - 1 ;\n else if ( ! p [ 1 ] && p [ 2 ] ) return p ;\n }\n }\n return end + 2 ;\n }",
        "output": "0",
        "idx": 4328
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( ContentFaviconDriverTest , LoadIconFromWebManifest ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n GURL url = embedded_test_server ( ) -> GetURL ( \"/favicon/page_with_manifest.html\" ) ;\n GURL icon_url = embedded_test_server ( ) -> GetURL ( \"/favicon/icon.png\" ) ;\n std : : unique_ptr < TestResourceDispatcherHostDelegate > delegate ( new TestResourceDispatcherHostDelegate ( icon_url ) ) ;\n content : : ResourceDispatcherHost : : Get ( ) -> SetDelegate ( delegate . get ( ) ) ;\n PendingTaskWaiter waiter ( web_contents ( ) ) ;\n ui_test_utils : : NavigateToURLWithDisposition ( browser ( ) , url , WindowOpenDisposition : : CURRENT_TAB , ui_test_utils : : BROWSER_TEST_NONE ) ;\n waiter . Wait ( ) ;\n # if defined ( OS_ANDROID ) EXPECT_TRUE ( delegate -> was_requested ( ) ) ;\n EXPECT_NE ( nullptr , GetFaviconForPageURL ( url , favicon_base : : IconType : : kWebManifestIcon ) . bitmap_data ) ;\n # else EXPECT_FALSE ( delegate -> was_requested ( ) ) ;\n # endif }",
        "output": "0",
        "idx": 485
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Py_ssize_t string_buffer_getreadbuf ( PyStringObject * self , Py_ssize_t index , const void * * ptr ) {\n if ( index != 0 ) {\n PyErr_SetString ( PyExc_SystemError , \"accessing non-existent string segment\" ) ;\n return - 1 ;\n }\n * ptr = ( void * ) self -> ob_sval ;\n return Py_SIZE ( self ) ;\n }",
        "output": "0",
        "idx": 3755
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int proc_connectinfo ( struct usb_dev_state * ps , void __user * arg ) {\n struct usbdevfs_connectinfo ci = {\n . devnum = ps -> dev -> devnum , . slow = ps -> dev -> speed == USB_SPEED_LOW }\n ;\n if ( copy_to_user ( arg , & ci , sizeof ( ci ) ) ) return - EFAULT ;\n return 0 ;\n }",
        "output": "1",
        "idx": 173
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void output_check_banner ( bool live_check ) {\n if ( user_opts . check && live_check ) {\n pg_log ( PG_REPORT , \"Performing Consistency Checks on Old Live Server\\n\" ) ;\n pg_log ( PG_REPORT , \"------------------------------------------------\\n\" ) ;\n }\n else {\n pg_log ( PG_REPORT , \"Performing Consistency Checks\\n\" ) ;\n pg_log ( PG_REPORT , \"-----------------------------\\n\" ) ;\n }\n }",
        "output": "0",
        "idx": 1206
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "VP9Decoder * vp9_decoder_create ( ) {\n VP9Decoder * const pbi = vpx_memalign ( 32 , sizeof ( * pbi ) ) ;\n VP9_COMMON * const cm = pbi ? & pbi -> common : NULL ;\n if ( ! cm ) return NULL ;\n vp9_zero ( * pbi ) ;\n if ( setjmp ( cm -> error . jmp ) ) {\n cm -> error . setjmp = 0 ;\n vp9_decoder_remove ( pbi ) ;\n return NULL ;\n }\n cm -> error . setjmp = 1 ;\n initialize_dec ( ) ;\n vpx_memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ;\n cm -> current_video_frame = 0 ;\n pbi -> ready_for_new_data = 1 ;\n cm -> bit_depth = VPX_BITS_8 ;\n vp9_init_dequantizer ( cm ) ;\n vp9_loop_filter_init ( cm ) ;\n cm -> error . setjmp = 0 ;\n vp9_get_worker_interface ( ) -> init ( & pbi -> lf_worker ) ;\n return pbi ;\n }",
        "output": "1",
        "idx": 2629
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sbr_lf_gen ( AACContext * ac , SpectralBandReplication * sbr , float X_low [ 32 ] [ 40 ] [ 2 ] , const float W [ 2 ] [ 32 ] [ 32 ] [ 2 ] , int buf_idx ) {\n int i , k ;\n const int t_HFGen = 8 ;\n const int i_f = 32 ;\n memset ( X_low , 0 , 32 * sizeof ( * X_low ) ) ;\n for ( k = 0 ;\n k < sbr -> kx [ 1 ] ;\n k ++ ) {\n for ( i = t_HFGen ;\n i < i_f + t_HFGen ;\n i ++ ) {\n X_low [ k ] [ i ] [ 0 ] = W [ buf_idx ] [ i - t_HFGen ] [ k ] [ 0 ] ;\n X_low [ k ] [ i ] [ 1 ] = W [ buf_idx ] [ i - t_HFGen ] [ k ] [ 1 ] ;\n }\n }\n buf_idx = 1 - buf_idx ;\n for ( k = 0 ;\n k < sbr -> kx [ 0 ] ;\n k ++ ) {\n for ( i = 0 ;\n i < t_HFGen ;\n i ++ ) {\n X_low [ k ] [ i ] [ 0 ] = W [ buf_idx ] [ i + i_f - t_HFGen ] [ k ] [ 0 ] ;\n X_low [ k ] [ i ] [ 1 ] = W [ buf_idx ] [ i + i_f - t_HFGen ] [ k ] [ 1 ] ;\n }\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 89
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint64 _tiffSeekProc ( thandle_t fd , uint64 off , int whence ) {\n LARGE_INTEGER offli ;\n DWORD dwMoveMethod ;\n offli . QuadPart = off ;\n switch ( whence ) {\n case SEEK_SET : dwMoveMethod = FILE_BEGIN ;\n break ;\n case SEEK_CUR : dwMoveMethod = FILE_CURRENT ;\n break ;\n case SEEK_END : dwMoveMethod = FILE_END ;\n break ;\n default : dwMoveMethod = FILE_BEGIN ;\n break ;\n }\n offli . LowPart = SetFilePointer ( fd , offli . LowPart , & offli . HighPart , dwMoveMethod ) ;\n if ( ( offli . LowPart == INVALID_SET_FILE_POINTER ) && ( GetLastError ( ) != NO_ERROR ) ) offli . QuadPart = 0 ;\n return ( offli . QuadPart ) ;\n }",
        "output": "0",
        "idx": 1285
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t u_scanf_count_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {\n if ( ! info -> fSkipArg ) {\n if ( info -> fIsShort ) * ( int16_t * ) ( args [ 0 ] . ptrValue ) = ( int16_t ) ( UINT16_MAX & info -> fWidth ) ;\n else if ( info -> fIsLongLong ) * ( int64_t * ) ( args [ 0 ] . ptrValue ) = info -> fWidth ;\n else * ( int32_t * ) ( args [ 0 ] . ptrValue ) = ( int32_t ) ( UINT32_MAX & info -> fWidth ) ;\n }\n * argConverted = 0 ;\n return 0 ;\n }",
        "output": "1",
        "idx": 3344
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipvideo_decode_block_opcode_0xE ( IpvideoContext * s ) {\n int y ;\n unsigned char pix ;\n pix = bytestream2_get_byte ( & s -> stream_ptr ) ;\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n memset ( s -> pixel_ptr , pix , 8 ) ;\n s -> pixel_ptr += s -> stride ;\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 2240
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ttfFont__Open_aux ( ttfFont * self , ttfInterpreter * tti , gx_ttfReader * r , gs_font_type42 * pfont , const gs_matrix * char_tm , const gs_log2_scale_point * log2_scale , bool design_grid ) {\n gs_point char_size , subpix_origin ;\n gs_matrix post_transform ;\n unsigned int nTTC = 0 ;\n bool dg ;\n decompose_matrix ( pfont , char_tm , log2_scale , design_grid , & char_size , & subpix_origin , & post_transform , & dg ) ;\n switch ( ttfFont__Open ( tti , self , & r -> super , nTTC , char_size . x , char_size . y , dg ) ) {\n case fNoError : return 0 ;\n case fMemoryError : return_error ( gs_error_VMerror ) ;\n case fUnimplemented : return_error ( gs_error_unregistered ) ;\n case fBadInstruction : WarnBadInstruction ( pfont , - 1 ) ;\n goto recover ;\n case fPatented : WarnPatented ( pfont , self , \"The font\" ) ;\n recover : self -> patented = true ;\n return 0 ;\n default : {\n int code = r -> super . Error ( & r -> super ) ;\n if ( code < 0 ) return code ;\n return_error ( gs_error_invalidfont ) ;\n }\n }\n }",
        "output": "0",
        "idx": 1345
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int gifPutWord ( int w , gdIOCtx * out ) {\n gdPutC ( w & 0xFF , out ) ;\n gdPutC ( ( w >> 8 ) & 0xFF , out ) ;\n return 0 ;\n }",
        "output": "0",
        "idx": 287
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "size_t print_file_stack ( char * s , const char * end ) {\n char * start = s ;\n struct st_test_file * err_file = cur_file ;\n if ( err_file == file_stack ) return 0 ;\n for ( ;\n ;\n ) {\n err_file -- ;\n s += my_snprintf ( s , end - s , \"included from %s at line %d:\\n\" , err_file -> file_name , err_file -> lineno ) ;\n if ( err_file == file_stack ) break ;\n }\n return s - start ;\n }",
        "output": "0",
        "idx": 1149
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ExternalProtocolHandlerTest , TestLaunchSchemeBlockedChromeDefault ) {\n DoTest ( ExternalProtocolHandler : : BLOCK , shell_integration : : IS_DEFAULT , Action : : BLOCK ) ;\n }",
        "output": "0",
        "idx": 1544
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvm_get_mce_cap_supported ( KVMState * s , uint64_t * mce_cap , int * max_banks ) {\n int r ;\n r = kvm_check_extension ( s , KVM_CAP_MCE ) ;\n if ( r > 0 ) {\n * max_banks = r ;\n return kvm_ioctl ( s , KVM_X86_GET_MCE_CAP_SUPPORTED , mce_cap ) ;\n }\n return - ENOSYS ;\n }",
        "output": "0",
        "idx": 2220
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void OnDangerPromptCreated ( DownloadDangerPrompt * prompt ) {\n prompt -> InvokeActionForTesting ( DownloadDangerPrompt : : ACCEPT ) ;\n }",
        "output": "0",
        "idx": 2389
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int BIO_vsnprintf ( char * buf , size_t n , const char * format , va_list args ) {\n size_t retlen ;\n int truncated ;\n _dopr ( & buf , NULL , & n , & retlen , & truncated , format , args ) ;\n if ( truncated ) return - 1 ;\n else return ( retlen <= INT_MAX ) ? ( int ) retlen : - 1 ;\n }",
        "output": "1",
        "idx": 3427
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gint pad_according_to_type ( gint offset , gint field_starting_offset , gint max_offset , guint8 type ) {\n switch ( type ) {\n case ARG_BYTE : break ;\n case ARG_DOUBLE : case ARG_UINT64 : case ARG_INT64 : case ARG_STRUCT : case ARG_DICT_ENTRY : offset = round_to_8byte ( offset , field_starting_offset ) ;\n break ;\n case ARG_SIGNATURE : break ;\n case ARG_HANDLE : break ;\n case ARG_INT32 : case ARG_UINT32 : case ARG_BOOLEAN : offset = round_to_4byte ( offset , field_starting_offset ) ;\n break ;\n case ARG_INT16 : case ARG_UINT16 : offset = round_to_2byte ( offset , field_starting_offset ) ;\n break ;\n case ARG_STRING : break ;\n case ARG_VARIANT : break ;\n case ARG_OBJ_PATH : break ;\n default : break ;\n }\n if ( offset > max_offset ) {\n offset = max_offset ;\n }\n return offset ;\n }",
        "output": "0",
        "idx": 1321
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ExternalProtocolHandlerTest , TestGetBlockStateLocalDontBlockCopiedAsIsToProfilePref ) {\n base : : DictionaryValue prefs_local ;\n prefs_local . SetBoolean ( \"tel\" , false ) ;\n local_state_ -> Set ( prefs : : kExcludedSchemes , prefs_local ) ;\n ExternalProtocolHandler : : BlockState block_state = ExternalProtocolHandler : : GetBlockState ( \"tel\" , profile_ . get ( ) ) ;\n EXPECT_EQ ( ExternalProtocolHandler : : DONT_BLOCK , block_state ) ;\n EXPECT_TRUE ( local_state_ -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;\n EXPECT_FALSE ( profile_ -> GetPrefs ( ) -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;\n }",
        "output": "1",
        "idx": 130
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GType hb_gobject_ ## name ## _get_type ( void ) \\ {\n static gsize type_id = 0 ;\n if ( g_once_init_enter ( & type_id ) ) {\n GType id = g_boxed_type_register_static ( g_intern_static_string ( \"hb_\" # name \"_t\" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;\n g_once_init_leave ( & type_id , id ) ;\n }\n return type_id ;\n \\ }\n # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs ) HB_DEFINE_OBJECT_TYPE ( set ) HB_DEFINE_OBJECT_TYPE ( shape_plan ) HB_DEFINE_OBJECT_TYPE ( unicode_funcs )",
        "output": "1",
        "idx": 4054
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * php_zip_make_relative_path ( char * path , int path_len ) {\n char * path_begin = path ;\n size_t i ;\n if ( path_len < 1 || path == NULL ) {\n return NULL ;\n }\n if ( IS_SLASH ( path [ 0 ] ) ) {\n return path + 1 ;\n }\n i = path_len ;\n while ( 1 ) {\n while ( i > 0 && ! IS_SLASH ( path [ i ] ) ) {\n i -- ;\n }\n if ( ! i ) {\n return path ;\n }\n if ( i >= 2 && ( path [ i - 1 ] == '.' || path [ i - 1 ] == ':' ) ) {\n path_begin = path + i + 1 ;\n break ;\n }\n i -- ;\n }\n return path_begin ;\n }",
        "output": "0",
        "idx": 1759
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void remove_new_subdir ( char * subdir , bool rmtopdir ) {\n char new_path [ MAXPGPATH ] ;\n prep_status ( \"Deleting files from new %s\" , subdir ) ;\n snprintf ( new_path , sizeof ( new_path ) , \"%s/%s\" , new_cluster . pgdata , subdir ) ;\n if ( ! rmtree ( new_path , rmtopdir ) ) pg_fatal ( \"could not delete directory \\\"%s\\\"\\n\" , new_path ) ;\n check_ok ( ) ;\n }",
        "output": "0",
        "idx": 2881
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void init_mv_penalty_and_fcode ( MpegEncContext * s ) {\n int f_code ;\n int mv ;\n for ( f_code = 1 ;\n f_code <= MAX_FCODE ;\n f_code ++ ) {\n for ( mv = - MAX_MV ;\n mv <= MAX_MV ;\n mv ++ ) {\n int len ;\n if ( mv == 0 ) len = ff_mvtab [ 0 ] [ 1 ] ;\n else {\n int val , bit_size , code ;\n bit_size = f_code - 1 ;\n val = mv ;\n if ( val < 0 ) val = - val ;\n val -- ;\n code = ( val >> bit_size ) + 1 ;\n if ( code < 33 ) {\n len = ff_mvtab [ code ] [ 1 ] + 1 + bit_size ;\n }\n else {\n len = ff_mvtab [ 32 ] [ 1 ] + av_log2 ( code >> 5 ) + 2 + bit_size ;\n }\n }\n mv_penalty [ f_code ] [ mv + MAX_MV ] = len ;\n }\n }\n for ( f_code = MAX_FCODE ;\n f_code > 0 ;\n f_code -- ) {\n for ( mv = - ( 16 << f_code ) ;\n mv < ( 16 << f_code ) ;\n mv ++ ) {\n fcode_tab [ mv + MAX_MV ] = f_code ;\n }\n }\n for ( mv = 0 ;\n mv < MAX_MV * 2 + 1 ;\n mv ++ ) {\n umv_fcode_tab [ mv ] = 1 ;\n }\n }",
        "output": "0",
        "idx": 1190
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void qemu_put_be64s ( QEMUFile * f , const uint64_t * pv ) {\n qemu_put_be64 ( f , * pv ) ;\n }",
        "output": "0",
        "idx": 34
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl ) ;\n __exctype ( isdigit )",
        "output": "1",
        "idx": 1608
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pxa2xx_register_types ( void ) {\n type_register_static ( & pxa2xx_i2c_slave_info ) ;\n type_register_static ( & pxa2xx_ssp_info ) ;\n type_register_static ( & pxa2xx_i2c_info ) ;\n type_register_static ( & pxa2xx_rtc_sysbus_info ) ;\n }",
        "output": "0",
        "idx": 2155
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void stubHashScannerFull ( void * payload , void * data , const xmlChar * name , const xmlChar * name2 ATTRIBUTE_UNUSED , const xmlChar * name3 ATTRIBUTE_UNUSED ) {\n stubData * stubdata = ( stubData * ) data ;\n stubdata -> hashscanner ( payload , stubdata -> data , ( xmlChar * ) name ) ;\n }",
        "output": "1",
        "idx": 785
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TSReturnCode TSMgmtCounterGet ( const char * var_name , TSMgmtCounter * result ) {\n return RecGetRecordCounter ( ( char * ) var_name , ( RecCounter * ) result ) == REC_ERR_OKAY ? TS_SUCCESS : TS_ERROR ;\n }",
        "output": "0",
        "idx": 516
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int aes_gcm_cleanup ( EVP_CIPHER_CTX * c ) {\n EVP_AES_GCM_CTX * gctx = EVP_C_DATA ( EVP_AES_GCM_CTX , c ) ;\n OPENSSL_cleanse ( & gctx -> gcm , sizeof ( gctx -> gcm ) ) ;\n if ( gctx -> iv != EVP_CIPHER_CTX_iv_noconst ( c ) ) OPENSSL_free ( gctx -> iv ) ;\n return 1 ;\n }",
        "output": "0",
        "idx": 4025
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_H221NonStandard ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 790 \"./asn1/h225/h225.cnf\" t35CountryCode = 0 ;\n t35Extension = 0 ;\n manufacturerCode = 0 ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_H221NonStandard , H221NonStandard_sequence ) ;\n # line 794 \"./asn1/h225/h225.cnf\" h221NonStandard = ( ( t35CountryCode * 256 ) + t35Extension ) * 65536 + manufacturerCode ;\n proto_tree_add_uint ( tree , hf_h221Manufacturer , tvb , ( offset >> 3 ) - 4 , 4 , h221NonStandard ) ;\n return offset ;\n }",
        "output": "1",
        "idx": 4090
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void read_sbr_dtdf ( SpectralBandReplication * sbr , GetBitContext * gb , SBRData * ch_data ) {\n get_bits1_vector ( gb , ch_data -> bs_df_env , ch_data -> bs_num_env ) ;\n get_bits1_vector ( gb , ch_data -> bs_df_noise , ch_data -> bs_num_noise ) ;\n }",
        "output": "1",
        "idx": 172
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( WebFrameTest , GetCanonicalUrlForSharing ) {\n FrameTestHelpers : : WebViewHelper web_view_helper ;\n web_view_helper . Initialize ( ) ;\n WebLocalFrameImpl * frame = web_view_helper . LocalMainFrame ( ) ;\n FrameTestHelpers : : LoadHTMLString ( frame , R \"( < head > < link rel = \"canonical\" href = \"https://example.com/canonical.html\" > < / head > ) \", ToKURL(\" https : EXPECT_EQ ( WebURL ( ToKURL ( \"https://example.com/canonical.html\" ) ) , frame -> GetDocument ( ) . CanonicalUrlForSharing ( ) ) ;\n }",
        "output": "0",
        "idx": 3043
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "double histogram_selectivity ( VariableStatData * vardata , FmgrInfo * opproc , Datum constval , bool varonleft , int min_hist_size , int n_skip , int * hist_size ) {\n double result ;\n Datum * values ;\n int nvalues ;\n Assert ( n_skip >= 0 ) ;\n Assert ( min_hist_size > 2 * n_skip ) ;\n if ( HeapTupleIsValid ( vardata -> statsTuple ) && get_attstatsslot ( vardata -> statsTuple , vardata -> atttype , vardata -> atttypmod , STATISTIC_KIND_HISTOGRAM , InvalidOid , NULL , & values , & nvalues , NULL , NULL ) ) {\n * hist_size = nvalues ;\n if ( nvalues >= min_hist_size ) {\n int nmatch = 0 ;\n int i ;\n for ( i = n_skip ;\n i < nvalues - n_skip ;\n i ++ ) {\n if ( varonleft ? DatumGetBool ( FunctionCall2Coll ( opproc , DEFAULT_COLLATION_OID , values [ i ] , constval ) ) : DatumGetBool ( FunctionCall2Coll ( opproc , DEFAULT_COLLATION_OID , constval , values [ i ] ) ) ) nmatch ++ ;\n }\n result = ( ( double ) nmatch ) / ( ( double ) ( nvalues - 2 * n_skip ) ) ;\n }\n else result = - 1 ;\n free_attstatsslot ( vardata -> atttype , values , nvalues , NULL , 0 ) ;\n }\n else {\n * hist_size = 0 ;\n result = - 1 ;\n }\n return result ;\n }",
        "output": "1",
        "idx": 1041
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t u_scanf_ustring_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {\n UChar * arg = ( UChar * ) ( args [ 0 ] . ptrValue ) ;\n UChar * alias = arg ;\n int32_t count ;\n int32_t skipped = 0 ;\n UChar c ;\n UBool isNotEOF = FALSE ;\n if ( info -> fIsString ) {\n skipped = u_scanf_skip_leading_ws ( input , info -> fPadChar ) ;\n }\n count = 0 ;\n while ( ( info -> fWidth == - 1 || count < info -> fWidth ) && ( isNotEOF = ufile_getch ( input , & c ) ) && ( ! info -> fIsString || ( c != info -> fPadChar && ! u_isWhitespace ( c ) ) ) ) {\n if ( ! info -> fSkipArg ) {\n * alias ++ = c ;\n }\n ++ count ;\n }\n if ( ! info -> fSkipArg ) {\n if ( ( info -> fWidth == - 1 || count < info -> fWidth ) && isNotEOF ) {\n u_fungetc ( c , input ) ;\n }\n if ( info -> fIsString ) {\n * alias = 0x0000 ;\n }\n }\n * argConverted = ! info -> fSkipArg ;\n return count + skipped ;\n }",
        "output": "1",
        "idx": 2048
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int parse_CPropertyRestriction ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , struct CPropertyRestriction * v , const char * fmt , ... ) {\n proto_tree * tree ;\n proto_item * item ;\n const char * txt , * str = NULL ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CPropertyRestriction , & item , txt ) ;\n offset = parse_relop ( tvb , offset , tree , & v -> relop , & str ) ;\n proto_item_append_text ( item , \" Op: %s\" , str ) ;\n offset = parse_CFullPropSpec ( tvb , offset , tree , pad_tree , & v -> property , \"Property\" ) ;\n offset = parse_CBaseStorageVariant ( tvb , offset , tree , pad_tree , & v -> prval , \"prval\" ) ;\n offset = parse_padding ( tvb , offset , 4 , pad_tree , \"padding_lcid\" ) ;\n v -> lcid = tvb_get_letohl ( tvb , offset ) ;\n offset = parse_lcid ( tvb , offset , tree , \"lcid\" ) ;\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }",
        "output": "1",
        "idx": 668
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int gic_get_current_cpu ( GICState * s ) {\n if ( s -> num_cpu > 1 ) {\n CPUState * cpu = ENV_GET_CPU ( cpu_single_env ) ;\n return cpu -> cpu_index ;\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 1917
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const mbfl_encoding * mbfl_encoding_detector_judge2 ( mbfl_encoding_detector * identd ) {\n mbfl_identify_filter * filter ;\n const mbfl_encoding * encoding = NULL ;\n int n ;\n if ( identd != NULL ) {\n n = identd -> filter_list_size - 1 ;\n while ( n >= 0 ) {\n filter = identd -> filter_list [ n ] ;\n if ( ! filter -> flag ) {\n if ( ! identd -> strict || ! filter -> status ) {\n encoding = filter -> encoding ;\n }\n }\n n -- ;\n }\n if ( ! encoding ) {\n n = identd -> filter_list_size - 1 ;\n while ( n >= 0 ) {\n filter = identd -> filter_list [ n ] ;\n if ( ! filter -> flag ) {\n encoding = filter -> encoding ;\n }\n n -- ;\n }\n }\n }\n return encoding ;\n }",
        "output": "1",
        "idx": 1969
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean capture_netbios ( const guchar * pd _U_ , int offset _U_ , int len _U_ , capture_packet_info_t * cpinfo , const union wtap_pseudo_header * pseudo_header _U_ ) {\n capture_dissector_increment_count ( cpinfo , proto_netbios ) ;\n return TRUE ;\n }",
        "output": "0",
        "idx": 2503
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static guint16 de_clg_party_bcd_num ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo , guint32 offset , guint len , gchar * add_string , int string_len ) {\n const gchar * extr_addr ;\n de_bcd_num ( tvb , tree , pinfo , offset , len , hf_gsm_a_dtap_clg_party_bcd_num , & extr_addr ) ;\n if ( extr_addr && add_string ) g_snprintf ( add_string , string_len , \" - (%s)\" , extr_addr ) ;\n return ( len ) ;\n }",
        "output": "0",
        "idx": 3560
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileInfo , __construct ) {\n spl_filesystem_object * intern ;\n char * path ;\n int len ;\n zend_error_handling error_handling ;\n zend_replace_error_handling ( EH_THROW , spl_ce_RuntimeException , & error_handling TSRMLS_CC ) ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"s\" , & path , & len ) == FAILURE ) {\n zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;\n return ;\n }\n intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n spl_filesystem_info_set_filename ( intern , path , len , 1 TSRMLS_CC ) ;\n zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;\n }",
        "output": "1",
        "idx": 193
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned int hb_set_get_population ( const hb_set_t * set ) {\n return set -> get_population ( ) ;\n }",
        "output": "0",
        "idx": 604
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pxa2xx_fir_load ( QEMUFile * f , void * opaque , int version_id ) {\n PXA2xxFIrState * s = ( PXA2xxFIrState * ) opaque ;\n int i ;\n s -> enable = qemu_get_be32 ( f ) ;\n qemu_get_8s ( f , & s -> control [ 0 ] ) ;\n qemu_get_8s ( f , & s -> control [ 1 ] ) ;\n qemu_get_8s ( f , & s -> control [ 2 ] ) ;\n qemu_get_8s ( f , & s -> status [ 0 ] ) ;\n qemu_get_8s ( f , & s -> status [ 1 ] ) ;\n s -> rx_len = qemu_get_byte ( f ) ;\n s -> rx_start = 0 ;\n for ( i = 0 ;\n i < s -> rx_len ;\n i ++ ) s -> rx_fifo [ i ] = qemu_get_byte ( f ) ;\n return 0 ;\n }",
        "output": "0",
        "idx": 4200
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemuMonitorTextRemoveNetdev ( qemuMonitorPtr mon , const char * alias ) {\n char * cmd ;\n char * reply = NULL ;\n int ret = - 1 ;\n if ( virAsprintf ( & cmd , \"netdev_del %s\" , alias ) < 0 ) {\n virReportOOMError ( ) ;\n return - 1 ;\n }\n if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( \"failed to remove netdev in qemu with '%s'\" ) , cmd ) ;\n goto cleanup ;\n }\n ret = 0 ;\n cleanup : VIR_FREE ( cmd ) ;\n VIR_FREE ( reply ) ;\n return ret ;\n }",
        "output": "0",
        "idx": 4325
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_fdct32x32_1_c ( const int16_t * input , int16_t * output , int stride ) {\n int r , c ;\n int16_t sum = 0 ;\n for ( r = 0 ;\n r < 32 ;\n ++ r ) for ( c = 0 ;\n c < 32 ;\n ++ c ) sum += input [ r * stride + c ] ;\n output [ 0 ] = sum >> 3 ;\n output [ 1 ] = 0 ;\n }",
        "output": "1",
        "idx": 614
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void check_and_dump_old_cluster ( bool live_check ) {\n if ( ! live_check ) start_postmaster ( & old_cluster , true ) ;\n get_db_and_rel_infos ( & old_cluster ) ;\n init_tablespaces ( ) ;\n get_loadable_libraries ( ) ;\n check_is_install_user ( & old_cluster ) ;\n check_proper_datallowconn ( & old_cluster ) ;\n check_for_prepared_transactions ( & old_cluster ) ;\n check_for_reg_data_type_usage ( & old_cluster ) ;\n check_for_isn_and_int8_passing_mismatch ( & old_cluster ) ;\n if ( GET_MAJOR_VERSION ( old_cluster . major_version ) <= 905 ) check_for_pg_role_prefix ( & old_cluster ) ;\n if ( GET_MAJOR_VERSION ( old_cluster . major_version ) == 904 && old_cluster . controldata . cat_ver < JSONB_FORMAT_CHANGE_CAT_VER ) check_for_jsonb_9_4_usage ( & old_cluster ) ;\n if ( GET_MAJOR_VERSION ( old_cluster . major_version ) <= 903 ) old_9_3_check_for_line_data_type_usage ( & old_cluster ) ;\n if ( GET_MAJOR_VERSION ( old_cluster . major_version ) <= 804 ) new_9_0_populate_pg_largeobject_metadata ( & old_cluster , true ) ;\n if ( ! user_opts . check ) generate_old_dump ( ) ;\n if ( ! live_check ) stop_postmaster ( false ) ;\n }",
        "output": "0",
        "idx": 3974
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool test_if_create_new_users ( THD * thd ) {\n Security_context * sctx = thd -> security_ctx ;\n bool create_new_users = test ( sctx -> master_access & INSERT_ACL ) || ( ! opt_safe_user_create && test ( sctx -> master_access & CREATE_USER_ACL ) ) ;\n if ( ! create_new_users ) {\n TABLE_LIST tl ;\n ulong db_access ;\n bzero ( ( char * ) & tl , sizeof ( tl ) ) ;\n tl . db = ( char * ) \"mysql\" ;\n tl . table_name = ( char * ) \"user\" ;\n create_new_users = 1 ;\n db_access = acl_get ( sctx -> host , sctx -> ip , sctx -> priv_user , tl . db , 0 ) ;\n if ( ! ( db_access & INSERT_ACL ) ) {\n if ( check_grant ( thd , INSERT_ACL , & tl , 0 , UINT_MAX , 1 ) ) create_new_users = 0 ;\n }\n }\n return create_new_users ;\n }",
        "output": "0",
        "idx": 3000
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static double patternjoinsel ( PG_FUNCTION_ARGS , Pattern_Type ptype , bool negate ) {\n return negate ? ( 1.0 - DEFAULT_MATCH_SEL ) : DEFAULT_MATCH_SEL ;\n }",
        "output": "0",
        "idx": 3042
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void hmp_hostfwd_add ( Monitor * mon , const QDict * qdict ) {\n const char * redir_str ;\n SlirpState * s ;\n const char * arg1 = qdict_get_str ( qdict , \"arg1\" ) ;\n const char * arg2 = qdict_get_try_str ( qdict , \"arg2\" ) ;\n const char * arg3 = qdict_get_try_str ( qdict , \"arg3\" ) ;\n if ( arg2 ) {\n s = slirp_lookup ( mon , arg1 , arg2 ) ;\n redir_str = arg3 ;\n }\n else {\n s = slirp_lookup ( mon , NULL , NULL ) ;\n redir_str = arg1 ;\n }\n if ( s ) {\n slirp_hostfwd ( s , redir_str , 0 ) ;\n }\n }",
        "output": "0",
        "idx": 3902
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int alloc_mi ( VP9_COMMON * cm , int mi_size ) {\n int i ;\n for ( i = 0 ;\n i < 2 ;\n ++ i ) {\n cm -> mip_array [ i ] = ( MODE_INFO * ) vpx_calloc ( mi_size , sizeof ( MODE_INFO ) ) ;\n if ( cm -> mip_array [ i ] == NULL ) return 1 ;\n cm -> mi_grid_base_array [ i ] = ( MODE_INFO * * ) vpx_calloc ( mi_size , sizeof ( MODE_INFO * ) ) ;\n if ( cm -> mi_grid_base_array [ i ] == NULL ) return 1 ;\n }\n cm -> mi_alloc_size = mi_size ;\n cm -> mi_idx = 0 ;\n cm -> prev_mi_idx = 1 ;\n cm -> mip = cm -> mip_array [ cm -> mi_idx ] ;\n cm -> prev_mip = cm -> mip_array [ cm -> prev_mi_idx ] ;\n cm -> mi_grid_base = cm -> mi_grid_base_array [ cm -> mi_idx ] ;\n cm -> prev_mi_grid_base = cm -> mi_grid_base_array [ cm -> prev_mi_idx ] ;\n return 0 ;\n }",
        "output": "1",
        "idx": 4308
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ArchiveHandle * CloneArchive ( ArchiveHandle * AH ) {\n ArchiveHandle * clone ;\n clone = ( ArchiveHandle * ) pg_malloc ( sizeof ( ArchiveHandle ) ) ;\n memcpy ( clone , AH , sizeof ( ArchiveHandle ) ) ;\n memset ( & ( clone -> sqlparse ) , 0 , sizeof ( clone -> sqlparse ) ) ;\n clone -> connection = NULL ;\n clone -> connCancel = NULL ;\n clone -> currUser = NULL ;\n clone -> currSchema = NULL ;\n clone -> currTablespace = NULL ;\n clone -> currWithOids = - 1 ;\n if ( clone -> savedPassword ) clone -> savedPassword = pg_strdup ( clone -> savedPassword ) ;\n clone -> public . n_errors = 0 ;\n if ( AH -> mode == archModeRead ) {\n RestoreOptions * ropt = AH -> public . ropt ;\n Assert ( AH -> connection == NULL ) ;\n ConnectDatabase ( ( Archive * ) clone , ropt -> dbname , ropt -> pghost , ropt -> pgport , ropt -> username , ropt -> promptPassword ) ;\n _doSetFixedOutputState ( clone ) ;\n }\n else {\n char * dbname ;\n char * pghost ;\n char * pgport ;\n char * username ;\n Assert ( AH -> connection != NULL ) ;\n dbname = PQdb ( AH -> connection ) ;\n pghost = PQhost ( AH -> connection ) ;\n pgport = PQport ( AH -> connection ) ;\n username = PQuser ( AH -> connection ) ;\n ConnectDatabase ( ( Archive * ) clone , dbname , pghost , pgport , username , TRI_NO ) ;\n }\n ( clone -> ClonePtr ) ( clone ) ;\n Assert ( clone -> connection != NULL ) ;\n return clone ;\n }",
        "output": "1",
        "idx": 2701
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xsltDocumentPtr xsltLoadStyleDocument ( xsltStylesheetPtr style , const xmlChar * URI ) {\n xsltDocumentPtr ret ;\n xmlDocPtr doc ;\n xsltSecurityPrefsPtr sec ;\n if ( ( style == NULL ) || ( URI == NULL ) ) return ( NULL ) ;\n sec = xsltGetDefaultSecurityPrefs ( ) ;\n if ( sec != NULL ) {\n int res ;\n res = xsltCheckRead ( sec , NULL , URI ) ;\n if ( res == 0 ) {\n xsltTransformError ( NULL , NULL , NULL , \"xsltLoadStyleDocument: read rights for %s denied\\n\" , URI ) ;\n return ( NULL ) ;\n }\n }\n ret = style -> docList ;\n while ( ret != NULL ) {\n if ( ( ret -> doc != NULL ) && ( ret -> doc -> URL != NULL ) && ( xmlStrEqual ( ret -> doc -> URL , URI ) ) ) return ( ret ) ;\n ret = ret -> next ;\n }\n doc = xsltDocDefaultLoader ( URI , style -> dict , XSLT_PARSE_OPTIONS , ( void * ) style , XSLT_LOAD_STYLESHEET ) ;\n if ( doc == NULL ) return ( NULL ) ;\n ret = xsltNewStyleDocument ( style , doc ) ;\n return ( ret ) ;\n }",
        "output": "1",
        "idx": 652
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void clamp_indexed ( const fz_colorspace * cs , const float * in , float * out ) {\n struct indexed * idx = cs -> data ;\n * out = fz_clamp ( * in , 0 , idx -> high ) / 255.0f ;\n }",
        "output": "0",
        "idx": 2364
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE cState_object_nl_set ( VALUE self , VALUE object_nl ) {\n unsigned long len ;\n GET_STATE ( self ) ;\n Check_Type ( object_nl , T_STRING ) ;\n len = RSTRING_LEN ( object_nl ) ;\n if ( len == 0 ) {\n if ( state -> object_nl ) {\n ruby_xfree ( state -> object_nl ) ;\n state -> object_nl = NULL ;\n }\n }\n else {\n if ( state -> object_nl ) ruby_xfree ( state -> object_nl ) ;\n state -> object_nl = strdup ( RSTRING_PTR ( object_nl ) ) ;\n state -> object_nl_len = len ;\n }\n return Qnil ;\n }",
        "output": "1",
        "idx": 381
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cin_decode_lzss ( const unsigned char * src , int src_size , unsigned char * dst , int dst_size ) {\n uint16_t cmd ;\n int i , sz , offset , code ;\n unsigned char * dst_end = dst + dst_size , * dst_start = dst ;\n const unsigned char * src_end = src + src_size ;\n while ( src < src_end && dst < dst_end ) {\n code = * src ++ ;\n for ( i = 0 ;\n i < 8 && src < src_end && dst < dst_end ;\n ++ i ) {\n if ( code & ( 1 << i ) ) {\n * dst ++ = * src ++ ;\n }\n else {\n cmd = AV_RL16 ( src ) ;\n src += 2 ;\n offset = cmd >> 4 ;\n if ( ( int ) ( dst - dst_start ) < offset + 1 ) return AVERROR_INVALIDDATA ;\n sz = ( cmd & 0xF ) + 2 ;\n sz = FFMIN ( sz , dst_end - dst ) ;\n while ( sz -- ) {\n * dst = * ( dst - offset - 1 ) ;\n ++ dst ;\n }\n }\n }\n }\n return 0 ;\n }",
        "output": "0",
        "idx": 1681
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TSReturnCode TSCacheKeyDigestSet ( TSCacheKey key , const char * input , int length ) {\n sdk_assert ( sdk_sanity_check_cachekey ( key ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_iocore_structure ( ( void * ) input ) == TS_SUCCESS ) ;\n sdk_assert ( length > 0 ) ;\n CacheInfo * ci = reinterpret_cast < CacheInfo * > ( key ) ;\n if ( ci -> magic != CACHE_INFO_MAGIC_ALIVE ) {\n return TS_ERROR ;\n }\n MD5Context ( ) . hash_immediate ( ci -> cache_key , input , length ) ;\n return TS_SUCCESS ;\n }",
        "output": "0",
        "idx": 2096
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_list_fields ( ) {\n MYSQL_RES * result ;\n int rc ;\n myheader ( \"test_list_fields\" ) ;\n rc = mysql_query ( mysql , \"drop table if exists t1\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"create table t1(c1 int primary key auto_increment, c2 char(10) default 'mysql')\" ) ;\n myquery ( rc ) ;\n result = mysql_list_fields ( mysql , \"t1\" , NULL ) ;\n mytest ( result ) ;\n rc = my_process_result_set ( result ) ;\n DIE_UNLESS ( rc == 0 ) ;\n verify_prepare_field ( result , 0 , \"c1\" , \"c1\" , MYSQL_TYPE_LONG , \"t1\" , \"t1\" , current_db , 11 , \"0\" ) ;\n verify_prepare_field ( result , 1 , \"c2\" , \"c2\" , MYSQL_TYPE_STRING , \"t1\" , \"t1\" , current_db , 10 , \"mysql\" ) ;\n mysql_free_result ( result ) ;\n myquery ( mysql_query ( mysql , \"drop table t1\" ) ) ;\n }",
        "output": "0",
        "idx": 4195
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GType hb_gobject_ ## name ## _get_type ( void ) \\ {\n static gsize type_id = 0 ;\n if ( g_once_init_enter ( & type_id ) ) {\n GType id = g_boxed_type_register_static ( g_intern_static_string ( \"hb_\" # name \"_t\" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;\n g_once_init_leave ( & type_id , id ) ;\n }\n return type_id ;\n \\ }\n # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face )",
        "output": "1",
        "idx": 868
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int float_compare_desc ( const void * key1 , const void * key2 ) {\n float d1 = * ( ( const float * ) key1 ) ;\n float d2 = * ( ( const float * ) key2 ) ;\n if ( d1 > d2 ) return - 1 ;\n else if ( d1 < d2 ) return 1 ;\n else return 0 ;\n }",
        "output": "0",
        "idx": 473
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GType hb_gobject_ ## name ## _get_type ( void ) \\ {\n static gsize type_id = 0 ;\n if ( g_once_init_enter ( & type_id ) ) {\n GType id = g_boxed_type_register_static ( g_intern_static_string ( \"hb_\" # name \"_t\" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;\n g_once_init_leave ( & type_id , id ) ;\n }\n return type_id ;\n \\ }\n # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs ) HB_DEFINE_OBJECT_TYPE ( set ) HB_DEFINE_OBJECT_TYPE ( shape_plan ) HB_DEFINE_OBJECT_TYPE ( unicode_funcs ) static hb_feature_t * feature_reference ( hb_feature_t * g ) {\n hb_feature_t * c = ( hb_feature_t * ) calloc ( 1 , sizeof ( hb_feature_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }\n static void feature_destroy ( hb_feature_t * g ) {\n free ( g ) ;\n }\n HB_DEFINE_BOXED_TYPE ( feature , feature_reference , feature_destroy )",
        "output": "1",
        "idx": 4479
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static hb_segment_properties_t * segment_properties_reference ( hb_segment_properties_t * g ) {\n hb_segment_properties_t * c = ( hb_segment_properties_t * ) calloc ( 1 , sizeof ( hb_segment_properties_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }",
        "output": "1",
        "idx": 4117
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int test_save_copy ( const char * origname ) {\n char buf [ TESTBUFSIZE ] ;\n int ret ;\n snprintf_func ( buf , TESTBUFSIZE , \"cp -f %s %s\" , origname , TEST_COPY_FILE ) ;\n if ( ( ret = system ( buf ) ) != 0 ) {\n return XD3_INTERNAL ;\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 2613
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void * linux_udev_event_thread_main ( void * arg ) {\n char dummy ;\n int r ;\n struct udev_device * udev_dev ;\n struct pollfd fds [ ] = {\n {\n . fd = udev_control_pipe [ 0 ] , . events = POLLIN }\n , {\n . fd = udev_monitor_fd , . events = POLLIN }\n , }\n ;\n usbi_dbg ( \"udev event thread entering.\" ) ;\n while ( poll ( fds , 2 , - 1 ) >= 0 ) {\n if ( fds [ 0 ] . revents & POLLIN ) {\n r = usbi_read ( udev_control_pipe [ 0 ] , & dummy , sizeof ( dummy ) ) ;\n if ( r <= 0 ) {\n usbi_warn ( NULL , \"udev control pipe read failed\" ) ;\n }\n break ;\n }\n if ( fds [ 1 ] . revents & POLLIN ) {\n usbi_mutex_static_lock ( & linux_hotplug_lock ) ;\n udev_dev = udev_monitor_receive_device ( udev_monitor ) ;\n if ( udev_dev ) udev_hotplug_event ( udev_dev ) ;\n usbi_mutex_static_unlock ( & linux_hotplug_lock ) ;\n }\n }\n usbi_dbg ( \"udev event thread exiting\" ) ;\n return NULL ;\n }",
        "output": "1",
        "idx": 1707
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_start_slave_sql ( MYSQL * mysql_con ) {\n MYSQL_RES * slave ;\n if ( mysql_query_with_error_report ( mysql_con , & slave , \"SHOW SLAVE STATUS\" ) ) return ( 1 ) ;\n else {\n MYSQL_ROW row = mysql_fetch_row ( slave ) ;\n if ( row && row [ 11 ] ) {\n if ( ! strcmp ( row [ 11 ] , \"Yes\" ) ) {\n mysql_free_result ( slave ) ;\n return ( 0 ) ;\n }\n }\n }\n mysql_free_result ( slave ) ;\n if ( mysql_query_with_error_report ( mysql_con , 0 , \"START SLAVE\" ) ) {\n fprintf ( stderr , \"%s: Error: Unable to start slave\\n\" , my_progname_short ) ;\n return 1 ;\n }\n return ( 0 ) ;\n }",
        "output": "0",
        "idx": 2130
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint_fast32_t jpc_abstorelstepsize ( jpc_fix_t absdelta , int scaleexpn ) {\n int p ;\n uint_fast32_t mant ;\n uint_fast32_t expn ;\n int n ;\n if ( absdelta < 0 ) {\n abort ( ) ;\n }\n p = jpc_firstone ( absdelta ) - JPC_FIX_FRACBITS ;\n n = 11 - jpc_firstone ( absdelta ) ;\n mant = ( ( n < 0 ) ? ( absdelta >> ( - n ) ) : ( absdelta << n ) ) & 0x7ff ;\n expn = scaleexpn - p ;\n if ( scaleexpn < p ) {\n abort ( ) ;\n }\n return JPC_QCX_EXPN ( expn ) | JPC_QCX_MANT ( mant ) ;\n }",
        "output": "0",
        "idx": 1016
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_MPV_report_decode_progress ( MpegEncContext * s ) {\n if ( s -> pict_type != AV_PICTURE_TYPE_B && ! s -> partitioned_frame && ! s -> er . error_occurred ) ff_thread_report_progress ( & s -> current_picture_ptr -> f , s -> mb_y , 0 ) ;\n }",
        "output": "1",
        "idx": 2887
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main ( int argc , char * argv [ ] ) {\n libettercap_init ( ) ;\n ef_globals_alloc ( ) ;\n select_text_interface ( ) ;\n libettercap_ui_init ( ) ;\n fprintf ( stdout , \"\\n\" EC_COLOR_BOLD \"%s %s\" EC_COLOR_END \" copyright %s %s\\n\\n\" , PROGRAM , EC_VERSION , EC_COPYRIGHT , EC_AUTHORS ) ;\n EF_GBL -> lineno = 1 ;\n parse_options ( argc , argv ) ;\n if ( EF_GBL_OPTIONS -> source_file ) {\n yyin = fopen ( EF_GBL_OPTIONS -> source_file , \"r\" ) ;\n if ( yyin == NULL ) FATAL_ERROR ( \"Input file not found !\" ) ;\n }\n else {\n FATAL_ERROR ( \"No source file.\" ) ;\n }\n setbuf ( yyin , NULL ) ;\n setbuf ( stdout , NULL ) ;\n setbuf ( stderr , NULL ) ;\n load_tables ( ) ;\n load_constants ( ) ;\n fprintf ( stdout , \"\\n Parsing source file \\'%s\\' \" , EF_GBL_OPTIONS -> source_file ) ;\n fflush ( stdout ) ;\n ef_debug ( 1 , \"\\n\" ) ;\n if ( yyparse ( ) == 0 ) fprintf ( stdout , \" done.\\n\\n\" ) ;\n else fprintf ( stdout , \"\\n\\nThe script contains errors...\\n\\n\" ) ;\n if ( write_output ( ) != E_SUCCESS ) FATAL_ERROR ( \"Cannot write output file (%s)\" , EF_GBL_OPTIONS -> output_file ) ;\n ef_globals_free ( ) ;\n return 0 ;\n }",
        "output": "1",
        "idx": 1467
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void stroke_config ( private_stroke_socket_t * this , stroke_msg_t * msg , FILE * out ) {\n this -> cred -> cachecrl ( this -> cred , msg -> config . cachecrl ) ;\n }",
        "output": "0",
        "idx": 1855
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( SupervisedUserNavigationThrottleTest , DontBlockSubFrame ) {\n BlockHost ( kExampleHost2 ) ;\n BlockHost ( kIframeHost2 ) ;\n WebContents * tab = browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) ;\n GURL allowed_url_with_iframes = embedded_test_server ( ) -> GetURL ( kExampleHost , \"/supervised_user/with_iframes.html\" ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , allowed_url_with_iframes ) ;\n EXPECT_FALSE ( tab -> ShowingInterstitialPage ( ) ) ;\n bool loaded1 = false ;\n ASSERT_TRUE ( content : : ExecuteScriptAndExtractBool ( tab , \"loaded1()\" , & loaded1 ) ) ;\n EXPECT_TRUE ( loaded1 ) ;\n bool loaded2 = false ;\n ASSERT_TRUE ( content : : ExecuteScriptAndExtractBool ( tab , \"loaded2()\" , & loaded2 ) ) ;\n EXPECT_TRUE ( loaded2 ) ;\n }",
        "output": "1",
        "idx": 573
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pubkey_get_nsig ( int algorithm ) {\n gcry_module_t pubkey ;\n int nsig = 0 ;\n REGISTER_DEFAULT_PUBKEYS ;\n ath_mutex_lock ( & pubkeys_registered_lock ) ;\n pubkey = _gcry_module_lookup_id ( pubkeys_registered , algorithm ) ;\n if ( pubkey ) {\n nsig = strlen ( ( ( gcry_pk_spec_t * ) pubkey -> spec ) -> elements_sig ) ;\n _gcry_module_release ( pubkey ) ;\n }\n ath_mutex_unlock ( & pubkeys_registered_lock ) ;\n return nsig ;\n }",
        "output": "0",
        "idx": 1529
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void free_grant_table ( GRANT_TABLE * grant_table ) {\n hash_free ( & grant_table -> hash_columns ) ;\n }",
        "output": "0",
        "idx": 3225
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static xmlLinkPtr xmlListLowerSearch ( xmlListPtr l , void * data ) {\n xmlLinkPtr lk ;\n if ( l == NULL ) return ( NULL ) ;\n for ( lk = l -> sentinel -> next ;\n lk != l -> sentinel && l -> linkCompare ( lk -> data , data ) < 0 ;\n lk = lk -> next ) ;\n return lk ;\n }",
        "output": "1",
        "idx": 2995
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int raster_block_offset ( BLOCK_SIZE plane_bsize , int raster_block , int stride ) {\n const int bw = b_width_log2 ( plane_bsize ) ;\n const int y = 4 * ( raster_block >> bw ) ;\n const int x = 4 * ( raster_block & ( ( 1 << bw ) - 1 ) ) ;\n return y * stride + x ;\n }",
        "output": "0",
        "idx": 20
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fd_list_add ( struct FrameData * * list , struct FrameData * layer_data ) {\n struct FrameData * * p = list ;\n while ( * p != NULL ) p = & ( * p ) -> next ;\n * p = layer_data ;\n layer_data -> next = NULL ;\n }",
        "output": "1",
        "idx": 2201
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void min_heap_dtor ( min_heap_t * s ) {\n free ( s -> p ) ;\n }",
        "output": "1",
        "idx": 3366
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static GList * get_file_list_for_launch_locations ( GList * locations ) {\n GList * files , * l ;\n LaunchLocation * location ;\n files = NULL ;\n for ( l = locations ;\n l != NULL ;\n l = l -> next ) {\n location = l -> data ;\n files = g_list_prepend ( files , nautilus_file_ref ( location -> file ) ) ;\n }\n return g_list_reverse ( files ) ;\n }",
        "output": "0",
        "idx": 2132
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE cState_s_allocate ( VALUE klass ) {\n JSON_Generator_State * state ;\n return TypedData_Make_Struct ( klass , JSON_Generator_State , & JSON_Generator_State_type , state ) ;\n }",
        "output": "0",
        "idx": 2060
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sig_message_join ( SERVER_REC * server , const char * channel , const char * nick , const char * address ) {\n CHANNEL_REC * chanrec ;\n chanrec = channel_find ( server , channel ) ;\n if ( chanrec != NULL ) CHANNEL_LAST_MSG_ADD ( chanrec , nick , FALSE ) ;\n }",
        "output": "1",
        "idx": 2171
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool config_filter_match_local_name ( const struct config_filter * mask , const char * filter_local_name ) {\n const char * const * local_name = t_strsplit_spaces ( mask -> local_name , \" \" ) ;\n for ( ;\n * local_name != NULL ;\n local_name ++ ) {\n if ( dns_match_wildcard ( filter_local_name , * local_name ) == 0 ) return TRUE ;\n }\n return FALSE ;\n }",
        "output": "0",
        "idx": 3578
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void filter_channel ( MLPDecodeContext * m , unsigned int substr , unsigned int channel ) {\n SubStream * s = & m -> substream [ substr ] ;\n const int32_t * fircoeff = s -> channel_params [ channel ] . coeff [ FIR ] ;\n int32_t state_buffer [ NUM_FILTERS ] [ MAX_BLOCKSIZE + MAX_FIR_ORDER ] ;\n int32_t * firbuf = state_buffer [ FIR ] + MAX_BLOCKSIZE ;\n int32_t * iirbuf = state_buffer [ IIR ] + MAX_BLOCKSIZE ;\n FilterParams * fir = & s -> channel_params [ channel ] . filter_params [ FIR ] ;\n FilterParams * iir = & s -> channel_params [ channel ] . filter_params [ IIR ] ;\n unsigned int filter_shift = fir -> shift ;\n int32_t mask = MSB_MASK ( s -> quant_step_size [ channel ] ) ;\n memcpy ( firbuf , fir -> state , MAX_FIR_ORDER * sizeof ( int32_t ) ) ;\n memcpy ( iirbuf , iir -> state , MAX_IIR_ORDER * sizeof ( int32_t ) ) ;\n m -> dsp . mlp_filter_channel ( firbuf , fircoeff , fir -> order , iir -> order , filter_shift , mask , s -> blocksize , & m -> sample_buffer [ s -> blockpos ] [ channel ] ) ;\n memcpy ( fir -> state , firbuf - s -> blocksize , MAX_FIR_ORDER * sizeof ( int32_t ) ) ;\n memcpy ( iir -> state , iirbuf - s -> blocksize , MAX_IIR_ORDER * sizeof ( int32_t ) ) ;\n }",
        "output": "0",
        "idx": 2901
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_iht4x4_16_add_c ( const int16_t * input , uint8_t * dest , int stride , int tx_type ) {\n const transform_2d IHT_4 [ ] = {\n {\n idct4 , idct4 }\n , {\n iadst4 , idct4 }\n , {\n idct4 , iadst4 }\n , {\n iadst4 , iadst4 }\n }\n ;\n int i , j ;\n int16_t out [ 4 * 4 ] ;\n int16_t * outptr = out ;\n int16_t temp_in [ 4 ] , temp_out [ 4 ] ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) {\n IHT_4 [ tx_type ] . rows ( input , outptr ) ;\n input += 4 ;\n outptr += 4 ;\n }\n for ( i = 0 ;\n i < 4 ;\n ++ i ) {\n for ( j = 0 ;\n j < 4 ;\n ++ j ) temp_in [ j ] = out [ j * 4 + i ] ;\n IHT_4 [ tx_type ] . cols ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 4 ;\n ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 4 ) + dest [ j * stride + i ] ) ;\n }\n }",
        "output": "1",
        "idx": 1534
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void handle_raw_login ( char * packet , int len , struct query * q , int fd , int userid ) {\n char myhash [ 16 ] ;\n if ( len < 16 ) return ;\n if ( userid < 0 || userid >= created_users ) return ;\n if ( ! users [ userid ] . active || users [ userid ] . disabled ) return ;\n if ( users [ userid ] . last_pkt + 60 < time ( NULL ) ) return ;\n if ( debug >= 1 ) {\n fprintf ( stderr , \"IN login raw, len %d, from user %d\\n\" , len , userid ) ;\n }\n login_calculate ( myhash , 16 , password , users [ userid ] . seed + 1 ) ;\n if ( memcmp ( packet , myhash , 16 ) == 0 ) {\n struct sockaddr_in * tempin ;\n users [ userid ] . last_pkt = time ( NULL ) ;\n memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n tempin = ( struct sockaddr_in * ) & ( q -> from ) ;\n memcpy ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;\n user_set_conn_type ( userid , CONN_RAW_UDP ) ;\n login_calculate ( myhash , 16 , password , users [ userid ] . seed - 1 ) ;\n send_raw ( fd , myhash , 16 , userid , RAW_HDR_CMD_LOGIN , q ) ;\n }\n }",
        "output": "1",
        "idx": 1743
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( RegisterProtocolHandlerBrowserTest , ContextMenuEntryAppearsForHandledUrls ) {\n scoped_ptr < TestRenderViewContextMenu > menu ( CreateContextMenu ( GURL ( \"http://www.google.com/\" ) ) ) ;\n ASSERT_FALSE ( menu -> IsItemPresent ( IDC_CONTENT_CONTEXT_OPENLINKWITH ) ) ;\n AddProtocolHandler ( std : : string ( \"web+search\" ) , GURL ( \"http://www.google.com/%s\" ) , base : : UTF8ToUTF16 ( std : : string ( \"Test handler\" ) ) ) ;\n GURL url ( \"web+search:testing\" ) ;\n ProtocolHandlerRegistry * registry = ProtocolHandlerRegistryFactory : : GetForProfile ( browser ( ) -> profile ( ) ) ;\n ASSERT_EQ ( 1u , registry -> GetHandlersFor ( url . scheme ( ) ) . size ( ) ) ;\n menu . reset ( CreateContextMenu ( url ) ) ;\n ASSERT_TRUE ( menu -> IsItemPresent ( IDC_CONTENT_CONTEXT_OPENLINKWITH ) ) ;\n }",
        "output": "1",
        "idx": 3655
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void free_pred_buffer ( PRED_BUFFER * p ) {\n if ( p != NULL ) p -> in_use = 0 ;\n }",
        "output": "1",
        "idx": 2192
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int evutil_make_socket_nonblocking ( int fd ) {\n # ifdef WIN32 {\n unsigned long nonblocking = 1 ;\n ioctlsocket ( fd , FIONBIO , ( unsigned long * ) & nonblocking ) ;\n }\n # else if ( fcntl ( fd , F_SETFL , O_NONBLOCK ) == - 1 ) {\n event_warn ( \"fcntl(O_NONBLOCK)\" ) ;\n return - 1 ;\n }\n # endif return 0 ;\n }",
        "output": "1",
        "idx": 3678
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean is_link_trusted ( NautilusFile * file , gboolean is_launcher ) {\n GFile * location ;\n gboolean res ;\n if ( ! is_launcher ) {\n return TRUE ;\n }\n if ( nautilus_file_can_execute ( file ) ) {\n return TRUE ;\n }\n res = FALSE ;\n if ( nautilus_file_is_local ( file ) ) {\n location = nautilus_file_get_location ( file ) ;\n res = nautilus_is_in_system_dir ( location ) ;\n g_object_unref ( location ) ;\n }\n return res ;\n }",
        "output": "1",
        "idx": 2552
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_encode_sb ( MACROBLOCK * x , BLOCK_SIZE bsize ) {\n MACROBLOCKD * const xd = & x -> e_mbd ;\n struct optimize_ctx ctx ;\n MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ;\n struct encode_b_args arg = {\n x , & ctx , & mbmi -> skip }\n ;\n int plane ;\n for ( plane = 0 ;\n plane < MAX_MB_PLANE ;\n ++ plane ) {\n if ( ! x -> skip_recode ) vp9_subtract_plane ( x , bsize , plane ) ;\n if ( x -> optimize && ( ! x -> skip_recode || ! x -> skip_optimize ) ) {\n const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;\n const TX_SIZE tx_size = plane ? get_uv_tx_size ( mbmi , pd ) : mbmi -> tx_size ;\n vp9_get_entropy_contexts ( bsize , tx_size , pd , ctx . ta [ plane ] , ctx . tl [ plane ] ) ;\n }\n vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , encode_block , & arg ) ;\n }\n }",
        "output": "1",
        "idx": 1225
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fdct4 ( const int16_t * input , int16_t * output ) {\n int16_t step [ 4 ] ;\n int temp1 , temp2 ;\n step [ 0 ] = input [ 0 ] + input [ 3 ] ;\n step [ 1 ] = input [ 1 ] + input [ 2 ] ;\n step [ 2 ] = input [ 1 ] - input [ 2 ] ;\n step [ 3 ] = input [ 0 ] - input [ 3 ] ;\n temp1 = ( step [ 0 ] + step [ 1 ] ) * cospi_16_64 ;\n temp2 = ( step [ 0 ] - step [ 1 ] ) * cospi_16_64 ;\n output [ 0 ] = fdct_round_shift ( temp1 ) ;\n output [ 2 ] = fdct_round_shift ( temp2 ) ;\n temp1 = step [ 2 ] * cospi_24_64 + step [ 3 ] * cospi_8_64 ;\n temp2 = - step [ 2 ] * cospi_8_64 + step [ 3 ] * cospi_24_64 ;\n output [ 1 ] = fdct_round_shift ( temp1 ) ;\n output [ 3 ] = fdct_round_shift ( temp2 ) ;\n }",
        "output": "1",
        "idx": 4227
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int _warc_read ( struct archive_read * a , const void * * buf , size_t * bsz , int64_t * off ) {\n struct warc_s * w = a -> format -> data ;\n const char * rab ;\n ssize_t nrd ;\n if ( w -> cntoff >= w -> cntlen ) {\n eof : * buf = NULL ;\n * bsz = 0U ;\n * off = w -> cntoff + 4U ;\n w -> unconsumed = 0U ;\n return ( ARCHIVE_EOF ) ;\n }\n rab = __archive_read_ahead ( a , 1U , & nrd ) ;\n if ( nrd < 0 ) {\n * bsz = 0U ;\n return ( int ) nrd ;\n }\n else if ( nrd == 0 ) {\n goto eof ;\n }\n else if ( ( size_t ) nrd > w -> cntlen - w -> cntoff ) {\n nrd = w -> cntlen - w -> cntoff ;\n }\n * off = w -> cntoff ;\n * bsz = nrd ;\n * buf = rab ;\n w -> cntoff += nrd ;\n w -> unconsumed = ( size_t ) nrd ;\n return ( ARCHIVE_OK ) ;\n }",
        "output": "1",
        "idx": 4153
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int64_t rd_sbuv_dcpred ( const VP9_COMP * cpi , MACROBLOCK * x , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize ) {\n const VP9_COMMON * cm = & cpi -> common ;\n int64_t unused ;\n x -> e_mbd . mi [ 0 ] . src_mi -> mbmi . uv_mode = DC_PRED ;\n super_block_uvrd ( cpi , x , rate_tokenonly , distortion , skippable , & unused , bsize , INT64_MAX ) ;\n * rate = * rate_tokenonly + cpi -> intra_uv_mode_cost [ cm -> frame_type ] [ DC_PRED ] ;\n return RDCOST ( x -> rdmult , x -> rddiv , * rate , * distortion ) ;\n }",
        "output": "0",
        "idx": 1758
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipvideo_decode_block_opcode_0x4 ( IpvideoContext * s ) {\n int x , y ;\n unsigned char B , BL , BH ;\n if ( ! s -> is_16bpp ) {\n B = bytestream2_get_byte ( & s -> stream_ptr ) ;\n }\n else {\n B = bytestream2_get_byte ( & s -> mv_ptr ) ;\n }\n BL = B & 0x0F ;\n BH = ( B >> 4 ) & 0x0F ;\n x = - 8 + BL ;\n y = - 8 + BH ;\n av_dlog ( NULL , \" motion byte = %d, (x, y) = (%d, %d)\\n\" , B , x , y ) ;\n return copy_from ( s , & s -> last_frame , x , y ) ;\n }",
        "output": "1",
        "idx": 3263
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void proto_reg_handoff_dcerpc_spoolss ( void ) {\n dcerpc_init_uuid ( proto_dcerpc_spoolss , ett_dcerpc_spoolss , & uuid_dcerpc_spoolss , ver_dcerpc_spoolss , dcerpc_spoolss_dissectors , hf_opnum ) ;\n }",
        "output": "0",
        "idx": 811
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t u_printf_char_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n UChar s [ U16_MAX_LENGTH + 1 ] ;\n int32_t len = 1 , written ;\n unsigned char arg = ( unsigned char ) ( args [ 0 ] . int64Value ) ;\n ufmt_defaultCPToUnicode ( ( const char * ) & arg , 2 , s , UPRV_LENGTHOF ( s ) ) ;\n if ( arg != 0 ) {\n len = u_strlen ( s ) ;\n }\n written = handler -> pad_and_justify ( context , info , s , len ) ;\n return written ;\n }",
        "output": "1",
        "idx": 2297
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static xsltAttrVTPtr xsltSetAttrVTsegment ( xsltAttrVTPtr avt , void * val ) {\n if ( avt -> nb_seg >= avt -> max_seg ) {\n avt = ( xsltAttrVTPtr ) xmlRealloc ( avt , sizeof ( xsltAttrVT ) + avt -> max_seg * sizeof ( void * ) ) ;\n if ( avt == NULL ) {\n return NULL ;\n }\n memset ( & avt -> segments [ avt -> nb_seg ] , 0 , MAX_AVT_SEG * sizeof ( void * ) ) ;\n avt -> max_seg += MAX_AVT_SEG ;\n }\n avt -> segments [ avt -> nb_seg ++ ] = val ;\n return avt ;\n }",
        "output": "1",
        "idx": 122
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * shorten_utf8_string ( const char * base , int reduce_by_num_bytes ) {\n int len ;\n char * ret ;\n const char * p ;\n len = strlen ( base ) ;\n len -= reduce_by_num_bytes ;\n if ( len <= 0 ) {\n return NULL ;\n }\n ret = g_new ( char , len + 1 ) ;\n p = base ;\n while ( len ) {\n char * next ;\n next = g_utf8_next_char ( p ) ;\n if ( next - p > len || * next == '\\0' ) {\n break ;\n }\n len -= next - p ;\n p = next ;\n }\n if ( p - base == 0 ) {\n g_free ( ret ) ;\n return NULL ;\n }\n else {\n memcpy ( ret , base , p - base ) ;\n ret [ p - base ] = '\\0' ;\n return ret ;\n }\n }",
        "output": "0",
        "idx": 1044
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const DataHeader * offsetTOCLookupFn ( const UDataMemory * pData , const char * tocEntryName , int32_t * pLength , UErrorCode * pErrorCode ) {\n const UDataOffsetTOC * toc = ( UDataOffsetTOC * ) pData -> toc ;\n if ( toc != NULL ) {\n const char * base = ( const char * ) toc ;\n int32_t number , count = ( int32_t ) toc -> count ;\n # if defined ( UDATA_DEBUG_DUMP ) for ( number = 0 ;\n number < count ;\n ++ number ) {\n fprintf ( stderr , \"\\tx%d: %s\\n\" , number , & base [ toc -> entry [ number ] . nameOffset ] ) ;\n }\n # endif number = offsetTOCPrefixBinarySearch ( tocEntryName , base , toc -> entry , count ) ;\n if ( number >= 0 ) {\n const UDataOffsetTOCEntry * entry = toc -> entry + number ;\n # ifdef UDATA_DEBUG fprintf ( stderr , \"%s: Found.\\n\" , tocEntryName ) ;\n # endif if ( ( number + 1 ) < count ) {\n * pLength = ( int32_t ) ( entry [ 1 ] . dataOffset - entry -> dataOffset ) ;\n }\n else {\n * pLength = - 1 ;\n }\n return ( const DataHeader * ) ( base + entry -> dataOffset ) ;\n }\n else {\n # ifdef UDATA_DEBUG fprintf ( stderr , \"%s: Not found.\\n\" , tocEntryName ) ;\n # endif return NULL ;\n }\n }\n else {\n # ifdef UDATA_DEBUG fprintf ( stderr , \"returning header\\n\" ) ;\n # endif return pData -> pHeader ;\n }\n }",
        "output": "1",
        "idx": 1157
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vp9_rc_bits_per_mb ( FRAME_TYPE frame_type , int qindex , double correction_factor ) {\n const double q = vp9_convert_qindex_to_q ( qindex ) ;\n int enumerator = frame_type == KEY_FRAME ? 3300000 : 2250000 ;\n enumerator += ( int ) ( enumerator * q ) >> 12 ;\n return ( int ) ( enumerator * correction_factor / q ) ;\n }",
        "output": "1",
        "idx": 629
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void * xmlListSearch ( xmlListPtr l , void * data ) {\n xmlLinkPtr lk ;\n if ( l == NULL ) return ( NULL ) ;\n lk = xmlListLinkSearch ( l , data ) ;\n if ( lk ) return ( lk -> data ) ;\n return NULL ;\n }",
        "output": "1",
        "idx": 670
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void free_h225_info ( gpointer p ) {\n h323_calls_info_t * tmp_h323info = ( h323_calls_info_t * ) p ;\n DUMP_PTR2 ( tmp_h323info -> guid ) ;\n g_free ( tmp_h323info -> guid ) ;\n if ( tmp_h323info -> h245_list ) {\n GList * list2 = g_list_first ( tmp_h323info -> h245_list ) ;\n while ( list2 ) {\n h245_address_t * h245_add = ( h245_address_t * ) list2 -> data ;\n g_free ( ( void * ) h245_add -> h245_address . data ) ;\n g_free ( list2 -> data ) ;\n list2 = g_list_next ( list2 ) ;\n }\n g_list_free ( tmp_h323info -> h245_list ) ;\n }\n g_free ( p ) ;\n }",
        "output": "0",
        "idx": 2785
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int auth_server_input_done ( struct auth_server_connection * conn ) {\n if ( array_count ( & conn -> available_auth_mechs ) == 0 ) {\n i_error ( \"BUG: Authentication server returned no mechanisms\" ) ;\n return - 1 ;\n }\n if ( conn -> cookie == NULL ) {\n i_error ( \"BUG: Authentication server didn't send a cookie\" ) ;\n return - 1 ;\n }\n timeout_remove ( & conn -> to ) ;\n conn -> handshake_received = TRUE ;\n if ( conn -> client -> connect_notify_callback != NULL ) {\n conn -> client -> connect_notify_callback ( conn -> client , TRUE , conn -> client -> connect_notify_context ) ;\n }\n return 0 ;\n }",
        "output": "0",
        "idx": 2046
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( RegisterProtocolHandlerBrowserTest , CustomHandler ) {\n ASSERT_TRUE ( test_server ( ) -> Start ( ) ) ;\n GURL handler_url = test_server ( ) -> GetURL ( \"files/custom_handler_foo.html\" ) ;\n AddProtocolHandler ( \"foo\" , handler_url , base : : UTF8ToUTF16 ( std : : string ( \"Test foo Handler\" ) ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , GURL ( \"foo:test\" ) ) ;\n ASSERT_EQ ( handler_url , browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) -> GetURL ( ) ) ;\n }",
        "output": "1",
        "idx": 431
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_result_width ( MYSQL_RES * result ) {\n unsigned int len = 0 ;\n MYSQL_FIELD * field ;\n MYSQL_FIELD_OFFSET offset ;\n # ifndef DBUG_OFF offset = mysql_field_tell ( result ) ;\n DBUG_ASSERT ( offset == 0 ) ;\n # else offset = 0 ;\n # endif while ( ( field = mysql_fetch_field ( result ) ) != NULL ) len += get_field_disp_length ( field ) + 3 ;\n ( void ) mysql_field_seek ( result , offset ) ;\n return len + 1 ;\n }",
        "output": "0",
        "idx": 4415
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int truemotion1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int ret , buf_size = avpkt -> size ;\n TrueMotion1Context * s = avctx -> priv_data ;\n s -> buf = buf ;\n s -> size = buf_size ;\n if ( ( ret = truemotion1_decode_header ( s ) ) < 0 ) return ret ;\n s -> frame . reference = 1 ;\n s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( compression_types [ s -> compression ] . algorithm == ALGO_RGB24H ) {\n truemotion1_decode_24bit ( s ) ;\n }\n else if ( compression_types [ s -> compression ] . algorithm != ALGO_NOP ) {\n truemotion1_decode_16bit ( s ) ;\n }\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return buf_size ;\n }",
        "output": "1",
        "idx": 3957
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ctl_putarray ( const char * tag , double * arr , int start ) {\n register char * cp ;\n register const char * cq ;\n char buffer [ 200 ] ;\n int i ;\n cp = buffer ;\n cq = tag ;\n while ( * cq != '\\0' ) * cp ++ = * cq ++ ;\n * cp ++ = '=' ;\n i = start ;\n do {\n if ( i == 0 ) i = NTP_SHIFT ;\n i -- ;\n INSIST ( ( cp - buffer ) < ( int ) sizeof ( buffer ) ) ;\n snprintf ( cp , sizeof ( buffer ) - ( cp - buffer ) , \" %.2f\" , arr [ i ] * 1e3 ) ;\n cp += strlen ( cp ) ;\n }\n while ( i != start ) ;\n ctl_putdata ( buffer , ( unsigned ) ( cp - buffer ) , 0 ) ;\n }",
        "output": "0",
        "idx": 3145
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool intel_pt_enable_needed ( void * opaque ) {\n X86CPU * cpu = opaque ;\n CPUX86State * env = & cpu -> env ;\n int i ;\n if ( env -> msr_rtit_ctrl || env -> msr_rtit_status || env -> msr_rtit_output_base || env -> msr_rtit_output_mask || env -> msr_rtit_cr3_match ) {\n return true ;\n }\n for ( i = 0 ;\n i < MAX_RTIT_ADDRS ;\n i ++ ) {\n if ( env -> msr_rtit_addrs [ i ] ) {\n return true ;\n }\n }\n return false ;\n }",
        "output": "0",
        "idx": 4405
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void link_task_done ( GObject * source_object , GAsyncResult * res , gpointer user_data ) {\n CopyMoveJob * job ;\n job = user_data ;\n if ( job -> done_callback ) {\n job -> done_callback ( job -> debuting_files , ! job_aborted ( ( CommonJob * ) job ) , job -> done_callback_data ) ;\n }\n g_list_free_full ( job -> files , g_object_unref ) ;\n g_object_unref ( job -> destination ) ;\n g_hash_table_unref ( job -> debuting_files ) ;\n g_free ( job -> icon_positions ) ;\n finalize_common ( ( CommonJob * ) job ) ;\n nautilus_file_changes_consume_changes ( TRUE ) ;\n }",
        "output": "0",
        "idx": 3590
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main ( int argc ATTRIBUTE_UNUSED , char * * argv ATTRIBUTE_UNUSED ) {\n printf ( \"%s : Automata support not compiled in\\n\" , argv [ 0 ] ) ;\n return ( 0 ) ;\n }",
        "output": "0",
        "idx": 4146
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void process_gitlink ( struct rev_info * revs , const unsigned char * sha1 , show_object_fn show , struct name_path * path , const char * name , void * cb_data ) {\n }",
        "output": "1",
        "idx": 3542
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_cmd ( xd3_stream * stream , const char * buf ) {\n int ret ;\n if ( ( ret = system ( buf ) ) != 0 ) {\n if ( WIFEXITED ( ret ) ) {\n stream -> msg = \"command exited non-zero\" ;\n IF_DEBUG1 ( XPR ( NT \"command was: %s\\n\" , buf ) ) ;\n }\n else {\n stream -> msg = \"abnormal command termination\" ;\n }\n return XD3_INTERNAL ;\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 3279
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gsm_a_sacch_rr_stat_init ( new_stat_tap_ui * new_stat , new_stat_tap_gui_init_cb gui_callback , void * gui_data ) {\n gsm_a_stat_init ( new_stat , gui_callback , gui_data , \"GSM A-I/F SACCH Statistics\" , gsm_a_rr_short_pd_msg_strings ) ;\n }",
        "output": "0",
        "idx": 1253
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int check_authenticated_user_and_ip ( int userid , struct query * q ) {\n int res = check_user_and_ip ( userid , q ) ;\n if ( res ) return res ;\n if ( ! users [ userid ] . authenticated ) return 1 ;\n return 0 ;\n }",
        "output": "0",
        "idx": 3962
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int get_current_cpu ( ARMMPTimerState * s ) {\n CPUState * cpu_single_cpu = ENV_GET_CPU ( cpu_single_env ) ;\n if ( cpu_single_cpu -> cpu_index >= s -> num_cpu ) {\n hw_error ( \"arm_mptimer: num-cpu %d but this cpu is %d!\\n\" , s -> num_cpu , cpu_single_cpu -> cpu_index ) ;\n }\n return cpu_single_cpu -> cpu_index ;\n }",
        "output": "1",
        "idx": 2186
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void Pass2Encode ( VP9_COMP * cpi , size_t * size , uint8_t * dest , unsigned int * frame_flags ) {\n cpi -> allow_encode_breakout = ENCODE_BREAKOUT_ENABLED ;\n vp9_rc_get_second_pass_params ( cpi ) ;\n encode_frame_to_data_rate ( cpi , size , dest , frame_flags ) ;\n vp9_twopass_postencode_update ( cpi ) ;\n }",
        "output": "1",
        "idx": 4217
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void build_config ( char * prefix , struct server * server ) {\n char * path = NULL ;\n int path_size = strlen ( prefix ) + strlen ( server -> port ) + 20 ;\n path = ss_malloc ( path_size ) ;\n snprintf ( path , path_size , \"%s/.shadowsocks_%s.conf\" , prefix , server -> port ) ;\n FILE * f = fopen ( path , \"w+\" ) ;\n if ( f == NULL ) {\n if ( verbose ) {\n LOGE ( \"unable to open config file\" ) ;\n }\n ss_free ( path ) ;\n return ;\n }\n fprintf ( f , \"{\n\\n\" ) ;\n fprintf ( f , \"\\\"server_port\\\":%d,\\n\" , atoi ( server -> port ) ) ;\n fprintf ( f , \"\\\"password\\\":\\\"%s\\\"\" , server -> password ) ;\n if ( server -> fast_open [ 0 ] ) fprintf ( f , \",\\n\\\"fast_open\\\": %s\" , server -> fast_open ) ;\n if ( server -> mode ) fprintf ( f , \",\\n\\\"mode\\\":\\\"%s\\\"\" , server -> mode ) ;\n if ( server -> method ) fprintf ( f , \",\\n\\\"method\\\":\\\"%s\\\"\" , server -> method ) ;\n if ( server -> plugin ) fprintf ( f , \",\\n\\\"plugin\\\":\\\"%s\\\"\" , server -> plugin ) ;\n if ( server -> plugin_opts ) fprintf ( f , \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\" , server -> plugin_opts ) ;\n fprintf ( f , \"\\n}\n\\n\" ) ;\n fclose ( f ) ;\n ss_free ( path ) ;\n }",
        "output": "1",
        "idx": 2749
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sbr_reset ( AACContext * ac , SpectralBandReplication * sbr ) {\n int err ;\n err = sbr_make_f_master ( ac , sbr , & sbr -> spectrum_params ) ;\n if ( err >= 0 ) err = sbr_make_f_derived ( ac , sbr ) ;\n if ( err < 0 ) {\n av_log ( ac -> avctx , AV_LOG_ERROR , \"SBR reset failed. Switching SBR to pure upsampling mode.\\n\" ) ;\n sbr_turnoff ( sbr ) ;\n }\n }",
        "output": "1",
        "idx": 140
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void proto_reg_handoff_zbee_zcl_identify ( void ) {\n dissector_handle_t identify_handle ;\n identify_handle = find_dissector ( ZBEE_PROTOABBREV_ZCL_IDENTIFY ) ;\n dissector_add_uint ( \"zbee.zcl.cluster\" , ZBEE_ZCL_CID_IDENTIFY , identify_handle ) ;\n zbee_zcl_init_cluster ( proto_zbee_zcl_identify , ett_zbee_zcl_identify , ZBEE_ZCL_CID_IDENTIFY , hf_zbee_zcl_identify_attr_id , hf_zbee_zcl_identify_srv_rx_cmd_id , hf_zbee_zcl_identify_srv_tx_cmd_id , ( zbee_zcl_fn_attr_data ) dissect_zcl_identify_attr_data ) ;\n }",
        "output": "0",
        "idx": 2875
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void proto_reg_handoff_zbee_zcl_appl_stats ( void ) {\n dissector_handle_t appl_stats_handle ;\n appl_stats_handle = find_dissector ( ZBEE_PROTOABBREV_ZCL_APPLSTATS ) ;\n dissector_add_uint ( \"zbee.zcl.cluster\" , ZBEE_ZCL_CID_APPLIANCE_STATISTICS , appl_stats_handle ) ;\n zbee_zcl_init_cluster ( proto_zbee_zcl_appl_stats , ett_zbee_zcl_appl_stats , ZBEE_ZCL_CID_APPLIANCE_STATISTICS , hf_zbee_zcl_appl_stats_attr_id , hf_zbee_zcl_appl_stats_srv_rx_cmd_id , hf_zbee_zcl_appl_stats_srv_tx_cmd_id , NULL ) ;\n }",
        "output": "0",
        "idx": 157
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pdf_xobject * pdf_load_xobject ( fz_context * ctx , pdf_document * doc , pdf_obj * dict ) {\n pdf_xobject * form ;\n if ( ( form = pdf_find_item ( ctx , pdf_drop_xobject_imp , dict ) ) != NULL ) return form ;\n form = fz_malloc_struct ( ctx , pdf_xobject ) ;\n FZ_INIT_STORABLE ( form , 1 , pdf_drop_xobject_imp ) ;\n form -> obj = NULL ;\n form -> iteration = 0 ;\n pdf_store_item ( ctx , dict , form , pdf_xobject_size ( form ) ) ;\n form -> obj = pdf_keep_obj ( ctx , dict ) ;\n return form ;\n }",
        "output": "1",
        "idx": 2383
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void remoteDispatchCopyError ( remote_error * rerr , virErrorPtr verr ) {\n rerr -> code = verr -> code ;\n rerr -> domain = verr -> domain ;\n rerr -> message = verr -> message ? malloc ( sizeof ( char * ) ) : NULL ;\n if ( rerr -> message ) * rerr -> message = strdup ( verr -> message ) ;\n rerr -> level = verr -> level ;\n rerr -> str1 = verr -> str1 ? malloc ( sizeof ( char * ) ) : NULL ;\n if ( rerr -> str1 ) * rerr -> str1 = strdup ( verr -> str1 ) ;\n rerr -> str2 = verr -> str2 ? malloc ( sizeof ( char * ) ) : NULL ;\n if ( rerr -> str2 ) * rerr -> str2 = strdup ( verr -> str2 ) ;\n rerr -> str3 = verr -> str3 ? malloc ( sizeof ( char * ) ) : NULL ;\n if ( rerr -> str3 ) * rerr -> str3 = strdup ( verr -> str3 ) ;\n rerr -> int1 = verr -> int1 ;\n rerr -> int2 = verr -> int2 ;\n }",
        "output": "0",
        "idx": 1587
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char * TSUrlSchemeGet ( TSMBuffer bufp , TSMLoc obj , int * length ) {\n return URLPartGet ( bufp , obj , length , & URL : : scheme_get ) ;\n }",
        "output": "0",
        "idx": 3112
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hb_unicode_funcs_t * hb_icu_get_unicode_funcs ( void ) {\n static const hb_unicode_funcs_t _hb_icu_unicode_funcs = {\n HB_OBJECT_HEADER_STATIC , NULL , true , {\n # define HB_UNICODE_FUNC_IMPLEMENT ( name ) hb_icu_unicode_ ## name , HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS # undef HB_UNICODE_FUNC_IMPLEMENT }\n }\n ;\n # if U_ICU_VERSION_MAJOR_NUM >= 49 if ( ! hb_atomic_ptr_get ( & normalizer ) ) {\n UErrorCode icu_err = U_ZERO_ERROR ;\n hb_atomic_ptr_cmpexch ( & normalizer , NULL , unorm2_getNFCInstance ( & icu_err ) ) ;\n }\n # endif return const_cast < hb_unicode_funcs_t * > ( & _hb_icu_unicode_funcs ) ;\n }",
        "output": "1",
        "idx": 2572
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , ClosedWhileHidden_Http ) {\n StartHttpServer ( ) ;\n base : : TimeDelta upper_bound = NavigateInForegroundAndCloseInBackgroundWithTiming ( http_test_server_ -> GetURL ( \"/simple.html\" ) ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;\n int32_t bucket_min = histogram_tester_ . GetAllSamples ( internal : : kHttpEngagementHistogram ) [ 0 ] . min ;\n EXPECT_GE ( upper_bound . InMilliseconds ( ) , bucket_min ) ;\n EXPECT_LT ( 0 , bucket_min ) ;\n }",
        "output": "1",
        "idx": 2461
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Entity * EntityCreate ( SplinePointList * head , int linecap , int linejoin , real linewidth , real * transform , SplineSet * clippath ) {\n Entity * ent = calloc ( 1 , sizeof ( Entity ) ) ;\n ent -> type = et_splines ;\n ent -> u . splines . splines = head ;\n ent -> u . splines . cap = linecap ;\n ent -> u . splines . join = linejoin ;\n ent -> u . splines . stroke_width = linewidth ;\n ent -> u . splines . fill . col = 0xffffffff ;\n ent -> u . splines . stroke . col = 0xffffffff ;\n ent -> u . splines . fill . opacity = 1.0 ;\n ent -> u . splines . stroke . opacity = 1.0 ;\n ent -> clippath = SplinePointListCopy ( clippath ) ;\n memcpy ( ent -> u . splines . transform , transform , 6 * sizeof ( real ) ) ;\n return ( ent ) ;\n }",
        "output": "0",
        "idx": 409
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static TX_SIZE read_tx_size ( VP9_COMMON * cm , MACROBLOCKD * xd , TX_MODE tx_mode , BLOCK_SIZE bsize , int allow_select , vp9_reader * r ) {\n const TX_SIZE max_tx_size = max_txsize_lookup [ bsize ] ;\n if ( allow_select && tx_mode == TX_MODE_SELECT && bsize >= BLOCK_8X8 ) return read_selected_tx_size ( cm , xd , max_tx_size , r ) ;\n else return MIN ( max_tx_size , tx_mode_to_biggest_tx_size [ tx_mode ] ) ;\n }",
        "output": "0",
        "idx": 3054
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileInfo , getPathInfo ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n zend_class_entry * ce = intern -> info_class ;\n zend_error_handling error_handling ;\n zend_replace_error_handling ( EH_THROW , spl_ce_UnexpectedValueException , & error_handling TSRMLS_CC ) ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"|C\" , & ce ) == SUCCESS ) {\n int path_len ;\n char * path = spl_filesystem_object_get_pathname ( intern , & path_len TSRMLS_CC ) ;\n if ( path ) {\n char * dpath = estrndup ( path , path_len ) ;\n path_len = php_dirname ( dpath , path_len ) ;\n spl_filesystem_object_create_info ( intern , dpath , path_len , 1 , ce , return_value TSRMLS_CC ) ;\n efree ( dpath ) ;\n }\n }\n zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;\n }",
        "output": "1",
        "idx": 3471
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static vpx_codec_err_t ctrl_set_svc_parameters ( vpx_codec_alg_priv_t * ctx , va_list args ) {\n VP9_COMP * const cpi = ctx -> cpi ;\n vpx_svc_extra_cfg_t * const params = va_arg ( args , vpx_svc_extra_cfg_t * ) ;\n int i ;\n for ( i = 0 ;\n i < cpi -> svc . number_spatial_layers ;\n ++ i ) {\n LAYER_CONTEXT * lc = & cpi -> svc . layer_context [ i ] ;\n lc -> max_q = params -> max_quantizers [ i ] ;\n lc -> min_q = params -> min_quantizers [ i ] ;\n lc -> scaling_factor_num = params -> scaling_factor_num [ i ] ;\n lc -> scaling_factor_den = params -> scaling_factor_den [ i ] ;\n }\n return VPX_CODEC_OK ;\n }",
        "output": "0",
        "idx": 2017
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , PayloadSizeIgnoresDownloads ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n bool prev_io_allowed = base : : ThreadRestrictions : : SetIOAllowed ( true ) ;\n {\n base : : ScopedTempDir downloads_directory ;\n ASSERT_TRUE ( downloads_directory . CreateUniqueTempDir ( ) ) ;\n browser ( ) -> profile ( ) -> GetPrefs ( ) -> SetFilePath ( prefs : : kDownloadDefaultDirectory , downloads_directory . GetPath ( ) ) ;\n content : : DownloadTestObserverTerminal downloads_observer ( content : : BrowserContext : : GetDownloadManager ( browser ( ) -> profile ( ) ) , 1 , content : : DownloadTestObserver : : ON_DANGEROUS_DOWNLOAD_FAIL ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( \"/page_load_metrics/download_anchor_click.html\" ) ) ;\n downloads_observer . WaitForFinished ( ) ;\n }\n base : : ThreadRestrictions : : SetIOAllowed ( prev_io_allowed ) ;\n NavigateToUntrackedUrl ( ) ;\n histogram_tester_ . ExpectUniqueSample ( internal : : kHistogramPageLoadTotalBytes , 0 , 1 ) ;\n }",
        "output": "1",
        "idx": 1938
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int answer_from_qmem ( int dns_fd , struct query * q , unsigned char * qmem_cmc , unsigned short * qmem_type , int qmem_len , unsigned char * cmc_to_check ) {\n int i ;\n for ( i = 0 ;\n i < qmem_len ;\n i ++ ) {\n if ( qmem_type [ i ] == T_UNSET ) continue ;\n if ( qmem_type [ i ] != q -> type ) continue ;\n if ( memcmp ( qmem_cmc + i * 4 , cmc_to_check , 4 ) ) continue ;\n if ( debug >= 1 ) fprintf ( stderr , \"OUT from qmem for %s == duplicate, sending illegal reply\\n\" , q -> name ) ;\n write_dns ( dns_fd , q , \"x\" , 1 , 'T' ) ;\n q -> id = 0 ;\n return 1 ;\n }\n return 0 ;\n }",
        "output": "0",
        "idx": 393
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "END_TEST START_TEST ( test_find_available_user ) {\n in_addr_t ip ;\n int i ;\n ip = inet_addr ( \"127.0.0.1\" ) ;\n init_users ( ip , 27 ) ;\n for ( i = 0 ;\n i < USERS ;\n i ++ ) {\n fail_unless ( find_available_user ( ) == i ) ;\n }\n for ( i = 0 ;\n i < USERS ;\n i ++ ) {\n fail_unless ( find_available_user ( ) == - 1 ) ;\n }\n users [ 3 ] . active = 0 ;\n fail_unless ( find_available_user ( ) == 3 ) ;\n fail_unless ( find_available_user ( ) == - 1 ) ;\n users [ 3 ] . last_pkt = 55 ;\n fail_unless ( find_available_user ( ) == 3 ) ;\n fail_unless ( find_available_user ( ) == - 1 ) ;\n }",
        "output": "1",
        "idx": 2536
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dissect_h225_TunnelledProtocol ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 748 \"./asn1/h225/h225.cnf\" tpOID = \"\" ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_TunnelledProtocol , TunnelledProtocol_sequence ) ;\n # line 750 \"./asn1/h225/h225.cnf\" tp_handle = dissector_get_string_handle ( tp_dissector_table , tpOID ) ;\n return offset ;\n }",
        "output": "1",
        "idx": 3250
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void untrusted_launcher_response_callback ( GtkDialog * dialog , int response_id , ActivateParametersDesktop * parameters ) {\n GdkScreen * screen ;\n char * uri ;\n GFile * file ;\n switch ( response_id ) {\n case GTK_RESPONSE_OK : {\n file = nautilus_file_get_location ( parameters -> file ) ;\n nautilus_file_set_metadata ( parameters -> file , NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED , NULL , \"yes\" ) ;\n nautilus_file_mark_desktop_file_executable ( file , parameters -> parent_window , TRUE , NULL , NULL ) ;\n nautilus_file_invalidate_all_attributes ( parameters -> file ) ;\n screen = gtk_widget_get_screen ( GTK_WIDGET ( parameters -> parent_window ) ) ;\n uri = nautilus_file_get_uri ( parameters -> file ) ;\n DEBUG ( \"Launching untrusted launcher %s\" , uri ) ;\n nautilus_launch_desktop_file ( screen , uri , NULL , parameters -> parent_window ) ;\n g_free ( uri ) ;\n g_object_unref ( file ) ;\n }\n break ;\n default : {\n }\n break ;\n }\n gtk_widget_destroy ( GTK_WIDGET ( dialog ) ) ;\n activate_parameters_desktop_free ( parameters ) ;\n }",
        "output": "0",
        "idx": 2334
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rtp_add_address ( packet_info * pinfo , address * addr , int port , int other_port , const gchar * setup_method , guint32 setup_frame_number , gboolean is_video , GHashTable * rtp_dyn_payload ) {\n srtp_add_address ( pinfo , addr , port , other_port , setup_method , setup_frame_number , is_video , rtp_dyn_payload , NULL ) ;\n }",
        "output": "1",
        "idx": 4233
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int64_t unix_to_file_time ( int ti ) {\n int64_t t ;\n t = ti * INT64_C ( 10000000 ) ;\n t += INT64_C ( 116444736000000000 ) ;\n return t ;\n }",
        "output": "0",
        "idx": 1801
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "zend_function * spl_filesystem_object_get_method_check ( zval * * object_ptr , char * method , int method_len , const struct _zend_literal * key TSRMLS_DC ) {\n spl_filesystem_object * fsobj = zend_object_store_get_object ( * object_ptr TSRMLS_CC ) ;\n if ( fsobj -> u . dir . entry . d_name [ 0 ] == '\\0' && fsobj -> orig_path == NULL ) {\n method = \"_bad_state_ex\" ;\n method_len = sizeof ( \"_bad_state_ex\" ) - 1 ;\n key = NULL ;\n }\n return zend_get_std_object_handlers ( ) -> get_method ( object_ptr , method , method_len , key TSRMLS_CC ) ;\n }",
        "output": "1",
        "idx": 663
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_fht16x16_c ( const int16_t * input , tran_low_t * output , int stride , int tx_type ) {\n if ( tx_type == DCT_DCT ) {\n vp9_fdct16x16_c ( input , output , stride ) ;\n }\n else {\n tran_low_t out [ 256 ] ;\n tran_low_t * outptr = & out [ 0 ] ;\n int i , j ;\n tran_low_t temp_in [ 16 ] , temp_out [ 16 ] ;\n const transform_2d ht = FHT_16 [ tx_type ] ;\n for ( i = 0 ;\n i < 16 ;\n ++ i ) {\n for ( j = 0 ;\n j < 16 ;\n ++ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ;\n ht . cols ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 16 ;\n ++ j ) outptr [ j * 16 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ;\n }\n for ( i = 0 ;\n i < 16 ;\n ++ i ) {\n for ( j = 0 ;\n j < 16 ;\n ++ j ) temp_in [ j ] = out [ j + i * 16 ] ;\n ht . rows ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 16 ;\n ++ j ) output [ j + i * 16 ] = temp_out [ j ] ;\n }\n }\n }",
        "output": "0",
        "idx": 1001
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t ReadBlobBlock ( Image * image , unsigned char * data ) {\n ssize_t count ;\n unsigned char block_count ;\n assert ( image != ( Image * ) NULL ) ;\n assert ( image -> signature == MagickSignature ) ;\n assert ( data != ( unsigned char * ) NULL ) ;\n count = ReadBlob ( image , 1 , & block_count ) ;\n if ( count != 1 ) return ( 0 ) ;\n count = ReadBlob ( image , ( size_t ) block_count , data ) ;\n if ( count != ( ssize_t ) block_count ) return ( 0 ) ;\n return ( count ) ;\n }",
        "output": "0",
        "idx": 1082
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline const UChar * toUCharPtr ( const char16_t * p ) {\n # ifdef U_ALIASING_BARRIER U_ALIASING_BARRIER ( p ) ;\n # endif return reinterpret_cast < const UChar * > ( p ) ;\n }",
        "output": "1",
        "idx": 2867
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( ExternalProtocolDialogBrowserTest , TestCancelWithChecked ) {\n ShowDialog ( ) ;\n SetChecked ( true ) ;\n EXPECT_TRUE ( dialog_ -> Cancel ( ) ) ;\n EXPECT_TRUE ( called_ ) ;\n EXPECT_FALSE ( accept_ ) ;\n EXPECT_TRUE ( cancel_ ) ;\n EXPECT_TRUE ( dont_block_ ) ;\n histogram_tester_ . ExpectBucketCount ( ExternalProtocolHandler : : kRememberCheckboxMetric , 1 , 1 ) ;\n histogram_tester_ . ExpectBucketCount ( ExternalProtocolHandler : : kHandleStateMetric , ExternalProtocolHandler : : CHECKED_DONT_LAUNCH , 1 ) ;\n }",
        "output": "1",
        "idx": 312
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void erase_screen ( AVCodecContext * avctx ) {\n AnsiContext * s = avctx -> priv_data ;\n int i ;\n for ( i = 0 ;\n i < avctx -> height ;\n i ++ ) memset ( s -> frame . data [ 0 ] + i * s -> frame . linesize [ 0 ] , DEFAULT_BG_COLOR , avctx -> width ) ;\n s -> x = s -> y = 0 ;\n }",
        "output": "1",
        "idx": 3100
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dcc_ctcp_resume_parse ( int type , const char * data , const char * nick , FILE_DCC_REC * * dcc , uoff_t * size , int * pasv_id ) {\n char * * params ;\n int paramcount , fileparams ;\n int port ;\n params = g_strsplit ( data , \" \" , - 1 ) ;\n paramcount = g_strv_length ( params ) ;\n if ( paramcount < 3 ) return 0 ;\n fileparams = get_file_params_count_resume ( params , paramcount ) ;\n if ( paramcount >= fileparams + 2 ) {\n port = atoi ( params [ fileparams ] ) ;\n * size = str_to_uofft ( params [ fileparams + 1 ] ) ;\n * pasv_id = ( ( port == 0 ) && ( paramcount == fileparams + 3 ) ) ? atoi ( params [ fileparams + 2 ] ) : - 1 ;\n * dcc = dcc_resume_find ( type , nick , port ) ;\n g_strfreev ( params ) ;\n return ( ( * dcc != NULL ) && ( ( * dcc ) -> pasv_id == * pasv_id ) ) ;\n }\n g_strfreev ( params ) ;\n return FALSE ;\n }",
        "output": "0",
        "idx": 1780
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipvideo_decode_block_opcode_0x7 ( IpvideoContext * s , AVFrame * frame ) {\n int x , y ;\n unsigned char P [ 2 ] ;\n unsigned int flags ;\n P [ 0 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n P [ 1 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n if ( P [ 0 ] <= P [ 1 ] ) {\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n flags = bytestream2_get_byte ( & s -> stream_ptr ) | 0x100 ;\n for ( ;\n flags != 1 ;\n flags >>= 1 ) * s -> pixel_ptr ++ = P [ flags & 1 ] ;\n s -> pixel_ptr += s -> line_inc ;\n }\n }\n else {\n flags = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n for ( y = 0 ;\n y < 8 ;\n y += 2 ) {\n for ( x = 0 ;\n x < 8 ;\n x += 2 , flags >>= 1 ) {\n s -> pixel_ptr [ x ] = s -> pixel_ptr [ x + 1 ] = s -> pixel_ptr [ x + s -> stride ] = s -> pixel_ptr [ x + 1 + s -> stride ] = P [ flags & 1 ] ;\n }\n s -> pixel_ptr += s -> stride * 2 ;\n }\n }\n return 0 ;\n }",
        "output": "0",
        "idx": 3600
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ztype ( i_ctx_t * i_ctx_p ) {\n os_ptr op = osp ;\n ref tnref ;\n int code = array_get ( imemory , op , ( long ) r_btype ( op - 1 ) , & tnref ) ;\n if ( code < 0 ) return code ;\n if ( ! r_has_type ( & tnref , t_name ) ) {\n check_op ( 2 ) ;\n {\n if ( op [ - 1 ] . value . pstruct != 0x00 ) {\n const char * sname = gs_struct_type_name_string ( gs_object_type ( imemory , op [ - 1 ] . value . pstruct ) ) ;\n int code = name_ref ( imemory , ( const byte * ) sname , strlen ( sname ) , ( ref * ) ( op - 1 ) , 0 ) ;\n if ( code < 0 ) return code ;\n }\n else return_error ( gs_error_stackunderflow ) ;\n }\n r_set_attrs ( op - 1 , a_executable ) ;\n }\n else {\n ref_assign ( op - 1 , & tnref ) ;\n }\n pop ( 1 ) ;\n return 0 ;\n }",
        "output": "1",
        "idx": 720
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void evhttp_connection_done ( struct evhttp_connection * evcon ) {\n struct evhttp_request * req = TAILQ_FIRST ( & evcon -> requests ) ;\n int con_outgoing = evcon -> flags & EVHTTP_CON_OUTGOING ;\n if ( con_outgoing ) {\n int need_close ;\n TAILQ_REMOVE ( & evcon -> requests , req , next ) ;\n req -> evcon = NULL ;\n evcon -> state = EVCON_IDLE ;\n need_close = evhttp_is_connection_close ( req -> flags , req -> input_headers ) || evhttp_is_connection_close ( req -> flags , req -> output_headers ) ;\n if ( need_close ) evhttp_connection_reset ( evcon ) ;\n if ( TAILQ_FIRST ( & evcon -> requests ) != NULL ) {\n if ( ! evhttp_connected ( evcon ) ) evhttp_connection_connect ( evcon ) ;\n else evhttp_request_dispatch ( evcon ) ;\n }\n else if ( ! need_close ) {\n evhttp_connection_start_detectclose ( evcon ) ;\n }\n }\n else {\n evcon -> state = EVCON_WRITING ;\n }\n ( * req -> cb ) ( req , req -> cb_arg ) ;\n if ( con_outgoing ) {\n evhttp_request_free ( req ) ;\n }\n }",
        "output": "1",
        "idx": 4101
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ProtocolHandlerRegistryTest , TestReplaceRemovesStaleHandlers ) {\n ProtocolHandler ph1 = CreateProtocolHandler ( \"mailto\" , GURL ( \"http://test.com/%s\" ) , \"test1\" ) ;\n ProtocolHandler ph2 = CreateProtocolHandler ( \"mailto\" , GURL ( \"http://test.com/updated-url/%s\" ) , \"test2\" ) ;\n ProtocolHandler ph3 = CreateProtocolHandler ( \"mailto\" , GURL ( \"http://test.com/third/%s\" ) , \"test\" ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph2 ) ;\n ASSERT_TRUE ( registry ( ) -> AttemptReplace ( ph3 ) ) ;\n const ProtocolHandler & handler ( registry ( ) -> GetHandlerFor ( \"mailto\" ) ) ;\n ASSERT_EQ ( handler . url ( ) , ph3 . url ( ) ) ;\n registry ( ) -> RemoveHandler ( ph3 ) ;\n ASSERT_TRUE ( registry ( ) -> GetHandlerFor ( \"mailto\" ) . IsEmpty ( ) ) ;\n }",
        "output": "1",
        "idx": 3732
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_execstack ( i_ctx_t * i_ctx_p , bool include_marks , os_ptr op1 ) {\n os_ptr op = osp ;\n ref * arefs = op1 -> value . refs ;\n uint asize = r_size ( op1 ) ;\n uint i ;\n ref * rq ;\n for ( i = 0 , rq = arefs + asize ;\n rq != arefs ;\n ++ i ) {\n const ref * rp = ref_stack_index ( & e_stack , ( long ) i ) ;\n if ( r_has_type_attrs ( rp , t_null , a_executable ) && ! include_marks ) continue ;\n -- rq ;\n ref_assign_old ( op1 , rq , rp , \"execstack\" ) ;\n switch ( r_type ( rq ) ) {\n case t_operator : {\n uint opidx = op_index ( rq ) ;\n if ( opidx == 0 || op_def_is_internal ( op_index_def ( opidx ) ) ) r_clear_attrs ( rq , a_executable ) ;\n break ;\n }\n case t_struct : case t_astruct : {\n const char * tname = rq -> value . pstruct ? gs_struct_type_name_string ( gs_object_type ( imemory , rq -> value . pstruct ) ) : \"NULL\" ;\n make_const_string ( rq , a_readonly | avm_foreign , strlen ( tname ) , ( const byte * ) tname ) ;\n break ;\n }\n default : ;\n }\n }\n pop ( op - op1 ) ;\n return 0 ;\n }",
        "output": "1",
        "idx": 98
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_tokenize_initialize ( ) {\n TOKENVALUE * const t = dct_value_tokens + DCT_MAX_VALUE ;\n const vp9_extra_bit * const e = vp9_extra_bits ;\n int i = - DCT_MAX_VALUE ;\n int sign = 1 ;\n do {\n if ( ! i ) sign = 0 ;\n {\n const int a = sign ? - i : i ;\n int eb = sign ;\n if ( a > 4 ) {\n int j = 4 ;\n while ( ++ j < 11 && e [ j ] . base_val <= a ) {\n }\n t [ i ] . token = -- j ;\n eb |= ( a - e [ j ] . base_val ) << 1 ;\n }\n else {\n t [ i ] . token = a ;\n }\n t [ i ] . extra = eb ;\n }\n {\n int cost = 0 ;\n const vp9_extra_bit * p = & vp9_extra_bits [ t [ i ] . token ] ;\n if ( p -> base_val ) {\n const int extra = t [ i ] . extra ;\n const int length = p -> len ;\n if ( length ) cost += treed_cost ( p -> tree , p -> prob , extra >> 1 , length ) ;\n cost += vp9_cost_bit ( vp9_prob_half , extra & 1 ) ;\n dct_value_cost [ i + DCT_MAX_VALUE ] = cost ;\n }\n }\n }\n while ( ++ i < DCT_MAX_VALUE ) ;\n vp9_dct_value_tokens_ptr = dct_value_tokens + DCT_MAX_VALUE ;\n vp9_dct_value_cost_ptr = dct_value_cost + DCT_MAX_VALUE ;\n }",
        "output": "1",
        "idx": 3647
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int parse_CCoercionRestriction ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , struct CCoercionRestriction * v , const char * fmt , ... ) {\n proto_tree * tree ;\n proto_item * item ;\n const char * txt ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CCoercionRestriction , & item , txt ) ;\n v -> value = tvb_get_letohieee_float ( tvb , offset ) ;\n proto_tree_add_float ( tree , hf_mswsp_ccoercerestrict_value , tvb , offset , 4 , v -> value ) ;\n offset += 4 ;\n offset = parse_CRestriction ( tvb , offset , tree , pad_tree , & v -> child , \"child\" ) ;\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }",
        "output": "1",
        "idx": 2549
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "__attribute__ ( ( format ( printf , 2 , 3 ) ) ) static int cmd_submitf ( int id , const char * fmt , ... ) {\n char cmd [ MAX_EXTERNAL_COMMAND_LENGTH ] ;\n const char * command ;\n int len , len2 ;\n va_list ap ;\n command = extcmd_get_name ( id ) ;\n len = snprintf ( cmd , sizeof ( cmd ) - 1 , \"[%lu] %s;\n\" , time ( NULL ) , command ) ;\n if ( len < 0 ) return ERROR ;\n if ( fmt ) {\n va_start ( ap , fmt ) ;\n len2 = vsnprintf ( & cmd [ len ] , sizeof ( cmd ) - len - 1 , fmt , ap ) ;\n va_end ( ap ) ;\n if ( len2 < 0 ) return ERROR ;\n }\n return write_command_to_file ( cmd ) ;\n }",
        "output": "1",
        "idx": 3831
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void at1_subband_synthesis ( AT1Ctx * q , AT1SUCtx * su , float * pOut ) {\n float temp [ 256 ] ;\n float iqmf_temp [ 512 + 46 ] ;\n ff_atrac_iqmf ( q -> bands [ 0 ] , q -> bands [ 1 ] , 128 , temp , su -> fst_qmf_delay , iqmf_temp ) ;\n memcpy ( su -> last_qmf_delay , & su -> last_qmf_delay [ 256 ] , sizeof ( float ) * 23 ) ;\n memcpy ( & su -> last_qmf_delay [ 23 ] , q -> bands [ 2 ] , sizeof ( float ) * 256 ) ;\n ff_atrac_iqmf ( temp , su -> last_qmf_delay , 256 , pOut , su -> snd_qmf_delay , iqmf_temp ) ;\n }",
        "output": "0",
        "idx": 1791
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static hb_feature_t * feature_reference ( hb_feature_t * g ) {\n hb_feature_t * c = ( hb_feature_t * ) calloc ( 1 , sizeof ( hb_feature_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }",
        "output": "1",
        "idx": 1174
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mimic_decode_update_thread_context ( AVCodecContext * avctx , const AVCodecContext * avctx_from ) {\n MimicContext * dst = avctx -> priv_data , * src = avctx_from -> priv_data ;\n if ( avctx == avctx_from ) return 0 ;\n dst -> cur_index = src -> next_cur_index ;\n dst -> prev_index = src -> next_prev_index ;\n memcpy ( dst -> buf_ptrs , src -> buf_ptrs , sizeof ( src -> buf_ptrs ) ) ;\n memcpy ( dst -> flipped_ptrs , src -> flipped_ptrs , sizeof ( src -> flipped_ptrs ) ) ;\n memset ( & dst -> buf_ptrs [ dst -> cur_index ] , 0 , sizeof ( AVFrame ) ) ;\n return 0 ;\n }",
        "output": "1",
        "idx": 970
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vga_draw_line32_be ( VGACommonState * s1 , uint8_t * d , const uint8_t * s , int width ) {\n # ifdef HOST_WORDS_BIGENDIAN memcpy ( d , s , width * 4 ) ;\n # else int w ;\n uint32_t r , g , b ;\n w = width ;\n do {\n r = s [ 1 ] ;\n g = s [ 2 ] ;\n b = s [ 3 ] ;\n ( ( uint32_t * ) d ) [ 0 ] = rgb_to_pixel32 ( r , g , b ) ;\n s += 4 ;\n d += 4 ;\n }\n while ( -- w != 0 ) ;\n # endif }",
        "output": "1",
        "idx": 2684
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t vmsvga_index_read ( void * opaque , uint32_t address ) {\n struct vmsvga_state_s * s = opaque ;\n return s -> index ;\n }",
        "output": "0",
        "idx": 853
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void calc_segtree_probs ( int * segcounts , vp9_prob * segment_tree_probs ) {\n const int c01 = segcounts [ 0 ] + segcounts [ 1 ] ;\n const int c23 = segcounts [ 2 ] + segcounts [ 3 ] ;\n const int c45 = segcounts [ 4 ] + segcounts [ 5 ] ;\n const int c67 = segcounts [ 6 ] + segcounts [ 7 ] ;\n segment_tree_probs [ 0 ] = get_binary_prob ( c01 + c23 , c45 + c67 ) ;\n segment_tree_probs [ 1 ] = get_binary_prob ( c01 , c23 ) ;\n segment_tree_probs [ 2 ] = get_binary_prob ( c45 , c67 ) ;\n segment_tree_probs [ 3 ] = get_binary_prob ( segcounts [ 0 ] , segcounts [ 1 ] ) ;\n segment_tree_probs [ 4 ] = get_binary_prob ( segcounts [ 2 ] , segcounts [ 3 ] ) ;\n segment_tree_probs [ 5 ] = get_binary_prob ( segcounts [ 4 ] , segcounts [ 5 ] ) ;\n segment_tree_probs [ 6 ] = get_binary_prob ( segcounts [ 6 ] , segcounts [ 7 ] ) ;\n }",
        "output": "0",
        "idx": 618
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_NonStandardIdentifier ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 771 \"./asn1/h225/h225.cnf\" gint32 value ;\n nsiOID = \"\" ;\n h221NonStandard = 0 ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_NonStandardIdentifier , NonStandardIdentifier_choice , & value ) ;\n switch ( value ) {\n case 0 : nsp_handle = dissector_get_string_handle ( nsp_object_dissector_table , nsiOID ) ;\n break ;\n case 1 : nsp_handle = dissector_get_uint_handle ( nsp_h221_dissector_table , h221NonStandard ) ;\n break ;\n default : nsp_handle = NULL ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 2160
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char * _CompoundTextgetName ( const UConverter * cnv ) {\n return \"x11-compound-text\" ;\n }",
        "output": "1",
        "idx": 870
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vp9_get_segment_id ( const VP9_COMMON * cm , const uint8_t * segment_ids , BLOCK_SIZE bsize , int mi_row , int mi_col ) {\n const int mi_offset = mi_row * cm -> mi_cols + mi_col ;\n const int bw = num_8x8_blocks_wide_lookup [ bsize ] ;\n const int bh = num_8x8_blocks_high_lookup [ bsize ] ;\n const int xmis = MIN ( cm -> mi_cols - mi_col , bw ) ;\n const int ymis = MIN ( cm -> mi_rows - mi_row , bh ) ;\n int x , y , segment_id = INT_MAX ;\n for ( y = 0 ;\n y < ymis ;\n y ++ ) for ( x = 0 ;\n x < xmis ;\n x ++ ) segment_id = MIN ( segment_id , segment_ids [ mi_offset + y * cm -> mi_cols + x ] ) ;\n assert ( segment_id >= 0 && segment_id < MAX_SEGMENTS ) ;\n return segment_id ;\n }",
        "output": "0",
        "idx": 4092
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_T_rfc2733Mode ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_rfc2733Mode , T_rfc2733Mode_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 4366
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_T_h223_al_type_al2WithSequenceNumbers ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 309 \"../../asn1/h245/h245.cnf\" if ( h223_lc_params_temp ) h223_lc_params_temp -> al_type = al2WithSequenceNumbers ;\n offset = dissect_per_null ( tvb , offset , actx , tree , hf_index ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 3033
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t _warc_rdlen ( const char * buf , size_t bsz ) {\n static const char _key [ ] = \"\\r\\nContent-Length:\" ;\n const char * val , * eol ;\n char * on = NULL ;\n long int len ;\n if ( ( val = xmemmem ( buf , bsz , _key , sizeof ( _key ) - 1U ) ) == NULL ) {\n return - 1 ;\n }\n val += sizeof ( _key ) - 1U ;\n if ( ( eol = _warc_find_eol ( val , buf + bsz - val ) ) == NULL ) {\n return - 1 ;\n }\n while ( val < eol && ( * val == ' ' || * val == '\\t' ) ) val ++ ;\n if ( ! isdigit ( ( unsigned char ) * val ) ) return - 1 ;\n len = strtol ( val , & on , 10 ) ;\n if ( on != eol ) {\n return - 1 ;\n }\n return ( size_t ) len ;\n }",
        "output": "0",
        "idx": 4045
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint64_t mpc8544_guts_read ( void * opaque , hwaddr addr , unsigned size ) {\n uint32_t value = 0 ;\n CPUPPCState * env = cpu_single_env ;\n addr &= MPC8544_GUTS_MMIO_SIZE - 1 ;\n switch ( addr ) {\n case MPC8544_GUTS_ADDR_PVR : value = env -> spr [ SPR_PVR ] ;\n break ;\n case MPC8544_GUTS_ADDR_SVR : value = env -> spr [ SPR_E500_SVR ] ;\n break ;\n default : fprintf ( stderr , \"guts: Unknown register read: %x\\n\" , ( int ) addr ) ;\n break ;\n }\n return value ;\n }",
        "output": "1",
        "idx": 1974
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline OldUChar * toOldUCharPtr ( char16_t * p ) {\n # ifdef U_ALIASING_BARRIER U_ALIASING_BARRIER ( p ) ;\n # endif return reinterpret_cast < OldUChar * > ( p ) ;\n }",
        "output": "1",
        "idx": 1569
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static guint32 dissect_netb_datagram_bcast ( tvbuff_t * tvb , packet_info * pinfo _U_ , int offset , proto_tree * tree ) {\n if ( tvb_memeql ( tvb , offset + NB_SENDER_NAME , zeroes , 10 ) == 0 ) {\n proto_tree_add_item ( tree , hf_netb_datagram_bcast_mac , tvb , offset + NB_SENDER_NAME + 10 , 6 , ENC_NA ) ;\n }\n else {\n netbios_add_name ( \"Sender's Name\" , tvb , offset + NB_SENDER_NAME , tree ) ;\n }\n return 0 ;\n }",
        "output": "0",
        "idx": 2165
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dtls1_retrieve_buffered_fragment ( SSL * s , int * ok ) {\n pitem * item ;\n hm_fragment * frag ;\n int al ;\n * ok = 0 ;\n item = pqueue_peek ( s -> d1 -> buffered_messages ) ;\n if ( item == NULL ) return 0 ;\n frag = ( hm_fragment * ) item -> data ;\n if ( frag -> reassembly != NULL ) return 0 ;\n if ( s -> d1 -> handshake_read_seq == frag -> msg_header . seq ) {\n unsigned long frag_len = frag -> msg_header . frag_len ;\n pqueue_pop ( s -> d1 -> buffered_messages ) ;\n al = dtls1_preprocess_fragment ( s , & frag -> msg_header ) ;\n if ( al == 0 ) {\n unsigned char * p = ( unsigned char * ) s -> init_buf -> data + DTLS1_HM_HEADER_LENGTH ;\n memcpy ( & p [ frag -> msg_header . frag_off ] , frag -> fragment , frag -> msg_header . frag_len ) ;\n }\n dtls1_hm_fragment_free ( frag ) ;\n pitem_free ( item ) ;\n if ( al == 0 ) {\n * ok = 1 ;\n return frag_len ;\n }\n ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ;\n s -> init_num = 0 ;\n * ok = 0 ;\n return - 1 ;\n }\n else return 0 ;\n }",
        "output": "1",
        "idx": 2463
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int show_tags ( WriterContext * w , AVDictionary * tags , int section_id ) {\n AVDictionaryEntry * tag = NULL ;\n int ret = 0 ;\n if ( ! tags ) return 0 ;\n writer_print_section_header ( w , section_id ) ;\n while ( ( tag = av_dict_get ( tags , \"\" , tag , AV_DICT_IGNORE_SUFFIX ) ) ) {\n if ( ( ret = print_str_validate ( tag -> key , tag -> value ) ) < 0 ) break ;\n }\n writer_print_section_footer ( w ) ;\n return ret ;\n }",
        "output": "0",
        "idx": 2262
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void get_name_from_fullpropspec ( struct CFullPropSpec * v , char * out , int bufsize ) {\n struct GuidPropertySet * pset = GuidPropertySet_find_guid ( & v -> guid ) ;\n const char * id_str , * guid_str ;\n char * dest = out ;\n id_str = pset ? try_val_to_str ( v -> u . propid , pset -> id_map ) : NULL ;\n if ( id_str ) {\n g_snprintf ( dest , bufsize , \"%s\" , id_str ) ;\n }\n else {\n guid_str = guids_get_guid_name ( & v -> guid ) ;\n if ( guid_str ) {\n g_snprintf ( dest , bufsize , \"\\\"%s\\\"\" , guid_str ) ;\n }\n else {\n guid_str = guid_to_str ( wmem_packet_scope ( ) , & v -> guid ) ;\n g_snprintf ( dest , bufsize , \"{\n%s}\n\" , guid_str ) ;\n }\n if ( v -> kind == PRSPEC_LPWSTR ) {\n g_snprintf ( dest , bufsize , \"%s \\\"%s\\\"\" , guid_str , v -> u . name ) ;\n }\n else if ( v -> kind == PRSPEC_PROPID ) {\n g_snprintf ( dest , bufsize , \"%s 0x%08x\" , guid_str , v -> u . propid ) ;\n }\n else {\n g_snprintf ( dest , bufsize , \"%s <INVALID>\" , dest ) ;\n }\n }\n }",
        "output": "0",
        "idx": 4107
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void setup_masks_indic ( const hb_ot_shape_plan_t * plan HB_UNUSED , hb_buffer_t * buffer , hb_font_t * font HB_UNUSED ) {\n HB_BUFFER_ALLOCATE_VAR ( buffer , indic_category ) ;\n HB_BUFFER_ALLOCATE_VAR ( buffer , indic_position ) ;\n unsigned int count = buffer -> len ;\n hb_glyph_info_t * info = buffer -> info ;\n for ( unsigned int i = 0 ;\n i < count ;\n i ++ ) set_indic_properties ( info [ i ] ) ;\n }",
        "output": "0",
        "idx": 373
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( BookmarkBubbleSignInDelegateTest , OnSignInLinkClicked ) {\n ReplaceBlank ( browser ( ) ) ;\n int starting_tab_count = browser ( ) -> tab_strip_model ( ) -> count ( ) ;\n scoped_ptr < BookmarkBubbleDelegate > delegate ;\n delegate . reset ( new BookmarkBubbleSignInDelegate ( browser ( ) ) ) ;\n delegate -> OnSignInLinkClicked ( ) ;\n EXPECT_EQ ( starting_tab_count + 1 , browser ( ) -> tab_strip_model ( ) -> count ( ) ) ;\n }",
        "output": "1",
        "idx": 2751
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_encode_block_intra ( MACROBLOCK * x , int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , int8_t * skip ) {\n struct encode_b_args arg = {\n x , NULL , skip }\n ;\n encode_block_intra ( plane , block , plane_bsize , tx_size , & arg ) ;\n }",
        "output": "0",
        "idx": 1950
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( SingleClientSessionsSyncTest , ResponseCodeIsPreserved ) {\n ASSERT_TRUE ( SetupSync ( ) ) << \"SetupSync() failed.\" ;\n ASSERT_TRUE ( CheckInitialState ( 0 ) ) ;\n const GURL url ( \"about:version\" ) ;\n ScopedWindowMap windows ;\n ASSERT_TRUE ( OpenTabAndGetLocalWindows ( 0 , url , windows . GetMutable ( ) ) ) ;\n int found_navigations = 0 ;\n for ( SessionWindowMap : : const_iterator it = windows . Get ( ) -> begin ( ) ;\n it != windows . Get ( ) -> end ( ) ;\n ++ it ) {\n for ( std : : vector < sessions : : SessionTab * > : : const_iterator it2 = it -> second -> tabs . begin ( ) ;\n it2 != it -> second -> tabs . end ( ) ;\n ++ it2 ) {\n for ( std : : vector < sessions : : SerializedNavigationEntry > : : const_iterator it3 = ( * it2 ) -> navigations . begin ( ) ;\n it3 != ( * it2 ) -> navigations . end ( ) ;\n ++ it3 ) {\n EXPECT_EQ ( 200 , it3 -> http_status_code ( ) ) ;\n ++ found_navigations ;\n }\n }\n }\n ASSERT_EQ ( 1 , found_navigations ) ;\n }",
        "output": "1",
        "idx": 586
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void xsltFreeDocuments ( xsltTransformContextPtr ctxt ) {\n xsltDocumentPtr doc , cur ;\n cur = ctxt -> docList ;\n while ( cur != NULL ) {\n doc = cur ;\n cur = cur -> next ;\n xsltFreeDocumentKeys ( doc ) ;\n if ( ! doc -> main ) xmlFreeDoc ( doc -> doc ) ;\n xmlFree ( doc ) ;\n }\n cur = ctxt -> styleList ;\n while ( cur != NULL ) {\n doc = cur ;\n cur = cur -> next ;\n xsltFreeDocumentKeys ( doc ) ;\n if ( ! doc -> main ) xmlFreeDoc ( doc -> doc ) ;\n xmlFree ( doc ) ;\n }\n }",
        "output": "1",
        "idx": 882
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint16_t U_CALLCONV uprv_readSwapUInt16 ( uint16_t x ) {\n return ( uint16_t ) ( ( x << 8 ) | ( x >> 8 ) ) ;\n }",
        "output": "0",
        "idx": 3163
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_T_member ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h225_T_member , T_member_sequence_of ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 396
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int evbuffer_add ( struct evbuffer * buf , const void * data , size_t datlen ) {\n size_t need = buf -> misalign + buf -> off + datlen ;\n size_t oldoff = buf -> off ;\n if ( buf -> totallen < need ) {\n if ( evbuffer_expand ( buf , datlen ) == - 1 ) return ( - 1 ) ;\n }\n memcpy ( buf -> buffer + buf -> off , data , datlen ) ;\n buf -> off += datlen ;\n if ( datlen && buf -> cb != NULL ) ( * buf -> cb ) ( buf , oldoff , buf -> off , buf -> cbarg ) ;\n return ( 0 ) ;\n }",
        "output": "1",
        "idx": 847
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pass1 ( vpx_image_t * raw , FILE * infile , const char * outfile_name , const VpxInterface * encoder , const vpx_codec_enc_cfg_t * cfg ) {\n VpxVideoInfo info = {\n encoder -> fourcc , cfg -> g_w , cfg -> g_h , {\n cfg -> g_timebase . num , cfg -> g_timebase . den }\n }\n ;\n VpxVideoWriter * writer = NULL ;\n vpx_codec_ctx_t codec ;\n int frame_count = 0 ;\n writer = vpx_video_writer_open ( outfile_name , kContainerIVF , & info ) ;\n if ( ! writer ) die ( \"Failed to open %s for writing\" , outfile_name ) ;\n if ( vpx_codec_enc_init ( & codec , encoder -> codec_interface ( ) , cfg , 0 ) ) die_codec ( & codec , \"Failed to initialize encoder\" ) ;\n while ( vpx_img_read ( raw , infile ) ) {\n ++ frame_count ;\n encode_frame ( & codec , raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , writer ) ;\n }\n while ( encode_frame ( & codec , NULL , - 1 , 1 , 0 , VPX_DL_BEST_QUALITY , writer ) ) {\n }\n printf ( \"\\n\" ) ;\n if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , \"Failed to destroy codec.\" ) ;\n vpx_video_writer_close ( writer ) ;\n printf ( \"Pass 1 complete. Processed %d frames.\\n\" , frame_count ) ;\n }",
        "output": "1",
        "idx": 1586
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void virLogStackTraceToFd ( int fd ) {\n void * array [ 100 ] ;\n int size ;\n static bool doneWarning ;\n const char * msg = \"Stack trace not available on this platform\\n\" ;\n # define STRIP_DEPTH 3 size = backtrace ( array , ARRAY_CARDINALITY ( array ) ) ;\n if ( size ) {\n backtrace_symbols_fd ( array + STRIP_DEPTH , size - STRIP_DEPTH , fd ) ;\n ignore_value ( safewrite ( fd , \"\\n\" , 1 ) ) ;\n }\n else if ( ! doneWarning ) {\n ignore_value ( safewrite ( fd , msg , strlen ( msg ) ) ) ;\n doneWarning = true ;\n }\n # undef STRIP_DEPTH }",
        "output": "0",
        "idx": 251
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void output ( code_int code , GifCtx * ctx ) {\n ctx -> cur_accum &= masks [ ctx -> cur_bits ] ;\n if ( ctx -> cur_bits > 0 ) {\n ctx -> cur_accum |= ( ( long ) code << ctx -> cur_bits ) ;\n }\n else {\n ctx -> cur_accum = code ;\n }\n ctx -> cur_bits += ctx -> n_bits ;\n while ( ctx -> cur_bits >= 8 ) {\n char_out ( ( unsigned int ) ( ctx -> cur_accum & 0xff ) , ctx ) ;\n ctx -> cur_accum >>= 8 ;\n ctx -> cur_bits -= 8 ;\n }\n if ( ctx -> free_ent > ctx -> maxcode || ctx -> clear_flg ) {\n if ( ctx -> clear_flg ) {\n ctx -> maxcode = MAXCODE ( ctx -> n_bits = ctx -> g_init_bits ) ;\n ctx -> clear_flg = 0 ;\n }\n else {\n ++ ( ctx -> n_bits ) ;\n if ( ctx -> n_bits == maxbits ) {\n ctx -> maxcode = maxmaxcode ;\n }\n else {\n ctx -> maxcode = MAXCODE ( ctx -> n_bits ) ;\n }\n }\n }\n if ( code == ctx -> EOFCode ) {\n while ( ctx -> cur_bits > 0 ) {\n char_out ( ( unsigned int ) ( ctx -> cur_accum & 0xff ) , ctx ) ;\n ctx -> cur_accum >>= 8 ;\n ctx -> cur_bits -= 8 ;\n }\n flush_char ( ctx ) ;\n }\n }",
        "output": "1",
        "idx": 3696
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipvideo_decode_block_opcode_0xC_16 ( IpvideoContext * s ) {\n int x , y ;\n uint16_t * pixel_ptr = ( uint16_t * ) s -> pixel_ptr ;\n for ( y = 0 ;\n y < 8 ;\n y += 2 ) {\n for ( x = 0 ;\n x < 8 ;\n x += 2 ) {\n pixel_ptr [ x ] = pixel_ptr [ x + 1 ] = pixel_ptr [ x + s -> stride ] = pixel_ptr [ x + 1 + s -> stride ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n }\n pixel_ptr += s -> stride * 2 ;\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 4279
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static UChar32 T_UConverter_getNextUChar_UTF32_BE ( UConverterToUnicodeArgs * args , UErrorCode * err ) {\n const uint8_t * mySource ;\n UChar32 myUChar ;\n int32_t length ;\n mySource = ( const uint8_t * ) args -> source ;\n if ( mySource >= ( const uint8_t * ) args -> sourceLimit ) {\n * err = U_INDEX_OUTOFBOUNDS_ERROR ;\n return 0xffff ;\n }\n length = ( int32_t ) ( ( const uint8_t * ) args -> sourceLimit - mySource ) ;\n if ( length < 4 ) {\n uprv_memcpy ( args -> converter -> toUBytes , mySource , length ) ;\n args -> converter -> toULength = ( int8_t ) length ;\n args -> source = ( const char * ) ( mySource + length ) ;\n * err = U_TRUNCATED_CHAR_FOUND ;\n return 0xffff ;\n }\n myUChar = ( ( UChar32 ) mySource [ 0 ] << 24 ) | ( ( UChar32 ) mySource [ 1 ] << 16 ) | ( ( UChar32 ) mySource [ 2 ] << 8 ) | ( ( UChar32 ) mySource [ 3 ] ) ;\n args -> source = ( const char * ) ( mySource + 4 ) ;\n if ( ( uint32_t ) myUChar <= MAXIMUM_UTF && ! U_IS_SURROGATE ( myUChar ) ) {\n return myUChar ;\n }\n uprv_memcpy ( args -> converter -> toUBytes , mySource , 4 ) ;\n args -> converter -> toULength = 4 ;\n * err = U_ILLEGAL_CHAR_FOUND ;\n return 0xffff ;\n }",
        "output": "1",
        "idx": 3896
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( SupervisedUserNavigationThrottleTest , BlockMainFrameWithInterstitial ) {\n BlockHost ( kExampleHost2 ) ;\n WebContents * tab = browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) ;\n GURL allowed_url = embedded_test_server ( ) -> GetURL ( kExampleHost , \"/supervised_user/simple.html\" ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , allowed_url ) ;\n EXPECT_FALSE ( tab -> ShowingInterstitialPage ( ) ) ;\n GURL blocked_url = embedded_test_server ( ) -> GetURL ( kExampleHost2 , \"/supervised_user/simple.html\" ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , blocked_url ) ;\n EXPECT_TRUE ( tab -> ShowingInterstitialPage ( ) ) ;\n }",
        "output": "1",
        "idx": 486
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dissect_zcl_appl_evtalt_alerts_struct ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {\n proto_tree_add_item ( tree , hf_zbee_zcl_appl_evtalt_alert_id , tvb , * offset , 3 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_appl_evtalt_category , tvb , * offset , 3 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_appl_evtalt_status , tvb , * offset , 3 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_appl_evtalt_reserved , tvb , * offset , 3 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_appl_evtalt_proprietary , tvb , * offset , 3 , ENC_BIG_ENDIAN ) ;\n * offset += 3 ;\n }",
        "output": "0",
        "idx": 3534
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int key_notify_policy_flush ( const struct km_event * c ) {\n struct sk_buff * skb_out ;\n struct sadb_msg * hdr ;\n skb_out = alloc_skb ( sizeof ( struct sadb_msg ) + 16 , GFP_ATOMIC ) ;\n if ( ! skb_out ) return - ENOBUFS ;\n hdr = ( struct sadb_msg * ) skb_put ( skb_out , sizeof ( struct sadb_msg ) ) ;\n hdr -> sadb_msg_type = SADB_X_SPDFLUSH ;\n hdr -> sadb_msg_seq = c -> seq ;\n hdr -> sadb_msg_pid = c -> portid ;\n hdr -> sadb_msg_version = PF_KEY_V2 ;\n hdr -> sadb_msg_errno = ( uint8_t ) 0 ;\n hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ;\n pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ;\n return 0 ;\n }",
        "output": "1",
        "idx": 2528
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline GRANT_TABLE * table_hash_search ( const char * host , const char * ip , const char * db , const char * user , const char * tname , bool exact ) {\n return ( GRANT_TABLE * ) name_hash_search ( & column_priv_hash , host , ip , db , user , tname , exact , FALSE ) ;\n }",
        "output": "0",
        "idx": 1400
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int match_re ( my_regex_t * re , char * str ) {\n while ( my_isspace ( charset_info , * str ) ) str ++ ;\n if ( str [ 0 ] == '/' && str [ 1 ] == '*' ) {\n char * comm_end = strstr ( str , \"*/\" ) ;\n if ( ! comm_end ) die ( \"Statement is unterminated comment\" ) ;\n str = comm_end + 2 ;\n }\n int err = my_regexec ( re , str , ( size_t ) 0 , NULL , 0 ) ;\n if ( err == 0 ) return 1 ;\n else if ( err == REG_NOMATCH ) return 0 ;\n {\n char erbuf [ 100 ] ;\n int len = my_regerror ( err , re , erbuf , sizeof ( erbuf ) ) ;\n die ( \"error %s, %d/%d `%s'\\n\" , re_eprint ( err ) , ( int ) len , ( int ) sizeof ( erbuf ) , erbuf ) ;\n }\n return 0 ;\n }",
        "output": "0",
        "idx": 858
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_spoolss_uint16uni ( tvbuff_t * tvb , int offset , packet_info * pinfo _U_ , proto_tree * tree , guint8 * drep _U_ , char * * data , int hf_name ) {\n gint len , remaining ;\n char * text ;\n if ( offset % 2 ) offset += 2 - ( offset % 2 ) ;\n remaining = tvb_captured_length_remaining ( tvb , offset ) ;\n if ( remaining <= 0 ) {\n if ( data ) * data = g_strdup ( \"\" ) ;\n return offset ;\n }\n text = tvb_get_string_enc ( NULL , tvb , offset , remaining , ENC_UTF_16 | ENC_LITTLE_ENDIAN ) ;\n len = ( int ) strlen ( text ) ;\n proto_tree_add_string ( tree , hf_name , tvb , offset , len * 2 , text ) ;\n if ( data ) * data = text ;\n else g_free ( text ) ;\n return offset + ( len + 1 ) * 2 ;\n }",
        "output": "1",
        "idx": 992
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _CompoundTextReset ( UConverter * converter , UConverterResetChoice choice ) {\n }",
        "output": "1",
        "idx": 3402
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int SRP_user_pwd_set_sv ( SRP_user_pwd * vinfo , const char * s , const char * v ) {\n unsigned char tmp [ MAX_LEN ] ;\n int len ;\n if ( strlen ( s ) > MAX_LEN || strlen ( v ) > MAX_LEN ) return 0 ;\n len = t_fromb64 ( tmp , v ) ;\n if ( NULL == ( vinfo -> v = BN_bin2bn ( tmp , len , NULL ) ) ) return 0 ;\n len = t_fromb64 ( tmp , s ) ;\n return ( ( vinfo -> s = BN_bin2bn ( tmp , len , NULL ) ) != NULL ) ;\n }",
        "output": "0",
        "idx": 2473
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gboolean logcat_text_thread_dump_open ( wtap_dumper * wdh , int * err _U_ ) {\n struct dumper_t * dumper ;\n dumper = ( struct dumper_t * ) g_malloc ( sizeof ( struct dumper_t ) ) ;\n dumper -> type = DUMP_THREAD ;\n wdh -> priv = dumper ;\n wdh -> subtype_write = logcat_dump_text ;\n wdh -> subtype_close = NULL ;\n return TRUE ;\n }",
        "output": "0",
        "idx": 2686
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_SEQUENCE_OF_IntegrityMechanism ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h225_SEQUENCE_OF_IntegrityMechanism , SEQUENCE_OF_IntegrityMechanism_sequence_of ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 3983
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t vmport_cmd_get_version ( void * opaque , uint32_t addr ) {\n CPUX86State * env = cpu_single_env ;\n env -> regs [ R_EBX ] = VMPORT_MAGIC ;\n return 6 ;\n }",
        "output": "1",
        "idx": 3522
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dissect_h225_RasMessage ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 292 \"./asn1/h225/h225.cnf\" gint32 rasmessage_value ;\n h225_packet_info * h225_pi ;\n call_id_guid = NULL ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_RasMessage , RasMessage_choice , & rasmessage_value ) ;\n col_add_fstr ( actx -> pinfo -> cinfo , COL_INFO , \"RAS: %s \" , val_to_str ( rasmessage_value , h225_RasMessage_vals , \"<unknown>\" ) ) ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> msg_tag = rasmessage_value ;\n if ( call_id_guid ) {\n h225_pi -> guid = * call_id_guid ;\n }\n }\n return offset ;\n }",
        "output": "1",
        "idx": 2750
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void s390_virtio_register ( void ) {\n s390_virtio_bus_register_withprop ( & s390_virtio_console ) ;\n s390_virtio_bus_register_withprop ( & s390_virtio_blk ) ;\n s390_virtio_bus_register_withprop ( & s390_virtio_net ) ;\n }",
        "output": "1",
        "idx": 1888
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void set_p_mv_tables ( MpegEncContext * s , int mx , int my , int mv4 ) {\n const int xy = s -> mb_x + s -> mb_y * s -> mb_stride ;\n s -> p_mv_table [ xy ] [ 0 ] = mx ;\n s -> p_mv_table [ xy ] [ 1 ] = my ;\n if ( mv4 ) {\n int mot_xy = s -> block_index [ 0 ] ;\n s -> current_picture . f . motion_val [ 0 ] [ mot_xy ] [ 0 ] = mx ;\n s -> current_picture . f . motion_val [ 0 ] [ mot_xy ] [ 1 ] = my ;\n s -> current_picture . f . motion_val [ 0 ] [ mot_xy + 1 ] [ 0 ] = mx ;\n s -> current_picture . f . motion_val [ 0 ] [ mot_xy + 1 ] [ 1 ] = my ;\n mot_xy += s -> b8_stride ;\n s -> current_picture . f . motion_val [ 0 ] [ mot_xy ] [ 0 ] = mx ;\n s -> current_picture . f . motion_val [ 0 ] [ mot_xy ] [ 1 ] = my ;\n s -> current_picture . f . motion_val [ 0 ] [ mot_xy + 1 ] [ 0 ] = mx ;\n s -> current_picture . f . motion_val [ 0 ] [ mot_xy + 1 ] [ 1 ] = my ;\n }\n }",
        "output": "1",
        "idx": 2214
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void xmlListPopBack ( xmlListPtr l ) {\n if ( ! xmlListEmpty ( l ) ) xmlLinkDeallocator ( l , l -> sentinel -> prev ) ;\n }",
        "output": "0",
        "idx": 3356
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void erase_line ( AVCodecContext * avctx , int xoffset , int xlength ) {\n AnsiContext * s = avctx -> priv_data ;\n int i ;\n for ( i = 0 ;\n i < s -> font_height ;\n i ++ ) memset ( s -> frame . data [ 0 ] + ( s -> y + i ) * s -> frame . linesize [ 0 ] + xoffset , DEFAULT_BG_COLOR , xlength ) ;\n }",
        "output": "1",
        "idx": 2866
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void IGDstartelt ( void * d , const char * name , int l ) {\n struct IGDdatas * datas = ( struct IGDdatas * ) d ;\n memcpy ( datas -> cureltname , name , l ) ;\n datas -> cureltname [ l ] = '\\0' ;\n datas -> level ++ ;\n if ( ( l == 7 ) && ! memcmp ( name , \"service\" , l ) ) {\n datas -> tmp . controlurl [ 0 ] = '\\0' ;\n datas -> tmp . eventsuburl [ 0 ] = '\\0' ;\n datas -> tmp . scpdurl [ 0 ] = '\\0' ;\n datas -> tmp . servicetype [ 0 ] = '\\0' ;\n }\n }",
        "output": "1",
        "idx": 2295
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static UBool action_setRunsOnly ( UBiDiTransform * pTransform , UErrorCode * pErrorCode ) {\n ubidi_setReorderingMode ( pTransform -> pBidi , UBIDI_REORDER_RUNS_ONLY ) ;\n return FALSE ;\n }",
        "output": "1",
        "idx": 4280
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( OmniboxViewViewsTest , ScheduledTextEditCommand ) {\n omnibox_textfield ( ) -> SetTextEditCommandForNextKeyEvent ( ui : : TextEditCommand : : MOVE_UP ) ;\n EXPECT_EQ ( ui : : TextEditCommand : : MOVE_UP , scheduled_text_edit_command ( ) ) ;\n ui : : KeyEvent up_pressed ( ui : : ET_KEY_PRESSED , ui : : VKEY_UP , 0 ) ;\n omnibox_textfield ( ) -> OnKeyEvent ( & up_pressed ) ;\n EXPECT_EQ ( ui : : TextEditCommand : : INVALID_COMMAND , scheduled_text_edit_command ( ) ) ;\n }",
        "output": "1",
        "idx": 3428
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "type_init ( ehci_pci_register_types ) struct ehci_companions {\n const char * name ;\n int func ;\n int port ;\n }\n ;\n static const struct ehci_companions ich9_1d [ ] = {\n {\n . name = \"ich9-usb-uhci1\" , . func = 0 , . port = 0 }\n , {\n . name = \"ich9-usb-uhci2\" , . func = 1 , . port = 2 }\n , {\n . name = \"ich9-usb-uhci3\" , . func = 2 , . port = 4 }\n , }",
        "output": "0",
        "idx": 136
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "byte * _gcry_mpi_get_buffer ( gcry_mpi_t a , unsigned int * nbytes , int * sign ) {\n return do_get_buffer ( a , nbytes , sign , 0 ) ;\n }",
        "output": "1",
        "idx": 3296
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipvideo_decode_block_opcode_0xC ( IpvideoContext * s ) {\n int x , y ;\n for ( y = 0 ;\n y < 8 ;\n y += 2 ) {\n for ( x = 0 ;\n x < 8 ;\n x += 2 ) {\n s -> pixel_ptr [ x ] = s -> pixel_ptr [ x + 1 ] = s -> pixel_ptr [ x + s -> stride ] = s -> pixel_ptr [ x + 1 + s -> stride ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n }\n s -> pixel_ptr += s -> stride * 2 ;\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 2635
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int64_t cpu_get_icount ( void ) {\n int64_t icount ;\n CPUArchState * env = cpu_single_env ;\n icount = qemu_icount ;\n if ( env ) {\n if ( ! can_do_io ( env ) ) {\n fprintf ( stderr , \"Bad clock read\\n\" ) ;\n }\n icount -= ( env -> icount_decr . u16 . low + env -> icount_extra ) ;\n }\n return qemu_icount_bias + ( icount << icount_time_shift ) ;\n }",
        "output": "1",
        "idx": 1286
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char * xml_escape_str ( AVBPrint * dst , const char * src , void * log_ctx ) {\n const char * p ;\n for ( p = src ;\n * p ;\n p ++ ) {\n switch ( * p ) {\n case '&' : av_bprintf ( dst , \"%s\" , \"&amp;\n\" ) ;\n break ;\n case '<' : av_bprintf ( dst , \"%s\" , \"&lt;\n\" ) ;\n break ;\n case '>' : av_bprintf ( dst , \"%s\" , \"&gt;\n\" ) ;\n break ;\n case '\"' : av_bprintf ( dst , \"%s\" , \"&quot;\n\" ) ;\n break ;\n case '\\'' : av_bprintf ( dst , \"%s\" , \"&apos;\n\" ) ;\n break ;\n default : av_bprint_chars ( dst , * p , 1 ) ;\n }\n }\n return dst -> str ;\n }",
        "output": "0",
        "idx": 3361
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dtls1_clear ( SSL * s ) {\n pqueue * buffered_messages ;\n pqueue * sent_messages ;\n unsigned int mtu ;\n unsigned int link_mtu ;\n DTLS_RECORD_LAYER_clear ( & s -> rlayer ) ;\n if ( s -> d1 ) {\n buffered_messages = s -> d1 -> buffered_messages ;\n sent_messages = s -> d1 -> sent_messages ;\n mtu = s -> d1 -> mtu ;\n link_mtu = s -> d1 -> link_mtu ;\n dtls1_clear_queues ( s ) ;\n memset ( s -> d1 , 0 , sizeof ( * s -> d1 ) ) ;\n if ( s -> server ) {\n s -> d1 -> cookie_len = sizeof ( s -> d1 -> cookie ) ;\n }\n if ( SSL_get_options ( s ) & SSL_OP_NO_QUERY_MTU ) {\n s -> d1 -> mtu = mtu ;\n s -> d1 -> link_mtu = link_mtu ;\n }\n s -> d1 -> buffered_messages = buffered_messages ;\n s -> d1 -> sent_messages = sent_messages ;\n }\n ssl3_clear ( s ) ;\n if ( s -> method -> version == DTLS_ANY_VERSION ) s -> version = DTLS_MAX_VERSION ;\n # ifndef OPENSSL_NO_DTLS1_METHOD else if ( s -> options & SSL_OP_CISCO_ANYCONNECT ) s -> client_version = s -> version = DTLS1_BAD_VER ;\n # endif else s -> version = s -> method -> version ;\n }",
        "output": "0",
        "idx": 1442
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int gs_to_exit ( const gs_memory_t * mem , int exit_status ) {\n return gs_to_exit_with_code ( mem , exit_status , 0 ) ;\n }",
        "output": "0",
        "idx": 4289
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fill_vaapi_RefPicList ( VAPictureH264 RefPicList [ 32 ] , Picture * ref_list , unsigned int ref_count ) {\n unsigned int i , n = 0 ;\n for ( i = 0 ;\n i < ref_count ;\n i ++ ) if ( ref_list [ i ] . f . reference ) fill_vaapi_pic ( & RefPicList [ n ++ ] , & ref_list [ i ] , 0 ) ;\n for ( ;\n n < 32 ;\n n ++ ) init_vaapi_pic ( & RefPicList [ n ] ) ;\n }",
        "output": "1",
        "idx": 426
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void curses_connection_purge ( void * conn ) {\n ( void ) conn ;\n DEBUG_MSG ( \"curses_connection_purge\" ) ;\n conntrack_purge ( ) ;\n refresh_connections ( ) ;\n }",
        "output": "0",
        "idx": 939
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_GatekeeperRejectReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 592 \"./asn1/h225/h225.cnf\" gint32 value ;\n h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_GatekeeperRejectReason , GatekeeperRejectReason_choice , & value ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> reason = value ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 4248
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool rowtype_field_matches ( Oid rowtypeid , int fieldnum , Oid expectedtype , int32 expectedtypmod , Oid expectedcollation ) {\n TupleDesc tupdesc ;\n Form_pg_attribute attr ;\n if ( rowtypeid == RECORDOID ) return true ;\n tupdesc = lookup_rowtype_tupdesc ( rowtypeid , - 1 ) ;\n if ( fieldnum <= 0 || fieldnum > tupdesc -> natts ) {\n ReleaseTupleDesc ( tupdesc ) ;\n return false ;\n }\n attr = tupdesc -> attrs [ fieldnum - 1 ] ;\n if ( attr -> attisdropped || attr -> atttypid != expectedtype || attr -> atttypmod != expectedtypmod || attr -> attcollation != expectedcollation ) {\n ReleaseTupleDesc ( tupdesc ) ;\n return false ;\n }\n ReleaseTupleDesc ( tupdesc ) ;\n return true ;\n }",
        "output": "0",
        "idx": 1481
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void remove_tap_listener_sccp_calls ( void ) {\n remove_tap_listener ( & ( the_tapinfo_struct . sccp_dummy ) ) ;\n have_sccp_tap_listener = FALSE ;\n have_sua_tap_listener = FALSE ;\n }",
        "output": "0",
        "idx": 1592
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_rsl_ie_meas_res_no ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , int offset , gboolean is_mandatory ) {\n proto_tree * ie_tree ;\n guint8 ie_id ;\n if ( is_mandatory == FALSE ) {\n ie_id = tvb_get_guint8 ( tvb , offset ) ;\n if ( ie_id != RSL_IE_MEAS_RES_NO ) return offset ;\n }\n ie_tree = proto_tree_add_subtree ( tree , tvb , offset , 2 , ett_ie_meas_res_no , NULL , \"Measurement result number IE\" ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n proto_tree_add_item ( ie_tree , hf_rsl_meas_res_no , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n return offset ;\n }",
        "output": "0",
        "idx": 2959
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void icount_adjust_rt ( void * opaque ) {\n qemu_mod_timer ( icount_rt_timer , qemu_get_clock_ms ( rt_clock ) + 1000 ) ;\n icount_adjust ( ) ;\n }",
        "output": "0",
        "idx": 1954
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int16_t vp9_ac_quant ( int qindex , int delta ) {\n return ac_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ;\n }",
        "output": "1",
        "idx": 3189
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_T_h245Tunnelling ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 454 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n offset = dissect_per_boolean ( tvb , offset , actx , tree , hf_index , & ( h225_pi -> is_h245Tunneling ) ) ;\n # line 462 \"./asn1/h225/h225.cnf\" }\n return offset ;\n }",
        "output": "1",
        "idx": 3376
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _UTF7Open ( UConverter * cnv , UConverterLoadArgs * pArgs , UErrorCode * pErrorCode ) {\n if ( UCNV_GET_VERSION ( cnv ) <= 1 ) {\n cnv -> fromUnicodeStatus = UCNV_GET_VERSION ( cnv ) << 28 ;\n _UTF7Reset ( cnv , UCNV_RESET_BOTH ) ;\n }\n else {\n * pErrorCode = U_ILLEGAL_ARGUMENT_ERROR ;\n }\n }",
        "output": "1",
        "idx": 3551
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , SameOrigin_Http ) {\n StartHttpServer ( ) ;\n NavigateTwiceInTabAndClose ( http_test_server_ -> GetURL ( \"/simple.html\" ) , http_test_server_ -> GetURL ( \"/empty.html\" ) ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 2 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;\n }",
        "output": "1",
        "idx": 2321
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __always_inline __le64 __cpu_to_le64p ( const __u64 * p ) {\n return ( __le64 ) * p ;\n }",
        "output": "1",
        "idx": 4254
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char * TSHttpHdrReasonGet ( TSMBuffer bufp , TSMLoc obj , int * length ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_http_hdr_handle ( obj ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) length ) == TS_SUCCESS ) ;\n HTTPHdr h ;\n SET_HTTP_HDR ( h , bufp , obj ) ;\n return h . reason_get ( length ) ;\n }",
        "output": "0",
        "idx": 2829
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int X509_verify ( X509 * a , EVP_PKEY * r ) {\n return ( ASN1_item_verify ( ASN1_ITEM_rptr ( X509_CINF ) , a -> sig_alg , a -> signature , a -> cert_info , r ) ) ;\n }",
        "output": "1",
        "idx": 344
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_quant ( AVCodecContext * avctx , NuvContext * c , const uint8_t * buf , int size ) {\n int i ;\n if ( size < 2 * 64 * 4 ) {\n av_log ( avctx , AV_LOG_ERROR , \"insufficient rtjpeg quant data\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n for ( i = 0 ;\n i < 64 ;\n i ++ , buf += 4 ) c -> lq [ i ] = AV_RL32 ( buf ) ;\n for ( i = 0 ;\n i < 64 ;\n i ++ , buf += 4 ) c -> cq [ i ] = AV_RL32 ( buf ) ;\n return 0 ;\n }",
        "output": "0",
        "idx": 4207
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u16 transaction_id_pick ( void ) {\n for ( ;\n ;\n ) {\n const struct request * req = req_head , * started_at ;\n u16 trans_id = trans_id_function ( ) ;\n if ( trans_id == 0xffff ) continue ;\n req = started_at = req_head ;\n if ( req ) {\n do {\n if ( req -> trans_id == trans_id ) break ;\n req = req -> next ;\n }\n while ( req != started_at ) ;\n }\n if ( req == started_at ) return trans_id ;\n }\n }",
        "output": "1",
        "idx": 2610
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_T_conferenceGoal ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_T_conferenceGoal , T_conferenceGoal_choice , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 441
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "clump_t * clump_splay_walk_bwd_init ( clump_splay_walker * sw , const gs_ref_memory_t * mem ) {\n clump_t * cp = mem -> root ;\n if ( cp ) {\n SANITY_CHECK ( cp ) ;\n sw -> from = SPLAY_FROM_RIGHT ;\n while ( cp -> right ) {\n cp = cp -> right ;\n }\n }\n sw -> cp = cp ;\n sw -> end = NULL ;\n return cp ;\n }",
        "output": "0",
        "idx": 1770
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void U_CALLCONV _HZ_GetUnicodeSet ( const UConverter * cnv , const USetAdder * sa , UConverterUnicodeSet which , UErrorCode * pErrorCode ) {\n sa -> addRange ( sa -> set , 0 , 0x7f ) ;\n ucnv_MBCSGetFilteredUnicodeSetForUnicode ( ( ( UConverterDataHZ * ) cnv -> extraInfo ) -> gbConverter -> sharedData , sa , which , UCNV_SET_FILTER_HZ , pErrorCode ) ;\n }",
        "output": "0",
        "idx": 1677
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void udev_hotplug_event ( struct udev_device * udev_dev ) {\n const char * udev_action ;\n const char * sys_name = NULL ;\n uint8_t busnum = 0 , devaddr = 0 ;\n int detached ;\n int r ;\n do {\n udev_action = udev_device_get_action ( udev_dev ) ;\n if ( ! udev_action ) {\n break ;\n }\n detached = ! strncmp ( udev_action , \"remove\" , 6 ) ;\n r = udev_device_info ( NULL , detached , udev_dev , & busnum , & devaddr , & sys_name ) ;\n if ( LIBUSB_SUCCESS != r ) {\n break ;\n }\n usbi_dbg ( \"udev hotplug event. action: %s.\" , udev_action ) ;\n if ( strncmp ( udev_action , \"add\" , 3 ) == 0 ) {\n linux_hotplug_enumerate ( busnum , devaddr , sys_name ) ;\n }\n else if ( detached ) {\n linux_device_disconnected ( busnum , devaddr , sys_name ) ;\n }\n else {\n usbi_err ( NULL , \"ignoring udev action %s\" , udev_action ) ;\n }\n }\n while ( 0 ) ;\n udev_device_unref ( udev_dev ) ;\n }",
        "output": "1",
        "idx": 2579
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int loop_filter_row_worker ( void * arg1 , void * arg2 ) {\n TileWorkerData * const tile_data = ( TileWorkerData * ) arg1 ;\n LFWorkerData * const lf_data = & tile_data -> lfdata ;\n ( void ) arg2 ;\n loop_filter_rows_mt ( lf_data -> frame_buffer , lf_data -> cm , lf_data -> planes , lf_data -> start , lf_data -> stop , lf_data -> y_only , lf_data -> lf_sync , lf_data -> num_lf_workers ) ;\n return 1 ;\n }",
        "output": "1",
        "idx": 3797
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int TS_OBJ_print_bio ( BIO * bio , const ASN1_OBJECT * obj ) {\n char obj_txt [ 128 ] ;\n int len = OBJ_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ;\n BIO_write ( bio , obj_txt , len ) ;\n BIO_write ( bio , \"\\n\" , 1 ) ;\n return 1 ;\n }",
        "output": "1",
        "idx": 4442
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "VALUE rb_dlhandle_close ( VALUE self ) {\n struct dl_handle * dlhandle ;\n Data_Get_Struct ( self , struct dl_handle , dlhandle ) ;\n dlhandle -> open = 0 ;\n return INT2NUM ( dlclose ( dlhandle -> ptr ) ) ;\n }",
        "output": "0",
        "idx": 4119
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int get_words ( OHCIState * ohci , dma_addr_t addr , uint16_t * buf , int num ) {\n int i ;\n addr += ohci -> localmem_base ;\n for ( i = 0 ;\n i < num ;\n i ++ , buf ++ , addr += sizeof ( * buf ) ) {\n if ( dma_memory_read ( ohci -> as , addr , buf , sizeof ( * buf ) ) ) {\n return - 1 ;\n }\n * buf = le16_to_cpu ( * buf ) ;\n }\n return 0 ;\n }",
        "output": "0",
        "idx": 2952
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rfbBool rfbSendFileTransferMessage ( rfbClientPtr cl , uint8_t contentType , uint8_t contentParam , uint32_t size , uint32_t length , const char * buffer ) {\n rfbFileTransferMsg ft ;\n ft . type = rfbFileTransfer ;\n ft . contentType = contentType ;\n ft . contentParam = contentParam ;\n ft . pad = 0 ;\n ft . size = Swap32IfLE ( size ) ;\n ft . length = Swap32IfLE ( length ) ;\n FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN ( \"\" , cl , FALSE ) ;\n LOCK ( cl -> sendMutex ) ;\n if ( rfbWriteExact ( cl , ( char * ) & ft , sz_rfbFileTransferMsg ) < 0 ) {\n rfbLogPerror ( \"rfbSendFileTransferMessage: write\" ) ;\n rfbCloseClient ( cl ) ;\n UNLOCK ( cl -> sendMutex ) ;\n return FALSE ;\n }\n if ( length > 0 ) {\n if ( rfbWriteExact ( cl , buffer , length ) < 0 ) {\n rfbLogPerror ( \"rfbSendFileTransferMessage: write\" ) ;\n rfbCloseClient ( cl ) ;\n UNLOCK ( cl -> sendMutex ) ;\n return FALSE ;\n }\n }\n UNLOCK ( cl -> sendMutex ) ;\n rfbStatRecordMessageSent ( cl , rfbFileTransfer , sz_rfbFileTransferMsg + length , sz_rfbFileTransferMsg + length ) ;\n return TRUE ;\n }",
        "output": "1",
        "idx": 3531
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;\n __exctype_l ( isalpha_l ) ;\n __exctype_l ( iscntrl_l )",
        "output": "1",
        "idx": 2452
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void free_frame_buffer ( MpegEncContext * s , Picture * pic ) {\n if ( s -> codec_id != AV_CODEC_ID_WMV3IMAGE && s -> codec_id != AV_CODEC_ID_VC1IMAGE && s -> codec_id != AV_CODEC_ID_MSS2 ) ff_thread_release_buffer ( s -> avctx , & pic -> f ) ;\n else avcodec_default_release_buffer ( s -> avctx , & pic -> f ) ;\n av_freep ( & pic -> hwaccel_picture_private ) ;\n }",
        "output": "1",
        "idx": 3947
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void http_suite ( void ) {\n http_base_test ( ) ;\n http_bad_header_test ( ) ;\n http_parse_query_test ( ) ;\n http_basic_test ( ) ;\n http_connection_test ( 0 ) ;\n http_connection_test ( 1 ) ;\n http_close_detection ( 0 ) ;\n http_close_detection ( 1 ) ;\n http_post_test ( ) ;\n http_failure_test ( ) ;\n http_highport_test ( ) ;\n http_dispatcher_test ( ) ;\n http_multi_line_header_test ( ) ;\n http_negative_content_length_test ( ) ;\n http_chunked_test ( ) ;\n }",
        "output": "1",
        "idx": 1053
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int compute_rd_thresh_factor ( int qindex ) {\n const int q = ( int ) ( pow ( vp9_dc_quant ( qindex , 0 ) / 4.0 , RD_THRESH_POW ) * 5.12 ) ;\n return MAX ( q , 8 ) ;\n }",
        "output": "1",
        "idx": 900
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static cmsBool WriteOffsetArray ( cmsIOHANDLER * io , _cmsDICarray * a , cmsUInt32Number Count , cmsUInt32Number Length ) {\n cmsUInt32Number i ;\n for ( i = 0 ;\n i < Count ;\n i ++ ) {\n if ( ! WriteOneElem ( io , & a -> Name , i ) ) return FALSE ;\n if ( ! WriteOneElem ( io , & a -> Value , i ) ) return FALSE ;\n if ( Length > 16 ) {\n if ( ! WriteOneElem ( io , & a -> DisplayName , i ) ) return FALSE ;\n }\n if ( Length > 24 ) {\n if ( ! WriteOneElem ( io , & a -> DisplayValue , i ) ) return FALSE ;\n }\n }\n return TRUE ;\n }",
        "output": "0",
        "idx": 704
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void report_progress_end ( ) {\n if ( last_progress_report_length ) {\n printf ( \"%*s\\r\" , last_progress_report_length , \"\" ) ;\n last_progress_report_length = 0 ;\n }\n }",
        "output": "0",
        "idx": 2482
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_pvfs2_error ( tvbuff_t * tvb , proto_tree * tree , int offset , packet_info * pinfo ) {\n gint32 err ;\n const char * errmsg = NULL ;\n err = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_pvfs_error , tvb , offset , 4 , - err ) ;\n offset += 4 ;\n if ( err != 0 ) {\n errmsg = val_to_str ( - err , names_pvfs_error , \"Unknown error: %u\" ) ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \" Error: %s\" , errmsg ) ;\n }\n return offset ;\n }",
        "output": "0",
        "idx": 1154
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int find_unused_picture ( MpegEncContext * s , int shared ) {\n int i ;\n if ( shared ) {\n for ( i = s -> picture_range_start ;\n i < s -> picture_range_end ;\n i ++ ) {\n if ( s -> picture [ i ] . f . data [ 0 ] == NULL && s -> picture [ i ] . f . type == 0 ) return i ;\n }\n }\n else {\n for ( i = s -> picture_range_start ;\n i < s -> picture_range_end ;\n i ++ ) {\n if ( pic_is_unused ( s , & s -> picture [ i ] ) && s -> picture [ i ] . f . type != 0 ) return i ;\n }\n for ( i = s -> picture_range_start ;\n i < s -> picture_range_end ;\n i ++ ) {\n if ( pic_is_unused ( s , & s -> picture [ i ] ) ) return i ;\n }\n }\n return AVERROR_INVALIDDATA ;\n }",
        "output": "1",
        "idx": 3813
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void init_util ( void ) {\n filegen_register ( statsdir , \"peerstats\" , & peerstats ) ;\n filegen_register ( statsdir , \"loopstats\" , & loopstats ) ;\n filegen_register ( statsdir , \"clockstats\" , & clockstats ) ;\n filegen_register ( statsdir , \"rawstats\" , & rawstats ) ;\n filegen_register ( statsdir , \"sysstats\" , & sysstats ) ;\n filegen_register ( statsdir , \"protostats\" , & protostats ) ;\n # ifdef AUTOKEY filegen_register ( statsdir , \"cryptostats\" , & cryptostats ) ;\n # endif # ifdef DEBUG_TIMING filegen_register ( statsdir , \"timingstats\" , & timingstats ) ;\n # endif step_callback = & ntpd_time_stepped ;\n # ifdef DEBUG atexit ( & uninit_util ) ;\n # endif }",
        "output": "1",
        "idx": 3046
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , Navigate_Http ) {\n StartHttpServer ( ) ;\n NavigateTwiceInTabAndClose ( http_test_server_ -> GetURL ( \"/simple.html\" ) , GURL ( chrome : : kChromeUIVersionURL ) ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;\n }",
        "output": "1",
        "idx": 97
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void * jas_realloc ( void * ptr , size_t size ) {\n void * result ;\n JAS_DBGLOG ( 101 , ( \"jas_realloc called with %x,%zu\\n\" , ptr , size ) ) ;\n result = realloc ( ptr , size ) ;\n JAS_DBGLOG ( 100 , ( \"jas_realloc(%p, %zu) -> %p\\n\" , ptr , size , result ) ) ;\n return result ;\n }",
        "output": "1",
        "idx": 3096
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rfbBool rfbSendTextChatMessage ( rfbClientPtr cl , uint32_t length , char * buffer ) {\n rfbTextChatMsg tc ;\n int bytesToSend = 0 ;\n memset ( ( char * ) & tc , 0 , sizeof ( tc ) ) ;\n tc . type = rfbTextChat ;\n tc . length = Swap32IfLE ( length ) ;\n switch ( length ) {\n case rfbTextChatOpen : case rfbTextChatClose : case rfbTextChatFinished : bytesToSend = 0 ;\n break ;\n default : bytesToSend = length ;\n if ( bytesToSend > rfbTextMaxSize ) bytesToSend = rfbTextMaxSize ;\n }\n if ( cl -> ublen + sz_rfbTextChatMsg + bytesToSend > UPDATE_BUF_SIZE ) {\n if ( ! rfbSendUpdateBuf ( cl ) ) return FALSE ;\n }\n memcpy ( & cl -> updateBuf [ cl -> ublen ] , ( char * ) & tc , sz_rfbTextChatMsg ) ;\n cl -> ublen += sz_rfbTextChatMsg ;\n if ( bytesToSend > 0 ) {\n memcpy ( & cl -> updateBuf [ cl -> ublen ] , buffer , bytesToSend ) ;\n cl -> ublen += bytesToSend ;\n }\n rfbStatRecordMessageSent ( cl , rfbTextChat , sz_rfbTextChatMsg + bytesToSend , sz_rfbTextChatMsg + bytesToSend ) ;\n if ( ! rfbSendUpdateBuf ( cl ) ) return FALSE ;\n return TRUE ;\n }",
        "output": "1",
        "idx": 2733
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __inline__ __u64 __arch_swab64 ( __u64 val ) {\n # ifdef __i386__ union {\n struct {\n __u32 a ;\n __u32 b ;\n }\n s ;\n __u64 u ;\n }\n v ;\n v . u = val ;\n __asm__ ( \"bswapl %0 ;\n bswapl %1 ;\n xchgl %0,%1\" : \"=r\" ( v . s . a ) , \"=r\" ( v . s . b ) : \"0\" ( v . s . a ) , \"1\" ( v . s . b ) ) ;\n return v . u ;\n # else __asm__ ( \"bswapq %0\" : \"=r\" ( val ) : \"0\" ( val ) ) ;\n return val ;\n # endif }",
        "output": "1",
        "idx": 690
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fz_default_colorspaces * fz_keep_default_colorspaces ( fz_context * ctx , fz_default_colorspaces * default_cs ) {\n return fz_keep_imp ( ctx , default_cs , & default_cs -> refs ) ;\n }",
        "output": "0",
        "idx": 3616
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _HZClose ( UConverter * cnv ) {\n if ( cnv -> extraInfo != NULL ) {\n ucnv_close ( ( ( UConverterDataHZ * ) ( cnv -> extraInfo ) ) -> gbConverter ) ;\n if ( ! cnv -> isExtraLocal ) {\n uprv_free ( cnv -> extraInfo ) ;\n }\n cnv -> extraInfo = NULL ;\n }\n }",
        "output": "1",
        "idx": 3874
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void * evport_init ( struct event_base * base ) {\n struct evport_data * evpd ;\n int i ;\n if ( evutil_getenv ( \"EVENT_NOEVPORT\" ) ) return ( NULL ) ;\n if ( ! ( evpd = calloc ( 1 , sizeof ( struct evport_data ) ) ) ) return ( NULL ) ;\n if ( ( evpd -> ed_port = port_create ( ) ) == - 1 ) {\n free ( evpd ) ;\n return ( NULL ) ;\n }\n evpd -> ed_fds = calloc ( DEFAULT_NFDS , sizeof ( struct fd_info ) ) ;\n if ( evpd -> ed_fds == NULL ) {\n close ( evpd -> ed_port ) ;\n free ( evpd ) ;\n return ( NULL ) ;\n }\n evpd -> ed_nevents = DEFAULT_NFDS ;\n for ( i = 0 ;\n i < EVENTS_PER_GETN ;\n i ++ ) evpd -> ed_pending [ i ] = - 1 ;\n evsignal_init ( base ) ;\n return ( evpd ) ;\n }",
        "output": "0",
        "idx": 3783
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vga_draw_line32_le ( VGACommonState * s1 , uint8_t * d , const uint8_t * s , int width ) {\n # ifndef HOST_WORDS_BIGENDIAN memcpy ( d , s , width * 4 ) ;\n # else int w ;\n uint32_t r , g , b ;\n w = width ;\n do {\n b = s [ 0 ] ;\n g = s [ 1 ] ;\n r = s [ 2 ] ;\n ( ( uint32_t * ) d ) [ 0 ] = rgb_to_pixel32 ( r , g , b ) ;\n s += 4 ;\n d += 4 ;\n }\n while ( -- w != 0 ) ;\n # endif }",
        "output": "1",
        "idx": 3146
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void show_object ( struct object * obj , const struct name_path * path , const char * component , void * cb_data ) {\n struct rev_list_info * info = cb_data ;\n finish_object ( obj , path , component , cb_data ) ;\n if ( info -> flags & REV_LIST_QUIET ) return ;\n show_object_with_name ( stdout , obj , path , component ) ;\n }",
        "output": "1",
        "idx": 626
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SSL3_RECORD_release ( SSL3_RECORD * r , unsigned int num_recs ) {\n unsigned int i ;\n for ( i = 0 ;\n i < num_recs ;\n i ++ ) {\n OPENSSL_free ( r [ i ] . comp ) ;\n r [ i ] . comp = NULL ;\n }\n }",
        "output": "0",
        "idx": 1983
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dovec ( struct vars * v , struct cvec * cv , struct state * lp , struct state * rp ) {\n chr ch , from , to ;\n const chr * p ;\n int i ;\n for ( p = cv -> chrs , i = cv -> nchrs ;\n i > 0 ;\n p ++ , i -- ) {\n ch = * p ;\n newarc ( v -> nfa , PLAIN , subcolor ( v -> cm , ch ) , lp , rp ) ;\n }\n for ( p = cv -> ranges , i = cv -> nranges ;\n i > 0 ;\n p += 2 , i -- ) {\n from = * p ;\n to = * ( p + 1 ) ;\n if ( from <= to ) subrange ( v , from , to , lp , rp ) ;\n }\n }",
        "output": "1",
        "idx": 263
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( MediaStreamPermissionTest , TestDismissingRequest ) {\n content : : WebContents * tab_contents = LoadTestPageInTab ( ) ;\n GetUserMediaAndDismiss ( tab_contents ) ;\n }",
        "output": "0",
        "idx": 1061
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl ) ;\n __exctype ( isdigit ) ;\n __exctype ( islower ) ;\n __exctype ( isgraph ) ;\n __exctype ( isprint ) ;\n __exctype ( ispunct ) ;\n __exctype ( isspace ) ;\n __exctype ( isupper ) ;\n __exctype ( isxdigit ) ;\n extern int tolower ( int __c ) __THROW ;\n extern int toupper ( int __c ) __THROW ;\n # ifdef __USE_ISOC99 __exctype ( isblank )",
        "output": "1",
        "idx": 3211
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE cState_space_set ( VALUE self , VALUE space ) {\n unsigned long len ;\n GET_STATE ( self ) ;\n Check_Type ( space , T_STRING ) ;\n len = RSTRING_LEN ( space ) ;\n if ( len == 0 ) {\n if ( state -> space ) {\n ruby_xfree ( state -> space ) ;\n state -> space = NULL ;\n state -> space_len = 0 ;\n }\n }\n else {\n if ( state -> space ) ruby_xfree ( state -> space ) ;\n state -> space = strdup ( RSTRING_PTR ( space ) ) ;\n state -> space_len = len ;\n }\n return Qnil ;\n }",
        "output": "1",
        "idx": 1659
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dissect_diameter_other_vendor_exp_res ( tvbuff_t * tvb , proto_tree * tree , diam_sub_dis_t * diam_sub_dis ) {\n proto_item * pi ;\n if ( tree ) {\n pi = proto_tree_add_item ( tree , hf_diameter_other_vendor_exp_res , tvb , 0 , 4 , ENC_BIG_ENDIAN ) ;\n diam_sub_dis -> avp_str = ( char * ) wmem_alloc ( wmem_packet_scope ( ) , ITEM_LABEL_LENGTH + 1 ) ;\n proto_item_fill_label ( PITEM_FINFO ( pi ) , diam_sub_dis -> avp_str ) ;\n diam_sub_dis -> avp_str = strstr ( diam_sub_dis -> avp_str , \": \" ) + 2 ;\n }\n }",
        "output": "0",
        "idx": 1541
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_fdct4x4_1_c ( const int16_t * input , int16_t * output , int stride ) {\n int r , c ;\n int16_t sum = 0 ;\n for ( r = 0 ;\n r < 4 ;\n ++ r ) for ( c = 0 ;\n c < 4 ;\n ++ c ) sum += input [ r * stride + c ] ;\n output [ 0 ] = sum << 1 ;\n output [ 1 ] = 0 ;\n }",
        "output": "1",
        "idx": 1834
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dissect_ber_octet_string_wcb ( gboolean implicit_tag , asn1_ctx_t * actx , proto_tree * tree , tvbuff_t * tvb , int offset , gint hf_id , ber_callback func ) {\n tvbuff_t * out_tvb = NULL ;\n offset = dissect_ber_octet_string ( implicit_tag , actx , tree , tvb , offset , hf_id , ( func ) ? & out_tvb : NULL ) ;\n if ( func && out_tvb && ( tvb_reported_length ( out_tvb ) > 0 ) ) {\n if ( hf_id >= 0 ) tree = proto_item_add_subtree ( actx -> created_item , ett_ber_octet_string ) ;\n func ( FALSE , out_tvb , 0 , actx , tree , - 1 ) ;\n }\n return offset ;\n }",
        "output": "0",
        "idx": 2027
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_T_raw ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 881 \"./asn1/h225/h225.cnf\" tvbuff_t * value_tvb ;\n gef_ctx_t * gefx ;\n proto_item * ti ;\n offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , NO_BOUND , NO_BOUND , FALSE , & value_tvb ) ;\n gefx = gef_ctx_get ( actx -> private_data ) ;\n if ( gefx ) {\n ti = proto_tree_add_string ( tree , hf_h225_debug_dissector_try_string , tvb , offset >> 3 , 0 , gefx -> key ) ;\n PROTO_ITEM_SET_HIDDEN ( ti ) ;\n dissector_try_string ( gef_content_dissector_table , gefx -> key , value_tvb , actx -> pinfo , tree , actx ) ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 3288
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlLinkPtr xmlListEnd ( xmlListPtr l ) {\n if ( l == NULL ) return ( NULL ) ;\n return ( l -> sentinel -> prev ) ;\n }",
        "output": "1",
        "idx": 3573
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_mode_info_seg_skip ( MACROBLOCK * x , TX_MODE tx_mode , int * rate , int64_t * dist , BLOCK_SIZE bsize ) {\n MACROBLOCKD * const xd = & x -> e_mbd ;\n MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;\n INTERP_FILTER filter_ref ;\n if ( xd -> up_available ) filter_ref = xd -> mi [ - xd -> mi_stride ] -> mbmi . interp_filter ;\n else if ( xd -> left_available ) filter_ref = xd -> mi [ - 1 ] -> mbmi . interp_filter ;\n else filter_ref = EIGHTTAP ;\n mbmi -> sb_type = bsize ;\n mbmi -> mode = ZEROMV ;\n mbmi -> tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ tx_mode ] ) ;\n mbmi -> skip = 1 ;\n mbmi -> uv_mode = DC_PRED ;\n mbmi -> ref_frame [ 0 ] = LAST_FRAME ;\n mbmi -> ref_frame [ 1 ] = NONE ;\n mbmi -> mv [ 0 ] . as_int = 0 ;\n mbmi -> interp_filter = filter_ref ;\n xd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_int = 0 ;\n x -> skip = 1 ;\n * rate = 0 ;\n * dist = 0 ;\n }",
        "output": "1",
        "idx": 1305
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cmyk2bgr ( fz_context * ctx , fz_color_converter * cc , float * dv , const float * sv ) {\n # ifdef SLOWCMYK float rgb [ 3 ] ;\n cmyk_to_rgb ( ctx , NULL , sv , rgb ) ;\n dv [ 0 ] = rgb [ 2 ] ;\n dv [ 1 ] = rgb [ 1 ] ;\n dv [ 2 ] = rgb [ 0 ] ;\n # else dv [ 0 ] = 1 - fz_min ( sv [ 2 ] + sv [ 3 ] , 1 ) ;\n dv [ 1 ] = 1 - fz_min ( sv [ 1 ] + sv [ 3 ] , 1 ) ;\n dv [ 2 ] = 1 - fz_min ( sv [ 0 ] + sv [ 3 ] , 1 ) ;\n # endif }",
        "output": "0",
        "idx": 249
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void * qemu_kvm_cpu_thread_fn ( void * arg ) {\n CPUState * cpu = arg ;\n int r ;\n qemu_mutex_lock ( & qemu_global_mutex ) ;\n qemu_thread_get_self ( cpu -> thread ) ;\n cpu -> thread_id = qemu_get_thread_id ( ) ;\n cpu_single_env = cpu -> env_ptr ;\n r = kvm_init_vcpu ( cpu ) ;\n if ( r < 0 ) {\n fprintf ( stderr , \"kvm_init_vcpu failed: %s\\n\" , strerror ( - r ) ) ;\n exit ( 1 ) ;\n }\n qemu_kvm_init_cpu_signals ( cpu ) ;\n cpu -> created = true ;\n qemu_cond_signal ( & qemu_cpu_cond ) ;\n while ( 1 ) {\n if ( cpu_can_run ( cpu ) ) {\n r = kvm_cpu_exec ( cpu ) ;\n if ( r == EXCP_DEBUG ) {\n cpu_handle_guest_debug ( cpu ) ;\n }\n }\n qemu_kvm_wait_io_event ( cpu ) ;\n }\n return NULL ;\n }",
        "output": "1",
        "idx": 3287
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int alloc_addbyter ( int output , FILE * data ) {\n struct asprintf * infop = ( struct asprintf * ) data ;\n unsigned char outc = ( unsigned char ) output ;\n if ( ! infop -> buffer ) {\n infop -> buffer = malloc ( 32 ) ;\n if ( ! infop -> buffer ) {\n infop -> fail = 1 ;\n return - 1 ;\n }\n infop -> alloc = 32 ;\n infop -> len = 0 ;\n }\n else if ( infop -> len + 1 >= infop -> alloc ) {\n char * newptr ;\n newptr = realloc ( infop -> buffer , infop -> alloc * 2 ) ;\n if ( ! newptr ) {\n infop -> fail = 1 ;\n return - 1 ;\n }\n infop -> buffer = newptr ;\n infop -> alloc *= 2 ;\n }\n infop -> buffer [ infop -> len ] = outc ;\n infop -> len ++ ;\n return outc ;\n }",
        "output": "1",
        "idx": 2849
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int com_use ( String * buffer __attribute__ ( ( unused ) ) , char * line ) {\n char * tmp , buff [ FN_REFLEN + 1 ] ;\n int select_db ;\n bzero ( buff , sizeof ( buff ) ) ;\n strmake_buf ( buff , line ) ;\n tmp = get_arg ( buff , 0 ) ;\n if ( ! tmp || ! * tmp ) {\n put_info ( \"USE must be followed by a database name\" , INFO_ERROR ) ;\n return 0 ;\n }\n get_current_db ( ) ;\n if ( ! current_db || cmp_database ( charset_info , current_db , tmp ) ) {\n if ( one_database ) {\n skip_updates = 1 ;\n select_db = 0 ;\n }\n else select_db = 2 ;\n }\n else {\n skip_updates = 0 ;\n select_db = 1 ;\n }\n if ( select_db ) {\n if ( ! connected && reconnect ( ) ) return opt_reconnect ? - 1 : 1 ;\n if ( mysql_select_db ( & mysql , tmp ) ) {\n if ( mysql_errno ( & mysql ) != CR_SERVER_GONE_ERROR ) return put_error ( & mysql ) ;\n if ( reconnect ( ) ) return opt_reconnect ? - 1 : 1 ;\n if ( mysql_select_db ( & mysql , tmp ) ) return put_error ( & mysql ) ;\n }\n my_free ( current_db ) ;\n current_db = my_strdup ( tmp , MYF ( MY_WME ) ) ;\n # ifdef HAVE_READLINE if ( select_db > 1 ) build_completion_hash ( opt_rehash , 1 ) ;\n # endif }\n put_info ( \"Database changed\" , INFO_INFO ) ;\n return 0 ;\n }",
        "output": "1",
        "idx": 2470
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int show_object_fast ( const unsigned char * sha1 , enum object_type type , int exclude , uint32_t name_hash , struct packed_git * found_pack , off_t found_offset ) {\n fprintf ( stdout , \"%s\\n\" , sha1_to_hex ( sha1 ) ) ;\n return 1 ;\n }",
        "output": "0",
        "idx": 781
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_T_h4501SupplementaryService_item ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 736 \"./asn1/h225/h225.cnf\" tvbuff_t * h4501_tvb = NULL ;\n offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , NO_BOUND , NO_BOUND , FALSE , & h4501_tvb ) ;\n if ( h4501_tvb && tvb_reported_length ( h4501_tvb ) ) {\n call_dissector ( h4501_handle , h4501_tvb , actx -> pinfo , tree ) ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 1358
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int selinux_sb_statfs ( struct dentry * dentry ) {\n const struct cred * cred = current_cred ( ) ;\n struct common_audit_data ad ;\n ad . type = LSM_AUDIT_DATA_DENTRY ;\n ad . u . dentry = dentry -> d_sb -> s_root ;\n return superblock_has_perm ( cred , dentry -> d_sb , FILESYSTEM__GETATTR , & ad ) ;\n }",
        "output": "0",
        "idx": 2813
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl ) ;\n __exctype ( isdigit ) ;\n __exctype ( islower ) ;\n __exctype ( isgraph ) ;\n __exctype ( isprint )",
        "output": "1",
        "idx": 694
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;\n __exctype_l ( isalpha_l ) ;\n __exctype_l ( iscntrl_l ) ;\n __exctype_l ( isdigit_l ) ;\n __exctype_l ( islower_l )",
        "output": "1",
        "idx": 535
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( RecursiveDirectoryIterator , getSubPathname ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n char * sub_name ;\n int len ;\n char slash = SPL_HAS_FLAG ( intern -> flags , SPL_FILE_DIR_UNIXPATHS ) ? '/' : DEFAULT_SLASH ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n if ( intern -> u . dir . sub_path ) {\n len = spprintf ( & sub_name , 0 , \"%s%c%s\" , intern -> u . dir . sub_path , slash , intern -> u . dir . entry . d_name ) ;\n RETURN_STRINGL ( sub_name , len , 0 ) ;\n }\n else {\n RETURN_STRING ( intern -> u . dir . entry . d_name , 1 ) ;\n }\n }",
        "output": "1",
        "idx": 4163
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int parse_CNodeRestriction ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , struct CNodeRestriction * v , const char * fmt , ... ) {\n proto_tree * tree ;\n proto_item * item ;\n unsigned i ;\n const char * txt ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CNodeRestriction , & item , txt ) ;\n v -> cNode = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_cnoderestrict_cnode , tvb , offset , 4 , v -> cNode ) ;\n offset += 4 ;\n for ( i = 0 ;\n i < v -> cNode ;\n i ++ ) {\n struct CRestriction r ;\n ZERO_STRUCT ( r ) ;\n offset = parse_CRestriction ( tvb , offset , tree , pad_tree , & r , \"paNode[%u]\" , i ) ;\n offset = parse_padding ( tvb , offset , 4 , tree , \"padding_paNode[%u]\" , i ) ;\n }\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }",
        "output": "1",
        "idx": 1941
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void decode_color_temperature ( gchar * s , guint16 value ) {\n g_snprintf ( s , ITEM_LABEL_LENGTH , \"%d [Mired] (%d [K])\" , value , 1000000 / value ) ;\n return ;\n }",
        "output": "1",
        "idx": 3065
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int parse_CRestrictionArray ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , const char * fmt , ... ) {\n guint8 present , count ;\n proto_tree * tree ;\n proto_item * item ;\n const char * txt ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CRestrictionArray , & item , txt ) ;\n pad_tree = tree ;\n count = tvb_get_guint8 ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_crestrictarray_count , tvb , offset , 1 , count ) ;\n offset += 1 ;\n present = tvb_get_guint8 ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_crestrictarray_present , tvb , offset , 1 , present ) ;\n offset += 1 ;\n if ( present ) {\n unsigned i ;\n offset = parse_padding ( tvb , offset , 4 , pad_tree , \"paddingCRestrictionPresent\" ) ;\n for ( i = 0 ;\n i < count ;\n i ++ ) {\n struct CRestriction r ;\n offset = parse_CRestriction ( tvb , offset , tree , pad_tree , & r , \"Restriction[%d]\" , i ) ;\n }\n }\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }",
        "output": "1",
        "idx": 1317
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void nautilus_file_mark_desktop_file_trusted ( GFile * file , GtkWindow * parent_window , gboolean interactive , NautilusOpCallback done_callback , gpointer done_callback_data ) {\n GTask * task ;\n MarkTrustedJob * job ;\n job = op_job_new ( MarkTrustedJob , parent_window ) ;\n job -> file = g_object_ref ( file ) ;\n job -> interactive = interactive ;\n job -> done_callback = done_callback ;\n job -> done_callback_data = done_callback_data ;\n task = g_task_new ( NULL , NULL , mark_trusted_task_done , job ) ;\n g_task_set_task_data ( task , job , NULL ) ;\n g_task_run_in_thread ( task , mark_trusted_task_thread_func ) ;\n g_object_unref ( task ) ;\n }",
        "output": "1",
        "idx": 247
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int for_pos_int_continue ( i_ctx_t * i_ctx_p ) {\n os_ptr op = osp ;\n register es_ptr ep = esp ;\n int var = ep [ - 3 ] . value . intval ;\n if ( var > ep [ - 1 ] . value . intval ) {\n esp -= 5 ;\n return o_pop_estack ;\n }\n push ( 1 ) ;\n make_int ( op , var ) ;\n ep [ - 3 ] . value . intval = var + ep [ - 2 ] . value . intval ;\n ref_assign_inline ( ep + 2 , ep ) ;\n esp = ep + 2 ;\n return o_push_estack ;\n }",
        "output": "0",
        "idx": 918
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( SupervisedUserNavigationThrottleNotSupervisedTest , DontBlock ) {\n BlockHost ( kExampleHost ) ;\n WebContents * tab = browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) ;\n GURL blocked_url = embedded_test_server ( ) -> GetURL ( kExampleHost , \"/supervised_user/simple.html\" ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , blocked_url ) ;\n EXPECT_FALSE ( tab -> ShowingInterstitialPage ( ) ) ;\n }",
        "output": "1",
        "idx": 738
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void get_type_category_preferred ( Oid typid , char * typcategory , bool * typispreferred ) {\n HeapTuple tp ;\n Form_pg_type typtup ;\n tp = SearchSysCache1 ( TYPEOID , ObjectIdGetDatum ( typid ) ) ;\n if ( ! HeapTupleIsValid ( tp ) ) elog ( ERROR , \"cache lookup failed for type %u\" , typid ) ;\n typtup = ( Form_pg_type ) GETSTRUCT ( tp ) ;\n * typcategory = typtup -> typcategory ;\n * typispreferred = typtup -> typispreferred ;\n ReleaseSysCache ( tp ) ;\n }",
        "output": "0",
        "idx": 4395
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hb_face_t * hb_face_create ( hb_blob_t * blob , unsigned int index ) {\n hb_face_t * face ;\n if ( unlikely ( ! blob || ! hb_blob_get_length ( blob ) ) ) return hb_face_get_empty ( ) ;\n hb_face_for_data_closure_t * closure = _hb_face_for_data_closure_create ( OT : : Sanitizer < OT : : OpenTypeFontFile > : : sanitize ( hb_blob_reference ( blob ) ) , index ) ;\n if ( unlikely ( ! closure ) ) return hb_face_get_empty ( ) ;\n face = hb_face_create_for_tables ( _hb_face_for_data_reference_table , closure , ( hb_destroy_func_t ) _hb_face_for_data_closure_destroy ) ;\n hb_face_set_index ( face , index ) ;\n return face ;\n }",
        "output": "1",
        "idx": 3597
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Datum nlikesel ( PG_FUNCTION_ARGS ) {\n PG_RETURN_FLOAT8 ( patternsel ( fcinfo , Pattern_Type_Like , true ) ) ;\n }",
        "output": "0",
        "idx": 2893
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _doSetSessionAuth ( ArchiveHandle * AH , const char * user ) {\n PQExpBuffer cmd = createPQExpBuffer ( ) ;\n appendPQExpBufferStr ( cmd , \"SET SESSION AUTHORIZATION \" ) ;\n if ( user && * user ) appendStringLiteralAHX ( cmd , user , AH ) ;\n else appendPQExpBufferStr ( cmd , \"DEFAULT\" ) ;\n appendPQExpBufferChar ( cmd , ';\n' ) ;\n if ( RestoringToDB ( AH ) ) {\n PGresult * res ;\n res = PQexec ( AH -> connection , cmd -> data ) ;\n if ( ! res || PQresultStatus ( res ) != PGRES_COMMAND_OK ) exit_horribly ( modulename , \"could not set session user to \\\"%s\\\": %s\" , user , PQerrorMessage ( AH -> connection ) ) ;\n PQclear ( res ) ;\n }\n else ahprintf ( AH , \"%s\\n\\n\" , cmd -> data ) ;\n destroyPQExpBuffer ( cmd ) ;\n }",
        "output": "0",
        "idx": 3244
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char * cluster_conn_opts ( ClusterInfo * cluster ) {\n static char conn_opts [ MAXPGPATH + NAMEDATALEN + 100 ] ;\n if ( cluster -> sockdir ) snprintf ( conn_opts , sizeof ( conn_opts ) , \"--host \\\"%s\\\" --port %d --username \\\"%s\\\"\" , cluster -> sockdir , cluster -> port , os_info . user ) ;\n else snprintf ( conn_opts , sizeof ( conn_opts ) , \"--port %d --username \\\"%s\\\"\" , cluster -> port , os_info . user ) ;\n return conn_opts ;\n }",
        "output": "1",
        "idx": 476
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void SetPixelYTraits ( Image * image , const PixelTrait traits ) {\n image -> channel_map [ YPixelChannel ] . traits = traits ;\n }",
        "output": "0",
        "idx": 1879
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , AlwaysInBackground ) {\n StartHttpsServer ( false ) ;\n StartHttpServer ( ) ;\n NavigateInBackgroundAndClose ( https_test_server_ -> GetURL ( \"/simple.html\" ) ) ;\n NavigateInBackgroundAndClose ( http_test_server_ -> GetURL ( \"/simple.html\" ) ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 0 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;\n }",
        "output": "1",
        "idx": 813
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl ) ;\n __exctype ( isdigit ) ;\n __exctype ( islower )",
        "output": "1",
        "idx": 2167
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rtp_dyn_payloads_init ( void ) {\n if ( rtp_dyn_payloads == NULL ) {\n rtp_dyn_payloads = g_hash_table_new ( NULL , NULL ) ;\n wmem_register_callback ( wmem_file_scope ( ) , wmem_rtp_dyn_payload_destroy_cb , NULL ) ;\n }\n }",
        "output": "0",
        "idx": 3433
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fadst4 ( const int16_t * input , int16_t * output ) {\n int x0 , x1 , x2 , x3 ;\n int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;\n x0 = input [ 0 ] ;\n x1 = input [ 1 ] ;\n x2 = input [ 2 ] ;\n x3 = input [ 3 ] ;\n if ( ! ( x0 | x1 | x2 | x3 ) ) {\n output [ 0 ] = output [ 1 ] = output [ 2 ] = output [ 3 ] = 0 ;\n return ;\n }\n s0 = sinpi_1_9 * x0 ;\n s1 = sinpi_4_9 * x0 ;\n s2 = sinpi_2_9 * x1 ;\n s3 = sinpi_1_9 * x1 ;\n s4 = sinpi_3_9 * x2 ;\n s5 = sinpi_4_9 * x3 ;\n s6 = sinpi_2_9 * x3 ;\n s7 = x0 + x1 - x3 ;\n x0 = s0 + s2 + s5 ;\n x1 = sinpi_3_9 * s7 ;\n x2 = s1 - s3 + s6 ;\n x3 = s4 ;\n s0 = x0 + x3 ;\n s1 = x1 ;\n s2 = x2 - x3 ;\n s3 = x2 - x0 + x3 ;\n output [ 0 ] = fdct_round_shift ( s0 ) ;\n output [ 1 ] = fdct_round_shift ( s1 ) ;\n output [ 2 ] = fdct_round_shift ( s2 ) ;\n output [ 3 ] = fdct_round_shift ( s3 ) ;\n }",
        "output": "1",
        "idx": 357
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int parse_CInGroupSortAggregSet ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , const char * fmt , ... ) {\n proto_item * item ;\n proto_tree * tree ;\n va_list ap ;\n enum CInGroupSortAggregSet_type type ;\n const char * txt ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CInGroupSortAggregSet , & item , txt ) ;\n offset = parse_CInGroupSortAggregSet_type ( tvb , offset , tree , & type ) ;\n offset = parse_padding ( tvb , offset , 4 , pad_tree , \"CInGroupSortAggregSet\" ) ;\n if ( type == GroupIdValue ) {\n struct CBaseStorageVariant id ;\n offset = parse_CBaseStorageVariant ( tvb , offset , tree , pad_tree , & id , \"inGroupId\" ) ;\n }\n offset = parse_CSortSet ( tvb , offset , tree , pad_tree , \"SortSet\" ) ;\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }",
        "output": "1",
        "idx": 310
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_ReleaseComplete_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 515 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_ReleaseComplete_UUIE , ReleaseComplete_UUIE_sequence ) ;\n # line 519 \"./asn1/h225/h225.cnf\" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> cs_type = H225_RELEASE_COMPLET ;\n g_snprintf ( h225_pi -> frame_label , 50 , \"%s\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) ) ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 4370
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static call_list * call_list_append ( call_list * list , guint16 scallno ) {\n call_list * node = wmem_new0 ( wmem_packet_scope ( ) , call_list ) ;\n node -> scallno = scallno ;\n if ( list ) {\n call_list * cur = list ;\n while ( cur -> next ) {\n cur = cur -> next ;\n }\n cur -> next = node ;\n return list ;\n }\n else {\n return node ;\n }\n }",
        "output": "0",
        "idx": 2812
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t u_printf_uchar_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n int32_t written = 0 ;\n UChar arg = ( UChar ) ( args [ 0 ] . int64Value ) ;\n written = handler -> pad_and_justify ( context , info , & arg , 1 ) ;\n return written ;\n }",
        "output": "1",
        "idx": 1710
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static FILE * dumpcffstrings ( struct pschars * strs ) {\n FILE * file = tmpfile ( ) ;\n _dumpcffstrings ( file , strs ) ;\n PSCharsFree ( strs ) ;\n return ( file ) ;\n }",
        "output": "0",
        "idx": 1526
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mt_init ( mtrand * mt , uint32_t seed ) {\n int i ;\n mt -> mt_buffer_ [ 0 ] = seed ;\n mt -> mt_index_ = MT_LEN ;\n for ( i = 1 ;\n i < MT_LEN ;\n i ++ ) {\n mt -> mt_buffer_ [ i ] = ( 1812433253UL * ( mt -> mt_buffer_ [ i - 1 ] ^ ( mt -> mt_buffer_ [ i - 1 ] >> 30 ) ) + i ) ;\n }\n }",
        "output": "1",
        "idx": 3037
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static vpx_codec_err_t encoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) {\n vpx_codec_err_t res = VPX_CODEC_OK ;\n ( void ) data ;\n if ( ctx -> priv == NULL ) {\n vpx_codec_alg_priv_t * const priv = vpx_calloc ( 1 , sizeof ( * priv ) ) ;\n if ( priv == NULL ) return VPX_CODEC_MEM_ERROR ;\n ctx -> priv = ( vpx_codec_priv_t * ) priv ;\n ctx -> priv -> init_flags = ctx -> init_flags ;\n ctx -> priv -> enc . total_encoders = 1 ;\n if ( ctx -> config . enc ) {\n priv -> cfg = * ctx -> config . enc ;\n ctx -> config . enc = & priv -> cfg ;\n }\n priv -> extra_cfg = default_extra_cfg ;\n vp9_initialize_enc ( ) ;\n res = validate_config ( priv , & priv -> cfg , & priv -> extra_cfg ) ;\n if ( res == VPX_CODEC_OK ) {\n set_encoder_config ( & priv -> oxcf , & priv -> cfg , & priv -> extra_cfg ) ;\n priv -> cpi = vp9_create_compressor ( & priv -> oxcf ) ;\n if ( priv -> cpi == NULL ) res = VPX_CODEC_MEM_ERROR ;\n else priv -> cpi -> output_pkt_list = & priv -> pkt_list . head ;\n }\n }\n return res ;\n }",
        "output": "1",
        "idx": 2752
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __inline__ __u64 __fswab64 ( __u64 val ) {\n # if defined ( __arch_swab64 ) return __arch_swab64 ( val ) ;\n # elif defined ( __SWAB_64_THRU_32__ ) __u32 h = val >> 32 ;\n __u32 l = val & ( ( 1ULL << 32 ) - 1 ) ;\n return ( ( ( __u64 ) __fswab32 ( l ) ) << 32 ) | ( ( __u64 ) ( __fswab32 ( h ) ) ) ;\n # else return ___constant_swab64 ( val ) ;\n # endif }",
        "output": "1",
        "idx": 87
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cpu_stop_current ( void ) {\n if ( cpu_single_env ) {\n CPUState * cpu_single_cpu = ENV_GET_CPU ( cpu_single_env ) ;\n cpu_single_cpu -> stop = false ;\n cpu_single_cpu -> stopped = true ;\n cpu_exit ( cpu_single_cpu ) ;\n qemu_cond_signal ( & qemu_pause_cond ) ;\n }\n }",
        "output": "1",
        "idx": 3858
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_pvfs2_geteattr_response ( tvbuff_t * tvb , proto_tree * tree , int offset , packet_info * pinfo _U_ ) {\n offset += 4 ;\n offset = dissect_ds_keyval_array ( tvb , tree , offset ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 549
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int kvm_device_msi_assign ( KVMState * s , uint32_t dev_id , int virq ) {\n return kvm_assign_irq_internal ( s , dev_id , KVM_DEV_IRQ_HOST_MSI | KVM_DEV_IRQ_GUEST_MSI , virq ) ;\n }",
        "output": "0",
        "idx": 343
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipvideo_decode_block_opcode_0x3 ( IpvideoContext * s ) {\n unsigned char B ;\n int x , y ;\n if ( ! s -> is_16bpp ) {\n B = bytestream2_get_byte ( & s -> stream_ptr ) ;\n }\n else {\n B = bytestream2_get_byte ( & s -> mv_ptr ) ;\n }\n if ( B < 56 ) {\n x = - ( 8 + ( B % 7 ) ) ;\n y = - ( B / 7 ) ;\n }\n else {\n x = - ( - 14 + ( ( B - 56 ) % 29 ) ) ;\n y = - ( 8 + ( ( B - 56 ) / 29 ) ) ;\n }\n av_dlog ( NULL , \" motion byte = %d, (x, y) = (%d, %d)\\n\" , B , x , y ) ;\n return copy_from ( s , & s -> current_frame , x , y ) ;\n }",
        "output": "1",
        "idx": 32
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gpgme_error_t add_io_cb ( engine_gpgsm_t gpgsm , iocb_data_t * iocbd , gpgme_io_cb_t handler ) {\n gpgme_error_t err ;\n TRACE_BEG2 ( DEBUG_ENGINE , \"engine-gpgsm:add_io_cb\" , gpgsm , \"fd %d, dir %d\" , iocbd -> fd , iocbd -> dir ) ;\n err = ( * gpgsm -> io_cbs . add ) ( gpgsm -> io_cbs . add_priv , iocbd -> fd , iocbd -> dir , handler , iocbd -> data , & iocbd -> tag ) ;\n if ( err ) return TRACE_ERR ( err ) ;\n if ( ! iocbd -> dir ) err = _gpgme_io_set_nonblocking ( iocbd -> fd ) ;\n return TRACE_ERR ( err ) ;\n }",
        "output": "0",
        "idx": 1989
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PkRoleEnum pk_transaction_get_role ( PkTransaction * transaction ) {\n g_return_val_if_fail ( PK_IS_TRANSACTION ( transaction ) , FALSE ) ;\n return transaction -> priv -> role ;\n }",
        "output": "0",
        "idx": 523
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dissect_h225_CallReferenceValue ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 0U , 65535U , NULL , FALSE ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 3540
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int EVP_CIPHER_CTX_reset ( EVP_CIPHER_CTX * c ) {\n if ( c == NULL ) return 1 ;\n if ( c -> cipher != NULL ) {\n if ( c -> cipher -> cleanup && ! c -> cipher -> cleanup ( c ) ) return 0 ;\n if ( c -> cipher_data && c -> cipher -> ctx_size ) OPENSSL_cleanse ( c -> cipher_data , c -> cipher -> ctx_size ) ;\n }\n OPENSSL_free ( c -> cipher_data ) ;\n # ifndef OPENSSL_NO_ENGINE ENGINE_finish ( c -> engine ) ;\n # endif memset ( c , 0 , sizeof ( * c ) ) ;\n return 1 ;\n }",
        "output": "0",
        "idx": 3886
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int i2d_PUBKEY_bio ( BIO * bp , EVP_PKEY * pkey ) {\n return ASN1_i2d_bio_of ( EVP_PKEY , i2d_PUBKEY , bp , pkey ) ;\n }",
        "output": "0",
        "idx": 4115
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void search_stack_free ( void * key , void * data ) {\n ber_memfree_x ( data , NULL ) ;\n }",
        "output": "0",
        "idx": 678
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qdev_unplug ( DeviceState * dev ) {\n if ( ! dev -> parent_bus -> allow_hotplug ) {\n qemu_error ( \"Bus %s does not support hotplugging\\n\" , dev -> parent_bus -> name ) ;\n return - 1 ;\n }\n assert ( dev -> info -> unplug != NULL ) ;\n return dev -> info -> unplug ( dev ) ;\n }",
        "output": "0",
        "idx": 2306
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_T_nsp_data ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 805 \"./asn1/h225/h225.cnf\" tvbuff_t * next_tvb = NULL ;\n offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , NO_BOUND , NO_BOUND , FALSE , & next_tvb ) ;\n if ( next_tvb && tvb_reported_length ( next_tvb ) ) {\n call_dissector ( ( nsp_handle ) ? nsp_handle : data_handle , next_tvb , actx -> pinfo , tree ) ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 1689
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Datum ExecEvalOr ( BoolExprState * orExpr , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {\n List * clauses = orExpr -> args ;\n ListCell * clause ;\n bool AnyNull ;\n if ( isDone ) * isDone = ExprSingleResult ;\n AnyNull = false ;\n foreach ( clause , clauses ) {\n ExprState * clausestate = ( ExprState * ) lfirst ( clause ) ;\n Datum clause_value ;\n clause_value = ExecEvalExpr ( clausestate , econtext , isNull , NULL ) ;\n if ( * isNull ) AnyNull = true ;\n else if ( DatumGetBool ( clause_value ) ) return clause_value ;\n }\n * isNull = AnyNull ;\n return BoolGetDatum ( false ) ;\n }",
        "output": "0",
        "idx": 730
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __tipc_nl_compat_doit ( struct tipc_nl_compat_cmd_doit * cmd , struct tipc_nl_compat_msg * msg ) {\n int err ;\n struct sk_buff * doit_buf ;\n struct sk_buff * trans_buf ;\n struct nlattr * * attrbuf ;\n struct genl_info info ;\n trans_buf = alloc_skb ( NLMSG_GOODSIZE , GFP_KERNEL ) ;\n if ( ! trans_buf ) return - ENOMEM ;\n err = ( * cmd -> transcode ) ( cmd , trans_buf , msg ) ;\n if ( err ) goto trans_out ;\n attrbuf = kmalloc ( ( tipc_genl_family . maxattr + 1 ) * sizeof ( struct nlattr * ) , GFP_KERNEL ) ;\n if ( ! attrbuf ) {\n err = - ENOMEM ;\n goto trans_out ;\n }\n err = nla_parse ( attrbuf , tipc_genl_family . maxattr , ( const struct nlattr * ) trans_buf -> data , trans_buf -> len , NULL ) ;\n if ( err ) goto parse_out ;\n doit_buf = alloc_skb ( NLMSG_GOODSIZE , GFP_KERNEL ) ;\n if ( ! doit_buf ) {\n err = - ENOMEM ;\n goto parse_out ;\n }\n doit_buf -> sk = msg -> dst_sk ;\n memset ( & info , 0 , sizeof ( info ) ) ;\n info . attrs = attrbuf ;\n err = ( * cmd -> doit ) ( doit_buf , & info ) ;\n kfree_skb ( doit_buf ) ;\n parse_out : kfree ( attrbuf ) ;\n trans_out : kfree_skb ( trans_buf ) ;\n return err ;\n }",
        "output": "0",
        "idx": 1932
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Expr * make_orclause ( List * orclauses ) {\n BoolExpr * expr = makeNode ( BoolExpr ) ;\n expr -> boolop = OR_EXPR ;\n expr -> args = orclauses ;\n expr -> location = - 1 ;\n return ( Expr * ) expr ;\n }",
        "output": "0",
        "idx": 217
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void write_frame_size ( const VP9_COMMON * cm , struct vp9_write_bit_buffer * wb ) {\n vp9_wb_write_literal ( wb , cm -> width - 1 , 16 ) ;\n vp9_wb_write_literal ( wb , cm -> height - 1 , 16 ) ;\n write_display_size ( cm , wb ) ;\n }",
        "output": "0",
        "idx": 1749
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileObject , fgets ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n if ( spl_filesystem_file_read ( intern , 0 TSRMLS_CC ) == FAILURE ) {\n RETURN_FALSE ;\n }\n RETURN_STRINGL ( intern -> u . file . current_line , intern -> u . file . current_line_len , 1 ) ;\n }",
        "output": "1",
        "idx": 1571
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PkTransaction * pk_transaction_new ( GKeyFile * conf , GDBusNodeInfo * introspection ) {\n PkTransaction * transaction ;\n transaction = g_object_new ( PK_TYPE_TRANSACTION , NULL ) ;\n transaction -> priv -> conf = g_key_file_ref ( conf ) ;\n transaction -> priv -> job = pk_backend_job_new ( conf ) ;\n transaction -> priv -> introspection = g_dbus_node_info_ref ( introspection ) ;\n return PK_TRANSACTION ( transaction ) ;\n }",
        "output": "0",
        "idx": 2861
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _UTF16BEOpen ( UConverter * cnv , UConverterLoadArgs * pArgs , UErrorCode * pErrorCode ) {\n if ( UCNV_GET_VERSION ( cnv ) <= 1 ) {\n _UTF16BEReset ( cnv , UCNV_RESET_BOTH ) ;\n }\n else {\n * pErrorCode = U_ILLEGAL_ARGUMENT_ERROR ;\n }\n }",
        "output": "1",
        "idx": 2038
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void * checked_xcalloc ( size_t num , size_t size ) {\n alloc_limit_assert ( \"checked_xcalloc\" , ( num * size ) ) ;\n return xcalloc ( num , size ) ;\n }",
        "output": "1",
        "idx": 631
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static hb_user_data_key_t user_data_key_reference ( hb_user_data_key_t l ) {\n return l ;\n }",
        "output": "1",
        "idx": 2212
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int authenticate_nss_2_3 ( struct crypto_instance * instance , unsigned char * buf , int * buf_len ) {\n if ( hash_to_nss [ instance -> crypto_hash_type ] ) {\n unsigned char tmp_hash [ hash_len [ instance -> crypto_hash_type ] ] ;\n int datalen = * buf_len - hash_len [ instance -> crypto_hash_type ] ;\n if ( calculate_nss_hash ( instance , buf , datalen , tmp_hash ) < 0 ) {\n return - 1 ;\n }\n if ( memcmp ( tmp_hash , buf + datalen , hash_len [ instance -> crypto_hash_type ] ) != 0 ) {\n log_printf ( instance -> log_level_error , \"Digest does not match\" ) ;\n return - 1 ;\n }\n * buf_len = datalen ;\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 1451
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void show_object ( struct object * object , const char * name , void * data ) {\n struct bitmap * base = data ;\n int bitmap_pos ;\n bitmap_pos = bitmap_position ( object -> oid . hash ) ;\n if ( bitmap_pos < 0 ) bitmap_pos = ext_index_add_object ( object , name ) ;\n bitmap_set ( base , bitmap_pos ) ;\n }",
        "output": "0",
        "idx": 3703
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t u_scanf_octal_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {\n int32_t len ;\n int32_t skipped ;\n void * num = ( void * ) ( args [ 0 ] . ptrValue ) ;\n int64_t result ;\n skipped = u_scanf_skip_leading_ws ( input , info -> fPadChar ) ;\n ufile_fill_uchar_buffer ( input ) ;\n len = ( int32_t ) ( input -> str . fLimit - input -> str . fPos ) ;\n if ( info -> fWidth != - 1 ) len = ufmt_min ( len , info -> fWidth ) ;\n result = ufmt_uto64 ( input -> str . fPos , & len , 8 ) ;\n input -> str . fPos += len ;\n if ( ! info -> fSkipArg ) {\n if ( info -> fIsShort ) * ( int16_t * ) num = ( int16_t ) ( UINT16_MAX & result ) ;\n else if ( info -> fIsLongLong ) * ( int64_t * ) num = result ;\n else * ( int32_t * ) num = ( int32_t ) ( UINT32_MAX & result ) ;\n }\n * argConverted = ! info -> fSkipArg ;\n return len + skipped ;\n }",
        "output": "1",
        "idx": 3646
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemuMonitorJSONScreendump ( qemuMonitorPtr mon , const char * file ) {\n int ret ;\n virJSONValuePtr cmd , reply = NULL ;\n cmd = qemuMonitorJSONMakeCommand ( \"screendump\" , \"s:filename\" , file , NULL ) ;\n if ( ! cmd ) return - 1 ;\n ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;\n if ( ret == 0 ) ret = qemuMonitorJSONCheckError ( cmd , reply ) ;\n virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }",
        "output": "0",
        "idx": 2965
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned char clamp_u8 ( float v ) {\n if ( v > 255. ) return 255 ;\n else if ( v < 0 ) return 0 ;\n else return floor ( v + .5 ) ;\n }",
        "output": "0",
        "idx": 3345
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gboolean k12_dump_open ( wtap_dumper * wdh , int * err ) {\n k12_dump_t * k12 ;\n if ( ! wtap_dump_file_write ( wdh , k12_file_magic , 8 , err ) ) {\n return FALSE ;\n }\n if ( wtap_dump_file_seek ( wdh , K12_FILE_HDR_LEN , SEEK_SET , err ) == - 1 ) return FALSE ;\n wdh -> subtype_write = k12_dump ;\n wdh -> subtype_finish = k12_dump_finish ;\n k12 = ( k12_dump_t * ) g_malloc ( sizeof ( k12_dump_t ) ) ;\n wdh -> priv = ( void * ) k12 ;\n k12 -> file_len = K12_FILE_HDR_LEN ;\n k12 -> num_of_records = 0 ;\n k12 -> file_offset = K12_FILE_HDR_LEN ;\n return TRUE ;\n }",
        "output": "0",
        "idx": 3506
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ttfFont * ttfFont__create ( gs_font_dir * dir ) {\n gs_memory_t * mem = dir -> memory -> stable_memory ;\n ttfFont * ttf ;\n if ( dir -> ttm == NULL ) {\n gx_ttfMemory * m = gs_alloc_struct ( mem , gx_ttfMemory , & st_gx_ttfMemory , \"ttfFont__create(gx_ttfMemory)\" ) ;\n if ( ! m ) return 0 ;\n m -> super . alloc_struct = gx_ttfMemory__alloc_struct ;\n m -> super . alloc_bytes = gx_ttfMemory__alloc_bytes ;\n m -> super . free = gx_ttfMemory__free ;\n m -> memory = mem ;\n dir -> ttm = m ;\n }\n if ( ttfInterpreter__obtain ( & dir -> ttm -> super , & dir -> tti ) ) return 0 ;\n if ( gx_san__obtain ( mem , & dir -> san ) ) return 0 ;\n ttf = gs_alloc_struct ( mem , ttfFont , & st_ttfFont , \"ttfFont__create\" ) ;\n if ( ttf == NULL ) return 0 ;\n # ifdef DEBUG ttfFont__init ( ttf , & dir -> ttm -> super , DebugRepaint , ( gs_debug_c ( 'Y' ) ? DebugPrint : NULL ) , mem ) ;\n # else ttfFont__init ( ttf , & dir -> ttm -> super , DebugRepaint , NULL , mem ) ;\n # endif return ttf ;\n }",
        "output": "0",
        "idx": 886
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int zcond ( i_ctx_t * i_ctx_p ) {\n os_ptr op = osp ;\n es_ptr ep = esp ;\n if ( ! r_is_array ( op ) ) return_op_typecheck ( op ) ;\n check_execute ( * op ) ;\n if ( ( r_size ( op ) & 1 ) != 0 ) return_error ( gs_error_rangecheck ) ;\n if ( r_size ( op ) == 0 ) return zpop ( i_ctx_p ) ;\n check_estack ( 3 ) ;\n esp = ep += 3 ;\n ref_assign ( ep - 2 , op ) ;\n make_op_estack ( ep - 1 , cond_continue ) ;\n array_get ( imemory , op , 0L , ep ) ;\n esfile_check_cache ( ) ;\n pop ( 1 ) ;\n return o_push_estack ;\n }",
        "output": "0",
        "idx": 1267
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void * U_CALLCONV myMemRealloc ( const void * context , void * mem , size_t size ) {\n char * p = ( char * ) mem ;\n char * retPtr ;\n if ( p != NULL ) {\n p -= sizeof ( ctest_AlignedMemory ) ;\n }\n retPtr = realloc ( p , size + sizeof ( ctest_AlignedMemory ) ) ;\n if ( retPtr != NULL ) {\n p += sizeof ( ctest_AlignedMemory ) ;\n }\n return retPtr ;\n }",
        "output": "0",
        "idx": 323
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void openpic_register_types ( void ) {\n type_register_static ( & openpic_info ) ;\n }",
        "output": "0",
        "idx": 1000
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * pool_strdup ( const char * s ) {\n char * r = pool_alloc ( strlen ( s ) + 1 ) ;\n strcpy ( r , s ) ;\n return r ;\n }",
        "output": "1",
        "idx": 2833
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void write_sync_code ( struct vp9_write_bit_buffer * wb ) {\n vp9_wb_write_literal ( wb , VP9_SYNC_CODE_0 , 8 ) ;\n vp9_wb_write_literal ( wb , VP9_SYNC_CODE_1 , 8 ) ;\n vp9_wb_write_literal ( wb , VP9_SYNC_CODE_2 , 8 ) ;\n }",
        "output": "0",
        "idx": 311
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GType hb_gobject_ ## name ## _get_type ( void ) \\ {\n static gsize type_id = 0 ;\n if ( g_once_init_enter ( & type_id ) ) {\n GType id = g_boxed_type_register_static ( g_intern_static_string ( \"hb_\" # name \"_t\" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;\n g_once_init_leave ( & type_id , id ) ;\n }\n return type_id ;\n \\ }\n # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font )",
        "output": "1",
        "idx": 1590
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int evhttp_connection_incoming_fail ( struct evhttp_request * req , enum evhttp_connection_error error ) {\n switch ( error ) {\n case EVCON_HTTP_TIMEOUT : case EVCON_HTTP_EOF : return ( - 1 ) ;\n case EVCON_HTTP_INVALID_HEADER : default : if ( req -> uri ) {\n free ( req -> uri ) ;\n req -> uri = NULL ;\n }\n ( * req -> cb ) ( req , req -> cb_arg ) ;\n }\n return ( 0 ) ;\n }",
        "output": "1",
        "idx": 2960
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_update_mv_count ( VP9_COMMON * cm , const MACROBLOCKD * xd ) {\n const MODE_INFO * mi = xd -> mi [ 0 ] ;\n const MB_MODE_INFO * const mbmi = & mi -> mbmi ;\n if ( mbmi -> sb_type < BLOCK_8X8 ) {\n const int num_4x4_w = num_4x4_blocks_wide_lookup [ mbmi -> sb_type ] ;\n const int num_4x4_h = num_4x4_blocks_high_lookup [ mbmi -> sb_type ] ;\n int idx , idy ;\n for ( idy = 0 ;\n idy < 2 ;\n idy += num_4x4_h ) {\n for ( idx = 0 ;\n idx < 2 ;\n idx += num_4x4_w ) {\n const int i = idy * 2 + idx ;\n if ( mi -> bmi [ i ] . as_mode == NEWMV ) inc_mvs ( mbmi , mi -> bmi [ i ] . as_mv , & cm -> counts . mv ) ;\n }\n }\n }\n else {\n if ( mbmi -> mode == NEWMV ) inc_mvs ( mbmi , mbmi -> mv , & cm -> counts . mv ) ;\n }\n }",
        "output": "1",
        "idx": 567
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void prc_destroy ( jpc_enc_prc_t * prc ) {\n jpc_enc_cblk_t * cblk ;\n uint_fast32_t cblkno ;\n if ( prc -> cblks ) {\n for ( cblkno = 0 , cblk = prc -> cblks ;\n cblkno < prc -> numcblks ;\n ++ cblkno , ++ cblk ) {\n cblk_destroy ( cblk ) ;\n }\n jas_free ( prc -> cblks ) ;\n }\n if ( prc -> incltree ) {\n jpc_tagtree_destroy ( prc -> incltree ) ;\n }\n if ( prc -> nlibtree ) {\n jpc_tagtree_destroy ( prc -> nlibtree ) ;\n }\n if ( prc -> savincltree ) {\n jpc_tagtree_destroy ( prc -> savincltree ) ;\n }\n if ( prc -> savnlibtree ) {\n jpc_tagtree_destroy ( prc -> savnlibtree ) ;\n }\n }",
        "output": "1",
        "idx": 4306
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static xmlLinkPtr xmlListHigherSearch ( xmlListPtr l , void * data ) {\n xmlLinkPtr lk ;\n if ( l == NULL ) return ( NULL ) ;\n for ( lk = l -> sentinel -> prev ;\n lk != l -> sentinel && l -> linkCompare ( lk -> data , data ) > 0 ;\n lk = lk -> prev ) ;\n return lk ;\n }",
        "output": "1",
        "idx": 139
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void e1000e_read_ps_rx_descr ( E1000ECore * core , uint8_t * desc , hwaddr ( * buff_addr ) [ MAX_PS_BUFFERS ] ) {\n int i ;\n union e1000_rx_desc_packet_split * d = ( union e1000_rx_desc_packet_split * ) desc ;\n for ( i = 0 ;\n i < MAX_PS_BUFFERS ;\n i ++ ) {\n ( * buff_addr ) [ i ] = le64_to_cpu ( d -> read . buffer_addr [ i ] ) ;\n }\n trace_e1000e_rx_desc_ps_read ( ( * buff_addr ) [ 0 ] , ( * buff_addr ) [ 1 ] , ( * buff_addr ) [ 2 ] , ( * buff_addr ) [ 3 ] ) ;\n }",
        "output": "0",
        "idx": 4323
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dtls1_clear_record_buffer ( SSL * s ) {\n pitem * item ;\n for ( item = pqueue_pop ( s -> d1 -> sent_messages ) ;\n item != NULL ;\n item = pqueue_pop ( s -> d1 -> sent_messages ) ) {\n dtls1_hm_fragment_free ( ( hm_fragment * ) item -> data ) ;\n pitem_free ( item ) ;\n }\n }",
        "output": "1",
        "idx": 520
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void SetPixelIndexTraits ( Image * image , const PixelTrait traits ) {\n image -> channel_map [ IndexPixelChannel ] . traits = traits ;\n }",
        "output": "0",
        "idx": 2026
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cgfs_destroy ( void * hdata ) {\n struct cgfs_data * d = hdata ;\n if ( ! d ) return ;\n free ( d -> name ) ;\n lxc_cgroup_process_info_free_and_remove ( d -> info ) ;\n lxc_cgroup_put_meta ( d -> meta ) ;\n free ( d ) ;\n }",
        "output": "0",
        "idx": 790
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const gchar * nautilus_mime_types_group_get_name ( gint group_index ) {\n g_return_val_if_fail ( group_index < G_N_ELEMENTS ( mimetype_groups ) , NULL ) ;\n return gettext ( mimetype_groups [ group_index ] . name ) ;\n }",
        "output": "0",
        "idx": 53
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int selinux_ismaclabel ( const char * name ) {\n return ( strcmp ( name , XATTR_SELINUX_SUFFIX ) == 0 ) ;\n }",
        "output": "0",
        "idx": 2407
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mspack_fmap_free ( void * mem ) {\n free ( mem ) ;\n }",
        "output": "1",
        "idx": 4098
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int finish_frame ( AVCodecContext * avctx , AVFrame * pict ) {\n RV34DecContext * r = avctx -> priv_data ;\n MpegEncContext * s = & r -> s ;\n int got_picture = 0 ;\n ff_er_frame_end ( & s -> er ) ;\n ff_MPV_frame_end ( s ) ;\n s -> mb_num_left = 0 ;\n if ( HAVE_THREADS && ( s -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) ff_thread_report_progress ( & s -> current_picture_ptr -> f , INT_MAX , 0 ) ;\n if ( s -> pict_type == AV_PICTURE_TYPE_B || s -> low_delay ) {\n * pict = s -> current_picture_ptr -> f ;\n got_picture = 1 ;\n }\n else if ( s -> last_picture_ptr != NULL ) {\n * pict = s -> last_picture_ptr -> f ;\n got_picture = 1 ;\n }\n if ( got_picture ) ff_print_debug_info ( s , pict ) ;\n return got_picture ;\n }",
        "output": "1",
        "idx": 4273
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean prplcb_ev_remove ( guint id ) {\n b_event_remove ( ( gint ) id ) ;\n return TRUE ;\n }",
        "output": "0",
        "idx": 75
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void print_xml_cdata ( FILE * xml_file , const char * str , ulong len ) {\n const char * end ;\n fputs ( \"<![CDATA[\\n\" , xml_file ) ;\n for ( end = str + len ;\n str != end ;\n str ++ ) {\n switch ( * str ) {\n case ']' : if ( ( * ( str + 1 ) == ']' ) && ( * ( str + 2 ) == '>' ) ) {\n fputs ( \"]]]]><![CDATA[>\" , xml_file ) ;\n str += 2 ;\n continue ;\n }\n default : fputc ( * str , xml_file ) ;\n break ;\n }\n }\n fputs ( \"\\n]]>\\n\" , xml_file ) ;\n check_io ( xml_file ) ;\n }",
        "output": "0",
        "idx": 1175
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PNGAPI png_set_compression_buffer_size ( png_structp png_ptr , png_uint_32 size ) {\n if ( png_ptr == NULL ) return ;\n png_free ( png_ptr , png_ptr -> zbuf ) ;\n png_ptr -> zbuf_size = ( png_size_t ) size ;\n png_ptr -> zbuf = ( png_bytep ) png_malloc ( png_ptr , size ) ;\n png_ptr -> zstream . next_out = png_ptr -> zbuf ;\n png_ptr -> zstream . avail_out = ( uInt ) png_ptr -> zbuf_size ;\n }",
        "output": "0",
        "idx": 3476
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __always_inline __u16 __be16_to_cpup ( const __be16 * p ) {\n return __swab16p ( ( __u16 * ) p ) ;\n }",
        "output": "1",
        "idx": 942
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_T_h245Ip ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 339 \"./asn1/h225/h225.cnf\" tvbuff_t * value_tvb ;\n ipv4_address = 0 ;\n offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , 4 , 4 , FALSE , & value_tvb ) ;\n if ( value_tvb ) ipv4_address = tvb_get_ipv4 ( value_tvb , 0 ) ;\n return offset ;\n }",
        "output": "1",
        "idx": 3592
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t u_printf_string_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n UChar * s ;\n UChar buffer [ UFMT_DEFAULT_BUFFER_SIZE ] ;\n int32_t len , written ;\n int32_t argSize ;\n const char * arg = ( const char * ) ( args [ 0 ] . ptrValue ) ;\n if ( arg ) {\n argSize = ( int32_t ) strlen ( arg ) + 1 ;\n if ( argSize >= MAX_UCHAR_BUFFER_SIZE ( buffer ) ) {\n s = ufmt_defaultCPToUnicode ( arg , argSize , ( UChar * ) uprv_malloc ( MAX_UCHAR_BUFFER_NEEDED ( argSize ) ) , MAX_UCHAR_BUFFER_NEEDED ( argSize ) ) ;\n if ( s == NULL ) {\n return 0 ;\n }\n }\n else {\n s = ufmt_defaultCPToUnicode ( arg , argSize , buffer , UPRV_LENGTHOF ( buffer ) ) ;\n }\n }\n else {\n s = ( UChar * ) gNullStr ;\n }\n len = u_strlen ( s ) ;\n if ( info -> fPrecision != - 1 && info -> fPrecision < len ) {\n len = info -> fPrecision ;\n }\n written = handler -> pad_and_justify ( context , info , s , len ) ;\n if ( gNullStr != s && buffer != s ) {\n uprv_free ( s ) ;\n }\n return written ;\n }",
        "output": "1",
        "idx": 607
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_spoolss_uint16uni ( tvbuff_t * tvb , int offset , packet_info * pinfo _U_ , proto_tree * tree , guint8 * drep _U_ , char * * data , int hf_name ) {\n gint len , remaining ;\n char * text ;\n if ( offset % 2 ) offset += 2 - ( offset % 2 ) ;\n remaining = tvb_reported_length_remaining ( tvb , offset ) ;\n if ( remaining <= 0 ) {\n if ( data ) * data = g_strdup ( \"\" ) ;\n return offset ;\n }\n text = tvb_get_string_enc ( NULL , tvb , offset , remaining , ENC_UTF_16 | ENC_LITTLE_ENDIAN ) ;\n len = ( int ) strlen ( text ) ;\n proto_tree_add_string ( tree , hf_name , tvb , offset , len * 2 , text ) ;\n if ( data ) * data = text ;\n else g_free ( text ) ;\n return offset + ( len + 1 ) * 2 ;\n }",
        "output": "0",
        "idx": 2246
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int decode_rgb24_frame ( CLLCContext * ctx , GetBitContext * gb , AVFrame * pic ) {\n AVCodecContext * avctx = ctx -> avctx ;\n uint8_t * dst ;\n int pred [ 3 ] ;\n int ret ;\n int i , j ;\n VLC vlc [ 3 ] ;\n pred [ 0 ] = 0x80 ;\n pred [ 1 ] = 0x80 ;\n pred [ 2 ] = 0x80 ;\n dst = pic -> data [ 0 ] ;\n skip_bits ( gb , 16 ) ;\n for ( i = 0 ;\n i < 3 ;\n i ++ ) {\n ret = read_code_table ( ctx , gb , & vlc [ i ] ) ;\n if ( ret < 0 ) {\n for ( j = 0 ;\n j <= i ;\n j ++ ) ff_free_vlc ( & vlc [ j ] ) ;\n av_log ( ctx -> avctx , AV_LOG_ERROR , \"Could not read code table %d.\\n\" , i ) ;\n return ret ;\n }\n }\n for ( i = 0 ;\n i < avctx -> height ;\n i ++ ) {\n for ( j = 0 ;\n j < 3 ;\n j ++ ) read_rgb24_component_line ( ctx , gb , & pred [ j ] , & vlc [ j ] , & dst [ j ] ) ;\n dst += pic -> linesize [ 0 ] ;\n }\n for ( i = 0 ;\n i < 3 ;\n i ++ ) ff_free_vlc ( & vlc [ i ] ) ;\n return 0 ;\n }",
        "output": "0",
        "idx": 1099
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_DataModeApplication ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 523 \"../../asn1/h245/h245.cnf\" gint32 value ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_DataModeApplication , DataModeApplication_choice , & value ) ;\n codec_type = val_to_str ( value , h245_DataModeApplication_vals , \"<unknown>\" ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 1664
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void * checked_xmalloc ( size_t size ) {\n alloc_limit_assert ( \"checked_xmalloc\" , size ) ;\n return xmalloc ( size ) ;\n }",
        "output": "1",
        "idx": 3694
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int arm_cpu_caps ( void ) {\n int flags ;\n int mask ;\n if ( ! arm_cpu_env_flags ( & flags ) ) {\n return flags ;\n }\n mask = arm_cpu_env_mask ( ) ;\n # if HAVE_EDSP flags |= HAS_EDSP ;\n # endif # if HAVE_MEDIA flags |= HAS_MEDIA ;\n # endif # if HAVE_NEON flags |= HAS_NEON ;\n # endif return flags & mask ;\n }",
        "output": "1",
        "idx": 314
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pk_transaction_dispose ( GObject * object ) {\n PkTransaction * transaction ;\n g_return_if_fail ( PK_IS_TRANSACTION ( object ) ) ;\n transaction = PK_TRANSACTION ( object ) ;\n if ( transaction -> priv -> waiting_for_auth ) {\n g_cancellable_cancel ( transaction -> priv -> cancellable ) ;\n pk_transaction_error_code_emit ( transaction , PK_ERROR_ENUM_NOT_AUTHORIZED , \"client did not authorize action\" ) ;\n pk_transaction_finished_emit ( transaction , PK_EXIT_ENUM_FAILED , 0 ) ;\n }\n if ( transaction -> priv -> registration_id > 0 ) {\n g_dbus_connection_unregister_object ( transaction -> priv -> connection , transaction -> priv -> registration_id ) ;\n transaction -> priv -> registration_id = 0 ;\n }\n if ( transaction -> priv -> connection != NULL ) {\n g_debug ( \"emitting destroy %s\" , transaction -> priv -> tid ) ;\n g_dbus_connection_emit_signal ( transaction -> priv -> connection , NULL , transaction -> priv -> tid , PK_DBUS_INTERFACE_TRANSACTION , \"Destroy\" , NULL , NULL ) ;\n }\n G_OBJECT_CLASS ( pk_transaction_parent_class ) -> dispose ( object ) ;\n }",
        "output": "0",
        "idx": 1807
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void imc_decode_level_coefficients ( IMCContext * q , int * levlCoeffBuf , float * flcoeffs1 , float * flcoeffs2 ) {\n int i , level ;\n float tmp , tmp2 ;\n flcoeffs1 [ 0 ] = 20000.0 / pow ( 2 , levlCoeffBuf [ 0 ] * 0.18945 ) ;\n flcoeffs2 [ 0 ] = log2f ( flcoeffs1 [ 0 ] ) ;\n tmp = flcoeffs1 [ 0 ] ;\n tmp2 = flcoeffs2 [ 0 ] ;\n for ( i = 1 ;\n i < BANDS ;\n i ++ ) {\n level = levlCoeffBuf [ i ] ;\n if ( level == 16 ) {\n flcoeffs1 [ i ] = 1.0 ;\n flcoeffs2 [ i ] = 0.0 ;\n }\n else {\n if ( level < 17 ) level -= 7 ;\n else if ( level <= 24 ) level -= 32 ;\n else level -= 16 ;\n tmp *= imc_exp_tab [ 15 + level ] ;\n tmp2 += 0.83048 * level ;\n flcoeffs1 [ i ] = tmp ;\n flcoeffs2 [ i ] = tmp2 ;\n }\n }\n }",
        "output": "0",
        "idx": 1368
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_TerminalCapabilitySetRelease ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_TerminalCapabilitySetRelease , TerminalCapabilitySetRelease_sequence ) ;\n # line 596 \"../../asn1/h245/h245.cnf\" if ( h245_pi != NULL ) h245_pi -> msg_type = H245_TermCapSetRls ;\n return offset ;\n }",
        "output": "0",
        "idx": 4026
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_EndpointIdentifier ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_BMPString ( tvb , offset , actx , tree , hf_index , 1 , 128 , FALSE ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 244
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vga_draw_line16_le ( VGACommonState * s1 , uint8_t * d , const uint8_t * s , int width ) {\n int w ;\n uint32_t v , r , g , b ;\n w = width ;\n do {\n v = lduw_le_p ( ( void * ) s ) ;\n r = ( v >> 8 ) & 0xf8 ;\n g = ( v >> 3 ) & 0xfc ;\n b = ( v << 3 ) & 0xf8 ;\n ( ( uint32_t * ) d ) [ 0 ] = rgb_to_pixel32 ( r , g , b ) ;\n s += 2 ;\n d += 4 ;\n }\n while ( -- w != 0 ) ;\n }",
        "output": "1",
        "idx": 980
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xhci_kick_ep ( XHCIState * xhci , unsigned int slotid , unsigned int epid , unsigned int streamid ) {\n XHCIEPContext * epctx ;\n assert ( slotid >= 1 && slotid <= xhci -> numslots ) ;\n assert ( epid >= 1 && epid <= 31 ) ;\n if ( ! xhci -> slots [ slotid - 1 ] . enabled ) {\n DPRINTF ( \"xhci: xhci_kick_ep for disabled slot %d\\n\" , slotid ) ;\n return ;\n }\n epctx = xhci -> slots [ slotid - 1 ] . eps [ epid - 1 ] ;\n if ( ! epctx ) {\n DPRINTF ( \"xhci: xhci_kick_ep for disabled endpoint %d,%d\\n\" , epid , slotid ) ;\n return ;\n }\n xhci_kick_epctx ( epctx , streamid ) ;\n }",
        "output": "1",
        "idx": 2189
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "proto_item * parseUInt16 ( proto_tree * tree , tvbuff_t * tvb , packet_info * pinfo _U_ , gint * pOffset , int hfIndex ) {\n proto_item * item = proto_tree_add_item ( tree , hfIndex , tvb , * pOffset , 2 , ENC_LITTLE_ENDIAN ) ;\n * pOffset += 2 ;\n return item ;\n }",
        "output": "0",
        "idx": 1031
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_init_qscale_tab ( MpegEncContext * s ) {\n int8_t * const qscale_table = s -> current_picture . f . qscale_table ;\n int i ;\n for ( i = 0 ;\n i < s -> mb_num ;\n i ++ ) {\n unsigned int lam = s -> lambda_table [ s -> mb_index2xy [ i ] ] ;\n int qp = ( lam * 139 + FF_LAMBDA_SCALE * 64 ) >> ( FF_LAMBDA_SHIFT + 7 ) ;\n qscale_table [ s -> mb_index2xy [ i ] ] = av_clip ( qp , s -> avctx -> qmin , s -> avctx -> qmax ) ;\n }\n }",
        "output": "1",
        "idx": 3184
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( MultiBufferTest , ReadAllAdvanceFirst_NeverDefer ) {\n multibuffer_ . SetMaxWriters ( 1 ) ;\n size_t pos = 0 ;\n size_t end = 10000 ;\n multibuffer_ . SetFileSize ( 10000 ) ;\n multibuffer_ . SetMaxBlocksAfterDefer ( - 10000 ) ;\n multibuffer_ . SetRangeSupported ( true ) ;\n media : : MultiBufferReader reader ( & multibuffer_ , pos , end , base : : Callback < void ( int64_t , int64_t ) > ( ) ) ;\n reader . SetMaxBuffer ( 2000 , 5000 ) ;\n reader . SetPreload ( 1000 , 1000 ) ;\n while ( pos < end ) {\n unsigned char buffer [ 27 ] ;\n buffer [ 17 ] = 17 ;\n size_t to_read = std : : min < size_t > ( end - pos , 17 ) ;\n while ( AdvanceAll ( ) ) ;\n int64_t bytes = reader . TryRead ( buffer , to_read ) ;\n EXPECT_GT ( bytes , 0 ) ;\n EXPECT_EQ ( buffer [ 17 ] , 17 ) ;\n for ( int64_t i = 0 ;\n i < bytes ;\n i ++ ) {\n uint8_t expected = static_cast < uint8_t > ( ( pos * 15485863 ) >> 16 ) ;\n EXPECT_EQ ( expected , buffer [ i ] ) << \" pos = \" << pos ;\n pos ++ ;\n }\n }\n EXPECT_GT ( multibuffer_ . writers_created ( ) , 1 ) ;\n }",
        "output": "1",
        "idx": 3601
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gen_vector_table24 ( TrueMotion1Context * s , const uint8_t * sel_vector_table ) {\n int len , i , j ;\n unsigned char delta_pair ;\n for ( i = 0 ;\n i < 1024 ;\n i += 4 ) {\n len = * sel_vector_table ++ / 2 ;\n for ( j = 0 ;\n j < len ;\n j ++ ) {\n delta_pair = * sel_vector_table ++ ;\n s -> y_predictor_table [ i + j ] = 0xfffffffe & make_ydt24_entry ( delta_pair >> 4 , delta_pair & 0xf , s -> ydt ) ;\n s -> c_predictor_table [ i + j ] = 0xfffffffe & make_cdt24_entry ( delta_pair >> 4 , delta_pair & 0xf , s -> cdt ) ;\n s -> fat_y_predictor_table [ i + j ] = 0xfffffffe & make_ydt24_entry ( delta_pair >> 4 , delta_pair & 0xf , s -> fat_ydt ) ;\n s -> fat_c_predictor_table [ i + j ] = 0xfffffffe & make_cdt24_entry ( delta_pair >> 4 , delta_pair & 0xf , s -> fat_cdt ) ;\n }\n s -> y_predictor_table [ i + ( j - 1 ) ] |= 1 ;\n s -> c_predictor_table [ i + ( j - 1 ) ] |= 1 ;\n s -> fat_y_predictor_table [ i + ( j - 1 ) ] |= 1 ;\n s -> fat_c_predictor_table [ i + ( j - 1 ) ] |= 1 ;\n }\n }",
        "output": "0",
        "idx": 542
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int padr_match ( PCNetState * s , const uint8_t * buf , int size ) {\n struct qemu_ether_header * hdr = ( void * ) buf ;\n uint8_t padr [ 6 ] = {\n s -> csr [ 12 ] & 0xff , s -> csr [ 12 ] >> 8 , s -> csr [ 13 ] & 0xff , s -> csr [ 13 ] >> 8 , s -> csr [ 14 ] & 0xff , s -> csr [ 14 ] >> 8 }\n ;\n int result = ( ! CSR_DRCVPA ( s ) ) && ! memcmp ( hdr -> ether_dhost , padr , 6 ) ;\n # ifdef PCNET_DEBUG_MATCH printf ( \"packet dhost=%02x:%02x:%02x:%02x:%02x:%02x, \" \"padr=%02x:%02x:%02x:%02x:%02x:%02x\\n\" , hdr -> ether_dhost [ 0 ] , hdr -> ether_dhost [ 1 ] , hdr -> ether_dhost [ 2 ] , hdr -> ether_dhost [ 3 ] , hdr -> ether_dhost [ 4 ] , hdr -> ether_dhost [ 5 ] , padr [ 0 ] , padr [ 1 ] , padr [ 2 ] , padr [ 3 ] , padr [ 4 ] , padr [ 5 ] ) ;\n printf ( \"padr_match result=%d\\n\" , result ) ;\n # endif return result ;\n }",
        "output": "0",
        "idx": 3426
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_iwht4x4_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) {\n if ( eob > 1 ) vp9_iwht4x4_16_add ( input , dest , stride ) ;\n else vp9_iwht4x4_1_add ( input , dest , stride ) ;\n }",
        "output": "1",
        "idx": 2803
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ilbc_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n ILBCDecContext * s = avctx -> priv_data ;\n AVFrame * frame = data ;\n int ret ;\n if ( s -> decoder . no_of_bytes > buf_size ) {\n av_log ( avctx , AV_LOG_ERROR , \"iLBC frame too short (%u, should be %u)\\n\" , buf_size , s -> decoder . no_of_bytes ) ;\n return AVERROR_INVALIDDATA ;\n }\n frame -> nb_samples = s -> decoder . blockl ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n WebRtcIlbcfix_DecodeImpl ( ( WebRtc_Word16 * ) frame -> data [ 0 ] , ( const WebRtc_UWord16 * ) buf , & s -> decoder , 1 ) ;\n * got_frame_ptr = 1 ;\n return s -> decoder . no_of_bytes ;\n }",
        "output": "1",
        "idx": 297
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static double get_prediction_decay_rate ( const VP9_COMMON * cm , const FIRSTPASS_STATS * next_frame ) {\n const double mb_sr_err_diff = ( next_frame -> sr_coded_error - next_frame -> coded_error ) / cm -> MBs ;\n const double second_ref_decay = mb_sr_err_diff <= 512.0 ? fclamp ( pow ( 1.0 - ( mb_sr_err_diff / 512.0 ) , 0.5 ) , 0.85 , 1.0 ) : 0.85 ;\n return MIN ( second_ref_decay , next_frame -> pcnt_inter ) ;\n }",
        "output": "1",
        "idx": 1342
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void virtio_net_save ( QEMUFile * f , void * opaque ) {\n VirtIONet * n = opaque ;\n assert ( ! n -> vhost_started ) ;\n virtio_save ( & n -> vdev , f ) ;\n qemu_put_buffer ( f , n -> mac , ETH_ALEN ) ;\n qemu_put_be32 ( f , n -> tx_waiting ) ;\n qemu_put_be32 ( f , n -> mergeable_rx_bufs ) ;\n qemu_put_be16 ( f , n -> status ) ;\n qemu_put_byte ( f , n -> promisc ) ;\n qemu_put_byte ( f , n -> allmulti ) ;\n qemu_put_be32 ( f , n -> mac_table . in_use ) ;\n qemu_put_buffer ( f , n -> mac_table . macs , n -> mac_table . in_use * ETH_ALEN ) ;\n qemu_put_buffer ( f , ( uint8_t * ) n -> vlans , MAX_VLAN >> 3 ) ;\n qemu_put_be32 ( f , n -> has_vnet_hdr ) ;\n qemu_put_byte ( f , n -> mac_table . multi_overflow ) ;\n qemu_put_byte ( f , n -> mac_table . uni_overflow ) ;\n qemu_put_byte ( f , n -> alluni ) ;\n qemu_put_byte ( f , n -> nomulti ) ;\n qemu_put_byte ( f , n -> nouni ) ;\n qemu_put_byte ( f , n -> nobcast ) ;\n qemu_put_byte ( f , n -> has_ufo ) ;\n }",
        "output": "0",
        "idx": 3311
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int zcliprestore ( i_ctx_t * i_ctx_p ) {\n return gs_cliprestore ( igs ) ;\n }",
        "output": "0",
        "idx": 2332
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char * cmd_hash_engine ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {\n directory_config * dcfg = ( directory_config * ) _dcfg ;\n if ( dcfg == NULL ) return NULL ;\n if ( strcasecmp ( p1 , \"on\" ) == 0 ) {\n dcfg -> hash_is_enabled = HASH_ENABLED ;\n dcfg -> hash_enforcement = HASH_ENABLED ;\n }\n else if ( strcasecmp ( p1 , \"off\" ) == 0 ) {\n dcfg -> hash_is_enabled = HASH_DISABLED ;\n dcfg -> hash_enforcement = HASH_DISABLED ;\n }\n else return apr_psprintf ( cmd -> pool , \"ModSecurity: Invalid value for SecRuleEngine: %s\" , p1 ) ;\n return NULL ;\n }",
        "output": "1",
        "idx": 2548
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void * read_into_buffer ( FILE * fp , size_t * r_length ) {\n char * buffer ;\n size_t buflen ;\n size_t nread , bufsize = 0 ;\n * r_length = 0 ;\n # define NCHUNK 8192 # ifdef HAVE_W32_SYSTEM setmode ( fileno ( fp ) , O_BINARY ) ;\n # endif buffer = NULL ;\n buflen = 0 ;\n do {\n bufsize += NCHUNK ;\n buffer = realloc ( buffer , bufsize ) ;\n if ( ! buffer ) {\n perror ( \"realloc failed\" ) ;\n exit ( 1 ) ;\n }\n nread = fread ( buffer + buflen , 1 , NCHUNK , fp ) ;\n if ( nread < NCHUNK && ferror ( fp ) ) {\n perror ( \"fread failed\" ) ;\n exit ( 1 ) ;\n }\n buflen += nread ;\n }\n while ( nread == NCHUNK ) ;\n # undef NCHUNK * r_length = buflen ;\n return buffer ;\n }",
        "output": "0",
        "idx": 2425
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ProtocolHandlerRegistryTest , TestSilentlyRegisterHandler ) {\n ProtocolHandler ph1 = CreateProtocolHandler ( \"test\" , GURL ( \"http://test/1/%s\" ) ) ;\n ProtocolHandler ph2 = CreateProtocolHandler ( \"test\" , GURL ( \"http://test/2/%s\" ) ) ;\n ProtocolHandler ph3 = CreateProtocolHandler ( \"ignore\" , GURL ( \"http://test/%s\" ) ) ;\n ProtocolHandler ph4 = CreateProtocolHandler ( \"ignore\" , GURL ( \"http://test/%s\" ) ) ;\n ASSERT_FALSE ( registry ( ) -> SilentlyHandleRegisterHandlerRequest ( ph1 ) ) ;\n ASSERT_FALSE ( registry ( ) -> IsRegistered ( ph1 ) ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;\n ASSERT_TRUE ( registry ( ) -> IsRegistered ( ph1 ) ) ;\n ASSERT_TRUE ( registry ( ) -> SilentlyHandleRegisterHandlerRequest ( ph2 ) ) ;\n ASSERT_FALSE ( registry ( ) -> IsRegistered ( ph1 ) ) ;\n ASSERT_TRUE ( registry ( ) -> IsRegistered ( ph2 ) ) ;\n ASSERT_FALSE ( registry ( ) -> SilentlyHandleRegisterHandlerRequest ( ph3 ) ) ;\n ASSERT_FALSE ( registry ( ) -> IsRegistered ( ph3 ) ) ;\n registry ( ) -> OnIgnoreRegisterProtocolHandler ( ph3 ) ;\n ASSERT_FALSE ( registry ( ) -> IsRegistered ( ph3 ) ) ;\n ASSERT_TRUE ( registry ( ) -> IsIgnored ( ph3 ) ) ;\n ASSERT_TRUE ( registry ( ) -> SilentlyHandleRegisterHandlerRequest ( ph4 ) ) ;\n ASSERT_FALSE ( registry ( ) -> IsRegistered ( ph4 ) ) ;\n ASSERT_TRUE ( registry ( ) -> HasIgnoredEquivalent ( ph4 ) ) ;\n }",
        "output": "0",
        "idx": 3641
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void proto_reg_handoff_zbee_zcl_on_off ( void ) {\n dissector_handle_t on_off_handle ;\n on_off_handle = find_dissector ( ZBEE_PROTOABBREV_ZCL_ONOFF ) ;\n dissector_add_uint ( \"zbee.zcl.cluster\" , ZBEE_ZCL_CID_ON_OFF , on_off_handle ) ;\n zbee_zcl_init_cluster ( proto_zbee_zcl_on_off , ett_zbee_zcl_on_off , ZBEE_ZCL_CID_ON_OFF , hf_zbee_zcl_on_off_attr_id , hf_zbee_zcl_on_off_srv_rx_cmd_id , - 1 , ( zbee_zcl_fn_attr_data ) dissect_zcl_on_off_attr_data ) ;\n }",
        "output": "0",
        "idx": 2602
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RecordsConfigIterate ( RecordElementCallback callback , void * data ) {\n for ( unsigned i = 0 ;\n i < countof ( RecordsConfig ) ;\n ++ i ) {\n callback ( & RecordsConfig [ i ] , data ) ;\n }\n }",
        "output": "0",
        "idx": 1884
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( ExternalProtocolDialogBrowserTest , TestClose ) {\n ShowDialog ( ) ;\n EXPECT_TRUE ( dialog_ -> Close ( ) ) ;\n EXPECT_TRUE ( called_ ) ;\n EXPECT_FALSE ( accept_ ) ;\n EXPECT_TRUE ( cancel_ ) ;\n EXPECT_FALSE ( dont_block_ ) ;\n histogram_tester_ . ExpectTotalCount ( ExternalProtocolHandler : : kRememberCheckboxMetric , 0 ) ;\n histogram_tester_ . ExpectTotalCount ( ExternalProtocolHandler : : kHandleStateMetric , 0 ) ;\n }",
        "output": "1",
        "idx": 4462
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char * _UTF16BEGetName ( const UConverter * cnv ) {\n if ( UCNV_GET_VERSION ( cnv ) == 0 ) {\n return \"UTF-16BE\" ;\n }\n else {\n return \"UTF-16BE,version=1\" ;\n }\n }",
        "output": "1",
        "idx": 415
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void luaD_reallocstack ( lua_State * L , int newsize ) {\n TValue * oldstack = L -> stack ;\n int realsize = newsize + 1 + EXTRA_STACK ;\n lua_assert ( L -> stack_last - L -> stack == L -> stacksize - EXTRA_STACK - 1 ) ;\n luaM_reallocvector ( L , L -> stack , L -> stacksize , realsize , TValue ) ;\n L -> stacksize = realsize ;\n L -> stack_last = L -> stack + newsize ;\n correctstack ( L , oldstack ) ;\n }",
        "output": "0",
        "idx": 2309
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_fht4x4_c ( const int16_t * input , tran_low_t * output , int stride , int tx_type ) {\n if ( tx_type == DCT_DCT ) {\n vp9_fdct4x4_c ( input , output , stride ) ;\n }\n else {\n tran_low_t out [ 4 * 4 ] ;\n tran_low_t * outptr = & out [ 0 ] ;\n int i , j ;\n tran_low_t temp_in [ 4 ] , temp_out [ 4 ] ;\n const transform_2d ht = FHT_4 [ tx_type ] ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) {\n for ( j = 0 ;\n j < 4 ;\n ++ j ) temp_in [ j ] = input [ j * stride + i ] * 16 ;\n if ( i == 0 && temp_in [ 0 ] ) temp_in [ 0 ] += 1 ;\n ht . cols ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 4 ;\n ++ j ) outptr [ j * 4 + i ] = temp_out [ j ] ;\n }\n for ( i = 0 ;\n i < 4 ;\n ++ i ) {\n for ( j = 0 ;\n j < 4 ;\n ++ j ) temp_in [ j ] = out [ j + i * 4 ] ;\n ht . rows ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 4 ;\n ++ j ) output [ j + i * 4 ] = ( temp_out [ j ] + 1 ) >> 2 ;\n }\n }\n }",
        "output": "0",
        "idx": 2784
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int _warc_cleanup ( struct archive_read * a ) {\n struct warc_s * w = a -> format -> data ;\n if ( w -> pool . len > 0U ) {\n free ( w -> pool . str ) ;\n }\n archive_string_free ( & w -> sver ) ;\n free ( w ) ;\n a -> format -> data = NULL ;\n return ( ARCHIVE_OK ) ;\n }",
        "output": "0",
        "idx": 4437
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void proto_tree_set_uint ( field_info * fi , guint32 value ) {\n header_field_info * hfinfo ;\n guint32 integer ;\n hfinfo = fi -> hfinfo ;\n integer = value ;\n if ( hfinfo -> bitmask ) {\n integer &= ( guint32 ) ( hfinfo -> bitmask ) ;\n integer >>= hfinfo_bitshift ( hfinfo ) ;\n }\n fvalue_set_uinteger ( & fi -> value , integer ) ;\n }",
        "output": "0",
        "idx": 3256
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int test_in_memory ( xd3_stream * stream , int ignore ) {\n uint8_t ibuf [ sizeof ( test_text ) ] ;\n uint8_t dbuf [ sizeof ( test_text ) ] ;\n uint8_t obuf [ sizeof ( test_text ) ] ;\n usize_t size = sizeof ( test_text ) ;\n usize_t dsize , osize ;\n int r1 , r2 ;\n int eflags = SECONDARY_DJW ? XD3_SEC_DJW : 0 ;\n memcpy ( ibuf , test_text , size ) ;\n memset ( ibuf + 128 , 0 , 16 ) ;\n r1 = xd3_encode_memory ( ibuf , size , test_text , size , dbuf , & dsize , size , eflags ) ;\n r2 = xd3_decode_memory ( dbuf , dsize , test_text , size , obuf , & osize , size , 0 ) ;\n if ( r1 != 0 || r2 != 0 || dsize >= ( size / 2 ) || dsize < 1 || osize != size ) {\n stream -> msg = \"encode/decode size error\" ;\n return XD3_INTERNAL ;\n }\n if ( memcmp ( obuf , ibuf , size ) != 0 ) {\n stream -> msg = \"encode/decode data error\" ;\n return XD3_INTERNAL ;\n }\n return 0 ;\n }",
        "output": "0",
        "idx": 1818
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int qsort_comparison_function_int16 ( const void * a , const void * b ) {\n return * ( const int16_t * ) a - * ( const int16_t * ) b ;\n }",
        "output": "1",
        "idx": 3399
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint64_t vmport_ioport_read ( void * opaque , hwaddr addr , unsigned size ) {\n VMPortState * s = opaque ;\n CPUX86State * env = cpu_single_env ;\n unsigned char command ;\n uint32_t eax ;\n cpu_synchronize_state ( CPU ( x86_env_get_cpu ( env ) ) ) ;\n eax = env -> regs [ R_EAX ] ;\n if ( eax != VMPORT_MAGIC ) return eax ;\n command = env -> regs [ R_ECX ] ;\n if ( command >= VMPORT_ENTRIES ) return eax ;\n if ( ! s -> func [ command ] ) {\n # ifdef VMPORT_DEBUG fprintf ( stderr , \"vmport: unknown command %x\\n\" , command ) ;\n # endif return eax ;\n }\n return s -> func [ command ] ( s -> opaque [ command ] , addr ) ;\n }",
        "output": "1",
        "idx": 2375
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void new_files_cancel ( NautilusDirectory * directory ) {\n GList * l ;\n NewFilesState * state ;\n if ( directory -> details -> new_files_in_progress != NULL ) {\n for ( l = directory -> details -> new_files_in_progress ;\n l != NULL ;\n l = l -> next ) {\n state = l -> data ;\n g_cancellable_cancel ( state -> cancellable ) ;\n state -> directory = NULL ;\n }\n g_list_free ( directory -> details -> new_files_in_progress ) ;\n directory -> details -> new_files_in_progress = NULL ;\n }\n }",
        "output": "0",
        "idx": 3963
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gtkui_inject_user ( int side ) {\n size_t len ;\n len = strescape ( injectbuf , injectbuf ) ;\n if ( side == 1 || side == 2 ) {\n user_inject ( injectbuf , len , curr_conn , side ) ;\n }\n }",
        "output": "1",
        "idx": 539
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "zend_object_iterator * spl_filesystem_tree_get_iterator ( zend_class_entry * ce , zval * object , int by_ref TSRMLS_DC ) {\n spl_filesystem_iterator * iterator ;\n spl_filesystem_object * dir_object ;\n if ( by_ref ) {\n zend_error ( E_ERROR , \"An iterator cannot be used with foreach by reference\" ) ;\n }\n dir_object = ( spl_filesystem_object * ) zend_object_store_get_object ( object TSRMLS_CC ) ;\n iterator = spl_filesystem_object_to_iterator ( dir_object ) ;\n if ( iterator -> intern . data == NULL ) {\n iterator -> intern . data = object ;\n iterator -> intern . funcs = & spl_filesystem_tree_it_funcs ;\n }\n zval_add_ref ( & object ) ;\n return ( zend_object_iterator * ) iterator ;\n }",
        "output": "1",
        "idx": 2998
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spl_filesystem_tree_it_rewind ( zend_object_iterator * iter TSRMLS_DC ) {\n spl_filesystem_iterator * iterator = ( spl_filesystem_iterator * ) iter ;\n spl_filesystem_object * object = spl_filesystem_iterator_to_object ( iterator ) ;\n object -> u . dir . index = 0 ;\n if ( object -> u . dir . dirp ) {\n php_stream_rewinddir ( object -> u . dir . dirp ) ;\n }\n do {\n spl_filesystem_dir_read ( object TSRMLS_CC ) ;\n }\n while ( spl_filesystem_is_dot ( object -> u . dir . entry . d_name ) ) ;\n if ( iterator -> current ) {\n zval_ptr_dtor ( & iterator -> current ) ;\n iterator -> current = NULL ;\n }\n }",
        "output": "1",
        "idx": 2241
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int parse_RowsBuffer ( tvbuff_t * tvb , int offset , guint32 num_rows , struct CPMSetBindingsIn * bindingsin , struct rows_data * rowsin , gboolean is64bit , proto_tree * parent_tree , const char * fmt , ... ) {\n proto_tree * tree ;\n proto_item * item ;\n guint32 num ;\n const char * txt ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_GetRowsRow , & item , txt ) ;\n for ( num = 0 ;\n num < num_rows ;\n ++ num ) {\n guint32 col ;\n proto_tree * row_tree ;\n row_tree = proto_tree_add_subtree_format ( tree , tvb , offset , 0 , ett_GetRowsRow , NULL , \"Row[%d]\" , num ) ;\n for ( col = 0 ;\n col < bindingsin -> ccolumns ;\n col ++ ) {\n parse_RowsBufferCol ( tvb , offset , num , col , bindingsin , rowsin , is64bit , row_tree , \"Col[%d]\" , col ) ;\n }\n }\n return offset ;\n }",
        "output": "1",
        "idx": 965
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void residual_interp ( int16_t * buf , int16_t * out , int lag , int gain , int * rseed ) {\n int i ;\n if ( lag ) {\n int16_t * vector_ptr = buf + PITCH_MAX ;\n for ( i = 0 ;\n i < lag ;\n i ++ ) out [ i ] = vector_ptr [ i - lag ] * 3 >> 2 ;\n av_memcpy_backptr ( ( uint8_t * ) ( out + lag ) , lag * sizeof ( * out ) , ( FRAME_LEN - lag ) * sizeof ( * out ) ) ;\n }\n else {\n for ( i = 0 ;\n i < FRAME_LEN ;\n i ++ ) {\n * rseed = * rseed * 521 + 259 ;\n out [ i ] = gain * * rseed >> 15 ;\n }\n memset ( buf , 0 , ( FRAME_LEN + PITCH_MAX ) * sizeof ( * buf ) ) ;\n }\n }",
        "output": "0",
        "idx": 2147
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _cmd_window_show_opt ( const char * data , int right ) {\n MAIN_WINDOW_REC * parent ;\n WINDOW_REC * window ;\n if ( * data == '\\0' ) cmd_return_error ( CMDERR_NOT_ENOUGH_PARAMS ) ;\n if ( is_numeric ( data , '\\0' ) ) {\n window = window_find_refnum ( atoi ( data ) ) ;\n if ( window == NULL ) {\n printformat_window ( active_win , MSGLEVEL_CLIENTERROR , TXT_REFNUM_NOT_FOUND , data ) ;\n }\n }\n else {\n window = window_find_item ( active_win -> active_server , data ) ;\n }\n if ( window == NULL || is_window_visible ( window ) ) return ;\n if ( WINDOW_GUI ( window ) -> sticky ) {\n if ( ! settings_get_bool ( \"autounstick_windows\" ) ) {\n printformat_window ( active_win , MSGLEVEL_CLIENTERROR , TXT_CANT_SHOW_STICKY_WINDOWS ) ;\n return ;\n }\n }\n parent = mainwindow_create ( right ) ;\n parent -> active = window ;\n gui_window_reparent ( window , parent ) ;\n if ( settings_get_bool ( \"autostick_split_windows\" ) ) gui_window_set_sticky ( window ) ;\n active_mainwin = NULL ;\n window_set_active ( window ) ;\n }",
        "output": "1",
        "idx": 4313
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , DocumentWriteBlock ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n auto waiter = CreatePageLoadMetricsWaiter ( ) ;\n waiter -> AddPageExpectation ( TimingField : : FIRST_CONTENTFUL_PAINT ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( \"/page_load_metrics/document_write_script_block.html\" ) ) ;\n waiter -> Wait ( ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramDocWriteBlockParseStartToFirstContentfulPaint , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramDocWriteBlockCount , 1 ) ;\n }",
        "output": "0",
        "idx": 1856
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_Setup_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 466 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n contains_faststart = FALSE ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_Setup_UUIE , Setup_UUIE_sequence ) ;\n # line 471 \"./asn1/h225/h225.cnf\" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> cs_type = H225_SETUP ;\n if ( contains_faststart == TRUE ) g_snprintf ( h225_pi -> frame_label , 50 , \"%s OLC (%s)\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) , h225_pi -> frame_label ) ;\n else g_snprintf ( h225_pi -> frame_label , 50 , \"%s\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) ) ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 3935
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void show_object ( struct object * object , const struct name_path * path , const char * last , void * data ) {\n struct bitmap * base = data ;\n int bitmap_pos ;\n bitmap_pos = bitmap_position ( object -> oid . hash ) ;\n if ( bitmap_pos < 0 ) {\n char * name = path_name ( path , last ) ;\n bitmap_pos = ext_index_add_object ( object , name ) ;\n free ( name ) ;\n }\n bitmap_set ( base , bitmap_pos ) ;\n }",
        "output": "1",
        "idx": 556
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int BIO_printf ( BIO * bio , const char * format , ... ) {\n va_list args ;\n int ret ;\n va_start ( args , format ) ;\n ret = BIO_vprintf ( bio , format , args ) ;\n va_end ( args ) ;\n return ( ret ) ;\n }",
        "output": "0",
        "idx": 1394
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void virLogResetOutputs ( void ) {\n virLogOutputListFree ( virLogOutputs , virLogNbOutputs ) ;\n virLogOutputs = NULL ;\n virLogNbOutputs = 0 ;\n }",
        "output": "0",
        "idx": 1185
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , PaintInChildFrame ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n GURL a_url ( embedded_test_server ( ) -> GetURL ( \"/page_load_metrics/iframe.html\" ) ) ;\n auto waiter = CreatePageLoadMetricsWaiter ( ) ;\n waiter -> AddPageExpectation ( TimingField : : FIRST_LAYOUT ) ;\n waiter -> AddPageExpectation ( TimingField : : LOAD_EVENT ) ;\n waiter -> AddSubFrameExpectation ( TimingField : : FIRST_PAINT ) ;\n waiter -> AddSubFrameExpectation ( TimingField : : FIRST_CONTENTFUL_PAINT ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , a_url ) ;\n waiter -> Wait ( ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramFirstLayout , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramLoad , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramFirstPaint , 1 ) ;\n }",
        "output": "0",
        "idx": 1260
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_P ( GLES2DecoderTestWithCHROMIUMPathRendering , MatrixLoadfCHROMIUMImmediateValidArgs ) {\n cmds : : MatrixLoadfCHROMIUMImmediate & cmd = * GetImmediateAs < cmds : : MatrixLoadfCHROMIUMImmediate > ( ) ;\n SpecializedSetup < cmds : : MatrixLoadfCHROMIUMImmediate , 0 > ( true ) ;\n GLfloat temp [ 16 ] = {\n 0 , }\n ;\n cmd . Init ( GL_PATH_PROJECTION_CHROMIUM , & temp [ 0 ] ) ;\n EXPECT_CALL ( * gl_ , MatrixLoadfEXT ( GL_PATH_PROJECTION_CHROMIUM , PointsToArray ( temp , 16 ) ) ) ;\n EXPECT_EQ ( error : : kNoError , ExecuteImmediateCmd ( cmd , sizeof ( temp ) ) ) ;\n EXPECT_EQ ( GL_NO_ERROR , GetGLError ( ) ) ;\n }",
        "output": "0",
        "idx": 3670
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_MultilinkResponse ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_MultilinkResponse , MultilinkResponse_choice , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 2022
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_CallProceeding_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 483 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_CallProceeding_UUIE , CallProceeding_UUIE_sequence ) ;\n # line 487 \"./asn1/h225/h225.cnf\" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> cs_type = H225_CALL_PROCEDING ;\n if ( contains_faststart == TRUE ) g_snprintf ( h225_pi -> frame_label , 50 , \"%s OLC (%s)\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) , h225_pi -> frame_label ) ;\n else g_snprintf ( h225_pi -> frame_label , 50 , \"%s\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) ) ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 681
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void doapr_outch ( char * * sbuffer , char * * buffer , size_t * currlen , size_t * maxlen , int c ) {\n assert ( * sbuffer != NULL || buffer != NULL ) ;\n assert ( * currlen <= * maxlen ) ;\n if ( buffer && * currlen == * maxlen ) {\n * maxlen += 1024 ;\n if ( * buffer == NULL ) {\n * buffer = OPENSSL_malloc ( * maxlen ) ;\n if ( ! * buffer ) {\n return ;\n }\n if ( * currlen > 0 ) {\n assert ( * sbuffer != NULL ) ;\n memcpy ( * buffer , * sbuffer , * currlen ) ;\n }\n * sbuffer = NULL ;\n }\n else {\n * buffer = OPENSSL_realloc ( * buffer , * maxlen ) ;\n if ( ! * buffer ) {\n return ;\n }\n }\n }\n if ( * currlen < * maxlen ) {\n if ( * sbuffer ) ( * sbuffer ) [ ( * currlen ) ++ ] = ( char ) c ;\n else ( * buffer ) [ ( * currlen ) ++ ] = ( char ) c ;\n }\n return ;\n }",
        "output": "1",
        "idx": 81
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main ( int argc , char * * argv ) {\n struct event signal_int ;\n event_init ( ) ;\n event_set ( & signal_int , SIGINT , EV_SIGNAL | EV_PERSIST , signal_cb , & signal_int ) ;\n event_add ( & signal_int , NULL ) ;\n event_dispatch ( ) ;\n return ( 0 ) ;\n }",
        "output": "1",
        "idx": 1455
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp8cx_frame_init_quantizer ( VP8_COMP * cpi ) {\n cpi -> mb . zbin_mode_boost = 0 ;\n vp8cx_mb_init_quantizer ( cpi , & cpi -> mb , 0 ) ;\n }",
        "output": "0",
        "idx": 462
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cirrus_vga_register_types ( void ) {\n type_register_static ( & isa_cirrus_vga_info ) ;\n type_register_static ( & cirrus_vga_info ) ;\n }",
        "output": "0",
        "idx": 1075
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Datum ExecEvalCoerceViaIO ( CoerceViaIOState * iostate , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {\n Datum result ;\n Datum inputval ;\n char * string ;\n inputval = ExecEvalExpr ( iostate -> arg , econtext , isNull , isDone ) ;\n if ( isDone && * isDone == ExprEndResult ) return inputval ;\n if ( * isNull ) string = NULL ;\n else string = OutputFunctionCall ( & iostate -> outfunc , inputval ) ;\n result = InputFunctionCall ( & iostate -> infunc , string , iostate -> intypioparam , - 1 ) ;\n return result ;\n }",
        "output": "0",
        "idx": 2798
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE ossl_x509name_eql ( VALUE self , VALUE other ) {\n if ( ! rb_obj_is_kind_of ( other , cX509Name ) ) return Qfalse ;\n return ossl_x509name_cmp0 ( self , other ) == 0 ? Qtrue : Qfalse ;\n }",
        "output": "0",
        "idx": 397
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void simplestring_addn ( simplestring * target , const char * source , int add_len ) {\n if ( target && source ) {\n if ( ! target -> str ) {\n simplestring_init_str ( target ) ;\n }\n if ( target -> len + add_len + 1 > target -> size ) {\n int newsize = target -> len + add_len + 1 ;\n int incr = target -> size * 2 ;\n newsize = newsize - ( newsize % incr ) + incr ;\n target -> str = ( char * ) realloc ( target -> str , newsize ) ;\n target -> size = target -> str ? newsize : 0 ;\n }\n if ( target -> str ) {\n if ( add_len ) {\n memcpy ( target -> str + target -> len , source , add_len ) ;\n }\n target -> len += add_len ;\n target -> str [ target -> len ] = 0 ;\n }\n }\n }",
        "output": "1",
        "idx": 2194
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cdxl_decode_rgb ( CDXLVideoContext * c ) {\n uint32_t * new_palette = ( uint32_t * ) c -> frame . data [ 1 ] ;\n import_palette ( c , new_palette ) ;\n import_format ( c , c -> frame . linesize [ 0 ] , c -> frame . data [ 0 ] ) ;\n }",
        "output": "1",
        "idx": 432
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static xmlLinkPtr xmlListLinkReverseSearch ( xmlListPtr l , void * data ) {\n xmlLinkPtr lk ;\n if ( l == NULL ) return ( NULL ) ;\n lk = xmlListHigherSearch ( l , data ) ;\n if ( lk == l -> sentinel ) return NULL ;\n else {\n if ( l -> linkCompare ( lk -> data , data ) == 0 ) return lk ;\n return NULL ;\n }\n }",
        "output": "1",
        "idx": 4455
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileObject , current ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n if ( ! intern -> u . file . current_line && ! intern -> u . file . current_zval ) {\n spl_filesystem_file_read_line ( getThis ( ) , intern , 1 TSRMLS_CC ) ;\n }\n if ( intern -> u . file . current_line && ( ! SPL_HAS_FLAG ( intern -> flags , SPL_FILE_OBJECT_READ_CSV ) || ! intern -> u . file . current_zval ) ) {\n RETURN_STRINGL ( intern -> u . file . current_line , intern -> u . file . current_line_len , 1 ) ;\n }\n else if ( intern -> u . file . current_zval ) {\n RETURN_ZVAL ( intern -> u . file . current_zval , 1 , 0 ) ;\n }\n RETURN_FALSE ;\n }",
        "output": "1",
        "idx": 2041
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cdxl_decode_ham6 ( CDXLVideoContext * c ) {\n AVCodecContext * avctx = c -> avctx ;\n uint32_t new_palette [ 16 ] , r , g , b ;\n uint8_t * ptr , * out , index , op ;\n int x , y ;\n ptr = c -> new_video ;\n out = c -> frame . data [ 0 ] ;\n import_palette ( c , new_palette ) ;\n import_format ( c , avctx -> width , c -> new_video ) ;\n for ( y = 0 ;\n y < avctx -> height ;\n y ++ ) {\n r = new_palette [ 0 ] & 0xFF0000 ;\n g = new_palette [ 0 ] & 0xFF00 ;\n b = new_palette [ 0 ] & 0xFF ;\n for ( x = 0 ;\n x < avctx -> width ;\n x ++ ) {\n index = * ptr ++ ;\n op = index >> 4 ;\n index &= 15 ;\n switch ( op ) {\n case 0 : r = new_palette [ index ] & 0xFF0000 ;\n g = new_palette [ index ] & 0xFF00 ;\n b = new_palette [ index ] & 0xFF ;\n break ;\n case 1 : b = index * 0x11 ;\n break ;\n case 2 : r = index * 0x11 << 16 ;\n break ;\n case 3 : g = index * 0x11 << 8 ;\n break ;\n }\n AV_WL24 ( out + x * 3 , r | g | b ) ;\n }\n out += c -> frame . linesize [ 0 ] ;\n }\n }",
        "output": "1",
        "idx": 1862
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_H322Caps ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_H322Caps , H322Caps_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 506
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipvideo_decode_block_opcode_0x7 ( IpvideoContext * s ) {\n int x , y ;\n unsigned char P [ 2 ] ;\n unsigned int flags ;\n P [ 0 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n P [ 1 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n if ( P [ 0 ] <= P [ 1 ] ) {\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n flags = bytestream2_get_byte ( & s -> stream_ptr ) | 0x100 ;\n for ( ;\n flags != 1 ;\n flags >>= 1 ) * s -> pixel_ptr ++ = P [ flags & 1 ] ;\n s -> pixel_ptr += s -> line_inc ;\n }\n }\n else {\n flags = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n for ( y = 0 ;\n y < 8 ;\n y += 2 ) {\n for ( x = 0 ;\n x < 8 ;\n x += 2 , flags >>= 1 ) {\n s -> pixel_ptr [ x ] = s -> pixel_ptr [ x + 1 ] = s -> pixel_ptr [ x + s -> stride ] = s -> pixel_ptr [ x + 1 + s -> stride ] = P [ flags & 1 ] ;\n }\n s -> pixel_ptr += s -> stride * 2 ;\n }\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 2058
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void * xcalloc ( size_t num , size_t size ) {\n void * ptr = malloc ( num * size ) ;\n if ( ptr ) {\n memset ( ptr , '\\0' , ( num * size ) ) ;\n }\n return ptr ;\n }",
        "output": "1",
        "idx": 2169
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileInfo , getFileInfo ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n zend_class_entry * ce = intern -> info_class ;\n zend_error_handling error_handling ;\n zend_replace_error_handling ( EH_THROW , spl_ce_UnexpectedValueException , & error_handling TSRMLS_CC ) ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"|C\" , & ce ) == SUCCESS ) {\n spl_filesystem_object_create_type ( ht , intern , SPL_FS_INFO , ce , return_value TSRMLS_CC ) ;\n }\n zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;\n }",
        "output": "1",
        "idx": 2250
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void collect_features_myanmar ( hb_ot_shape_planner_t * plan ) {\n hb_ot_map_builder_t * map = & plan -> map ;\n map -> add_gsub_pause ( setup_syllables ) ;\n map -> add_global_bool_feature ( HB_TAG ( 'l' , 'o' , 'c' , 'l' ) ) ;\n map -> add_global_bool_feature ( HB_TAG ( 'c' , 'c' , 'm' , 'p' ) ) ;\n map -> add_gsub_pause ( initial_reordering ) ;\n for ( unsigned int i = 0 ;\n i < ARRAY_LENGTH ( basic_features ) ;\n i ++ ) {\n map -> add_feature ( basic_features [ i ] , 1 , F_GLOBAL | F_MANUAL_ZWJ ) ;\n map -> add_gsub_pause ( NULL ) ;\n }\n map -> add_gsub_pause ( final_reordering ) ;\n for ( unsigned int i = 0 ;\n i < ARRAY_LENGTH ( other_features ) ;\n i ++ ) map -> add_feature ( other_features [ i ] , 1 , F_GLOBAL | F_MANUAL_ZWJ ) ;\n }",
        "output": "0",
        "idx": 331
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vp9_get_preview_raw_frame ( VP9_COMP * cpi , YV12_BUFFER_CONFIG * dest , vp9_ppflags_t * flags ) {\n VP9_COMMON * cm = & cpi -> common ;\n # if ! CONFIG_VP9_POSTPROC ( void ) flags ;\n # endif if ( ! cm -> show_frame ) {\n return - 1 ;\n }\n else {\n int ret ;\n # if CONFIG_VP9_POSTPROC ret = vp9_post_proc_frame ( cm , dest , flags ) ;\n # else if ( cm -> frame_to_show ) {\n * dest = * cm -> frame_to_show ;\n dest -> y_width = cm -> width ;\n dest -> y_height = cm -> height ;\n dest -> uv_width = cm -> width >> cm -> subsampling_x ;\n dest -> uv_height = cm -> height >> cm -> subsampling_y ;\n ret = 0 ;\n }\n else {\n ret = - 1 ;\n }\n # endif vp9_clear_system_state ( ) ;\n return ret ;\n }\n }",
        "output": "0",
        "idx": 4399
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int SpoolssEnumJobs_q ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep _U_ ) {\n dcerpc_call_value * dcv = ( dcerpc_call_value * ) di -> call_data ;\n guint32 level ;\n offset = dissect_nt_policy_hnd ( tvb , offset , pinfo , tree , di , drep , hf_hnd , NULL , NULL , FALSE , FALSE ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_enumjobs_firstjob , NULL ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_enumjobs_numjobs , NULL ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_level , & level ) ;\n if ( ! pinfo -> fd -> flags . visited ) {\n dcv -> se_data = GUINT_TO_POINTER ( ( int ) level ) ;\n }\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \", level %d\" , level ) ;\n offset = dissect_spoolss_buffer ( tvb , offset , pinfo , tree , di , drep , NULL ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_offered , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 3071
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int X509_REQ_get_attr_by_OBJ ( const X509_REQ * req , ASN1_OBJECT * obj , int lastpos ) {\n return X509at_get_attr_by_OBJ ( req -> req_info -> attributes , obj , lastpos ) ;\n }",
        "output": "0",
        "idx": 2896
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_idct16x16_256_add_c ( const int16_t * input , uint8_t * dest , int stride ) {\n int16_t out [ 16 * 16 ] ;\n int16_t * outptr = out ;\n int i , j ;\n int16_t temp_in [ 16 ] , temp_out [ 16 ] ;\n for ( i = 0 ;\n i < 16 ;\n ++ i ) {\n idct16 ( input , outptr ) ;\n input += 16 ;\n outptr += 16 ;\n }\n for ( i = 0 ;\n i < 16 ;\n ++ i ) {\n for ( j = 0 ;\n j < 16 ;\n ++ j ) temp_in [ j ] = out [ j * 16 + i ] ;\n idct16 ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 16 ;\n ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) + dest [ j * stride + i ] ) ;\n }\n }",
        "output": "1",
        "idx": 1504
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PHP_NAMED_FUNCTION ( zif_zip_entry_name ) {\n php_zip_entry_get_info ( INTERNAL_FUNCTION_PARAM_PASSTHRU , 0 ) ;\n }",
        "output": "0",
        "idx": 2229
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void aacsbr_func_ptr_init ( AACSBRContext * c ) {\n c -> sbr_lf_gen = sbr_lf_gen ;\n c -> sbr_hf_assemble = sbr_hf_assemble ;\n c -> sbr_x_gen = sbr_x_gen ;\n c -> sbr_hf_inverse_filter = sbr_hf_inverse_filter ;\n if ( ARCH_MIPS ) ff_aacsbr_func_ptr_init_mips ( c ) ;\n }",
        "output": "1",
        "idx": 1391
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ExternalProtocolHandlerTest , TestGetBlockStateDefaultBlock ) {\n ExternalProtocolHandler : : BlockState block_state = ExternalProtocolHandler : : GetBlockState ( \"afp\" , profile_ . get ( ) ) ;\n EXPECT_EQ ( ExternalProtocolHandler : : BLOCK , block_state ) ;\n EXPECT_TRUE ( local_state_ -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;\n EXPECT_FALSE ( profile_ -> GetPrefs ( ) -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;\n }",
        "output": "1",
        "idx": 3309
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _ISCIIGetUnicodeSet ( const UConverter * cnv , const USetAdder * sa , UConverterUnicodeSet which , UErrorCode * pErrorCode ) {\n int32_t idx , script ;\n uint8_t mask ;\n sa -> addRange ( sa -> set , 0 , ASCII_END ) ;\n for ( script = DEVANAGARI ;\n script <= MALAYALAM ;\n script ++ ) {\n mask = ( uint8_t ) ( lookupInitialData [ script ] . maskEnum ) ;\n for ( idx = 0 ;\n idx < DELTA ;\n idx ++ ) {\n if ( ( validityTable [ idx ] & mask ) || ( script == TELUGU && idx == 0x31 ) ) {\n sa -> add ( sa -> set , idx + ( script * DELTA ) + INDIC_BLOCK_BEGIN ) ;\n }\n }\n }\n sa -> add ( sa -> set , DANDA ) ;\n sa -> add ( sa -> set , DOUBLE_DANDA ) ;\n sa -> add ( sa -> set , ZWNJ ) ;\n sa -> add ( sa -> set , ZWJ ) ;\n }",
        "output": "1",
        "idx": 4011
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void reindex_all_databases ( const char * maintenance_db , const char * host , const char * port , const char * username , enum trivalue prompt_password , const char * progname , bool echo , bool quiet , bool verbose ) {\n PGconn * conn ;\n PGresult * result ;\n int i ;\n conn = connectMaintenanceDatabase ( maintenance_db , host , port , username , prompt_password , progname ) ;\n result = executeQuery ( conn , \"SELECT datname FROM pg_database WHERE datallowconn ORDER BY 1;\n\" , progname , echo ) ;\n PQfinish ( conn ) ;\n for ( i = 0 ;\n i < PQntuples ( result ) ;\n i ++ ) {\n char * dbname = PQgetvalue ( result , i , 0 ) ;\n if ( ! quiet ) {\n printf ( _ ( \"%s: reindexing database \\\"%s\\\"\\n\" ) , progname , dbname ) ;\n fflush ( stdout ) ;\n }\n reindex_one_database ( dbname , dbname , \"DATABASE\" , host , port , username , prompt_password , progname , echo , verbose ) ;\n }\n PQclear ( result ) ;\n }",
        "output": "1",
        "idx": 1651
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( NativeBackendLibsecretTest , SomeKeyringAttributesAreMissing ) {\n NativeBackendLibsecret backend ( 42 ) ;\n VerifiedAdd ( & backend , form_google_ ) ;\n EXPECT_EQ ( 1u , global_mock_libsecret_items -> size ( ) ) ;\n ( * global_mock_libsecret_items ) [ 0 ] -> RemoveAttribute ( \"avatar_url\" ) ;\n ( * global_mock_libsecret_items ) [ 0 ] -> RemoveAttribute ( \"ssl_valid\" ) ;\n ScopedVector < autofill : : PasswordForm > form_list ;\n EXPECT_TRUE ( backend . GetAutofillableLogins ( & form_list ) ) ;\n EXPECT_EQ ( 1u , form_list . size ( ) ) ;\n EXPECT_EQ ( GURL ( \"\" ) , form_list [ 0 ] -> icon_url ) ;\n EXPECT_FALSE ( form_list [ 0 ] -> ssl_valid ) ;\n }",
        "output": "1",
        "idx": 2190
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileInfo , setInfoClass ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n zend_class_entry * ce = spl_ce_SplFileInfo ;\n zend_error_handling error_handling ;\n zend_replace_error_handling ( EH_THROW , spl_ce_UnexpectedValueException , & error_handling TSRMLS_CC ) ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"|C\" , & ce ) == SUCCESS ) {\n intern -> info_class = ce ;\n }\n zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;\n }",
        "output": "1",
        "idx": 4192
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void update_reference_segmentation_map ( VP9_COMP * cpi ) {\n VP9_COMMON * const cm = & cpi -> common ;\n MODE_INFO * * mi_8x8_ptr = cm -> mi_grid_visible ;\n uint8_t * cache_ptr = cm -> last_frame_seg_map ;\n int row , col ;\n for ( row = 0 ;\n row < cm -> mi_rows ;\n row ++ ) {\n MODE_INFO * * mi_8x8 = mi_8x8_ptr ;\n uint8_t * cache = cache_ptr ;\n for ( col = 0 ;\n col < cm -> mi_cols ;\n col ++ , mi_8x8 ++ , cache ++ ) cache [ 0 ] = mi_8x8 [ 0 ] -> mbmi . segment_id ;\n mi_8x8_ptr += cm -> mi_stride ;\n cache_ptr += cm -> mi_cols ;\n }\n }",
        "output": "1",
        "idx": 1952
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main ( int argc , char * * argv ) {\n using std : : string ;\n if ( argc != 2 ) {\n fprintf ( stderr , \"One argument, the input filename, must be provided.\\n\" ) ;\n return 1 ;\n }\n string filename ( argv [ 1 ] ) ;\n string outfilename = filename . substr ( 0 , filename . find_last_of ( \".\" ) ) + \".ttf\" ;\n fprintf ( stdout , \"Processing %s => %s\\n\" , filename . c_str ( ) , outfilename . c_str ( ) ) ;\n string input = woff2 : : GetFileContent ( filename ) ;\n size_t decompressed_size = woff2 : : ComputeWOFF2FinalSize ( reinterpret_cast < const uint8_t * > ( input . data ( ) ) , input . size ( ) ) ;\n string output ( decompressed_size , 0 ) ;\n const bool ok = woff2 : : ConvertWOFF2ToTTF ( reinterpret_cast < uint8_t * > ( & output [ 0 ] ) , decompressed_size , reinterpret_cast < const uint8_t * > ( input . data ( ) ) , input . size ( ) ) ;\n if ( ! ok ) {\n fprintf ( stderr , \"Decompression failed\\n\" ) ;\n return 1 ;\n }\n woff2 : : SetFileContents ( outfilename , output ) ;\n return 0 ;\n }",
        "output": "1",
        "idx": 3052
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spl_filesystem_dir_it_current_data ( zend_object_iterator * iter , zval * * * data TSRMLS_DC ) {\n spl_filesystem_iterator * iterator = ( spl_filesystem_iterator * ) iter ;\n * data = & iterator -> current ;\n }",
        "output": "1",
        "idx": 2712
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Asn1Generic * DecodeAsn1DerIA5String ( const unsigned char * buffer , uint32_t max_size , uint8_t depth , uint32_t * errcode ) {\n const unsigned char * d_ptr = buffer ;\n uint32_t length , numbytes ;\n Asn1Generic * a ;\n unsigned char c ;\n d_ptr ++ ;\n c = d_ptr [ 0 ] ;\n if ( ( c & ( 1 << 7 ) ) >> 7 == 0 ) {\n length = c ;\n d_ptr ++ ;\n }\n else {\n numbytes = c & 0x7f ;\n d_ptr ++ ;\n if ( DecodeAsn1BuildValue ( & d_ptr , & length , numbytes , errcode ) == - 1 ) {\n return NULL ;\n }\n }\n if ( length > max_size ) return NULL ;\n a = Asn1GenericNew ( ) ;\n if ( a == NULL ) return NULL ;\n a -> type = ASN1_IA5STRING ;\n a -> strlen = length ;\n a -> str = SCMalloc ( length + 1 ) ;\n if ( a -> str == NULL ) {\n SCFree ( a ) ;\n return NULL ;\n }\n strlcpy ( a -> str , ( const char * ) d_ptr , length + 1 ) ;\n d_ptr += length ;\n a -> length = ( d_ptr - buffer ) ;\n return a ;\n }",
        "output": "1",
        "idx": 3863
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void Type_ColorantTable_Free ( struct _cms_typehandler_struct * self , void * Ptr ) {\n cmsFreeNamedColorList ( ( cmsNAMEDCOLORLIST * ) Ptr ) ;\n return ;\n cmsUNUSED_PARAMETER ( self ) ;\n }",
        "output": "0",
        "idx": 2414
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_rfc822_parse_content_param ( void ) {\n const char * input = \";\n key1=value1#$!%&'*+-.^_`{\n|}\n~\" \";\n key2=\\\" \\\\\\\"(),/:;\n<=>?@[\\\\\\\\]\\\"\" ;\n const struct {\n const char * key , * value ;\n }\n output [ ] = {\n {\n \"key1\" , \"value1#$!%&'*+-.^_`{\n|}\n~\" }\n , {\n \"key2\" , \" \\\"(),/:;\n<=>?@[\\\\]\" }\n }\n ;\n struct rfc822_parser_context parser ;\n const char * key , * value ;\n unsigned int i = 0 ;\n int ret ;\n test_begin ( \"rfc822 parse content param\" ) ;\n rfc822_parser_init ( & parser , ( const void * ) input , strlen ( input ) , NULL ) ;\n while ( ( ret = rfc822_parse_content_param ( & parser , & key , & value ) ) > 0 && i < N_ELEMENTS ( output ) ) {\n test_assert_idx ( strcmp ( output [ i ] . key , key ) == 0 , i ) ;\n test_assert_idx ( strcmp ( output [ i ] . value , value ) == 0 , i ) ;\n i ++ ;\n }\n test_assert ( ret == 0 ) ;\n test_assert ( i == N_ELEMENTS ( output ) ) ;\n test_end ( ) ;\n }",
        "output": "1",
        "idx": 2582
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void parseExtensionObject ( proto_tree * tree , tvbuff_t * tvb , packet_info * pinfo , gint * pOffset , const char * szFieldName ) {\n static const int * extobj_mask [ ] = {\n & hf_opcua_extobj_mask_binbodyflag , & hf_opcua_extobj_mask_xmlbodyflag , NULL }\n ;\n gint iOffset = * pOffset ;\n guint8 EncodingMask ;\n guint32 TypeId ;\n proto_tree * extobj_tree ;\n proto_item * ti ;\n extobj_tree = proto_tree_add_subtree_format ( tree , tvb , * pOffset , - 1 , ett_opcua_extensionobject , & ti , \"%s: ExtensionObject\" , szFieldName ) ;\n TypeId = getExtensionObjectType ( tvb , & iOffset ) ;\n parseExpandedNodeId ( extobj_tree , tvb , pinfo , & iOffset , \"TypeId\" ) ;\n EncodingMask = tvb_get_guint8 ( tvb , iOffset ) ;\n proto_tree_add_bitmask ( extobj_tree , tvb , iOffset , hf_opcua_extobj_mask , ett_opcua_extensionobject_encodingmask , extobj_mask , ENC_LITTLE_ENDIAN ) ;\n iOffset ++ ;\n if ( EncodingMask & EXTOBJ_ENCODINGMASK_BINBODY_FLAG ) {\n dispatchExtensionObjectType ( extobj_tree , tvb , pinfo , & iOffset , TypeId ) ;\n }\n proto_item_set_end ( ti , tvb , iOffset ) ;\n * pOffset = iOffset ;\n }",
        "output": "1",
        "idx": 2116
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xan_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n XanContext * s = avctx -> priv_data ;\n int ftype ;\n int ret ;\n s -> pic . reference = 1 ;\n s -> pic . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , & s -> pic ) ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n bytestream2_init ( & s -> gb , avpkt -> data , avpkt -> size ) ;\n ftype = bytestream2_get_le32 ( & s -> gb ) ;\n switch ( ftype ) {\n case 0 : ret = xan_decode_frame_type0 ( avctx ) ;\n break ;\n case 1 : ret = xan_decode_frame_type1 ( avctx ) ;\n break ;\n default : av_log ( avctx , AV_LOG_ERROR , \"Unknown frame type %d\\n\" , ftype ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( ret ) return ret ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> pic ;\n return avpkt -> size ;\n }",
        "output": "1",
        "idx": 1389
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void loop_filter_rows_mt ( const YV12_BUFFER_CONFIG * const frame_buffer , VP9_COMMON * const cm , struct macroblockd_plane planes [ MAX_MB_PLANE ] , int start , int stop , int y_only , VP9LfSync * const lf_sync , int num_lf_workers ) {\n const int num_planes = y_only ? 1 : MAX_MB_PLANE ;\n int r , c ;\n const int sb_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) >> MI_BLOCK_SIZE_LOG2 ;\n for ( r = start ;\n r < stop ;\n r += num_lf_workers ) {\n const int mi_row = r << MI_BLOCK_SIZE_LOG2 ;\n MODE_INFO * * const mi = cm -> mi_grid_visible + mi_row * cm -> mi_stride ;\n for ( c = 0 ;\n c < sb_cols ;\n ++ c ) {\n const int mi_col = c << MI_BLOCK_SIZE_LOG2 ;\n LOOP_FILTER_MASK lfm ;\n int plane ;\n sync_read ( lf_sync , r , c ) ;\n vp9_setup_dst_planes ( planes , frame_buffer , mi_row , mi_col ) ;\n vp9_setup_mask ( cm , mi_row , mi_col , mi + mi_col , cm -> mi_stride , & lfm ) ;\n for ( plane = 0 ;\n plane < num_planes ;\n ++ plane ) {\n vp9_filter_block_plane ( cm , & planes [ plane ] , mi_row , & lfm ) ;\n }\n sync_write ( lf_sync , r , c , sb_cols ) ;\n }\n }\n }",
        "output": "1",
        "idx": 2986
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned char conv_ascii2bin ( unsigned char a ) {\n if ( a & 0x80 ) return B64_ERROR ;\n return data_ascii2bin [ a ] ;\n }",
        "output": "0",
        "idx": 3547
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( CrossOriginXHR , NoFileAccess ) {\n ASSERT_TRUE ( RunExtensionTestNoFileAccess ( \"cross_origin_xhro_file_access\" ) ) << message_ ;\n }",
        "output": "1",
        "idx": 4270
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static guint32 dissect_netb_data_ack ( tvbuff_t * tvb , packet_info * pinfo _U_ , int offset , proto_tree * tree ) {\n nb_xmit_corrl ( tvb , offset , tree ) ;\n nb_remote_session ( tvb , offset , tree ) ;\n nb_local_session ( tvb , offset , tree ) ;\n return 0 ;\n }",
        "output": "0",
        "idx": 2277
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( DirectoryIterator , valid ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n RETURN_BOOL ( intern -> u . dir . entry . d_name [ 0 ] != '\\0' ) ;\n }",
        "output": "1",
        "idx": 1377
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , PaintInMainAndChildFrame ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n GURL a_url ( embedded_test_server ( ) -> GetURL ( \"/page_load_metrics/main_frame_with_iframe.html\" ) ) ;\n auto waiter = CreatePageLoadMetricsWaiter ( ) ;\n waiter -> AddPageExpectation ( TimingField : : FIRST_LAYOUT ) ;\n waiter -> AddPageExpectation ( TimingField : : LOAD_EVENT ) ;\n waiter -> AddPageExpectation ( TimingField : : FIRST_PAINT ) ;\n waiter -> AddPageExpectation ( TimingField : : FIRST_CONTENTFUL_PAINT ) ;\n waiter -> AddSubFrameExpectation ( TimingField : : FIRST_PAINT ) ;\n waiter -> AddSubFrameExpectation ( TimingField : : FIRST_CONTENTFUL_PAINT ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , a_url ) ;\n waiter -> Wait ( ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramFirstLayout , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramLoad , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramFirstPaint , 1 ) ;\n }",
        "output": "0",
        "idx": 201
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static vpx_codec_err_t ctrl_set_arnr_type ( vpx_codec_alg_priv_t * ctx , va_list args ) {\n ( void ) ctx ;\n ( void ) args ;\n return VPX_CODEC_OK ;\n }",
        "output": "0",
        "idx": 866
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void selinux_sb_free_security ( struct super_block * sb ) {\n superblock_free_security ( sb ) ;\n }",
        "output": "0",
        "idx": 175
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int64_t rd_sbuv_dcpred ( const VP9_COMP * cpi , MACROBLOCK * x , int * rate , int * rate_tokenonly , int64_t * distortion , int * skippable , BLOCK_SIZE bsize ) {\n const VP9_COMMON * cm = & cpi -> common ;\n int64_t unused ;\n x -> e_mbd . mi [ 0 ] -> mbmi . uv_mode = DC_PRED ;\n super_block_uvrd ( cpi , x , rate_tokenonly , distortion , skippable , & unused , bsize , INT64_MAX ) ;\n * rate = * rate_tokenonly + cpi -> intra_uv_mode_cost [ cm -> frame_type ] [ DC_PRED ] ;\n return RDCOST ( x -> rdmult , x -> rddiv , * rate , * distortion ) ;\n }",
        "output": "1",
        "idx": 3061
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char * passphrase_callback ( struct archive * a , void * _client_data ) {\n struct cpio * cpio = ( struct cpio * ) _client_data ;\n ( void ) a ;\n if ( cpio -> ppbuff == NULL ) {\n cpio -> ppbuff = malloc ( PPBUFF_SIZE ) ;\n if ( cpio -> ppbuff == NULL ) lafe_errc ( 1 , errno , \"Out of memory\" ) ;\n }\n return lafe_readpassphrase ( \"Enter passphrase:\" , cpio -> ppbuff , PPBUFF_SIZE ) ;\n }",
        "output": "0",
        "idx": 1361
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gboolean lbmpdm_verify_payload ( tvbuff_t * tvb , int offset , int * encoding , int * length ) {\n guint8 next_header ;\n guint32 len = 0 ;\n if ( ! tvb_bytes_exist ( tvb , offset , L_LBMPDM_MSG_HDR_T ) ) {\n return ( FALSE ) ;\n }\n if ( ! check_lbmpdm_encoding ( tvb , offset , encoding ) ) {\n return ( FALSE ) ;\n }\n next_header = tvb_get_guint8 ( tvb , offset + O_LBMPDM_MSG_HDR_T_NEXT_HDR ) ;\n switch ( next_header ) {\n case PDM_HDR_TYPE_DATA : case PDM_HDR_TYPE_OFSTTBLE : case PDM_HDR_TYPE_DEFN : case PDM_HDR_TYPE_EOM : break ;\n default : return ( FALSE ) ;\n break ;\n }\n len = lbmpdm_fetch_uint32_encoded ( tvb , offset + O_LBMPDM_MSG_HDR_T_LEN , * encoding ) ;\n if ( len > G_MAXINT ) {\n return ( FALSE ) ;\n }\n * length = ( int ) len ;\n return ( TRUE ) ;\n }",
        "output": "0",
        "idx": 2362
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int parse_audio_var ( AVFormatContext * avctx , AVStream * st , const char * name , int size ) {\n MvContext * mv = avctx -> priv_data ;\n AVIOContext * pb = avctx -> pb ;\n if ( ! strcmp ( name , \"__DIR_COUNT\" ) ) {\n st -> nb_frames = var_read_int ( pb , size ) ;\n }\n else if ( ! strcmp ( name , \"AUDIO_FORMAT\" ) ) {\n mv -> aformat = var_read_int ( pb , size ) ;\n }\n else if ( ! strcmp ( name , \"COMPRESSION\" ) ) {\n mv -> acompression = var_read_int ( pb , size ) ;\n }\n else if ( ! strcmp ( name , \"DEFAULT_VOL\" ) ) {\n var_read_metadata ( avctx , name , size ) ;\n }\n else if ( ! strcmp ( name , \"NUM_CHANNELS\" ) ) {\n return set_channels ( avctx , st , var_read_int ( pb , size ) ) ;\n }\n else if ( ! strcmp ( name , \"SAMPLE_RATE\" ) ) {\n st -> codecpar -> sample_rate = var_read_int ( pb , size ) ;\n avpriv_set_pts_info ( st , 33 , 1 , st -> codecpar -> sample_rate ) ;\n }\n else if ( ! strcmp ( name , \"SAMPLE_WIDTH\" ) ) {\n st -> codecpar -> bits_per_coded_sample = var_read_int ( pb , size ) * 8 ;\n }\n else return AVERROR_INVALIDDATA ;\n return 0 ;\n }",
        "output": "0",
        "idx": 2953
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void log_read_interval ( const ReadInterval * interval , void * log_ctx , int log_level ) {\n av_log ( log_ctx , log_level , \"id:%d\" , interval -> id ) ;\n if ( interval -> has_start ) {\n av_log ( log_ctx , log_level , \" start:%s%s\" , interval -> start_is_offset ? \"+\" : \"\" , av_ts2timestr ( interval -> start , & AV_TIME_BASE_Q ) ) ;\n }\n else {\n av_log ( log_ctx , log_level , \" start:N/A\" ) ;\n }\n if ( interval -> has_end ) {\n av_log ( log_ctx , log_level , \" end:%s\" , interval -> end_is_offset ? \"+\" : \"\" ) ;\n if ( interval -> duration_frames ) av_log ( log_ctx , log_level , \"#%\" PRId64 , interval -> end ) ;\n else av_log ( log_ctx , log_level , \"%s\" , av_ts2timestr ( interval -> end , & AV_TIME_BASE_Q ) ) ;\n }\n else {\n av_log ( log_ctx , log_level , \" end:N/A\" ) ;\n }\n av_log ( log_ctx , log_level , \"\\n\" ) ;\n }",
        "output": "0",
        "idx": 3952
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void get_sb_partition_size_range ( MACROBLOCKD * xd , MODE_INFO * * mi_8x8 , BLOCK_SIZE * min_block_size , BLOCK_SIZE * max_block_size , int bs_hist [ BLOCK_SIZES ] ) {\n int sb_width_in_blocks = MI_BLOCK_SIZE ;\n int sb_height_in_blocks = MI_BLOCK_SIZE ;\n int i , j ;\n int index = 0 ;\n for ( i = 0 ;\n i < sb_height_in_blocks ;\n ++ i ) {\n for ( j = 0 ;\n j < sb_width_in_blocks ;\n ++ j ) {\n MODE_INFO * mi = mi_8x8 [ index + j ] ;\n BLOCK_SIZE sb_type = mi ? mi -> mbmi . sb_type : 0 ;\n bs_hist [ sb_type ] ++ ;\n * min_block_size = MIN ( * min_block_size , sb_type ) ;\n * max_block_size = MAX ( * max_block_size , sb_type ) ;\n }\n index += xd -> mi_stride ;\n }\n }",
        "output": "1",
        "idx": 3466
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void destroy_address_node ( address_node * my_node ) {\n if ( NULL == my_node ) return ;\n NTP_REQUIRE ( NULL != my_node -> address ) ;\n free ( my_node -> address ) ;\n free ( my_node ) ;\n }",
        "output": "0",
        "idx": 3566
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dumpDatabases ( PGconn * conn ) {\n PGresult * res ;\n int i ;\n if ( server_version >= 70100 ) res = executeQuery ( conn , \"SELECT datname FROM pg_database WHERE datallowconn ORDER BY 1\" ) ;\n else res = executeQuery ( conn , \"SELECT datname FROM pg_database ORDER BY 1\" ) ;\n for ( i = 0 ;\n i < PQntuples ( res ) ;\n i ++ ) {\n int ret ;\n char * dbname = PQgetvalue ( res , i , 0 ) ;\n if ( verbose ) fprintf ( stderr , _ ( \"%s: dumping database \\\"%s\\\"...\\n\" ) , progname , dbname ) ;\n fprintf ( OPF , \"\\\\connect %s\\n\\n\" , fmtId ( dbname ) ) ;\n fprintf ( OPF , \"SET default_transaction_read_only = off;\n\\n\\n\" ) ;\n if ( filename ) fclose ( OPF ) ;\n ret = runPgDump ( dbname ) ;\n if ( ret != 0 ) {\n fprintf ( stderr , _ ( \"%s: pg_dump failed on database \\\"%s\\\", exiting\\n\" ) , progname , dbname ) ;\n exit_nicely ( 1 ) ;\n }\n if ( filename ) {\n OPF = fopen ( filename , PG_BINARY_A ) ;\n if ( ! OPF ) {\n fprintf ( stderr , _ ( \"%s: could not re-open the output file \\\"%s\\\": %s\\n\" ) , progname , filename , strerror ( errno ) ) ;\n exit_nicely ( 1 ) ;\n }\n }\n }\n PQclear ( res ) ;\n }",
        "output": "1",
        "idx": 1119
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cluster_all_databases ( bool verbose , const char * maintenance_db , const char * host , const char * port , const char * username , enum trivalue prompt_password , const char * progname , bool echo , bool quiet ) {\n PGconn * conn ;\n PGresult * result ;\n int i ;\n conn = connectMaintenanceDatabase ( maintenance_db , host , port , username , prompt_password , progname ) ;\n result = executeQuery ( conn , \"SELECT datname FROM pg_database WHERE datallowconn ORDER BY 1;\n\" , progname , echo ) ;\n PQfinish ( conn ) ;\n for ( i = 0 ;\n i < PQntuples ( result ) ;\n i ++ ) {\n char * dbname = PQgetvalue ( result , i , 0 ) ;\n if ( ! quiet ) {\n printf ( _ ( \"%s: clustering database \\\"%s\\\"\\n\" ) , progname , dbname ) ;\n fflush ( stdout ) ;\n }\n cluster_one_database ( dbname , verbose , NULL , host , port , username , prompt_password , progname , echo ) ;\n }\n PQclear ( result ) ;\n }",
        "output": "1",
        "idx": 162
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( MultiBufferTest , RandomTest_RangeSupported ) {\n size_t file_size = 1000000 ;\n multibuffer_ . SetFileSize ( file_size ) ;\n multibuffer_ . SetMaxBlocksAfterDefer ( 10 ) ;\n std : : vector < ReadHelper * > read_helpers ;\n multibuffer_ . SetRangeSupported ( true ) ;\n for ( size_t i = 0 ;\n i < 20 ;\n i ++ ) {\n read_helpers . push_back ( new ReadHelper ( file_size , 1000 , & multibuffer_ , & rnd_ ) ) ;\n }\n for ( int i = 0 ;\n i < 100 ;\n i ++ ) {\n for ( int j = 0 ;\n j < 100 ;\n j ++ ) {\n if ( rnd_ . Rand ( ) & 1 ) {\n if ( ! media : : writers . empty ( ) ) Advance ( ) ;\n }\n else {\n size_t j = rnd_ . Rand ( ) % read_helpers . size ( ) ;\n if ( rnd_ . Rand ( ) % 100 < 3 ) read_helpers [ j ] -> Seek ( ) ;\n read_helpers [ j ] -> StartRead ( ) ;\n }\n }\n multibuffer_ . CheckLRUState ( ) ;\n }\n multibuffer_ . CheckPresentState ( ) ;\n while ( ! read_helpers . empty ( ) ) {\n delete read_helpers . back ( ) ;\n read_helpers . pop_back ( ) ;\n }\n }",
        "output": "1",
        "idx": 3602
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mbfl_string * mbfl_buffer_converter_feed_result ( mbfl_buffer_converter * convd , mbfl_string * string , mbfl_string * result ) {\n if ( convd == NULL || string == NULL || result == NULL ) {\n return NULL ;\n }\n mbfl_buffer_converter_feed ( convd , string ) ;\n if ( convd -> filter1 != NULL ) {\n mbfl_convert_filter_flush ( convd -> filter1 ) ;\n }\n if ( convd -> filter2 != NULL ) {\n mbfl_convert_filter_flush ( convd -> filter2 ) ;\n }\n result -> no_encoding = convd -> to -> no_encoding ;\n return mbfl_memory_device_result ( & convd -> device , result ) ;\n }",
        "output": "1",
        "idx": 638
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool parse_authorityInfoAccess ( chunk_t blob , int level0 , private_x509_cert_t * this ) {\n asn1_parser_t * parser ;\n chunk_t object ;\n int objectID ;\n int accessMethod = OID_UNKNOWN ;\n bool success = FALSE ;\n parser = asn1_parser_create ( authInfoAccessObjects , blob ) ;\n parser -> set_top_level ( parser , level0 ) ;\n while ( parser -> iterate ( parser , & objectID , & object ) ) {\n switch ( objectID ) {\n case AUTH_INFO_ACCESS_METHOD : accessMethod = asn1_known_oid ( object ) ;\n break ;\n case AUTH_INFO_ACCESS_LOCATION : {\n switch ( accessMethod ) {\n case OID_OCSP : case OID_CA_ISSUERS : {\n identification_t * id ;\n char * uri ;\n id = parse_generalName ( object , parser -> get_level ( parser ) + 1 ) ;\n if ( id == NULL ) {\n goto end ;\n }\n DBG2 ( DBG_ASN , \" '%Y'\" , id ) ;\n if ( accessMethod == OID_OCSP && gn_to_string ( id , & uri ) ) {\n this -> ocsp_uris -> insert_last ( this -> ocsp_uris , uri ) ;\n }\n id -> destroy ( id ) ;\n }\n break ;\n default : break ;\n }\n break ;\n }\n default : break ;\n }\n }\n success = parser -> success ( parser ) ;\n end : parser -> destroy ( parser ) ;\n return success ;\n }",
        "output": "0",
        "idx": 4178
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST ( BuildTime , DoesntCrash ) {\n base : : GetBuildTime ( ) ;\n }",
        "output": "1",
        "idx": 996
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const DataHeader * U_CALLCONV pointerTOCLookupFn ( const UDataMemory * pData , const char * name , int32_t * pLength , UErrorCode * pErrorCode ) {\n ( void ) pErrorCode ;\n if ( pData -> toc != NULL ) {\n const PointerTOC * toc = ( PointerTOC * ) pData -> toc ;\n int32_t number , count = ( int32_t ) toc -> count ;\n # if defined ( UDATA_DEBUG_DUMP ) for ( number = 0 ;\n number < count ;\n ++ number ) {\n fprintf ( stderr , \"\\tx%d: %s\\n\" , number , toc -> entry [ number ] . entryName ) ;\n }\n # endif number = pointerTOCPrefixBinarySearch ( name , toc -> entry , count ) ;\n if ( number >= 0 ) {\n # ifdef UDATA_DEBUG fprintf ( stderr , \"%s: Found.\\n\" , toc -> entry [ number ] . entryName ) ;\n # endif * pLength = - 1 ;\n return UDataMemory_normalizeDataPointer ( toc -> entry [ number ] . pHeader ) ;\n }\n else {\n # ifdef UDATA_DEBUG fprintf ( stderr , \"%s: Not found.\\n\" , name ) ;\n # endif return NULL ;\n }\n }\n else {\n return pData -> pHeader ;\n }\n }",
        "output": "0",
        "idx": 610
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int fill_vaapi_ReferenceFrames ( VAPictureParameterBufferH264 * pic_param , H264Context * h ) {\n DPB dpb ;\n int i ;\n dpb . size = 0 ;\n dpb . max_size = FF_ARRAY_ELEMS ( pic_param -> ReferenceFrames ) ;\n dpb . va_pics = pic_param -> ReferenceFrames ;\n for ( i = 0 ;\n i < dpb . max_size ;\n i ++ ) init_vaapi_pic ( & dpb . va_pics [ i ] ) ;\n for ( i = 0 ;\n i < h -> short_ref_count ;\n i ++ ) {\n Picture * const pic = h -> short_ref [ i ] ;\n if ( pic && pic -> f . reference && dpb_add ( & dpb , pic ) < 0 ) return - 1 ;\n }\n for ( i = 0 ;\n i < 16 ;\n i ++ ) {\n Picture * const pic = h -> long_ref [ i ] ;\n if ( pic && pic -> f . reference && dpb_add ( & dpb , pic ) < 0 ) return - 1 ;\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 1845
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileInfo , func_name ) \\ {\n \\ spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n \\ zend_error_handling error_handling ;\n \\ if ( zend_parse_parameters_none ( ) == FAILURE ) {\n \\ return ;\n \\ }\n \\ \\ zend_replace_error_handling ( EH_THROW , spl_ce_RuntimeException , & error_handling TSRMLS_CC ) ;\n \\ spl_filesystem_object_get_file_name ( intern TSRMLS_CC ) ;\n \\ php_stat ( intern -> file_name , intern -> file_name_len , func_num , return_value TSRMLS_CC ) ;\n \\ zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;\n \\ }\n FileInfoFunction ( getPerms , FS_PERMS ) FileInfoFunction ( getInode , FS_INODE ) FileInfoFunction ( getSize , FS_SIZE ) FileInfoFunction ( getOwner , FS_OWNER ) FileInfoFunction ( getGroup , FS_GROUP ) FileInfoFunction ( getATime , FS_ATIME ) FileInfoFunction ( getMTime , FS_MTIME )",
        "output": "0",
        "idx": 2120
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void xmlHashScan ( xmlHashTablePtr table , xmlHashScanner f , void * data ) {\n stubData stubdata ;\n stubdata . data = data ;\n stubdata . hashscanner = f ;\n xmlHashScanFull ( table , stubHashScannerFull , & stubdata ) ;\n }",
        "output": "1",
        "idx": 1901
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileObject , hasChildren ) {\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n RETURN_FALSE ;\n }",
        "output": "1",
        "idx": 2763
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const DataHeader * pointerTOCLookupFn ( const UDataMemory * pData , const char * name , int32_t * pLength , UErrorCode * pErrorCode ) {\n if ( pData -> toc != NULL ) {\n const PointerTOC * toc = ( PointerTOC * ) pData -> toc ;\n int32_t number , count = ( int32_t ) toc -> count ;\n # if defined ( UDATA_DEBUG_DUMP ) for ( number = 0 ;\n number < count ;\n ++ number ) {\n fprintf ( stderr , \"\\tx%d: %s\\n\" , number , toc -> entry [ number ] . entryName ) ;\n }\n # endif number = pointerTOCPrefixBinarySearch ( name , toc -> entry , count ) ;\n if ( number >= 0 ) {\n # ifdef UDATA_DEBUG fprintf ( stderr , \"%s: Found.\\n\" , toc -> entry [ number ] . entryName ) ;\n # endif * pLength = - 1 ;\n return UDataMemory_normalizeDataPointer ( toc -> entry [ number ] . pHeader ) ;\n }\n else {\n # ifdef UDATA_DEBUG fprintf ( stderr , \"%s: Not found.\\n\" , name ) ;\n # endif return NULL ;\n }\n }\n else {\n return pData -> pHeader ;\n }\n }",
        "output": "1",
        "idx": 3210
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int key_notify_sa_expire ( struct xfrm_state * x , const struct km_event * c ) {\n struct sk_buff * out_skb ;\n struct sadb_msg * out_hdr ;\n int hard ;\n int hsc ;\n hard = c -> data . hard ;\n if ( hard ) hsc = 2 ;\n else hsc = 1 ;\n out_skb = pfkey_xfrm_state2msg_expire ( x , hsc ) ;\n if ( IS_ERR ( out_skb ) ) return PTR_ERR ( out_skb ) ;\n out_hdr = ( struct sadb_msg * ) out_skb -> data ;\n out_hdr -> sadb_msg_version = PF_KEY_V2 ;\n out_hdr -> sadb_msg_type = SADB_EXPIRE ;\n out_hdr -> sadb_msg_satype = pfkey_proto2satype ( x -> id . proto ) ;\n out_hdr -> sadb_msg_errno = 0 ;\n out_hdr -> sadb_msg_reserved = 0 ;\n out_hdr -> sadb_msg_seq = 0 ;\n out_hdr -> sadb_msg_pid = 0 ;\n pfkey_broadcast ( out_skb , GFP_ATOMIC , BROADCAST_REGISTERED , NULL , xs_net ( x ) ) ;\n return 0 ;\n }",
        "output": "0",
        "idx": 1298
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "X509_REQ * X509_to_X509_REQ ( X509 * x , EVP_PKEY * pkey , const EVP_MD * md ) {\n X509_REQ * ret ;\n X509_REQ_INFO * ri ;\n int i ;\n EVP_PKEY * pktmp ;\n ret = X509_REQ_new ( ) ;\n if ( ret == NULL ) {\n X509err ( X509_F_X509_TO_X509_REQ , ERR_R_MALLOC_FAILURE ) ;\n goto err ;\n }\n ri = ret -> req_info ;\n ri -> version -> length = 1 ;\n ri -> version -> data = ( unsigned char * ) OPENSSL_malloc ( 1 ) ;\n if ( ri -> version -> data == NULL ) goto err ;\n ri -> version -> data [ 0 ] = 0 ;\n if ( ! X509_REQ_set_subject_name ( ret , X509_get_subject_name ( x ) ) ) goto err ;\n pktmp = X509_get_pubkey ( x ) ;\n i = X509_REQ_set_pubkey ( ret , pktmp ) ;\n EVP_PKEY_free ( pktmp ) ;\n if ( ! i ) goto err ;\n if ( pkey != NULL ) {\n if ( ! X509_REQ_sign ( ret , pkey , md ) ) goto err ;\n }\n return ( ret ) ;\n err : X509_REQ_free ( ret ) ;\n return ( NULL ) ;\n }",
        "output": "1",
        "idx": 2521
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dtap_tp_reset_ms_positioning_stored_information ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_len = len ;\n curr_offset = offset ;\n ELEM_MAND_V ( GSM_A_PDU_TYPE_DTAP , DE_TP_MS_POSITIONING_TECHNOLOGY , NULL ) ;\n EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n }",
        "output": "0",
        "idx": 2344
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , AbortNewNavigation ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n GURL url ( embedded_test_server ( ) -> GetURL ( \"/title1.html\" ) ) ;\n NavigateParams params ( browser ( ) , url , ui : : PAGE_TRANSITION_LINK ) ;\n content : : TestNavigationManager manager ( browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) , url ) ;\n Navigate ( & params ) ;\n EXPECT_TRUE ( manager . WaitForRequestStart ( ) ) ;\n GURL url2 ( embedded_test_server ( ) -> GetURL ( \"/title2.html\" ) ) ;\n NavigateParams params2 ( browser ( ) , url2 , ui : : PAGE_TRANSITION_FROM_ADDRESS_BAR ) ;\n auto waiter = CreatePageLoadMetricsWaiter ( ) ;\n waiter -> AddPageExpectation ( TimingField : : LOAD_EVENT ) ;\n Navigate ( & params2 ) ;\n waiter -> Wait ( ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramAbortNewNavigationBeforeCommit , 1 ) ;\n }",
        "output": "0",
        "idx": 169
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void feature_destroy ( hb_feature_t * g ) {\n free ( g ) ;\n }",
        "output": "1",
        "idx": 1402
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int DSA_verify ( int type , const unsigned char * dgst , int dgst_len , const unsigned char * sigbuf , int siglen , DSA * dsa ) {\n DSA_SIG * s ;\n int ret = - 1 ;\n s = DSA_SIG_new ( ) ;\n if ( s == NULL ) return ( ret ) ;\n if ( d2i_DSA_SIG ( & s , & sigbuf , siglen ) == NULL ) goto err ;\n ret = DSA_do_verify ( dgst , dgst_len , s , dsa ) ;\n err : DSA_SIG_free ( s ) ;\n return ( ret ) ;\n }",
        "output": "1",
        "idx": 392
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static UConverter * _ISCII_SafeClone ( const UConverter * cnv , void * stackBuffer , int32_t * pBufferSize , UErrorCode * status ) {\n struct cloneISCIIStruct * localClone ;\n int32_t bufferSizeNeeded = sizeof ( struct cloneISCIIStruct ) ;\n if ( U_FAILURE ( * status ) ) {\n return 0 ;\n }\n if ( * pBufferSize == 0 ) {\n * pBufferSize = bufferSizeNeeded ;\n return 0 ;\n }\n localClone = ( struct cloneISCIIStruct * ) stackBuffer ;\n uprv_memcpy ( & localClone -> mydata , cnv -> extraInfo , sizeof ( UConverterDataISCII ) ) ;\n localClone -> cnv . extraInfo = & localClone -> mydata ;\n localClone -> cnv . isExtraLocal = TRUE ;\n return & localClone -> cnv ;\n }",
        "output": "1",
        "idx": 2920
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int ipv6_addr_type ( const struct in6_addr * addr ) {\n return __ipv6_addr_type ( addr ) & 0xffff ;\n }",
        "output": "0",
        "idx": 1683
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void exsltNodeSetFunction ( xmlXPathParserContextPtr ctxt , int nargs ) {\n if ( nargs != 1 ) {\n xmlXPathSetArityError ( ctxt ) ;\n return ;\n }\n if ( xmlXPathStackIsNodeSet ( ctxt ) ) {\n xsltFunctionNodeSet ( ctxt , nargs ) ;\n return ;\n }\n else {\n xmlDocPtr fragment ;\n xsltTransformContextPtr tctxt = xsltXPathGetTransformContext ( ctxt ) ;\n xmlNodePtr txt ;\n xmlChar * strval ;\n xmlXPathObjectPtr obj ;\n fragment = xsltCreateRVT ( tctxt ) ;\n if ( fragment == NULL ) {\n xsltTransformError ( tctxt , NULL , tctxt -> inst , \"exsltNodeSetFunction: Failed to create a tree fragment.\\n\" ) ;\n tctxt -> state = XSLT_STATE_STOPPED ;\n return ;\n }\n xsltRegisterLocalRVT ( tctxt , fragment ) ;\n strval = xmlXPathPopString ( ctxt ) ;\n txt = xmlNewDocText ( fragment , strval ) ;\n xmlAddChild ( ( xmlNodePtr ) fragment , txt ) ;\n obj = xmlXPathNewNodeSet ( txt ) ;\n if ( obj == NULL ) {\n xsltTransformError ( tctxt , NULL , tctxt -> inst , \"exsltNodeSetFunction: Failed to create a node set object.\\n\" ) ;\n tctxt -> state = XSLT_STATE_STOPPED ;\n }\n else {\n xsltExtensionInstructionResultRegister ( tctxt , obj ) ;\n }\n if ( strval != NULL ) xmlFree ( strval ) ;\n valuePush ( ctxt , obj ) ;\n }\n }",
        "output": "1",
        "idx": 1930
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_loop_filter_rows ( const YV12_BUFFER_CONFIG * frame_buffer , VP9_COMMON * cm , struct macroblockd_plane planes [ MAX_MB_PLANE ] , int start , int stop , int y_only ) {\n const int num_planes = y_only ? 1 : MAX_MB_PLANE ;\n const int use_420 = y_only || ( planes [ 1 ] . subsampling_y == 1 && planes [ 1 ] . subsampling_x == 1 ) ;\n LOOP_FILTER_MASK lfm ;\n int mi_row , mi_col ;\n for ( mi_row = start ;\n mi_row < stop ;\n mi_row += MI_BLOCK_SIZE ) {\n MODE_INFO * * mi = cm -> mi_grid_visible + mi_row * cm -> mi_stride ;\n for ( mi_col = 0 ;\n mi_col < cm -> mi_cols ;\n mi_col += MI_BLOCK_SIZE ) {\n int plane ;\n vp9_setup_dst_planes ( planes , frame_buffer , mi_row , mi_col ) ;\n if ( use_420 ) vp9_setup_mask ( cm , mi_row , mi_col , mi + mi_col , cm -> mi_stride , & lfm ) ;\n for ( plane = 0 ;\n plane < num_planes ;\n ++ plane ) {\n if ( use_420 ) vp9_filter_block_plane ( cm , & planes [ plane ] , mi_row , & lfm ) ;\n else filter_block_plane_non420 ( cm , & planes [ plane ] , mi + mi_col , mi_row , mi_col ) ;\n }\n }\n }\n }",
        "output": "1",
        "idx": 322
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int decode_argb_frame ( CLLCContext * ctx , GetBitContext * gb , AVFrame * pic ) {\n AVCodecContext * avctx = ctx -> avctx ;\n uint8_t * dst ;\n int pred [ 4 ] ;\n int ret ;\n int i , j ;\n VLC vlc [ 4 ] ;\n pred [ 0 ] = 0 ;\n pred [ 1 ] = 0x80 ;\n pred [ 2 ] = 0x80 ;\n pred [ 3 ] = 0x80 ;\n dst = pic -> data [ 0 ] ;\n skip_bits ( gb , 16 ) ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n ret = read_code_table ( ctx , gb , & vlc [ i ] ) ;\n if ( ret < 0 ) {\n for ( j = 0 ;\n j <= i ;\n j ++ ) ff_free_vlc ( & vlc [ j ] ) ;\n av_log ( ctx -> avctx , AV_LOG_ERROR , \"Could not read code table %d.\\n\" , i ) ;\n return ret ;\n }\n }\n for ( i = 0 ;\n i < avctx -> height ;\n i ++ ) {\n read_argb_line ( ctx , gb , pred , vlc , dst ) ;\n dst += pic -> linesize [ 0 ] ;\n }\n for ( i = 0 ;\n i < 4 ;\n i ++ ) ff_free_vlc ( & vlc [ i ] ) ;\n return 0 ;\n }",
        "output": "0",
        "idx": 3997
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char * gcry_sexp_nth_string ( const gcry_sexp_t list , int number ) {\n const char * s ;\n size_t n ;\n char * buf ;\n s = sexp_nth_data ( list , number , & n ) ;\n if ( ! s || n < 1 || ( n + 1 ) < 1 ) return NULL ;\n buf = gcry_malloc ( n + 1 ) ;\n if ( ! buf ) return NULL ;\n memcpy ( buf , s , n ) ;\n buf [ n ] = 0 ;\n return buf ;\n }",
        "output": "0",
        "idx": 757
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int check_n_master ( AVCodecContext * avctx , int n_master , int bs_xover_band ) {\n if ( n_master <= 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid n_master: %d\\n\" , n_master ) ;\n return - 1 ;\n }\n if ( bs_xover_band >= n_master ) {\n av_log ( avctx , AV_LOG_ERROR , \"Invalid bitstream, crossover band index beyond array bounds: %d\\n\" , bs_xover_band ) ;\n return - 1 ;\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 1990
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void gs_memory_set_vm_threshold ( gs_ref_memory_t * mem , long val ) {\n gs_memory_gc_status_t stat ;\n gs_ref_memory_t * stable = ( gs_ref_memory_t * ) mem -> stable_memory ;\n gs_memory_gc_status ( mem , & stat ) ;\n stat . vm_threshold = val ;\n gs_memory_set_gc_status ( mem , & stat ) ;\n gs_memory_gc_status ( stable , & stat ) ;\n stat . vm_threshold = val ;\n gs_memory_set_gc_status ( stable , & stat ) ;\n }",
        "output": "0",
        "idx": 1589
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct condition * compiler_create_condition ( struct filter_op * fop ) {\n struct condition * cnd ;\n SAFE_CALLOC ( cnd , 1 , sizeof ( struct condition ) ) ;\n memcpy ( & cnd -> fop , fop , sizeof ( struct filter_op ) ) ;\n return cnd ;\n }",
        "output": "0",
        "idx": 1906
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rds_inc_info_copy ( struct rds_incoming * inc , struct rds_info_iterator * iter , __be32 saddr , __be32 daddr , int flip ) {\n struct rds_info_message minfo ;\n minfo . seq = be64_to_cpu ( inc -> i_hdr . h_sequence ) ;\n minfo . len = be32_to_cpu ( inc -> i_hdr . h_len ) ;\n if ( flip ) {\n minfo . laddr = daddr ;\n minfo . faddr = saddr ;\n minfo . lport = inc -> i_hdr . h_dport ;\n minfo . fport = inc -> i_hdr . h_sport ;\n }\n else {\n minfo . laddr = saddr ;\n minfo . faddr = daddr ;\n minfo . lport = inc -> i_hdr . h_sport ;\n minfo . fport = inc -> i_hdr . h_dport ;\n }\n rds_info_copy ( iter , & minfo , sizeof ( minfo ) ) ;\n }",
        "output": "1",
        "idx": 2931
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_KeyProtectionMethod ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_KeyProtectionMethod , KeyProtectionMethod_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 490
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "proto_item * proto_tree_get_parent ( proto_tree * tree ) {\n if ( ! tree ) return NULL ;\n return ( proto_item * ) tree ;\n }",
        "output": "0",
        "idx": 2758
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void purple_logout ( struct im_connection * ic ) {\n struct purple_data * pd = ic -> proto_data ;\n if ( ! pd ) {\n return ;\n }\n while ( ic -> groupchats ) {\n imcb_chat_free ( ic -> groupchats -> data ) ;\n }\n purple_account_set_enabled ( pd -> account , \"BitlBee\" , FALSE ) ;\n purple_connections = g_slist_remove ( purple_connections , ic ) ;\n purple_accounts_remove ( pd -> account ) ;\n imcb_chat_list_free ( ic ) ;\n g_free ( pd -> chat_list_server ) ;\n g_hash_table_destroy ( pd -> input_requests ) ;\n g_free ( pd ) ;\n }",
        "output": "1",
        "idx": 3663
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "size_t vpx_svc_get_rc_stats_buffer_size ( const SvcContext * svc_ctx ) {\n const SvcInternal * const si = get_const_svc_internal ( svc_ctx ) ;\n if ( svc_ctx == NULL || si == NULL ) return 0 ;\n return si -> rc_stats_buf_used ;\n }",
        "output": "1",
        "idx": 2484
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void flush ( AVCodecContext * avctx ) {\n WmallDecodeCtx * s = avctx -> priv_data ;\n s -> packet_loss = 1 ;\n s -> packet_done = 0 ;\n s -> num_saved_bits = 0 ;\n s -> frame_offset = 0 ;\n s -> next_packet_start = 0 ;\n s -> cdlms [ 0 ] [ 0 ] . order = 0 ;\n s -> frame . nb_samples = 0 ;\n init_put_bits ( & s -> pb , s -> frame_data , MAX_FRAMESIZE ) ;\n }",
        "output": "0",
        "idx": 2584
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _UTF7Reset ( UConverter * cnv , UConverterResetChoice choice ) {\n if ( choice <= UCNV_RESET_TO_UNICODE ) {\n cnv -> toUnicodeStatus = 0x1000000 ;\n cnv -> toULength = 0 ;\n }\n if ( choice != UCNV_RESET_TO_UNICODE ) {\n cnv -> fromUnicodeStatus = ( cnv -> fromUnicodeStatus & 0xf0000000 ) | 0x1000000 ;\n }\n }",
        "output": "1",
        "idx": 651
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PyObject * string_index ( PyStringObject * self , PyObject * args ) {\n Py_ssize_t result = string_find_internal ( self , args , + 1 ) ;\n if ( result == - 2 ) return NULL ;\n if ( result == - 1 ) {\n PyErr_SetString ( PyExc_ValueError , \"substring not found\" ) ;\n return NULL ;\n }\n return PyInt_FromSsize_t ( result ) ;\n }",
        "output": "0",
        "idx": 266
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void evhttp_connection_free ( struct evhttp_connection * evcon ) {\n struct evhttp_request * req ;\n if ( evcon -> fd != - 1 ) {\n if ( evhttp_connected ( evcon ) && evcon -> closecb != NULL ) ( * evcon -> closecb ) ( evcon , evcon -> closecb_arg ) ;\n }\n while ( ( req = TAILQ_FIRST ( & evcon -> requests ) ) != NULL ) {\n TAILQ_REMOVE ( & evcon -> requests , req , next ) ;\n evhttp_request_free ( req ) ;\n }\n if ( evcon -> http_server != NULL ) {\n struct evhttp * http = evcon -> http_server ;\n TAILQ_REMOVE ( & http -> connections , evcon , next ) ;\n }\n if ( event_initialized ( & evcon -> close_ev ) ) event_del ( & evcon -> close_ev ) ;\n if ( event_initialized ( & evcon -> ev ) ) event_del ( & evcon -> ev ) ;\n if ( evcon -> fd != - 1 ) EVUTIL_CLOSESOCKET ( evcon -> fd ) ;\n if ( evcon -> bind_address != NULL ) free ( evcon -> bind_address ) ;\n if ( evcon -> address != NULL ) free ( evcon -> address ) ;\n if ( evcon -> input_buffer != NULL ) evbuffer_free ( evcon -> input_buffer ) ;\n if ( evcon -> output_buffer != NULL ) evbuffer_free ( evcon -> output_buffer ) ;\n free ( evcon ) ;\n }",
        "output": "1",
        "idx": 4439
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t u_scanf_simple_percent_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {\n * argConverted = 0 ;\n if ( u_fgetc ( input ) != 0x0025 ) {\n * argConverted = - 1 ;\n }\n return 1 ;\n }",
        "output": "1",
        "idx": 3705
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void window_reparent ( WINDOW_REC * win , MAIN_WINDOW_REC * mainwin ) {\n MAIN_WINDOW_REC * old_mainwin ;\n old_mainwin = WINDOW_MAIN ( win ) ;\n if ( old_mainwin != mainwin ) {\n gui_window_set_unsticky ( win ) ;\n if ( old_mainwin -> active == win ) {\n mainwindow_change_active ( old_mainwin , win ) ;\n if ( active_mainwin == NULL ) {\n active_mainwin = mainwin ;\n window_set_active ( mainwin -> active ) ;\n }\n }\n gui_window_reparent ( win , mainwin ) ;\n window_set_active ( win ) ;\n }\n }",
        "output": "0",
        "idx": 2554
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static UConverter * _LMBCSSafeClone ( const UConverter * cnv , void * stackBuffer , int32_t * pBufferSize , UErrorCode * status ) {\n LMBCSClone * newLMBCS ;\n UConverterDataLMBCS * extraInfo ;\n int32_t i ;\n if ( * pBufferSize <= 0 ) {\n * pBufferSize = ( int32_t ) sizeof ( LMBCSClone ) ;\n return NULL ;\n }\n extraInfo = ( UConverterDataLMBCS * ) cnv -> extraInfo ;\n newLMBCS = ( LMBCSClone * ) stackBuffer ;\n uprv_memcpy ( & newLMBCS -> lmbcs , extraInfo , sizeof ( UConverterDataLMBCS ) ) ;\n for ( i = 0 ;\n i <= ULMBCS_GRP_LAST ;\n ++ i ) {\n if ( extraInfo -> OptGrpConverter [ i ] != NULL ) {\n ucnv_incrementRefCount ( extraInfo -> OptGrpConverter [ i ] ) ;\n }\n }\n newLMBCS -> cnv . extraInfo = & newLMBCS -> lmbcs ;\n newLMBCS -> cnv . isExtraLocal = TRUE ;\n return & newLMBCS -> cnv ;\n }",
        "output": "1",
        "idx": 1572
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void security_init ( void ) {\n uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard ( _dl_random ) ;\n # ifdef THREAD_SET_STACK_GUARD THREAD_SET_STACK_GUARD ( stack_chk_guard ) ;\n # else __stack_chk_guard = stack_chk_guard ;\n # endif if ( GLRO ( dl_pointer_guard ) ) {\n uintptr_t pointer_chk_guard = _dl_setup_pointer_guard ( _dl_random , stack_chk_guard ) ;\n # ifdef THREAD_SET_POINTER_GUARD THREAD_SET_POINTER_GUARD ( pointer_chk_guard ) ;\n # endif __pointer_chk_guard_local = pointer_chk_guard ;\n }\n _dl_random = NULL ;\n }",
        "output": "1",
        "idx": 2568
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * pathToFullPath ( const char * path , const char * source ) {\n int32_t length ;\n int32_t newLength ;\n char * fullPath ;\n int32_t n ;\n length = ( uint32_t ) ( uprv_strlen ( path ) + 1 ) ;\n newLength = ( length + 1 + ( int32_t ) uprv_strlen ( source ) ) ;\n fullPath = uprv_malloc ( newLength ) ;\n if ( source != NULL ) {\n uprv_strcpy ( fullPath , source ) ;\n uprv_strcat ( fullPath , U_FILE_SEP_STRING ) ;\n }\n else {\n fullPath [ 0 ] = 0 ;\n }\n n = ( int32_t ) uprv_strlen ( fullPath ) ;\n fullPath [ n ] = 0 ;\n uprv_strcat ( fullPath , path ) ;\n # if ( U_FILE_ALT_SEP_CHAR != U_TREE_ENTRY_SEP_CHAR ) # if ( U_FILE_ALT_SEP_CHAR != U_FILE_SEP_CHAR ) for ( ;\n fullPath [ n ] ;\n n ++ ) {\n if ( fullPath [ n ] == U_FILE_ALT_SEP_CHAR ) {\n fullPath [ n ] = U_FILE_SEP_CHAR ;\n }\n }\n # endif # endif # if ( U_FILE_SEP_CHAR != U_TREE_ENTRY_SEP_CHAR ) for ( ;\n fullPath [ n ] ;\n n ++ ) {\n if ( fullPath [ n ] == U_TREE_ENTRY_SEP_CHAR ) {\n fullPath [ n ] = U_FILE_SEP_CHAR ;\n }\n }\n # endif return fullPath ;\n }",
        "output": "1",
        "idx": 3753
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( PrefsFunctionalTest , TestDownloadDirPref ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n base : : ScopedAllowBlockingForTesting allow_blocking ;\n base : : ScopedTempDir new_download_dir ;\n ASSERT_TRUE ( new_download_dir . CreateUniqueTempDir ( ) ) ;\n base : : FilePath downloaded_pkg = new_download_dir . GetPath ( ) . AppendASCII ( \"a_zip_file.zip\" ) ;\n browser ( ) -> profile ( ) -> GetPrefs ( ) -> SetFilePath ( prefs : : kDownloadDefaultDirectory , new_download_dir . GetPath ( ) ) ;\n std : : unique_ptr < content : : DownloadTestObserver > downloads_observer ( CreateWaiter ( browser ( ) , 1 ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( \"/downloads/a_zip_file.zip\" ) ) ;\n downloads_observer -> WaitForFinished ( ) ;\n EXPECT_TRUE ( base : : PathExists ( downloaded_pkg ) ) ;\n }",
        "output": "1",
        "idx": 359
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int yop_copy_previous_block ( YopDecContext * s , int copy_tag ) {\n uint8_t * bufptr ;\n bufptr = s -> dstptr + motion_vector [ copy_tag ] [ 0 ] + s -> frame . linesize [ 0 ] * motion_vector [ copy_tag ] [ 1 ] ;\n if ( bufptr < s -> dstbuf ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"YOP: cannot decode, file probably corrupt\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n s -> dstptr [ 0 ] = bufptr [ 0 ] ;\n s -> dstptr [ 1 ] = bufptr [ 1 ] ;\n s -> dstptr [ s -> frame . linesize [ 0 ] ] = bufptr [ s -> frame . linesize [ 0 ] ] ;\n s -> dstptr [ s -> frame . linesize [ 0 ] + 1 ] = bufptr [ s -> frame . linesize [ 0 ] + 1 ] ;\n return 0 ;\n }",
        "output": "1",
        "idx": 2511
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int kvm_arch_remove_sw_breakpoint ( CPUState * cs , struct kvm_sw_breakpoint * bp ) {\n uint8_t int3 ;\n if ( cpu_memory_rw_debug ( cs , bp -> pc , & int3 , 1 , 0 ) || int3 != 0xcc || cpu_memory_rw_debug ( cs , bp -> pc , ( uint8_t * ) & bp -> saved_insn , 1 , 1 ) ) {\n return - EINVAL ;\n }\n return 0 ;\n }",
        "output": "0",
        "idx": 4332
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int proc_alloc_streams ( struct usb_dev_state * ps , void __user * arg ) {\n unsigned num_streams , num_eps ;\n struct usb_host_endpoint * * eps ;\n struct usb_interface * intf ;\n int r ;\n r = parse_usbdevfs_streams ( ps , arg , & num_streams , & num_eps , & eps , & intf ) ;\n if ( r ) return r ;\n destroy_async_on_interface ( ps , intf -> altsetting [ 0 ] . desc . bInterfaceNumber ) ;\n r = usb_alloc_streams ( intf , eps , num_eps , num_streams , GFP_KERNEL ) ;\n kfree ( eps ) ;\n return r ;\n }",
        "output": "0",
        "idx": 3951
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "proto_item * ptvcursor_add ( ptvcursor_t * ptvc , int hfindex , gint length , const guint encoding ) {\n field_info * new_fi ;\n header_field_info * hfinfo ;\n gint item_length ;\n int offset ;\n offset = ptvc -> offset ;\n PROTO_REGISTRAR_GET_NTH ( hfindex , hfinfo ) ;\n get_hfi_length ( hfinfo , ptvc -> tvb , offset , & length , & item_length ) ;\n test_length ( hfinfo , ptvc -> tvb , offset , item_length ) ;\n ptvc -> offset += get_full_length ( hfinfo , ptvc -> tvb , offset , length , item_length , encoding ) ;\n CHECK_FOR_NULL_TREE ( ptvc -> tree ) ;\n TRY_TO_FAKE_THIS_ITEM ( ptvc -> tree , hfindex , hfinfo ) ;\n new_fi = new_field_info ( ptvc -> tree , hfinfo , ptvc -> tvb , offset , item_length ) ;\n return proto_tree_new_item ( new_fi , ptvc -> tree , ptvc -> tvb , offset , length , encoding ) ;\n }",
        "output": "0",
        "idx": 1853
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "proto_item * proto_tree_add_uint_format_value ( proto_tree * tree , int hfindex , tvbuff_t * tvb , gint start , gint length , guint32 value , const char * format , ... ) {\n proto_item * pi ;\n va_list ap ;\n pi = proto_tree_add_uint ( tree , hfindex , tvb , start , length , value ) ;\n if ( pi != tree ) {\n va_start ( ap , format ) ;\n proto_tree_set_representation_value ( pi , format , ap ) ;\n va_end ( ap ) ;\n }\n return pi ;\n }",
        "output": "0",
        "idx": 1530
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xsltDocumentPtr xsltNewStyleDocument ( xsltStylesheetPtr style , xmlDocPtr doc ) {\n xsltDocumentPtr cur ;\n cur = ( xsltDocumentPtr ) xmlMalloc ( sizeof ( xsltDocument ) ) ;\n if ( cur == NULL ) {\n xsltTransformError ( NULL , style , ( xmlNodePtr ) doc , \"xsltNewStyleDocument : malloc failed\\n\" ) ;\n return ( NULL ) ;\n }\n memset ( cur , 0 , sizeof ( xsltDocument ) ) ;\n cur -> doc = doc ;\n if ( style != NULL ) {\n cur -> next = style -> docList ;\n style -> docList = cur ;\n }\n return ( cur ) ;\n }",
        "output": "0",
        "idx": 1182
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;\n __exctype_l ( isalpha_l ) ;\n __exctype_l ( iscntrl_l ) ;\n __exctype_l ( isdigit_l ) ;\n __exctype_l ( islower_l ) ;\n __exctype_l ( isgraph_l ) ;\n __exctype_l ( isprint_l )",
        "output": "1",
        "idx": 2912
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void EVP_EncodeUpdate ( EVP_ENCODE_CTX * ctx , unsigned char * out , int * outl , const unsigned char * in , int inl ) {\n int i , j ;\n unsigned int total = 0 ;\n * outl = 0 ;\n if ( inl <= 0 ) return ;\n OPENSSL_assert ( ctx -> length <= ( int ) sizeof ( ctx -> enc_data ) ) ;\n if ( ( ctx -> num + inl ) < ctx -> length ) {\n memcpy ( & ( ctx -> enc_data [ ctx -> num ] ) , in , inl ) ;\n ctx -> num += inl ;\n return ;\n }\n if ( ctx -> num != 0 ) {\n i = ctx -> length - ctx -> num ;\n memcpy ( & ( ctx -> enc_data [ ctx -> num ] ) , in , i ) ;\n in += i ;\n inl -= i ;\n j = EVP_EncodeBlock ( out , ctx -> enc_data , ctx -> length ) ;\n ctx -> num = 0 ;\n out += j ;\n * ( out ++ ) = '\\n' ;\n * out = '\\0' ;\n total = j + 1 ;\n }\n while ( inl >= ctx -> length ) {\n j = EVP_EncodeBlock ( out , in , ctx -> length ) ;\n in += ctx -> length ;\n inl -= ctx -> length ;\n out += j ;\n * ( out ++ ) = '\\n' ;\n * out = '\\0' ;\n total += j + 1 ;\n }\n if ( inl != 0 ) memcpy ( & ( ctx -> enc_data [ 0 ] ) , in , inl ) ;\n ctx -> num = inl ;\n * outl = total ;\n }",
        "output": "1",
        "idx": 4211
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void main_get_appheader ( xd3_stream * stream , main_file * ifile , main_file * output , main_file * sfile ) {\n uint8_t * apphead ;\n usize_t appheadsz ;\n int ret ;\n if ( ! option_use_appheader ) {\n return ;\n }\n ret = xd3_get_appheader ( stream , & apphead , & appheadsz ) ;\n if ( ret != 0 ) {\n return ;\n }\n if ( appheadsz > 0 ) {\n char * start = ( char * ) apphead ;\n char * slash ;\n int place = 0 ;\n char * parsed [ 4 ] ;\n memset ( parsed , 0 , sizeof ( parsed ) ) ;\n while ( ( slash = strchr ( start , '/' ) ) != NULL ) {\n * slash = 0 ;\n parsed [ place ++ ] = start ;\n start = slash + 1 ;\n }\n parsed [ place ++ ] = start ;\n if ( place == 2 || place == 4 ) {\n main_get_appheader_params ( output , parsed , 1 , \"output\" , ifile ) ;\n }\n if ( place == 4 ) {\n main_get_appheader_params ( sfile , parsed + 2 , 0 , \"source\" , ifile ) ;\n }\n }\n option_use_appheader = 0 ;\n return ;\n }",
        "output": "1",
        "idx": 375
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tm2_read_deltas ( TM2Context * ctx , int stream_id ) {\n int d , mb ;\n int i , v ;\n d = get_bits ( & ctx -> gb , 9 ) ;\n mb = get_bits ( & ctx -> gb , 5 ) ;\n if ( ( d < 1 ) || ( d > TM2_DELTAS ) || ( mb < 1 ) || ( mb > 32 ) ) {\n av_log ( ctx -> avctx , AV_LOG_ERROR , \"Incorrect delta table: %i deltas x %i bits\\n\" , d , mb ) ;\n return AVERROR_INVALIDDATA ;\n }\n for ( i = 0 ;\n i < d ;\n i ++ ) {\n v = get_bits_long ( & ctx -> gb , mb ) ;\n if ( v & ( 1 << ( mb - 1 ) ) ) ctx -> deltas [ stream_id ] [ i ] = v - ( 1 << mb ) ;\n else ctx -> deltas [ stream_id ] [ i ] = v ;\n }\n for ( ;\n i < TM2_DELTAS ;\n i ++ ) ctx -> deltas [ stream_id ] [ i ] = 0 ;\n return 0 ;\n }",
        "output": "0",
        "idx": 4435
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vp9_get_mvpred_av_var ( const MACROBLOCK * x , const MV * best_mv , const MV * center_mv , const uint8_t * second_pred , const vp9_variance_fn_ptr_t * vfp , int use_mvcost ) {\n const MACROBLOCKD * const xd = & x -> e_mbd ;\n const struct buf_2d * const what = & x -> plane [ 0 ] . src ;\n const struct buf_2d * const in_what = & xd -> plane [ 0 ] . pre [ 0 ] ;\n const MV mv = {\n best_mv -> row * 8 , best_mv -> col * 8 }\n ;\n unsigned int unused ;\n return vfp -> svaf ( get_buf_from_mv ( in_what , best_mv ) , in_what -> stride , 0 , 0 , what -> buf , what -> stride , & unused , second_pred ) + ( use_mvcost ? mv_err_cost ( & mv , center_mv , x -> nmvjointcost , x -> mvcost , x -> errorperbit ) : 0 ) ;\n }",
        "output": "0",
        "idx": 4063
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void tb_jmp_remove ( TranslationBlock * tb , int n ) {\n TranslationBlock * tb1 , * * ptb ;\n unsigned int n1 ;\n ptb = & tb -> jmp_next [ n ] ;\n tb1 = * ptb ;\n if ( tb1 ) {\n for ( ;\n ;\n ) {\n tb1 = * ptb ;\n n1 = ( uintptr_t ) tb1 & 3 ;\n tb1 = ( TranslationBlock * ) ( ( uintptr_t ) tb1 & ~ 3 ) ;\n if ( n1 == n && tb1 == tb ) {\n break ;\n }\n if ( n1 == 2 ) {\n ptb = & tb1 -> jmp_first ;\n }\n else {\n ptb = & tb1 -> jmp_next [ n1 ] ;\n }\n }\n * ptb = tb -> jmp_next [ n ] ;\n tb -> jmp_next [ n ] = NULL ;\n }\n }",
        "output": "0",
        "idx": 4191
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char * lookup_gname ( struct cpio * cpio , gid_t gid ) {\n return ( lookup_name ( cpio , & cpio -> gname_cache , & lookup_gname_helper , ( id_t ) gid ) ) ;\n }",
        "output": "0",
        "idx": 1997
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void e1000e_core_pci_uninit ( E1000ECore * core ) {\n int i ;\n timer_del ( core -> autoneg_timer ) ;\n timer_free ( core -> autoneg_timer ) ;\n e1000e_intrmgr_pci_unint ( core ) ;\n qemu_del_vm_change_state_handler ( core -> vmstate ) ;\n for ( i = 0 ;\n i < E1000E_NUM_QUEUES ;\n i ++ ) {\n net_tx_pkt_reset ( core -> tx [ i ] . tx_pkt ) ;\n net_tx_pkt_uninit ( core -> tx [ i ] . tx_pkt ) ;\n }\n net_rx_pkt_uninit ( core -> rx_pkt ) ;\n }",
        "output": "0",
        "idx": 166
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Asn1Generic * DecodeAsn1DerOctetString ( const unsigned char * buffer , uint32_t max_size , uint8_t depth , uint32_t * errcode ) {\n const unsigned char * d_ptr = buffer ;\n uint32_t length , numbytes ;\n Asn1Generic * a ;\n unsigned char c ;\n d_ptr ++ ;\n c = d_ptr [ 0 ] ;\n if ( ( c & ( 1 << 7 ) ) >> 7 == 0 ) {\n length = c ;\n d_ptr ++ ;\n }\n else {\n numbytes = c & 0x7f ;\n d_ptr ++ ;\n if ( DecodeAsn1BuildValue ( & d_ptr , & length , numbytes , errcode ) == - 1 ) {\n return NULL ;\n }\n }\n if ( length > max_size ) return NULL ;\n a = Asn1GenericNew ( ) ;\n if ( a == NULL ) return NULL ;\n a -> type = ASN1_OCTETSTRING ;\n a -> strlen = length ;\n a -> str = SCMalloc ( length + 1 ) ;\n if ( a -> str == NULL ) {\n SCFree ( a ) ;\n return NULL ;\n }\n memcpy ( a -> str , ( const char * ) d_ptr , length ) ;\n a -> str [ length ] = 0 ;\n d_ptr += length ;\n a -> length = ( d_ptr - buffer ) ;\n return a ;\n }",
        "output": "1",
        "idx": 3969
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_DisengageRequest ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_DisengageRequest , DisengageRequest_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 4161
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void initial_reordering_non_indic_cluster ( const hb_ot_shape_plan_t * plan HB_UNUSED , hb_face_t * face HB_UNUSED , hb_buffer_t * buffer HB_UNUSED , unsigned int start HB_UNUSED , unsigned int end HB_UNUSED ) {\n }",
        "output": "1",
        "idx": 2805
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void setup_plane_dequants ( VP9_COMMON * cm , MACROBLOCKD * xd , int q_index ) {\n int i ;\n xd -> plane [ 0 ] . dequant = cm -> y_dequant [ q_index ] ;\n for ( i = 1 ;\n i < MAX_MB_PLANE ;\n i ++ ) xd -> plane [ i ] . dequant = cm -> uv_dequant [ q_index ] ;\n }",
        "output": "0",
        "idx": 2614
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_QseriesOptions ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_QseriesOptions , QseriesOptions_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 534
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void SetPixelChannels ( Image * image , const size_t number_channels ) {\n image -> number_channels = number_channels ;\n }",
        "output": "0",
        "idx": 2778
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _SCSUOpen ( UConverter * cnv , UConverterLoadArgs * pArgs , UErrorCode * pErrorCode ) {\n const char * locale = pArgs -> locale ;\n if ( pArgs -> onlyTestIsLoadable ) {\n return ;\n }\n cnv -> extraInfo = uprv_malloc ( sizeof ( SCSUData ) ) ;\n if ( cnv -> extraInfo != NULL ) {\n if ( locale != NULL && locale [ 0 ] == 'j' && locale [ 1 ] == 'a' && ( locale [ 2 ] == 0 || locale [ 2 ] == '_' ) ) {\n ( ( SCSUData * ) cnv -> extraInfo ) -> locale = l_ja ;\n }\n else {\n ( ( SCSUData * ) cnv -> extraInfo ) -> locale = lGeneric ;\n }\n _SCSUReset ( cnv , UCNV_RESET_BOTH ) ;\n }\n else {\n * pErrorCode = U_MEMORY_ALLOCATION_ERROR ;\n }\n cnv -> subUChars [ 0 ] = 0xfffd ;\n cnv -> subCharLen = - 1 ;\n }",
        "output": "1",
        "idx": 4096
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "my_bool include_table ( const uchar * hash_key , size_t len ) {\n return ! my_hash_search ( & ignore_table , hash_key , len ) ;\n }",
        "output": "0",
        "idx": 1108
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cpu_halt_signal ( void * opaque , int irq , int level ) {\n if ( level && cpu_single_env ) {\n cpu_interrupt ( CPU ( sparc_env_get_cpu ( cpu_single_env ) ) , CPU_INTERRUPT_HALT ) ;\n }\n }",
        "output": "1",
        "idx": 5
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_tile_limits ( VP9_COMP * cpi ) {\n VP9_COMMON * const cm = & cpi -> common ;\n int min_log2_tile_cols , max_log2_tile_cols ;\n vp9_get_tile_n_bits ( cm -> mi_cols , & min_log2_tile_cols , & max_log2_tile_cols ) ;\n cm -> log2_tile_cols = clamp ( cpi -> oxcf . tile_columns , min_log2_tile_cols , max_log2_tile_cols ) ;\n cm -> log2_tile_rows = cpi -> oxcf . tile_rows ;\n }",
        "output": "0",
        "idx": 2209
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void check_reset_2nd_coeffs ( MACROBLOCKD * x , int type , ENTROPY_CONTEXT * a , ENTROPY_CONTEXT * l ) {\n int sum = 0 ;\n int i ;\n BLOCKD * bd = & x -> block [ 24 ] ;\n if ( bd -> dequant [ 0 ] >= 35 && bd -> dequant [ 1 ] >= 35 ) return ;\n for ( i = 0 ;\n i < ( * bd -> eob ) ;\n i ++ ) {\n int coef = bd -> dqcoeff [ vp8_default_zig_zag1d [ i ] ] ;\n sum += ( coef >= 0 ) ? coef : - coef ;\n if ( sum >= 35 ) return ;\n }\n if ( sum < 35 ) {\n for ( i = 0 ;\n i < ( * bd -> eob ) ;\n i ++ ) {\n int rc = vp8_default_zig_zag1d [ i ] ;\n bd -> qcoeff [ rc ] = 0 ;\n bd -> dqcoeff [ rc ] = 0 ;\n }\n * bd -> eob = 0 ;\n * a = * l = ( * bd -> eob != ! type ) ;\n }\n }",
        "output": "0",
        "idx": 3661
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int proto_registrar_get_parent ( const int n ) {\n header_field_info * hfinfo ;\n PROTO_REGISTRAR_GET_NTH ( n , hfinfo ) ;\n return hfinfo -> parent ;\n }",
        "output": "0",
        "idx": 1164
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _UTF16LEReset ( UConverter * cnv , UConverterResetChoice choice ) {\n if ( choice <= UCNV_RESET_TO_UNICODE ) {\n if ( UCNV_GET_VERSION ( cnv ) == 0 ) {\n cnv -> mode = 8 ;\n }\n else {\n cnv -> mode = 0 ;\n }\n }\n if ( choice != UCNV_RESET_TO_UNICODE && UCNV_GET_VERSION ( cnv ) == 1 ) {\n cnv -> fromUnicodeStatus = UCNV_NEED_TO_WRITE_BOM ;\n }\n }",
        "output": "1",
        "idx": 2599
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qemu_mutex_unlock_iothread ( void ) {\n qemu_mutex_unlock ( & qemu_global_mutex ) ;\n }",
        "output": "0",
        "idx": 163
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , BackgroundThenForeground_Http ) {\n StartHttpServer ( ) ;\n base : : TimeDelta upper_bound = NavigateInBackgroundAndCloseInForegroundWithTiming ( http_test_server_ -> GetURL ( \"/simple.html\" ) ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;\n int32_t bucket_min = histogram_tester_ . GetAllSamples ( internal : : kHttpEngagementHistogram ) [ 0 ] . min ;\n EXPECT_GE ( upper_bound . InMilliseconds ( ) , bucket_min ) ;\n EXPECT_LT ( 0 , bucket_min ) ;\n FakeUserMetricsUpload ( ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementSessionPercentage , 1 ) ;\n int32_t ratio_bucket = histogram_tester_ . GetAllSamples ( internal : : kHttpsEngagementSessionPercentage ) [ 0 ] . min ;\n EXPECT_EQ ( 0 , ratio_bucket ) ;\n }",
        "output": "0",
        "idx": 3946
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_idct8x8_64_add_c ( const int16_t * input , uint8_t * dest , int stride ) {\n int16_t out [ 8 * 8 ] ;\n int16_t * outptr = out ;\n int i , j ;\n int16_t temp_in [ 8 ] , temp_out [ 8 ] ;\n for ( i = 0 ;\n i < 8 ;\n ++ i ) {\n idct8 ( input , outptr ) ;\n input += 8 ;\n outptr += 8 ;\n }\n for ( i = 0 ;\n i < 8 ;\n ++ i ) {\n for ( j = 0 ;\n j < 8 ;\n ++ j ) temp_in [ j ] = out [ j * 8 + i ] ;\n idct8 ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 8 ;\n ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 5 ) + dest [ j * stride + i ] ) ;\n }\n }",
        "output": "1",
        "idx": 4140
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void log_invalid_scale_factor ( SvcContext * svc_ctx , const char * value ) {\n svc_log ( svc_ctx , SVC_LOG_ERROR , \"svc scale-factors: invalid value %s\\n\" , value ) ;\n }",
        "output": "1",
        "idx": 1088
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * _get_user_from_associd ( mysql_conn_t * mysql_conn , char * cluster , uint32_t associd ) {\n char * user = NULL ;\n char * query = NULL ;\n MYSQL_RES * result = NULL ;\n MYSQL_ROW row ;\n query = xstrdup_printf ( \"select user from \\\"%s_%s\\\" where id_assoc=%u\" , cluster , assoc_table , associd ) ;\n debug4 ( \"%d(%s:%d) query\\n%s\" , mysql_conn -> conn , THIS_FILE , __LINE__ , query ) ;\n if ( ! ( result = mysql_db_query_ret ( mysql_conn , query , 0 ) ) ) {\n xfree ( query ) ;\n return NULL ;\n }\n xfree ( query ) ;\n if ( ( row = mysql_fetch_row ( result ) ) && row [ 0 ] [ 0 ] ) user = xstrdup ( row [ 0 ] ) ;\n mysql_free_result ( result ) ;\n return user ;\n }",
        "output": "0",
        "idx": 1632
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "file_transfer_t * imcb_file_send_start ( struct im_connection * ic , char * handle , char * file_name , size_t file_size ) {\n bee_t * bee = ic -> bee ;\n bee_user_t * bu = bee_user_by_handle ( bee , ic , handle ) ;\n if ( bee -> ui -> ft_in_start ) {\n return bee -> ui -> ft_in_start ( bee , bu , file_name , file_size ) ;\n }\n else {\n return NULL ;\n }\n }",
        "output": "1",
        "idx": 3908
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char * notify_plural ( int count ) {\n if ( count == 1 ) return \"notification\" ;\n return \"notifies\" ;\n }",
        "output": "0",
        "idx": 2795
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CharDriverState * qdev_init_chardev ( DeviceState * dev ) {\n static int next_serial ;\n static int next_virtconsole ;\n if ( strncmp ( dev -> info -> name , \"virtio\" , 6 ) == 0 ) {\n return virtcon_hds [ next_virtconsole ++ ] ;\n }\n else {\n return serial_hds [ next_serial ++ ] ;\n }\n }",
        "output": "1",
        "idx": 4465
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_P ( BrowserCloseManagerWithDownloadsBrowserTest , DISABLED_TestBeforeUnloadAndDownloads ) {\n SetDownloadPathForProfile ( browser ( ) -> profile ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( CreateStalledDownload ( browser ( ) ) ) ;\n ASSERT_NO_FATAL_FAILURE ( ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( \"/beforeunload.html\" ) ) ) ;\n PrepareForDialog ( browser ( ) ) ;\n content : : WindowedNotificationObserver cancel_observer ( chrome : : NOTIFICATION_BROWSER_CLOSE_CANCELLED , content : : NotificationService : : AllSources ( ) ) ;\n TestBrowserCloseManager : : AttemptClose ( TestBrowserCloseManager : : USER_CHOICE_USER_CANCELS_CLOSE ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n cancel_observer . Wait ( ) ;\n EXPECT_FALSE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n RepeatedNotificationObserver close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , 1 ) ;\n TestBrowserCloseManager : : AttemptClose ( TestBrowserCloseManager : : USER_CHOICE_USER_ALLOWS_CLOSE ) ;\n ASSERT_NO_FATAL_FAILURE ( AcceptClose ( ) ) ;\n close_observer . Wait ( ) ;\n EXPECT_TRUE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_TRUE ( BrowserList : : GetInstance ( ) -> empty ( ) ) ;\n }",
        "output": "1",
        "idx": 1876
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int libopus_decode ( AVCodecContext * avc , void * data , int * got_frame_ptr , AVPacket * pkt ) {\n struct libopus_context * opus = avc -> priv_data ;\n AVFrame * frame = data ;\n int ret , nb_samples ;\n frame -> nb_samples = MAX_FRAME_SIZE ;\n ret = ff_get_buffer ( avc , frame ) ;\n if ( ret < 0 ) {\n av_log ( avc , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( avc -> sample_fmt == AV_SAMPLE_FMT_S16 ) nb_samples = opus_multistream_decode ( opus -> dec , pkt -> data , pkt -> size , ( opus_int16 * ) frame -> data [ 0 ] , frame -> nb_samples , 0 ) ;\n else nb_samples = opus_multistream_decode_float ( opus -> dec , pkt -> data , pkt -> size , ( float * ) frame -> data [ 0 ] , frame -> nb_samples , 0 ) ;\n if ( nb_samples < 0 ) {\n av_log ( avc , AV_LOG_ERROR , \"Decoding error: %s\\n\" , opus_strerror ( nb_samples ) ) ;\n return ff_opus_error_to_averror ( nb_samples ) ;\n }\n frame -> nb_samples = nb_samples ;\n * got_frame_ptr = 1 ;\n return pkt -> size ;\n }",
        "output": "1",
        "idx": 233
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void report_type_length_mismatch ( proto_tree * tree , const gchar * descr , int length , gboolean is_error ) {\n if ( is_error ) {\n expert_add_info_format ( NULL , tree , & ei_type_length_mismatch_error , \"Trying to fetch %s with length %d\" , descr , length ) ;\n }\n else {\n expert_add_info_format ( NULL , tree , & ei_type_length_mismatch_warn , \"Trying to fetch %s with length %d\" , descr , length ) ;\n }\n if ( is_error ) {\n THROW ( ReportedBoundsError ) ;\n }\n }",
        "output": "0",
        "idx": 1511
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void decompose_current_character ( const hb_ot_shape_normalize_context_t * c , bool shortest ) {\n hb_buffer_t * const buffer = c -> buffer ;\n hb_codepoint_t glyph ;\n if ( shortest && c -> font -> get_glyph ( buffer -> cur ( ) . codepoint , 0 , & glyph ) ) next_char ( buffer , glyph ) ;\n else if ( decompose ( c , shortest , buffer -> cur ( ) . codepoint ) ) skip_char ( buffer ) ;\n else if ( ! shortest && c -> font -> get_glyph ( buffer -> cur ( ) . codepoint , 0 , & glyph ) ) next_char ( buffer , glyph ) ;\n else if ( decompose_compatibility ( c , buffer -> cur ( ) . codepoint ) ) skip_char ( buffer ) ;\n else next_char ( buffer , glyph ) ;\n }",
        "output": "1",
        "idx": 443
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemuMonitorJSONGetStatus ( qemuMonitorPtr mon , bool * running , virDomainPausedReason * reason ) {\n int ret ;\n const char * status ;\n virJSONValuePtr cmd ;\n virJSONValuePtr reply = NULL ;\n virJSONValuePtr data ;\n if ( reason ) * reason = VIR_DOMAIN_PAUSED_UNKNOWN ;\n if ( ! ( cmd = qemuMonitorJSONMakeCommand ( \"query-status\" , NULL ) ) ) return - 1 ;\n ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;\n if ( ret == 0 ) ret = qemuMonitorJSONCheckError ( cmd , reply ) ;\n if ( ret < 0 ) goto cleanup ;\n ret = - 1 ;\n if ( ! ( data = virJSONValueObjectGet ( reply , \"return\" ) ) ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"query-status reply was missing return data\" ) ) ;\n goto cleanup ;\n }\n if ( virJSONValueObjectGetBoolean ( data , \"running\" , running ) < 0 ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"query-status reply was missing running state\" ) ) ;\n goto cleanup ;\n }\n if ( ( status = virJSONValueObjectGetString ( data , \"status\" ) ) ) {\n if ( ! * running && reason ) * reason = qemuMonitorVMStatusToPausedReason ( status ) ;\n }\n else if ( ! * running ) {\n VIR_DEBUG ( \"query-status reply was missing status details\" ) ;\n }\n ret = 0 ;\n cleanup : virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }",
        "output": "0",
        "idx": 2807
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gint nlm_msg_res_unmatched_equal ( gconstpointer k1 , gconstpointer k2 ) {\n const nlm_msg_res_unmatched_data * umd1 = ( const nlm_msg_res_unmatched_data * ) k1 ;\n const nlm_msg_res_unmatched_data * umd2 = ( const nlm_msg_res_unmatched_data * ) k2 ;\n if ( umd1 -> cookie_len != umd2 -> cookie_len ) {\n return 0 ;\n }\n return ( memcmp ( umd1 -> cookie , umd2 -> cookie , umd1 -> cookie_len ) == 0 ) ;\n }",
        "output": "0",
        "idx": 1188
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_H222LogicalChannelParameters ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_H222LogicalChannelParameters , H222LogicalChannelParameters_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 195
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pdf_run_gs_OPM ( fz_context * ctx , pdf_processor * proc , int i ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n pdf_gstate * gstate = pdf_flush_text ( ctx , pr ) ;\n gstate -> stroke . color_params . opm = i ;\n gstate -> fill . color_params . opm = i ;\n }",
        "output": "0",
        "idx": 3844
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_lpf_vertical_16_dual_sse2 ( unsigned char * s , int p , const uint8_t * blimit , const uint8_t * limit , const uint8_t * thresh ) {\n DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , t_dst , 256 ) ;\n transpose8x16 ( s - 8 , s - 8 + 8 * p , p , t_dst , 16 ) ;\n transpose8x16 ( s , s + 8 * p , p , t_dst + 8 * 16 , 16 ) ;\n mb_lpf_horizontal_edge_w_sse2_16 ( t_dst + 8 * 16 , 16 , blimit , limit , thresh ) ;\n transpose8x16 ( t_dst , t_dst + 8 * 16 , 16 , s - 8 , p ) ;\n transpose8x16 ( t_dst + 8 , t_dst + 8 + 8 * 16 , 16 , s - 8 + 8 * p , p ) ;\n }",
        "output": "1",
        "idx": 554
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_BandRejectReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 625 \"./asn1/h225/h225.cnf\" gint32 value ;\n h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_BandRejectReason , BandRejectReason_choice , & value ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> reason = value ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 3648
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void record_recent_object ( struct object * obj , const struct name_path * path , const char * last , void * data ) {\n sha1_array_append ( & recent_objects , obj -> oid . hash ) ;\n }",
        "output": "1",
        "idx": 2969
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( BluetoothChooserBrowserTest , InvokeDialog_ConnectedBubble ) {\n set_status ( FakeBluetoothChooserController : : BluetoothStatus : : IDLE ) ;\n AddConnectedDevice ( ) ;\n RunDialog ( ) ;\n }",
        "output": "0",
        "idx": 2540
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int x ( struct vcache * avc , int afun , struct vrequest * areq , \\ struct afs_pdata * ain , struct afs_pdata * aout , \\ afs_ucred_t * * acred ) DECL_PIOCTL ( PGetFID ) ;\n DECL_PIOCTL ( PSetAcl ) ;\n DECL_PIOCTL ( PStoreBehind ) ;\n DECL_PIOCTL ( PGCPAGs ) ;\n DECL_PIOCTL ( PGetAcl ) ;\n DECL_PIOCTL ( PNoop ) ;\n DECL_PIOCTL ( PBogus ) ;\n DECL_PIOCTL ( PGetFileCell ) ;\n DECL_PIOCTL ( PGetWSCell ) ;\n DECL_PIOCTL ( PGetUserCell ) ;\n DECL_PIOCTL ( PSetTokens ) ;\n DECL_PIOCTL ( PGetVolumeStatus ) ;\n DECL_PIOCTL ( PSetVolumeStatus ) ;\n DECL_PIOCTL ( PFlush ) ;\n DECL_PIOCTL ( PNewStatMount ) ;\n DECL_PIOCTL ( PGetTokens ) ;\n DECL_PIOCTL ( PUnlog ) ;\n DECL_PIOCTL ( PMariner ) ;\n DECL_PIOCTL ( PCheckServers ) ;\n DECL_PIOCTL ( PCheckVolNames ) ;\n DECL_PIOCTL ( PCheckAuth ) ;\n DECL_PIOCTL ( PFindVolume ) ;\n DECL_PIOCTL ( PViceAccess )",
        "output": "0",
        "idx": 860
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void glyph_position_destroy ( hb_glyph_position_t * g ) {\n free ( g ) ;\n }",
        "output": "1",
        "idx": 3478
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cmsBool _cmsRegisterMultiProcessElementPlugin ( cmsContext id , cmsPluginBase * Data ) {\n return RegisterTypesPlugin ( id , Data , MPEPlugin ) ;\n }",
        "output": "0",
        "idx": 1721
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ff_wmv2_decode_picture_header ( MpegEncContext * s ) {\n Wmv2Context * const w = ( Wmv2Context * ) s ;\n int code ;\n if ( s -> picture_number == 0 ) decode_ext_header ( w ) ;\n s -> pict_type = get_bits1 ( & s -> gb ) + 1 ;\n if ( s -> pict_type == AV_PICTURE_TYPE_I ) {\n code = get_bits ( & s -> gb , 7 ) ;\n av_log ( s -> avctx , AV_LOG_DEBUG , \"I7:%X/\\n\" , code ) ;\n }\n s -> chroma_qscale = s -> qscale = get_bits ( & s -> gb , 5 ) ;\n if ( s -> qscale <= 0 ) return - 1 ;\n return 0 ;\n }",
        "output": "0",
        "idx": 1230
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cirrus_mem_writeb_mode4and5_16bpp ( CirrusVGAState * s , unsigned mode , unsigned offset , uint32_t mem_value ) {\n int x ;\n unsigned val = mem_value ;\n uint8_t * dst ;\n dst = s -> vga . vram_ptr + ( offset &= s -> cirrus_addr_mask ) ;\n for ( x = 0 ;\n x < 8 ;\n x ++ ) {\n if ( val & 0x80 ) {\n * dst = s -> cirrus_shadow_gr1 ;\n * ( dst + 1 ) = s -> vga . gr [ 0x11 ] ;\n }\n else if ( mode == 5 ) {\n * dst = s -> cirrus_shadow_gr0 ;\n * ( dst + 1 ) = s -> vga . gr [ 0x10 ] ;\n }\n val <<= 1 ;\n dst += 2 ;\n }\n memory_region_set_dirty ( & s -> vga . vram , offset , 16 ) ;\n }",
        "output": "1",
        "idx": 3214
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dissect_q931_cause_ie ( tvbuff_t * tvb , int offset , int len , proto_tree * tree , int hf_cause_value , guint8 * cause_value , const value_string * ie_vals ) {\n gboolean have_valid_q931_pi_save = have_valid_q931_pi ;\n have_valid_q931_pi = FALSE ;\n dissect_q931_cause_ie_unsafe ( tvb , offset , len , tree , hf_cause_value , cause_value , ie_vals ) ;\n have_valid_q931_pi = have_valid_q931_pi_save ;\n }",
        "output": "1",
        "idx": 3900
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool check_grant_db_routine ( THD * thd , const char * db , HASH * hash ) {\n Security_context * sctx = thd -> security_ctx ;\n for ( uint idx = 0 ;\n idx < hash -> records ;\n ++ idx ) {\n GRANT_NAME * item = ( GRANT_NAME * ) hash_element ( hash , idx ) ;\n if ( strcmp ( item -> user , sctx -> priv_user ) == 0 && strcmp ( item -> db , db ) == 0 && compare_hostname ( & item -> host , sctx -> host , sctx -> ip ) ) {\n return FALSE ;\n }\n }\n return TRUE ;\n }",
        "output": "0",
        "idx": 1836
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_mpeg_flush ( AVCodecContext * avctx ) {\n int i ;\n MpegEncContext * s = avctx -> priv_data ;\n if ( s == NULL || s -> picture == NULL ) return ;\n for ( i = 0 ;\n i < s -> picture_count ;\n i ++ ) {\n if ( s -> picture [ i ] . f . data [ 0 ] && ( s -> picture [ i ] . f . type == FF_BUFFER_TYPE_INTERNAL || s -> picture [ i ] . f . type == FF_BUFFER_TYPE_USER ) ) free_frame_buffer ( s , & s -> picture [ i ] ) ;\n }\n s -> current_picture_ptr = s -> last_picture_ptr = s -> next_picture_ptr = NULL ;\n s -> mb_x = s -> mb_y = 0 ;\n s -> parse_context . state = - 1 ;\n s -> parse_context . frame_start_found = 0 ;\n s -> parse_context . overread = 0 ;\n s -> parse_context . overread_index = 0 ;\n s -> parse_context . index = 0 ;\n s -> parse_context . last_index = 0 ;\n s -> bitstream_buffer_size = 0 ;\n s -> pp_time = 0 ;\n }",
        "output": "1",
        "idx": 4183
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemuMonitorJSONGetMigrationStatus ( qemuMonitorPtr mon , int * status , unsigned long long * transferred , unsigned long long * remaining , unsigned long long * total ) {\n int ret ;\n virJSONValuePtr cmd = qemuMonitorJSONMakeCommand ( \"query-migrate\" , NULL ) ;\n virJSONValuePtr reply = NULL ;\n * status = 0 ;\n * transferred = * remaining = * total = 0 ;\n if ( ! cmd ) return - 1 ;\n ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;\n if ( ret == 0 ) ret = qemuMonitorJSONCheckError ( cmd , reply ) ;\n if ( ret == 0 && qemuMonitorJSONGetMigrationStatusReply ( reply , status , transferred , remaining , total ) < 0 ) ret = - 1 ;\n virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }",
        "output": "0",
        "idx": 299
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int execstack2_continue ( i_ctx_t * i_ctx_p ) {\n os_ptr op = osp ;\n return do_execstack ( i_ctx_p , op -> value . boolval , op - 1 ) ;\n }",
        "output": "1",
        "idx": 4016
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nonrd_pick_sb_modes ( VP9_COMP * cpi , const TileInfo * const tile , int mi_row , int mi_col , int * rate , int64_t * dist , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx ) {\n VP9_COMMON * const cm = & cpi -> common ;\n MACROBLOCK * const x = & cpi -> mb ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n MB_MODE_INFO * mbmi ;\n set_offsets ( cpi , tile , mi_row , mi_col , bsize ) ;\n mbmi = & xd -> mi [ 0 ] -> mbmi ;\n mbmi -> sb_type = bsize ;\n if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled ) if ( mbmi -> segment_id && x -> in_static_area ) x -> rdmult = vp9_cyclic_refresh_get_rdmult ( cpi -> cyclic_refresh ) ;\n if ( vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) set_mode_info_seg_skip ( x , cm -> tx_mode , rate , dist , bsize ) ;\n else vp9_pick_inter_mode ( cpi , x , tile , mi_row , mi_col , rate , dist , bsize , ctx ) ;\n duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ;\n }",
        "output": "1",
        "idx": 1810
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t offsetTOCPrefixBinarySearch ( const char * s , const char * names , const UDataOffsetTOCEntry * toc , int32_t count ) {\n int32_t start = 0 ;\n int32_t limit = count ;\n int32_t startPrefixLength = 0 ;\n int32_t limitPrefixLength = 0 ;\n if ( count == 0 ) {\n return - 1 ;\n }\n if ( 0 == strcmpAfterPrefix ( s , names + toc [ 0 ] . nameOffset , & startPrefixLength ) ) {\n return 0 ;\n }\n ++ start ;\n -- limit ;\n if ( 0 == strcmpAfterPrefix ( s , names + toc [ limit ] . nameOffset , & limitPrefixLength ) ) {\n return limit ;\n }\n while ( start < limit ) {\n int32_t i = ( start + limit ) / 2 ;\n int32_t prefixLength = MIN ( startPrefixLength , limitPrefixLength ) ;\n int32_t cmp = strcmpAfterPrefix ( s , names + toc [ i ] . nameOffset , & prefixLength ) ;\n if ( cmp < 0 ) {\n limit = i ;\n limitPrefixLength = prefixLength ;\n }\n else if ( cmp == 0 ) {\n return i ;\n }\n else {\n start = i + 1 ;\n startPrefixLength = prefixLength ;\n }\n }\n return - 1 ;\n }",
        "output": "0",
        "idx": 2117
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void openpic_init ( Object * obj ) {\n OpenPICState * opp = OPENPIC ( obj ) ;\n memory_region_init ( & opp -> mem , obj , \"openpic\" , 0x40000 ) ;\n }",
        "output": "0",
        "idx": 2371
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char * irc_ctcp_dcc_filename_without_quotes ( const char * filename ) {\n int length ;\n length = strlen ( filename ) ;\n if ( length > 0 ) {\n if ( ( filename [ 0 ] == '\\\"' ) && ( filename [ length - 1 ] == '\\\"' ) ) return weechat_strndup ( filename + 1 , length - 2 ) ;\n }\n return strdup ( filename ) ;\n }",
        "output": "1",
        "idx": 3828
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int x_catch_free_colors ( Display * dpy , XErrorEvent * err ) {\n if ( err -> request_code == X_FreeColors ) return 0 ;\n return x_error_handler . orighandler ( dpy , err ) ;\n }",
        "output": "1",
        "idx": 7
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void kvm_arch_on_sigbus_vcpu ( CPUState * c , int code , void * addr ) {\n X86CPU * cpu = X86_CPU ( c ) ;\n CPUX86State * env = & cpu -> env ;\n ram_addr_t ram_addr ;\n hwaddr paddr ;\n assert ( code == BUS_MCEERR_AR || code == BUS_MCEERR_AO ) ;\n if ( ( env -> mcg_cap & MCG_SER_P ) && addr ) {\n ram_addr = qemu_ram_addr_from_host ( addr ) ;\n if ( ram_addr != RAM_ADDR_INVALID && kvm_physical_memory_addr_from_host ( c -> kvm_state , addr , & paddr ) ) {\n kvm_hwpoison_page_add ( ram_addr ) ;\n kvm_mce_inject ( cpu , paddr , code ) ;\n return ;\n }\n fprintf ( stderr , \"Hardware memory error for memory used by \" \"QEMU itself instead of guest system!\\n\" ) ;\n }\n if ( code == BUS_MCEERR_AR ) {\n hardware_memory_error ( ) ;\n }\n }",
        "output": "0",
        "idx": 1746
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static time_t xstrpisotime ( const char * s , char * * endptr ) {\n struct tm tm ;\n time_t res = ( time_t ) - 1 ;\n memset ( & tm , 0 , sizeof ( tm ) ) ;\n while ( * s == ' ' || * s == '\\t' ) ++ s ;\n if ( ( tm . tm_year = strtoi_lim ( s , & s , 1583 , 4095 ) ) < 0 || * s ++ != '-' ) {\n goto out ;\n }\n if ( ( tm . tm_mon = strtoi_lim ( s , & s , 1 , 12 ) ) < 0 || * s ++ != '-' ) {\n goto out ;\n }\n if ( ( tm . tm_mday = strtoi_lim ( s , & s , 1 , 31 ) ) < 0 || * s ++ != 'T' ) {\n goto out ;\n }\n if ( ( tm . tm_hour = strtoi_lim ( s , & s , 0 , 23 ) ) < 0 || * s ++ != ':' ) {\n goto out ;\n }\n if ( ( tm . tm_min = strtoi_lim ( s , & s , 0 , 59 ) ) < 0 || * s ++ != ':' ) {\n goto out ;\n }\n if ( ( tm . tm_sec = strtoi_lim ( s , & s , 0 , 60 ) ) < 0 || * s ++ != 'Z' ) {\n goto out ;\n }\n tm . tm_year -= 1900 ;\n tm . tm_mon -- ;\n res = time_from_tm ( & tm ) ;\n out : if ( endptr != NULL ) {\n * endptr = deconst ( s ) ;\n }\n return res ;\n }",
        "output": "0",
        "idx": 1667
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int linux_udev_scan_devices ( struct libusb_context * ctx ) {\n struct udev_enumerate * enumerator ;\n struct udev_list_entry * devices , * entry ;\n struct udev_device * udev_dev ;\n const char * sys_name ;\n int r ;\n assert ( udev_ctx != NULL ) ;\n enumerator = udev_enumerate_new ( udev_ctx ) ;\n if ( NULL == enumerator ) {\n usbi_err ( ctx , \"error creating udev enumerator\" ) ;\n return LIBUSB_ERROR_OTHER ;\n }\n udev_enumerate_add_match_subsystem ( enumerator , \"usb\" ) ;\n udev_enumerate_scan_devices ( enumerator ) ;\n devices = udev_enumerate_get_list_entry ( enumerator ) ;\n udev_list_entry_foreach ( entry , devices ) {\n const char * path = udev_list_entry_get_name ( entry ) ;\n uint8_t busnum = 0 , devaddr = 0 ;\n udev_dev = udev_device_new_from_syspath ( udev_ctx , path ) ;\n r = udev_device_info ( ctx , 0 , udev_dev , & busnum , & devaddr , & sys_name ) ;\n if ( r ) {\n udev_device_unref ( udev_dev ) ;\n continue ;\n }\n linux_enumerate_device ( ctx , busnum , devaddr , sys_name ) ;\n udev_device_unref ( udev_dev ) ;\n }\n udev_enumerate_unref ( enumerator ) ;\n return LIBUSB_SUCCESS ;\n }",
        "output": "1",
        "idx": 1300
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void initial_reordering ( const hb_ot_shape_plan_t * plan , hb_font_t * font , hb_buffer_t * buffer ) {\n update_consonant_positions ( plan , font , buffer ) ;\n insert_dotted_circles ( plan , font , buffer ) ;\n foreach_syllable ( buffer , start , end ) initial_reordering_syllable ( plan , font -> face , buffer , start , end ) ;\n }",
        "output": "0",
        "idx": 4079
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( BookmarkBubbleSignInDelegateTest , OnSignInLinkClickedReusesBlank ) {\n int starting_tab_count = browser ( ) -> tab_strip_model ( ) -> count ( ) ;\n scoped_ptr < BookmarkBubbleDelegate > delegate ;\n delegate . reset ( new BookmarkBubbleSignInDelegate ( browser ( ) ) ) ;\n delegate -> OnSignInLinkClicked ( ) ;\n EXPECT_EQ ( starting_tab_count , browser ( ) -> tab_strip_model ( ) -> count ( ) ) ;\n }",
        "output": "1",
        "idx": 3422
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_opcua ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n tcp_dissect_pdus ( tvb , pinfo , tree , TRUE , FRAME_HEADER_LEN , get_opcua_message_len , dissect_opcua_message , data ) ;\n return tvb_reported_length ( tvb ) ;\n }",
        "output": "0",
        "idx": 722
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void safeputs ( netdissect_options * ndo , const u_char * s , const u_int maxlen ) {\n u_int idx = 0 ;\n while ( * s && idx < maxlen ) {\n safeputchar ( ndo , * s ) ;\n idx ++ ;\n s ++ ;\n }\n }",
        "output": "1",
        "idx": 1456
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int pic_is_unused ( MpegEncContext * s , Picture * pic ) {\n if ( pic -> f . data [ 0 ] == NULL ) return 1 ;\n if ( pic -> needs_realloc && ! ( pic -> f . reference & DELAYED_PIC_REF ) ) if ( ! pic -> owner2 || pic -> owner2 == s ) return 1 ;\n return 0 ;\n }",
        "output": "1",
        "idx": 4034
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "X509_NAME * GetX509NamePtr ( VALUE obj ) {\n X509_NAME * name ;\n SafeGetX509Name ( obj , name ) ;\n return name ;\n }",
        "output": "0",
        "idx": 3633
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vble_restore_plane ( VBLEContext * ctx , int plane , int offset , int width , int height ) {\n AVFrame * pic = ctx -> avctx -> coded_frame ;\n uint8_t * dst = pic -> data [ plane ] ;\n uint8_t * val = ctx -> val + offset ;\n int stride = pic -> linesize [ plane ] ;\n int i , j , left , left_top ;\n for ( i = 0 ;\n i < height ;\n i ++ ) {\n for ( j = 0 ;\n j < width ;\n j ++ ) val [ j ] = ( val [ j ] >> 1 ) ^ - ( val [ j ] & 1 ) ;\n if ( i ) {\n left = 0 ;\n left_top = dst [ - stride ] ;\n ctx -> dsp . add_hfyu_median_prediction ( dst , dst - stride , val , width , & left , & left_top ) ;\n }\n else {\n dst [ 0 ] = val [ 0 ] ;\n for ( j = 1 ;\n j < width ;\n j ++ ) dst [ j ] = val [ j ] + dst [ j - 1 ] ;\n }\n dst += stride ;\n val += width ;\n }\n }",
        "output": "1",
        "idx": 4298
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long usbdev_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) {\n int ret ;\n ret = usbdev_do_ioctl ( file , cmd , ( void __user * ) arg ) ;\n return ret ;\n }",
        "output": "0",
        "idx": 4240
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Archive * CreateArchive ( const char * FileSpec , const ArchiveFormat fmt , const int compression , ArchiveMode mode , SetupWorkerPtr setupDumpWorker ) {\n ArchiveHandle * AH = _allocAH ( FileSpec , fmt , compression , mode , setupDumpWorker ) ;\n return ( Archive * ) AH ;\n }",
        "output": "0",
        "idx": 3027
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _slurm_rpc_sib_job_lock ( uint32_t uid , slurm_msg_t * msg ) {\n int rc ;\n sib_msg_t * sib_msg = msg -> data ;\n if ( ! msg -> conn ) {\n error ( \"Security violation, SIB_JOB_LOCK RPC from uid=%d\" , uid ) ;\n slurm_send_rc_msg ( msg , ESLURM_ACCESS_DENIED ) ;\n return ;\n }\n rc = fed_mgr_job_lock_set ( sib_msg -> job_id , sib_msg -> cluster_id ) ;\n slurm_send_rc_msg ( msg , rc ) ;\n }",
        "output": "0",
        "idx": 452
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mime_hdr_length_get ( MIMEHdrImpl * mh ) {\n unsigned int length , index ;\n MIMEFieldBlockImpl * fblock ;\n MIMEField * field ;\n length = 2 ;\n for ( fblock = & ( mh -> m_first_fblock ) ;\n fblock != nullptr ;\n fblock = fblock -> m_next ) {\n for ( index = 0 ;\n index < fblock -> m_freetop ;\n index ++ ) {\n field = & ( fblock -> m_field_slots [ index ] ) ;\n if ( field -> is_live ( ) ) {\n length += mime_field_length_get ( field ) ;\n }\n }\n }\n return length ;\n }",
        "output": "0",
        "idx": 2530
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_fdct8x8_1_c ( const int16_t * input , int16_t * output , int stride ) {\n int r , c ;\n int16_t sum = 0 ;\n for ( r = 0 ;\n r < 8 ;\n ++ r ) for ( c = 0 ;\n c < 8 ;\n ++ c ) sum += input [ r * stride + c ] ;\n output [ 0 ] = sum ;\n output [ 1 ] = 0 ;\n }",
        "output": "1",
        "idx": 3938
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_fdct32x32_c ( const int16_t * input , int16_t * out , int stride ) {\n int i , j ;\n int output [ 32 * 32 ] ;\n for ( i = 0 ;\n i < 32 ;\n ++ i ) {\n int temp_in [ 32 ] , temp_out [ 32 ] ;\n for ( j = 0 ;\n j < 32 ;\n ++ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ;\n fdct32 ( temp_in , temp_out , 0 ) ;\n for ( j = 0 ;\n j < 32 ;\n ++ j ) output [ j * 32 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] > 0 ) ) >> 2 ;\n }\n for ( i = 0 ;\n i < 32 ;\n ++ i ) {\n int temp_in [ 32 ] , temp_out [ 32 ] ;\n for ( j = 0 ;\n j < 32 ;\n ++ j ) temp_in [ j ] = output [ j + i * 32 ] ;\n fdct32 ( temp_in , temp_out , 0 ) ;\n for ( j = 0 ;\n j < 32 ;\n ++ j ) out [ j + i * 32 ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ;\n }\n }",
        "output": "1",
        "idx": 1292
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileObject , setCsvControl ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n char delimiter = ',' , enclosure = '\"' , escape = '\\\\' ;\n char * delim = NULL , * enclo = NULL , * esc = NULL ;\n int d_len = 0 , e_len = 0 , esc_len = 0 ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"|sss\" , & delim , & d_len , & enclo , & e_len , & esc , & esc_len ) == SUCCESS ) {\n switch ( ZEND_NUM_ARGS ( ) ) {\n case 3 : if ( esc_len != 1 ) {\n php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"escape must be a character\" ) ;\n RETURN_FALSE ;\n }\n escape = esc [ 0 ] ;\n case 2 : if ( e_len != 1 ) {\n php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"enclosure must be a character\" ) ;\n RETURN_FALSE ;\n }\n enclosure = enclo [ 0 ] ;\n case 1 : if ( d_len != 1 ) {\n php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"delimiter must be a character\" ) ;\n RETURN_FALSE ;\n }\n delimiter = delim [ 0 ] ;\n case 0 : break ;\n }\n intern -> u . file . delimiter = delimiter ;\n intern -> u . file . enclosure = enclosure ;\n intern -> u . file . escape = escape ;\n }\n }",
        "output": "1",
        "idx": 555
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vp3_draw_horiz_band ( Vp3DecodeContext * s , int y ) {\n int h , cy , i ;\n int offset [ AV_NUM_DATA_POINTERS ] ;\n if ( HAVE_THREADS && s -> avctx -> active_thread_type & FF_THREAD_FRAME ) {\n int y_flipped = s -> flipped_image ? s -> avctx -> height - y : y ;\n ff_thread_report_progress ( & s -> current_frame , y_flipped == s -> avctx -> height ? INT_MAX : y_flipped - 1 , 0 ) ;\n }\n if ( s -> avctx -> draw_horiz_band == NULL ) return ;\n h = y - s -> last_slice_end ;\n s -> last_slice_end = y ;\n y -= h ;\n if ( ! s -> flipped_image ) {\n y = s -> avctx -> height - y - h ;\n }\n cy = y >> s -> chroma_y_shift ;\n offset [ 0 ] = s -> current_frame . linesize [ 0 ] * y ;\n offset [ 1 ] = s -> current_frame . linesize [ 1 ] * cy ;\n offset [ 2 ] = s -> current_frame . linesize [ 2 ] * cy ;\n for ( i = 3 ;\n i < AV_NUM_DATA_POINTERS ;\n i ++ ) offset [ i ] = 0 ;\n emms_c ( ) ;\n s -> avctx -> draw_horiz_band ( s -> avctx , & s -> current_frame , offset , y , 3 , h ) ;\n }",
        "output": "1",
        "idx": 1734
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void do_system ( struct st_command * command ) {\n DYNAMIC_STRING ds_cmd ;\n DBUG_ENTER ( \"do_system\" ) ;\n if ( strlen ( command -> first_argument ) == 0 ) {\n report_or_die ( \"Missing arguments to system, nothing to do!\" ) ;\n return ;\n }\n init_dynamic_string ( & ds_cmd , 0 , command -> query_len + 64 , 256 ) ;\n do_eval ( & ds_cmd , command -> first_argument , command -> end , ! is_windows ) ;\n # ifdef __WIN__ # ifndef USE_CYGWIN while ( replace ( & ds_cmd , \"/devull\" , 9 , \"NUL\" , 3 ) == 0 ) ;\n # endif # endif DBUG_PRINT ( \"info\" , ( \"running system command '%s' as '%s'\" , command -> first_argument , ds_cmd . str ) ) ;\n if ( my_system ( & ds_cmd ) ) {\n if ( command -> abort_on_error ) report_or_die ( \"system command '%s' failed\" , command -> first_argument ) ;\n else {\n dynstr_append ( & ds_res , \"system command '\" ) ;\n replace_dynstr_append ( & ds_res , command -> first_argument ) ;\n dynstr_append ( & ds_res , \"' failed\\n\" ) ;\n }\n }\n command -> last_argument = command -> end ;\n dynstr_free ( & ds_cmd ) ;\n DBUG_VOID_RETURN ;\n }",
        "output": "0",
        "idx": 4042
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t u_scanf_spellout_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {\n int32_t len ;\n double num ;\n UNumberFormat * format ;\n int32_t parsePos = 0 ;\n int32_t skipped ;\n UErrorCode status = U_ZERO_ERROR ;\n skipped = u_scanf_skip_leading_ws ( input , info -> fPadChar ) ;\n ufile_fill_uchar_buffer ( input ) ;\n len = ( int32_t ) ( input -> str . fLimit - input -> str . fPos ) ;\n if ( info -> fWidth != - 1 ) len = ufmt_min ( len , info -> fWidth ) ;\n format = u_locbund_getNumberFormat ( & input -> str . fBundle , UNUM_SPELLOUT ) ;\n if ( format == 0 ) return 0 ;\n num = unum_parseDouble ( format , input -> str . fPos , len , & parsePos , & status ) ;\n if ( ! info -> fSkipArg ) {\n * ( double * ) ( args [ 0 ] . ptrValue ) = num ;\n }\n input -> str . fPos += parsePos ;\n * argConverted = ! info -> fSkipArg ;\n return parsePos + skipped ;\n }",
        "output": "1",
        "idx": 986
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mktree ( struct tree_content * t , int v , struct strbuf * b ) {\n size_t maxlen = 0 ;\n unsigned int i ;\n if ( ! v ) qsort ( t -> entries , t -> entry_count , sizeof ( t -> entries [ 0 ] ) , tecmp0 ) ;\n else qsort ( t -> entries , t -> entry_count , sizeof ( t -> entries [ 0 ] ) , tecmp1 ) ;\n for ( i = 0 ;\n i < t -> entry_count ;\n i ++ ) {\n if ( t -> entries [ i ] -> versions [ v ] . mode ) maxlen += t -> entries [ i ] -> name -> str_len + 34 ;\n }\n strbuf_reset ( b ) ;\n strbuf_grow ( b , maxlen ) ;\n for ( i = 0 ;\n i < t -> entry_count ;\n i ++ ) {\n struct tree_entry * e = t -> entries [ i ] ;\n if ( ! e -> versions [ v ] . mode ) continue ;\n strbuf_addf ( b , \"%o %s%c\" , ( unsigned int ) ( e -> versions [ v ] . mode & ~ NO_DELTA ) , e -> name -> str_dat , '\\0' ) ;\n strbuf_add ( b , e -> versions [ v ] . sha1 , 20 ) ;\n }\n }",
        "output": "0",
        "idx": 1490
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t compareFallbacks ( const void * context , const void * fb1 , const void * fb2 ) {\n return ( ( const _MBCSToUFallback * ) fb1 ) -> offset - ( ( const _MBCSToUFallback * ) fb2 ) -> offset ;\n }",
        "output": "1",
        "idx": 2263
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int get_vp9_frame_buffer ( void * cb_priv , size_t min_size , vpx_codec_frame_buffer_t * fb ) {\n int i ;\n struct ExternalFrameBufferList * const ext_fb_list = ( struct ExternalFrameBufferList * ) cb_priv ;\n if ( ext_fb_list == NULL ) return - 1 ;\n for ( i = 0 ;\n i < ext_fb_list -> num_external_frame_buffers ;\n ++ i ) {\n if ( ! ext_fb_list -> ext_fb [ i ] . in_use ) break ;\n }\n if ( i == ext_fb_list -> num_external_frame_buffers ) return - 1 ;\n if ( ext_fb_list -> ext_fb [ i ] . size < min_size ) {\n free ( ext_fb_list -> ext_fb [ i ] . data ) ;\n ext_fb_list -> ext_fb [ i ] . data = ( uint8_t * ) malloc ( min_size ) ;\n if ( ! ext_fb_list -> ext_fb [ i ] . data ) return - 1 ;\n ext_fb_list -> ext_fb [ i ] . size = min_size ;\n }\n fb -> data = ext_fb_list -> ext_fb [ i ] . data ;\n fb -> size = ext_fb_list -> ext_fb [ i ] . size ;\n ext_fb_list -> ext_fb [ i ] . in_use = 1 ;\n fb -> priv = & ext_fb_list -> ext_fb [ i ] ;\n return 0 ;\n }",
        "output": "1",
        "idx": 1902
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void arm_gic_realize ( DeviceState * dev , Error * * errp ) {\n int i ;\n GICState * s = ARM_GIC ( dev ) ;\n SysBusDevice * sbd = SYS_BUS_DEVICE ( dev ) ;\n ARMGICClass * agc = ARM_GIC_GET_CLASS ( s ) ;\n agc -> parent_realize ( dev , errp ) ;\n if ( error_is_set ( errp ) ) {\n return ;\n }\n gic_init_irqs_and_distributor ( s , s -> num_irq ) ;\n memory_region_init_io ( & s -> cpuiomem [ 0 ] , OBJECT ( s ) , & gic_thiscpu_ops , s , \"gic_cpu\" , 0x100 ) ;\n for ( i = 0 ;\n i < NUM_CPU ( s ) ;\n i ++ ) {\n s -> backref [ i ] = s ;\n memory_region_init_io ( & s -> cpuiomem [ i + 1 ] , OBJECT ( s ) , & gic_cpu_ops , & s -> backref [ i ] , \"gic_cpu\" , 0x100 ) ;\n }\n sysbus_init_mmio ( sbd , & s -> iomem ) ;\n for ( i = 0 ;\n i <= NUM_CPU ( s ) ;\n i ++ ) {\n sysbus_init_mmio ( sbd , & s -> cpuiomem [ i ] ) ;\n }\n }",
        "output": "0",
        "idx": 4239
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void user_data_key_destroy ( hb_user_data_key_t l ) {\n }",
        "output": "1",
        "idx": 2093
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool virLogProbablyLogMessage ( const char * str ) {\n bool ret = false ;\n if ( ! virLogRegex ) return false ;\n if ( regexec ( virLogRegex , str , 0 , NULL , 0 ) == 0 ) ret = true ;\n return ret ;\n }",
        "output": "0",
        "idx": 12
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fts_build_parse_content_type ( struct fts_mail_build_context * ctx , const struct message_header_line * hdr ) {\n struct rfc822_parser_context parser ;\n string_t * content_type ;\n if ( ctx -> content_type != NULL ) return ;\n rfc822_parser_init ( & parser , hdr -> full_value , hdr -> full_value_len , NULL ) ;\n rfc822_skip_lwsp ( & parser ) ;\n T_BEGIN {\n content_type = t_str_new ( 64 ) ;\n ( void ) rfc822_parse_content_type ( & parser , content_type ) ;\n ctx -> content_type = str_lcase ( i_strdup ( str_c ( content_type ) ) ) ;\n }\n T_END ;\n }",
        "output": "1",
        "idx": 724
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool _is_valid_will_run_user ( job_desc_msg_t * job_desc_msg , uid_t uid ) {\n char * account = NULL ;\n if ( ( uid == job_desc_msg -> user_id ) || validate_operator ( uid ) ) return true ;\n if ( job_desc_msg -> job_id != NO_VAL ) {\n struct job_record * job_ptr ;\n job_ptr = find_job_record ( job_desc_msg -> job_id ) ;\n if ( job_ptr ) account = job_ptr -> account ;\n }\n else if ( job_desc_msg -> account ) account = job_desc_msg -> account ;\n if ( account && assoc_mgr_is_user_acct_coord ( acct_db_conn , uid , account ) ) return true ;\n return false ;\n }",
        "output": "1",
        "idx": 3650
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileInfo , func_name ) \\ {\n \\ spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n \\ zend_error_handling error_handling ;\n \\ if ( zend_parse_parameters_none ( ) == FAILURE ) {\n \\ return ;\n \\ }\n \\ \\ zend_replace_error_handling ( EH_THROW , spl_ce_RuntimeException , & error_handling TSRMLS_CC ) ;\n \\ spl_filesystem_object_get_file_name ( intern TSRMLS_CC ) ;\n \\ php_stat ( intern -> file_name , intern -> file_name_len , func_num , return_value TSRMLS_CC ) ;\n \\ zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;\n \\ }\n FileInfoFunction ( getPerms , FS_PERMS ) FileInfoFunction ( getInode , FS_INODE ) FileInfoFunction ( getSize , FS_SIZE ) FileInfoFunction ( getOwner , FS_OWNER ) FileInfoFunction ( getGroup , FS_GROUP ) FileInfoFunction ( getATime , FS_ATIME ) FileInfoFunction ( getMTime , FS_MTIME ) FileInfoFunction ( getCTime , FS_CTIME ) FileInfoFunction ( getType , FS_TYPE ) FileInfoFunction ( isWritable , FS_IS_W ) FileInfoFunction ( isReadable , FS_IS_R ) FileInfoFunction ( isExecutable , FS_IS_X ) FileInfoFunction ( isFile , FS_IS_FILE )",
        "output": "0",
        "idx": 844
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int purge_bin_logs_to ( MYSQL * mysql_con , char * log_name ) {\n DYNAMIC_STRING str ;\n int err ;\n init_dynamic_string_checked ( & str , \"PURGE BINARY LOGS TO '\" , 1024 , 1024 ) ;\n dynstr_append_checked ( & str , log_name ) ;\n dynstr_append_checked ( & str , \"'\" ) ;\n err = mysql_query_with_error_report ( mysql_con , 0 , str . str ) ;\n dynstr_free ( & str ) ;\n return err ;\n }",
        "output": "0",
        "idx": 1312
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gboolean pk_transaction_set_tid ( PkTransaction * transaction , const gchar * tid ) {\n static const GDBusInterfaceVTable interface_vtable = {\n pk_transaction_method_call , pk_transaction_get_property , NULL }\n ;\n g_return_val_if_fail ( PK_IS_TRANSACTION ( transaction ) , FALSE ) ;\n g_return_val_if_fail ( tid != NULL , FALSE ) ;\n g_return_val_if_fail ( transaction -> priv -> tid == NULL , FALSE ) ;\n transaction -> priv -> tid = g_strdup ( tid ) ;\n transaction -> priv -> connection = g_bus_get_sync ( G_BUS_TYPE_SYSTEM , NULL , NULL ) ;\n g_assert ( transaction -> priv -> connection != NULL ) ;\n transaction -> priv -> registration_id = g_dbus_connection_register_object ( transaction -> priv -> connection , tid , transaction -> priv -> introspection -> interfaces [ 0 ] , & interface_vtable , transaction , NULL , NULL ) ;\n g_assert ( transaction -> priv -> registration_id > 0 ) ;\n return TRUE ;\n }",
        "output": "0",
        "idx": 3316
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qemu_cpu_kick_self ( void ) {\n # ifndef _WIN32 assert ( current_cpu ) ;\n if ( ! current_cpu -> thread_kicked ) {\n qemu_cpu_kick_thread ( current_cpu ) ;\n current_cpu -> thread_kicked = true ;\n }\n # else abort ( ) ;\n # endif }",
        "output": "0",
        "idx": 780
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void inter_predictor ( const uint8_t * src , int src_stride , uint8_t * dst , int dst_stride , const int subpel_x , const int subpel_y , const struct scale_factors * sf , int w , int h , int ref , const InterpKernel * kernel , int xs , int ys ) {\n sf -> predict [ subpel_x != 0 ] [ subpel_y != 0 ] [ ref ] ( src , src_stride , dst , dst_stride , kernel [ subpel_x ] , xs , kernel [ subpel_y ] , ys , w , h ) ;\n }",
        "output": "0",
        "idx": 2569
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mpi_set_ui ( MPI w , unsigned long u ) {\n RESIZE_IF_NEEDED ( w , 1 ) ;\n w -> d [ 0 ] = u ;\n w -> nlimbs = u ? 1 : 0 ;\n w -> sign = 0 ;\n w -> nbits = 0 ;\n w -> flags = 0 ;\n }",
        "output": "1",
        "idx": 155
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rtp_free_hash_dyn_payload ( GHashTable * rtp_dyn_payload ) {\n if ( rtp_dyn_payload == NULL ) return ;\n g_hash_table_destroy ( rtp_dyn_payload ) ;\n rtp_dyn_payload = NULL ;\n }",
        "output": "1",
        "idx": 4040
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "METHOD ( certificate_t , destroy , void , private_x509_cert_t * this ) {\n if ( ref_put ( & this -> ref ) ) {\n this -> subjectAltNames -> destroy_offset ( this -> subjectAltNames , offsetof ( identification_t , destroy ) ) ;\n this -> crl_uris -> destroy_function ( this -> crl_uris , ( void * ) crl_uri_destroy ) ;\n this -> ocsp_uris -> destroy_function ( this -> ocsp_uris , free ) ;\n this -> ipAddrBlocks -> destroy_offset ( this -> ipAddrBlocks , offsetof ( traffic_selector_t , destroy ) ) ;\n this -> permitted_names -> destroy_offset ( this -> permitted_names , offsetof ( identification_t , destroy ) ) ;\n this -> excluded_names -> destroy_offset ( this -> excluded_names , offsetof ( identification_t , destroy ) ) ;\n this -> cert_policies -> destroy_function ( this -> cert_policies , ( void * ) cert_policy_destroy ) ;\n this -> policy_mappings -> destroy_function ( this -> policy_mappings , ( void * ) policy_mapping_destroy ) ;\n DESTROY_IF ( this -> issuer ) ;\n DESTROY_IF ( this -> subject ) ;\n DESTROY_IF ( this -> public_key ) ;\n chunk_free ( & this -> authKeyIdentifier ) ;\n chunk_free ( & this -> encoding ) ;\n chunk_free ( & this -> encoding_hash ) ;\n if ( ! this -> parsed ) {\n chunk_free ( & this -> signature ) ;\n chunk_free ( & this -> serialNumber ) ;\n chunk_free ( & this -> tbsCertificate ) ;\n }\n free ( this ) ;\n }\n }",
        "output": "0",
        "idx": 4449
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static COMMANDS * find_command ( char cmd_char ) {\n DBUG_ENTER ( \"find_command\" ) ;\n DBUG_PRINT ( \"enter\" , ( \"cmd_char: %d\" , cmd_char ) ) ;\n int index = - 1 ;\n if ( real_binary_mode ) {\n if ( cmd_char == 'C' ) index = charset_index ;\n }\n else index = get_command_index ( cmd_char ) ;\n if ( index >= 0 ) {\n DBUG_PRINT ( \"exit\" , ( \"found command: %s\" , commands [ index ] . name ) ) ;\n DBUG_RETURN ( & commands [ index ] ) ;\n }\n else DBUG_RETURN ( ( COMMANDS * ) 0 ) ;\n }",
        "output": "0",
        "idx": 2063
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TSTextLogObjectRollingIntervalSecSet ( TSTextLogObject the_object , int rolling_interval_sec ) {\n sdk_assert ( sdk_sanity_check_iocore_structure ( the_object ) == TS_SUCCESS ) ;\n ( ( TextLogObject * ) the_object ) -> set_rolling_interval_sec ( rolling_interval_sec ) ;\n }",
        "output": "0",
        "idx": 4445
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_predict_intra_block ( const MACROBLOCKD * xd , int block_idx , int bwl_in , TX_SIZE tx_size , PREDICTION_MODE mode , const uint8_t * ref , int ref_stride , uint8_t * dst , int dst_stride , int aoff , int loff , int plane ) {\n const int bwl = bwl_in - tx_size ;\n const int wmask = ( 1 << bwl ) - 1 ;\n const int have_top = ( block_idx >> bwl ) || xd -> up_available ;\n const int have_left = ( block_idx & wmask ) || xd -> left_available ;\n const int have_right = ( ( block_idx & wmask ) != wmask ) ;\n const int x = aoff * 4 ;\n const int y = loff * 4 ;\n assert ( bwl >= 0 ) ;\n build_intra_predictors ( xd , ref , ref_stride , dst , dst_stride , mode , tx_size , have_top , have_left , have_right , x , y , plane ) ;\n }",
        "output": "1",
        "idx": 2156
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char * vpx_svc_get_rc_stats_buffer ( const SvcContext * svc_ctx ) {\n const SvcInternal * const si = get_const_svc_internal ( svc_ctx ) ;\n if ( svc_ctx == NULL || si == NULL ) return NULL ;\n return si -> rc_stats_buf ;\n }",
        "output": "1",
        "idx": 420
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static vpx_codec_err_t ctrl_update_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) {\n const int ref_frame_flags = va_arg ( args , int ) ;\n vp9_update_reference ( ctx -> cpi , ref_frame_flags ) ;\n return VPX_CODEC_OK ;\n }",
        "output": "0",
        "idx": 1359
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct object_list * * process_tree ( struct tree * tree , struct object_list * * p , struct name_path * path , const char * name ) {\n struct object * obj = & tree -> object ;\n struct tree_desc desc ;\n struct name_entry entry ;\n struct name_path me ;\n obj -> flags |= LOCAL ;\n if ( obj -> flags & ( UNINTERESTING | SEEN ) ) return p ;\n if ( parse_tree ( tree ) < 0 ) die ( \"bad tree object %s\" , oid_to_hex ( & obj -> oid ) ) ;\n obj -> flags |= SEEN ;\n name = xstrdup ( name ) ;\n p = add_one_object ( obj , p ) ;\n me . up = path ;\n me . elem = name ;\n me . elem_len = strlen ( name ) ;\n init_tree_desc ( & desc , tree -> buffer , tree -> size ) ;\n while ( tree_entry ( & desc , & entry ) ) switch ( object_type ( entry . mode ) ) {\n case OBJ_TREE : p = process_tree ( lookup_tree ( entry . sha1 ) , p , & me , name ) ;\n break ;\n case OBJ_BLOB : p = process_blob ( lookup_blob ( entry . sha1 ) , p , & me , name ) ;\n break ;\n default : break ;\n }\n free_tree_buffer ( tree ) ;\n return p ;\n }",
        "output": "1",
        "idx": 1919
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipvideo_decode_block_opcode_0x6 ( IpvideoContext * s ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \" Interplay video: Help! Mystery opcode 0x6 seen\\n\" ) ;\n return 0 ;\n }",
        "output": "1",
        "idx": 1706
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cmd_window_move_up ( void ) {\n MAIN_WINDOW_REC * rec ;\n rec = mainwindows_find_upper_left ( active_mainwin ) ;\n if ( rec != NULL ) window_reparent ( active_win , rec ) ;\n }",
        "output": "0",
        "idx": 3605
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE ossl_cipher_set_key ( VALUE self , VALUE key ) {\n EVP_CIPHER_CTX * ctx ;\n int key_len ;\n StringValue ( key ) ;\n GetCipher ( self , ctx ) ;\n key_len = EVP_CIPHER_CTX_key_length ( ctx ) ;\n if ( RSTRING_LEN ( key ) != key_len ) ossl_raise ( rb_eArgError , \"key must be %d bytes\" , key_len ) ;\n if ( EVP_CipherInit_ex ( ctx , NULL , NULL , ( unsigned char * ) RSTRING_PTR ( key ) , NULL , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ;\n return key ;\n }",
        "output": "1",
        "idx": 2122
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static UChar32 T_UConverter_getNextUChar_UTF32_LE ( UConverterToUnicodeArgs * args , UErrorCode * err ) {\n const uint8_t * mySource ;\n UChar32 myUChar ;\n int32_t length ;\n mySource = ( const uint8_t * ) args -> source ;\n if ( mySource >= ( const uint8_t * ) args -> sourceLimit ) {\n * err = U_INDEX_OUTOFBOUNDS_ERROR ;\n return 0xffff ;\n }\n length = ( int32_t ) ( ( const uint8_t * ) args -> sourceLimit - mySource ) ;\n if ( length < 4 ) {\n uprv_memcpy ( args -> converter -> toUBytes , mySource , length ) ;\n args -> converter -> toULength = ( int8_t ) length ;\n args -> source = ( const char * ) ( mySource + length ) ;\n * err = U_TRUNCATED_CHAR_FOUND ;\n return 0xffff ;\n }\n myUChar = ( ( UChar32 ) mySource [ 3 ] << 24 ) | ( ( UChar32 ) mySource [ 2 ] << 16 ) | ( ( UChar32 ) mySource [ 1 ] << 8 ) | ( ( UChar32 ) mySource [ 0 ] ) ;\n args -> source = ( const char * ) ( mySource + 4 ) ;\n if ( ( uint32_t ) myUChar <= MAXIMUM_UTF && ! U_IS_SURROGATE ( myUChar ) ) {\n return myUChar ;\n }\n uprv_memcpy ( args -> converter -> toUBytes , mySource , 4 ) ;\n args -> converter -> toULength = 4 ;\n * err = U_ILLEGAL_CHAR_FOUND ;\n return 0xffff ;\n }",
        "output": "1",
        "idx": 580
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nsv_probe ( AVProbeData * p ) {\n int i , score = 0 ;\n if ( p -> buf [ 0 ] == 'N' && p -> buf [ 1 ] == 'S' && p -> buf [ 2 ] == 'V' && ( p -> buf [ 3 ] == 'f' || p -> buf [ 3 ] == 's' ) ) return AVPROBE_SCORE_MAX ;\n for ( i = 1 ;\n i < p -> buf_size - 3 ;\n i ++ ) {\n if ( AV_RL32 ( p -> buf + i ) == AV_RL32 ( \"NSVs\" ) ) {\n int vsize = AV_RL24 ( p -> buf + i + 19 ) >> 4 ;\n int asize = AV_RL16 ( p -> buf + i + 22 ) ;\n int offset = i + 23 + asize + vsize + 1 ;\n if ( offset <= p -> buf_size - 2 && AV_RL16 ( p -> buf + offset ) == 0xBEEF ) return 4 * AVPROBE_SCORE_MAX / 5 ;\n score = AVPROBE_SCORE_MAX / 5 ;\n }\n }\n if ( av_match_ext ( p -> filename , \"nsv\" ) ) return AVPROBE_SCORE_EXTENSION ;\n return score ;\n }",
        "output": "0",
        "idx": 455
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE mFloat_to_json ( int argc , VALUE * argv , VALUE self ) {\n GENERATE_JSON ( float ) ;\n }",
        "output": "0",
        "idx": 2311
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static UBool action_setInverse ( UBiDiTransform * pTransform , UErrorCode * pErrorCode ) {\n ubidi_setInverse ( pTransform -> pBidi , TRUE ) ;\n ubidi_setReorderingMode ( pTransform -> pBidi , UBIDI_REORDER_INVERSE_LIKE_DIRECT ) ;\n return FALSE ;\n }",
        "output": "1",
        "idx": 798
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char * html_replace ( char ch , char * buf ) {\n switch ( ch ) {\n case '<' : return \"&lt;\n\" ;\n case '>' : return \"&gt;\n\" ;\n case '\"' : return \"&quot;\n\" ;\n case '\\'' : return \"&#039;\n\" ;\n case '&' : return \"&amp;\n\" ;\n default : break ;\n }\n buf [ 0 ] = ch ;\n buf [ 1 ] = '\\0' ;\n return buf ;\n }",
        "output": "0",
        "idx": 735
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION ( locale_accept_from_http ) {\n UEnumeration * available ;\n char * http_accept = NULL ;\n int http_accept_len ;\n UErrorCode status = 0 ;\n int len ;\n char resultLocale [ INTL_MAX_LOCALE_LEN + 1 ] ;\n UAcceptResult outResult ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"s\" , & http_accept , & http_accept_len ) == FAILURE ) {\n intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , \"locale_accept_from_http: unable to parse input parameters\" , 0 TSRMLS_CC ) ;\n RETURN_FALSE ;\n }\n available = ures_openAvailableLocales ( NULL , & status ) ;\n INTL_CHECK_STATUS ( status , \"locale_accept_from_http: failed to retrieve locale list\" ) ;\n len = uloc_acceptLanguageFromHTTP ( resultLocale , INTL_MAX_LOCALE_LEN , & outResult , http_accept , available , & status ) ;\n uenum_close ( available ) ;\n INTL_CHECK_STATUS ( status , \"locale_accept_from_http: failed to find acceptable locale\" ) ;\n if ( len < 0 || outResult == ULOC_ACCEPT_FAILED ) {\n RETURN_FALSE ;\n }\n RETURN_STRINGL ( resultLocale , len , 1 ) ;\n }",
        "output": "1",
        "idx": 4296
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_T_oid ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 883 \"./asn1/h225/h225.cnf\" const gchar * oid_str = NULL ;\n gef_ctx_t * gefx ;\n offset = dissect_per_object_identifier_str ( tvb , offset , actx , tree , hf_index , & oid_str ) ;\n gefx = gef_ctx_get ( actx -> private_data ) ;\n if ( gefx ) gefx -> id = oid_str ;\n return offset ;\n }",
        "output": "0",
        "idx": 2925
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , Navigate_Both_NonHtmlMainResource ) {\n StartHttpServer ( ) ;\n StartHttpsServer ( false ) ;\n NavigateTwiceInTabAndClose ( http_test_server_ -> GetURL ( \"/circle.svg\" ) , https_test_server_ -> GetURL ( \"/circle.svg\" ) ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 1 ) ;\n }",
        "output": "1",
        "idx": 4230
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_block_size ( VP9_COMP * const cpi , int mi_row , int mi_col , BLOCK_SIZE bsize ) {\n if ( cpi -> common . mi_cols > mi_col && cpi -> common . mi_rows > mi_row ) {\n MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;\n set_modeinfo_offsets ( & cpi -> common , xd , mi_row , mi_col ) ;\n xd -> mi [ 0 ] -> mbmi . sb_type = bsize ;\n duplicate_mode_info_in_sb ( & cpi -> common , xd , mi_row , mi_col , bsize ) ;\n }\n }",
        "output": "1",
        "idx": 3901
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int * __xmlParserDebugEntities ( void ) {\n if ( IS_MAIN_THREAD ) return ( & xmlParserDebugEntities ) ;\n else return ( & xmlGetGlobalState ( ) -> xmlParserDebugEntities ) ;\n }",
        "output": "0",
        "idx": 14
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int execstack_continue ( i_ctx_t * i_ctx_p ) {\n os_ptr op = osp ;\n return do_execstack ( i_ctx_p , false , op ) ;\n }",
        "output": "1",
        "idx": 1929
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int main_open_output ( xd3_stream * stream , main_file * ofile ) {\n int ret ;\n if ( option_no_output ) {\n return 0 ;\n }\n if ( ofile -> filename == NULL ) {\n XSTDOUT_XF ( ofile ) ;\n if ( option_verbose > 1 ) {\n XPR ( NT \"using standard output: %s\\n\" , ofile -> filename ) ;\n }\n }\n else {\n if ( option_force == 0 && main_file_exists ( ofile ) ) {\n if ( ! option_quiet ) {\n XPR ( NT \"to overwrite output file specify -f: %s\\n\" , ofile -> filename ) ;\n }\n return EEXIST ;\n }\n if ( ( ret = main_file_open ( ofile , ofile -> filename , XO_WRITE ) ) ) {\n return ret ;\n }\n if ( option_verbose > 1 ) {\n XPR ( NT \"output %s\\n\" , ofile -> filename ) ;\n }\n }\n # if EXTERNAL_COMPRESSION if ( ofile -> compressor != NULL && option_recompress_outputs == 1 ) {\n if ( ! option_quiet ) {\n XPR ( NT \"externally compressed output: %s %s%s > %s\\n\" , ofile -> compressor -> recomp_cmdname , ofile -> compressor -> recomp_options , ( option_force2 ? \" -f\" : \"\" ) , ofile -> filename ) ;\n }\n if ( ( ret = main_recompress_output ( ofile ) ) ) {\n return ret ;\n }\n }\n # endif return 0 ;\n }",
        "output": "0",
        "idx": 1340
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int handle_cpu_signal ( uintptr_t pc , unsigned long address , int is_write , sigset_t * old_set , void * puc ) {\n int ret ;\n # if defined ( DEBUG_SIGNAL ) qemu_printf ( \"qemu: SIGSEGV pc=0x%08lx address=%08lx w=%d oldset=0x%08lx\\n\" , pc , address , is_write , * ( unsigned long * ) old_set ) ;\n # endif if ( is_write && h2g_valid ( address ) && page_unprotect ( h2g ( address ) , pc , puc ) ) {\n return 1 ;\n }\n ret = cpu_handle_mmu_fault ( cpu_single_env , address , is_write , MMU_USER_IDX ) ;\n if ( ret < 0 ) {\n return 0 ;\n }\n if ( ret == 0 ) {\n return 1 ;\n }\n cpu_restore_state ( cpu_single_env , pc ) ;\n sigprocmask ( SIG_SETMASK , old_set , NULL ) ;\n exception_action ( cpu_single_env ) ;\n return 1 ;\n }",
        "output": "1",
        "idx": 4180
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static usize_t main_get_winsize ( main_file * ifile ) {\n xoff_t file_size = 0 ;\n usize_t size = option_winsize ;\n static shortbuf iszbuf ;\n if ( main_file_stat ( ifile , & file_size ) == 0 ) {\n size = ( usize_t ) min ( file_size , ( xoff_t ) size ) ;\n }\n size = max ( size , XD3_ALLOCSIZE ) ;\n if ( option_verbose > 1 ) {\n XPR ( NT \"input %s window size %s\\n\" , ifile -> filename , main_format_bcnt ( size , & iszbuf ) ) ;\n }\n return size ;\n }",
        "output": "0",
        "idx": 131
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void eval_lpcenv ( TwinContext * tctx , const float * cos_vals , float * lpc ) {\n int i ;\n const ModeTab * mtab = tctx -> mtab ;\n int size_s = mtab -> size / mtab -> fmode [ FT_SHORT ] . sub ;\n for ( i = 0 ;\n i < size_s / 2 ;\n i ++ ) {\n float cos_i = tctx -> cos_tabs [ 0 ] [ i ] ;\n lpc [ i ] = eval_lpc_spectrum ( cos_vals , cos_i , mtab -> n_lsp ) ;\n lpc [ size_s - i - 1 ] = eval_lpc_spectrum ( cos_vals , - cos_i , mtab -> n_lsp ) ;\n }\n }",
        "output": "0",
        "idx": 2817
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , IgnoreDownloads ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n base : : ScopedAllowBlockingForTesting allow_blocking ;\n base : : ScopedTempDir downloads_directory ;\n ASSERT_TRUE ( downloads_directory . CreateUniqueTempDir ( ) ) ;\n browser ( ) -> profile ( ) -> GetPrefs ( ) -> SetFilePath ( prefs : : kDownloadDefaultDirectory , downloads_directory . GetPath ( ) ) ;\n content : : DownloadTestObserverTerminal downloads_observer ( content : : BrowserContext : : GetDownloadManager ( browser ( ) -> profile ( ) ) , 1 , content : : DownloadTestObserver : : ON_DANGEROUS_DOWNLOAD_FAIL ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( \"/download-test3.gif\" ) ) ;\n downloads_observer . WaitForFinished ( ) ;\n NavigateToUntrackedUrl ( ) ;\n EXPECT_TRUE ( NoPageLoadMetricsRecorded ( ) ) << \"Recorded metrics: \" << GetRecordedPageLoadMetricNames ( ) ;\n }",
        "output": "1",
        "idx": 3520
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void my_coll_agg_error ( Item * * args , uint count , const char * fname , int item_sep ) {\n if ( count == 2 ) my_coll_agg_error ( args [ 0 ] -> collation , args [ item_sep ] -> collation , fname ) ;\n else if ( count == 3 ) my_coll_agg_error ( args [ 0 ] -> collation , args [ item_sep ] -> collation , args [ 2 * item_sep ] -> collation , fname ) ;\n else my_error ( ER_CANT_AGGREGATE_NCOLLATIONS , MYF ( 0 ) , fname ) ;\n }",
        "output": "0",
        "idx": 747
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int event_base_priority_init ( struct event_base * base , int npriorities ) {\n int i ;\n if ( base -> event_count_active ) return ( - 1 ) ;\n if ( base -> nactivequeues && npriorities != base -> nactivequeues ) {\n for ( i = 0 ;\n i < base -> nactivequeues ;\n ++ i ) {\n free ( base -> activequeues [ i ] ) ;\n }\n free ( base -> activequeues ) ;\n }\n base -> nactivequeues = npriorities ;\n base -> activequeues = ( struct event_list * * ) calloc ( base -> nactivequeues , sizeof ( struct event_list * ) ) ;\n if ( base -> activequeues == NULL ) event_err ( 1 , \"%s: calloc\" , __func__ ) ;\n for ( i = 0 ;\n i < base -> nactivequeues ;\n ++ i ) {\n base -> activequeues [ i ] = malloc ( sizeof ( struct event_list ) ) ;\n if ( base -> activequeues [ i ] == NULL ) event_err ( 1 , \"%s: malloc\" , __func__ ) ;\n TAILQ_INIT ( base -> activequeues [ i ] ) ;\n }\n return ( 0 ) ;\n }",
        "output": "1",
        "idx": 2345
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void SRP_user_pwd_free ( SRP_user_pwd * user_pwd ) {\n if ( user_pwd == NULL ) return ;\n BN_free ( user_pwd -> s ) ;\n BN_clear_free ( user_pwd -> v ) ;\n OPENSSL_free ( user_pwd -> id ) ;\n OPENSSL_free ( user_pwd -> info ) ;\n OPENSSL_free ( user_pwd ) ;\n }",
        "output": "1",
        "idx": 3321
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_DialedDigits ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 319 \"./asn1/h225/h225.cnf\" tvbuff_t * value_tvb = NULL ;\n guint len = 0 ;\n h225_packet_info * h225_pi ;\n offset = dissect_per_restricted_character_string ( tvb , offset , actx , tree , hf_index , 1 , 128 , FALSE , \"0123456789#*,\" , 13 , & value_tvb ) ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi && h225_pi -> is_destinationInfo == TRUE ) {\n if ( value_tvb ) {\n len = tvb_reported_length ( value_tvb ) ;\n if ( len > sizeof h225_pi -> dialedDigits - 1 ) len = sizeof h225_pi -> dialedDigits - 1 ;\n tvb_memcpy ( value_tvb , ( guint8 * ) h225_pi -> dialedDigits , 0 , len ) ;\n }\n h225_pi -> dialedDigits [ len ] = '\\0' ;\n h225_pi -> is_destinationInfo = FALSE ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 3735
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ExternalProtocolHandlerTest , TestGetBlockStateDefaultDontBlock ) {\n ExternalProtocolHandler : : BlockState block_state = ExternalProtocolHandler : : GetBlockState ( \"mailto\" , profile_ . get ( ) ) ;\n EXPECT_EQ ( ExternalProtocolHandler : : DONT_BLOCK , block_state ) ;\n EXPECT_TRUE ( local_state_ -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;\n EXPECT_TRUE ( profile_ -> GetPrefs ( ) -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;\n }",
        "output": "0",
        "idx": 2862
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int find_real_tpr_addr ( VAPICROMState * s , CPUX86State * env ) {\n hwaddr paddr ;\n target_ulong addr ;\n if ( s -> state == VAPIC_ACTIVE ) {\n return 0 ;\n }\n for ( addr = 0xfffff000 ;\n addr >= 0x80000000 ;\n addr -= TARGET_PAGE_SIZE ) {\n paddr = cpu_get_phys_page_debug ( env , addr ) ;\n if ( paddr != APIC_DEFAULT_ADDRESS ) {\n continue ;\n }\n s -> real_tpr_addr = addr + 0x80 ;\n update_guest_rom_state ( s ) ;\n return 0 ;\n }\n return - 1 ;\n }",
        "output": "0",
        "idx": 1362
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void lag_pred_line ( LagarithContext * l , uint8_t * buf , int width , int stride , int line ) {\n int L , TL ;\n if ( ! line ) {\n L = l -> dsp . add_hfyu_left_prediction ( buf + 1 , buf + 1 , width - 1 , buf [ 0 ] ) ;\n }\n else {\n L = buf [ width - stride - 1 ] ;\n if ( line == 1 ) {\n TL = l -> avctx -> pix_fmt == AV_PIX_FMT_YUV420P ? buf [ - stride ] : L ;\n }\n else {\n TL = buf [ width - ( 2 * stride ) - 1 ] ;\n }\n add_lag_median_prediction ( buf , buf - stride , buf , width , & L , & TL ) ;\n }\n }",
        "output": "0",
        "idx": 2419
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void extra_close_record ( struct ctl_extr_rec * ctl , int ce_size ) {\n int padding = 0 ;\n if ( ce_size > 0 ) extra_tell_used_size ( ctl , ce_size ) ;\n if ( ctl -> cur_len & 0x01 ) {\n ctl -> cur_len ++ ;\n if ( ctl -> bp != NULL ) ctl -> bp [ ctl -> cur_len ] = 0 ;\n padding = 1 ;\n }\n if ( ctl -> use_extr ) {\n if ( ctl -> ce_ptr != NULL ) set_SUSP_CE ( ctl -> ce_ptr , ctl -> extr_loc , ctl -> extr_off , ctl -> cur_len - padding ) ;\n }\n else ctl -> dr_len = ctl -> cur_len ;\n }",
        "output": "0",
        "idx": 2620
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_regular_quantize_b_4x4 ( MACROBLOCK * x , int plane , int block , const int16_t * scan , const int16_t * iscan ) {\n MACROBLOCKD * const xd = & x -> e_mbd ;\n struct macroblock_plane * p = & x -> plane [ plane ] ;\n struct macroblockd_plane * pd = & xd -> plane [ plane ] ;\n vp9_quantize_b ( BLOCK_OFFSET ( p -> coeff , block ) , 16 , x -> skip_block , p -> zbin , p -> round , p -> quant , p -> quant_shift , BLOCK_OFFSET ( p -> qcoeff , block ) , BLOCK_OFFSET ( pd -> dqcoeff , block ) , pd -> dequant , p -> zbin_extra , & p -> eobs [ block ] , scan , iscan ) ;\n }",
        "output": "1",
        "idx": 3024
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BerElement * der_alloc ( void ) {\n return ber_alloc_t ( LBER_USE_DER ) ;\n }",
        "output": "0",
        "idx": 1649
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int find_best_16x16_intra ( VP9_COMP * cpi , PREDICTION_MODE * pbest_mode ) {\n MACROBLOCK * const x = & cpi -> mb ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n PREDICTION_MODE best_mode = - 1 , mode ;\n unsigned int best_err = INT_MAX ;\n for ( mode = DC_PRED ;\n mode <= TM_PRED ;\n mode ++ ) {\n unsigned int err ;\n xd -> mi [ 0 ] -> mbmi . mode = mode ;\n vp9_predict_intra_block ( xd , 0 , 2 , TX_16X16 , mode , x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride , 0 , 0 , 0 ) ;\n err = vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride ) ;\n if ( err < best_err ) {\n best_err = err ;\n best_mode = mode ;\n }\n }\n if ( pbest_mode ) * pbest_mode = best_mode ;\n return best_err ;\n }",
        "output": "1",
        "idx": 3799
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_UnregRequestReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 603 \"./asn1/h225/h225.cnf\" gint32 value ;\n h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_UnregRequestReason , UnregRequestReason_choice , & value ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> reason = value ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 1117
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rgb_to_gray ( fz_context * ctx , const fz_colorspace * cs , const float * rgb , float * gray ) {\n float r = rgb [ 0 ] ;\n float g = rgb [ 1 ] ;\n float b = rgb [ 2 ] ;\n gray [ 0 ] = r * 0.3f + g * 0.59f + b * 0.11f ;\n }",
        "output": "0",
        "idx": 962
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipvideo_decode_block_opcode_0x7_16 ( IpvideoContext * s ) {\n int x , y ;\n uint16_t P [ 2 ] ;\n unsigned int flags ;\n uint16_t * pixel_ptr = ( uint16_t * ) s -> pixel_ptr ;\n P [ 0 ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n P [ 1 ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n if ( ! ( P [ 0 ] & 0x8000 ) ) {\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n flags = bytestream2_get_byte ( & s -> stream_ptr ) | 0x100 ;\n for ( ;\n flags != 1 ;\n flags >>= 1 ) * pixel_ptr ++ = P [ flags & 1 ] ;\n pixel_ptr += s -> line_inc ;\n }\n }\n else {\n flags = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n for ( y = 0 ;\n y < 8 ;\n y += 2 ) {\n for ( x = 0 ;\n x < 8 ;\n x += 2 , flags >>= 1 ) {\n pixel_ptr [ x ] = pixel_ptr [ x + 1 ] = pixel_ptr [ x + s -> stride ] = pixel_ptr [ x + 1 + s -> stride ] = P [ flags & 1 ] ;\n }\n pixel_ptr += s -> stride * 2 ;\n }\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 3644
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static field_info * new_field_info ( proto_tree * tree , header_field_info * hfinfo , tvbuff_t * tvb , const gint start , const gint item_length ) {\n field_info * fi ;\n FIELD_INFO_NEW ( PNODE_POOL ( tree ) , fi ) ;\n fi -> hfinfo = hfinfo ;\n fi -> start = start ;\n fi -> start += ( tvb ) ? tvb_raw_offset ( tvb ) : 0 ;\n fi -> length = item_length ;\n fi -> tree_type = - 1 ;\n fi -> flags = 0 ;\n if ( ! PTREE_DATA ( tree ) -> visible ) FI_SET_FLAG ( fi , FI_HIDDEN ) ;\n fvalue_init ( & fi -> value , fi -> hfinfo -> type ) ;\n fi -> rep = NULL ;\n fi -> ds_tvb = tvb ? tvb_get_ds_tvb ( tvb ) : NULL ;\n fi -> appendix_start = 0 ;\n fi -> appendix_length = 0 ;\n return fi ;\n }",
        "output": "0",
        "idx": 2524
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vp9_denoiser_alloc ( VP9_DENOISER * denoiser , int width , int height , int ssx , int ssy , # if CONFIG_VP9_HIGHBITDEPTH int use_highbitdepth , # endif int border ) {\n int i , fail ;\n assert ( denoiser != NULL ) ;\n for ( i = 0 ;\n i < MAX_REF_FRAMES ;\n ++ i ) {\n fail = vp9_alloc_frame_buffer ( & denoiser -> running_avg_y [ i ] , width , height , ssx , ssy , # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif border ) ;\n if ( fail ) {\n vp9_denoiser_free ( denoiser ) ;\n return 1 ;\n }\n # ifdef OUTPUT_YUV_DENOISED make_grayscale ( & denoiser -> running_avg_y [ i ] ) ;\n # endif }\n fail = vp9_alloc_frame_buffer ( & denoiser -> mc_running_avg_y , width , height , ssx , ssy , # if CONFIG_VP9_HIGHBITDEPTH use_highbitdepth , # endif border ) ;\n if ( fail ) {\n vp9_denoiser_free ( denoiser ) ;\n return 1 ;\n }\n # ifdef OUTPUT_YUV_DENOISED make_grayscale ( & denoiser -> running_avg_y [ i ] ) ;\n # endif denoiser -> increase_denoising = 0 ;\n return 0 ;\n }",
        "output": "0",
        "idx": 4339
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bluetooth_uuid_t get_service_uuid_from_handle ( packet_info * pinfo , guint32 handle , bluetooth_data_t * bluetooth_data ) {\n wmem_tree_key_t key [ 4 ] ;\n guint32 frame_number ;\n handle_data_t * handle_data ;\n wmem_tree_t * sub_wmemtree ;\n bluetooth_uuid_t uuid ;\n memset ( & uuid , 0 , sizeof uuid ) ;\n frame_number = pinfo -> num ;\n key [ 0 ] . length = 1 ;\n key [ 0 ] . key = & bluetooth_data -> interface_id ;\n key [ 1 ] . length = 1 ;\n key [ 1 ] . key = & bluetooth_data -> adapter_id ;\n key [ 2 ] . length = 1 ;\n key [ 2 ] . key = & handle ;\n key [ 3 ] . length = 0 ;\n key [ 3 ] . key = NULL ;\n while ( handle > 0 ) {\n sub_wmemtree = ( wmem_tree_t * ) wmem_tree_lookup32_array ( handle_to_uuid , key ) ;\n handle_data = ( sub_wmemtree ) ? ( handle_data_t * ) wmem_tree_lookup32_le ( sub_wmemtree , frame_number ) : NULL ;\n if ( handle_data && handle_data -> type == ATTRIBUTE_TYPE_SERVICE ) {\n uuid = handle_data -> uuid ;\n return uuid ;\n }\n handle -= 1 ;\n }\n return uuid ;\n }",
        "output": "0",
        "idx": 1961
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int yop_paint_block ( YopDecContext * s , int tag ) {\n if ( s -> src_end - s -> srcptr < paint_lut [ tag ] [ 3 ] ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Packet too small.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n s -> dstptr [ 0 ] = s -> srcptr [ 0 ] ;\n s -> dstptr [ 1 ] = s -> srcptr [ paint_lut [ tag ] [ 0 ] ] ;\n s -> dstptr [ s -> frame . linesize [ 0 ] ] = s -> srcptr [ paint_lut [ tag ] [ 1 ] ] ;\n s -> dstptr [ s -> frame . linesize [ 0 ] + 1 ] = s -> srcptr [ paint_lut [ tag ] [ 2 ] ] ;\n s -> srcptr += paint_lut [ tag ] [ 3 ] ;\n return 0 ;\n }",
        "output": "1",
        "idx": 1245
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ber_len ( BerElement * ber ) {\n return ( ber -> ber_end - ber -> ber_buf ) ;\n }",
        "output": "0",
        "idx": 2804
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char * evhttp_method ( enum evhttp_cmd_type type ) {\n const char * method ;\n switch ( type ) {\n case EVHTTP_REQ_GET : method = \"GET\" ;\n break ;\n case EVHTTP_REQ_POST : method = \"POST\" ;\n break ;\n case EVHTTP_REQ_HEAD : method = \"HEAD\" ;\n break ;\n default : method = NULL ;\n break ;\n }\n return ( method ) ;\n }",
        "output": "0",
        "idx": 3811
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int selinux_inet_conn_request ( struct sock * sk , struct sk_buff * skb , struct request_sock * req ) {\n struct sk_security_struct * sksec = sk -> sk_security ;\n int err ;\n u16 family = req -> rsk_ops -> family ;\n u32 connsid ;\n u32 peersid ;\n err = selinux_skb_peerlbl_sid ( skb , family , & peersid ) ;\n if ( err ) return err ;\n err = selinux_conn_sid ( sksec -> sid , peersid , & connsid ) ;\n if ( err ) return err ;\n req -> secid = connsid ;\n req -> peer_secid = peersid ;\n return selinux_netlbl_inet_conn_request ( req , family ) ;\n }",
        "output": "0",
        "idx": 4468
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void idct4 ( const int16_t * input , int16_t * output ) {\n int16_t step [ 4 ] ;\n int temp1 , temp2 ;\n temp1 = ( input [ 0 ] + input [ 2 ] ) * cospi_16_64 ;\n temp2 = ( input [ 0 ] - input [ 2 ] ) * cospi_16_64 ;\n step [ 0 ] = dct_const_round_shift ( temp1 ) ;\n step [ 1 ] = dct_const_round_shift ( temp2 ) ;\n temp1 = input [ 1 ] * cospi_24_64 - input [ 3 ] * cospi_8_64 ;\n temp2 = input [ 1 ] * cospi_8_64 + input [ 3 ] * cospi_24_64 ;\n step [ 2 ] = dct_const_round_shift ( temp1 ) ;\n step [ 3 ] = dct_const_round_shift ( temp2 ) ;\n output [ 0 ] = step [ 0 ] + step [ 3 ] ;\n output [ 1 ] = step [ 1 ] + step [ 2 ] ;\n output [ 2 ] = step [ 1 ] - step [ 2 ] ;\n output [ 3 ] = step [ 0 ] - step [ 3 ] ;\n }",
        "output": "1",
        "idx": 2640
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "op_array_table * get_op_array ( const gs_memory_t * mem , int size ) {\n gs_main_instance * minst = get_minst_from_memory ( mem ) ;\n return op_index_op_array_table ( minst -> i_ctx_p , size ) ;\n }",
        "output": "0",
        "idx": 1445
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int split_field_copy ( Picture * dest , Picture * src , int parity , int id_add ) {\n int match = ! ! ( src -> reference & parity ) ;\n if ( match ) {\n COPY_PICTURE ( dest , src ) ;\n if ( parity != PICT_FRAME ) {\n pic_as_field ( dest , parity ) ;\n dest -> pic_id *= 2 ;\n dest -> pic_id += id_add ;\n }\n }\n return match ;\n }",
        "output": "0",
        "idx": 4085
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int lang_compare_first_component ( const char * a , const char * b ) {\n unsigned int da , db ;\n const char * p ;\n p = strchr ( a , '-' ) ;\n da = p ? ( unsigned int ) ( p - a ) : strlen ( a ) ;\n p = strchr ( b , '-' ) ;\n db = p ? ( unsigned int ) ( p - b ) : strlen ( b ) ;\n return strncmp ( a , b , MAX ( da , db ) ) ;\n }",
        "output": "0",
        "idx": 1784
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int libgsm_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n int i , ret ;\n LibGSMDecodeContext * s = avctx -> priv_data ;\n AVFrame * frame = data ;\n uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n int16_t * samples ;\n if ( buf_size < avctx -> block_align ) {\n av_log ( avctx , AV_LOG_ERROR , \"Packet is too small\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n frame -> nb_samples = avctx -> frame_size ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n samples = ( int16_t * ) frame -> data [ 0 ] ;\n for ( i = 0 ;\n i < avctx -> frame_size / GSM_FRAME_SIZE ;\n i ++ ) {\n if ( ( ret = gsm_decode ( s -> state , buf , samples ) ) < 0 ) return - 1 ;\n buf += GSM_BLOCK_SIZE ;\n samples += GSM_FRAME_SIZE ;\n }\n * got_frame_ptr = 1 ;\n return avctx -> block_align ;\n }",
        "output": "1",
        "idx": 3996
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void short_usage ( FILE * f ) {\n short_usage_sub ( f ) ;\n fprintf ( f , \"For more options, use %s --help\\n\" , my_progname_short ) ;\n }",
        "output": "1",
        "idx": 2716
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool spec_ctrl_needed ( void * opaque ) {\n X86CPU * cpu = opaque ;\n CPUX86State * env = & cpu -> env ;\n return env -> spec_ctrl != 0 ;\n }",
        "output": "0",
        "idx": 1916
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _CompoundText_GetUnicodeSet ( const UConverter * cnv , const USetAdder * sa , UConverterUnicodeSet which , UErrorCode * pErrorCode ) {\n UConverterDataCompoundText * myConverterData = ( UConverterDataCompoundText * ) cnv -> extraInfo ;\n int32_t i ;\n for ( i = 1 ;\n i < NUM_OF_CONVERTERS ;\n i ++ ) {\n ucnv_MBCSGetUnicodeSetForUnicode ( myConverterData -> myConverterArray [ i ] , sa , which , pErrorCode ) ;\n }\n sa -> add ( sa -> set , 0x0000 ) ;\n sa -> add ( sa -> set , 0x0009 ) ;\n sa -> add ( sa -> set , 0x000A ) ;\n sa -> addRange ( sa -> set , 0x0020 , 0x007F ) ;\n sa -> addRange ( sa -> set , 0x00A0 , 0x00FF ) ;\n }",
        "output": "1",
        "idx": 1320
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int read_inter_segment_id ( VP9_COMMON * const cm , MACROBLOCKD * const xd , int mi_row , int mi_col , vp9_reader * r ) {\n struct segmentation * const seg = & cm -> seg ;\n MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;\n const BLOCK_SIZE bsize = mbmi -> sb_type ;\n int predicted_segment_id , segment_id ;\n if ( ! seg -> enabled ) return 0 ;\n predicted_segment_id = vp9_get_segment_id ( cm , cm -> last_frame_seg_map , bsize , mi_row , mi_col ) ;\n if ( ! seg -> update_map ) return predicted_segment_id ;\n if ( seg -> temporal_update ) {\n const vp9_prob pred_prob = vp9_get_pred_prob_seg_id ( seg , xd ) ;\n mbmi -> seg_id_predicted = vp9_read ( r , pred_prob ) ;\n segment_id = mbmi -> seg_id_predicted ? predicted_segment_id : read_segment_id ( r , seg ) ;\n }\n else {\n segment_id = read_segment_id ( r , seg ) ;\n }\n set_segment_id ( cm , bsize , mi_row , mi_col , segment_id ) ;\n return segment_id ;\n }",
        "output": "1",
        "idx": 4390
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sdp_parse_fmtp_config_h264 ( AVFormatContext * s , AVStream * stream , PayloadContext * h264_data , const char * attr , const char * value ) {\n AVCodecParameters * par = stream -> codecpar ;\n if ( ! strcmp ( attr , \"packetization-mode\" ) ) {\n av_log ( s , AV_LOG_DEBUG , \"RTP Packetization Mode: %d\\n\" , atoi ( value ) ) ;\n h264_data -> packetization_mode = atoi ( value ) ;\n if ( h264_data -> packetization_mode > 1 ) av_log ( s , AV_LOG_ERROR , \"Interleaved RTP mode is not supported yet.\\n\" ) ;\n }\n else if ( ! strcmp ( attr , \"profile-level-id\" ) ) {\n if ( strlen ( value ) == 6 ) parse_profile_level_id ( s , h264_data , value ) ;\n }\n else if ( ! strcmp ( attr , \"sprop-parameter-sets\" ) ) {\n int ret ;\n if ( value [ strlen ( value ) - 1 ] == ',' ) {\n av_log ( s , AV_LOG_WARNING , \"Missing PPS in sprop-parameter-sets, ignoring\\n\" ) ;\n return 0 ;\n }\n par -> extradata_size = 0 ;\n av_freep ( & par -> extradata ) ;\n ret = ff_h264_parse_sprop_parameter_sets ( s , & par -> extradata , & par -> extradata_size , value ) ;\n av_log ( s , AV_LOG_DEBUG , \"Extradata set to %p (size: %d)\\n\" , par -> extradata , par -> extradata_size ) ;\n return ret ;\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 4155
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , Simple_Http ) {\n StartHttpServer ( ) ;\n base : : TimeDelta upper_bound = NavigateInForegroundAndCloseWithTiming ( http_test_server_ -> GetURL ( \"/simple.html\" ) ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;\n int32_t bucket_min = histogram_tester_ . GetAllSamples ( internal : : kHttpEngagementHistogram ) [ 0 ] . min ;\n EXPECT_GE ( upper_bound . InMilliseconds ( ) , bucket_min ) ;\n EXPECT_LT ( 0 , bucket_min ) ;\n }",
        "output": "1",
        "idx": 1110
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fixDirToTreePath ( char * s ) {\n # if ( U_FILE_SEP_CHAR != U_TREE_ENTRY_SEP_CHAR ) || ( ( U_FILE_ALT_SEP_CHAR != U_FILE_SEP_CHAR ) && ( U_FILE_ALT_SEP_CHAR != U_TREE_ENTRY_SEP_CHAR ) ) char * t ;\n # endif # if ( U_FILE_SEP_CHAR != U_TREE_ENTRY_SEP_CHAR ) for ( t = s ;\n t = uprv_strchr ( t , U_FILE_SEP_CHAR ) ;\n ) {\n * t = U_TREE_ENTRY_SEP_CHAR ;\n }\n # endif # if ( U_FILE_ALT_SEP_CHAR != U_FILE_SEP_CHAR ) && ( U_FILE_ALT_SEP_CHAR != U_TREE_ENTRY_SEP_CHAR ) for ( t = s ;\n t = uprv_strchr ( t , U_FILE_ALT_SEP_CHAR ) ;\n ) {\n * t = U_TREE_ENTRY_SEP_CHAR ;\n }\n # endif }",
        "output": "1",
        "idx": 1239
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int msvideo1_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n Msvideo1Context * s = avctx -> priv_data ;\n s -> buf = buf ;\n s -> size = buf_size ;\n s -> frame . reference = 1 ;\n s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( avctx -> reget_buffer ( avctx , & s -> frame ) ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return - 1 ;\n }\n if ( s -> mode_8bit ) {\n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n if ( pal ) {\n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n s -> frame . palette_has_changed = 1 ;\n }\n }\n if ( s -> mode_8bit ) msvideo1_decode_8bit ( s ) ;\n else msvideo1_decode_16bit ( s ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return buf_size ;\n }",
        "output": "1",
        "idx": 3543
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_rc_set_gf_max_interval ( const VP9_COMP * const cpi , RATE_CONTROL * const rc ) {\n const VP9EncoderConfig * const oxcf = & cpi -> oxcf ;\n rc -> max_gf_interval = 16 ;\n rc -> static_scene_max_gf_interval = oxcf -> key_freq >> 1 ;\n if ( rc -> static_scene_max_gf_interval > ( MAX_LAG_BUFFERS * 2 ) ) rc -> static_scene_max_gf_interval = MAX_LAG_BUFFERS * 2 ;\n if ( is_altref_enabled ( cpi ) ) {\n if ( rc -> static_scene_max_gf_interval > oxcf -> lag_in_frames - 1 ) rc -> static_scene_max_gf_interval = oxcf -> lag_in_frames - 1 ;\n }\n if ( rc -> max_gf_interval > rc -> static_scene_max_gf_interval ) rc -> max_gf_interval = rc -> static_scene_max_gf_interval ;\n }",
        "output": "0",
        "idx": 2438
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char )",
        "output": "1",
        "idx": 2316
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static UBool _isVariantSubtag ( const char * s , int32_t len ) {\n if ( len < 0 ) {\n len = ( int32_t ) uprv_strlen ( s ) ;\n }\n if ( len >= 5 && len <= 8 && _isAlphaNumericString ( s , len ) ) {\n return TRUE ;\n }\n if ( len == 4 && ISNUMERIC ( * s ) && _isAlphaNumericString ( s + 1 , 3 ) ) {\n return TRUE ;\n }\n return FALSE ;\n }",
        "output": "0",
        "idx": 1584
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ProtocolHandlerRegistryTest , TestIsSameOrigin ) {\n ProtocolHandler ph1 = CreateProtocolHandler ( \"mailto\" , GURL ( \"http://test.com/%s\" ) , \"test1\" ) ;\n ProtocolHandler ph2 = CreateProtocolHandler ( \"mailto\" , GURL ( \"http://test.com/updated-url/%s\" ) , \"test2\" ) ;\n ProtocolHandler ph3 = CreateProtocolHandler ( \"mailto\" , GURL ( \"http://other.com/%s\" ) , \"test\" ) ;\n ASSERT_EQ ( ph1 . url ( ) . GetOrigin ( ) == ph2 . url ( ) . GetOrigin ( ) , ph1 . IsSameOrigin ( ph2 ) ) ;\n ASSERT_EQ ( ph1 . url ( ) . GetOrigin ( ) == ph2 . url ( ) . GetOrigin ( ) , ph2 . IsSameOrigin ( ph1 ) ) ;\n ASSERT_EQ ( ph2 . url ( ) . GetOrigin ( ) == ph3 . url ( ) . GetOrigin ( ) , ph2 . IsSameOrigin ( ph3 ) ) ;\n ASSERT_EQ ( ph3 . url ( ) . GetOrigin ( ) == ph2 . url ( ) . GetOrigin ( ) , ph3 . IsSameOrigin ( ph2 ) ) ;\n }",
        "output": "1",
        "idx": 4197
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void lag_pred_line_yuy2 ( LagarithContext * l , uint8_t * buf , int width , int stride , int line , int is_luma ) {\n int L , TL ;\n if ( ! line ) {\n if ( is_luma ) {\n buf ++ ;\n width -- ;\n }\n l -> dsp . add_hfyu_left_prediction ( buf + 1 , buf + 1 , width - 1 , buf [ 0 ] ) ;\n return ;\n }\n if ( line == 1 ) {\n const int HEAD = is_luma ? 4 : 2 ;\n int i ;\n L = buf [ width - stride - 1 ] ;\n TL = buf [ HEAD - stride - 1 ] ;\n for ( i = 0 ;\n i < HEAD ;\n i ++ ) {\n L += buf [ i ] ;\n buf [ i ] = L ;\n }\n buf += HEAD ;\n width -= HEAD ;\n }\n else {\n TL = buf [ width - ( 2 * stride ) - 1 ] ;\n L = buf [ width - stride - 1 ] ;\n }\n l -> dsp . add_hfyu_median_prediction ( buf , buf - stride , buf , width , & L , & TL ) ;\n }",
        "output": "0",
        "idx": 3525
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void get_hfi_length ( header_field_info * hfinfo , tvbuff_t * tvb , const gint start , gint * length , gint * item_length ) {\n gint length_remaining ;\n DISSECTOR_ASSERT ( tvb != NULL || * length == 0 ) ;\n if ( * length == - 1 ) {\n switch ( hfinfo -> type ) {\n case FT_PROTOCOL : case FT_NONE : case FT_BYTES : case FT_STRING : case FT_STRINGZPAD : * length = tvb_captured_length ( tvb ) ? tvb_ensure_captured_length_remaining ( tvb , start ) : 0 ;\n DISSECTOR_ASSERT ( * length >= 0 ) ;\n break ;\n case FT_STRINGZ : break ;\n default : THROW ( ReportedBoundsError ) ;\n DISSECTOR_ASSERT_NOT_REACHED ( ) ;\n }\n * item_length = * length ;\n }\n else {\n * item_length = * length ;\n if ( hfinfo -> type == FT_PROTOCOL || hfinfo -> type == FT_NONE ) {\n if ( tvb ) {\n length_remaining = tvb_captured_length_remaining ( tvb , start ) ;\n if ( * item_length < 0 || ( * item_length > 0 && ( length_remaining < * item_length ) ) ) * item_length = length_remaining ;\n }\n }\n if ( * item_length < 0 ) {\n THROW ( ReportedBoundsError ) ;\n }\n }\n }",
        "output": "0",
        "idx": 200
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int SRP_user_pwd_set_sv_BN ( SRP_user_pwd * vinfo , BIGNUM * s , BIGNUM * v ) {\n vinfo -> v = v ;\n vinfo -> s = s ;\n return ( vinfo -> s != NULL && vinfo -> v != NULL ) ;\n }",
        "output": "1",
        "idx": 2997
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int xmlListPushBack ( xmlListPtr l , void * data ) {\n xmlLinkPtr lkPlace , lkNew ;\n if ( l == NULL ) return ( 0 ) ;\n lkPlace = l -> sentinel -> prev ;\n if ( NULL == ( lkNew = ( xmlLinkPtr ) xmlMalloc ( sizeof ( xmlLink ) ) ) ) {\n xmlGenericError ( xmlGenericErrorContext , \"Cannot initialize memory for new link\" ) ;\n return ( 0 ) ;\n }\n lkNew -> data = data ;\n lkNew -> next = lkPlace -> next ;\n ( lkPlace -> next ) -> prev = lkNew ;\n lkPlace -> next = lkNew ;\n lkNew -> prev = lkPlace ;\n return 1 ;\n }",
        "output": "1",
        "idx": 3549
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static double calc_frame_boost ( const TWO_PASS * twopass , const FIRSTPASS_STATS * this_frame , double this_frame_mv_in_out ) {\n double frame_boost ;\n if ( this_frame -> intra_error > twopass -> gf_intra_err_min ) frame_boost = ( IIFACTOR * this_frame -> intra_error / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ;\n else frame_boost = ( IIFACTOR * twopass -> gf_intra_err_min / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ;\n if ( this_frame_mv_in_out > 0.0 ) frame_boost += frame_boost * ( this_frame_mv_in_out * 2.0 ) ;\n else frame_boost += frame_boost * ( this_frame_mv_in_out / 2.0 ) ;\n return MIN ( frame_boost , GF_RMAX ) ;\n }",
        "output": "1",
        "idx": 3023
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_DisengageRejectReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 646 \"./asn1/h225/h225.cnf\" gint32 value ;\n h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_DisengageRejectReason , DisengageRejectReason_choice , & value ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> reason = value ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 2111
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void DangerousDownloadValidated ( JNIEnv * env , const JavaParamRef < jclass > & clazz , const JavaParamRef < jobject > & tab , jint download_id , jboolean accept ) {\n TabAndroid * tab_android = TabAndroid : : GetNativeTab ( env , tab ) ;\n content : : DownloadControllerAndroid : : Get ( ) -> DangerousDownloadValidated ( tab_android -> web_contents ( ) , download_id , accept ) ;\n }",
        "output": "1",
        "idx": 2481
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void unixErrorHandler ( const char * module , const char * fmt , va_list ap ) {\n if ( module != NULL ) fprintf ( stderr , \"%s: \" , module ) ;\n vfprintf ( stderr , fmt , ap ) ;\n fprintf ( stderr , \".\\n\" ) ;\n }",
        "output": "0",
        "idx": 3194
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int selinux_inode_setsecctx ( struct dentry * dentry , void * ctx , u32 ctxlen ) {\n return __vfs_setxattr_noperm ( dentry , XATTR_NAME_SELINUX , ctx , ctxlen , 0 ) ;\n }",
        "output": "0",
        "idx": 993
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void * jas_malloc ( size_t size ) {\n void * result ;\n JAS_DBGLOG ( 101 , ( \"jas_malloc called with %zu\\n\" , size ) ) ;\n result = malloc ( size ) ;\n JAS_DBGLOG ( 100 , ( \"jas_malloc(%zu) -> %p\\n\" , size , result ) ) ;\n return result ;\n }",
        "output": "1",
        "idx": 4010
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_ExtendedVideoCapability ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_ExtendedVideoCapability , ExtendedVideoCapability_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 750
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void untrusted_launcher_response_callback ( GtkDialog * dialog , int response_id , ActivateParametersDesktop * parameters ) {\n GdkScreen * screen ;\n char * uri ;\n GFile * file ;\n switch ( response_id ) {\n case RESPONSE_RUN : {\n screen = gtk_widget_get_screen ( GTK_WIDGET ( parameters -> parent_window ) ) ;\n uri = nautilus_file_get_uri ( parameters -> file ) ;\n DEBUG ( \"Launching untrusted launcher %s\" , uri ) ;\n nautilus_launch_desktop_file ( screen , uri , NULL , parameters -> parent_window ) ;\n g_free ( uri ) ;\n }\n break ;\n case RESPONSE_MARK_TRUSTED : {\n file = nautilus_file_get_location ( parameters -> file ) ;\n nautilus_file_mark_desktop_file_trusted ( file , parameters -> parent_window , TRUE , NULL , NULL ) ;\n g_object_unref ( file ) ;\n }\n break ;\n default : {\n }\n break ;\n }\n gtk_widget_destroy ( GTK_WIDGET ( dialog ) ) ;\n activate_parameters_desktop_free ( parameters ) ;\n }",
        "output": "1",
        "idx": 3098
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void * vpx_svc_get_buffer ( SvcContext * svc_ctx ) {\n SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n if ( svc_ctx == NULL || si == NULL || si -> frame_list == NULL ) return NULL ;\n if ( si -> frame_temp ) fd_free ( si -> frame_temp ) ;\n si -> frame_temp = si -> frame_list ;\n si -> frame_list = si -> frame_list -> next ;\n return si -> frame_temp -> buf ;\n }",
        "output": "1",
        "idx": 2844
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_idct32x32_34_add_c ( const int16_t * input , uint8_t * dest , int stride ) {\n int16_t out [ 32 * 32 ] = {\n 0 }\n ;\n int16_t * outptr = out ;\n int i , j ;\n int16_t temp_in [ 32 ] , temp_out [ 32 ] ;\n for ( i = 0 ;\n i < 8 ;\n ++ i ) {\n idct32 ( input , outptr ) ;\n input += 32 ;\n outptr += 32 ;\n }\n for ( i = 0 ;\n i < 32 ;\n ++ i ) {\n for ( j = 0 ;\n j < 32 ;\n ++ j ) temp_in [ j ] = out [ j * 32 + i ] ;\n idct32 ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 32 ;\n ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) + dest [ j * stride + i ] ) ;\n }\n }",
        "output": "1",
        "idx": 3995
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cinaudio_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n CinAudioContext * cin = avctx -> priv_data ;\n const uint8_t * buf_end = buf + avpkt -> size ;\n int16_t * samples ;\n int delta , ret ;\n frame -> nb_samples = avpkt -> size - cin -> initial_decode_frame ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n samples = ( int16_t * ) frame -> data [ 0 ] ;\n delta = cin -> delta ;\n if ( cin -> initial_decode_frame ) {\n cin -> initial_decode_frame = 0 ;\n delta = sign_extend ( AV_RL16 ( buf ) , 16 ) ;\n buf += 2 ;\n * samples ++ = delta ;\n }\n while ( buf < buf_end ) {\n delta += cinaudio_delta16_table [ * buf ++ ] ;\n delta = av_clip_int16 ( delta ) ;\n * samples ++ = delta ;\n }\n cin -> delta = delta ;\n * got_frame_ptr = 1 ;\n return avpkt -> size ;\n }",
        "output": "1",
        "idx": 302
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void add_dct ( MpegEncContext * s , int16_t * block , int i , uint8_t * dest , int line_size ) {\n if ( s -> block_last_index [ i ] >= 0 ) {\n s -> dsp . idct_add ( dest , line_size , block ) ;\n }\n }",
        "output": "0",
        "idx": 383
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void handle_raw_login ( char * packet , int len , struct query * q , int fd , int userid ) {\n char myhash [ 16 ] ;\n if ( len < 16 ) return ;\n if ( userid < 0 || userid >= created_users ) return ;\n if ( ! users [ userid ] . active || users [ userid ] . disabled ) return ;\n if ( ! users [ userid ] . authenticated ) return ;\n if ( users [ userid ] . last_pkt + 60 < time ( NULL ) ) return ;\n if ( debug >= 1 ) {\n fprintf ( stderr , \"IN login raw, len %d, from user %d\\n\" , len , userid ) ;\n }\n login_calculate ( myhash , 16 , password , users [ userid ] . seed + 1 ) ;\n if ( memcmp ( packet , myhash , 16 ) == 0 ) {\n struct sockaddr_in * tempin ;\n users [ userid ] . last_pkt = time ( NULL ) ;\n memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n tempin = ( struct sockaddr_in * ) & ( q -> from ) ;\n memcpy ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;\n user_set_conn_type ( userid , CONN_RAW_UDP ) ;\n login_calculate ( myhash , 16 , password , users [ userid ] . seed - 1 ) ;\n send_raw ( fd , myhash , 16 , userid , RAW_HDR_CMD_LOGIN , q ) ;\n users [ userid ] . authenticated_raw = 1 ;\n }\n }",
        "output": "0",
        "idx": 3460
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t u_scanf_pointer_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {\n int32_t len ;\n int32_t skipped ;\n void * result ;\n void * * p = ( void * * ) ( args [ 0 ] . ptrValue ) ;\n skipped = u_scanf_skip_leading_ws ( input , info -> fPadChar ) ;\n ufile_fill_uchar_buffer ( input ) ;\n len = ( int32_t ) ( input -> str . fLimit - input -> str . fPos ) ;\n if ( info -> fWidth != - 1 ) {\n len = ufmt_min ( len , info -> fWidth ) ;\n }\n if ( len > ( int32_t ) ( sizeof ( void * ) * 2 ) ) {\n len = ( int32_t ) ( sizeof ( void * ) * 2 ) ;\n }\n result = ufmt_utop ( input -> str . fPos , & len ) ;\n if ( ! info -> fSkipArg ) {\n * p = result ;\n }\n input -> str . fPos += len ;\n * argConverted = ! info -> fSkipArg ;\n return len + skipped ;\n }",
        "output": "1",
        "idx": 1554
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void * data_create_arabic ( const hb_ot_shape_plan_t * plan ) {\n arabic_shape_plan_t * arabic_plan = ( arabic_shape_plan_t * ) calloc ( 1 , sizeof ( arabic_shape_plan_t ) ) ;\n if ( unlikely ( ! arabic_plan ) ) return NULL ;\n arabic_plan -> do_fallback = plan -> props . script == HB_SCRIPT_ARABIC ;\n for ( unsigned int i = 0 ;\n i < ARABIC_NUM_FEATURES ;\n i ++ ) {\n arabic_plan -> mask_array [ i ] = plan -> map . get_1_mask ( arabic_features [ i ] ) ;\n arabic_plan -> do_fallback = arabic_plan -> do_fallback && ( FEATURE_IS_SYRIAC ( arabic_features [ i ] ) || plan -> map . needs_fallback ( arabic_features [ i ] ) ) ;\n }\n return arabic_plan ;\n }",
        "output": "1",
        "idx": 3586
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_kf_active_quality ( const RATE_CONTROL * const rc , int q ) {\n return get_active_quality ( q , rc -> kf_boost , kf_low , kf_high , kf_low_motion_minq , kf_high_motion_minq ) ;\n }",
        "output": "1",
        "idx": 3973
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sethalftone_cleanup ( i_ctx_t * i_ctx_p ) {\n gx_device_halftone * pdht = r_ptr ( & esp [ 4 ] , gx_device_halftone ) ;\n gs_halftone * pht = r_ptr ( & esp [ 3 ] , gs_halftone ) ;\n gs_free_object ( pdht -> rc . memory , pdht , \"sethalftone_cleanup(device halftone)\" ) ;\n gs_free_object ( pht -> rc . memory , pht , \"sethalftone_cleanup(halftone)\" ) ;\n return 0 ;\n }",
        "output": "0",
        "idx": 679
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int read_intra_segment_id ( VP9_COMMON * const cm , MACROBLOCKD * const xd , int mi_row , int mi_col , vp9_reader * r ) {\n struct segmentation * const seg = & cm -> seg ;\n const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ;\n int segment_id ;\n if ( ! seg -> enabled ) return 0 ;\n if ( ! seg -> update_map ) return 0 ;\n segment_id = read_segment_id ( r , seg ) ;\n set_segment_id ( cm , bsize , mi_row , mi_col , segment_id ) ;\n return segment_id ;\n }",
        "output": "1",
        "idx": 3330
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ctr64_inc ( unsigned char * counter ) {\n int n = 8 ;\n unsigned char c ;\n do {\n -- n ;\n c = counter [ n ] ;\n ++ c ;\n counter [ n ] = c ;\n if ( c ) return ;\n }\n while ( n ) ;\n }",
        "output": "0",
        "idx": 2741
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( ExtensionMessageBubbleViewBrowserTest , ExtensionBubbleAnchoredToAppMenu ) {\n TestBubbleAnchoredToAppMenu ( ) ;\n }",
        "output": "0",
        "idx": 597
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "EXCLUSIVE_REGRESSION_TEST ( SDK_API_HttpParentProxySet_Success ) ( RegressionTest * test , int level , int * pstatus ) {\n * pstatus = REGRESSION_TEST_INPROGRESS ;\n if ( level < REGRESSION_TEST_EXTENDED ) {\n * pstatus = REGRESSION_TEST_NOT_RUN ;\n return ;\n }\n TSCont cont = TSContCreate ( parent_proxy_handler , TSMutexCreate ( ) ) ;\n if ( cont == nullptr ) {\n SDK_RPRINT ( test , \"TSHttpTxnParentProxySet\" , \"SuccessCase\" , TC_FAIL , \"Unable to create continuation\" ) ;\n * pstatus = REGRESSION_TEST_FAILED ;\n return ;\n }\n ParentTest * ptest = new ParentTest ( test , pstatus ) ;\n ptest -> testcase = \"SuccessCase\" ;\n ptest -> handler = parent_proxy_success ;\n TSContDataSet ( cont , ptest ) ;\n TSHttpHookAdd ( TS_HTTP_READ_REQUEST_HDR_HOOK , cont ) ;\n ptest -> os = synserver_create ( SYNSERVER_LISTEN_PORT , TSContCreate ( synserver_vc_accept , TSMutexCreate ( ) ) ) ;\n synserver_start ( ptest -> os ) ;\n TSContSchedule ( cont , 25 , TS_THREAD_POOL_DEFAULT ) ;\n }",
        "output": "0",
        "idx": 1279
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct event_base * event_base_new ( void ) {\n int i ;\n struct event_base * base ;\n if ( ( base = calloc ( 1 , sizeof ( struct event_base ) ) ) == NULL ) event_err ( 1 , \"%s: calloc\" , __func__ ) ;\n gettime ( base , & base -> event_tv ) ;\n min_heap_ctor ( & base -> timeheap ) ;\n TAILQ_INIT ( & base -> eventqueue ) ;\n base -> sig . ev_signal_pair [ 0 ] = - 1 ;\n base -> sig . ev_signal_pair [ 1 ] = - 1 ;\n base -> evbase = NULL ;\n for ( i = 0 ;\n eventops [ i ] && ! base -> evbase ;\n i ++ ) {\n base -> evsel = eventops [ i ] ;\n base -> evbase = base -> evsel -> init ( base ) ;\n }\n if ( base -> evbase == NULL ) event_errx ( 1 , \"%s: no event mechanism available\" , __func__ ) ;\n if ( evutil_getenv ( \"EVENT_SHOW_METHOD\" ) ) event_msgx ( \"libevent using: %s\\n\" , base -> evsel -> name ) ;\n event_base_priority_init ( base , 1 ) ;\n return ( base ) ;\n }",
        "output": "1",
        "idx": 3434
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bprint_bytes ( AVBPrint * bp , const uint8_t * ubuf , size_t ubuf_size ) {\n int i ;\n av_bprintf ( bp , \"0X\" ) ;\n for ( i = 0 ;\n i < ubuf_size ;\n i ++ ) av_bprintf ( bp , \"%02X\" , ubuf [ i ] ) ;\n }",
        "output": "0",
        "idx": 3499
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_MaintenanceLoopRejectCause ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_MaintenanceLoopRejectCause , MaintenanceLoopRejectCause_choice , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 3103
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool is_one_of ( const hb_glyph_info_t & info , unsigned int flags ) {\n if ( _hb_glyph_info_ligated ( & info ) ) return false ;\n return ! ! ( FLAG ( info . myanmar_category ( ) ) & flags ) ;\n }",
        "output": "1",
        "idx": 2666
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ATF_TP_ADD_TCS ( tp ) {\n ATF_TP_ADD_TC ( tp , option_refcnt ) ;\n return ( atf_no_error ( ) ) ;\n }",
        "output": "1",
        "idx": 3191
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int xmlIsBlank ( unsigned int ch ) {\n return ( xmlIsBlankQ ( ch ) ) ;\n }",
        "output": "0",
        "idx": 2967
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parse_ls ( const char * p , struct branch * b ) {\n struct tree_entry * root = NULL ;\n struct tree_entry leaf = {\n NULL }\n ;\n if ( * p == '\"' ) {\n if ( ! b ) die ( \"Not in a commit: %s\" , command_buf . buf ) ;\n root = & b -> branch_tree ;\n }\n else {\n struct object_entry * e = parse_treeish_dataref ( & p ) ;\n root = new_tree_entry ( ) ;\n hashcpy ( root -> versions [ 1 ] . sha1 , e -> idx . sha1 ) ;\n if ( ! is_null_sha1 ( root -> versions [ 1 ] . sha1 ) ) root -> versions [ 1 ] . mode = S_IFDIR ;\n load_tree ( root ) ;\n }\n if ( * p == '\"' ) {\n static struct strbuf uq = STRBUF_INIT ;\n const char * endp ;\n strbuf_reset ( & uq ) ;\n if ( unquote_c_style ( & uq , p , & endp ) ) die ( \"Invalid path: %s\" , command_buf . buf ) ;\n if ( * endp ) die ( \"Garbage after path in: %s\" , command_buf . buf ) ;\n p = uq . buf ;\n }\n tree_content_get ( root , p , & leaf , 1 ) ;\n if ( S_ISDIR ( leaf . versions [ 1 ] . mode ) ) store_tree ( & leaf ) ;\n print_ls ( leaf . versions [ 1 ] . mode , leaf . versions [ 1 ] . sha1 , p ) ;\n if ( leaf . tree ) release_tree_content_recursive ( leaf . tree ) ;\n if ( ! b || root != & b -> branch_tree ) release_tree_entry ( root ) ;\n }",
        "output": "0",
        "idx": 2134
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t compareMappingsUnicodeFirst ( const void * context , const void * left , const void * right ) {\n return compareMappings ( ( UCMTable * ) context , ( const UCMapping * ) left , ( UCMTable * ) context , ( const UCMapping * ) right , TRUE ) ;\n }",
        "output": "1",
        "idx": 1991
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool e1000e_rx_csum_enabled ( E1000ECore * core ) {\n return ( core -> mac [ RXCSUM ] & E1000_RXCSUM_PCSD ) ? false : true ;\n }",
        "output": "0",
        "idx": 3158
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void memshl ( register int32_t * a , register int32_t * b ) {\n * a ++ = * b ++ ;\n * a ++ = * b ++ ;\n * a ++ = * b ++ ;\n * a ++ = * b ++ ;\n * a ++ = * b ++ ;\n * a ++ = * b ++ ;\n * a ++ = * b ++ ;\n * a = * b ;\n }",
        "output": "0",
        "idx": 202
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_P ( GLES2DecoderTestWithCHROMIUMPathRendering , MatrixLoadfCHROMIUMImmediateValidArgs ) {\n cmds : : MatrixLoadfCHROMIUMImmediate & cmd = * GetImmediateAs < cmds : : MatrixLoadfCHROMIUMImmediate > ( ) ;\n SpecializedSetup < cmds : : MatrixLoadfCHROMIUMImmediate , 0 > ( true ) ;\n GLfloat temp [ 16 ] = {\n 0 , }\n ;\n cmd . Init ( GL_PATH_PROJECTION_CHROMIUM , & temp [ 0 ] ) ;\n EXPECT_CALL ( * gl_ , MatrixLoadfEXT ( GL_PATH_PROJECTION_CHROMIUM , reinterpret_cast < GLfloat * > ( ImmediateDataAddress ( & cmd ) ) ) ) ;\n EXPECT_EQ ( error : : kNoError , ExecuteImmediateCmd ( cmd , sizeof ( temp ) ) ) ;\n EXPECT_EQ ( GL_NO_ERROR , GetGLError ( ) ) ;\n }",
        "output": "1",
        "idx": 2772
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void spl_filesystem_info_set_filename ( spl_filesystem_object * intern , char * path , int len , int use_copy TSRMLS_DC ) {\n char * p1 , * p2 ;\n if ( intern -> file_name ) {\n efree ( intern -> file_name ) ;\n }\n intern -> file_name = use_copy ? estrndup ( path , len ) : path ;\n intern -> file_name_len = len ;\n while ( IS_SLASH_AT ( intern -> file_name , intern -> file_name_len - 1 ) && intern -> file_name_len > 1 ) {\n intern -> file_name [ intern -> file_name_len - 1 ] = 0 ;\n intern -> file_name_len -- ;\n }\n p1 = strrchr ( intern -> file_name , '/' ) ;\n # if defined ( PHP_WIN32 ) || defined ( NETWARE ) p2 = strrchr ( intern -> file_name , '\\\\' ) ;\n # else p2 = 0 ;\n # endif if ( p1 || p2 ) {\n intern -> _path_len = ( p1 > p2 ? p1 : p2 ) - intern -> file_name ;\n }\n else {\n intern -> _path_len = 0 ;\n }\n if ( intern -> _path ) {\n efree ( intern -> _path ) ;\n }\n intern -> _path = estrndup ( path , intern -> _path_len ) ;\n }",
        "output": "1",
        "idx": 2328
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void e1000e_set_rx_control ( E1000ECore * core , int index , uint32_t val ) {\n core -> mac [ RCTL ] = val ;\n trace_e1000e_rx_set_rctl ( core -> mac [ RCTL ] ) ;\n if ( val & E1000_RCTL_EN ) {\n e1000e_parse_rxbufsize ( core ) ;\n e1000e_calc_rxdesclen ( core ) ;\n core -> rxbuf_min_shift = ( ( val / E1000_RCTL_RDMTS_QUAT ) & 3 ) + 1 + E1000_RING_DESC_LEN_SHIFT ;\n e1000e_start_recv ( core ) ;\n }\n }",
        "output": "0",
        "idx": 313
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void voutf ( struct GlobalConfig * config , const char * prefix , const char * fmt , va_list ap ) {\n size_t width = ( 79 - strlen ( prefix ) ) ;\n if ( ! config -> mute ) {\n size_t len ;\n char * ptr ;\n char * print_buffer ;\n print_buffer = curlx_mvaprintf ( fmt , ap ) ;\n if ( ! print_buffer ) return ;\n len = strlen ( print_buffer ) ;\n ptr = print_buffer ;\n while ( len > 0 ) {\n fputs ( prefix , config -> errors ) ;\n if ( len > width ) {\n size_t cut = width - 1 ;\n while ( ! ISSPACE ( ptr [ cut ] ) && cut ) {\n cut -- ;\n }\n if ( 0 == cut ) cut = width - 1 ;\n ( void ) fwrite ( ptr , cut + 1 , 1 , config -> errors ) ;\n fputs ( \"\\n\" , config -> errors ) ;\n ptr += cut + 1 ;\n len -= cut ;\n }\n else {\n fputs ( ptr , config -> errors ) ;\n len = 0 ;\n }\n }\n curl_free ( print_buffer ) ;\n }\n }",
        "output": "1",
        "idx": 4365
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlHashTablePtr xmlHashCopy ( xmlHashTablePtr table , xmlHashCopier f ) {\n int i ;\n xmlHashEntryPtr iter ;\n xmlHashEntryPtr next ;\n xmlHashTablePtr ret ;\n if ( table == NULL ) return ( NULL ) ;\n if ( f == NULL ) return ( NULL ) ;\n ret = xmlHashCreate ( table -> size ) ;\n if ( table -> table ) {\n for ( i = 0 ;\n i < table -> size ;\n i ++ ) {\n if ( table -> table [ i ] . valid == 0 ) continue ;\n iter = & ( table -> table [ i ] ) ;\n while ( iter ) {\n next = iter -> next ;\n xmlHashAddEntry3 ( ret , iter -> name , iter -> name2 , iter -> name3 , f ( iter -> payload , iter -> name ) ) ;\n iter = next ;\n }\n }\n }\n ret -> nbElems = table -> nbElems ;\n return ( ret ) ;\n }",
        "output": "1",
        "idx": 48
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PREDICTION_MODE read_intra_mode ( vp9_reader * r , const vp9_prob * p ) {\n return ( PREDICTION_MODE ) vp9_read_tree ( r , vp9_intra_mode_tree , p ) ;\n }",
        "output": "0",
        "idx": 1363
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ber_decode_as_dt ( const gchar * table_name _U_ , ftenum_t selector_type _U_ , gpointer key , gpointer value , gpointer user_data ) {\n da_data * decode_as_data ;\n decode_as_data = ( da_data * ) user_data ;\n decode_as_data -> func ( key , value , decode_as_data -> user_data ) ;\n }",
        "output": "0",
        "idx": 3050
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_rsl_ie_smscb_mess ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , int offset , gboolean is_mandatory ) {\n proto_item * ti ;\n proto_tree * ie_tree ;\n tvbuff_t * next_tvb ;\n guint length ;\n guint8 ie_id ;\n int ie_offset ;\n if ( is_mandatory == FALSE ) {\n ie_id = tvb_get_guint8 ( tvb , offset ) ;\n if ( ie_id != RSL_IE_SMSCB_MESS ) return offset ;\n }\n ie_tree = proto_tree_add_subtree ( tree , tvb , offset , 0 , ett_ie_smscb_mess , & ti , \"SMSCB Message IE\" ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_id , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n length = tvb_get_guint8 ( tvb , offset ) ;\n proto_item_set_len ( ti , length + 2 ) ;\n proto_tree_add_item ( ie_tree , hf_rsl_ie_length , tvb , offset , 1 , ENC_BIG_ENDIAN ) ;\n offset ++ ;\n ie_offset = offset ;\n next_tvb = tvb_new_subset_length ( tvb , offset , length ) ;\n call_dissector ( gsm_cbs_handle , next_tvb , pinfo , top_tree ) ;\n offset = ie_offset + length ;\n return offset ;\n }",
        "output": "0",
        "idx": 1007
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( ProfileBrowserTest , URLFetcherUsingMediaContextDuringShutdown ) {\n StartActiveFetcherDuringProfileShutdownTest ( content : : BrowserContext : : GetDefaultStoragePartition ( browser ( ) -> profile ( ) ) -> GetMediaURLRequestContext ( ) ) ;\n }",
        "output": "1",
        "idx": 2786
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nlm_msg_res_unmatched_value_destroy ( gpointer value ) {\n nlm_msg_res_unmatched_data * umd = ( nlm_msg_res_unmatched_data * ) value ;\n g_free ( ( gpointer ) umd -> cookie ) ;\n g_free ( umd ) ;\n }",
        "output": "1",
        "idx": 3788
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tgq_idct_put_mb ( TgqContext * s , int16_t ( * block ) [ 64 ] , int mb_x , int mb_y ) {\n int linesize = s -> frame . linesize [ 0 ] ;\n uint8_t * dest_y = s -> frame . data [ 0 ] + ( mb_y * 16 * linesize ) + mb_x * 16 ;\n uint8_t * dest_cb = s -> frame . data [ 1 ] + ( mb_y * 8 * s -> frame . linesize [ 1 ] ) + mb_x * 8 ;\n uint8_t * dest_cr = s -> frame . data [ 2 ] + ( mb_y * 8 * s -> frame . linesize [ 2 ] ) + mb_x * 8 ;\n ff_ea_idct_put_c ( dest_y , linesize , block [ 0 ] ) ;\n ff_ea_idct_put_c ( dest_y + 8 , linesize , block [ 1 ] ) ;\n ff_ea_idct_put_c ( dest_y + 8 * linesize , linesize , block [ 2 ] ) ;\n ff_ea_idct_put_c ( dest_y + 8 * linesize + 8 , linesize , block [ 3 ] ) ;\n if ( ! ( s -> avctx -> flags & CODEC_FLAG_GRAY ) ) {\n ff_ea_idct_put_c ( dest_cb , s -> frame . linesize [ 1 ] , block [ 4 ] ) ;\n ff_ea_idct_put_c ( dest_cr , s -> frame . linesize [ 2 ] , block [ 5 ] ) ;\n }\n }",
        "output": "1",
        "idx": 4069
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemuMonitorJSONSavePhysicalMemory ( qemuMonitorPtr mon , unsigned long long offset , size_t length , const char * path ) {\n return qemuMonitorJSONSaveMemory ( mon , \"pmemsave\" , offset , length , path ) ;\n }",
        "output": "0",
        "idx": 797
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vvalue_tvb_vector_internal ( tvbuff_t * tvb , int offset , struct vt_vector * val , struct vtype_data * type , guint num ) {\n const int offset_in = offset ;\n const gboolean varsize = ( type -> size == - 1 ) ;\n const guint elsize = varsize ? ( guint ) sizeof ( struct data_blob ) : ( guint ) type -> size ;\n guint8 * data ;\n int len ;\n guint i ;\n if ( ( guint64 ) elsize * ( guint64 ) num > G_MAXUINT ) {\n THROW ( ReportedBoundsError ) ;\n }\n tvb_ensure_bytes_exist ( tvb , offset , elsize * num ) ;\n data = ( guint8 * ) wmem_alloc ( wmem_packet_scope ( ) , elsize * num ) ;\n val -> len = num ;\n val -> u . vt_ui1 = data ;\n DISSECTOR_ASSERT ( ( void * ) & val -> u == ( ( void * ) & val -> u . vt_ui1 ) ) ;\n for ( i = 0 ;\n i < num ;\n i ++ ) {\n DISSECTOR_ASSERT_HINT ( type -> tvb_get != 0 , \"type that we don't know yet how to handle, please submit a bug with trace\" ) ;\n len = type -> tvb_get ( tvb , offset , data ) ;\n data += elsize ;\n offset += len ;\n if ( varsize && ( offset % 4 ) ) {\n int padding = 4 - ( offset % 4 ) ;\n offset += padding ;\n }\n }\n return offset - offset_in ;\n }",
        "output": "0",
        "idx": 623
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void move_file_to_low_priority_queue ( NautilusDirectory * directory , NautilusFile * file ) {\n nautilus_file_queue_enqueue ( directory -> details -> low_priority_queue , file ) ;\n nautilus_file_queue_remove ( directory -> details -> high_priority_queue , file ) ;\n }",
        "output": "0",
        "idx": 1090
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void pxa2xx_rtc_swal1_tick ( void * opaque ) {\n PXA2xxRTCState * s = ( PXA2xxRTCState * ) opaque ;\n s -> rtsr |= ( 1 << 8 ) ;\n pxa2xx_rtc_alarm_update ( s , s -> rtsr ) ;\n pxa2xx_rtc_int_update ( s ) ;\n }",
        "output": "0",
        "idx": 4327
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int BIO_vprintf ( BIO * bio , const char * format , va_list args ) {\n int ret ;\n size_t retlen ;\n char hugebuf [ 1024 * 2 ] ;\n char * hugebufp = hugebuf ;\n size_t hugebufsize = sizeof ( hugebuf ) ;\n char * dynbuf = NULL ;\n int ignored ;\n dynbuf = NULL ;\n CRYPTO_push_info ( \"doapr()\" ) ;\n _dopr ( & hugebufp , & dynbuf , & hugebufsize , & retlen , & ignored , format , args ) ;\n if ( dynbuf ) {\n ret = BIO_write ( bio , dynbuf , ( int ) retlen ) ;\n OPENSSL_free ( dynbuf ) ;\n }\n else {\n ret = BIO_write ( bio , hugebuf , ( int ) retlen ) ;\n }\n CRYPTO_pop_info ( ) ;\n return ( ret ) ;\n }",
        "output": "1",
        "idx": 3669
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "proto_item * parseByte ( proto_tree * tree , tvbuff_t * tvb , packet_info * pinfo _U_ , gint * pOffset , int hfIndex ) {\n proto_item * item = proto_tree_add_item ( tree , hfIndex , tvb , * pOffset , 1 , ENC_LITTLE_ENDIAN ) ;\n * pOffset += 1 ;\n return item ;\n }",
        "output": "0",
        "idx": 2154
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_T_nonCollapsingRaw ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 689 \"../../asn1/h245/h245.cnf\" tvbuff_t * value_tvb ;\n gef_ctx_t * parent_gefx ;\n gef_ctx_t * gefx ;\n parent_gefx = gef_ctx_get ( actx -> private_data ) ;\n actx -> private_data = gef_ctx_alloc ( parent_gefx , \"nonCollapsingRaw\" ) ;\n offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , NO_BOUND , NO_BOUND , FALSE , & value_tvb ) ;\n gefx = gef_ctx_get ( actx -> private_data ) ;\n if ( gefx ) {\n dissector_try_string ( gef_content_dissector_table , gefx -> key , value_tvb , actx -> pinfo , tree , actx ) ;\n }\n actx -> private_data = parent_gefx ;\n return offset ;\n }",
        "output": "0",
        "idx": 3793
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char * proto_get_protocol_long_name ( const protocol_t * protocol ) {\n if ( protocol == NULL ) return \"(none)\" ;\n return protocol -> name ;\n }",
        "output": "0",
        "idx": 4137
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void handle_raw_data ( char * packet , int len , struct query * q , int dns_fd , int tun_fd , int userid ) {\n if ( check_user_and_ip ( userid , q ) != 0 ) {\n return ;\n }\n users [ userid ] . last_pkt = time ( NULL ) ;\n memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n users [ userid ] . inpacket . offset = 0 ;\n memcpy ( users [ userid ] . inpacket . data , packet , len ) ;\n users [ userid ] . inpacket . len = len ;\n if ( debug >= 1 ) {\n fprintf ( stderr , \"IN pkt raw, total %d, from user %d\\n\" , users [ userid ] . inpacket . len , userid ) ;\n }\n handle_full_packet ( tun_fd , dns_fd , userid ) ;\n }",
        "output": "1",
        "idx": 940
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_iht16x16_256_add_c ( const int16_t * input , uint8_t * dest , int stride , int tx_type ) {\n int i , j ;\n int16_t out [ 16 * 16 ] ;\n int16_t * outptr = out ;\n int16_t temp_in [ 16 ] , temp_out [ 16 ] ;\n const transform_2d ht = IHT_16 [ tx_type ] ;\n for ( i = 0 ;\n i < 16 ;\n ++ i ) {\n ht . rows ( input , outptr ) ;\n input += 16 ;\n outptr += 16 ;\n }\n for ( i = 0 ;\n i < 16 ;\n ++ i ) {\n for ( j = 0 ;\n j < 16 ;\n ++ j ) temp_in [ j ] = out [ j * 16 + i ] ;\n ht . cols ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 16 ;\n ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) + dest [ j * stride + i ] ) ;\n }\n }",
        "output": "1",
        "idx": 1775
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipvideo_decode_block_opcode_0x0 ( IpvideoContext * s ) {\n return copy_from ( s , & s -> last_frame , 0 , 0 ) ;\n }",
        "output": "1",
        "idx": 3904
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( DirectoryIterator , isDot ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n RETURN_BOOL ( spl_filesystem_is_dot ( intern -> u . dir . entry . d_name ) ) ;\n }",
        "output": "1",
        "idx": 502
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void array_cleanup ( char * arr [ ] , int arr_size ) {\n int i = 0 ;\n for ( i = 0 ;\n i < arr_size ;\n i ++ ) {\n if ( arr [ i * 2 ] ) {\n efree ( arr [ i * 2 ] ) ;\n }\n }\n efree ( arr ) ;\n }",
        "output": "0",
        "idx": 3572
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char * ContentTypeForFilename ( const char * filename , const char * prevtype ) {\n const char * contenttype = NULL ;\n unsigned int i ;\n struct ContentType {\n const char * extension ;\n const char * type ;\n }\n ;\n static const struct ContentType ctts [ ] = {\n {\n \".gif\" , \"image/gif\" }\n , {\n \".jpg\" , \"image/jpeg\" }\n , {\n \".jpeg\" , \"image/jpeg\" }\n , {\n \".txt\" , \"text/plain\" }\n , {\n \".html\" , \"text/html\" }\n , {\n \".xml\" , \"application/xml\" }\n }\n ;\n if ( prevtype ) contenttype = prevtype ;\n else contenttype = HTTPPOST_CONTENTTYPE_DEFAULT ;\n if ( filename ) {\n for ( i = 0 ;\n i < sizeof ( ctts ) / sizeof ( ctts [ 0 ] ) ;\n i ++ ) {\n if ( strlen ( filename ) >= strlen ( ctts [ i ] . extension ) ) {\n if ( strequal ( filename + strlen ( filename ) - strlen ( ctts [ i ] . extension ) , ctts [ i ] . extension ) ) {\n contenttype = ctts [ i ] . type ;\n break ;\n }\n }\n }\n }\n return contenttype ;\n }",
        "output": "0",
        "idx": 2783
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean confirm_empty_trash ( CommonJob * job ) {\n char * prompt ;\n int response ;\n if ( ! should_confirm_trash ( ) ) {\n return TRUE ;\n }\n prompt = f ( _ ( \"Empty all items from Trash?\" ) ) ;\n response = run_warning ( job , prompt , f ( _ ( \"All items in the Trash will be permanently deleted.\" ) ) , NULL , FALSE , CANCEL , _ ( \"Empty _Trash\" ) , NULL ) ;\n return ( response == 1 ) ;\n }",
        "output": "0",
        "idx": 599
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ber_check_value64 ( gint64 value , gint64 min_len , gint64 max_len , asn1_ctx_t * actx , proto_item * item ) {\n if ( ( min_len != - 1 ) && ( value < min_len ) ) {\n expert_add_info_format ( actx -> pinfo , item , & ei_ber_size_constraint_value , \"Size constraint: value too small: %\" G_GINT64_MODIFIER \"d (%\" G_GINT64_MODIFIER \"d .. %\" G_GINT64_MODIFIER \"d)\" , value , min_len , max_len ) ;\n }\n else if ( ( max_len != - 1 ) && ( value > max_len ) ) {\n expert_add_info_format ( actx -> pinfo , item , & ei_ber_size_constraint_value , \"Size constraint: value too big: %\" G_GINT64_MODIFIER \"d (%\" G_GINT64_MODIFIER \"d .. %\" G_GINT64_MODIFIER \"d)\" , value , min_len , max_len ) ;\n }\n }",
        "output": "0",
        "idx": 2555
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int all_vcpus_paused ( void ) {\n CPUArchState * penv = first_cpu ;\n while ( penv ) {\n CPUState * pcpu = ENV_GET_CPU ( penv ) ;\n if ( ! pcpu -> stopped ) {\n return 0 ;\n }\n penv = penv -> next_cpu ;\n }\n return 1 ;\n }",
        "output": "0",
        "idx": 1730
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern rtype gnu_dev_ ## name proto __THROW __attribute_const__ ;\n # define __SYSMACROS_IMPL_TEMPL ( rtype , name , proto ) __extension__ __extern_inline __attribute_const__ rtype __NTH ( gnu_dev_ ## name proto ) __BEGIN_DECLS __SYSMACROS_DECLARE_MAJOR ( __SYSMACROS_DECL_TEMPL ) __SYSMACROS_DECLARE_MINOR ( __SYSMACROS_DECL_TEMPL )",
        "output": "1",
        "idx": 1792
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_AdmissionRejectReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 657 \"./asn1/h225/h225.cnf\" gint32 value ;\n h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_AdmissionRejectReason , AdmissionRejectReason_choice , & value ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> reason = value ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 425
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gint round_to_4byte ( gint current_offset , gint starting_offset ) {\n gint length = current_offset - starting_offset ;\n return starting_offset + ROUND_TO_4BYTE ( length ) ;\n }",
        "output": "0",
        "idx": 3953
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( SingleClientSessionsSyncTest , TimestampMatchesHistory ) {\n ASSERT_TRUE ( SetupSync ( ) ) << \"SetupSync() failed.\" ;\n ASSERT_TRUE ( CheckInitialState ( 0 ) ) ;\n const GURL url ( \"about:version\" ) ;\n ScopedWindowMap windows ;\n ASSERT_TRUE ( OpenTabAndGetLocalWindows ( 0 , url , windows . GetMutable ( ) ) ) ;\n int found_navigations = 0 ;\n for ( SessionWindowMap : : const_iterator it = windows . Get ( ) -> begin ( ) ;\n it != windows . Get ( ) -> end ( ) ;\n ++ it ) {\n for ( std : : vector < sessions : : SessionTab * > : : const_iterator it2 = it -> second -> tabs . begin ( ) ;\n it2 != it -> second -> tabs . end ( ) ;\n ++ it2 ) {\n for ( std : : vector < sessions : : SerializedNavigationEntry > : : const_iterator it3 = ( * it2 ) -> navigations . begin ( ) ;\n it3 != ( * it2 ) -> navigations . end ( ) ;\n ++ it3 ) {\n const base : : Time timestamp = it3 -> timestamp ( ) ;\n history : : URLRow virtual_row ;\n ASSERT_TRUE ( GetUrlFromClient ( 0 , it3 -> virtual_url ( ) , & virtual_row ) ) ;\n const base : : Time history_timestamp = virtual_row . last_visit ( ) ;\n ASSERT_EQ ( timestamp , history_timestamp ) ;\n ++ found_navigations ;\n }\n }\n }\n ASSERT_EQ ( 1 , found_navigations ) ;\n }",
        "output": "1",
        "idx": 901
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlChar * xsltEvalAttrValueTemplate ( xsltTransformContextPtr ctxt , xmlNodePtr inst , const xmlChar * name , const xmlChar * ns ) {\n xmlChar * ret ;\n xmlChar * expr ;\n if ( ( ctxt == NULL ) || ( inst == NULL ) || ( name == NULL ) ) return ( NULL ) ;\n expr = xsltGetNsProp ( inst , name , ns ) ;\n if ( expr == NULL ) return ( NULL ) ;\n ret = xsltAttrTemplateValueProcessNode ( ctxt , expr , inst ) ;\n # ifdef WITH_XSLT_DEBUG_TEMPLATES XSLT_TRACE ( ctxt , XSLT_TRACE_TEMPLATES , xsltGenericDebug ( xsltGenericDebugContext , \"xsltEvalAttrValueTemplate: %s returns %s\\n\" , expr , ret ) ) ;\n # endif if ( expr != NULL ) xmlFree ( expr ) ;\n return ( ret ) ;\n }",
        "output": "1",
        "idx": 372
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void interpolate_isp ( double isp_q [ 4 ] [ LP_ORDER ] , const double * isp4_past ) {\n int i , k ;\n for ( k = 0 ;\n k < 3 ;\n k ++ ) {\n float c = isfp_inter [ k ] ;\n for ( i = 0 ;\n i < LP_ORDER ;\n i ++ ) isp_q [ k ] [ i ] = ( 1.0 - c ) * isp4_past [ i ] + c * isp_q [ 3 ] [ i ] ;\n }\n }",
        "output": "0",
        "idx": 786
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int com_charset ( String * buffer __attribute__ ( ( unused ) ) , char * line ) {\n char buff [ 256 ] , * param ;\n CHARSET_INFO * new_cs ;\n strmake_buf ( buff , line ) ;\n param = get_arg ( buff , 0 ) ;\n if ( ! param || ! * param ) {\n return put_info ( \"Usage: \\\\C charset_name | charset charset_name\" , INFO_ERROR , 0 ) ;\n }\n new_cs = get_charset_by_csname ( param , MY_CS_PRIMARY , MYF ( MY_WME ) ) ;\n if ( new_cs ) {\n charset_info = new_cs ;\n mysql_set_character_set ( & mysql , charset_info -> csname ) ;\n default_charset = ( char * ) charset_info -> csname ;\n put_info ( \"Charset changed\" , INFO_INFO ) ;\n }\n else put_info ( \"Charset is not found\" , INFO_INFO ) ;\n return 0 ;\n }",
        "output": "1",
        "idx": 1212
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void SetPixelYellowTraits ( Image * image , const PixelTrait traits ) {\n image -> channel_map [ YellowPixelChannel ] . traits = traits ;\n }",
        "output": "0",
        "idx": 1204
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvm_put_xcrs ( X86CPU * cpu ) {\n CPUX86State * env = & cpu -> env ;\n struct kvm_xcrs xcrs = {\n }\n ;\n if ( ! has_xcrs ) {\n return 0 ;\n }\n xcrs . nr_xcrs = 1 ;\n xcrs . flags = 0 ;\n xcrs . xcrs [ 0 ] . xcr = 0 ;\n xcrs . xcrs [ 0 ] . value = env -> xcr0 ;\n return kvm_vcpu_ioctl ( CPU ( cpu ) , KVM_SET_XCRS , & xcrs ) ;\n }",
        "output": "0",
        "idx": 4326
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipvideo_decode_block_opcode_0x1 ( IpvideoContext * s ) {\n return copy_from ( s , & s -> second_last_frame , 0 , 0 ) ;\n }",
        "output": "1",
        "idx": 2776
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void * xmlHashLookup3 ( xmlHashTablePtr table , const xmlChar * name , const xmlChar * name2 , const xmlChar * name3 ) {\n unsigned long key ;\n xmlHashEntryPtr entry ;\n if ( table == NULL ) return ( NULL ) ;\n if ( name == NULL ) return ( NULL ) ;\n key = xmlHashComputeKey ( table , name , name2 , name3 ) ;\n if ( table -> table [ key ] . valid == 0 ) return ( NULL ) ;\n if ( table -> dict ) {\n for ( entry = & ( table -> table [ key ] ) ;\n entry != NULL ;\n entry = entry -> next ) {\n if ( ( entry -> name == name ) && ( entry -> name2 == name2 ) && ( entry -> name3 == name3 ) ) return ( entry -> payload ) ;\n }\n }\n for ( entry = & ( table -> table [ key ] ) ;\n entry != NULL ;\n entry = entry -> next ) {\n if ( ( xmlStrEqual ( entry -> name , name ) ) && ( xmlStrEqual ( entry -> name2 , name2 ) ) && ( xmlStrEqual ( entry -> name3 , name3 ) ) ) return ( entry -> payload ) ;\n }\n return ( NULL ) ;\n }",
        "output": "1",
        "idx": 3660
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( VirtualKeyboardBrowserTest , AttributesTest ) {\n RunTest ( base : : FilePath ( FILE_PATH_LITERAL ( \"attributes_test.js\" ) ) ) ;\n }",
        "output": "1",
        "idx": 2315
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static xmlLinkPtr xmlListLinkSearch ( xmlListPtr l , void * data ) {\n xmlLinkPtr lk ;\n if ( l == NULL ) return ( NULL ) ;\n lk = xmlListLowerSearch ( l , data ) ;\n if ( lk == l -> sentinel ) return NULL ;\n else {\n if ( l -> linkCompare ( lk -> data , data ) == 0 ) return lk ;\n return NULL ;\n }\n }",
        "output": "1",
        "idx": 219
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void store_coding_context ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int mode_index , int64_t comp_pred_diff [ REFERENCE_MODES ] , const int64_t tx_size_diff [ TX_MODES ] , int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] , int skippable ) {\n MACROBLOCKD * const xd = & x -> e_mbd ;\n ctx -> skip = x -> skip ;\n ctx -> skippable = skippable ;\n ctx -> best_mode_index = mode_index ;\n ctx -> mic = * xd -> mi [ 0 ] ;\n ctx -> single_pred_diff = ( int ) comp_pred_diff [ SINGLE_REFERENCE ] ;\n ctx -> comp_pred_diff = ( int ) comp_pred_diff [ COMPOUND_REFERENCE ] ;\n ctx -> hybrid_pred_diff = ( int ) comp_pred_diff [ REFERENCE_MODE_SELECT ] ;\n vpx_memcpy ( ctx -> tx_rd_diff , tx_size_diff , sizeof ( ctx -> tx_rd_diff ) ) ;\n vpx_memcpy ( ctx -> best_filter_diff , best_filter_diff , sizeof ( * best_filter_diff ) * SWITCHABLE_FILTER_CONTEXTS ) ;\n }",
        "output": "1",
        "idx": 227
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GType hb_gobject_ ## name ## _get_type ( void ) \\ {\n static gsize type_id = 0 ;\n if ( g_once_init_enter ( & type_id ) ) {\n GType id = g_boxed_type_register_static ( g_intern_static_string ( \"hb_\" # name \"_t\" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;\n g_once_init_leave ( & type_id , id ) ;\n }\n return type_id ;\n \\ }\n # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs ) HB_DEFINE_OBJECT_TYPE ( set )",
        "output": "1",
        "idx": 4360
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void initial_reordering ( const hb_ot_shape_plan_t * plan , hb_font_t * font , hb_buffer_t * buffer ) {\n insert_dotted_circles ( plan , font , buffer ) ;\n hb_glyph_info_t * info = buffer -> info ;\n unsigned int count = buffer -> len ;\n if ( unlikely ( ! count ) ) return ;\n unsigned int last = 0 ;\n unsigned int last_syllable = info [ 0 ] . syllable ( ) ;\n for ( unsigned int i = 1 ;\n i < count ;\n i ++ ) if ( last_syllable != info [ i ] . syllable ( ) ) {\n initial_reordering_syllable ( plan , font -> face , buffer , last , i ) ;\n last = i ;\n last_syllable = info [ last ] . syllable ( ) ;\n }\n initial_reordering_syllable ( plan , font -> face , buffer , last , count ) ;\n }",
        "output": "1",
        "idx": 457
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean delete_file_recursively ( GFile * file , GCancellable * cancellable , DeleteCallback callback , gpointer callback_data ) {\n gboolean success ;\n g_autoptr ( GError ) error = NULL ;\n do {\n g_autoptr ( GFileEnumerator ) enumerator = NULL ;\n success = g_file_delete ( file , cancellable , & error ) ;\n if ( success || ! g_error_matches ( error , G_IO_ERROR , G_IO_ERROR_NOT_EMPTY ) ) {\n break ;\n }\n g_clear_error ( & error ) ;\n enumerator = g_file_enumerate_children ( file , G_FILE_ATTRIBUTE_STANDARD_NAME , G_FILE_QUERY_INFO_NONE , cancellable , & error ) ;\n if ( enumerator ) {\n GFileInfo * info ;\n success = TRUE ;\n info = g_file_enumerator_next_file ( enumerator , cancellable , & error ) ;\n while ( info != NULL ) {\n g_autoptr ( GFile ) child = NULL ;\n child = g_file_enumerator_get_child ( enumerator , info ) ;\n success = success && delete_file_recursively ( child , cancellable , callback , callback_data ) ;\n g_object_unref ( info ) ;\n info = g_file_enumerator_next_file ( enumerator , cancellable , & error ) ;\n }\n }\n if ( error != NULL ) {\n success = FALSE ;\n }\n }\n while ( success ) ;\n if ( callback ) {\n callback ( file , error , callback_data ) ;\n }\n return success ;\n }",
        "output": "0",
        "idx": 1352
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char * remove_leading_slash ( const char * p ) {\n const char * rp ;\n if ( ( p [ 0 ] == '/' || p [ 0 ] == '\\\\' ) && ( p [ 1 ] == '/' || p [ 1 ] == '\\\\' ) && ( p [ 2 ] == '.' || p [ 2 ] == '?' ) && ( p [ 3 ] == '/' || p [ 3 ] == '\\\\' ) ) {\n if ( p [ 2 ] == '?' && ( p [ 4 ] == 'U' || p [ 4 ] == 'u' ) && ( p [ 5 ] == 'N' || p [ 5 ] == 'n' ) && ( p [ 6 ] == 'C' || p [ 6 ] == 'c' ) && ( p [ 7 ] == '/' || p [ 7 ] == '\\\\' ) ) p += 8 ;\n else p += 4 ;\n }\n do {\n rp = p ;\n if ( ( ( p [ 0 ] >= 'a' && p [ 0 ] <= 'z' ) || ( p [ 0 ] >= 'A' && p [ 0 ] <= 'Z' ) ) && p [ 1 ] == ':' ) {\n p += 2 ;\n }\n while ( p [ 0 ] == '/' || p [ 0 ] == '\\\\' ) {\n if ( p [ 1 ] == '.' && p [ 2 ] == '.' && ( p [ 3 ] == '/' || p [ 3 ] == '\\\\' ) ) {\n p += 3 ;\n }\n else p += 1 ;\n }\n }\n while ( rp != p ) ;\n return ( p ) ;\n }",
        "output": "0",
        "idx": 3512
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;\n __exctype_l ( isalpha_l ) ;\n __exctype_l ( iscntrl_l ) ;\n __exctype_l ( isdigit_l ) ;\n __exctype_l ( islower_l ) ;\n __exctype_l ( isgraph_l ) ;\n __exctype_l ( isprint_l ) ;\n __exctype_l ( ispunct_l ) ;\n __exctype_l ( isspace_l ) ;\n __exctype_l ( isupper_l ) ;\n __exctype_l ( isxdigit_l )",
        "output": "1",
        "idx": 4120
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct mszipd_stream * mszipd_init ( struct mspack_system * system , struct mspack_file * input , struct mspack_file * output , int input_buffer_size , int repair_mode ) {\n struct mszipd_stream * zip ;\n if ( ! system ) return NULL ;\n input_buffer_size = ( input_buffer_size + 1 ) & - 2 ;\n if ( ! input_buffer_size ) return NULL ;\n if ( ! ( zip = ( struct mszipd_stream * ) system -> alloc ( system , sizeof ( struct mszipd_stream ) ) ) ) {\n return NULL ;\n }\n zip -> inbuf = ( unsigned char * ) system -> alloc ( system , ( size_t ) input_buffer_size ) ;\n if ( ! zip -> inbuf ) {\n system -> free ( zip ) ;\n return NULL ;\n }\n zip -> sys = system ;\n zip -> input = input ;\n zip -> output = output ;\n zip -> inbuf_size = input_buffer_size ;\n zip -> input_end = 0 ;\n zip -> error = MSPACK_ERR_OK ;\n zip -> repair_mode = repair_mode ;\n zip -> flush_window = & mszipd_flush_window ;\n zip -> i_ptr = zip -> i_end = & zip -> inbuf [ 0 ] ;\n zip -> o_ptr = zip -> o_end = NULL ;\n zip -> bit_buffer = 0 ;\n zip -> bits_left = 0 ;\n return zip ;\n }",
        "output": "1",
        "idx": 3521
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_tokenize_sb ( VP9_COMP * cpi , TOKENEXTRA * * t , int dry_run , BLOCK_SIZE bsize ) {\n VP9_COMMON * const cm = & cpi -> common ;\n MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;\n MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;\n TOKENEXTRA * t_backup = * t ;\n const int ctx = vp9_get_skip_context ( xd ) ;\n const int skip_inc = ! vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ;\n struct tokenize_b_args arg = {\n cpi , xd , t }\n ;\n if ( mbmi -> skip ) {\n if ( ! dry_run ) cm -> counts . skip [ ctx ] [ 1 ] += skip_inc ;\n reset_skip_context ( xd , bsize ) ;\n if ( dry_run ) * t = t_backup ;\n return ;\n }\n if ( ! dry_run ) {\n cm -> counts . skip [ ctx ] [ 0 ] += skip_inc ;\n vp9_foreach_transformed_block ( xd , bsize , tokenize_b , & arg ) ;\n }\n else {\n vp9_foreach_transformed_block ( xd , bsize , set_entropy_context_b , & arg ) ;\n * t = t_backup ;\n }\n }",
        "output": "1",
        "idx": 2135
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static hb_unicode_combining_class_t hb_ucdn_combining_class ( hb_unicode_funcs_t * ufuncs , hb_codepoint_t unicode , void * user_data HB_UNUSED ) {\n return ( hb_unicode_combining_class_t ) ucdn_get_combining_class ( unicode ) ;\n }",
        "output": "0",
        "idx": 3790
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void build_inter_predictors_for_planes ( MACROBLOCKD * xd , BLOCK_SIZE bsize , int mi_row , int mi_col , int plane_from , int plane_to ) {\n int plane ;\n const int mi_x = mi_col * MI_SIZE ;\n const int mi_y = mi_row * MI_SIZE ;\n for ( plane = plane_from ;\n plane <= plane_to ;\n ++ plane ) {\n const BLOCK_SIZE plane_bsize = get_plane_block_size ( bsize , & xd -> plane [ plane ] ) ;\n const int num_4x4_w = num_4x4_blocks_wide_lookup [ plane_bsize ] ;\n const int num_4x4_h = num_4x4_blocks_high_lookup [ plane_bsize ] ;\n const int bw = 4 * num_4x4_w ;\n const int bh = 4 * num_4x4_h ;\n if ( xd -> mi [ 0 ] -> mbmi . sb_type < BLOCK_8X8 ) {\n int i = 0 , x , y ;\n assert ( bsize == BLOCK_8X8 ) ;\n for ( y = 0 ;\n y < num_4x4_h ;\n ++ y ) for ( x = 0 ;\n x < num_4x4_w ;\n ++ x ) build_inter_predictors ( xd , plane , i ++ , bw , bh , * x , 4 * y , 4 , 4 , mi_x , mi_y ) ;\n }\n else {\n build_inter_predictors ( xd , plane , 0 , bw , bh , 0 , 0 , bw , bh , mi_x , mi_y ) ;\n }\n }\n }",
        "output": "1",
        "idx": 1033
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vga_draw_line15_le ( VGACommonState * s1 , uint8_t * d , const uint8_t * s , int width ) {\n int w ;\n uint32_t v , r , g , b ;\n w = width ;\n do {\n v = lduw_le_p ( ( void * ) s ) ;\n r = ( v >> 7 ) & 0xf8 ;\n g = ( v >> 2 ) & 0xf8 ;\n b = ( v << 3 ) & 0xf8 ;\n ( ( uint32_t * ) d ) [ 0 ] = rgb_to_pixel32 ( r , g , b ) ;\n s += 2 ;\n d += 4 ;\n }\n while ( -- w != 0 ) ;\n }",
        "output": "1",
        "idx": 1415
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void keydb_release ( KEYDB_HANDLE hd ) {\n int i ;\n if ( ! hd ) return ;\n assert ( active_handles > 0 ) ;\n active_handles -- ;\n unlock_all ( hd ) ;\n for ( i = 0 ;\n i < hd -> used ;\n i ++ ) {\n switch ( hd -> active [ i ] . type ) {\n case KEYDB_RESOURCE_TYPE_NONE : break ;\n case KEYDB_RESOURCE_TYPE_KEYRING : keyring_release ( hd -> active [ i ] . u . kr ) ;\n break ;\n case KEYDB_RESOURCE_TYPE_KEYBOX : keybox_release ( hd -> active [ i ] . u . kb ) ;\n break ;\n }\n }\n xfree ( hd ) ;\n }",
        "output": "0",
        "idx": 585
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dissect_h225_GenericIdentifier ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 848 \"./asn1/h225/h225.cnf\" gef_ctx_t * gefx ;\n proto_item * ti ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_GenericIdentifier , GenericIdentifier_choice , NULL ) ;\n # line 851 \"./asn1/h225/h225.cnf\" gef_ctx_update_key ( gef_ctx_get ( actx -> private_data ) ) ;\n gefx = gef_ctx_get ( actx -> private_data ) ;\n if ( gefx ) {\n ti = proto_tree_add_string ( tree , hf_h225_debug_dissector_try_string , tvb , offset >> 3 , 0 , gefx -> key ) ;\n PROTO_ITEM_SET_HIDDEN ( ti ) ;\n dissector_try_string ( gef_name_dissector_table , gefx -> key , tvb_new_subset ( tvb , offset >> 3 , 0 , 0 ) , actx -> pinfo , tree , actx ) ;\n }\n actx -> private_data = gefx ;\n return offset ;\n }",
        "output": "1",
        "idx": 1910
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , SameOrigin_Https ) {\n StartHttpsServer ( false ) ;\n NavigateTwiceInTabAndClose ( https_test_server_ -> GetURL ( \"/simple.html\" ) , https_test_server_ -> GetURL ( \"/empty.html\" ) ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 0 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 2 ) ;\n FakeUserMetricsUpload ( ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementSessionPercentage , 1 ) ;\n int32_t ratio_bucket = histogram_tester_ . GetAllSamples ( internal : : kHttpsEngagementSessionPercentage ) [ 0 ] . min ;\n EXPECT_EQ ( 100 , ratio_bucket ) ;\n }",
        "output": "0",
        "idx": 2787
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void extend_to_full_distribution ( vp9_prob * probs , vp9_prob p ) {\n vpx_memcpy ( probs , vp9_pareto8_full [ p = 0 ? 0 : p - 1 ] , MODEL_NODES * sizeof ( vp9_prob ) ) ;\n }",
        "output": "0",
        "idx": 1264
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int remoteStreamHandleWriteData ( struct qemud_client * client , struct qemud_client_stream * stream , struct qemud_client_message * msg ) {\n remote_error rerr ;\n int ret ;\n VIR_DEBUG ( \"stream=%p proc=%d serial=%d len=%d offset=%d\" , stream , msg -> hdr . proc , msg -> hdr . serial , msg -> bufferLength , msg -> bufferOffset ) ;\n memset ( & rerr , 0 , sizeof rerr ) ;\n ret = virStreamSend ( stream -> st , msg -> buffer + msg -> bufferOffset , msg -> bufferLength - msg -> bufferOffset ) ;\n if ( ret > 0 ) {\n msg -> bufferOffset += ret ;\n if ( msg -> bufferOffset < msg -> bufferLength ) return 1 ;\n }\n else if ( ret == - 2 ) {\n return 1 ;\n }\n else {\n VIR_INFO0 ( \"Stream send failed\" ) ;\n stream -> closed = 1 ;\n remoteDispatchConnError ( & rerr , client -> conn ) ;\n return remoteSerializeReplyError ( client , & rerr , & msg -> hdr ) ;\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 2645
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( FullscreenControllerStateUnitTest , ExitTabFullscreenViaReplacingTab ) {\n AddTab ( browser ( ) , GURL ( url : : kAboutBlankURL ) ) ;\n ASSERT_TRUE ( InvokeEvent ( TAB_FULLSCREEN_TRUE ) ) ;\n ASSERT_TRUE ( InvokeEvent ( WINDOW_CHANGE ) ) ;\n ASSERT_TRUE ( browser ( ) -> window ( ) -> IsFullscreen ( ) ) ;\n content : : WebContents * new_web_contents = content : : WebContents : : Create ( content : : WebContents : : CreateParams ( profile ( ) ) ) ;\n scoped_ptr < content : : WebContents > old_web_contents ( browser ( ) -> tab_strip_model ( ) -> ReplaceWebContentsAt ( 0 , new_web_contents ) ) ;\n ChangeWindowFullscreenState ( ) ;\n EXPECT_FALSE ( browser ( ) -> window ( ) -> IsFullscreen ( ) ) ;\n }",
        "output": "0",
        "idx": 389
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vmmouse_set_data ( const uint32_t * data ) {\n CPUX86State * env = cpu_single_env ;\n env -> regs [ R_EAX ] = data [ 0 ] ;\n env -> regs [ R_EBX ] = data [ 1 ] ;\n env -> regs [ R_ECX ] = data [ 2 ] ;\n env -> regs [ R_EDX ] = data [ 3 ] ;\n env -> regs [ R_ESI ] = data [ 4 ] ;\n env -> regs [ R_EDI ] = data [ 5 ] ;\n }",
        "output": "1",
        "idx": 2966
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_DisengageReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 636 \"./asn1/h225/h225.cnf\" gint32 value ;\n h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_DisengageReason , DisengageReason_choice , & value ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> reason = value ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 2642
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t u_printf_count_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n ( void ) handler ;\n ( void ) context ;\n ( void ) formatBundle ;\n int32_t * count = ( int32_t * ) ( args [ 0 ] . ptrValue ) ;\n * count = info -> fWidth ;\n return 0 ;\n }",
        "output": "0",
        "idx": 36
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void initial_reordering_vowel_syllable ( const hb_ot_shape_plan_t * plan , hb_face_t * face , hb_buffer_t * buffer , unsigned int start , unsigned int end ) {\n initial_reordering_consonant_syllable ( plan , face , buffer , start , end ) ;\n }",
        "output": "1",
        "idx": 3063
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean isSignal ( const gchar * signal_str_p , const gchar * signalStr ) {\n gint i ;\n gchar * * resultArray ;\n if ( signalStr == NULL ) return FALSE ;\n if ( ( * signal_str_p == '\\0' ) && ( * signalStr == '\\0' ) ) return TRUE ;\n resultArray = g_strsplit ( signalStr , \",\" , 10 ) ;\n for ( i = 0 ;\n resultArray [ i ] ;\n i ++ ) {\n g_strstrip ( resultArray [ i ] ) ;\n if ( strcmp ( resultArray [ i ] , signal_str_p ) == 0 ) return TRUE ;\n }\n g_strfreev ( resultArray ) ;\n return FALSE ;\n }",
        "output": "0",
        "idx": 3204
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipvideo_decode_block_opcode_0xD ( IpvideoContext * s ) {\n int y ;\n unsigned char P [ 2 ] ;\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n if ( ! ( y & 3 ) ) {\n P [ 0 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n P [ 1 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n }\n memset ( s -> pixel_ptr , P [ 0 ] , 4 ) ;\n memset ( s -> pixel_ptr + 4 , P [ 1 ] , 4 ) ;\n s -> pixel_ptr += s -> stride ;\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 3830
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_flush_tables_read_lock ( MYSQL * mysql_con ) {\n return ( mysql_query_with_error_report ( mysql_con , 0 , ( ( opt_master_data != 0 ) ? \"FLUSH /*!40101 LOCAL */ TABLES\" : \"FLUSH TABLES\" ) ) || mysql_query_with_error_report ( mysql_con , 0 , \"FLUSH TABLES WITH READ LOCK\" ) ) ;\n }",
        "output": "0",
        "idx": 1517
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void evdns_search_add ( const char * domain ) {\n search_postfix_add ( domain ) ;\n }",
        "output": "0",
        "idx": 4038
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ShortcutsProviderTest , DaysAgoMatches ) {\n base : : string16 text ( ASCIIToUTF16 ( \"ago\" ) ) ;\n ExpectedURLs expected_urls ;\n expected_urls . push_back ( ExpectedURLAndAllowedToBeDefault ( \"http://www.daysagotest.com/a.html\" , false ) ) ;\n expected_urls . push_back ( ExpectedURLAndAllowedToBeDefault ( \"http://www.daysagotest.com/b.html\" , false ) ) ;\n expected_urls . push_back ( ExpectedURLAndAllowedToBeDefault ( \"http://www.daysagotest.com/c.html\" , false ) ) ;\n RunShortcutsProviderTest ( provider_ , text , false , expected_urls , \"http://www.daysagotest.com/a.html\" , base : : string16 ( ) ) ;\n }",
        "output": "0",
        "idx": 902
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vmport_ioport_write ( void * opaque , hwaddr addr , uint64_t val , unsigned size ) {\n CPUX86State * env = cpu_single_env ;\n env -> regs [ R_EAX ] = vmport_ioport_read ( opaque , addr , 4 ) ;\n }",
        "output": "1",
        "idx": 3716
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_errors ( ) {\n int rc ;\n MYSQL_RES * result ;\n myheader ( \"test_errors\" ) ;\n mysql_query ( mysql , \"DROP TABLE if exists test_non_exists\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE test_non_exists\" ) ;\n myquery_r ( rc ) ;\n rc = mysql_query ( mysql , \"SHOW ERRORS\" ) ;\n myquery ( rc ) ;\n result = mysql_store_result ( mysql ) ;\n mytest ( result ) ;\n ( void ) my_process_result_set ( result ) ;\n mysql_free_result ( result ) ;\n }",
        "output": "0",
        "idx": 2946
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static hb_language_t * language_reference ( hb_language_t * l ) {\n hb_language_t * c = ( hb_language_t * ) calloc ( 1 , sizeof ( hb_language_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * l ;\n return c ;\n }",
        "output": "1",
        "idx": 1202
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "size_t vpx_svc_get_frame_size ( const SvcContext * svc_ctx ) {\n const SvcInternal * const si = get_const_svc_internal ( svc_ctx ) ;\n if ( svc_ctx == NULL || si == NULL || si -> frame_list == NULL ) return 0 ;\n return si -> frame_list -> size ;\n }",
        "output": "1",
        "idx": 253
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_Avb_type ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_Avb_type , Avb_type_choice , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 2738
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_nlm4_shareres ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) {\n return dissect_nlm_shareres ( tvb , 0 , pinfo , tree , 4 ) ;\n }",
        "output": "0",
        "idx": 1698
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void isofile_free ( struct isofile * file ) {\n struct content * con , * tmp ;\n con = file -> content . next ;\n while ( con != NULL ) {\n tmp = con ;\n con = con -> next ;\n free ( tmp ) ;\n }\n archive_entry_free ( file -> entry ) ;\n archive_string_free ( & ( file -> parentdir ) ) ;\n archive_string_free ( & ( file -> basename ) ) ;\n archive_string_free ( & ( file -> basename_utf16 ) ) ;\n archive_string_free ( & ( file -> symlink ) ) ;\n free ( file ) ;\n }",
        "output": "0",
        "idx": 399
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int jbig2_page_add_result ( Jbig2Ctx * ctx , Jbig2Page * page , Jbig2Image * image , int x , int y , Jbig2ComposeOp op ) {\n if ( page -> image == NULL ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , - 1 , \"page info possibly missing, no image defined\" ) ;\n return 0 ;\n }\n if ( page -> striped ) {\n uint32_t new_height = y + image -> height + page -> end_row ;\n if ( page -> image -> height < new_height ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , - 1 , \"growing page buffer to %d rows \" \"to accomodate new stripe\" , new_height ) ;\n jbig2_image_resize ( ctx , page -> image , page -> image -> width , new_height ) ;\n }\n }\n jbig2_image_compose ( ctx , page -> image , image , x , y + page -> end_row , op ) ;\n return 0 ;\n }",
        "output": "0",
        "idx": 1852
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ExternalProtocolHandlerTest , TestGetBlockStateUnknown ) {\n ExternalProtocolHandler : : BlockState block_state = ExternalProtocolHandler : : GetBlockState ( \"tel\" , profile_ . get ( ) ) ;\n EXPECT_EQ ( ExternalProtocolHandler : : UNKNOWN , block_state ) ;\n EXPECT_TRUE ( local_state_ -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;\n EXPECT_FALSE ( profile_ -> GetPrefs ( ) -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;\n }",
        "output": "1",
        "idx": 246
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TSReturnCode TSMimeHdrFieldValueInt64Set ( TSMBuffer bufp , TSMLoc hdr , TSMLoc field , int idx , int64_t value ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( ( sdk_sanity_check_mime_hdr_handle ( hdr ) == TS_SUCCESS ) || ( sdk_sanity_check_http_hdr_handle ( hdr ) == TS_SUCCESS ) ) ;\n sdk_assert ( sdk_sanity_check_field_handle ( field , hdr ) == TS_SUCCESS ) ;\n if ( ! isWriteable ( bufp ) ) {\n return TS_ERROR ;\n }\n char tmp [ 20 ] ;\n int len = mime_format_int64 ( tmp , value , sizeof ( tmp ) ) ;\n TSMimeFieldValueSet ( bufp , field , idx , tmp , len ) ;\n return TS_SUCCESS ;\n }",
        "output": "0",
        "idx": 77
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_idct32x32_1_add_c ( const int16_t * input , uint8_t * dest , int stride ) {\n int i , j ;\n int a1 ;\n int16_t out = dct_const_round_shift ( input [ 0 ] * cospi_16_64 ) ;\n out = dct_const_round_shift ( out * cospi_16_64 ) ;\n a1 = ROUND_POWER_OF_TWO ( out , 6 ) ;\n for ( j = 0 ;\n j < 32 ;\n ++ j ) {\n for ( i = 0 ;\n i < 32 ;\n ++ i ) dest [ i ] = clip_pixel ( dest [ i ] + a1 ) ;\n dest += stride ;\n }\n }",
        "output": "1",
        "idx": 2595
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_T_subElementList ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 100 \"../../asn1/h245/h245.cnf\" h223_mux_element dummy_me , * parent_me = h223_me ;\n memset ( & dummy_me , 0 , sizeof ( h223_mux_element ) ) ;\n h223_me = & dummy_me ;\n offset = dissect_per_constrained_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h245_T_subElementList , T_subElementList_sequence_of , 2 , 255 , FALSE ) ;\n parent_me -> sublist = dummy_me . next ;\n h223_me = parent_me ;\n h223_me -> vc = 0 ;\n return offset ;\n }",
        "output": "0",
        "idx": 700
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_consumed_bytes ( MpegEncContext * s , int buf_size ) {\n int pos = get_bits_count ( & s -> gb ) >> 3 ;\n if ( pos == 0 ) pos = 1 ;\n if ( pos + 10 > buf_size ) pos = buf_size ;\n return pos ;\n }",
        "output": "0",
        "idx": 3382
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void finish_object ( struct object * obj , const char * name , void * cb_data ) {\n struct rev_list_info * info = cb_data ;\n if ( obj -> type == OBJ_BLOB && ! has_object_file ( & obj -> oid ) ) die ( \"missing blob object '%s'\" , oid_to_hex ( & obj -> oid ) ) ;\n if ( info -> revs -> verify_objects && ! obj -> parsed && obj -> type != OBJ_COMMIT ) parse_object ( obj -> oid . hash ) ;\n }",
        "output": "0",
        "idx": 4452
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GType hb_gobject_ ## name ## _get_type ( void ) \\ {\n static gsize type_id = 0 ;\n if ( g_once_init_enter ( & type_id ) ) {\n GType id = g_boxed_type_register_static ( g_intern_static_string ( \"hb_\" # name \"_t\" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;\n g_once_init_leave ( & type_id , id ) ;\n }\n return type_id ;\n \\ }\n # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs )",
        "output": "1",
        "idx": 2085
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int TS_X509_ALGOR_print_bio ( BIO * bio , const X509_ALGOR * alg ) {\n int i = OBJ_obj2nid ( alg -> algorithm ) ;\n return BIO_printf ( bio , \"Hash Algorithm: %s\\n\" , ( i == NID_undef ) ? \"UNKNOWN\" : OBJ_nid2ln ( i ) ) ;\n }",
        "output": "0",
        "idx": 3593
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean is_mpa_fpdu ( packet_info * pinfo ) {\n conversation_t * conversation = NULL ;\n mpa_state_t * state = NULL ;\n conversation = find_conversation ( pinfo -> num , & pinfo -> src , & pinfo -> dst , pinfo -> ptype , pinfo -> srcport , pinfo -> destport , 0 ) ;\n if ( ! conversation ) {\n return FALSE ;\n }\n state = get_mpa_state ( conversation ) ;\n if ( ! state ) {\n return FALSE ;\n }\n if ( ! state -> full_operation ) {\n return FALSE ;\n }\n if ( pinfo -> num == state -> req_frame_num || pinfo -> num == state -> rep_frame_num ) {\n return FALSE ;\n }\n else {\n return TRUE ;\n }\n }",
        "output": "0",
        "idx": 1883
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Datum ExecEvalRelabelType ( GenericExprState * exprstate , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {\n return ExecEvalExpr ( exprstate -> arg , econtext , isNull , isDone ) ;\n }",
        "output": "0",
        "idx": 4123
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _cmd_window_show_opt ( const char * data , int right ) {\n MAIN_WINDOW_REC * parent ;\n WINDOW_REC * window ;\n if ( * data == '\\0' ) cmd_return_error ( CMDERR_NOT_ENOUGH_PARAMS ) ;\n if ( is_numeric ( data , '\\0' ) ) {\n window = window_find_refnum ( atoi ( data ) ) ;\n if ( window == NULL ) {\n printformat_window ( active_win , MSGLEVEL_CLIENTERROR , TXT_REFNUM_NOT_FOUND , data ) ;\n }\n }\n else {\n window = window_find_item ( active_win -> active_server , data ) ;\n }\n if ( window == NULL || is_window_visible ( window ) ) return ;\n if ( WINDOW_GUI ( window ) -> sticky ) {\n if ( ! settings_get_bool ( \"autounstick_windows\" ) ) {\n printformat_window ( active_win , MSGLEVEL_CLIENTERROR , TXT_CANT_SHOW_STICKY_WINDOWS ) ;\n return ;\n }\n }\n parent = mainwindow_create ( right ) ;\n if ( parent == NULL ) {\n printformat_window ( active_win , MSGLEVEL_CLIENTERROR , TXT_WINDOW_TOO_SMALL ) ;\n return ;\n }\n parent -> active = window ;\n gui_window_reparent ( window , parent ) ;\n if ( settings_get_bool ( \"autostick_split_windows\" ) ) gui_window_set_sticky ( window ) ;\n active_mainwin = NULL ;\n window_set_active ( window ) ;\n }",
        "output": "0",
        "idx": 164
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( WebRtcApprtcBrowserTest , MAYBE_MANUAL_FirefoxApprtcInteropTest ) {\n DetectErrorsInJavaScript ( ) ;\n ASSERT_TRUE ( LaunchApprtcInstanceOnLocalhost ( \"9999\" ) ) ;\n ASSERT_TRUE ( LaunchColliderOnLocalHost ( \"http://localhost:9999\" , \"8089\" ) ) ;\n while ( ! LocalApprtcInstanceIsUp ( ) ) DVLOG ( 1 ) << \"Waiting for AppRTC to come up...\" ;\n GURL room_url = GURL ( \"http://localhost:9999/r/some_room\" \"?wshpp=localhost:8089&wstls=false\" \"&firefox_fake_device=1\" ) ;\n chrome : : AddTabAt ( browser ( ) , GURL ( ) , - 1 , true ) ;\n content : : WebContents * chrome_tab = browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) ;\n PermissionBubbleManager : : FromWebContents ( chrome_tab ) -> set_auto_response_for_test ( PermissionBubbleManager : : ACCEPT_ALL ) ;\n InfoBarResponder infobar_responder ( InfoBarService : : FromWebContents ( chrome_tab ) , InfoBarResponder : : ACCEPT ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , room_url ) ;\n ASSERT_TRUE ( LaunchFirefoxWithUrl ( room_url ) ) ;\n ASSERT_TRUE ( WaitForCallToComeUp ( chrome_tab ) ) ;\n ASSERT_TRUE ( DetectRemoteVideoPlaying ( chrome_tab ) ) ;\n }",
        "output": "1",
        "idx": 2366
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spl_filesystem_dir_it_rewind ( zend_object_iterator * iter TSRMLS_DC ) {\n spl_filesystem_object * object = spl_filesystem_iterator_to_object ( ( spl_filesystem_iterator * ) iter ) ;\n object -> u . dir . index = 0 ;\n if ( object -> u . dir . dirp ) {\n php_stream_rewinddir ( object -> u . dir . dirp ) ;\n }\n spl_filesystem_dir_read ( object TSRMLS_CC ) ;\n }",
        "output": "1",
        "idx": 2330
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void forward_query ( int bind_fd , struct query * q ) {\n char buf [ 64 * 1024 ] ;\n int len ;\n struct fw_query fwq ;\n struct sockaddr_in * myaddr ;\n in_addr_t newaddr ;\n len = dns_encode ( buf , sizeof ( buf ) , q , QR_QUERY , q -> name , strlen ( q -> name ) ) ;\n if ( len < 1 ) {\n warnx ( \"dns_encode doesn't fit\" ) ;\n return ;\n }\n memcpy ( & ( fwq . addr ) , & ( q -> from ) , q -> fromlen ) ;\n fwq . addrlen = q -> fromlen ;\n fwq . id = q -> id ;\n fw_query_put ( & fwq ) ;\n newaddr = inet_addr ( \"127.0.0.1\" ) ;\n myaddr = ( struct sockaddr_in * ) & ( q -> from ) ;\n memcpy ( & ( myaddr -> sin_addr ) , & newaddr , sizeof ( in_addr_t ) ) ;\n myaddr -> sin_port = htons ( bind_port ) ;\n if ( debug >= 2 ) {\n fprintf ( stderr , \"TX: NS reply \\n\" ) ;\n }\n if ( sendto ( bind_fd , buf , len , 0 , ( struct sockaddr * ) & q -> from , q -> fromlen ) <= 0 ) {\n warn ( \"forward query error\" ) ;\n }\n }",
        "output": "0",
        "idx": 4381
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void f_parser ( lua_State * L , void * ud ) {\n int i ;\n Proto * tf ;\n Closure * cl ;\n struct SParser * p = cast ( struct SParser * , ud ) ;\n int c = luaZ_lookahead ( p -> z ) ;\n luaC_checkGC ( L ) ;\n tf = ( ( c == LUA_SIGNATURE [ 0 ] ) ? luaU_undump : luaY_parser ) ( L , p -> z , & p -> buff , p -> name ) ;\n cl = luaF_newLclosure ( L , tf -> nups , hvalue ( gt ( L ) ) ) ;\n cl -> l . p = tf ;\n for ( i = 0 ;\n i < tf -> nups ;\n i ++ ) cl -> l . upvals [ i ] = luaF_newupval ( L ) ;\n setclvalue ( L , L -> top , cl ) ;\n incr_top ( L ) ;\n }",
        "output": "1",
        "idx": 3331
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GType hb_gobject_ ## name ## _get_type ( void ) \\ {\n static gsize type_id = 0 ;\n if ( g_once_init_enter ( & type_id ) ) {\n GType id = g_boxed_type_register_static ( g_intern_static_string ( \"hb_\" # name \"_t\" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;\n g_once_init_leave ( & type_id , id ) ;\n }\n return type_id ;\n \\ }\n # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob ) HB_DEFINE_OBJECT_TYPE ( face ) HB_DEFINE_OBJECT_TYPE ( font ) HB_DEFINE_OBJECT_TYPE ( font_funcs ) HB_DEFINE_OBJECT_TYPE ( set ) HB_DEFINE_OBJECT_TYPE ( shape_plan )",
        "output": "1",
        "idx": 1113
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sbr_qmf_deint_bfly_c ( float * v , const float * src0 , const float * src1 ) {\n int i ;\n for ( i = 0 ;\n i < 64 ;\n i ++ ) {\n v [ i ] = src0 [ i ] - src1 [ 63 - i ] ;\n v [ 127 - i ] = src0 [ i ] + src1 [ 63 - i ] ;\n }\n }",
        "output": "1",
        "idx": 1425
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void useSndTimeout ( socket_handle_t sock ) {\n # ifdef _WIN32 const DWORD socket_timeout = SOCKET_RW_TIMEOUT_MS ;\n setsockopt ( sock , SOL_SOCKET , SO_SNDTIMEO , ( const char * ) & socket_timeout , sizeof ( socket_timeout ) ) ;\n # else const struct timeval socket_timeout = {\n . tv_sec = SOCKET_RW_TIMEOUT_MS / 1000 , . tv_usec = ( SOCKET_RW_TIMEOUT_MS % 1000 ) * 1000 }\n ;\n setsockopt ( sock , SOL_SOCKET , SO_SNDTIMEO , & socket_timeout , sizeof ( socket_timeout ) ) ;\n # endif }",
        "output": "0",
        "idx": 892
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void update_remote_info_refs ( struct remote_lock * lock ) {\n struct buffer buffer = {\n STRBUF_INIT , 0 }\n ;\n struct active_request_slot * slot ;\n struct slot_results results ;\n struct curl_slist * dav_headers ;\n remote_ls ( \"refs/\" , ( PROCESS_FILES | RECURSIVE ) , add_remote_info_ref , & buffer . buf ) ;\n if ( ! aborted ) {\n dav_headers = get_dav_token_headers ( lock , DAV_HEADER_IF ) ;\n slot = get_active_slot ( ) ;\n slot -> results = & results ;\n curl_setup_http ( slot -> curl , lock -> url , DAV_PUT , & buffer , fwrite_null ) ;\n curl_easy_setopt ( slot -> curl , CURLOPT_HTTPHEADER , dav_headers ) ;\n if ( start_active_slot ( slot ) ) {\n run_active_slot ( slot ) ;\n if ( results . curl_result != CURLE_OK ) {\n fprintf ( stderr , \"PUT error: curl result=%d, HTTP code=%ld\\n\" , results . curl_result , results . http_code ) ;\n }\n }\n }\n strbuf_release ( & buffer . buf ) ;\n }",
        "output": "0",
        "idx": 1722
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char * _UTF7GetName ( const UConverter * cnv ) {\n switch ( cnv -> fromUnicodeStatus >> 28 ) {\n case 1 : return \"UTF-7,version=1\" ;\n default : return \"UTF-7\" ;\n }\n }",
        "output": "1",
        "idx": 2382
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ScoredHistoryMatchTest , ScoringTLD ) {\n base : : Time now = base : : Time : : NowFromSystemTime ( ) ;\n std : : string url_string ( \"http://fedcba.com/\" ) ;\n const GURL url ( url_string ) ;\n history : : URLRow row ( MakeURLRow ( url_string . c_str ( ) , \"\" , 8 , 3 , 1 ) ) ;\n RowWordStarts word_starts ;\n PopulateWordStarts ( row , & word_starts ) ;\n WordStarts two_words_no_offsets ( 2 , 0u ) ;\n VisitInfoVector visits = CreateVisitInfoVector ( 8 , 3 , now ) ;\n ScoredHistoryMatch scored ( row , visits , std : : string ( ) , ASCIIToUTF16 ( \"fed com\" ) , Make2Terms ( \"fed\" , \"com\" ) , two_words_no_offsets , word_starts , false , nullptr , now ) ;\n EXPECT_EQ ( 0 , scored . raw_score ) ;\n base : : AutoReset < bool > reset ( & ScoredHistoryMatch : : allow_tld_matches_ , true ) ;\n ScoredHistoryMatch scored_with_tld ( row , visits , std : : string ( ) , ASCIIToUTF16 ( \"fed com\" ) , Make2Terms ( \"fed\" , \"com\" ) , two_words_no_offsets , word_starts , false , nullptr , now ) ;\n EXPECT_GT ( scored_with_tld . raw_score , 0 ) ;\n }",
        "output": "1",
        "idx": 1618
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pdf_set_color ( fz_context * ctx , pdf_run_processor * pr , int what , float * v ) {\n pdf_gstate * gstate = pr -> gstate + pr -> gtop ;\n pdf_material * mat ;\n gstate = pdf_flush_text ( ctx , pr ) ;\n mat = what == PDF_FILL ? & gstate -> fill : & gstate -> stroke ;\n switch ( mat -> kind ) {\n case PDF_MAT_PATTERN : case PDF_MAT_COLOR : fz_clamp_color ( ctx , mat -> colorspace , v , mat -> v ) ;\n break ;\n default : fz_warn ( ctx , \"color incompatible with material\" ) ;\n }\n mat -> gstate_num = pr -> gparent ;\n }",
        "output": "0",
        "idx": 4008
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , Navigate_Https ) {\n StartHttpsServer ( false ) ;\n NavigateTwiceInTabAndClose ( https_test_server_ -> GetURL ( \"/simple.html\" ) , GURL ( chrome : : kChromeUIVersionURL ) ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 0 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 1 ) ;\n }",
        "output": "1",
        "idx": 2012
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _UTF16Reset ( UConverter * cnv , UConverterResetChoice choice ) {\n if ( choice <= UCNV_RESET_TO_UNICODE ) {\n cnv -> mode = 0 ;\n }\n if ( choice != UCNV_RESET_TO_UNICODE ) {\n cnv -> fromUnicodeStatus = UCNV_NEED_TO_WRITE_BOM ;\n }\n }",
        "output": "1",
        "idx": 1081
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void makeAlterConfigCommand ( PGconn * conn , const char * arrayitem , const char * type , const char * name , const char * type2 , const char * name2 ) {\n char * pos ;\n char * mine ;\n PQExpBuffer buf ;\n mine = pg_strdup ( arrayitem ) ;\n pos = strchr ( mine , '=' ) ;\n if ( pos == NULL ) {\n free ( mine ) ;\n return ;\n }\n buf = createPQExpBuffer ( ) ;\n * pos = 0 ;\n appendPQExpBuffer ( buf , \"ALTER %s %s \" , type , fmtId ( name ) ) ;\n if ( type2 != NULL && name2 != NULL ) appendPQExpBuffer ( buf , \"IN %s %s \" , type2 , fmtId ( name2 ) ) ;\n appendPQExpBuffer ( buf , \"SET %s TO \" , fmtId ( mine ) ) ;\n if ( pg_strcasecmp ( mine , \"DateStyle\" ) == 0 || pg_strcasecmp ( mine , \"search_path\" ) == 0 ) appendPQExpBufferStr ( buf , pos + 1 ) ;\n else appendStringLiteralConn ( buf , pos + 1 , conn ) ;\n appendPQExpBufferStr ( buf , \";\n\\n\" ) ;\n fprintf ( OPF , \"%s\" , buf -> data ) ;\n destroyPQExpBuffer ( buf ) ;\n free ( mine ) ;\n }",
        "output": "0",
        "idx": 2091
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool send_id ( connection_t * c ) {\n if ( proxytype && c -> outgoing && ! c -> status . proxy_passed ) {\n return send_proxyrequest ( c ) ;\n }\n return send_request ( c , \"%d %s %d\" , ID , myself -> connection -> name , myself -> connection -> protocol_version ) ;\n }",
        "output": "0",
        "idx": 2799
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int encode_frame ( vpx_codec_ctx_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , VpxVideoWriter * writer ) {\n int got_pkts = 0 ;\n vpx_codec_iter_t iter = NULL ;\n const vpx_codec_cx_pkt_t * pkt = NULL ;\n const vpx_codec_err_t res = vpx_codec_encode ( ctx , img , pts , duration , flags , deadline ) ;\n if ( res != VPX_CODEC_OK ) die_codec ( ctx , \"Failed to encode frame.\" ) ;\n while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) {\n got_pkts = 1 ;\n if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) {\n const int keyframe = ( pkt -> data . frame . flags & VPX_FRAME_IS_KEY ) != 0 ;\n if ( ! vpx_video_writer_write_frame ( writer , pkt -> data . frame . buf , pkt -> data . frame . sz , pkt -> data . frame . pts ) ) die_codec ( ctx , \"Failed to write compressed frame.\" ) ;\n printf ( keyframe ? \"K\" : \".\" ) ;\n fflush ( stdout ) ;\n }\n }\n return got_pkts ;\n }",
        "output": "0",
        "idx": 2034
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void process_blob ( struct rev_info * revs , struct blob * blob , show_object_fn show , struct name_path * path , const char * name , void * cb_data ) {\n struct object * obj = & blob -> object ;\n if ( ! revs -> blob_objects ) return ;\n if ( ! obj ) die ( \"bad blob object\" ) ;\n if ( obj -> flags & ( UNINTERESTING | SEEN ) ) return ;\n obj -> flags |= SEEN ;\n show ( obj , path , name , cb_data ) ;\n }",
        "output": "1",
        "idx": 1711
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_pick_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * cpi , LPF_PICK_METHOD method ) {\n VP9_COMMON * const cm = & cpi -> common ;\n struct loopfilter * const lf = & cm -> lf ;\n lf -> sharpness_level = cm -> frame_type == KEY_FRAME ? 0 : cpi -> oxcf . sharpness ;\n if ( method == LPF_PICK_MINIMAL_LPF && lf -> filter_level ) {\n lf -> filter_level = 0 ;\n }\n else if ( method >= LPF_PICK_FROM_Q ) {\n const int min_filter_level = 0 ;\n const int max_filter_level = get_max_filter_level ( cpi ) ;\n const int q = vp9_ac_quant ( cm -> base_qindex , 0 ) ;\n int filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 1015158 , 18 ) ;\n if ( cm -> frame_type == KEY_FRAME ) filt_guess -= 4 ;\n lf -> filter_level = clamp ( filt_guess , min_filter_level , max_filter_level ) ;\n }\n else {\n lf -> filter_level = search_filter_level ( sd , cpi , method == LPF_PICK_FROM_SUBIMAGE ) ;\n }\n }",
        "output": "1",
        "idx": 433
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void evhttp_set_timeout ( struct evhttp * http , int timeout_in_secs ) {\n http -> timeout = timeout_in_secs ;\n }",
        "output": "0",
        "idx": 3763
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void fz_init_cached_color_converter ( fz_context * ctx , fz_color_converter * cc , fz_colorspace * is , fz_colorspace * ds , fz_colorspace * ss , const fz_color_params * params ) {\n int n = ss -> n ;\n fz_cached_color_converter * cached = fz_malloc_struct ( ctx , fz_cached_color_converter ) ;\n cc -> opaque = cached ;\n cc -> convert = fz_cached_color_convert ;\n cc -> ds = ds ? ds : fz_device_gray ( ctx ) ;\n cc -> ss = ss ;\n cc -> is = is ;\n fz_try ( ctx ) {\n fz_find_color_converter ( ctx , & cached -> base , is , cc -> ds , ss , params ) ;\n cached -> hash = fz_new_hash_table ( ctx , 256 , n * sizeof ( float ) , - 1 , fz_free ) ;\n }\n fz_catch ( ctx ) {\n fz_drop_color_converter ( ctx , & cached -> base ) ;\n fz_drop_hash_table ( ctx , cached -> hash ) ;\n fz_free ( ctx , cached ) ;\n fz_rethrow ( ctx ) ;\n }\n }",
        "output": "1",
        "idx": 3613
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t idCmp ( const char * id1 , const char * id2 ) {\n int32_t diffIdx = 0 ;\n while ( * id1 == * id2 && * id1 != 0 ) {\n diffIdx ++ ;\n id1 ++ ;\n id2 ++ ;\n }\n return diffIdx ;\n }",
        "output": "1",
        "idx": 1406
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void print_blob_as_hex ( FILE * output_file , const char * str , ulong len ) {\n const char * ptr = str , * end = ptr + len ;\n for ( ;\n ptr < end ;\n ptr ++ ) fprintf ( output_file , \"%02X\" , * ( ( uchar * ) ptr ) ) ;\n check_io ( output_file ) ;\n }",
        "output": "0",
        "idx": 2557
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _ISCIIClose ( UConverter * cnv ) {\n if ( cnv -> extraInfo != NULL ) {\n if ( ! cnv -> isExtraLocal ) {\n uprv_free ( cnv -> extraInfo ) ;\n }\n cnv -> extraInfo = NULL ;\n }\n }",
        "output": "1",
        "idx": 144
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int com_delimiter ( String * buffer __attribute__ ( ( unused ) ) , char * line ) {\n char buff [ 256 ] , * tmp ;\n strmake_buf ( buff , line ) ;\n tmp = get_arg ( buff , 0 ) ;\n if ( ! tmp || ! * tmp ) {\n put_info ( \"DELIMITER must be followed by a 'delimiter' character or string\" , INFO_ERROR ) ;\n return 0 ;\n }\n else {\n if ( strstr ( tmp , \"\\\\\" ) ) {\n put_info ( \"DELIMITER cannot contain a backslash character\" , INFO_ERROR ) ;\n return 0 ;\n }\n }\n strmake_buf ( delimiter , tmp ) ;\n delimiter_length = ( int ) strlen ( delimiter ) ;\n delimiter_str = delimiter ;\n return 0 ;\n }",
        "output": "1",
        "idx": 1528
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileObject , key ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n RETURN_LONG ( intern -> u . file . current_line_num ) ;\n }",
        "output": "1",
        "idx": 763
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_EnumeratedParameter ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 830 \"./asn1/h225/h225.cnf\" gef_ctx_t * parent_gefx ;\n parent_gefx = gef_ctx_get ( actx -> private_data ) ;\n actx -> private_data = gef_ctx_alloc ( parent_gefx , NULL ) ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_EnumeratedParameter , EnumeratedParameter_sequence ) ;\n # line 835 \"./asn1/h225/h225.cnf\" actx -> private_data = parent_gefx ;\n return offset ;\n }",
        "output": "1",
        "idx": 4263
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void decode_gains ( AMRContext * p , const AMRNBSubframe * amr_subframe , const enum Mode mode , const int subframe , float * fixed_gain_factor ) {\n if ( mode == MODE_12k2 || mode == MODE_7k95 ) {\n p -> pitch_gain [ 4 ] = qua_gain_pit [ amr_subframe -> p_gain ] * ( 1.0 / 16384.0 ) ;\n * fixed_gain_factor = qua_gain_code [ amr_subframe -> fixed_gain ] * ( 1.0 / 2048.0 ) ;\n }\n else {\n const uint16_t * gains ;\n if ( mode >= MODE_6k7 ) {\n gains = gains_high [ amr_subframe -> p_gain ] ;\n }\n else if ( mode >= MODE_5k15 ) {\n gains = gains_low [ amr_subframe -> p_gain ] ;\n }\n else {\n gains = gains_MODE_4k75 [ ( p -> frame . subframe [ subframe & 2 ] . p_gain << 1 ) + ( subframe & 1 ) ] ;\n }\n p -> pitch_gain [ 4 ] = gains [ 0 ] * ( 1.0 / 16384.0 ) ;\n * fixed_gain_factor = gains [ 1 ] * ( 1.0 / 4096.0 ) ;\n }\n }",
        "output": "0",
        "idx": 117
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _LMBCSOpenWorker ( UConverter * _this , UConverterLoadArgs * pArgs , UErrorCode * err , ulmbcs_byte_t OptGroup ) {\n UConverterDataLMBCS * extraInfo = _this -> extraInfo = ( UConverterDataLMBCS * ) uprv_malloc ( sizeof ( UConverterDataLMBCS ) ) ;\n if ( extraInfo != NULL ) {\n UConverterNamePieces stackPieces ;\n UConverterLoadArgs stackArgs = {\n ( int32_t ) sizeof ( UConverterLoadArgs ) }\n ;\n ulmbcs_byte_t i ;\n uprv_memset ( extraInfo , 0 , sizeof ( UConverterDataLMBCS ) ) ;\n stackArgs . onlyTestIsLoadable = pArgs -> onlyTestIsLoadable ;\n for ( i = 0 ;\n i <= ULMBCS_GRP_LAST && U_SUCCESS ( * err ) ;\n i ++ ) {\n if ( OptGroupByteToCPName [ i ] != NULL ) {\n extraInfo -> OptGrpConverter [ i ] = ucnv_loadSharedData ( OptGroupByteToCPName [ i ] , & stackPieces , & stackArgs , err ) ;\n }\n }\n if ( U_FAILURE ( * err ) || pArgs -> onlyTestIsLoadable ) {\n _LMBCSClose ( _this ) ;\n return ;\n }\n extraInfo -> OptGroup = OptGroup ;\n extraInfo -> localeConverterIndex = FindLMBCSLocale ( pArgs -> locale ) ;\n }\n else {\n * err = U_MEMORY_ALLOCATION_ERROR ;\n }\n }",
        "output": "1",
        "idx": 3772
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int parse_CInGroupSortAggregSets ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , const char * fmt , ... ) {\n guint32 cCount , i ;\n proto_item * item ;\n proto_tree * tree ;\n const char * txt ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CInGroupSortAggregSets , & item , txt ) ;\n cCount = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_cingroupsortaggregsets_count , tvb , offset , 4 , cCount ) ;\n offset += 4 ;\n for ( i = 0 ;\n i < cCount ;\n i ++ ) {\n offset = parse_CInGroupSortAggregSet ( tvb , offset , tree , pad_tree , \"SortSets[%u]\" , i ) ;\n }\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }",
        "output": "1",
        "idx": 1146
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void http_writecb ( struct bufferevent * bev , void * arg ) {\n if ( EVBUFFER_LENGTH ( bev -> output ) == 0 ) {\n bufferevent_enable ( bev , EV_READ ) ;\n test_ok ++ ;\n }\n }",
        "output": "0",
        "idx": 3564
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Datum ExecEvalCurrentOfExpr ( ExprState * exprstate , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {\n ereport ( ERROR , ( errcode ( ERRCODE_FEATURE_NOT_SUPPORTED ) , errmsg ( \"WHERE CURRENT OF is not supported for this table type\" ) ) ) ;\n return 0 ;\n }",
        "output": "0",
        "idx": 3276
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void evhttp_send_reply_chunk ( struct evhttp_request * req , struct evbuffer * databuf ) {\n if ( req -> chunked ) {\n evbuffer_add_printf ( req -> evcon -> output_buffer , \"%x\\r\\n\" , ( unsigned ) EVBUFFER_LENGTH ( databuf ) ) ;\n }\n evbuffer_add_buffer ( req -> evcon -> output_buffer , databuf ) ;\n if ( req -> chunked ) {\n evbuffer_add ( req -> evcon -> output_buffer , \"\\r\\n\" , 2 ) ;\n }\n evhttp_write_buffer ( req -> evcon , NULL , NULL ) ;\n }",
        "output": "1",
        "idx": 1882
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl )",
        "output": "1",
        "idx": 3128
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void php_zip_free_entry ( zend_rsrc_list_entry * rsrc TSRMLS_DC ) {\n zip_read_rsrc * zr_rsrc = ( zip_read_rsrc * ) rsrc -> ptr ;\n if ( zr_rsrc ) {\n if ( zr_rsrc -> zf ) {\n if ( zr_rsrc -> zf -> za ) {\n zip_fclose ( zr_rsrc -> zf ) ;\n }\n else {\n if ( zr_rsrc -> zf -> src ) zip_source_free ( zr_rsrc -> zf -> src ) ;\n free ( zr_rsrc -> zf ) ;\n }\n zr_rsrc -> zf = NULL ;\n }\n efree ( zr_rsrc ) ;\n rsrc -> ptr = NULL ;\n }\n }",
        "output": "0",
        "idx": 1682
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void flush_unauthorized_files ( const struct cred * cred , struct files_struct * files ) {\n struct file * file , * devnull = NULL ;\n struct tty_struct * tty ;\n int drop_tty = 0 ;\n unsigned n ;\n tty = get_current_tty ( ) ;\n if ( tty ) {\n spin_lock ( & tty -> files_lock ) ;\n if ( ! list_empty ( & tty -> tty_files ) ) {\n struct tty_file_private * file_priv ;\n file_priv = list_first_entry ( & tty -> tty_files , struct tty_file_private , list ) ;\n file = file_priv -> file ;\n if ( file_path_has_perm ( cred , file , FILE__READ | FILE__WRITE ) ) drop_tty = 1 ;\n }\n spin_unlock ( & tty -> files_lock ) ;\n tty_kref_put ( tty ) ;\n }\n if ( drop_tty ) no_tty ( ) ;\n n = iterate_fd ( files , 0 , match_file , cred ) ;\n if ( ! n ) return ;\n devnull = dentry_open ( & selinux_null , O_RDWR , cred ) ;\n if ( IS_ERR ( devnull ) ) devnull = NULL ;\n do {\n replace_fd ( n - 1 , devnull , 0 ) ;\n }\n while ( ( n = iterate_fd ( files , n , match_file , cred ) ) != 0 ) ;\n if ( devnull ) fput ( devnull ) ;\n }",
        "output": "0",
        "idx": 1697
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_CapabilityIdentifier ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 714 \"../../asn1/h245/h245.cnf\" gef_ctx_t * gefx ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_CapabilityIdentifier , CapabilityIdentifier_choice , NULL ) ;\n # line 716 \"../../asn1/h245/h245.cnf\" gef_ctx_update_key ( gef_ctx_get ( actx -> private_data ) ) ;\n gefx = gef_ctx_get ( actx -> private_data ) ;\n if ( gefx ) {\n dissector_try_string ( gef_name_dissector_table , gefx -> key , tvb_new_subset ( tvb , offset >> 3 , 0 , 0 ) , actx -> pinfo , tree , actx ) ;\n }\n actx -> private_data = gefx ;\n return offset ;\n }",
        "output": "0",
        "idx": 4314
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void msyslog ( int level , const char * fmt , ... ) {\n char buf [ 1024 ] ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n mvsnprintf ( buf , sizeof ( buf ) , fmt , ap ) ;\n va_end ( ap ) ;\n addto_syslog ( level , buf ) ;\n }",
        "output": "1",
        "idx": 1013
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t PREP_io_800_readb ( void * opaque , uint32_t addr ) {\n uint32_t retval = 0xFF ;\n switch ( addr ) {\n case 0x0092 : retval = 0x40 ;\n break ;\n case 0x080C : retval = 0xFC ;\n break ;\n case 0x0818 : retval = 0x00 ;\n break ;\n case 0x081C : retval = syscontrol ;\n break ;\n case 0x0823 : retval = 0x03 ;\n break ;\n case 0x0850 : retval = 0x00 ;\n break ;\n default : break ;\n }\n PPC_IO_DPRINTF ( \"0x%08x <= 0x%08x\\n\" , addr - PPC_IO_BASE , retval ) ;\n return retval ;\n }",
        "output": "0",
        "idx": 3245
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void copy_picture_attributes ( MpegEncContext * s , AVFrame * dst , const AVFrame * src ) {\n dst -> pict_type = src -> pict_type ;\n dst -> quality = src -> quality ;\n dst -> coded_picture_number = src -> coded_picture_number ;\n dst -> display_picture_number = src -> display_picture_number ;\n dst -> pts = src -> pts ;\n dst -> interlaced_frame = src -> interlaced_frame ;\n dst -> top_field_first = src -> top_field_first ;\n }",
        "output": "0",
        "idx": 645
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void comp_ppf_gains ( int lag , PPFParam * ppf , enum Rate cur_rate , int tgt_eng , int ccr , int res_eng ) {\n int pf_residual ;\n int temp1 , temp2 ;\n ppf -> index = lag ;\n temp1 = tgt_eng * res_eng >> 1 ;\n temp2 = ccr * ccr << 1 ;\n if ( temp2 > temp1 ) {\n if ( ccr >= res_eng ) {\n ppf -> opt_gain = ppf_gain_weight [ cur_rate ] ;\n }\n else {\n ppf -> opt_gain = ( ccr << 15 ) / res_eng * ppf_gain_weight [ cur_rate ] >> 15 ;\n }\n temp1 = ( tgt_eng << 15 ) + ( ccr * ppf -> opt_gain << 1 ) ;\n temp2 = ( ppf -> opt_gain * ppf -> opt_gain >> 15 ) * res_eng ;\n pf_residual = av_sat_add32 ( temp1 , temp2 + ( 1 << 15 ) ) >> 16 ;\n if ( tgt_eng >= pf_residual << 1 ) {\n temp1 = 0x7fff ;\n }\n else {\n temp1 = ( tgt_eng << 14 ) / pf_residual ;\n }\n ppf -> sc_gain = square_root ( temp1 << 16 ) ;\n }\n else {\n ppf -> opt_gain = 0 ;\n ppf -> sc_gain = 0x7fff ;\n }\n ppf -> opt_gain = av_clip_int16 ( ppf -> opt_gain * ppf -> sc_gain >> 15 ) ;\n }",
        "output": "0",
        "idx": 3323
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( FullscreenControllerTest , PendingMouseLockExitsOnTabClose ) {\n AddTabAtIndex ( 0 , GURL ( url : : kAboutBlankURL ) , PAGE_TRANSITION_TYPED ) ;\n AddTabAtIndex ( 0 , GURL ( url : : kAboutBlankURL ) , PAGE_TRANSITION_TYPED ) ;\n RequestToLockMouse ( true , false ) ;\n ASSERT_TRUE ( IsFullscreenBubbleDisplayed ( ) ) ;\n {\n MouseLockNotificationObserver mouse_lock_observer ;\n chrome : : CloseTab ( browser ( ) ) ;\n mouse_lock_observer . Wait ( ) ;\n }\n ASSERT_FALSE ( IsFullscreenBubbleDisplayed ( ) ) ;\n }",
        "output": "0",
        "idx": 2291
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE cState_partial_generate ( VALUE self , VALUE obj ) {\n FBuffer * buffer = cState_prepare_buffer ( self ) ;\n GET_STATE ( self ) ;\n generate_json ( buffer , self , state , obj ) ;\n return fbuffer_to_s ( buffer ) ;\n }",
        "output": "0",
        "idx": 1022
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int is_mv_diff_gt_3 ( int16_t ( * motion_val ) [ 2 ] , int step ) {\n int d ;\n d = motion_val [ 0 ] [ 0 ] - motion_val [ - step ] [ 0 ] ;\n if ( d < - 3 || d > 3 ) return 1 ;\n d = motion_val [ 0 ] [ 1 ] - motion_val [ - step ] [ 1 ] ;\n if ( d < - 3 || d > 3 ) return 1 ;\n return 0 ;\n }",
        "output": "0",
        "idx": 270
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipvideo_decode_block_opcode_0xD_16 ( IpvideoContext * s ) {\n int x , y ;\n uint16_t P [ 2 ] ;\n uint16_t * pixel_ptr = ( uint16_t * ) s -> pixel_ptr ;\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n if ( ! ( y & 3 ) ) {\n P [ 0 ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n P [ 1 ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n }\n for ( x = 0 ;\n x < 8 ;\n x ++ ) pixel_ptr [ x ] = P [ x >> 2 ] ;\n pixel_ptr += s -> stride ;\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 2440
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int checkcmap ( int n , uint16 * r , uint16 * g , uint16 * b ) {\n while ( n -- > 0 ) if ( * r ++ >= 256 || * g ++ >= 256 || * b ++ >= 256 ) return ( 16 ) ;\n fprintf ( stderr , \"Warning, assuming 8-bit colormap.\\n\" ) ;\n return ( 8 ) ;\n }",
        "output": "0",
        "idx": 3712
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean istr_equal ( gconstpointer v , gconstpointer v2 ) {\n return g_ascii_strcasecmp ( v , v2 ) == 0 ;\n }",
        "output": "0",
        "idx": 3447
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char * mgs_hook_http_scheme ( const request_rec * r ) {\n mgs_srvconf_rec * sc ;\n if ( r == NULL ) return NULL ;\n sc = ( mgs_srvconf_rec * ) ap_get_module_config ( r -> server -> module_config , & gnutls_module ) ;\n _gnutls_log ( debug_log_fp , \"%s: %d\\n\" , __func__ , __LINE__ ) ;\n if ( sc -> enabled == GNUTLS_ENABLED_FALSE ) {\n return NULL ;\n }\n return \"https\" ;\n }",
        "output": "0",
        "idx": 2003
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Datum ExecEvalOper ( FuncExprState * fcache , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {\n OpExpr * op = ( OpExpr * ) fcache -> xprstate . expr ;\n init_fcache ( op -> opfuncid , op -> inputcollid , fcache , econtext -> ecxt_per_query_memory , true ) ;\n if ( fcache -> func . fn_retset || expression_returns_set ( ( Node * ) op -> args ) ) {\n fcache -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecMakeFunctionResult ;\n return ExecMakeFunctionResult ( fcache , econtext , isNull , isDone ) ;\n }\n else {\n fcache -> xprstate . evalfunc = ( ExprStateEvalFunc ) ExecMakeFunctionResultNoSets ;\n return ExecMakeFunctionResultNoSets ( fcache , econtext , isNull , isDone ) ;\n }\n }",
        "output": "0",
        "idx": 4456
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _SCSUReset ( UConverter * cnv , UConverterResetChoice choice ) {\n SCSUData * scsu = ( SCSUData * ) cnv -> extraInfo ;\n if ( choice <= UCNV_RESET_TO_UNICODE ) {\n uprv_memcpy ( scsu -> toUDynamicOffsets , initialDynamicOffsets , 32 ) ;\n scsu -> toUIsSingleByteMode = TRUE ;\n scsu -> toUState = readCommand ;\n scsu -> toUQuoteWindow = scsu -> toUDynamicWindow = 0 ;\n scsu -> toUByteOne = 0 ;\n cnv -> toULength = 0 ;\n }\n if ( choice != UCNV_RESET_TO_UNICODE ) {\n uprv_memcpy ( scsu -> fromUDynamicOffsets , initialDynamicOffsets , 32 ) ;\n scsu -> fromUIsSingleByteMode = TRUE ;\n scsu -> fromUDynamicWindow = 0 ;\n scsu -> nextWindowUseIndex = 0 ;\n switch ( scsu -> locale ) {\n case l_ja : uprv_memcpy ( scsu -> windowUse , initialWindowUse_ja , 8 ) ;\n break ;\n default : uprv_memcpy ( scsu -> windowUse , initialWindowUse , 8 ) ;\n break ;\n }\n cnv -> fromUChar32 = 0 ;\n }\n }",
        "output": "1",
        "idx": 4024
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void await_reference_row ( Vp3DecodeContext * s , Vp3Fragment * fragment , int motion_y , int y ) {\n AVFrame * ref_frame ;\n int ref_row ;\n int border = motion_y & 1 ;\n if ( fragment -> coding_method == MODE_USING_GOLDEN || fragment -> coding_method == MODE_GOLDEN_MV ) ref_frame = & s -> golden_frame ;\n else ref_frame = & s -> last_frame ;\n ref_row = y + ( motion_y >> 1 ) ;\n ref_row = FFMAX ( FFABS ( ref_row ) , ref_row + 8 + border ) ;\n ff_thread_await_progress ( ref_frame , ref_row , 0 ) ;\n }",
        "output": "1",
        "idx": 4048
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int copy_from ( IpvideoContext * s , AVFrame * src , int delta_x , int delta_y ) {\n int current_offset = s -> pixel_ptr - s -> current_frame . data [ 0 ] ;\n int motion_offset = current_offset + delta_y * s -> current_frame . linesize [ 0 ] + delta_x * ( 1 + s -> is_16bpp ) ;\n if ( motion_offset < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \" Interplay video: motion offset < 0 (%d)\\n\" , motion_offset ) ;\n return AVERROR_INVALIDDATA ;\n }\n else if ( motion_offset > s -> upper_motion_limit_offset ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \" Interplay video: motion offset above limit (%d >= %d)\\n\" , motion_offset , s -> upper_motion_limit_offset ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( src -> data [ 0 ] == NULL ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"Invalid decode type, corrupted header?\\n\" ) ;\n return AVERROR ( EINVAL ) ;\n }\n s -> dsp . put_pixels_tab [ ! s -> is_16bpp ] [ 0 ] ( s -> pixel_ptr , src -> data [ 0 ] + motion_offset , s -> current_frame . linesize [ 0 ] , 8 ) ;\n return 0 ;\n }",
        "output": "1",
        "idx": 1343
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __inline__ int TLV_GET_LEN ( struct tlv_desc * tlv ) {\n return ntohs ( tlv -> tlv_len ) ;\n }",
        "output": "0",
        "idx": 2698
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int x ( struct vcache * avc , int afun , struct vrequest * areq , \\ struct afs_pdata * ain , struct afs_pdata * aout , \\ afs_ucred_t * * acred ) DECL_PIOCTL ( PGetFID ) ;\n DECL_PIOCTL ( PSetAcl ) ;\n DECL_PIOCTL ( PStoreBehind ) ;\n DECL_PIOCTL ( PGCPAGs ) ;\n DECL_PIOCTL ( PGetAcl ) ;\n DECL_PIOCTL ( PNoop ) ;\n DECL_PIOCTL ( PBogus ) ;\n DECL_PIOCTL ( PGetFileCell ) ;\n DECL_PIOCTL ( PGetWSCell ) ;\n DECL_PIOCTL ( PGetUserCell ) ;\n DECL_PIOCTL ( PSetTokens ) ;\n DECL_PIOCTL ( PGetVolumeStatus ) ;\n DECL_PIOCTL ( PSetVolumeStatus ) ;\n DECL_PIOCTL ( PFlush )",
        "output": "0",
        "idx": 2112
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void initial_reordering_symbol_cluster ( const hb_ot_shape_plan_t * plan HB_UNUSED , hb_face_t * face HB_UNUSED , hb_buffer_t * buffer HB_UNUSED , unsigned int start HB_UNUSED , unsigned int end HB_UNUSED ) {\n }",
        "output": "1",
        "idx": 2886
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fd_free_list ( struct FrameData * list ) {\n struct FrameData * p = list ;\n while ( p ) {\n list = list -> next ;\n fd_free ( p ) ;\n p = list ;\n }\n }",
        "output": "1",
        "idx": 3451
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ossl_inline STACK_OF ( t1 ) * sk_ ## t1 ## _deep_copy ( const STACK_OF ( t1 ) * sk , sk_ ## t1 ## _copyfunc copyfunc , sk_ ## t1 ## _freefunc freefunc ) {\n return ( STACK_OF ( t1 ) * ) OPENSSL_sk_deep_copy ( ( const OPENSSL_STACK * ) sk , ( OPENSSL_sk_copyfunc ) copyfunc , ( OPENSSL_sk_freefunc ) freefunc ) ;\n }\n static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char )",
        "output": "1",
        "idx": 4379
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dumpcfffdselect ( SplineFont * sf , struct alltabs * at ) {\n int cid , k , lastfd , cnt ;\n int gid ;\n putc ( 3 , at -> fdselect ) ;\n putshort ( at -> fdselect , 0 ) ;\n for ( k = 0 ;\n k < sf -> subfontcnt ;\n ++ k ) if ( SCWorthOutputting ( sf -> subfonts [ k ] -> glyphs [ 0 ] ) ) break ;\n if ( k == sf -> subfontcnt ) -- k ;\n putshort ( at -> fdselect , 0 ) ;\n putc ( k , at -> fdselect ) ;\n lastfd = k ;\n cnt = 1 ;\n for ( gid = 1 ;\n gid < at -> gi . gcnt ;\n ++ gid ) {\n cid = at -> gi . bygid [ gid ] ;\n for ( k = 0 ;\n k < sf -> subfontcnt ;\n ++ k ) {\n if ( cid < sf -> subfonts [ k ] -> glyphcnt && SCWorthOutputting ( sf -> subfonts [ k ] -> glyphs [ cid ] ) ) break ;\n }\n if ( k == sf -> subfontcnt ) ;\n else {\n if ( k != lastfd ) {\n putshort ( at -> fdselect , gid ) ;\n putc ( k , at -> fdselect ) ;\n lastfd = k ;\n ++ cnt ;\n }\n }\n }\n putshort ( at -> fdselect , gid ) ;\n fseek ( at -> fdselect , 1 , SEEK_SET ) ;\n putshort ( at -> fdselect , cnt ) ;\n fseek ( at -> fdselect , 0 , SEEK_END ) ;\n }",
        "output": "0",
        "idx": 2443
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , LoadingMetricsFailed ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n auto waiter = CreatePageLoadMetricsWaiter ( ) ;\n waiter -> AddPageExpectation ( TimingField : : LOAD_TIMING_INFO ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( \"/page_load_metrics/404.html\" ) ) ;\n waiter -> Wait ( ) ;\n }",
        "output": "0",
        "idx": 622
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __always_inline __le32 __cpu_to_le32p ( const __u32 * p ) {\n return ( __le32 ) * p ;\n }",
        "output": "1",
        "idx": 4429
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_svc_parameters ( SvcContext * svc_ctx , vpx_codec_ctx_t * codec_ctx ) {\n int layer , layer_index ;\n vpx_svc_parameters_t svc_params ;\n SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n memset ( & svc_params , 0 , sizeof ( svc_params ) ) ;\n svc_params . temporal_layer = 0 ;\n svc_params . spatial_layer = si -> layer ;\n layer = si -> layer ;\n if ( VPX_CODEC_OK != vpx_svc_get_layer_resolution ( svc_ctx , layer , & svc_params . width , & svc_params . height ) ) {\n svc_log ( svc_ctx , SVC_LOG_ERROR , \"vpx_svc_get_layer_resolution failed\\n\" ) ;\n }\n layer_index = layer + VPX_SS_MAX_LAYERS - si -> layers ;\n if ( codec_ctx -> config . enc -> g_pass == VPX_RC_ONE_PASS ) {\n svc_params . min_quantizer = si -> quantizer [ layer_index ] ;\n svc_params . max_quantizer = si -> quantizer [ layer_index ] ;\n }\n else {\n svc_params . min_quantizer = codec_ctx -> config . enc -> rc_min_quantizer ;\n svc_params . max_quantizer = codec_ctx -> config . enc -> rc_max_quantizer ;\n }\n svc_params . distance_from_i_frame = si -> frame_within_gop ;\n vpx_codec_control ( codec_ctx , VP9E_SET_SVC_PARAMETERS , & svc_params ) ;\n }",
        "output": "1",
        "idx": 500
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pdf_run_c ( fz_context * ctx , pdf_processor * proc , float x1 , float y1 , float x2 , float y2 , float x3 , float y3 ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n fz_curveto ( ctx , pr -> path , x1 , y1 , x2 , y2 , x3 , y3 ) ;\n }",
        "output": "0",
        "idx": 4049
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gcry_mpi_t gcry_sexp_nth_mpi ( gcry_sexp_t list , int number , int mpifmt ) {\n const char * s ;\n size_t n ;\n gcry_mpi_t a ;\n if ( ! mpifmt ) mpifmt = GCRYMPI_FMT_STD ;\n s = sexp_nth_data ( list , number , & n ) ;\n if ( ! s ) return NULL ;\n if ( gcry_mpi_scan ( & a , mpifmt , s , n , NULL ) ) return NULL ;\n return a ;\n }",
        "output": "1",
        "idx": 37
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pdf_run_TD ( fz_context * ctx , pdf_processor * proc , float tx , float ty ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n pdf_gstate * gstate = pr -> gstate + pr -> gtop ;\n gstate -> text . leading = - ty ;\n pdf_tos_translate ( & pr -> tos , tx , ty ) ;\n }",
        "output": "0",
        "idx": 4017
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int _find_update_object_in_list ( void * x , void * key ) {\n slurmdb_update_object_t * object = ( slurmdb_update_object_t * ) x ;\n slurmdb_update_type_t type = * ( slurmdb_update_type_t * ) key ;\n if ( object -> type == type ) return 1 ;\n return 0 ;\n }",
        "output": "0",
        "idx": 2720
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int wpa_decrypt ( u_char * mac , u_char * data , size_t len , struct wpa_sa sa ) {\n if ( sa . algo == WPA_KEY_CCMP ) {\n return wpa_ccmp_decrypt ( mac , data , len , sa ) ;\n }\n else if ( sa . algo == WPA_KEY_TKIP ) {\n return wpa_tkip_decrypt ( mac , data , len , sa ) ;\n }\n return - E_NOTHANDLED ;\n }",
        "output": "0",
        "idx": 613
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( ExternalProtocolDialogBrowserTest , TestAccept ) {\n ShowDialog ( ) ;\n EXPECT_TRUE ( dialog_ -> Accept ( ) ) ;\n EXPECT_TRUE ( called_ ) ;\n EXPECT_TRUE ( accept_ ) ;\n EXPECT_FALSE ( cancel_ ) ;\n EXPECT_FALSE ( dont_block_ ) ;\n histogram_tester_ . ExpectBucketCount ( ExternalProtocolHandler : : kRememberCheckboxMetric , 0 , 1 ) ;\n histogram_tester_ . ExpectBucketCount ( ExternalProtocolHandler : : kHandleStateMetric , ExternalProtocolHandler : : LAUNCH , 1 ) ;\n }",
        "output": "1",
        "idx": 3217
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t U_CALLCONV compareMappingsUnicodeFirst ( const void * context , const void * left , const void * right ) {\n return compareMappings ( ( UCMTable * ) context , ( const UCMapping * ) left , ( UCMTable * ) context , ( const UCMapping * ) right , TRUE ) ;\n }",
        "output": "0",
        "idx": 4443
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pic_as_field ( Picture * pic , const int parity ) {\n int i ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) {\n if ( parity == PICT_BOTTOM_FIELD ) pic -> f . data [ i ] += pic -> f . linesize [ i ] ;\n pic -> f . reference = parity ;\n pic -> f . linesize [ i ] *= 2 ;\n }\n pic -> poc = pic -> field_poc [ parity == PICT_BOTTOM_FIELD ] ;\n }",
        "output": "1",
        "idx": 1638
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void main_buffree ( void * ptr ) {\n # if XD3_WIN32 VirtualFree ( ptr , 0 , MEM_RELEASE ) ;\n # else main_free1 ( NULL , ptr ) ;\n # endif }",
        "output": "0",
        "idx": 1895
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , Simple_Https ) {\n StartHttpsServer ( false ) ;\n base : : TimeDelta upper_bound = NavigateInForegroundAndCloseWithTiming ( https_test_server_ -> GetURL ( \"/simple.html\" ) ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 0 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 1 ) ;\n int32_t bucket_min = histogram_tester_ . GetAllSamples ( internal : : kHttpsEngagementHistogram ) [ 0 ] . min ;\n EXPECT_GE ( upper_bound . InMilliseconds ( ) , bucket_min ) ;\n EXPECT_LT ( 0 , bucket_min ) ;\n }",
        "output": "1",
        "idx": 3295
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_FeatureDescriptor ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 840 \"./asn1/h225/h225.cnf\" void * priv_data = actx -> private_data ;\n actx -> private_data = gef_ctx_alloc ( NULL , \"FeatureDescriptor\" ) ;\n offset = dissect_h225_GenericData ( tvb , offset , actx , tree , hf_index ) ;\n # line 843 \"./asn1/h225/h225.cnf\" actx -> private_data = priv_data ;\n return offset ;\n }",
        "output": "1",
        "idx": 1214
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t u_scanf_percent_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {\n int32_t len ;\n double num ;\n UNumberFormat * format ;\n int32_t parsePos = 0 ;\n UErrorCode status = U_ZERO_ERROR ;\n u_scanf_skip_leading_ws ( input , info -> fPadChar ) ;\n ufile_fill_uchar_buffer ( input ) ;\n len = ( int32_t ) ( input -> str . fLimit - input -> str . fPos ) ;\n if ( info -> fWidth != - 1 ) len = ufmt_min ( len , info -> fWidth ) ;\n format = u_locbund_getNumberFormat ( & input -> str . fBundle , UNUM_PERCENT ) ;\n if ( format == 0 ) return 0 ;\n u_scanf_skip_leading_positive_sign ( input , format , & status ) ;\n num = unum_parseDouble ( format , input -> str . fPos , len , & parsePos , & status ) ;\n if ( ! info -> fSkipArg ) {\n * ( double * ) ( args [ 0 ] . ptrValue ) = num ;\n }\n input -> str . fPos += parsePos ;\n * argConverted = ! info -> fSkipArg ;\n return parsePos ;\n }",
        "output": "1",
        "idx": 2496
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl ) ;\n __exctype ( isdigit ) ;\n __exctype ( islower ) ;\n __exctype ( isgraph ) ;\n __exctype ( isprint ) ;\n __exctype ( ispunct ) ;\n __exctype ( isspace ) ;\n __exctype ( isupper ) ;\n __exctype ( isxdigit ) ;\n extern int tolower ( int __c ) __THROW ;\n extern int toupper ( int __c ) __THROW ;\n # ifdef __USE_ISOC99 __exctype ( isblank ) ;\n # endif # ifdef __USE_GNU extern int isctype ( int __c , int __mask ) __THROW ;\n # endif # if defined __USE_MISC || defined __USE_XOPEN extern int isascii ( int __c ) __THROW ;\n extern int toascii ( int __c ) __THROW ;\n __exctype ( _toupper ) ;\n __exctype ( _tolower )",
        "output": "1",
        "idx": 3722
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int xml_init ( modsec_rec * msr , char * * error_msg ) {\n if ( error_msg == NULL ) return - 1 ;\n * error_msg = NULL ;\n msr -> xml = apr_pcalloc ( msr -> mp , sizeof ( xml_data ) ) ;\n if ( msr -> xml == NULL ) return - 1 ;\n return 1 ;\n }",
        "output": "1",
        "idx": 1140
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl ) ;\n __exctype ( isdigit ) ;\n __exctype ( islower ) ;\n __exctype ( isgraph ) ;\n __exctype ( isprint ) ;\n __exctype ( ispunct ) ;\n __exctype ( isspace ) ;\n __exctype ( isupper ) ;\n __exctype ( isxdigit )",
        "output": "1",
        "idx": 3169
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mi_check_print_error ( MI_CHECK * param , const char * fmt , ... ) {\n va_list args ;\n DBUG_ENTER ( \"mi_check_print_error\" ) ;\n DBUG_PRINT ( \"enter\" , ( \"format: %s\" , fmt ) ) ;\n fflush ( stdout ) ;\n if ( ! param -> warning_printed && ! param -> error_printed ) {\n if ( param -> testflag & T_SILENT ) fprintf ( stderr , \"%s: MyISAM file %s\\n\" , my_progname_short , param -> isam_file_name ) ;\n param -> out_flag |= O_DATA_LOST ;\n }\n param -> error_printed |= 1 ;\n va_start ( args , fmt ) ;\n fprintf ( stderr , \"%s: error: \" , my_progname_short ) ;\n ( void ) vfprintf ( stderr , fmt , args ) ;\n ( void ) fputc ( '\\n' , stderr ) ;\n fflush ( stderr ) ;\n va_end ( args ) ;\n DBUG_VOID_RETURN ;\n }",
        "output": "0",
        "idx": 2916
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void pcnet_ioport_writew ( void * opaque , uint32_t addr , uint32_t val ) {\n PCNetState * s = opaque ;\n pcnet_poll_timer ( s ) ;\n # ifdef PCNET_DEBUG_IO printf ( \"pcnet_ioport_writew addr=0x%08x val=0x%04x\\n\" , addr , val ) ;\n # endif if ( ! BCR_DWIO ( s ) ) {\n switch ( addr & 0x0f ) {\n case 0x00 : pcnet_csr_writew ( s , s -> rap , val ) ;\n break ;\n case 0x02 : s -> rap = val & 0x7f ;\n break ;\n case 0x06 : pcnet_bcr_writew ( s , s -> rap , val ) ;\n break ;\n }\n }\n pcnet_update_irq ( s ) ;\n }",
        "output": "0",
        "idx": 1302
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipvideo_decode_block_opcode_0xB ( IpvideoContext * s ) {\n int y ;\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n bytestream2_get_buffer ( & s -> stream_ptr , s -> pixel_ptr , 8 ) ;\n s -> pixel_ptr += s -> stride ;\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 568
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static kadm5_ret_t copy_tl_data ( krb5_int16 n_tl_data , krb5_tl_data * tl_data , krb5_tl_data * * out ) {\n kadm5_ret_t ret ;\n krb5_tl_data * tl , * tl_new ;\n if ( ( ret = alloc_tl_data ( n_tl_data , out ) ) ) return ret ;\n tl = tl_data ;\n tl_new = * out ;\n for ( ;\n tl ;\n tl = tl -> tl_data_next , tl_new = tl_new -> tl_data_next ) {\n tl_new -> tl_data_contents = malloc ( tl -> tl_data_length ) ;\n if ( tl_new -> tl_data_contents == NULL ) return ENOMEM ;\n memcpy ( tl_new -> tl_data_contents , tl -> tl_data_contents , tl -> tl_data_length ) ;\n tl_new -> tl_data_type = tl -> tl_data_type ;\n tl_new -> tl_data_length = tl -> tl_data_length ;\n }\n return 0 ;\n }",
        "output": "0",
        "idx": 1235
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_NonStandardIdentifier ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 947 \"../../asn1/h245/h245.cnf\" gint32 value ;\n nsiOID = \"\" ;\n h221NonStandard = 0 ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_NonStandardIdentifier , NonStandardIdentifier_choice , & value ) ;\n switch ( value ) {\n case 0 : nsp_handle = dissector_get_string_handle ( nsp_object_dissector_table , nsiOID ) ;\n break ;\n case 1 : nsp_handle = dissector_get_uint_handle ( nsp_h221_dissector_table , h221NonStandard ) ;\n break ;\n default : nsp_handle = NULL ;\n }\n return offset ;\n }",
        "output": "0",
        "idx": 3954
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void * pool_alloc ( size_t len ) {\n struct mem_pool * p ;\n void * r ;\n if ( len & ( sizeof ( uintmax_t ) - 1 ) ) len += sizeof ( uintmax_t ) - ( len & ( sizeof ( uintmax_t ) - 1 ) ) ;\n for ( p = mem_pool ;\n p ;\n p = p -> next_pool ) if ( ( p -> end - p -> next_free >= len ) ) break ;\n if ( ! p ) {\n if ( len >= ( mem_pool_alloc / 2 ) ) {\n total_allocd += len ;\n return xmalloc ( len ) ;\n }\n total_allocd += sizeof ( struct mem_pool ) + mem_pool_alloc ;\n p = xmalloc ( sizeof ( struct mem_pool ) + mem_pool_alloc ) ;\n p -> next_pool = mem_pool ;\n p -> next_free = ( char * ) p -> space ;\n p -> end = p -> next_free + mem_pool_alloc ;\n mem_pool = p ;\n }\n r = p -> next_free ;\n p -> next_free += len ;\n return r ;\n }",
        "output": "0",
        "idx": 1702
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void reindex_system_catalogs ( const char * dbname , const char * host , const char * port , const char * username , enum trivalue prompt_password , const char * progname , bool echo , bool verbose ) {\n PGconn * conn ;\n PQExpBufferData sql ;\n conn = connectDatabase ( dbname , host , port , username , prompt_password , progname , false , false ) ;\n initPQExpBuffer ( & sql ) ;\n appendPQExpBuffer ( & sql , \"REINDEX\" ) ;\n if ( verbose ) appendPQExpBuffer ( & sql , \" (VERBOSE)\" ) ;\n appendPQExpBuffer ( & sql , \" SYSTEM %s;\n\" , PQdb ( conn ) ) ;\n if ( ! executeMaintenanceCommand ( conn , sql . data , echo ) ) {\n fprintf ( stderr , _ ( \"%s: reindexing of system catalogs failed: %s\" ) , progname , PQerrorMessage ( conn ) ) ;\n PQfinish ( conn ) ;\n exit ( 1 ) ;\n }\n PQfinish ( conn ) ;\n termPQExpBuffer ( & sql ) ;\n }",
        "output": "1",
        "idx": 2203
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_T_mediaMode ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_T_mediaMode , T_mediaMode_choice , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 3384
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t getHostID ( const ILcidPosixMap * this_0 , const char * posixID , UErrorCode * status ) {\n int32_t bestIdx = 0 ;\n int32_t bestIdxDiff = 0 ;\n int32_t posixIDlen = ( int32_t ) uprv_strlen ( posixID ) ;\n uint32_t idx ;\n for ( idx = 0 ;\n idx < this_0 -> numRegions ;\n idx ++ ) {\n int32_t sameChars = idCmp ( posixID , this_0 -> regionMaps [ idx ] . posixID ) ;\n if ( sameChars > bestIdxDiff && this_0 -> regionMaps [ idx ] . posixID [ sameChars ] == 0 ) {\n if ( posixIDlen == sameChars ) {\n return this_0 -> regionMaps [ idx ] . hostID ;\n }\n bestIdxDiff = sameChars ;\n bestIdx = idx ;\n }\n }\n if ( ( posixID [ bestIdxDiff ] == '_' || posixID [ bestIdxDiff ] == '@' ) && this_0 -> regionMaps [ bestIdx ] . posixID [ bestIdxDiff ] == 0 ) {\n * status = U_USING_FALLBACK_WARNING ;\n return this_0 -> regionMaps [ bestIdx ] . hostID ;\n }\n * status = U_ILLEGAL_ARGUMENT_ERROR ;\n return this_0 -> regionMaps -> hostID ;\n }",
        "output": "1",
        "idx": 4212
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void flac_set_bps ( FLACContext * s ) {\n enum AVSampleFormat req = s -> avctx -> request_sample_fmt ;\n int need32 = s -> bps > 16 ;\n int want32 = av_get_bytes_per_sample ( req ) > 2 ;\n int planar = av_sample_fmt_is_planar ( req ) ;\n if ( need32 || want32 ) {\n if ( planar ) s -> avctx -> sample_fmt = AV_SAMPLE_FMT_S32P ;\n else s -> avctx -> sample_fmt = AV_SAMPLE_FMT_S32 ;\n s -> sample_shift = 32 - s -> bps ;\n }\n else {\n if ( planar ) s -> avctx -> sample_fmt = AV_SAMPLE_FMT_S16P ;\n else s -> avctx -> sample_fmt = AV_SAMPLE_FMT_S16 ;\n s -> sample_shift = 16 - s -> bps ;\n }\n }",
        "output": "0",
        "idx": 2205
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vp9_rc_regulate_q ( const VP9_COMP * cpi , int target_bits_per_frame , int active_best_quality , int active_worst_quality ) {\n const VP9_COMMON * const cm = & cpi -> common ;\n int q = active_worst_quality ;\n int last_error = INT_MAX ;\n int i , target_bits_per_mb ;\n const double correction_factor = get_rate_correction_factor ( cpi ) ;\n target_bits_per_mb = ( ( uint64_t ) target_bits_per_frame << BPER_MB_NORMBITS ) / cm -> MBs ;\n i = active_best_quality ;\n do {\n const int bits_per_mb_at_this_q = ( int ) vp9_rc_bits_per_mb ( cm -> frame_type , i , correction_factor ) ;\n if ( bits_per_mb_at_this_q <= target_bits_per_mb ) {\n if ( ( target_bits_per_mb - bits_per_mb_at_this_q ) <= last_error ) q = i ;\n else q = i - 1 ;\n break ;\n }\n else {\n last_error = bits_per_mb_at_this_q - target_bits_per_mb ;\n }\n }\n while ( ++ i <= active_worst_quality ) ;\n return q ;\n }",
        "output": "1",
        "idx": 1805
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE cState_initialize ( int argc , VALUE * argv , VALUE self ) {\n VALUE opts ;\n GET_STATE ( self ) ;\n state -> max_nesting = 100 ;\n state -> buffer_initial_length = FBUFFER_INITIAL_LENGTH_DEFAULT ;\n rb_scan_args ( argc , argv , \"01\" , & opts ) ;\n if ( ! NIL_P ( opts ) ) cState_configure ( self , opts ) ;\n return self ;\n }",
        "output": "0",
        "idx": 3738
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_idct32x32_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) {\n if ( eob == 1 ) vp9_idct32x32_1_add ( input , dest , stride ) ;\n else if ( eob <= 34 ) vp9_idct32x32_34_add ( input , dest , stride ) ;\n else vp9_idct32x32_1024_add ( input , dest , stride ) ;\n }",
        "output": "1",
        "idx": 4172
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int spl_filesystem_file_read_line ( zval * this_ptr , spl_filesystem_object * intern , int silent TSRMLS_DC ) {\n int ret = spl_filesystem_file_read_line_ex ( this_ptr , intern , silent TSRMLS_CC ) ;\n while ( SPL_HAS_FLAG ( intern -> flags , SPL_FILE_OBJECT_SKIP_EMPTY ) && ret == SUCCESS && spl_filesystem_file_is_empty_line ( intern TSRMLS_CC ) ) {\n spl_filesystem_file_free_line ( intern TSRMLS_CC ) ;\n ret = spl_filesystem_file_read_line_ex ( this_ptr , intern , silent TSRMLS_CC ) ;\n }\n return ret ;\n }",
        "output": "1",
        "idx": 4411
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static _Bool have_gcrypt ( void ) {\n static _Bool result = 0 ;\n static _Bool need_init = 1 ;\n if ( ! need_init ) return ( result ) ;\n need_init = 0 ;\n # if HAVE_LIBGCRYPT # if GCRYPT_VERSION_NUMBER < 0x010600 gcry_control ( GCRYCTL_SET_THREAD_CBS , & gcry_threads_pthread ) ;\n # endif if ( ! gcry_check_version ( GCRYPT_VERSION ) ) return ( 0 ) ;\n gcry_control ( GCRYCTL_INIT_SECMEM , 32768 , 0 ) ;\n gcry_control ( GCRYCTL_INITIALIZATION_FINISHED , 0 ) ;\n result = 1 ;\n return ( 1 ) ;\n # else return ( 0 ) ;\n # endif }",
        "output": "1",
        "idx": 3848
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int should_include ( struct commit * commit , void * _data ) {\n struct bitmap * base = _data ;\n if ( ! add_to_include_set ( base , commit ) ) {\n struct commit_list * parent = commit -> parents ;\n mark_as_seen ( ( struct object * ) commit ) ;\n while ( parent ) {\n parent -> item -> object . flags |= SEEN ;\n mark_as_seen ( ( struct object * ) parent -> item ) ;\n parent = parent -> next ;\n }\n return 0 ;\n }\n return 1 ;\n }",
        "output": "0",
        "idx": 4249
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int gs_heap_register_root ( gs_memory_t * mem , gs_gc_root_t * rp , gs_ptr_type_t ptype , void * * up , client_name_t cname ) {\n return 0 ;\n }",
        "output": "0",
        "idx": 4125
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void choose_largest_tx_size ( VP9_COMP * cpi , MACROBLOCK * x , int * rate , int64_t * distortion , int * skip , int64_t * sse , int64_t ref_best_rd , BLOCK_SIZE bs ) {\n const TX_SIZE max_tx_size = max_txsize_lookup [ bs ] ;\n VP9_COMMON * const cm = & cpi -> common ;\n const TX_SIZE largest_tx_size = tx_mode_to_biggest_tx_size [ cm -> tx_mode ] ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;\n mbmi -> tx_size = MIN ( max_tx_size , largest_tx_size ) ;\n txfm_rd_in_plane ( x , rate , distortion , skip , sse , ref_best_rd , 0 , bs , mbmi -> tx_size , cpi -> sf . use_fast_coef_costing ) ;\n }",
        "output": "1",
        "idx": 4352
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t u_printf_ustring_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n ( void ) formatBundle ;\n int32_t len , written ;\n const UChar * arg = ( const UChar * ) ( args [ 0 ] . ptrValue ) ;\n if ( arg == NULL ) {\n arg = gNullStr ;\n }\n len = u_strlen ( arg ) ;\n if ( info -> fPrecision != - 1 && info -> fPrecision < len ) {\n len = info -> fPrecision ;\n }\n written = handler -> pad_and_justify ( context , info , arg , len ) ;\n return written ;\n }",
        "output": "0",
        "idx": 3424
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipvideo_decode_block_opcode_0xB_16 ( IpvideoContext * s ) {\n int x , y ;\n uint16_t * pixel_ptr = ( uint16_t * ) s -> pixel_ptr ;\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n for ( x = 0 ;\n x < 8 ;\n x ++ ) pixel_ptr [ x ] = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n pixel_ptr += s -> stride ;\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 824
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int yop_copy_previous_block ( YopDecContext * s , int linesize , int copy_tag ) {\n uint8_t * bufptr ;\n bufptr = s -> dstptr + motion_vector [ copy_tag ] [ 0 ] + linesize * motion_vector [ copy_tag ] [ 1 ] ;\n if ( bufptr < s -> dstbuf ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"YOP: cannot decode, file probably corrupt\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n s -> dstptr [ 0 ] = bufptr [ 0 ] ;\n s -> dstptr [ 1 ] = bufptr [ 1 ] ;\n s -> dstptr [ linesize ] = bufptr [ linesize ] ;\n s -> dstptr [ linesize + 1 ] = bufptr [ linesize + 1 ] ;\n return 0 ;\n }",
        "output": "0",
        "idx": 4099
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_T_decision ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_T_decision , T_decision_choice , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 3164
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileObject , getCsvControl ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n char delimiter [ 2 ] , enclosure [ 2 ] ;\n array_init ( return_value ) ;\n delimiter [ 0 ] = intern -> u . file . delimiter ;\n delimiter [ 1 ] = '\\0' ;\n enclosure [ 0 ] = intern -> u . file . enclosure ;\n enclosure [ 1 ] = '\\0' ;\n add_next_index_string ( return_value , delimiter , 1 ) ;\n add_next_index_string ( return_value , enclosure , 1 ) ;\n }",
        "output": "1",
        "idx": 3808
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void get_current_db ( ) {\n MYSQL_RES * res ;\n if ( one_database ) return ;\n my_free ( current_db ) ;\n current_db = NULL ;\n if ( ! mysql_query ( & mysql , \"SELECT DATABASE()\" ) && ( res = mysql_use_result ( & mysql ) ) ) {\n MYSQL_ROW row = mysql_fetch_row ( res ) ;\n if ( row && row [ 0 ] ) current_db = my_strdup ( row [ 0 ] , MYF ( MY_WME ) ) ;\n mysql_free_result ( res ) ;\n }\n }",
        "output": "0",
        "idx": 3562
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_fetch_float ( ) {\n int rc ;\n myheader ( \"test_fetch_float\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS test_bind_fetch\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE test_bind_fetch(c1 float(3), \\ c2 float, \\ c3 float unsigned, \\ c4 float, \\ c5 float, \\ c6 float, \\ c7 float(10) unsigned)\" ) ;\n myquery ( rc ) ;\n bind_fetch ( 2 ) ;\n }",
        "output": "0",
        "idx": 1860
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int file_compare_by_parent_uri ( NautilusFile * file_a , NautilusFile * file_b ) {\n char * parent_uri_a , * parent_uri_b ;\n int ret ;\n parent_uri_a = nautilus_file_get_parent_uri ( file_a ) ;\n parent_uri_b = nautilus_file_get_parent_uri ( file_b ) ;\n ret = strcmp ( parent_uri_a , parent_uri_b ) ;\n g_free ( parent_uri_a ) ;\n g_free ( parent_uri_b ) ;\n return ret ;\n }",
        "output": "0",
        "idx": 2018
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int idcin_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n IdcinContext * s = avctx -> priv_data ;\n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n s -> buf = buf ;\n s -> size = buf_size ;\n if ( s -> frame . data [ 0 ] ) avctx -> release_buffer ( avctx , & s -> frame ) ;\n if ( ff_get_buffer ( avctx , & s -> frame ) ) {\n av_log ( avctx , AV_LOG_ERROR , \" id CIN Video: get_buffer() failed\\n\" ) ;\n return - 1 ;\n }\n idcin_decode_vlcs ( s ) ;\n if ( pal ) {\n s -> frame . palette_has_changed = 1 ;\n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n }\n memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return buf_size ;\n }",
        "output": "1",
        "idx": 3498
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void proto_report_dissector_bug ( const char * message ) {\n if ( getenv ( \"WIRESHARK_ABORT_ON_DISSECTOR_BUG\" ) != NULL ) abort ( ) ;\n else THROW_MESSAGE ( DissectorError , message ) ;\n }",
        "output": "0",
        "idx": 2247
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileInfo , setFileClass ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n zend_class_entry * ce = spl_ce_SplFileObject ;\n zend_error_handling error_handling ;\n zend_replace_error_handling ( EH_THROW , spl_ce_UnexpectedValueException , & error_handling TSRMLS_CC ) ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"|C\" , & ce ) == SUCCESS ) {\n intern -> file_class = ce ;\n }\n zend_restore_error_handling ( & error_handling TSRMLS_CC ) ;\n }",
        "output": "1",
        "idx": 3015
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int auth_server_input_cont ( struct auth_server_connection * conn , const char * const * args ) {\n struct auth_client_request * request ;\n if ( str_array_length ( args ) < 2 ) {\n i_error ( \"BUG: Authentication server sent broken CONT line\" ) ;\n return - 1 ;\n }\n if ( auth_server_lookup_request ( conn , args [ 0 ] , FALSE , & request ) < 0 ) return - 1 ;\n auth_client_request_server_input ( request , AUTH_REQUEST_STATUS_CONTINUE , args + 1 ) ;\n return 0 ;\n }",
        "output": "0",
        "idx": 4077
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void * i_alloc_struct_array ( gs_memory_t * mem , uint num_elements , gs_memory_type_ptr_t pstype , client_name_t cname ) {\n gs_ref_memory_t * const imem = ( gs_ref_memory_t * ) mem ;\n obj_header_t * obj ;\n # ifdef MEMENTO if ( Memento_failThisEvent ( ) ) return NULL ;\n # endif ALLOC_CHECK_SIZE ( mem , pstype ) ;\n # ifdef DEBUG if ( pstype -> enum_ptrs == basic_enum_ptrs ) {\n dmprintf2 ( mem , \" i_alloc_struct_array: called with incorrect structure type (not element), struct='%s', client='%s'\\n\" , pstype -> sname , cname ) ;\n return NULL ;\n }\n # endif obj = alloc_obj ( imem , ( ulong ) num_elements * pstype -> ssize , pstype , ALLOC_DIRECT , cname ) ;\n if_debug7m ( 'A' , mem , \"[a%d:+<.]%s %s*(%lu=%u*%u) = 0x%lx\\n\" , alloc_trace_space ( imem ) , client_name_string ( cname ) , struct_type_name_string ( pstype ) , ( ulong ) num_elements * pstype -> ssize , num_elements , pstype -> ssize , ( ulong ) obj ) ;\n return ( char * ) obj ;\n }",
        "output": "1",
        "idx": 274
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( DirectoryIterator , getBasename ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n char * suffix = 0 , * fname ;\n int slen = 0 ;\n size_t flen ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"|s\" , & suffix , & slen ) == FAILURE ) {\n return ;\n }\n php_basename ( intern -> u . dir . entry . d_name , strlen ( intern -> u . dir . entry . d_name ) , suffix , slen , & fname , & flen TSRMLS_CC ) ;\n RETURN_STRINGL ( fname , flen , 0 ) ;\n }",
        "output": "1",
        "idx": 388
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char * tok2str ( register const struct tok * lp , register const char * fmt , register u_int v ) {\n static char buf [ 4 ] [ TOKBUFSIZE ] ;\n static int idx = 0 ;\n char * ret ;\n ret = buf [ idx ] ;\n idx = ( idx + 1 ) & 3 ;\n return tok2strbuf ( lp , fmt , v , ret , sizeof ( buf [ 0 ] ) ) ;\n }",
        "output": "0",
        "idx": 3064
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WRITE_CLASS_ENCODER ( CephXServiceTicket ) struct CephXServiceTicketInfo {\n AuthTicket ticket ;\n CryptoKey session_key ;\n void encode ( bufferlist & bl ) const {\n __u8 struct_v = 1 ;\n : : encode ( struct_v , bl ) ;\n : : encode ( ticket , bl ) ;\n : : encode ( session_key , bl ) ;\n }\n void decode ( bufferlist : : iterator & bl ) {\n __u8 struct_v ;\n : : decode ( struct_v , bl ) ;\n : : decode ( ticket , bl ) ;\n : : decode ( session_key , bl ) ;\n }\n }\n ;\n WRITE_CLASS_ENCODER ( CephXServiceTicketInfo ) struct CephXAuthorize {\n uint64_t nonce ;\n void encode ( bufferlist & bl ) const {\n __u8 struct_v = 1 ;\n : : encode ( struct_v , bl ) ;\n : : encode ( nonce , bl ) ;\n }\n void decode ( bufferlist : : iterator & bl ) {\n __u8 struct_v ;\n : : decode ( struct_v , bl ) ;\n : : decode ( nonce , bl ) ;\n }\n }",
        "output": "1",
        "idx": 1570
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void server_port_read ( struct evdns_server_port * s ) {\n u8 packet [ 1500 ] ;\n struct sockaddr_storage addr ;\n socklen_t addrlen ;\n int r ;\n for ( ;\n ;\n ) {\n addrlen = sizeof ( struct sockaddr_storage ) ;\n r = recvfrom ( s -> socket , packet , sizeof ( packet ) , 0 , ( struct sockaddr * ) & addr , & addrlen ) ;\n if ( r < 0 ) {\n int err = last_error ( s -> socket ) ;\n if ( error_is_eagain ( err ) ) return ;\n log ( EVDNS_LOG_WARN , \"Error %s (%d) while reading request.\" , strerror ( err ) , err ) ;\n return ;\n }\n request_parse ( packet , r , s , ( struct sockaddr * ) & addr , addrlen ) ;\n }\n }",
        "output": "0",
        "idx": 2594
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct tree_content * new_tree_content ( unsigned int cnt ) {\n struct avail_tree_content * f , * l = NULL ;\n struct tree_content * t ;\n unsigned int hc = hc_entries ( cnt ) ;\n for ( f = avail_tree_table [ hc ] ;\n f ;\n l = f , f = f -> next_avail ) if ( f -> entry_capacity >= cnt ) break ;\n if ( f ) {\n if ( l ) l -> next_avail = f -> next_avail ;\n else avail_tree_table [ hc ] = f -> next_avail ;\n }\n else {\n cnt = cnt & 7 ? ( ( cnt / 8 ) + 1 ) * 8 : cnt ;\n f = pool_alloc ( sizeof ( * t ) + sizeof ( t -> entries [ 0 ] ) * cnt ) ;\n f -> entry_capacity = cnt ;\n }\n t = ( struct tree_content * ) f ;\n t -> entry_count = 0 ;\n t -> delta_depth = 0 ;\n return t ;\n }",
        "output": "0",
        "idx": 178
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sbr_chirp ( SpectralBandReplication * sbr , SBRData * ch_data ) {\n int i ;\n float new_bw ;\n static const float bw_tab [ ] = {\n 0.0f , 0.75f , 0.9f , 0.98f }\n ;\n for ( i = 0 ;\n i < sbr -> n_q ;\n i ++ ) {\n if ( ch_data -> bs_invf_mode [ 0 ] [ i ] + ch_data -> bs_invf_mode [ 1 ] [ i ] == 1 ) {\n new_bw = 0.6f ;\n }\n else new_bw = bw_tab [ ch_data -> bs_invf_mode [ 0 ] [ i ] ] ;\n if ( new_bw < ch_data -> bw_array [ i ] ) {\n new_bw = 0.75f * new_bw + 0.25f * ch_data -> bw_array [ i ] ;\n }\n else new_bw = 0.90625f * new_bw + 0.09375f * ch_data -> bw_array [ i ] ;\n ch_data -> bw_array [ i ] = new_bw < 0.015625f ? 0.0f : new_bw ;\n }\n }",
        "output": "1",
        "idx": 3358
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_Content ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_Content , Content_choice , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 382
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t u_printf_uinteger_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n int64_t num = args [ 0 ] . int64Value ;\n UNumberFormat * format ;\n UChar result [ UPRINTF_BUFFER_SIZE ] ;\n int32_t minDigits = - 1 ;\n int32_t resultLen ;\n UErrorCode status = U_ZERO_ERROR ;\n if ( info -> fIsShort ) num &= UINT16_MAX ;\n else if ( ! info -> fIsLongLong ) num &= UINT32_MAX ;\n format = u_locbund_getNumberFormat ( formatBundle , UNUM_DECIMAL ) ;\n if ( format == 0 ) return 0 ;\n if ( info -> fPrecision != - 1 ) {\n minDigits = unum_getAttribute ( format , UNUM_MIN_INTEGER_DIGITS ) ;\n unum_setAttribute ( format , UNUM_MIN_INTEGER_DIGITS , info -> fPrecision ) ;\n }\n resultLen = unum_formatInt64 ( format , num , result , UPRINTF_BUFFER_SIZE , 0 , & status ) ;\n if ( U_FAILURE ( status ) ) {\n resultLen = 0 ;\n }\n if ( minDigits != - 1 ) {\n unum_setAttribute ( format , UNUM_MIN_INTEGER_DIGITS , minDigits ) ;\n }\n return handler -> pad_and_justify ( context , info , result , resultLen ) ;\n }",
        "output": "0",
        "idx": 950
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static GList * get_trash_dirs_for_mount ( GMount * mount ) {\n GFile * root ;\n GFile * trash ;\n char * relpath ;\n GList * list ;\n root = g_mount_get_root ( mount ) ;\n if ( root == NULL ) {\n return NULL ;\n }\n list = NULL ;\n if ( g_file_is_native ( root ) ) {\n relpath = g_strdup_printf ( \".Trash/%d\" , getuid ( ) ) ;\n trash = g_file_resolve_relative_path ( root , relpath ) ;\n g_free ( relpath ) ;\n list = g_list_prepend ( list , g_file_get_child ( trash , \"files\" ) ) ;\n list = g_list_prepend ( list , g_file_get_child ( trash , \"info\" ) ) ;\n g_object_unref ( trash ) ;\n relpath = g_strdup_printf ( \".Trash-%d\" , getuid ( ) ) ;\n trash = g_file_get_child ( root , relpath ) ;\n g_free ( relpath ) ;\n list = g_list_prepend ( list , g_file_get_child ( trash , \"files\" ) ) ;\n list = g_list_prepend ( list , g_file_get_child ( trash , \"info\" ) ) ;\n g_object_unref ( trash ) ;\n }\n g_object_unref ( root ) ;\n return list ;\n }",
        "output": "0",
        "idx": 3464
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char * _ISCIIgetName ( const UConverter * cnv ) {\n if ( cnv -> extraInfo ) {\n UConverterDataISCII * myData = ( UConverterDataISCII * ) cnv -> extraInfo ;\n return myData -> name ;\n }\n return NULL ;\n }",
        "output": "1",
        "idx": 3152
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fill_vaapi_pic ( VAPictureH264 * va_pic , Picture * pic , int pic_structure ) {\n if ( pic_structure == 0 ) pic_structure = pic -> f . reference ;\n pic_structure &= PICT_FRAME ;\n va_pic -> picture_id = ff_vaapi_get_surface_id ( pic ) ;\n va_pic -> frame_idx = pic -> long_ref ? pic -> pic_id : pic -> frame_num ;\n va_pic -> flags = 0 ;\n if ( pic_structure != PICT_FRAME ) va_pic -> flags |= ( pic_structure & PICT_TOP_FIELD ) ? VA_PICTURE_H264_TOP_FIELD : VA_PICTURE_H264_BOTTOM_FIELD ;\n if ( pic -> f . reference ) va_pic -> flags |= pic -> long_ref ? VA_PICTURE_H264_LONG_TERM_REFERENCE : VA_PICTURE_H264_SHORT_TERM_REFERENCE ;\n va_pic -> TopFieldOrderCnt = 0 ;\n if ( pic -> field_poc [ 0 ] != INT_MAX ) va_pic -> TopFieldOrderCnt = pic -> field_poc [ 0 ] ;\n va_pic -> BottomFieldOrderCnt = 0 ;\n if ( pic -> field_poc [ 1 ] != INT_MAX ) va_pic -> BottomFieldOrderCnt = pic -> field_poc [ 1 ] ;\n }",
        "output": "1",
        "idx": 528
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int slice_end ( AVCodecContext * avctx , AVFrame * pict ) {\n Mpeg1Context * s1 = avctx -> priv_data ;\n MpegEncContext * s = & s1 -> mpeg_enc_ctx ;\n if ( ! s1 -> mpeg_enc_ctx_allocated || ! s -> current_picture_ptr ) return 0 ;\n if ( s -> avctx -> hwaccel ) {\n if ( s -> avctx -> hwaccel -> end_frame ( s -> avctx ) < 0 ) av_log ( avctx , AV_LOG_ERROR , \"hardware accelerator failed to decode picture\\n\" ) ;\n }\n if ( CONFIG_MPEG_XVMC_DECODER && s -> avctx -> xvmc_acceleration ) ff_xvmc_field_end ( s ) ;\n if ( ! s -> first_field ) {\n s -> current_picture_ptr -> f . qscale_type = FF_QSCALE_TYPE_MPEG2 ;\n ff_er_frame_end ( & s -> er ) ;\n ff_MPV_frame_end ( s ) ;\n if ( s -> pict_type == AV_PICTURE_TYPE_B || s -> low_delay ) {\n * pict = s -> current_picture_ptr -> f ;\n ff_print_debug_info ( s , pict ) ;\n }\n else {\n if ( avctx -> active_thread_type & FF_THREAD_FRAME ) s -> picture_number ++ ;\n if ( s -> last_picture_ptr != NULL ) {\n * pict = s -> last_picture_ptr -> f ;\n ff_print_debug_info ( s , pict ) ;\n }\n }\n return 1 ;\n }\n else {\n return 0 ;\n }\n }",
        "output": "1",
        "idx": 2181
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int qemudParseDriveAddReply ( const char * reply , virDomainDeviceDriveAddressPtr addr ) {\n char * s , * e ;\n if ( ! ( s = strstr ( reply , \"OK \" ) ) ) return - 1 ;\n s += 3 ;\n if ( STRPREFIX ( s , \"bus \" ) ) {\n s += strlen ( \"bus \" ) ;\n if ( virStrToLong_ui ( s , & e , 10 , & addr -> bus ) == - 1 ) {\n VIR_WARN ( \"Unable to parse bus '%s'\" , s ) ;\n return - 1 ;\n }\n if ( ! STRPREFIX ( e , \", \" ) ) {\n VIR_WARN ( \"Expected ', ' parsing drive_add reply '%s'\" , s ) ;\n return - 1 ;\n }\n s = e + 2 ;\n }\n if ( ! STRPREFIX ( s , \"unit \" ) ) {\n VIR_WARN ( \"Expected 'unit ' parsing drive_add reply '%s'\" , s ) ;\n return - 1 ;\n }\n s += strlen ( \"bus \" ) ;\n if ( virStrToLong_ui ( s , & e , 10 , & addr -> unit ) == - 1 ) {\n VIR_WARN ( \"Unable to parse unit number '%s'\" , s ) ;\n return - 1 ;\n }\n return 0 ;\n }",
        "output": "0",
        "idx": 1269
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int btatt_call_dissector_by_dissector_name_with_data ( const char * dissector_name , tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n dissector_handle_t handle ;\n handle = find_dissector ( dissector_name ) ;\n if ( handle != NULL ) return call_dissector_with_data ( handle , tvb , pinfo , tree , data ) ;\n else return call_data_dissector ( tvb , pinfo , tree ) ;\n }",
        "output": "0",
        "idx": 1283
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ExternalProtocolHandlerTest , TestGetBlockStateDefaultDontBlock ) {\n ExternalProtocolHandler : : BlockState block_state = ExternalProtocolHandler : : GetBlockState ( \"mailto\" , profile_ . get ( ) ) ;\n EXPECT_EQ ( ExternalProtocolHandler : : DONT_BLOCK , block_state ) ;\n EXPECT_TRUE ( local_state_ -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;\n EXPECT_FALSE ( profile_ -> GetPrefs ( ) -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;\n }",
        "output": "1",
        "idx": 4346
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( ProfileBrowserTest , URLFetcherUsingExtensionContextDuringIncognitoTeardown ) {\n Browser * incognito_browser = OpenURLOffTheRecord ( browser ( ) -> profile ( ) , GURL ( \"about:blank\" ) ) ;\n RunURLFetcherActiveDuringIncognitoTeardownTest ( incognito_browser , incognito_browser -> profile ( ) -> GetRequestContextForExtensions ( ) ) ;\n }",
        "output": "1",
        "idx": 4416
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static guint16 de_tp_ack ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len _U_ , gchar * add_string _U_ , int string_len _U_ ) {\n guint32 curr_offset ;\n guchar oct ;\n curr_offset = offset ;\n oct = tvb_get_guint8 ( tvb , curr_offset ) ;\n if ( ( oct & 0xF0 ) == 0x80 ) proto_tree_add_uint ( tree , hf_gsm_a_dtap_ack_element , tvb , curr_offset , 1 , oct & 0x01 ) ;\n else proto_tree_add_uint_format_value ( tree , hf_gsm_a_dtap_ack_element , tvb , curr_offset , 1 , 0xFF , \"No acknowledgment element present\" ) ;\n curr_offset += 1 ;\n return ( curr_offset - offset ) ;\n }",
        "output": "0",
        "idx": 2859
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int evhttp_add_header_internal ( struct evkeyvalq * headers , const char * key , const char * value ) {\n struct evkeyval * header = calloc ( 1 , sizeof ( struct evkeyval ) ) ;\n if ( header == NULL ) {\n event_warn ( \"%s: calloc\" , __func__ ) ;\n return ( - 1 ) ;\n }\n if ( ( header -> key = strdup ( key ) ) == NULL ) {\n free ( header ) ;\n event_warn ( \"%s: strdup\" , __func__ ) ;\n return ( - 1 ) ;\n }\n if ( ( header -> value = strdup ( value ) ) == NULL ) {\n free ( header -> key ) ;\n free ( header ) ;\n event_warn ( \"%s: strdup\" , __func__ ) ;\n return ( - 1 ) ;\n }\n TAILQ_INSERT_TAIL ( headers , header , next ) ;\n return ( 0 ) ;\n }",
        "output": "0",
        "idx": 4388
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( FastUnloadTest , BrowserListForceCloseAfterNormalCloseWithFastUnload ) {\n NavigateToDataURL ( BEFORE_UNLOAD_HTML , \"beforeunload\" ) ;\n content : : WindowedNotificationObserver window_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , content : : NotificationService : : AllSources ( ) ) ;\n UnloadResults unload_results ;\n BrowserList : : CloseAllBrowsersWithProfile ( browser ( ) -> profile ( ) , base : : Bind ( & UnloadResults : : AddSuccess , base : : Unretained ( & unload_results ) ) , base : : Bind ( & UnloadResults : : AddAbort , base : : Unretained ( & unload_results ) ) , false ) ;\n BrowserList : : CloseAllBrowsersWithProfile ( browser ( ) -> profile ( ) , base : : Bind ( & UnloadResults : : AddSuccess , base : : Unretained ( & unload_results ) ) , base : : Bind ( & UnloadResults : : AddAbort , base : : Unretained ( & unload_results ) ) , true ) ;\n window_observer . Wait ( ) ;\n EXPECT_EQ ( 1 , unload_results . get_successes ( ) ) ;\n EXPECT_EQ ( 0 , unload_results . get_aborts ( ) ) ;\n }",
        "output": "0",
        "idx": 779
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_notify_info_data_buffer ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n guint32 len ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_notify_info_data_buffer_len , & len ) ;\n offset = dissect_ndr_uint16s ( tvb , offset , pinfo , tree , di , drep , hf_notify_info_data_buffer_data , len ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 3435
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemuMonitorTextDiskSnapshot ( qemuMonitorPtr mon , const char * device , const char * file ) {\n char * cmd = NULL ;\n char * reply = NULL ;\n int ret = - 1 ;\n char * safename ;\n if ( ! ( safename = qemuMonitorEscapeArg ( file ) ) || virAsprintf ( & cmd , \"snapshot_blkdev %s \\\"%s\\\"\" , device , safename ) < 0 ) {\n virReportOOMError ( ) ;\n goto cleanup ;\n }\n if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( \"failed to take snapshot using command '%s'\" ) , cmd ) ;\n goto cleanup ;\n }\n if ( strstr ( reply , \"error while creating qcow2\" ) != NULL || strstr ( reply , \"unknown command:\" ) != NULL ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( \"Failed to take snapshot: %s\" ) , reply ) ;\n goto cleanup ;\n }\n ret = 0 ;\n cleanup : VIR_FREE ( safename ) ;\n VIR_FREE ( cmd ) ;\n VIR_FREE ( reply ) ;\n return ret ;\n }",
        "output": "0",
        "idx": 2765
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_bug5315 ( ) {\n MYSQL_STMT * stmt ;\n const char * stmt_text ;\n int rc ;\n myheader ( \"test_bug5315\" ) ;\n stmt_text = \"SELECT 1\" ;\n stmt = mysql_stmt_init ( mysql ) ;\n rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n DIE_UNLESS ( rc == 0 ) ;\n if ( ! opt_silent ) printf ( \"Excuting mysql_change_user\\n\" ) ;\n mysql_change_user ( mysql , opt_user , opt_password , current_db ) ;\n if ( ! opt_silent ) printf ( \"Excuting mysql_stmt_execute\\n\" ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n DIE_UNLESS ( rc != 0 ) ;\n if ( rc ) {\n if ( ! opt_silent ) printf ( \"Got error (as expected): '%s'\\n\" , mysql_stmt_error ( stmt ) ) ;\n }\n if ( ! opt_silent ) printf ( \"Excuting mysql_stmt_close\\n\" ) ;\n mysql_stmt_close ( stmt ) ;\n if ( ! opt_silent ) printf ( \"Excuting mysql_stmt_init\\n\" ) ;\n stmt = mysql_stmt_init ( mysql ) ;\n rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n DIE_UNLESS ( rc == 0 ) ;\n rc = mysql_stmt_execute ( stmt ) ;\n DIE_UNLESS ( rc == 0 ) ;\n mysql_stmt_close ( stmt ) ;\n }",
        "output": "0",
        "idx": 3986
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void free_days ( UChar * days [ ] ) {\n free_symbols ( days , DAY_COUNT ) ;\n }",
        "output": "0",
        "idx": 766
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ha_checksum mi_byte_checksum ( const uchar * buf , uint length ) {\n ha_checksum crc ;\n const uchar * end = buf + length ;\n for ( crc = 0 ;\n buf != end ;\n buf ++ ) crc = ( ( crc << 1 ) + * ( ( uchar * ) buf ) ) + test ( crc & ( ( ( ha_checksum ) 1 ) << ( 8 * sizeof ( ha_checksum ) - 1 ) ) ) ;\n return crc ;\n }",
        "output": "0",
        "idx": 2814
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline __s32 ceph_seq_cmp ( __u32 a , __u32 b ) {\n return ( __s32 ) a - ( __s32 ) b ;\n }",
        "output": "0",
        "idx": 1054
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct ifblock * compiler_create_ifblock ( struct condition * conds , struct block * blk ) {\n struct ifblock * ifblk ;\n SAFE_CALLOC ( ifblk , 1 , sizeof ( struct ifblock ) ) ;\n ifblk -> conds = conds ;\n ifblk -> blk = blk ;\n return ifblk ;\n }",
        "output": "0",
        "idx": 4094
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void exsltDynEvaluateFunction ( xmlXPathParserContextPtr ctxt , int nargs ) {\n xmlChar * str = NULL ;\n xmlXPathObjectPtr ret = NULL ;\n if ( ctxt == NULL ) return ;\n if ( nargs != 1 ) {\n xsltPrintErrorContext ( xsltXPathGetTransformContext ( ctxt ) , NULL , NULL ) ;\n xsltGenericError ( xsltGenericErrorContext , \"dyn:evalute() : invalid number of args %d\\n\" , nargs ) ;\n ctxt -> error = XPATH_INVALID_ARITY ;\n return ;\n }\n str = xmlXPathPopString ( ctxt ) ;\n if ( ! str || ! xmlStrlen ( str ) ) {\n if ( str ) xmlFree ( str ) ;\n valuePush ( ctxt , xmlXPathNewNodeSet ( NULL ) ) ;\n return ;\n }\n ret = xmlXPathEval ( str , ctxt -> context ) ;\n if ( ret ) valuePush ( ctxt , ret ) ;\n else {\n xsltGenericError ( xsltGenericErrorContext , \"dyn:evaluate() : unable to evaluate expression '%s'\\n\" , str ) ;\n valuePush ( ctxt , xmlXPathNewNodeSet ( NULL ) ) ;\n }\n xmlFree ( str ) ;\n return ;\n }",
        "output": "1",
        "idx": 1259
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemuAgentSuspend ( qemuAgentPtr mon , unsigned int target ) {\n int ret = - 1 ;\n virJSONValuePtr cmd ;\n virJSONValuePtr reply = NULL ;\n cmd = qemuAgentMakeCommand ( qemuAgentSuspendModeTypeToString ( target ) , NULL ) ;\n if ( ! cmd ) return - 1 ;\n mon -> await_event = QEMU_AGENT_EVENT_SUSPEND ;\n ret = qemuAgentCommand ( mon , cmd , & reply , false , VIR_DOMAIN_QEMU_AGENT_COMMAND_BLOCK ) ;\n virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }",
        "output": "0",
        "idx": 848
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int remoteSerializeStreamError ( struct qemud_client * client , remote_error * rerr , int proc , int serial ) {\n return remoteSerializeError ( client , rerr , REMOTE_PROGRAM , REMOTE_PROTOCOL_VERSION , proc , REMOTE_STREAM , serial ) ;\n }",
        "output": "0",
        "idx": 541
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_INTEGER_1_256 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 1U , 256U , NULL , FALSE ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 3659
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PyObject * authGSSClientUnwrap ( PyObject * self , PyObject * args ) {\n gss_client_state * state ;\n PyObject * pystate ;\n char * challenge = NULL ;\n int result = 0 ;\n if ( ! PyArg_ParseTuple ( args , \"Os\" , & pystate , & challenge ) ) return NULL ;\n # if PY_MAJOR_VERSION >= 3 if ( ! PyCapsule_CheckExact ( pystate ) ) {\n # else if ( ! PyCObject_Check ( pystate ) ) {\n # endif PyErr_SetString ( PyExc_TypeError , \"Expected a context object\" ) ;\n return NULL ;\n }\n # if PY_MAJOR_VERSION >= 3 state = PyCapsule_GetPointer ( pystate , NULL ) ;\n # else state = ( gss_client_state * ) PyCObject_AsVoidPtr ( pystate ) ;\n # endif if ( state == NULL ) return NULL ;\n result = authenticate_gss_client_unwrap ( state , challenge ) ;\n if ( result == AUTH_GSS_ERROR ) return NULL ;\n return Py_BuildValue ( \"i\" , result ) ;\n }",
        "output": "0",
        "idx": 3221
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ProtocolHandlerRegistryTest , IgnoreEquivalentProtocolHandler ) {\n ProtocolHandler ph1 = CreateProtocolHandler ( \"test\" , GURL ( \"http://test/%s\" ) , \"test1\" ) ;\n ProtocolHandler ph2 = CreateProtocolHandler ( \"test\" , GURL ( \"http://test/%s\" ) , \"test2\" ) ;\n registry ( ) -> OnIgnoreRegisterProtocolHandler ( ph1 ) ;\n ASSERT_TRUE ( registry ( ) -> IsIgnored ( ph1 ) ) ;\n ASSERT_TRUE ( registry ( ) -> HasIgnoredEquivalent ( ph2 ) ) ;\n registry ( ) -> RemoveIgnoredHandler ( ph1 ) ;\n ASSERT_FALSE ( registry ( ) -> IsIgnored ( ph1 ) ) ;\n ASSERT_FALSE ( registry ( ) -> HasIgnoredEquivalent ( ph2 ) ) ;\n }",
        "output": "1",
        "idx": 42
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;\n __exctype_l ( isalpha_l )",
        "output": "1",
        "idx": 4309
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dissect_h245_Capability ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_Capability , Capability_choice , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 1360
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_bug57058 ( ) {\n MYSQL_RES * res ;\n int rc ;\n DBUG_ENTER ( \"test_bug57058\" ) ;\n myheader ( \"test_bug57058\" ) ;\n rc = mysql_query ( mysql , \"set @@session.long_query_time=0.1\" ) ;\n myquery ( rc ) ;\n DIE_UNLESS ( ! ( mysql -> server_status & SERVER_QUERY_WAS_SLOW ) ) ;\n rc = mysql_query ( mysql , \"select sleep(1)\" ) ;\n myquery ( rc ) ;\n res = mysql_store_result ( mysql ) ;\n DIE_UNLESS ( mysql -> server_status & SERVER_QUERY_WAS_SLOW ) ;\n mysql_free_result ( res ) ;\n rc = mysql_query ( mysql , \"set @@session.long_query_time=default\" ) ;\n myquery ( rc ) ;\n DBUG_VOID_RETURN ;\n }",
        "output": "0",
        "idx": 1650
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlHashTablePtr xmlHashCreate ( int size ) {\n xmlHashTablePtr table ;\n if ( size <= 0 ) size = 256 ;\n table = xmlMalloc ( sizeof ( xmlHashTable ) ) ;\n if ( table ) {\n table -> dict = NULL ;\n table -> size = size ;\n table -> nbElems = 0 ;\n table -> table = xmlMalloc ( size * sizeof ( xmlHashEntry ) ) ;\n if ( table -> table ) {\n memset ( table -> table , 0 , size * sizeof ( xmlHashEntry ) ) ;\n return ( table ) ;\n }\n xmlFree ( table ) ;\n }\n return ( NULL ) ;\n }",
        "output": "1",
        "idx": 1516
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int make_cdt24_entry ( int p1 , int p2 , int16_t * cdt ) {\n int r , b ;\n b = cdt [ p2 ] ;\n r = cdt [ p1 ] << 16 ;\n return ( b + r ) << 1 ;\n }",
        "output": "0",
        "idx": 2405
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ulmbcs_byte_t FindLMBCSUniRange ( UChar uniChar ) {\n const struct _UniLMBCSGrpMap * pTable = UniLMBCSGrpMap ;\n while ( uniChar > pTable -> uniEndRange ) {\n pTable ++ ;\n }\n if ( uniChar >= pTable -> uniStartRange ) {\n return pTable -> GrpType ;\n }\n return ULMBCS_GRP_UNICODE ;\n }",
        "output": "0",
        "idx": 4461
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static UBool U_CALLCONV _enumPropertyStartsRange ( const void * context , UChar32 start , UChar32 end , uint32_t value ) {\n const USetAdder * sa = ( const USetAdder * ) context ;\n sa -> add ( sa -> set , start ) ;\n ( void ) end ;\n ( void ) value ;\n return TRUE ;\n }",
        "output": "0",
        "idx": 2823
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t u_scanf_simple_percent_handler ( UFILE * input , u_scanf_spec_info * info , ufmt_args * args , const UChar * fmt , int32_t * fmtConsumed , int32_t * argConverted ) {\n ( void ) info ;\n ( void ) args ;\n ( void ) fmt ;\n ( void ) fmtConsumed ;\n * argConverted = 0 ;\n if ( u_fgetc ( input ) != 0x0025 ) {\n * argConverted = - 1 ;\n }\n return 1 ;\n }",
        "output": "0",
        "idx": 3960
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean k12_seek_read ( wtap * wth , gint64 seek_off , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) {\n k12_t * k12 = ( k12_t * ) wth -> priv ;\n guint8 * buffer ;\n gint len ;\n K12_DBG ( 5 , ( \"k12_seek_read: ENTER\" ) ) ;\n if ( file_seek ( wth -> random_fh , seek_off , SEEK_SET , err ) == - 1 ) {\n K12_DBG ( 5 , ( \"k12_seek_read: SEEK ERROR\" ) ) ;\n return FALSE ;\n }\n len = get_record ( k12 , wth -> random_fh , seek_off , TRUE , err , err_info ) ;\n if ( len < 0 ) {\n K12_DBG ( 5 , ( \"k12_seek_read: READ ERROR\" ) ) ;\n return FALSE ;\n }\n else if ( len < K12_RECORD_SRC_ID + 4 ) {\n K12_DBG ( 5 , ( \"k12_seek_read: SHORT READ\" ) ) ;\n * err = WTAP_ERR_SHORT_READ ;\n return FALSE ;\n }\n buffer = k12 -> rand_read_buff ;\n process_packet_data ( phdr , buf , buffer , len , k12 ) ;\n K12_DBG ( 5 , ( \"k12_seek_read: DONE OK\" ) ) ;\n return TRUE ;\n }",
        "output": "1",
        "idx": 1976
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void jbig2_decode_mmr_init ( Jbig2MmrCtx * mmr , int width , int height , const byte * data , size_t size ) {\n int i ;\n uint32_t word = 0 ;\n mmr -> width = width ;\n mmr -> height = height ;\n mmr -> data = data ;\n mmr -> size = size ;\n mmr -> data_index = 0 ;\n mmr -> bit_index = 0 ;\n for ( i = 0 ;\n i < size && i < 4 ;\n i ++ ) word |= ( data [ i ] << ( ( 3 - i ) << 3 ) ) ;\n mmr -> word = word ;\n }",
        "output": "1",
        "idx": 4368
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char * _UTF16LEGetName ( const UConverter * cnv ) {\n if ( UCNV_GET_VERSION ( cnv ) == 0 ) {\n return \"UTF-16LE\" ;\n }\n else {\n return \"UTF-16LE,version=1\" ;\n }\n }",
        "output": "1",
        "idx": 2615
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vp9_get_frame_buffer ( void * cb_priv , size_t min_size , vpx_codec_frame_buffer_t * fb ) {\n int i ;\n InternalFrameBufferList * const int_fb_list = ( InternalFrameBufferList * ) cb_priv ;\n if ( int_fb_list == NULL ) return - 1 ;\n for ( i = 0 ;\n i < int_fb_list -> num_internal_frame_buffers ;\n ++ i ) {\n if ( ! int_fb_list -> int_fb [ i ] . in_use ) break ;\n }\n if ( i == int_fb_list -> num_internal_frame_buffers ) return - 1 ;\n if ( int_fb_list -> int_fb [ i ] . size < min_size ) {\n int_fb_list -> int_fb [ i ] . data = ( uint8_t * ) vpx_realloc ( int_fb_list -> int_fb [ i ] . data , min_size ) ;\n if ( ! int_fb_list -> int_fb [ i ] . data ) return - 1 ;\n int_fb_list -> int_fb [ i ] . size = min_size ;\n }\n fb -> data = int_fb_list -> int_fb [ i ] . data ;\n fb -> size = int_fb_list -> int_fb [ i ] . size ;\n int_fb_list -> int_fb [ i ] . in_use = 1 ;\n fb -> priv = & int_fb_list -> int_fb [ i ] ;\n return 0 ;\n }",
        "output": "1",
        "idx": 1715
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sigint ( int sig ) {\n running = 0 ;\n }",
        "output": "0",
        "idx": 4150
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void exsltSaxonRegister ( void ) {\n xsltRegisterExtModule ( SAXON_NAMESPACE , ( xsltExtInitFunction ) exsltSaxonInit , ( xsltExtShutdownFunction ) exsltSaxonShutdown ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"expression\" , SAXON_NAMESPACE , exsltSaxonExpressionFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"eval\" , SAXON_NAMESPACE , exsltSaxonEvalFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"evaluate\" , SAXON_NAMESPACE , exsltSaxonEvaluateFunction ) ;\n xsltRegisterExtModuleFunction ( ( const xmlChar * ) \"line-number\" , SAXON_NAMESPACE , exsltSaxonLineNumberFunction ) ;\n }",
        "output": "1",
        "idx": 4460
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vp9_loop_filter_worker ( void * arg1 , void * arg2 ) {\n LFWorkerData * const lf_data = ( LFWorkerData * ) arg1 ;\n ( void ) arg2 ;\n vp9_loop_filter_rows ( lf_data -> frame_buffer , lf_data -> cm , lf_data -> planes , lf_data -> start , lf_data -> stop , lf_data -> y_only ) ;\n return 1 ;\n }",
        "output": "1",
        "idx": 2650
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vp9_get_tx_size_context ( const MACROBLOCKD * xd ) {\n const int max_tx_size = max_txsize_lookup [ xd -> mi [ 0 ] -> mbmi . sb_type ] ;\n const MB_MODE_INFO * const above_mbmi = get_mbmi ( get_above_mi ( xd ) ) ;\n const MB_MODE_INFO * const left_mbmi = get_mbmi ( get_left_mi ( xd ) ) ;\n const int has_above = above_mbmi != NULL ;\n const int has_left = left_mbmi != NULL ;\n int above_ctx = ( has_above && ! above_mbmi -> skip ) ? ( int ) above_mbmi -> tx_size : max_tx_size ;\n int left_ctx = ( has_left && ! left_mbmi -> skip ) ? ( int ) left_mbmi -> tx_size : max_tx_size ;\n if ( ! has_left ) left_ctx = above_ctx ;\n if ( ! has_above ) above_ctx = left_ctx ;\n return ( above_ctx + left_ctx ) > max_tx_size ;\n }",
        "output": "1",
        "idx": 1290
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_MultiplexEntrySendRelease ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_MultiplexEntrySendRelease , MultiplexEntrySendRelease_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 3754
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void hostnames ( struct parse * pcmd , FILE * fp ) {\n if ( pcmd -> nargs == 0 ) {\n if ( showhostnames ) ( void ) fprintf ( fp , \"hostnames being shown\\n\" ) ;\n else ( void ) fprintf ( fp , \"hostnames not being shown\\n\" ) ;\n }\n else {\n if ( STREQ ( pcmd -> argval [ 0 ] . string , \"yes\" ) ) showhostnames = 1 ;\n else if ( STREQ ( pcmd -> argval [ 0 ] . string , \"no\" ) ) showhostnames = 0 ;\n else ( void ) fprintf ( stderr , \"What?\\n\" ) ;\n }\n }",
        "output": "0",
        "idx": 3723
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sbr_hf_apply_noise_3 ( float ( * Y ) [ 2 ] , const float * s_m , const float * q_filt , int noise , int kx , int m_max ) {\n float phi_sign = 1 - 2 * ( kx & 1 ) ;\n sbr_hf_apply_noise ( Y , s_m , q_filt , noise , 0.0 , - phi_sign , m_max ) ;\n }",
        "output": "1",
        "idx": 2152
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( ExternalProtocolDialogBrowserTest , TestCancel ) {\n ShowDialog ( ) ;\n EXPECT_TRUE ( dialog_ -> Cancel ( ) ) ;\n EXPECT_TRUE ( called_ ) ;\n EXPECT_FALSE ( accept_ ) ;\n EXPECT_TRUE ( cancel_ ) ;\n EXPECT_FALSE ( dont_block_ ) ;\n histogram_tester_ . ExpectBucketCount ( ExternalProtocolHandler : : kRememberCheckboxMetric , 0 , 1 ) ;\n histogram_tester_ . ExpectBucketCount ( ExternalProtocolHandler : : kHandleStateMetric , ExternalProtocolHandler : : DONT_LAUNCH , 1 ) ;\n }",
        "output": "1",
        "idx": 2386
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void erase_screen ( AVCodecContext * avctx ) {\n AnsiContext * s = avctx -> priv_data ;\n int i ;\n for ( i = 0 ;\n i < avctx -> height ;\n i ++ ) memset ( s -> frame -> data [ 0 ] + i * s -> frame -> linesize [ 0 ] , DEFAULT_BG_COLOR , avctx -> width ) ;\n s -> x = s -> y = 0 ;\n }",
        "output": "0",
        "idx": 2466
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int estimate_bits_at_q ( FRAME_TYPE frame_type , int q , int mbs , double correction_factor ) {\n const int bpm = ( int ) ( vp9_rc_bits_per_mb ( frame_type , q , correction_factor ) ) ;\n return ( ( uint64_t ) bpm * mbs ) >> BPER_MB_NORMBITS ;\n }",
        "output": "1",
        "idx": 4066
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ScoredHistoryMatchTest , ScoringScheme ) {\n base : : Time now = base : : Time : : NowFromSystemTime ( ) ;\n std : : string url_string ( \"http://fedcba/\" ) ;\n const GURL url ( url_string ) ;\n history : : URLRow row ( MakeURLRow ( url_string . c_str ( ) , \"\" , 8 , 3 , 1 ) ) ;\n RowWordStarts word_starts ;\n PopulateWordStarts ( row , & word_starts ) ;\n WordStarts two_words_no_offsets ( 2 , 0u ) ;\n VisitInfoVector visits = CreateVisitInfoVector ( 8 , 3 , now ) ;\n ScoredHistoryMatch scored ( row , visits , std : : string ( ) , ASCIIToUTF16 ( \"fed http\" ) , Make2Terms ( \"fed\" , \"http\" ) , two_words_no_offsets , word_starts , false , nullptr , now ) ;\n EXPECT_EQ ( 0 , scored . raw_score ) ;\n base : : AutoReset < bool > reset ( & ScoredHistoryMatch : : allow_scheme_matches_ , true ) ;\n ScoredHistoryMatch scored_with_scheme ( row , visits , std : : string ( ) , ASCIIToUTF16 ( \"fed http\" ) , Make2Terms ( \"fed\" , \"http\" ) , two_words_no_offsets , word_starts , false , nullptr , now ) ;\n EXPECT_GT ( scored_with_scheme . raw_score , 0 ) ;\n }",
        "output": "1",
        "idx": 894
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ProtocolHandlerRegistryTest , MAYBE_TestRemoveHandlerRemovesDefault ) {\n ProtocolHandler ph1 = CreateProtocolHandler ( \"test\" , \"test1\" ) ;\n ProtocolHandler ph2 = CreateProtocolHandler ( \"test\" , \"test2\" ) ;\n ProtocolHandler ph3 = CreateProtocolHandler ( \"test\" , \"test3\" ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph2 ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph3 ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;\n registry ( ) -> RemoveHandler ( ph1 ) ;\n ASSERT_FALSE ( registry ( ) -> IsDefault ( ph1 ) ) ;\n }",
        "output": "0",
        "idx": 4351
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void * xmalloc ( size_t size ) {\n void * ptr = malloc ( size ) ;\n if ( ! ptr && ( size != 0 ) ) {\n perror ( \"xmalloc: Memory allocation failure\" ) ;\n abort ( ) ;\n }\n return ptr ;\n }",
        "output": "1",
        "idx": 548
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_rfc2231_parser ( void ) {\n const char * input = \";\n key4*=us-ascii''foo\" \";\n key*2=ba%\" \";\n key2*0=a\" \";\n key3*0*=us-ascii'en'xyz\" \";\n key*0=\\\"foo\\\"\" \";\n key2*1*=b%25\" \";\n key3*1=plop%\" \";\n key*1=baz\" ;\n const char * output [ ] = {\n \"key\" , \"foobazba%\" , \"key2*\" , \"''ab%25\" , \"key3*\" , \"us-ascii'en'xyzplop%25\" , \"key4*\" , \"us-ascii''foo\" , NULL }\n ;\n struct rfc822_parser_context parser ;\n const char * const * result ;\n unsigned int i ;\n test_begin ( \"rfc2231 parser\" ) ;\n rfc822_parser_init ( & parser , ( const void * ) input , strlen ( input ) , NULL ) ;\n test_assert ( rfc2231_parse ( & parser , & result ) == 0 ) ;\n for ( i = 0 ;\n output [ i ] != NULL && result [ i ] != NULL ;\n i ++ ) test_assert ( strcmp ( output [ i ] , result [ i ] ) == 0 ) ;\n test_assert ( output [ i ] == NULL && result [ i ] == NULL ) ;\n test_end ( ) ;\n }",
        "output": "1",
        "idx": 1068
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_SPOOL_PRINTER_INFO ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n proto_tree * subtree ;\n guint32 level ;\n proto_tree * item ;\n subtree = proto_tree_add_subtree ( tree , tvb , offset , 0 , ett_SPOOL_PRINTER_INFO_LEVEL , & item , \"Spool printer info level\" ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_level , & level ) ;\n switch ( level ) {\n case 3 : {\n guint32 devmode_ptr , secdesc_ptr ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_spool_printer_info_devmode_ptr , & devmode_ptr ) ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , subtree , di , drep , hf_spool_printer_info_secdesc_ptr , & secdesc_ptr ) ;\n if ( devmode_ptr ) offset = dissect_DEVMODE_CTR ( tvb , offset , pinfo , subtree , di , drep ) ;\n if ( secdesc_ptr ) offset = dissect_SEC_DESC_BUF ( tvb , offset , pinfo , subtree , di , drep ) ;\n break ;\n }\n case 2 : default : expert_add_info_format ( pinfo , item , & ei_spool_printer_info_level , \"Unknown spool printer info level %d\" , level ) ;\n break ;\n }\n return offset ;\n }",
        "output": "0",
        "idx": 2099
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dtls1_clear_queues ( SSL * s ) {\n pitem * item = NULL ;\n hm_fragment * frag = NULL ;\n while ( ( item = pqueue_pop ( s -> d1 -> buffered_messages ) ) != NULL ) {\n frag = ( hm_fragment * ) item -> data ;\n dtls1_hm_fragment_free ( frag ) ;\n pitem_free ( item ) ;\n }\n while ( ( item = pqueue_pop ( s -> d1 -> sent_messages ) ) != NULL ) {\n frag = ( hm_fragment * ) item -> data ;\n dtls1_hm_fragment_free ( frag ) ;\n pitem_free ( item ) ;\n }\n }",
        "output": "1",
        "idx": 2495
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void update_consonant_positions ( const hb_ot_shape_plan_t * plan , hb_font_t * font , hb_buffer_t * buffer ) {\n const indic_shape_plan_t * indic_plan = ( const indic_shape_plan_t * ) plan -> data ;\n if ( indic_plan -> config -> base_pos != BASE_POS_LAST ) return ;\n hb_codepoint_t virama ;\n if ( indic_plan -> get_virama_glyph ( font , & virama ) ) {\n hb_face_t * face = font -> face ;\n unsigned int count = buffer -> len ;\n hb_glyph_info_t * info = buffer -> info ;\n for ( unsigned int i = 0 ;\n i < count ;\n i ++ ) if ( info [ i ] . indic_position ( ) == POS_BASE_C ) {\n hb_codepoint_t consonant = info [ i ] . codepoint ;\n info [ i ] . indic_position ( ) = consonant_position_from_face ( indic_plan , consonant , virama , face ) ;\n }\n }\n }",
        "output": "0",
        "idx": 2399
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int SpoolssGeneric_r ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep _U_ ) {\n int len = tvb_reported_length ( tvb ) ;\n proto_tree_add_expert ( tree , pinfo , & ei_unimplemented_dissector , tvb , offset , 0 ) ;\n offset = dissect_doserror ( tvb , len - 4 , pinfo , tree , di , drep , hf_rc , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 2942
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl ) ;\n __exctype ( isdigit ) ;\n __exctype ( islower ) ;\n __exctype ( isgraph ) ;\n __exctype ( isprint ) ;\n __exctype ( ispunct ) ;\n __exctype ( isspace )",
        "output": "1",
        "idx": 1672
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void read_sbr_invf ( SpectralBandReplication * sbr , GetBitContext * gb , SBRData * ch_data ) {\n int i ;\n memcpy ( ch_data -> bs_invf_mode [ 1 ] , ch_data -> bs_invf_mode [ 0 ] , 5 * sizeof ( uint8_t ) ) ;\n for ( i = 0 ;\n i < sbr -> n_q ;\n i ++ ) ch_data -> bs_invf_mode [ 0 ] [ i ] = get_bits ( gb , 2 ) ;\n }",
        "output": "1",
        "idx": 3457
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_FacilityReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 581 \"./asn1/h225/h225.cnf\" gint32 value ;\n h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_FacilityReason , FacilityReason_choice , & value ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> reason = value ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 1474
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t u_printf_hex_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n int64_t num = args [ 0 ] . int64Value ;\n UChar result [ UPRINTF_BUFFER_SIZE ] ;\n int32_t len = UPRINTF_BUFFER_SIZE ;\n if ( info -> fIsShort ) num &= UINT16_MAX ;\n else if ( ! info -> fIsLongLong ) num &= UINT32_MAX ;\n ufmt_64tou ( result , & len , num , 16 , ( UBool ) ( info -> fSpec == 0x0078 ) , ( info -> fPrecision == - 1 && info -> fZero ) ? info -> fWidth : info -> fPrecision ) ;\n if ( num != 0 && info -> fAlt && len < UPRINTF_BUFFER_SIZE - 2 ) {\n memmove ( result + 2 , result , len * sizeof ( UChar ) ) ;\n result [ 0 ] = 0x0030 ;\n result [ 1 ] = info -> fSpec ;\n len += 2 ;\n }\n return handler -> pad_and_justify ( context , info , result , len ) ;\n }",
        "output": "1",
        "idx": 3815
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint64_t openpic_src_read ( void * opaque , uint64_t addr , unsigned len ) {\n OpenPICState * opp = opaque ;\n uint32_t retval ;\n int idx ;\n DPRINTF ( \"%s: addr %#\" HWADDR_PRIx \"\\n\" , __func__ , addr ) ;\n retval = 0xFFFFFFFF ;\n addr = addr & 0xffff ;\n idx = addr >> 5 ;\n switch ( addr & 0x1f ) {\n case 0x00 : retval = read_IRQreg_ivpr ( opp , idx ) ;\n break ;\n case 0x10 : retval = read_IRQreg_idr ( opp , idx ) ;\n break ;\n case 0x18 : retval = read_IRQreg_ilr ( opp , idx ) ;\n break ;\n }\n DPRINTF ( \"%s: => 0x%08x\\n\" , __func__ , retval ) ;\n return retval ;\n }",
        "output": "0",
        "idx": 3352
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xhci_stop ( XHCIState * xhci ) {\n trace_usb_xhci_stop ( ) ;\n xhci -> usbsts |= USBSTS_HCH ;\n xhci -> crcr_low &= ~ CRCR_CRR ;\n }",
        "output": "0",
        "idx": 4389
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int event_reinit ( struct event_base * base ) {\n const struct eventop * evsel = base -> evsel ;\n void * evbase = base -> evbase ;\n int res = 0 ;\n struct event * ev ;\n if ( ! evsel -> need_reinit ) return ( 0 ) ;\n if ( base -> sig . ev_signal_added ) {\n event_queue_remove ( base , & base -> sig . ev_signal , EVLIST_INSERTED ) ;\n if ( base -> sig . ev_signal . ev_flags & EVLIST_ACTIVE ) event_queue_remove ( base , & base -> sig . ev_signal , EVLIST_ACTIVE ) ;\n base -> sig . ev_signal_added = 0 ;\n }\n if ( base -> evsel -> dealloc != NULL ) base -> evsel -> dealloc ( base , base -> evbase ) ;\n evbase = base -> evbase = evsel -> init ( base ) ;\n if ( base -> evbase == NULL ) event_errx ( 1 , \"%s: could not reinitialize event mechanism\" , __func__ ) ;\n TAILQ_FOREACH ( ev , & base -> eventqueue , ev_next ) {\n if ( evsel -> add ( evbase , ev ) == - 1 ) res = - 1 ;\n }\n return ( res ) ;\n }",
        "output": "1",
        "idx": 3773
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pk_transaction_get_categories ( PkTransaction * transaction , GVariant * params , GDBusMethodInvocation * context ) {\n g_autoptr ( GError ) error = NULL ;\n g_return_if_fail ( PK_IS_TRANSACTION ( transaction ) ) ;\n g_return_if_fail ( transaction -> priv -> tid != NULL ) ;\n g_debug ( \"GetCategories method called\" ) ;\n if ( ! pk_backend_is_implemented ( transaction -> priv -> backend , PK_ROLE_ENUM_GET_CATEGORIES ) ) {\n g_set_error ( & error , PK_TRANSACTION_ERROR , PK_TRANSACTION_ERROR_NOT_SUPPORTED , \"GetCategories not supported by backend\" ) ;\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_ERROR ) ;\n goto out ;\n }\n pk_transaction_set_role ( transaction , PK_ROLE_ENUM_GET_CATEGORIES ) ;\n pk_transaction_set_state ( transaction , PK_TRANSACTION_STATE_READY ) ;\n out : pk_transaction_dbus_return ( context , error ) ;\n }",
        "output": "0",
        "idx": 774
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void check_cluster_versions ( void ) {\n prep_status ( \"Checking cluster versions\" ) ;\n old_cluster . major_version = get_major_server_version ( & old_cluster ) ;\n new_cluster . major_version = get_major_server_version ( & new_cluster ) ;\n if ( GET_MAJOR_VERSION ( old_cluster . major_version ) < 804 ) pg_fatal ( \"This utility can only upgrade from PostgreSQL version 8.4 and later.\\n\" ) ;\n if ( GET_MAJOR_VERSION ( new_cluster . major_version ) != GET_MAJOR_VERSION ( PG_VERSION_NUM ) ) pg_fatal ( \"This utility can only upgrade to PostgreSQL version %s.\\n\" , PG_MAJORVERSION ) ;\n if ( old_cluster . major_version > new_cluster . major_version ) pg_fatal ( \"This utility cannot be used to downgrade to older major PostgreSQL versions.\\n\" ) ;\n get_bin_version ( & old_cluster ) ;\n get_bin_version ( & new_cluster ) ;\n if ( GET_MAJOR_VERSION ( old_cluster . major_version ) != GET_MAJOR_VERSION ( old_cluster . bin_version ) ) pg_fatal ( \"Old cluster data and binary directories are from different major versions.\\n\" ) ;\n if ( GET_MAJOR_VERSION ( new_cluster . major_version ) != GET_MAJOR_VERSION ( new_cluster . bin_version ) ) pg_fatal ( \"New cluster data and binary directories are from different major versions.\\n\" ) ;\n check_ok ( ) ;\n }",
        "output": "0",
        "idx": 1268
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spl_filesystem_dir_it_move_forward ( zend_object_iterator * iter TSRMLS_DC ) {\n spl_filesystem_object * object = spl_filesystem_iterator_to_object ( ( spl_filesystem_iterator * ) iter ) ;\n object -> u . dir . index ++ ;\n spl_filesystem_dir_read ( object TSRMLS_CC ) ;\n if ( object -> file_name ) {\n efree ( object -> file_name ) ;\n object -> file_name = NULL ;\n }\n }",
        "output": "1",
        "idx": 2502
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void Type_Measurement_Free ( struct _cms_typehandler_struct * self , void * Ptr ) {\n _cmsFree ( self -> ContextID , Ptr ) ;\n }",
        "output": "0",
        "idx": 232
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vpx_svc_get_encode_frame_count ( const SvcContext * svc_ctx ) {\n const SvcInternal * const si = get_const_svc_internal ( svc_ctx ) ;\n if ( svc_ctx == NULL || si == NULL ) return 0 ;\n return si -> encode_frame_count ;\n }",
        "output": "1",
        "idx": 1096
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "OM_uint32 kg_set_ccache_name ( OM_uint32 * minor_status , const char * name ) {\n char * new_name = NULL ;\n char * swap = NULL ;\n char * kg_ccache_name ;\n krb5_error_code kerr ;\n if ( name ) {\n new_name = strdup ( name ) ;\n if ( new_name == NULL ) {\n * minor_status = ENOMEM ;\n return GSS_S_FAILURE ;\n }\n }\n kg_ccache_name = k5_getspecific ( K5_KEY_GSS_KRB5_CCACHE_NAME ) ;\n swap = kg_ccache_name ;\n kg_ccache_name = new_name ;\n new_name = swap ;\n kerr = k5_setspecific ( K5_KEY_GSS_KRB5_CCACHE_NAME , kg_ccache_name ) ;\n if ( kerr != 0 ) {\n free ( kg_ccache_name ) ;\n * minor_status = kerr ;\n return GSS_S_FAILURE ;\n }\n free ( new_name ) ;\n * minor_status = 0 ;\n return GSS_S_COMPLETE ;\n }",
        "output": "0",
        "idx": 699
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline RV34VLC * choose_vlc_set ( int quant , int mod , int type ) {\n if ( mod == 2 && quant < 19 ) quant += 10 ;\n else if ( mod && quant < 26 ) quant += 5 ;\n return type ? & inter_vlcs [ rv34_quant_to_vlc_set [ 1 ] [ av_clip ( quant , 0 , 30 ) ] ] : & intra_vlcs [ rv34_quant_to_vlc_set [ 0 ] [ av_clip ( quant , 0 , 30 ) ] ] ;\n }",
        "output": "0",
        "idx": 2286
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int xsltSetCtxtSecurityPrefs ( xsltSecurityPrefsPtr sec , xsltTransformContextPtr ctxt ) {\n if ( ctxt == NULL ) return ( - 1 ) ;\n ctxt -> sec = ( void * ) sec ;\n return ( 0 ) ;\n }",
        "output": "1",
        "idx": 1718
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void or_bits ( REP_SET * to , REP_SET * from ) {\n reg1 uint i ;\n for ( i = 0 ;\n i < to -> size_of_bits ;\n i ++ ) to -> bits [ i ] |= from -> bits [ i ] ;\n return ;\n }",
        "output": "0",
        "idx": 1764
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TSReturnCode TSMimeHdrFieldValueStringInsert ( TSMBuffer bufp , TSMLoc hdr , TSMLoc field , int idx , const char * value , int length ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( ( sdk_sanity_check_mime_hdr_handle ( hdr ) == TS_SUCCESS ) || ( sdk_sanity_check_http_hdr_handle ( hdr ) == TS_SUCCESS ) ) ;\n sdk_assert ( sdk_sanity_check_field_handle ( field , hdr ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) value ) == TS_SUCCESS ) ;\n if ( ! isWriteable ( bufp ) ) {\n return TS_ERROR ;\n }\n if ( length == - 1 ) {\n length = strlen ( value ) ;\n }\n TSMimeFieldValueInsert ( bufp , field , value , length , idx ) ;\n return TS_SUCCESS ;\n }",
        "output": "0",
        "idx": 930
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kq_dealloc ( struct event_base * base , void * arg ) {\n struct kqop * kqop = arg ;\n if ( kqop -> changes ) free ( kqop -> changes ) ;\n if ( kqop -> events ) free ( kqop -> events ) ;\n if ( kqop -> kq >= 0 && kqop -> pid == getpid ( ) ) close ( kqop -> kq ) ;\n memset ( kqop , 0 , sizeof ( struct kqop ) ) ;\n free ( kqop ) ;\n }",
        "output": "1",
        "idx": 2142
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void * Type_Data_Read ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , cmsUInt32Number * nItems , cmsUInt32Number SizeOfTag ) {\n cmsICCData * BinData ;\n cmsUInt32Number LenOfData ;\n * nItems = 0 ;\n if ( SizeOfTag < sizeof ( cmsUInt32Number ) ) return NULL ;\n LenOfData = SizeOfTag - sizeof ( cmsUInt32Number ) ;\n if ( LenOfData > INT_MAX ) return NULL ;\n BinData = ( cmsICCData * ) _cmsMalloc ( self -> ContextID , sizeof ( cmsICCData ) + LenOfData - 1 ) ;\n if ( BinData == NULL ) return NULL ;\n BinData -> len = LenOfData ;\n if ( ! _cmsReadUInt32Number ( io , & BinData -> flag ) ) {\n _cmsFree ( self -> ContextID , BinData ) ;\n return NULL ;\n }\n if ( io -> Read ( io , BinData -> data , sizeof ( cmsUInt8Number ) , LenOfData ) != LenOfData ) {\n _cmsFree ( self -> ContextID , BinData ) ;\n return NULL ;\n }\n * nItems = 1 ;\n return ( void * ) BinData ;\n }",
        "output": "0",
        "idx": 1564
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_lpf_vertical_16_sse2 ( unsigned char * s , int p , const unsigned char * blimit , const unsigned char * limit , const unsigned char * thresh ) {\n DECLARE_ALIGNED_ARRAY ( 8 , unsigned char , t_dst , 8 * 16 ) ;\n unsigned char * src [ 2 ] ;\n unsigned char * dst [ 2 ] ;\n src [ 0 ] = s - 8 ;\n src [ 1 ] = s ;\n dst [ 0 ] = t_dst ;\n dst [ 1 ] = t_dst + 8 * 8 ;\n transpose ( src , p , dst , 8 , 2 ) ;\n mb_lpf_horizontal_edge_w_sse2_8 ( t_dst + 8 * 8 , 8 , blimit , limit , thresh ) ;\n src [ 0 ] = t_dst ;\n src [ 1 ] = t_dst + 8 * 8 ;\n dst [ 0 ] = s - 8 ;\n dst [ 1 ] = s ;\n transpose ( src , 8 , dst , p , 2 ) ;\n }",
        "output": "1",
        "idx": 2877
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fz_colorspace * fz_default_output_intent ( fz_context * ctx , const fz_default_colorspaces * default_cs ) {\n if ( default_cs ) return default_cs -> oi ;\n else return NULL ;\n }",
        "output": "0",
        "idx": 268
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void pfkey_exit_proc ( struct net * net ) {\n }",
        "output": "0",
        "idx": 2493
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipvideo_decode_block_opcode_0x5 ( IpvideoContext * s ) {\n signed char x , y ;\n x = bytestream2_get_byte ( & s -> stream_ptr ) ;\n y = bytestream2_get_byte ( & s -> stream_ptr ) ;\n av_dlog ( NULL , \" motion bytes = %d, %d\\n\" , x , y ) ;\n return copy_from ( s , & s -> last_frame , x , y ) ;\n }",
        "output": "1",
        "idx": 447
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void read_embedded_server_arguments ( const char * name ) {\n char argument [ 1024 ] , buff [ FN_REFLEN ] , * str = 0 ;\n FILE * file ;\n if ( ! test_if_hard_path ( name ) ) {\n strxmov ( buff , opt_basedir , name , NullS ) ;\n name = buff ;\n }\n fn_format ( buff , name , \"\" , \"\" , MY_UNPACK_FILENAME ) ;\n if ( ! embedded_server_arg_count ) {\n embedded_server_arg_count = 1 ;\n embedded_server_args [ 0 ] = ( char * ) \"\" ;\n }\n if ( ! ( file = my_fopen ( buff , O_RDONLY | FILE_BINARY , MYF ( MY_WME ) ) ) ) die ( \"Failed to open file '%s'\" , buff ) ;\n while ( embedded_server_arg_count < MAX_EMBEDDED_SERVER_ARGS && ( str = fgets ( argument , sizeof ( argument ) , file ) ) ) {\n * ( strend ( str ) - 1 ) = 0 ;\n if ( ! ( embedded_server_args [ embedded_server_arg_count ] = ( char * ) my_strdup ( str , MYF ( MY_WME ) ) ) ) {\n my_fclose ( file , MYF ( 0 ) ) ;\n die ( \"Out of memory\" ) ;\n }\n embedded_server_arg_count ++ ;\n }\n my_fclose ( file , MYF ( 0 ) ) ;\n if ( str ) die ( \"Too many arguments in option file: %s\" , name ) ;\n return ;\n }",
        "output": "0",
        "idx": 3867
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_idct8x8_1_add_c ( const int16_t * input , uint8_t * dest , int stride ) {\n int i , j ;\n int a1 ;\n int16_t out = dct_const_round_shift ( input [ 0 ] * cospi_16_64 ) ;\n out = dct_const_round_shift ( out * cospi_16_64 ) ;\n a1 = ROUND_POWER_OF_TWO ( out , 5 ) ;\n for ( j = 0 ;\n j < 8 ;\n ++ j ) {\n for ( i = 0 ;\n i < 8 ;\n ++ i ) dest [ i ] = clip_pixel ( dest [ i ] + a1 ) ;\n dest += stride ;\n }\n }",
        "output": "1",
        "idx": 165
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vp9_get_switchable_rate ( const VP9_COMP * cpi ) {\n const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;\n const MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;\n const int ctx = vp9_get_pred_context_switchable_interp ( xd ) ;\n return SWITCHABLE_INTERP_RATE_FACTOR * cpi -> switchable_interp_costs [ ctx ] [ mbmi -> interp_filter ] ;\n }",
        "output": "1",
        "idx": 1073
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( SyncBookmarkDataTypeControllerTest , StartBookmarkModelNotReady ) {\n CreateBookmarkModel ( DONT_LOAD_MODEL ) ;\n SetStartExpectations ( ) ;\n SetAssociateExpectations ( ) ;\n EXPECT_CALL ( start_callback_ , Run ( DataTypeController : : OK , _ , _ ) ) ;\n bookmark_dtc_ -> LoadModels ( base : : Bind ( & ModelLoadCallbackMock : : Run , base : : Unretained ( & model_load_callback_ ) ) ) ;\n EXPECT_EQ ( DataTypeController : : MODEL_STARTING , bookmark_dtc_ -> state ( ) ) ;\n TestingPrefServiceSimple prefs ;\n bookmark_model_ -> Load ( & prefs , std : : string ( ) , base : : FilePath ( ) , base : : ThreadTaskRunnerHandle : : Get ( ) , base : : ThreadTaskRunnerHandle : : Get ( ) ) ;\n bookmarks : : test : : WaitForBookmarkModelToLoad ( bookmark_model_ . get ( ) ) ;\n EXPECT_EQ ( DataTypeController : : MODEL_LOADED , bookmark_dtc_ -> state ( ) ) ;\n bookmark_dtc_ -> StartAssociating ( base : : Bind ( & StartCallbackMock : : Run , base : : Unretained ( & start_callback_ ) ) ) ;\n base : : MessageLoop : : current ( ) -> RunUntilIdle ( ) ;\n EXPECT_EQ ( DataTypeController : : RUNNING , bookmark_dtc_ -> state ( ) ) ;\n }",
        "output": "1",
        "idx": 2699
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int evhttp_is_connection_keepalive ( struct evkeyvalq * headers ) {\n const char * connection = evhttp_find_header ( headers , \"Connection\" ) ;\n return ( connection != NULL && strncasecmp ( connection , \"keep-alive\" , 10 ) == 0 ) ;\n }",
        "output": "0",
        "idx": 2739
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PyString_Concat ( register PyObject * * pv , register PyObject * w ) {\n register PyObject * v ;\n if ( * pv == NULL ) return ;\n if ( w == NULL || ! PyString_Check ( * pv ) ) {\n Py_CLEAR ( * pv ) ;\n return ;\n }\n v = string_concat ( ( PyStringObject * ) * pv , w ) ;\n Py_SETREF ( * pv , v ) ;\n }",
        "output": "0",
        "idx": 3770
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline realpath_cache_bucket * realpath_cache_find ( const char * path , int path_len , time_t t TSRMLS_DC ) {\n # ifdef PHP_WIN32 unsigned long key = realpath_cache_key ( path , path_len TSRMLS_CC ) ;\n # else unsigned long key = realpath_cache_key ( path , path_len ) ;\n # endif unsigned long n = key % ( sizeof ( CWDG ( realpath_cache ) ) / sizeof ( CWDG ( realpath_cache ) [ 0 ] ) ) ;\n realpath_cache_bucket * * bucket = & CWDG ( realpath_cache ) [ n ] ;\n while ( * bucket != NULL ) {\n if ( CWDG ( realpath_cache_ttl ) && ( * bucket ) -> expires < t ) {\n realpath_cache_bucket * r = * bucket ;\n * bucket = ( * bucket ) -> next ;\n if ( r -> path == r -> realpath ) {\n CWDG ( realpath_cache_size ) -= sizeof ( realpath_cache_bucket ) + r -> path_len + 1 ;\n }\n else {\n CWDG ( realpath_cache_size ) -= sizeof ( realpath_cache_bucket ) + r -> path_len + 1 + r -> realpath_len + 1 ;\n }\n free ( r ) ;\n }\n else if ( key == ( * bucket ) -> key && path_len == ( * bucket ) -> path_len && memcmp ( path , ( * bucket ) -> path , path_len ) == 0 ) {\n return * bucket ;\n }\n else {\n bucket = & ( * bucket ) -> next ;\n }\n }\n return NULL ;\n }",
        "output": "1",
        "idx": 3230
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void gx_device_set_media_size ( gx_device * dev , double media_width , double media_height ) {\n dev -> MediaSize [ 0 ] = media_width ;\n dev -> MediaSize [ 1 ] = media_height ;\n gx_device_set_hwsize_from_media ( dev ) ;\n }",
        "output": "0",
        "idx": 4315
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "proto_item * proto_tree_add_double_format_value ( proto_tree * tree , int hfindex , tvbuff_t * tvb , gint start , gint length , double value , const char * format , ... ) {\n proto_item * pi ;\n va_list ap ;\n pi = proto_tree_add_double ( tree , hfindex , tvb , start , length , value ) ;\n if ( pi != tree ) {\n va_start ( ap , format ) ;\n proto_tree_set_representation_value ( pi , format , ap ) ;\n va_end ( ap ) ;\n }\n return pi ;\n }",
        "output": "0",
        "idx": 4193
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * timelib_string ( Scanner * s ) {\n char * tmp = calloc ( 1 , s -> cur - s -> tok + 1 ) ;\n memcpy ( tmp , s -> tok , s -> cur - s -> tok ) ;\n return tmp ;\n }",
        "output": "0",
        "idx": 2777
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int gic_get_current_cpu ( GICState * s ) {\n if ( s -> num_cpu > 1 ) {\n return current_cpu -> cpu_index ;\n }\n return 0 ;\n }",
        "output": "0",
        "idx": 2445
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl ) ;\n __exctype ( isdigit ) ;\n __exctype ( islower ) ;\n __exctype ( isgraph ) ;\n __exctype ( isprint ) ;\n __exctype ( ispunct ) ;\n __exctype ( isspace ) ;\n __exctype ( isupper )",
        "output": "1",
        "idx": 293
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "enum nss_status CONCAT ( _nss_files_set , ENTNAME ) ( int stayopen ) {\n enum nss_status status ;\n __libc_lock_lock ( lock ) ;\n status = internal_setent ( stayopen ) ;\n if ( status == NSS_STATUS_SUCCESS && fgetpos ( stream , & position ) < 0 ) {\n fclose ( stream ) ;\n stream = NULL ;\n status = NSS_STATUS_UNAVAIL ;\n }\n last_use = getent ;\n __libc_lock_unlock ( lock ) ;\n return status ;\n }",
        "output": "1",
        "idx": 66
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_InfoRequestNak ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_InfoRequestNak , InfoRequestNak_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 2476
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool e1000e_rx_l3_cso_enabled ( E1000ECore * core ) {\n return ! ! ( core -> mac [ RXCSUM ] & E1000_RXCSUM_IPOFLD ) ;\n }",
        "output": "0",
        "idx": 2455
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CURLcode Curl_auth_create_plain_message ( struct Curl_easy * data , const char * userp , const char * passwdp , char * * outptr , size_t * outlen ) {\n CURLcode result ;\n char * plainauth ;\n size_t ulen ;\n size_t plen ;\n size_t plainlen ;\n * outlen = 0 ;\n * outptr = NULL ;\n ulen = strlen ( userp ) ;\n plen = strlen ( passwdp ) ;\n if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) return CURLE_OUT_OF_MEMORY ;\n plainlen = 2 * ulen + plen + 2 ;\n plainauth = malloc ( plainlen ) ;\n if ( ! plainauth ) return CURLE_OUT_OF_MEMORY ;\n memcpy ( plainauth , userp , ulen ) ;\n plainauth [ ulen ] = '\\0' ;\n memcpy ( plainauth + ulen + 1 , userp , ulen ) ;\n plainauth [ 2 * ulen + 1 ] = '\\0' ;\n memcpy ( plainauth + 2 * ulen + 2 , passwdp , plen ) ;\n result = Curl_base64_encode ( data , plainauth , plainlen , outptr , outlen ) ;\n free ( plainauth ) ;\n return result ;\n }",
        "output": "1",
        "idx": 3018
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __inline__ __u32 __fswahw32 ( __u32 val ) {\n # ifdef __arch_swahw32 return __arch_swahw32 ( val ) ;\n # else return ___constant_swahw32 ( val ) ;\n # endif }",
        "output": "1",
        "idx": 2968
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int search_request_new ( int type , const char * const name , int flags , evdns_callback_type user_callback , void * user_arg ) {\n assert ( type == TYPE_A || type == TYPE_AAAA ) ;\n if ( ( ( flags & DNS_QUERY_NO_SEARCH ) == 0 ) && global_search_state && global_search_state -> num_domains ) {\n struct request * req ;\n if ( string_num_dots ( name ) >= global_search_state -> ndots ) {\n req = request_new ( type , name , flags , user_callback , user_arg ) ;\n if ( ! req ) return 1 ;\n req -> search_index = - 1 ;\n }\n else {\n char * const new_name = search_make_new ( global_search_state , 0 , name ) ;\n if ( ! new_name ) return 1 ;\n req = request_new ( type , new_name , flags , user_callback , user_arg ) ;\n free ( new_name ) ;\n if ( ! req ) return 1 ;\n req -> search_index = 0 ;\n }\n req -> search_origname = strdup ( name ) ;\n req -> search_state = global_search_state ;\n req -> search_flags = flags ;\n global_search_state -> refcount ++ ;\n request_submit ( req ) ;\n return 0 ;\n }\n else {\n struct request * const req = request_new ( type , name , flags , user_callback , user_arg ) ;\n if ( ! req ) return 1 ;\n request_submit ( req ) ;\n return 0 ;\n }\n }",
        "output": "0",
        "idx": 955
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int udev_device_info ( struct libusb_context * ctx , int detached , struct udev_device * udev_dev , uint8_t * busnum , uint8_t * devaddr , const char * * sys_name ) {\n const char * dev_node ;\n dev_node = udev_device_get_devnode ( udev_dev ) ;\n if ( ! dev_node ) {\n return LIBUSB_ERROR_OTHER ;\n }\n * sys_name = udev_device_get_sysname ( udev_dev ) ;\n if ( ! * sys_name ) {\n return LIBUSB_ERROR_OTHER ;\n }\n return linux_get_device_address ( ctx , detached , busnum , devaddr , dev_node , * sys_name ) ;\n }",
        "output": "1",
        "idx": 1622
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_fht16x16_c ( const int16_t * input , int16_t * output , int stride , int tx_type ) {\n if ( tx_type == DCT_DCT ) {\n vp9_fdct16x16_c ( input , output , stride ) ;\n }\n else {\n int16_t out [ 256 ] ;\n int16_t * outptr = & out [ 0 ] ;\n int i , j ;\n int16_t temp_in [ 16 ] , temp_out [ 16 ] ;\n const transform_2d ht = FHT_16 [ tx_type ] ;\n for ( i = 0 ;\n i < 16 ;\n ++ i ) {\n for ( j = 0 ;\n j < 16 ;\n ++ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ;\n ht . cols ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 16 ;\n ++ j ) outptr [ j * 16 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ;\n }\n for ( i = 0 ;\n i < 16 ;\n ++ i ) {\n for ( j = 0 ;\n j < 16 ;\n ++ j ) temp_in [ j ] = out [ j + i * 16 ] ;\n ht . rows ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 16 ;\n ++ j ) output [ j + i * 16 ] = temp_out [ j ] ;\n }\n }\n }",
        "output": "1",
        "idx": 972
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "REGRESSION_TEST ( SDK_API_TSIOBufferReaderConsume ) ( RegressionTest * test , int , int * pstatus ) {\n bool test_passed = false ;\n * pstatus = REGRESSION_TEST_INPROGRESS ;\n TSIOBuffer bufp = TSIOBufferSizedCreate ( TS_IOBUFFER_SIZE_INDEX_4K ) ;\n TSIOBufferReader readerp = TSIOBufferReaderAlloc ( bufp ) ;\n TSIOBufferProduce ( bufp , 10 ) ;\n TSIOBufferReaderConsume ( readerp , 10 ) ;\n int64_t reader_avail = TSIOBufferReaderAvail ( readerp ) ;\n if ( reader_avail == 0 ) {\n SDK_RPRINT ( test , \"TSIOBufferReaderConsume\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n test_passed = true ;\n }\n else {\n SDK_RPRINT ( test , \"TSIOBufferReaderConsume\" , \"TestCase1\" , TC_FAIL , \"failed\" ) ;\n }\n * pstatus = ( ( test_passed == true ) ? REGRESSION_TEST_PASSED : REGRESSION_TEST_FAILED ) ;\n return ;\n }",
        "output": "0",
        "idx": 466
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char )",
        "output": "1",
        "idx": 3861
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_RequestSeqNum ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 724 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 1U , 65535U , & ( h225_pi -> requestSeqNum ) , FALSE ) ;\n # line 732 \"./asn1/h225/h225.cnf\" }\n return offset ;\n }",
        "output": "1",
        "idx": 353
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dec_connection_count ( THD * thd ) {\n mysql_mutex_lock ( & LOCK_connection_count ) ;\n ( * thd -> scheduler -> connection_count ) -- ;\n mysql_mutex_unlock ( & LOCK_connection_count ) ;\n }",
        "output": "0",
        "idx": 3653
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void count_segs ( const VP9_COMMON * cm , MACROBLOCKD * xd , const TileInfo * tile , MODE_INFO * * mi , int * no_pred_segcounts , int ( * temporal_predictor_count ) [ 2 ] , int * t_unpred_seg_counts , int bw , int bh , int mi_row , int mi_col ) {\n int segment_id ;\n if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ;\n xd -> mi = mi ;\n segment_id = xd -> mi [ 0 ] -> mbmi . segment_id ;\n set_mi_row_col ( xd , tile , mi_row , bh , mi_col , bw , cm -> mi_rows , cm -> mi_cols ) ;\n no_pred_segcounts [ segment_id ] ++ ;\n if ( cm -> frame_type != KEY_FRAME ) {\n const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ;\n const int pred_segment_id = vp9_get_segment_id ( cm , cm -> last_frame_seg_map , bsize , mi_row , mi_col ) ;\n const int pred_flag = pred_segment_id == segment_id ;\n const int pred_context = vp9_get_pred_context_seg_id ( xd ) ;\n xd -> mi [ 0 ] -> mbmi . seg_id_predicted = pred_flag ;\n temporal_predictor_count [ pred_context ] [ pred_flag ] ++ ;\n if ( ! pred_flag ) t_unpred_seg_counts [ segment_id ] ++ ;\n }\n }",
        "output": "1",
        "idx": 1020
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( SessionRestorePageLoadMetricsBrowserTest , SingleTabSessionRestore ) {\n ui_test_utils : : NavigateToURL ( browser ( ) , GetTestURL ( ) ) ;\n SessionRestorePaintWaiter session_restore_paint_waiter ;\n QuitBrowserAndRestore ( browser ( ) ) ;\n session_restore_paint_waiter . WaitForForegroundTabs ( 1 ) ;\n ExpectFirstPaintMetricsTotalCount ( 1 ) ;\n }",
        "output": "0",
        "idx": 1531
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void gx_device_init_on_stack ( gx_device * dev , const gx_device * proto , gs_memory_t * mem ) {\n memcpy ( dev , proto , proto -> params_size ) ;\n dev -> memory = mem ;\n dev -> retained = 0 ;\n dev -> pad = proto -> pad ;\n dev -> log2_align_mod = proto -> log2_align_mod ;\n dev -> is_planar = proto -> is_planar ;\n rc_init ( dev , NULL , 0 ) ;\n }",
        "output": "0",
        "idx": 3519
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rtp_packetize_mpa ( sout_stream_id_sys_t * id , block_t * in ) {\n int i_max = rtp_mtu ( id ) - 4 ;\n int i_count = ( in -> i_buffer + i_max - 1 ) / i_max ;\n uint8_t * p_data = in -> p_buffer ;\n int i_data = in -> i_buffer ;\n int i ;\n for ( i = 0 ;\n i < i_count ;\n i ++ ) {\n int i_payload = __MIN ( i_max , i_data ) ;\n block_t * out = block_Alloc ( 16 + i_payload ) ;\n rtp_packetize_common ( id , out , ( i == i_count - 1 ) ? 1 : 0 , in -> i_pts ) ;\n SetWBE ( out -> p_buffer + 12 , 0 ) ;\n SetWBE ( out -> p_buffer + 14 , i * i_max ) ;\n memcpy ( & out -> p_buffer [ 16 ] , p_data , i_payload ) ;\n out -> i_dts = in -> i_dts + i * in -> i_length / i_count ;\n out -> i_length = in -> i_length / i_count ;\n rtp_packetize_send ( id , out ) ;\n p_data += i_payload ;\n i_data -= i_payload ;\n }\n block_Release ( in ) ;\n return VLC_SUCCESS ;\n }",
        "output": "0",
        "idx": 203
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct kvm_cpuid2 * get_supported_cpuid ( KVMState * s ) {\n struct kvm_cpuid2 * cpuid ;\n int max = 1 ;\n if ( cpuid_cache != NULL ) {\n return cpuid_cache ;\n }\n while ( ( cpuid = try_get_cpuid ( s , max ) ) == NULL ) {\n max *= 2 ;\n }\n cpuid_cache = cpuid ;\n return cpuid ;\n }",
        "output": "0",
        "idx": 1468
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void initial_reordering ( const hb_ot_shape_plan_t * plan , hb_font_t * font , hb_buffer_t * buffer ) {\n update_consonant_positions ( plan , font , buffer ) ;\n insert_dotted_circles ( plan , font , buffer ) ;\n hb_glyph_info_t * info = buffer -> info ;\n unsigned int count = buffer -> len ;\n if ( unlikely ( ! count ) ) return ;\n unsigned int last = 0 ;\n unsigned int last_syllable = info [ 0 ] . syllable ( ) ;\n for ( unsigned int i = 1 ;\n i < count ;\n i ++ ) if ( last_syllable != info [ i ] . syllable ( ) ) {\n initial_reordering_syllable ( plan , font -> face , buffer , last , i ) ;\n last = i ;\n last_syllable = info [ last ] . syllable ( ) ;\n }\n initial_reordering_syllable ( plan , font -> face , buffer , last , count ) ;\n }",
        "output": "1",
        "idx": 1727
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void alloc_limit_failure ( char * fn_name , size_t size ) {\n fprintf ( stderr , \"%s: Maximum allocation size exceeded \" \"(maxsize = %lu;\n size = %lu).\\n\" , fn_name , ( unsigned long ) alloc_limit , ( unsigned long ) size ) ;\n }",
        "output": "1",
        "idx": 3841
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int jbig2_end_of_stripe ( Jbig2Ctx * ctx , Jbig2Segment * segment , const uint8_t * segment_data ) {\n Jbig2Page page = ctx -> pages [ ctx -> current_page ] ;\n int end_row ;\n end_row = jbig2_get_int32 ( segment_data ) ;\n if ( end_row < page . end_row ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , segment -> number , \"end of stripe segment with non-positive end row advance\" \" (new end row %d vs current end row %d)\" , end_row , page . end_row ) ;\n }\n else {\n jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , \"end of stripe: advancing end row to %d\" , end_row ) ;\n }\n page . end_row = end_row ;\n return 0 ;\n }",
        "output": "1",
        "idx": 737
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int estimate_array_length ( Node * arrayexpr ) {\n arrayexpr = strip_array_coercion ( arrayexpr ) ;\n if ( arrayexpr && IsA ( arrayexpr , Const ) ) {\n Datum arraydatum = ( ( Const * ) arrayexpr ) -> constvalue ;\n bool arrayisnull = ( ( Const * ) arrayexpr ) -> constisnull ;\n ArrayType * arrayval ;\n if ( arrayisnull ) return 0 ;\n arrayval = DatumGetArrayTypeP ( arraydatum ) ;\n return ArrayGetNItems ( ARR_NDIM ( arrayval ) , ARR_DIMS ( arrayval ) ) ;\n }\n else if ( arrayexpr && IsA ( arrayexpr , ArrayExpr ) && ! ( ( ArrayExpr * ) arrayexpr ) -> multidims ) {\n return list_length ( ( ( ArrayExpr * ) arrayexpr ) -> elements ) ;\n }\n else {\n return 10 ;\n }\n }",
        "output": "0",
        "idx": 3247
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int alac_set_info ( ALACContext * alac ) {\n GetByteContext gb ;\n bytestream2_init ( & gb , alac -> avctx -> extradata , alac -> avctx -> extradata_size ) ;\n bytestream2_skipu ( & gb , 12 ) ;\n alac -> max_samples_per_frame = bytestream2_get_be32u ( & gb ) ;\n if ( ! alac -> max_samples_per_frame || alac -> max_samples_per_frame > INT_MAX ) {\n av_log ( alac -> avctx , AV_LOG_ERROR , \"max samples per frame invalid: %u\\n\" , alac -> max_samples_per_frame ) ;\n return AVERROR_INVALIDDATA ;\n }\n bytestream2_skipu ( & gb , 1 ) ;\n alac -> sample_size = bytestream2_get_byteu ( & gb ) ;\n alac -> rice_history_mult = bytestream2_get_byteu ( & gb ) ;\n alac -> rice_initial_history = bytestream2_get_byteu ( & gb ) ;\n alac -> rice_limit = bytestream2_get_byteu ( & gb ) ;\n alac -> channels = bytestream2_get_byteu ( & gb ) ;\n bytestream2_get_be16u ( & gb ) ;\n bytestream2_get_be32u ( & gb ) ;\n bytestream2_get_be32u ( & gb ) ;\n bytestream2_get_be32u ( & gb ) ;\n return 0 ;\n }",
        "output": "0",
        "idx": 3090
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static guint mac_is_channel_hash ( gconstpointer key ) {\n const mac_is_channel * ch = ( const mac_is_channel * ) key ;\n return ( ch -> ueid << 4 ) | ch -> lchid ;\n }",
        "output": "0",
        "idx": 2904
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_pred_buffer ( PRED_BUFFER * p , int len ) {\n int i ;\n for ( i = 0 ;\n i < len ;\n i ++ ) {\n if ( ! p [ i ] . in_use ) {\n p [ i ] . in_use = 1 ;\n return i ;\n }\n }\n return - 1 ;\n }",
        "output": "1",
        "idx": 4103
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileObject , next ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n spl_filesystem_file_free_line ( intern TSRMLS_CC ) ;\n if ( SPL_HAS_FLAG ( intern -> flags , SPL_FILE_OBJECT_READ_AHEAD ) ) {\n spl_filesystem_file_read_line ( getThis ( ) , intern , 1 TSRMLS_CC ) ;\n }\n intern -> u . file . current_line_num ++ ;\n }",
        "output": "1",
        "idx": 601
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void evhttp_maybe_add_content_length_header ( struct evkeyvalq * headers , long content_length ) {\n if ( evhttp_find_header ( headers , \"Transfer-Encoding\" ) == NULL && evhttp_find_header ( headers , \"Content-Length\" ) == NULL ) {\n char len [ 12 ] ;\n evutil_snprintf ( len , sizeof ( len ) , \"%ld\" , content_length ) ;\n evhttp_add_header ( headers , \"Content-Length\" , len ) ;\n }\n }",
        "output": "1",
        "idx": 4222
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __inline__ void TLV_LIST_STEP ( struct tlv_list_desc * list ) {\n __u16 tlv_space = TLV_ALIGN ( ntohs ( list -> tlv_ptr -> tlv_len ) ) ;\n list -> tlv_ptr = ( struct tlv_desc * ) ( ( char * ) list -> tlv_ptr + tlv_space ) ;\n list -> tlv_space -= tlv_space ;\n }",
        "output": "0",
        "idx": 3419
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ulong get_sort ( uint count , ... ) {\n va_list args ;\n va_start ( args , count ) ;\n ulong sort = 0 ;\n DBUG_ASSERT ( count <= 4 ) ;\n while ( count -- ) {\n char * start , * str = va_arg ( args , char * ) ;\n uint chars = 0 ;\n uint wild_pos = 0 ;\n if ( ( start = str ) ) {\n for ( ;\n * str ;\n str ++ ) {\n if ( * str == wild_prefix && str [ 1 ] ) str ++ ;\n else if ( * str == wild_many || * str == wild_one ) {\n wild_pos = ( uint ) ( str - start ) + 1 ;\n break ;\n }\n chars = 128 ;\n }\n }\n sort = ( sort << 8 ) + ( wild_pos ? min ( wild_pos , 127 ) : chars ) ;\n }\n va_end ( args ) ;\n return sort ;\n }",
        "output": "1",
        "idx": 909
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void run_on_cpu ( CPUState * cpu , void ( * func ) ( void * data ) , void * data ) {\n struct qemu_work_item wi ;\n if ( qemu_cpu_is_self ( cpu ) ) {\n func ( data ) ;\n return ;\n }\n wi . func = func ;\n wi . data = data ;\n if ( cpu -> queued_work_first == NULL ) {\n cpu -> queued_work_first = & wi ;\n }\n else {\n cpu -> queued_work_last -> next = & wi ;\n }\n cpu -> queued_work_last = & wi ;\n wi . next = NULL ;\n wi . done = false ;\n qemu_cpu_kick ( cpu ) ;\n while ( ! wi . done ) {\n CPUArchState * self_env = cpu_single_env ;\n qemu_cond_wait ( & qemu_work_cond , & qemu_global_mutex ) ;\n cpu_single_env = self_env ;\n }\n }",
        "output": "1",
        "idx": 583
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_Facility_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 441 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_Facility_UUIE , Facility_UUIE_sequence ) ;\n # line 445 \"./asn1/h225/h225.cnf\" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> cs_type = H225_FACILITY ;\n g_snprintf ( h225_pi -> frame_label , 50 , \"%s\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) ) ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 406
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _UTF16BEReset ( UConverter * cnv , UConverterResetChoice choice ) {\n if ( choice <= UCNV_RESET_TO_UNICODE ) {\n if ( UCNV_GET_VERSION ( cnv ) == 0 ) {\n cnv -> mode = 8 ;\n }\n else {\n cnv -> mode = 0 ;\n }\n }\n if ( choice != UCNV_RESET_TO_UNICODE && UCNV_GET_VERSION ( cnv ) == 1 ) {\n cnv -> fromUnicodeStatus = UCNV_NEED_TO_WRITE_BOM ;\n }\n }",
        "output": "1",
        "idx": 936
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_FECData ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_FECData , FECData_choice , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 705
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( DirectoryIterator , rewind ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n intern -> u . dir . index = 0 ;\n if ( intern -> u . dir . dirp ) {\n php_stream_rewinddir ( intern -> u . dir . dirp ) ;\n }\n spl_filesystem_dir_read ( intern TSRMLS_CC ) ;\n }",
        "output": "1",
        "idx": 3181
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void evbuffer_align ( struct evbuffer * buf ) {\n memmove ( buf -> orig_buffer , buf -> buffer , buf -> off ) ;\n buf -> buffer = buf -> orig_buffer ;\n buf -> misalign = 0 ;\n }",
        "output": "0",
        "idx": 60
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Buf _build_rc_buf ( int rc , uint16_t rpc_version ) {\n Buf buf = NULL ;\n slurm_msg_t msg ;\n return_code_msg_t data ;\n data . return_code = rc ;\n slurm_msg_t_init ( & msg ) ;\n msg . msg_type = RESPONSE_SLURM_RC ;\n msg . data = & data ;\n buf = init_buf ( 128 ) ;\n pack16 ( msg . msg_type , buf ) ;\n if ( pack_msg ( & msg , buf ) != SLURM_SUCCESS ) FREE_NULL_BUFFER ( buf ) ;\n return buf ;\n }",
        "output": "0",
        "idx": 2669
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( WebUsbDetectorTest , UsbDeviceAddedAndRemoved ) {\n base : : string16 product_name = base : : UTF8ToUTF16 ( kProductName_1 ) ;\n GURL landing_page ( kLandingPage_1 ) ;\n scoped_refptr < device : : MockUsbDevice > device ( new device : : MockUsbDevice ( 0 , 1 , \"Google\" , kProductName_1 , \"002\" , landing_page ) ) ;\n std : : string guid = device -> guid ( ) ;\n Initialize ( ) ;\n device_client_ . usb_service ( ) -> AddDevice ( device ) ;\n message_center : : Notification * notification = message_center_ -> FindVisibleNotificationById ( guid ) ;\n ASSERT_TRUE ( notification != nullptr ) ;\n base : : string16 expected_title = base : : ASCIIToUTF16 ( \"Google Product A detected\" ) ;\n EXPECT_EQ ( expected_title , notification -> title ( ) ) ;\n base : : string16 expected_message = base : : ASCIIToUTF16 ( \"Go to www.google.com/A to connect.\" ) ;\n EXPECT_EQ ( expected_message , notification -> message ( ) ) ;\n EXPECT_TRUE ( notification -> delegate ( ) != nullptr ) ;\n device_client_ . usb_service ( ) -> RemoveDevice ( device ) ;\n EXPECT_TRUE ( message_center_ -> FindVisibleNotificationById ( guid ) == nullptr ) ;\n }",
        "output": "1",
        "idx": 4477
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int in_table_int16 ( const int16_t * table , int last_el , int16_t needle ) {\n int i ;\n for ( i = 0 ;\n i <= last_el ;\n i ++ ) if ( table [ i ] == needle ) return 1 ;\n return 0 ;\n }",
        "output": "1",
        "idx": 1636
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( NewAvatarMenuButtonTest , MAYBE_SignOut ) {\n if ( ! profiles : : IsMultipleProfilesEnabled ( ) ) return ;\n CreateTestingProfile ( ) ;\n ASSERT_NO_FATAL_FAILURE ( StartAvatarMenu ( ) ) ;\n BrowserList * browser_list = BrowserList : : GetInstance ( chrome : : GetActiveDesktop ( ) ) ;\n EXPECT_EQ ( 1U , browser_list -> size ( ) ) ;\n content : : WindowedNotificationObserver window_close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , content : : Source < Browser > ( browser ( ) ) ) ;\n AvatarMenu * menu = ProfileChooserView : : profile_bubble_ -> avatar_menu_ . get ( ) ;\n const AvatarMenu : : Item & menu_item_before = menu -> GetItemAt ( menu -> GetActiveProfileIndex ( ) ) ;\n EXPECT_FALSE ( menu_item_before . signin_required ) ;\n ui : : MouseEvent mouse_ev ( ui : : ET_MOUSE_RELEASED , gfx : : Point ( ) , gfx : : Point ( ) , 0 , 0 ) ;\n ProfileChooserView : : profile_bubble_ -> ButtonPressed ( ProfileChooserView : : profile_bubble_ -> lock_button_ , mouse_ev ) ;\n EXPECT_TRUE ( menu -> GetItemAt ( menu -> GetActiveProfileIndex ( ) ) . signin_required ) ;\n window_close_observer . Wait ( ) ;\n EXPECT_TRUE ( browser_list -> empty ( ) ) ;\n if ( ! UserManager : : IsShowing ( ) ) base : : MessageLoop : : current ( ) -> RunUntilIdle ( ) ;\n UserManager : : Hide ( ) ;\n }",
        "output": "0",
        "idx": 759
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int make_cdt16_entry ( int p1 , int p2 , int16_t * cdt ) {\n int r , b , lo ;\n b = cdt [ p2 ] ;\n r = cdt [ p1 ] << 11 ;\n lo = b + r ;\n return ( lo + ( lo << 16 ) ) << 1 ;\n }",
        "output": "0",
        "idx": 1378
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void main_file_cleanup ( main_file * xfile ) {\n XD3_ASSERT ( xfile != NULL ) ;\n if ( main_file_isopen ( xfile ) ) {\n main_file_close ( xfile ) ;\n }\n if ( xfile -> snprintf_buf != NULL ) {\n main_free ( xfile -> snprintf_buf ) ;\n xfile -> snprintf_buf = NULL ;\n }\n if ( xfile -> filename_copy != NULL ) {\n main_free ( xfile -> filename_copy ) ;\n xfile -> filename_copy = NULL ;\n }\n }",
        "output": "0",
        "idx": 2715
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_T_cryptoEPPwdHash ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_T_cryptoEPPwdHash , T_cryptoEPPwdHash_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 4235
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileObject , ftell ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n long ret = php_stream_tell ( intern -> u . file . stream ) ;\n if ( ret == - 1 ) {\n RETURN_FALSE ;\n }\n else {\n RETURN_LONG ( ret ) ;\n }\n }",
        "output": "1",
        "idx": 2727
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sf_count_t psf_fwrite ( const void * ptr , sf_count_t bytes , sf_count_t items , SF_PRIVATE * psf ) {\n sf_count_t total = 0 ;\n ssize_t count ;\n if ( psf -> virtual_io ) return psf -> vio . write ( ptr , bytes * items , psf -> vio_user_data ) / bytes ;\n items *= bytes ;\n if ( items <= 0 ) return 0 ;\n while ( items > 0 ) {\n count = ( items > SENSIBLE_SIZE ) ? SENSIBLE_SIZE : items ;\n count = write ( psf -> file . filedes , ( ( const char * ) ptr ) + total , count ) ;\n if ( count == - 1 ) {\n if ( errno == EINTR ) continue ;\n psf_log_syserr ( psf , errno ) ;\n break ;\n }\n ;\n if ( count == 0 ) break ;\n total += count ;\n items -= count ;\n }\n ;\n if ( psf -> is_pipe ) psf -> pipeoffset += total ;\n return total / bytes ;\n }",
        "output": "1",
        "idx": 1579
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( DirectoryIterator , next ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n int skip_dots = SPL_HAS_FLAG ( intern -> flags , SPL_FILE_DIR_SKIPDOTS ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n intern -> u . dir . index ++ ;\n do {\n spl_filesystem_dir_read ( intern TSRMLS_CC ) ;\n }\n while ( skip_dots && spl_filesystem_is_dot ( intern -> u . dir . entry . d_name ) ) ;\n if ( intern -> file_name ) {\n efree ( intern -> file_name ) ;\n intern -> file_name = NULL ;\n }\n }",
        "output": "1",
        "idx": 2433
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char * * slirp_dnssearch ( const StringList * dnsname ) {\n const StringList * c = dnsname ;\n size_t i = 0 , num_opts = 0 ;\n const char * * ret ;\n while ( c ) {\n num_opts ++ ;\n c = c -> next ;\n }\n if ( num_opts == 0 ) {\n return NULL ;\n }\n ret = g_malloc ( ( num_opts + 1 ) * sizeof ( * ret ) ) ;\n c = dnsname ;\n while ( c ) {\n ret [ i ++ ] = c -> value -> str ;\n c = c -> next ;\n }\n ret [ i ] = NULL ;\n return ret ;\n }",
        "output": "0",
        "idx": 899
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_InfoRequestNakReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 690 \"./asn1/h225/h225.cnf\" gint32 value ;\n h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_InfoRequestNakReason , InfoRequestNakReason_choice , & value ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> reason = value ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 1196
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void reset_skip_tx_size ( VP9_COMMON * cm , TX_SIZE max_tx_size ) {\n int mi_row , mi_col ;\n const int mis = cm -> mi_stride ;\n MODE_INFO * * mi_ptr = cm -> mi_grid_visible ;\n for ( mi_row = 0 ;\n mi_row < cm -> mi_rows ;\n ++ mi_row , mi_ptr += mis ) {\n for ( mi_col = 0 ;\n mi_col < cm -> mi_cols ;\n ++ mi_col ) {\n if ( mi_ptr [ mi_col ] -> mbmi . tx_size > max_tx_size ) mi_ptr [ mi_col ] -> mbmi . tx_size = max_tx_size ;\n }\n }\n }",
        "output": "1",
        "idx": 112
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vga_draw_line8 ( VGACommonState * vga , uint8_t * d , uint32_t addr , int width ) {\n uint32_t * palette ;\n int x ;\n palette = vga -> last_palette ;\n width >>= 3 ;\n for ( x = 0 ;\n x < width ;\n x ++ ) {\n ( ( uint32_t * ) d ) [ 0 ] = palette [ vga_read_byte ( vga , addr + 0 ) ] ;\n ( ( uint32_t * ) d ) [ 1 ] = palette [ vga_read_byte ( vga , addr + 1 ) ] ;\n ( ( uint32_t * ) d ) [ 2 ] = palette [ vga_read_byte ( vga , addr + 2 ) ] ;\n ( ( uint32_t * ) d ) [ 3 ] = palette [ vga_read_byte ( vga , addr + 3 ) ] ;\n ( ( uint32_t * ) d ) [ 4 ] = palette [ vga_read_byte ( vga , addr + 4 ) ] ;\n ( ( uint32_t * ) d ) [ 5 ] = palette [ vga_read_byte ( vga , addr + 5 ) ] ;\n ( ( uint32_t * ) d ) [ 6 ] = palette [ vga_read_byte ( vga , addr + 6 ) ] ;\n ( ( uint32_t * ) d ) [ 7 ] = palette [ vga_read_byte ( vga , addr + 7 ) ] ;\n d += 32 ;\n addr += 8 ;\n }\n }",
        "output": "0",
        "idx": 531
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int archive_read_format_cpio_bid ( struct archive_read * a , int best_bid ) {\n const unsigned char * p ;\n struct cpio * cpio ;\n int bid ;\n ( void ) best_bid ;\n cpio = ( struct cpio * ) ( a -> format -> data ) ;\n if ( ( p = __archive_read_ahead ( a , 6 , NULL ) ) == NULL ) return ( - 1 ) ;\n bid = 0 ;\n if ( memcmp ( p , \"070707\" , 6 ) == 0 ) {\n cpio -> read_header = header_odc ;\n bid += 48 ;\n }\n else if ( memcmp ( p , \"070727\" , 6 ) == 0 ) {\n cpio -> read_header = header_odc ;\n bid += 48 ;\n }\n else if ( memcmp ( p , \"070701\" , 6 ) == 0 ) {\n cpio -> read_header = header_newc ;\n bid += 48 ;\n }\n else if ( memcmp ( p , \"070702\" , 6 ) == 0 ) {\n cpio -> read_header = header_newc ;\n bid += 48 ;\n }\n else if ( p [ 0 ] * 256 + p [ 1 ] == 070707 ) {\n cpio -> read_header = header_bin_be ;\n bid += 16 ;\n }\n else if ( p [ 0 ] + p [ 1 ] * 256 == 070707 ) {\n cpio -> read_header = header_bin_le ;\n bid += 16 ;\n }\n else return ( ARCHIVE_WARN ) ;\n return ( bid ) ;\n }",
        "output": "0",
        "idx": 3269
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t u_printf_count_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n int32_t * count = ( int32_t * ) ( args [ 0 ] . ptrValue ) ;\n * count = info -> fWidth ;\n return 0 ;\n }",
        "output": "1",
        "idx": 286
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , FirstMeaningfulPaintNotRecorded ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n auto waiter = CreatePageLoadMetricsWaiter ( ) ;\n waiter -> AddPageExpectation ( TimingField : : FIRST_CONTENTFUL_PAINT ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( \"/page_load_metrics/page_with_active_connections.html\" ) ) ;\n waiter -> Wait ( ) ;\n NavigateToUntrackedUrl ( ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramFirstContentfulPaint , 1 ) ;\n histogram_tester_ . ExpectUniqueSample ( internal : : kHistogramFirstMeaningfulPaintStatus , internal : : FIRST_MEANINGFUL_PAINT_DID_NOT_REACH_NETWORK_STABLE , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramFirstMeaningfulPaint , 0 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramParseStartToFirstMeaningfulPaint , 0 ) ;\n }",
        "output": "0",
        "idx": 3734
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ar_parse_gnu_filename_table ( struct archive_read * a ) {\n struct ar * ar ;\n char * p ;\n size_t size ;\n ar = ( struct ar * ) ( a -> format -> data ) ;\n size = ar -> strtab_size ;\n for ( p = ar -> strtab ;\n p < ar -> strtab + size - 1 ;\n ++ p ) {\n if ( * p == '/' ) {\n * p ++ = '\\0' ;\n if ( * p != '\\n' ) goto bad_string_table ;\n * p = '\\0' ;\n }\n }\n if ( p != ar -> strtab + size && * p != '\\n' && * p != '`' ) goto bad_string_table ;\n ar -> strtab [ size - 1 ] = '\\0' ;\n return ( ARCHIVE_OK ) ;\n bad_string_table : archive_set_error ( & a -> archive , EINVAL , \"Invalid string table\" ) ;\n free ( ar -> strtab ) ;\n ar -> strtab = NULL ;\n return ( ARCHIVE_WARN ) ;\n }",
        "output": "1",
        "idx": 2288
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_spoolss_string_parm ( tvbuff_t * tvb , gint offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep , const char * text ) {\n offset = dissect_ndr_pointer ( tvb , offset , pinfo , tree , di , drep , dissect_spoolss_string_parm_data , NDR_POINTER_UNIQUE , text , - 1 ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 1812
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int uwsgi_php_init ( void ) {\n struct uwsgi_string_list * pset = uphp . set ;\n struct uwsgi_string_list * append_config = uphp . append_config ;\n # ifdef ZTS tsrm_startup ( 1 , 1 , 0 , NULL ) ;\n # endif sapi_startup ( & uwsgi_sapi_module ) ;\n while ( append_config ) {\n uwsgi_php_append_config ( append_config -> value ) ;\n append_config = append_config -> next ;\n }\n while ( pset ) {\n uwsgi_php_set ( pset -> value ) ;\n pset = pset -> next ;\n }\n if ( uphp . dump_config ) {\n uwsgi_log ( \"--- PHP custom config ---\\n\\n\" ) ;\n uwsgi_log ( \"%s\\n\" , uwsgi_sapi_module . ini_entries ) ;\n uwsgi_log ( \"--- end of PHP custom config ---\\n\" ) ;\n }\n if ( uphp . docroot ) {\n char * orig_docroot = uphp . docroot ;\n uphp . docroot = uwsgi_expand_path ( uphp . docroot , strlen ( uphp . docroot ) , NULL ) ;\n if ( ! uphp . docroot ) {\n uwsgi_log ( \"unable to set php docroot to %s\\n\" , orig_docroot ) ;\n exit ( 1 ) ;\n }\n }\n if ( uphp . sapi_name ) {\n uwsgi_sapi_module . name = uphp . sapi_name ;\n }\n uwsgi_sapi_module . startup ( & uwsgi_sapi_module ) ;\n uwsgi_log ( \"PHP %s initialized\\n\" , PHP_VERSION ) ;\n return 0 ;\n }",
        "output": "1",
        "idx": 4448
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct addrinfo * make_addrinfo ( const char * address , u_short port ) {\n struct addrinfo * aitop = NULL ;\n # ifdef HAVE_GETADDRINFO struct addrinfo ai ;\n char strport [ NI_MAXSERV ] ;\n int ai_result ;\n memset ( & ai , 0 , sizeof ( ai ) ) ;\n ai . ai_family = AF_INET ;\n ai . ai_socktype = SOCK_STREAM ;\n ai . ai_flags = AI_PASSIVE ;\n evutil_snprintf ( strport , sizeof ( strport ) , \"%d\" , port ) ;\n if ( ( ai_result = getaddrinfo ( address , strport , & ai , & aitop ) ) != 0 ) {\n if ( ai_result == EAI_SYSTEM ) event_warn ( \"getaddrinfo\" ) ;\n else event_warnx ( \"getaddrinfo: %s\" , gai_strerror ( ai_result ) ) ;\n return ( NULL ) ;\n }\n # else static int cur ;\n static struct addrinfo ai [ 2 ] ;\n if ( ++ cur == 2 ) cur = 0 ;\n if ( fake_getaddrinfo ( address , & ai [ cur ] ) < 0 ) {\n event_warn ( \"fake_getaddrinfo\" ) ;\n return ( NULL ) ;\n }\n aitop = & ai [ cur ] ;\n ( ( struct sockaddr_in * ) aitop -> ai_addr ) -> sin_port = htons ( port ) ;\n # endif return ( aitop ) ;\n }",
        "output": "0",
        "idx": 3517
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fmtstr ( char * * sbuffer , char * * buffer , size_t * currlen , size_t * maxlen , const char * value , int flags , int min , int max ) {\n int padlen , strln ;\n int cnt = 0 ;\n if ( value == 0 ) value = \"<NULL>\" ;\n for ( strln = 0 ;\n value [ strln ] ;\n ++ strln ) ;\n padlen = min - strln ;\n if ( padlen < 0 ) padlen = 0 ;\n if ( flags & DP_F_MINUS ) padlen = - padlen ;\n while ( ( padlen > 0 ) && ( cnt < max ) ) {\n doapr_outch ( sbuffer , buffer , currlen , maxlen , ' ' ) ;\n -- padlen ;\n ++ cnt ;\n }\n while ( * value && ( cnt < max ) ) {\n doapr_outch ( sbuffer , buffer , currlen , maxlen , * value ++ ) ;\n ++ cnt ;\n }\n while ( ( padlen < 0 ) && ( cnt < max ) ) {\n doapr_outch ( sbuffer , buffer , currlen , maxlen , ' ' ) ;\n ++ padlen ;\n ++ cnt ;\n }\n }",
        "output": "1",
        "idx": 2092
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void config_connection_input ( struct config_connection * conn ) {\n const char * const * args , * line ;\n switch ( i_stream_read ( conn -> input ) ) {\n case - 2 : i_error ( \"BUG: Config client connection sent too much data\" ) ;\n config_connection_destroy ( conn ) ;\n return ;\n case - 1 : config_connection_destroy ( conn ) ;\n return ;\n }\n if ( ! conn -> version_received ) {\n line = i_stream_next_line ( conn -> input ) ;\n if ( line == NULL ) return ;\n if ( ! version_string_verify ( line , \"config\" , CONFIG_CLIENT_PROTOCOL_MAJOR_VERSION ) ) {\n i_error ( \"Config client not compatible with this server \" \"(mixed old and new binaries?)\" ) ;\n config_connection_destroy ( conn ) ;\n return ;\n }\n conn -> version_received = TRUE ;\n }\n while ( ( args = config_connection_next_line ( conn ) ) != NULL ) {\n if ( args [ 0 ] == NULL ) continue ;\n if ( strcmp ( args [ 0 ] , \"REQ\" ) == 0 ) {\n if ( config_connection_request ( conn , args + 1 ) < 0 ) break ;\n }\n }\n }",
        "output": "1",
        "idx": 1322
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static vpx_codec_err_t ctrl_set_lossless ( vpx_codec_alg_priv_t * ctx , va_list args ) {\n struct vp9_extracfg extra_cfg = ctx -> extra_cfg ;\n extra_cfg . lossless = CAST ( VP9E_SET_LOSSLESS , args ) ;\n return update_extra_cfg ( ctx , & extra_cfg ) ;\n }",
        "output": "0",
        "idx": 2919
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "tdata_t _TIFFmalloc ( tsize_t s ) {\n if ( s == 0 ) return ( ( void * ) NULL ) ;\n return ( malloc ( ( size_t ) s ) ) ;\n }",
        "output": "1",
        "idx": 2333
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void relpTcpHintBurstEnd ( relpTcp_t * pThis ) {\n setCORKopt ( pThis -> sock , 0 ) ;\n }",
        "output": "0",
        "idx": 3683
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static kadm5_ret_t make_ks_from_keys ( krb5_context context , int n_keys , krb5_keyblock * keyblocks , krb5_key_salt_tuple * * ks_tuple ) {\n int i ;\n * ks_tuple = calloc ( n_keys , sizeof ( * * ks_tuple ) ) ;\n if ( * ks_tuple == NULL ) return ENOMEM ;\n for ( i = 0 ;\n i < n_keys ;\n i ++ ) {\n ( * ks_tuple ) [ i ] . ks_enctype = keyblocks [ i ] . enctype ;\n ( * ks_tuple ) [ i ] . ks_salttype = KRB5_KDB_SALTTYPE_NORMAL ;\n }\n return 0 ;\n }",
        "output": "0",
        "idx": 2543
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemuMonitorJSONSetMigrationSpeed ( qemuMonitorPtr mon , unsigned long bandwidth ) {\n int ret ;\n virJSONValuePtr cmd ;\n virJSONValuePtr reply = NULL ;\n cmd = qemuMonitorJSONMakeCommand ( \"migrate_set_speed\" , \"U:value\" , bandwidth * 1024ULL * 1024ULL , NULL ) ;\n if ( ! cmd ) return - 1 ;\n ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;\n if ( ret == 0 ) ret = qemuMonitorJSONCheckError ( cmd , reply ) ;\n virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }",
        "output": "0",
        "idx": 4363
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int archive_read_support_format_all ( struct archive * a ) {\n archive_check_magic ( a , ARCHIVE_READ_MAGIC , ARCHIVE_STATE_NEW , \"archive_read_support_format_all\" ) ;\n archive_read_support_format_ar ( a ) ;\n archive_read_support_format_cpio ( a ) ;\n archive_read_support_format_empty ( a ) ;\n archive_read_support_format_lha ( a ) ;\n archive_read_support_format_mtree ( a ) ;\n archive_read_support_format_tar ( a ) ;\n archive_read_support_format_xar ( a ) ;\n archive_read_support_format_7zip ( a ) ;\n archive_read_support_format_cab ( a ) ;\n archive_read_support_format_rar ( a ) ;\n archive_read_support_format_iso9660 ( a ) ;\n archive_read_support_format_zip ( a ) ;\n archive_clear_error ( a ) ;\n return ( ARCHIVE_OK ) ;\n }",
        "output": "1",
        "idx": 1121
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TSReturnCode TSMimeHdrFieldCreateNamed ( TSMBuffer bufp , TSMLoc mh_mloc , const char * name , int name_len , TSMLoc * locp ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( ( sdk_sanity_check_mime_hdr_handle ( mh_mloc ) == TS_SUCCESS ) || ( sdk_sanity_check_http_hdr_handle ( mh_mloc ) == TS_SUCCESS ) ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) name ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) locp ) == TS_SUCCESS ) ;\n if ( ! isWriteable ( bufp ) ) {\n return TS_ERROR ;\n }\n if ( name_len == - 1 ) {\n name_len = strlen ( name ) ;\n }\n MIMEHdrImpl * mh = _hdr_mloc_to_mime_hdr_impl ( mh_mloc ) ;\n HdrHeap * heap = ( HdrHeap * ) ( ( ( HdrHeapSDKHandle * ) bufp ) -> m_heap ) ;\n MIMEFieldSDKHandle * h = sdk_alloc_field_handle ( bufp , mh ) ;\n h -> field_ptr = mime_field_create_named ( heap , mh , name , name_len ) ;\n * locp = reinterpret_cast < TSMLoc > ( h ) ;\n return TS_SUCCESS ;\n }",
        "output": "0",
        "idx": 3782
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void iadst4 ( const int16_t * input , int16_t * output ) {\n int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ;\n int x0 = input [ 0 ] ;\n int x1 = input [ 1 ] ;\n int x2 = input [ 2 ] ;\n int x3 = input [ 3 ] ;\n if ( ! ( x0 | x1 | x2 | x3 ) ) {\n output [ 0 ] = output [ 1 ] = output [ 2 ] = output [ 3 ] = 0 ;\n return ;\n }\n s0 = sinpi_1_9 * x0 ;\n s1 = sinpi_2_9 * x0 ;\n s2 = sinpi_3_9 * x1 ;\n s3 = sinpi_4_9 * x2 ;\n s4 = sinpi_1_9 * x2 ;\n s5 = sinpi_2_9 * x3 ;\n s6 = sinpi_4_9 * x3 ;\n s7 = x0 - x2 + x3 ;\n x0 = s0 + s3 + s5 ;\n x1 = s1 - s4 - s6 ;\n x2 = sinpi_3_9 * s7 ;\n x3 = s2 ;\n s0 = x0 + x3 ;\n s1 = x1 + x3 ;\n s2 = x2 ;\n s3 = x0 + x1 - x3 ;\n output [ 0 ] = dct_const_round_shift ( s0 ) ;\n output [ 1 ] = dct_const_round_shift ( s1 ) ;\n output [ 2 ] = dct_const_round_shift ( s2 ) ;\n output [ 3 ] = dct_const_round_shift ( s3 ) ;\n }",
        "output": "1",
        "idx": 4335
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int PyString_AsStringAndSize ( register PyObject * obj , register char * * s , register Py_ssize_t * len ) {\n if ( s == NULL ) {\n PyErr_BadInternalCall ( ) ;\n return - 1 ;\n }\n if ( ! PyString_Check ( obj ) ) {\n # ifdef Py_USING_UNICODE if ( PyUnicode_Check ( obj ) ) {\n obj = _PyUnicode_AsDefaultEncodedString ( obj , NULL ) ;\n if ( obj == NULL ) return - 1 ;\n }\n else # endif {\n PyErr_Format ( PyExc_TypeError , \"expected string or Unicode object, \" \"%.200s found\" , Py_TYPE ( obj ) -> tp_name ) ;\n return - 1 ;\n }\n }\n * s = PyString_AS_STRING ( obj ) ;\n if ( len != NULL ) * len = PyString_GET_SIZE ( obj ) ;\n else if ( strlen ( * s ) != ( size_t ) PyString_GET_SIZE ( obj ) ) {\n PyErr_SetString ( PyExc_TypeError , \"expected string without null bytes\" ) ;\n return - 1 ;\n }\n return 0 ;\n }",
        "output": "0",
        "idx": 1423
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_JitterIndication ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_JitterIndication , JitterIndication_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 2094
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int evsignal_init ( struct event_base * base ) {\n int i ;\n if ( evutil_socketpair ( AF_UNIX , SOCK_STREAM , 0 , base -> sig . ev_signal_pair ) == - 1 ) {\n # ifdef WIN32 event_warn ( \"%s: socketpair\" , __func__ ) ;\n # else event_err ( 1 , \"%s: socketpair\" , __func__ ) ;\n # endif return - 1 ;\n }\n FD_CLOSEONEXEC ( base -> sig . ev_signal_pair [ 0 ] ) ;\n FD_CLOSEONEXEC ( base -> sig . ev_signal_pair [ 1 ] ) ;\n base -> sig . sh_old = NULL ;\n base -> sig . sh_old_max = 0 ;\n base -> sig . evsignal_caught = 0 ;\n memset ( & base -> sig . evsigcaught , 0 , sizeof ( sig_atomic_t ) * NSIG ) ;\n for ( i = 0 ;\n i < NSIG ;\n ++ i ) TAILQ_INIT ( & base -> sig . evsigevents [ i ] ) ;\n evutil_make_socket_nonblocking ( base -> sig . ev_signal_pair [ 0 ] ) ;\n event_set ( & base -> sig . ev_signal , base -> sig . ev_signal_pair [ 1 ] , EV_READ | EV_PERSIST , evsignal_cb , & base -> sig . ev_signal ) ;\n base -> sig . ev_signal . ev_base = base ;\n base -> sig . ev_signal . ev_flags |= EVLIST_INTERNAL ;\n return 0 ;\n }",
        "output": "1",
        "idx": 547
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static apr_status_t modsecurity_process_phase_request_headers ( modsec_rec * msr ) {\n apr_time_t time_before ;\n apr_status_t rc = 0 ;\n if ( msr -> txcfg -> debuglog_level >= 4 ) {\n msr_log ( msr , 4 , \"Starting phase REQUEST_HEADERS.\" ) ;\n }\n time_before = apr_time_now ( ) ;\n if ( msr -> txcfg -> ruleset != NULL ) {\n rc = msre_ruleset_process_phase ( msr -> txcfg -> ruleset , msr ) ;\n }\n msr -> time_phase1 = apr_time_now ( ) - time_before ;\n return rc ;\n }",
        "output": "0",
        "idx": 2677
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dissect_zcl_pwr_prof_pwrprofstatersp ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {\n proto_tree * sub_tree = NULL ;\n guint i ;\n guint8 power_profile_count ;\n power_profile_count = tvb_get_guint8 ( tvb , * offset ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_pwr_prof_pwr_prof_count , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n for ( i = 0 ;\n i < power_profile_count ;\n i ++ ) {\n sub_tree = proto_tree_add_subtree_format ( tree , tvb , * offset , 1 , ett_zbee_zcl_pwr_prof_pwrprofiles [ i ] , NULL , \"Power Profile #%u\" , i ) ;\n dissect_zcl_power_profile ( tvb , sub_tree , offset ) ;\n }\n }",
        "output": "1",
        "idx": 1744
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cblk_destroy ( jpc_enc_cblk_t * cblk ) {\n uint_fast16_t passno ;\n jpc_enc_pass_t * pass ;\n if ( cblk -> passes ) {\n for ( passno = 0 , pass = cblk -> passes ;\n passno < cblk -> numpasses ;\n ++ passno , ++ pass ) {\n pass_destroy ( pass ) ;\n }\n jas_free ( cblk -> passes ) ;\n }\n if ( cblk -> stream ) {\n jas_stream_close ( cblk -> stream ) ;\n }\n if ( cblk -> mqenc ) {\n jpc_mqenc_destroy ( cblk -> mqenc ) ;\n }\n if ( cblk -> data ) {\n jas_seq2d_destroy ( cblk -> data ) ;\n }\n if ( cblk -> flags ) {\n jas_seq2d_destroy ( cblk -> flags ) ;\n }\n }",
        "output": "1",
        "idx": 1998
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_stream_idx ( const unsigned * d ) {\n if ( d [ 0 ] >= '0' && d [ 0 ] <= '9' && d [ 1 ] >= '0' && d [ 1 ] <= '9' ) {\n return ( d [ 0 ] - '0' ) * 10 + ( d [ 1 ] - '0' ) ;\n }\n else {\n return 100 ;\n }\n }",
        "output": "0",
        "idx": 115
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spl_filesystem_tree_it_move_forward ( zend_object_iterator * iter TSRMLS_DC ) {\n spl_filesystem_iterator * iterator = ( spl_filesystem_iterator * ) iter ;\n spl_filesystem_object * object = spl_filesystem_iterator_to_object ( iterator ) ;\n object -> u . dir . index ++ ;\n do {\n spl_filesystem_dir_read ( object TSRMLS_CC ) ;\n }\n while ( spl_filesystem_is_dot ( object -> u . dir . entry . d_name ) ) ;\n if ( object -> file_name ) {\n efree ( object -> file_name ) ;\n object -> file_name = NULL ;\n }\n if ( iterator -> current ) {\n zval_ptr_dtor ( & iterator -> current ) ;\n iterator -> current = NULL ;\n }\n }",
        "output": "1",
        "idx": 3159
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int aes_cfb8_cipher ( EVP_CIPHER_CTX * ctx , unsigned char * out , const unsigned char * in , size_t len ) {\n EVP_AES_KEY * dat = EVP_C_DATA ( EVP_AES_KEY , ctx ) ;\n int num = EVP_CIPHER_CTX_num ( ctx ) ;\n CRYPTO_cfb128_8_encrypt ( in , out , len , & dat -> ks , EVP_CIPHER_CTX_iv_noconst ( ctx ) , & num , EVP_CIPHER_CTX_encrypting ( ctx ) , dat -> block ) ;\n EVP_CIPHER_CTX_set_num ( ctx , num ) ;\n return 1 ;\n }",
        "output": "0",
        "idx": 1733
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pxa2xx_i2c_event ( I2CSlave * i2c , enum i2c_event event ) {\n PXA2xxI2CSlaveState * slave = FROM_I2C_SLAVE ( PXA2xxI2CSlaveState , i2c ) ;\n PXA2xxI2CState * s = slave -> host ;\n switch ( event ) {\n case I2C_START_SEND : s -> status |= ( 1 << 9 ) ;\n s -> status &= ~ ( 1 << 0 ) ;\n break ;\n case I2C_START_RECV : s -> status |= ( 1 << 9 ) ;\n s -> status |= 1 << 0 ;\n break ;\n case I2C_FINISH : s -> status |= ( 1 << 4 ) ;\n break ;\n case I2C_NACK : s -> status |= 1 << 1 ;\n break ;\n }\n pxa2xx_i2c_update ( s ) ;\n }",
        "output": "0",
        "idx": 2575
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_T_billingMode ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_T_billingMode , T_billingMode_choice , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 3385
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cond_release_buffer ( AVFrame * pic ) {\n if ( pic -> data [ 0 ] ) {\n av_freep ( & pic -> data [ 0 ] ) ;\n av_free ( pic -> data [ 1 ] ) ;\n }\n }",
        "output": "1",
        "idx": 3984
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileObject , valid ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n if ( SPL_HAS_FLAG ( intern -> flags , SPL_FILE_OBJECT_READ_AHEAD ) ) {\n RETURN_BOOL ( intern -> u . file . current_line || intern -> u . file . current_zval ) ;\n }\n else {\n RETVAL_BOOL ( ! php_stream_eof ( intern -> u . file . stream ) ) ;\n }\n }",
        "output": "1",
        "idx": 1776
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mtime_t decoder_GetDisplayDate ( decoder_t * p_dec , mtime_t i_ts ) {\n if ( ! p_dec -> pf_get_display_date ) return VLC_TS_INVALID ;\n return p_dec -> pf_get_display_date ( p_dec , i_ts ) ;\n }",
        "output": "0",
        "idx": 982
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char * SSL_rstate_string ( const SSL * s ) {\n const char * str ;\n switch ( s -> rstate ) {\n case SSL_ST_READ_HEADER : str = \"RH\" ;\n break ;\n case SSL_ST_READ_BODY : str = \"RB\" ;\n break ;\n case SSL_ST_READ_DONE : str = \"RD\" ;\n break ;\n default : str = \"unknown\" ;\n break ;\n }\n return ( str ) ;\n }",
        "output": "0",
        "idx": 3676
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlListPtr xmlListDup ( const xmlListPtr old ) {\n xmlListPtr cur ;\n if ( old == NULL ) return ( NULL ) ;\n if ( NULL == ( cur = xmlListCreate ( NULL , old -> linkCompare ) ) ) return ( NULL ) ;\n if ( 0 != xmlListCopy ( cur , old ) ) return NULL ;\n return cur ;\n }",
        "output": "1",
        "idx": 237
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __inline__ __u32 __fswahb32 ( __u32 val ) {\n # ifdef __arch_swahb32 return __arch_swahb32 ( val ) ;\n # else return ___constant_swahb32 ( val ) ;\n # endif }",
        "output": "1",
        "idx": 3625
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hfinfo_container_bitwidth ( const header_field_info * hfinfo ) {\n if ( ! hfinfo -> bitmask ) {\n return 0 ;\n }\n if ( hfinfo -> type == FT_BOOLEAN ) {\n return hfinfo -> display ;\n }\n return hfinfo_type_bitwidth ( hfinfo -> type ) ;\n }",
        "output": "0",
        "idx": 3012
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_Mode_g7231 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_Mode_g7231 , Mode_g7231_choice , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 3577
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void report_preparing_move_progress ( CopyMoveJob * move_job , int total , int left ) {\n CommonJob * job ;\n job = ( CommonJob * ) move_job ;\n nautilus_progress_info_take_status ( job -> progress , f ( _ ( \"Preparing to move to \u201c%B\u201d\" ) , move_job -> destination ) ) ;\n nautilus_progress_info_take_details ( job -> progress , f ( ngettext ( \"Preparing to move %'d file\" , \"Preparing to move %'d files\" , left ) , left ) ) ;\n nautilus_progress_info_pulse_progress ( job -> progress ) ;\n }",
        "output": "0",
        "idx": 3102
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;\n __exctype_l ( isalpha_l ) ;\n __exctype_l ( iscntrl_l ) ;\n __exctype_l ( isdigit_l ) ;\n __exctype_l ( islower_l ) ;\n __exctype_l ( isgraph_l ) ;\n __exctype_l ( isprint_l ) ;\n __exctype_l ( ispunct_l ) ;\n __exctype_l ( isspace_l ) ;\n __exctype_l ( isupper_l ) ;\n __exctype_l ( isxdigit_l ) ;\n __exctype_l ( isblank_l )",
        "output": "1",
        "idx": 2975
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int gs_copydevice ( gx_device * * pnew_dev , const gx_device * dev , gs_memory_t * mem ) {\n return gs_copydevice2 ( pnew_dev , dev , false , mem ) ;\n }",
        "output": "0",
        "idx": 3097
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vpx_svc_is_keyframe ( const SvcContext * svc_ctx ) {\n const SvcInternal * const si = get_const_svc_internal ( svc_ctx ) ;\n if ( svc_ctx == NULL || si == NULL || si -> frame_list == NULL ) return 0 ;\n return ( si -> frame_list -> flags & VPX_FRAME_IS_KEY ) != 0 ;\n }",
        "output": "1",
        "idx": 88
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void Type_ColorantOrderType_Free ( struct _cms_typehandler_struct * self , void * Ptr ) {\n _cmsFree ( self -> ContextID , Ptr ) ;\n }",
        "output": "0",
        "idx": 17
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static guint32 dissect_netb_session_init ( tvbuff_t * tvb , packet_info * pinfo _U_ , int offset , proto_tree * tree ) {\n netbios_add_session_init_flags ( tvb , tree , offset + NB_FLAGS ) ;\n nb_data2 ( hf_netb_max_data_recv_size , tvb , offset , tree ) ;\n nb_resp_corrl ( tvb , offset , tree ) ;\n nb_xmit_corrl ( tvb , offset , tree ) ;\n nb_remote_session ( tvb , offset , tree ) ;\n nb_local_session ( tvb , offset , tree ) ;\n return 0 ;\n }",
        "output": "0",
        "idx": 3894
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vvalue_strbuf_append_i8 ( wmem_strbuf_t * strbuf , void * ptr ) {\n gint64 i8 = * ( gint64 * ) ptr ;\n wmem_strbuf_append_printf ( strbuf , \"%\" G_GINT64_MODIFIER \"d\" , i8 ) ;\n }",
        "output": "0",
        "idx": 3016
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void config_filter_deinit ( struct config_filter_context * * _ctx ) {\n struct config_filter_context * ctx = * _ctx ;\n unsigned int i ;\n * _ctx = NULL ;\n for ( i = 0 ;\n ctx -> parsers [ i ] != NULL ;\n i ++ ) config_filter_parsers_free ( ctx -> parsers [ i ] -> parsers ) ;\n pool_unref ( & ctx -> pool ) ;\n }",
        "output": "0",
        "idx": 3726
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "afs_int32 SPR_DumpEntry ( struct rx_call * call , afs_int32 apos , struct prdebugentry * aentry ) {\n afs_int32 code ;\n afs_int32 cid = ANONYMOUSID ;\n code = dumpEntry ( call , apos , aentry , & cid ) ;\n osi_auditU ( call , PTS_DmpEntEvent , code , AUD_LONG , apos , AUD_END ) ;\n ViceLog ( 125 , ( \"PTS_DumpEntry: code %d cid %d apos %d\\n\" , code , cid , apos ) ) ;\n return code ;\n }",
        "output": "0",
        "idx": 1461
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rtp_dyn_payload_insert ( rtp_dyn_payload_t * rtp_dyn_payload , const guint8 pt , const gchar * encoding_name , const int sample_rate ) {\n if ( rtp_dyn_payload && rtp_dyn_payload -> table ) {\n encoding_name_and_rate_t * encoding_name_and_rate_pt = wmem_new ( wmem_file_scope ( ) , encoding_name_and_rate_t ) ;\n encoding_name_and_rate_pt -> encoding_name = wmem_strdup ( wmem_file_scope ( ) , encoding_name ) ;\n encoding_name_and_rate_pt -> sample_rate = sample_rate ;\n g_hash_table_insert ( rtp_dyn_payload -> table , GUINT_TO_POINTER ( pt ) , encoding_name_and_rate_pt ) ;\n }\n }",
        "output": "0",
        "idx": 925
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_Alerting_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 499 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_Alerting_UUIE , Alerting_UUIE_sequence ) ;\n # line 503 \"./asn1/h225/h225.cnf\" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> cs_type = H225_ALERTING ;\n if ( contains_faststart == TRUE ) g_snprintf ( h225_pi -> frame_label , 50 , \"%s OLC (%s)\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) , h225_pi -> frame_label ) ;\n else g_snprintf ( h225_pi -> frame_label , 50 , \"%s\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) ) ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 50
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void select_connection_name ( const char * name ) {\n DBUG_ENTER ( \"select_connection_name\" ) ;\n DBUG_PRINT ( \"enter\" , ( \"name: '%s'\" , name ) ) ;\n st_connection * con = find_connection_by_name ( name ) ;\n if ( ! con ) die ( \"connection '%s' not found in connection pool\" , name ) ;\n set_current_connection ( con ) ;\n if ( ! disable_connect_log && ! disable_query_log ) {\n DYNAMIC_STRING * ds = & ds_res ;\n dynstr_append_mem ( ds , \"connection \" , 11 ) ;\n replace_dynstr_append ( ds , name ) ;\n dynstr_append_mem ( ds , \";\n\\n\" , 2 ) ;\n }\n DBUG_VOID_RETURN ;\n }",
        "output": "0",
        "idx": 2175
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void call_avp_subdissector ( guint32 vendorid , guint32 code , tvbuff_t * subtvb , packet_info * pinfo , proto_tree * avp_tree , diam_sub_dis_t * diam_sub_dis_inf ) {\n TRY {\n switch ( vendorid ) {\n case 0 : dissector_try_uint_new ( diameter_dissector_table , code , subtvb , pinfo , avp_tree , FALSE , diam_sub_dis_inf ) ;\n break ;\n case VENDOR_ERICSSON : dissector_try_uint_new ( diameter_ericsson_avp_dissector_table , code , subtvb , pinfo , avp_tree , FALSE , diam_sub_dis_inf ) ;\n break ;\n case VENDOR_THE3GPP : dissector_try_uint_new ( diameter_3gpp_avp_dissector_table , code , subtvb , pinfo , avp_tree , FALSE , diam_sub_dis_inf ) ;\n break ;\n default : break ;\n }\n }\n CATCH_NONFATAL_ERRORS {\n show_exception ( subtvb , pinfo , avp_tree , EXCEPT_CODE , GET_MESSAGE ) ;\n }\n ENDTRY ;\n }",
        "output": "0",
        "idx": 919
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pxa2xx_i2s_data_req ( void * opaque , int tx , int rx ) {\n PXA2xxI2SState * s = ( PXA2xxI2SState * ) opaque ;\n uint32_t * sample ;\n if ( s -> enable && s -> tx_len ) s -> status |= 1 << 5 ;\n if ( s -> enable && s -> rx_len ) s -> status |= 1 << 6 ;\n s -> tx_len = tx - s -> fifo_len ;\n s -> rx_len = rx ;\n if ( s -> enable ) for ( sample = s -> fifo ;\n s -> fifo_len ;\n s -> fifo_len -- , sample ++ ) s -> codec_out ( s -> opaque , * sample ) ;\n pxa2xx_i2s_update ( s ) ;\n }",
        "output": "0",
        "idx": 2979
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void initial_reordering_punctuation_cluster ( const hb_ot_shape_plan_t * plan HB_UNUSED , hb_face_t * face HB_UNUSED , hb_buffer_t * buffer HB_UNUSED , unsigned int start HB_UNUSED , unsigned int end HB_UNUSED ) {\n }",
        "output": "1",
        "idx": 641
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TSMatcherLine TSMatcherLineCreate ( void ) {\n return reinterpret_cast < TSMatcherLine > ( ats_malloc ( sizeof ( matcher_line ) ) ) ;\n }",
        "output": "0",
        "idx": 855
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ogg_probe ( AVProbeData * p ) {\n if ( ! memcmp ( \"OggS\" , p -> buf , 5 ) && p -> buf [ 5 ] <= 0x7 ) return AVPROBE_SCORE_MAX ;\n return 0 ;\n }",
        "output": "0",
        "idx": 1973
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void appendConnStrVal ( PQExpBuffer buf , const char * str ) {\n const char * s ;\n bool needquotes ;\n needquotes = false ;\n for ( s = str ;\n * s ;\n s ++ ) {\n if ( ! ( ( * s >= 'a' && * s <= 'z' ) || ( * s >= 'A' && * s <= 'Z' ) || ( * s >= '0' && * s <= '9' ) || * s == '_' || * s == '.' ) ) {\n needquotes = true ;\n break ;\n }\n }\n if ( needquotes ) {\n appendPQExpBufferChar ( buf , '\\'' ) ;\n while ( * str ) {\n if ( * str == '\\'' || * str == '\\\\' ) appendPQExpBufferChar ( buf , '\\\\' ) ;\n appendPQExpBufferChar ( buf , * str ) ;\n str ++ ;\n }\n appendPQExpBufferChar ( buf , '\\'' ) ;\n }\n else appendPQExpBufferStr ( buf , str ) ;\n }",
        "output": "1",
        "idx": 2312
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static guint composite_offset ( const tvbuff_t * tvb , const guint counter ) {\n const struct tvb_composite * composite_tvb = ( const struct tvb_composite * ) tvb ;\n const tvbuff_t * member = ( const tvbuff_t * ) composite_tvb -> composite . tvbs -> data ;\n return tvb_offset_from_real_beginning_counter ( member , counter ) ;\n }",
        "output": "1",
        "idx": 716
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileObject , fscanf ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n spl_filesystem_file_free_line ( intern TSRMLS_CC ) ;\n intern -> u . file . current_line_num ++ ;\n FileFunctionCall ( fscanf , ZEND_NUM_ARGS ( ) , NULL ) ;\n }",
        "output": "0",
        "idx": 4019
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * get_pid_environ_val ( pid_t pid , char * val ) {\n char temp [ 500 ] ;\n int i = 0 ;\n int foundit = 0 ;\n FILE * fp ;\n sprintf ( temp , \"/proc/%d/environ\" , pid ) ;\n fp = fopen ( temp , \"r\" ) ;\n if ( fp == NULL ) return NULL ;\n for ( ;\n ;\n ) {\n temp [ i ] = fgetc ( fp ) ;\n if ( foundit == 1 && ( temp [ i ] == 0 || temp [ i ] == '\\0' || temp [ i ] == EOF ) ) {\n char * ret ;\n temp [ i ] = 0 ;\n ret = malloc ( strlen ( temp ) + 10 ) ;\n sprintf ( ret , \"%s\" , temp ) ;\n fclose ( fp ) ;\n return ret ;\n }\n switch ( temp [ i ] ) {\n case EOF : fclose ( fp ) ;\n return NULL ;\n case '=' : temp [ i ] = 0 ;\n if ( ! strcmp ( temp , val ) ) {\n foundit = 1 ;\n }\n i = 0 ;\n break ;\n case '\\0' : i = 0 ;\n break ;\n default : i ++ ;\n }\n }\n }",
        "output": "1",
        "idx": 3216
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PGconn * get_db_conn ( ClusterInfo * cluster , const char * db_name ) {\n char conn_opts [ 2 * NAMEDATALEN + MAXPGPATH + 100 ] ;\n if ( cluster -> sockdir ) snprintf ( conn_opts , sizeof ( conn_opts ) , \"dbname = '%s' user = '%s' host = '%s' port = %d\" , db_name , os_info . user , cluster -> sockdir , cluster -> port ) ;\n else snprintf ( conn_opts , sizeof ( conn_opts ) , \"dbname = '%s' user = '%s' port = %d\" , db_name , os_info . user , cluster -> port ) ;\n return PQconnectdb ( conn_opts ) ;\n }",
        "output": "1",
        "idx": 105
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {\n OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;\n }\n LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {\n OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;\n }\n LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING ) ;\n # ifdef _MSC_VER # pragma warning ( push ) # pragma warning ( disable : 4090 ) # endif DEFINE_LHASH_OF ( OPENSSL_CSTRING )",
        "output": "1",
        "idx": 3079
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_T_mediaControlChannel ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 914 \"../../asn1/h245/h245.cnf\" if ( upcoming_channel ) upcoming_channel -> upcoming_addr = & upcoming_channel -> media_control_addr ;\n offset = dissect_h245_TransportAddress ( tvb , offset , actx , tree , hf_index ) ;\n # line 918 \"../../asn1/h245/h245.cnf\" if ( upcoming_channel ) upcoming_channel -> upcoming_addr = NULL ;\n return offset ;\n }",
        "output": "0",
        "idx": 3032
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_ModeElement ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_ModeElement , ModeElement_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 2429
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void uiserver_io_event ( void * engine , gpgme_event_io_t type , void * type_data ) {\n engine_uiserver_t uiserver = engine ;\n TRACE3 ( DEBUG_ENGINE , \"gpgme:uiserver_io_event\" , uiserver , \"event %p, type %d, type_data %p\" , uiserver -> io_cbs . event , type , type_data ) ;\n if ( uiserver -> io_cbs . event ) ( * uiserver -> io_cbs . event ) ( uiserver -> io_cbs . event_priv , type , type_data ) ;\n }",
        "output": "0",
        "idx": 2355
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE ossl_cipher_decrypt ( int argc , VALUE * argv , VALUE self ) {\n return ossl_cipher_init ( argc , argv , self , 0 ) ;\n }",
        "output": "0",
        "idx": 3105
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gcry_err_code_t pubkey_verify ( int algorithm , gcry_mpi_t hash , gcry_mpi_t * data , gcry_mpi_t * pkey , struct pk_encoding_ctx * ctx ) {\n gcry_pk_spec_t * pubkey ;\n gcry_module_t module ;\n gcry_err_code_t rc ;\n int i ;\n if ( DBG_CIPHER && ! fips_mode ( ) ) {\n log_debug ( \"pubkey_verify: algo=%d\\n\" , algorithm ) ;\n for ( i = 0 ;\n i < pubkey_get_npkey ( algorithm ) ;\n i ++ ) log_mpidump ( \" pkey\" , pkey [ i ] ) ;\n for ( i = 0 ;\n i < pubkey_get_nsig ( algorithm ) ;\n i ++ ) log_mpidump ( \" sig\" , data [ i ] ) ;\n log_mpidump ( \" hash\" , hash ) ;\n }\n ath_mutex_lock ( & pubkeys_registered_lock ) ;\n module = _gcry_module_lookup_id ( pubkeys_registered , algorithm ) ;\n if ( module ) {\n pubkey = ( gcry_pk_spec_t * ) module -> spec ;\n rc = pubkey -> verify ( algorithm , hash , data , pkey , ctx -> verify_cmp , ctx , ctx -> flags , ctx -> hash_algo ) ;\n _gcry_module_release ( module ) ;\n goto ready ;\n }\n rc = GPG_ERR_PUBKEY_ALGO ;\n ready : ath_mutex_unlock ( & pubkeys_registered_lock ) ;\n return rc ;\n }",
        "output": "0",
        "idx": 4330
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( MultiBufferTest , ReadAllAdvanceFirst_NeverDefer2 ) {\n multibuffer_ . SetMaxWriters ( 1 ) ;\n size_t pos = 0 ;\n size_t end = 10000 ;\n multibuffer_ . SetFileSize ( 10000 ) ;\n multibuffer_ . SetMustReadWholeFile ( true ) ;\n multibuffer_ . SetMaxBlocksAfterDefer ( - 10000 ) ;\n media : : MultiBufferReader reader ( & multibuffer_ , pos , end , base : : Callback < void ( int64_t , int64_t ) > ( ) ) ;\n reader . SetMaxBuffer ( 2000 , 5000 ) ;\n reader . SetPreload ( 1000 , 1000 ) ;\n while ( pos < end ) {\n unsigned char buffer [ 27 ] ;\n buffer [ 17 ] = 17 ;\n size_t to_read = std : : min < size_t > ( end - pos , 17 ) ;\n while ( AdvanceAll ( ) ) ;\n int64_t bytes = reader . TryRead ( buffer , to_read ) ;\n EXPECT_GT ( bytes , 0 ) ;\n EXPECT_EQ ( buffer [ 17 ] , 17 ) ;\n for ( int64_t i = 0 ;\n i < bytes ;\n i ++ ) {\n uint8_t expected = static_cast < uint8_t > ( ( pos * 15485863 ) >> 16 ) ;\n EXPECT_EQ ( expected , buffer [ i ] ) << \" pos = \" << pos ;\n pos ++ ;\n }\n }\n }",
        "output": "1",
        "idx": 2131
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __inline __uint32_t __uint32_identity ( __uint32_t __x ) {\n return __x ;\n }",
        "output": "1",
        "idx": 4111
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileObject , rewind ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n spl_filesystem_file_rewind ( getThis ( ) , intern TSRMLS_CC ) ;\n }",
        "output": "1",
        "idx": 1133
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int getulong ( const char * numstr , unsigned long int * result ) {\n long long int val ;\n char * endptr ;\n errno = 0 ;\n val = strtoll ( numstr , & endptr , 0 ) ;\n if ( ( '\\0' == * numstr ) || ( '\\0' != * endptr ) || ( ERANGE == errno ) || ( val != ( unsigned long int ) val ) ) {\n return 0 ;\n }\n * result = ( unsigned long int ) val ;\n return 1 ;\n }",
        "output": "1",
        "idx": 3291
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int16_t vp9_dc_quant ( int qindex , int delta ) {\n return dc_qlookup [ clamp ( qindex + delta , 0 , MAXQ ) ] ;\n }",
        "output": "1",
        "idx": 1690
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int xmlListInsert ( xmlListPtr l , void * data ) {\n xmlLinkPtr lkPlace , lkNew ;\n if ( l == NULL ) return ( 1 ) ;\n lkPlace = xmlListLowerSearch ( l , data ) ;\n lkNew = ( xmlLinkPtr ) xmlMalloc ( sizeof ( xmlLink ) ) ;\n if ( lkNew == NULL ) {\n xmlGenericError ( xmlGenericErrorContext , \"Cannot initialize memory for new link\" ) ;\n return ( 1 ) ;\n }\n lkNew -> data = data ;\n lkPlace = lkPlace -> prev ;\n lkNew -> next = lkPlace -> next ;\n ( lkPlace -> next ) -> prev = lkNew ;\n lkPlace -> next = lkNew ;\n lkNew -> prev = lkPlace ;\n return 0 ;\n }",
        "output": "1",
        "idx": 3177
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int libopenjpeg_matches_pix_fmt ( const opj_image_t * img , enum AVPixelFormat pix_fmt ) {\n const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( pix_fmt ) ;\n int match = 1 ;\n if ( desc -> nb_components != img -> numcomps ) {\n return 0 ;\n }\n switch ( desc -> nb_components ) {\n case 4 : match = match && desc -> comp [ 3 ] . depth_minus1 + 1 >= img -> comps [ 3 ] . prec && 1 == img -> comps [ 3 ] . dx && 1 == img -> comps [ 3 ] . dy ;\n case 3 : match = match && desc -> comp [ 2 ] . depth_minus1 + 1 >= img -> comps [ 2 ] . prec && 1 << desc -> log2_chroma_w == img -> comps [ 2 ] . dx && 1 << desc -> log2_chroma_h == img -> comps [ 2 ] . dy ;\n case 2 : match = match && desc -> comp [ 1 ] . depth_minus1 + 1 >= img -> comps [ 1 ] . prec && 1 << desc -> log2_chroma_w == img -> comps [ 1 ] . dx && 1 << desc -> log2_chroma_h == img -> comps [ 1 ] . dy ;\n case 1 : match = match && desc -> comp [ 0 ] . depth_minus1 + 1 >= img -> comps [ 0 ] . prec && 1 == img -> comps [ 0 ] . dx && 1 == img -> comps [ 0 ] . dy ;\n default : break ;\n }\n return match ;\n }",
        "output": "0",
        "idx": 1167
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int xmlListAppend ( xmlListPtr l , void * data ) {\n xmlLinkPtr lkPlace , lkNew ;\n if ( l == NULL ) return ( 1 ) ;\n lkPlace = xmlListHigherSearch ( l , data ) ;\n lkNew = ( xmlLinkPtr ) xmlMalloc ( sizeof ( xmlLink ) ) ;\n if ( lkNew == NULL ) {\n xmlGenericError ( xmlGenericErrorContext , \"Cannot initialize memory for new link\" ) ;\n return ( 1 ) ;\n }\n lkNew -> data = data ;\n lkNew -> next = lkPlace -> next ;\n ( lkPlace -> next ) -> prev = lkNew ;\n lkPlace -> next = lkNew ;\n lkNew -> prev = lkPlace ;\n return 0 ;\n }",
        "output": "1",
        "idx": 875
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void init_config ( struct VP9_COMP * cpi , VP9EncoderConfig * oxcf ) {\n VP9_COMMON * const cm = & cpi -> common ;\n cpi -> oxcf = * oxcf ;\n cpi -> framerate = oxcf -> init_framerate ;\n cm -> profile = oxcf -> profile ;\n cm -> bit_depth = oxcf -> bit_depth ;\n cm -> color_space = UNKNOWN ;\n cm -> width = oxcf -> width ;\n cm -> height = oxcf -> height ;\n vp9_alloc_compressor_data ( cpi ) ;\n cpi -> svc . number_spatial_layers = oxcf -> ss_number_layers ;\n cpi -> svc . number_temporal_layers = oxcf -> ts_number_layers ;\n if ( ( cpi -> svc . number_temporal_layers > 1 && cpi -> oxcf . rc_mode == VPX_CBR ) || ( ( cpi -> svc . number_temporal_layers > 1 || cpi -> svc . number_spatial_layers > 1 ) && cpi -> oxcf . pass == 2 ) ) {\n vp9_init_layer_context ( cpi ) ;\n }\n vp9_change_config ( cpi , oxcf ) ;\n cpi -> static_mb_pct = 0 ;\n cpi -> ref_frame_flags = 0 ;\n init_buffer_indices ( cpi ) ;\n set_tile_limits ( cpi ) ;\n }",
        "output": "1",
        "idx": 3155
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int archive_read_support_format_cpio ( struct archive * _a ) {\n struct archive_read * a = ( struct archive_read * ) _a ;\n struct cpio * cpio ;\n int r ;\n archive_check_magic ( _a , ARCHIVE_READ_MAGIC , ARCHIVE_STATE_NEW , \"archive_read_support_format_cpio\" ) ;\n cpio = ( struct cpio * ) calloc ( 1 , sizeof ( * cpio ) ) ;\n if ( cpio == NULL ) {\n archive_set_error ( & a -> archive , ENOMEM , \"Can't allocate cpio data\" ) ;\n return ( ARCHIVE_FATAL ) ;\n }\n cpio -> magic = CPIO_MAGIC ;\n r = __archive_read_register_format ( a , cpio , \"cpio\" , archive_read_format_cpio_bid , archive_read_format_cpio_options , archive_read_format_cpio_read_header , archive_read_format_cpio_read_data , archive_read_format_cpio_skip , NULL , archive_read_format_cpio_cleanup , NULL , NULL ) ;\n if ( r != ARCHIVE_OK ) free ( cpio ) ;\n return ( ARCHIVE_OK ) ;\n }",
        "output": "0",
        "idx": 2676
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_TBCD_STRING ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 900 \"./asn1/h225/h225.cnf\" int min_len , max_len ;\n gboolean has_extension ;\n get_size_constraint_from_stack ( actx , \"TBCD_STRING\" , & min_len , & max_len , & has_extension ) ;\n offset = dissect_per_restricted_character_string ( tvb , offset , actx , tree , hf_index , min_len , max_len , has_extension , \"0123456789#*abc\" , 15 , NULL ) ;\n return offset ;\n }",
        "output": "1",
        "idx": 1452
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_CallTerminationCause ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_CallTerminationCause , CallTerminationCause_choice , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 2618
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int multi_reg_replace ( struct st_replace_regex * r , char * val ) {\n uint i ;\n char * in_buf , * out_buf ;\n int * buf_len_p ;\n in_buf = val ;\n out_buf = r -> even_buf ;\n buf_len_p = & r -> even_buf_len ;\n r -> buf = 0 ;\n for ( i = 0 ;\n i < r -> regex_arr . elements ;\n i ++ ) {\n struct st_regex re ;\n char * save_out_buf = out_buf ;\n get_dynamic ( & r -> regex_arr , ( uchar * ) & re , i ) ;\n if ( ! reg_replace ( & out_buf , buf_len_p , re . pattern , re . replace , in_buf , re . icase ) ) {\n if ( save_out_buf != out_buf ) {\n if ( save_out_buf == r -> even_buf ) r -> even_buf = out_buf ;\n else r -> odd_buf = out_buf ;\n }\n r -> buf = out_buf ;\n if ( in_buf == val ) in_buf = r -> odd_buf ;\n swap_variables ( char * , in_buf , out_buf ) ;\n buf_len_p = ( out_buf == r -> even_buf ) ? & r -> even_buf_len : & r -> odd_buf_len ;\n }\n }\n return ( r -> buf == 0 ) ;\n }",
        "output": "0",
        "idx": 2806
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void search_state_decref ( struct search_state * const state ) {\n if ( ! state ) return ;\n state -> refcount -- ;\n if ( ! state -> refcount ) {\n struct search_domain * next , * dom ;\n for ( dom = state -> head ;\n dom ;\n dom = next ) {\n next = dom -> next ;\n free ( dom ) ;\n }\n free ( state ) ;\n }\n }",
        "output": "0",
        "idx": 794
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_G723AnnexCAudioMode ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_G723AnnexCAudioMode , G723AnnexCAudioMode_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 2106
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool is_zero_width_char ( hb_font_t * font , hb_codepoint_t unicode ) {\n hb_codepoint_t glyph ;\n return hb_font_get_glyph ( font , unicode , 0 , & glyph ) && hb_font_get_glyph_h_advance ( font , glyph ) == 0 ;\n }",
        "output": "0",
        "idx": 2694
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( TemplateURLTest , PrefetchQueryParameters ) {\n TemplateURLData data ;\n search_terms_data_ . set_google_base_url ( \"http://bar/\" ) ;\n data . SetURL ( \"http://bar/search?q={\nsearchTerms}\n&{\ngoogle:prefetchQuery}\nxssi=t\" ) ;\n TemplateURL url ( data ) ;\n TemplateURLRef : : SearchTermsArgs search_terms_args ( ASCIIToUTF16 ( \"foo\" ) ) ;\n search_terms_args . prefetch_query = \"full query text\" ;\n search_terms_args . prefetch_query_type = \"2338\" ;\n std : : string result = url . url_ref ( ) . ReplaceSearchTerms ( search_terms_args , search_terms_data_ ) ;\n EXPECT_EQ ( \"http://bar/search?q=foo&pfq=full%20query%20text&qha=2338&xssi=t\" , result ) ;\n TemplateURL url2 ( data ) ;\n search_terms_args . prefetch_query . clear ( ) ;\n search_terms_args . prefetch_query_type . clear ( ) ;\n result = url2 . url_ref ( ) . ReplaceSearchTerms ( search_terms_args , search_terms_data_ ) ;\n EXPECT_EQ ( \"http://bar/search?q=foo&xssi=t\" , result ) ;\n }",
        "output": "0",
        "idx": 4185
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vga_draw_line8d2 ( VGACommonState * s1 , uint8_t * d , const uint8_t * s , int width ) {\n uint32_t * palette ;\n int x ;\n palette = s1 -> last_palette ;\n width >>= 3 ;\n for ( x = 0 ;\n x < width ;\n x ++ ) {\n PUT_PIXEL2 ( d , 0 , palette [ s [ 0 ] ] ) ;\n PUT_PIXEL2 ( d , 1 , palette [ s [ 1 ] ] ) ;\n PUT_PIXEL2 ( d , 2 , palette [ s [ 2 ] ] ) ;\n PUT_PIXEL2 ( d , 3 , palette [ s [ 3 ] ] ) ;\n d += 32 ;\n s += 4 ;\n }\n }",
        "output": "1",
        "idx": 2317
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int selinux_socket_recvmsg ( struct socket * sock , struct msghdr * msg , int size , int flags ) {\n return sock_has_perm ( current , sock -> sk , SOCKET__READ ) ;\n }",
        "output": "0",
        "idx": 403
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_idct16x16_10_add_c ( const int16_t * input , uint8_t * dest , int stride ) {\n int16_t out [ 16 * 16 ] = {\n 0 }\n ;\n int16_t * outptr = out ;\n int i , j ;\n int16_t temp_in [ 16 ] , temp_out [ 16 ] ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) {\n idct16 ( input , outptr ) ;\n input += 16 ;\n outptr += 16 ;\n }\n for ( i = 0 ;\n i < 16 ;\n ++ i ) {\n for ( j = 0 ;\n j < 16 ;\n ++ j ) temp_in [ j ] = out [ j * 16 + i ] ;\n idct16 ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 16 ;\n ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 6 ) + dest [ j * stride + i ] ) ;\n }\n }",
        "output": "1",
        "idx": 2962
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void setup_frame_size ( VP9_COMMON * cm , struct vp9_read_bit_buffer * rb ) {\n int width , height ;\n vp9_read_frame_size ( rb , & width , & height ) ;\n resize_context_buffers ( cm , width , height ) ;\n setup_display_size ( cm , rb ) ;\n if ( vp9_realloc_frame_buffer ( get_frame_new_buffer ( cm ) , cm -> width , cm -> height , cm -> subsampling_x , cm -> subsampling_y , # if CONFIG_VP9_HIGHBITDEPTH cm -> use_highbitdepth , # endif VP9_DEC_BORDER_IN_PIXELS , & cm -> frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer , cm -> get_fb_cb , cm -> cb_priv ) ) {\n vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , \"Failed to allocate frame buffer\" ) ;\n }\n }",
        "output": "1",
        "idx": 578
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void remoteDispatchConnError ( remote_error * rerr , virConnectPtr conn ATTRIBUTE_UNUSED ) {\n virErrorPtr verr = virGetLastError ( ) ;\n if ( verr ) remoteDispatchCopyError ( rerr , verr ) ;\n else remoteDispatchGenericError ( rerr ) ;\n }",
        "output": "1",
        "idx": 2636
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void evhttp_send_reply ( struct evhttp_request * req , int code , const char * reason , struct evbuffer * databuf ) {\n evhttp_response_code ( req , code , reason ) ;\n evhttp_send ( req , databuf ) ;\n }",
        "output": "0",
        "idx": 58
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xsltFreeAttrVT ( xsltAttrVTPtr avt ) {\n int i ;\n if ( avt == NULL ) return ;\n if ( avt -> strstart == 1 ) {\n for ( i = 0 ;\n i < avt -> nb_seg ;\n i += 2 ) if ( avt -> segments [ i ] != NULL ) xmlFree ( ( xmlChar * ) avt -> segments [ i ] ) ;\n for ( i = 1 ;\n i < avt -> nb_seg ;\n i += 2 ) xmlXPathFreeCompExpr ( ( xmlXPathCompExprPtr ) avt -> segments [ i ] ) ;\n }\n else {\n for ( i = 0 ;\n i < avt -> nb_seg ;\n i += 2 ) xmlXPathFreeCompExpr ( ( xmlXPathCompExprPtr ) avt -> segments [ i ] ) ;\n for ( i = 1 ;\n i < avt -> nb_seg ;\n i += 2 ) if ( avt -> segments [ i ] != NULL ) xmlFree ( ( xmlChar * ) avt -> segments [ i ] ) ;\n }\n if ( avt -> nsList != NULL ) xmlFree ( avt -> nsList ) ;\n xmlFree ( avt ) ;\n }",
        "output": "0",
        "idx": 740
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int test_read_integer_error ( xd3_stream * stream , usize_t trunto , const char * msg ) {\n uint64_t eval = 1ULL << 34 ;\n uint32_t rval ;\n xd3_output * buf = NULL ;\n const uint8_t * max ;\n const uint8_t * inp ;\n int ret ;\n buf = xd3_alloc_output ( stream , buf ) ;\n if ( ( ret = xd3_emit_uint64_t ( stream , & buf , eval ) ) ) {\n goto fail ;\n }\n again : inp = buf -> base ;\n max = buf -> base + buf -> next - trunto ;\n if ( ( ret = xd3_read_uint32_t ( stream , & inp , max , & rval ) ) != XD3_INVALID_INPUT || ! MSG_IS ( msg ) ) {\n ret = XD3_INTERNAL ;\n }\n else if ( trunto && trunto < buf -> next ) {\n trunto += 1 ;\n goto again ;\n }\n else {\n ret = 0 ;\n }\n fail : xd3_free_output ( stream , buf ) ;\n return ret ;\n }",
        "output": "1",
        "idx": 2811
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nlm_msg_res_match_cleanup ( void ) {\n g_hash_table_destroy ( nlm_msg_res_unmatched ) ;\n g_hash_table_destroy ( nlm_msg_res_matched ) ;\n }",
        "output": "0",
        "idx": 2501
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_q931_ie_cs7 ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) {\n dissect_q931_IEs ( tvb , pinfo , NULL , tree , FALSE , 0 , 7 ) ;\n return tvb_captured_length ( tvb ) ;\n }",
        "output": "1",
        "idx": 984
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void intra_pred_down_right ( uint8_t * d , uint8_t * top , uint8_t * left , int stride ) {\n int x , y ;\n for ( y = 0 ;\n y < 8 ;\n y ++ ) for ( x = 0 ;\n x < 8 ;\n x ++ ) if ( x == y ) d [ y * stride + x ] = ( left [ 1 ] + 2 * top [ 0 ] + top [ 1 ] + 2 ) >> 2 ;\n else if ( x > y ) d [ y * stride + x ] = LOWPASS ( top , x - y ) ;\n else d [ y * stride + x ] = LOWPASS ( left , y - x ) ;\n }",
        "output": "0",
        "idx": 1754
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void e1000e_autoneg_resume ( E1000ECore * core ) {\n if ( e1000e_have_autoneg ( core ) && ! ( core -> phy [ 0 ] [ PHY_STATUS ] & MII_SR_AUTONEG_COMPLETE ) ) {\n qemu_get_queue ( core -> owner_nic ) -> link_down = false ;\n timer_mod ( core -> autoneg_timer , qemu_clock_get_ms ( QEMU_CLOCK_VIRTUAL ) + 500 ) ;\n }\n }",
        "output": "0",
        "idx": 1132
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int at1_parse_bsm ( GetBitContext * gb , int log2_block_cnt [ AT1_QMF_BANDS ] ) {\n int log2_block_count_tmp , i ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n log2_block_count_tmp = get_bits ( gb , 2 ) ;\n if ( log2_block_count_tmp & 1 ) return AVERROR_INVALIDDATA ;\n log2_block_cnt [ i ] = 2 - log2_block_count_tmp ;\n }\n log2_block_count_tmp = get_bits ( gb , 2 ) ;\n if ( log2_block_count_tmp != 0 && log2_block_count_tmp != 3 ) return AVERROR_INVALIDDATA ;\n log2_block_cnt [ IDX_HIGH_BAND ] = 3 - log2_block_count_tmp ;\n skip_bits ( gb , 2 ) ;\n return 0 ;\n }",
        "output": "0",
        "idx": 2
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( TemplateURLTest , ParseURLTwoParameters ) {\n TemplateURLData data ;\n data . SetURL ( \"{\n}\n{\n{\n%s}\n}\n\" ) ;\n TemplateURL url ( data ) ;\n TemplateURLRef : : Replacements replacements ;\n bool valid = false ;\n EXPECT_EQ ( \"{\n}\n{\n}\n\" , url . url_ref ( ) . ParseURL ( \"{\n}\n{\n{\nsearchTerms}\n}\n\" , & replacements , NULL , & valid ) ) ;\n ASSERT_EQ ( 1U , replacements . size ( ) ) ;\n EXPECT_EQ ( 3U , replacements [ 0 ] . index ) ;\n EXPECT_EQ ( TemplateURLRef : : SEARCH_TERMS , replacements [ 0 ] . type ) ;\n EXPECT_TRUE ( valid ) ;\n }",
        "output": "0",
        "idx": 4431
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spl_ptr_llist_push ( spl_ptr_llist * llist , void * data TSRMLS_DC ) {\n spl_ptr_llist_element * elem = emalloc ( sizeof ( spl_ptr_llist_element ) ) ;\n elem -> data = data ;\n elem -> rc = 1 ;\n elem -> prev = llist -> tail ;\n elem -> next = NULL ;\n if ( llist -> tail ) {\n llist -> tail -> next = elem ;\n }\n else {\n llist -> head = elem ;\n }\n llist -> tail = elem ;\n llist -> count ++ ;\n if ( llist -> ctor ) {\n llist -> ctor ( elem TSRMLS_CC ) ;\n }\n }",
        "output": "0",
        "idx": 2612
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static UChar32 _UTF32GetNextUChar ( UConverterToUnicodeArgs * pArgs , UErrorCode * pErrorCode ) {\n switch ( pArgs -> converter -> mode ) {\n case 8 : return T_UConverter_getNextUChar_UTF32_BE ( pArgs , pErrorCode ) ;\n case 9 : return T_UConverter_getNextUChar_UTF32_LE ( pArgs , pErrorCode ) ;\n default : return UCNV_GET_NEXT_UCHAR_USE_TO_U ;\n }\n }",
        "output": "1",
        "idx": 2434
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dvvideo_close ( AVCodecContext * c ) {\n DVVideoContext * s = c -> priv_data ;\n if ( s -> picture . data [ 0 ] ) c -> release_buffer ( c , & s -> picture ) ;\n return 0 ;\n }",
        "output": "1",
        "idx": 2280
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PyObject * string_sizeof ( PyStringObject * v ) {\n Py_ssize_t res ;\n res = PyStringObject_SIZE + PyString_GET_SIZE ( v ) * Py_TYPE ( v ) -> tp_itemsize ;\n return PyInt_FromSsize_t ( res ) ;\n }",
        "output": "0",
        "idx": 877
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplDoublyLinkedList , key ) {\n spl_dllist_object * intern = ( spl_dllist_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n RETURN_LONG ( intern -> traverse_position ) ;\n }",
        "output": "0",
        "idx": 3343
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int gs_main_init0 ( gs_main_instance * minst , FILE * in , FILE * out , FILE * err , int max_lib_paths ) {\n ref * array ;\n gp_init ( ) ;\n # ifdef PACIFY_VALGRIND VALGRIND_HG_DISABLE_CHECKING ( gs_debug , 128 ) ;\n # endif memset ( gs_debug , 0 , 128 ) ;\n gs_log_errors = 0 ;\n gp_get_realtime ( minst -> base_time ) ;\n array = ( ref * ) gs_alloc_byte_array ( minst -> heap , max_lib_paths , sizeof ( ref ) , \"lib_path array\" ) ;\n if ( array == 0 ) {\n gs_lib_finit ( 1 , gs_error_VMerror , minst -> heap ) ;\n return_error ( gs_error_VMerror ) ;\n }\n make_array ( & minst -> lib_path . container , avm_foreign , max_lib_paths , array ) ;\n make_array ( & minst -> lib_path . list , avm_foreign | a_readonly , 0 , minst -> lib_path . container . value . refs ) ;\n minst -> lib_path . env = 0 ;\n minst -> lib_path . final = 0 ;\n minst -> lib_path . count = 0 ;\n minst -> user_errors = 1 ;\n minst -> init_done = 0 ;\n return 0 ;\n }",
        "output": "0",
        "idx": 4023
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void * i_alloc_struct_array_immovable ( gs_memory_t * mem , uint num_elements , gs_memory_type_ptr_t pstype , client_name_t cname ) {\n gs_ref_memory_t * const imem = ( gs_ref_memory_t * ) mem ;\n obj_header_t * obj ;\n # ifdef MEMENTO if ( Memento_failThisEvent ( ) ) return NULL ;\n # endif ALLOC_CHECK_SIZE ( mem , pstype ) ;\n obj = alloc_obj ( imem , ( ulong ) num_elements * pstype -> ssize , pstype , ALLOC_IMMOVABLE | ALLOC_DIRECT , cname ) ;\n if_debug7m ( 'A' , mem , \"[a%d|+<.]%s %s*(%lu=%u*%u) = 0x%lx\\n\" , alloc_trace_space ( imem ) , client_name_string ( cname ) , struct_type_name_string ( pstype ) , ( ulong ) num_elements * pstype -> ssize , num_elements , pstype -> ssize , ( ulong ) obj ) ;\n return ( char * ) obj ;\n }",
        "output": "1",
        "idx": 124
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dissect_h225_ReleaseCompleteReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 701 \"./asn1/h225/h225.cnf\" gint32 value ;\n h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_ReleaseCompleteReason , ReleaseCompleteReason_choice , & value ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> reason = value ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 1532
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dwarf_elf_object_access_load_section ( void * obj_in , Dwarf_Half section_index , Dwarf_Small * * section_data , int * error ) {\n dwarf_elf_object_access_internals_t * obj = ( dwarf_elf_object_access_internals_t * ) obj_in ;\n if ( section_index == 0 ) {\n return DW_DLV_NO_ENTRY ;\n }\n {\n Elf_Scn * scn = 0 ;\n Elf_Data * data = 0 ;\n scn = elf_getscn ( obj -> elf , section_index ) ;\n if ( scn == NULL ) {\n * error = DW_DLE_MDE ;\n return DW_DLV_ERROR ;\n }\n data = elf_getdata ( scn , NULL ) ;\n if ( data == NULL ) {\n * error = DW_DLE_MDE ;\n return DW_DLV_ERROR ;\n }\n * section_data = data -> d_buf ;\n }\n return DW_DLV_OK ;\n }",
        "output": "1",
        "idx": 1429
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool challenge_h ( connection_t * c ) {\n char buffer [ MAX_STRING_SIZE ] ;\n int len ;\n if ( sscanf ( c -> buffer , \"%*d \" MAX_STRING , buffer ) != 1 ) {\n logger ( LOG_ERR , \"Got bad %s from %s (%s)\" , \"CHALLENGE\" , c -> name , c -> hostname ) ;\n return false ;\n }\n len = RSA_size ( myself -> connection -> rsa_key ) ;\n if ( strlen ( buffer ) != ( size_t ) len * 2 ) {\n logger ( LOG_ERR , \"Possible intruder %s (%s): %s\" , c -> name , c -> hostname , \"wrong challenge length\" ) ;\n return false ;\n }\n c -> mychallenge = xrealloc ( c -> mychallenge , len ) ;\n if ( ! hex2bin ( buffer , c -> mychallenge , len ) ) {\n logger ( LOG_ERR , \"Got bad %s from %s(%s): %s\" , \"CHALLENGE\" , c -> name , c -> hostname , \"invalid challenge\" ) ;\n return false ;\n }\n c -> allow_request = CHAL_REPLY ;\n return send_chal_reply ( c ) ;\n }",
        "output": "1",
        "idx": 125
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void word ( struct vars * v , int dir , struct state * lp , struct state * rp ) {\n assert ( dir == AHEAD || dir == BEHIND ) ;\n cloneouts ( v -> nfa , v -> wordchrs , lp , rp , dir ) ;\n }",
        "output": "0",
        "idx": 1384
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PyObject * string_slice ( register PyStringObject * a , register Py_ssize_t i , register Py_ssize_t j ) {\n if ( i < 0 ) i = 0 ;\n if ( j < 0 ) j = 0 ;\n if ( j > Py_SIZE ( a ) ) j = Py_SIZE ( a ) ;\n if ( i == 0 && j == Py_SIZE ( a ) && PyString_CheckExact ( a ) ) {\n Py_INCREF ( a ) ;\n return ( PyObject * ) a ;\n }\n if ( j < i ) j = i ;\n return PyString_FromStringAndSize ( a -> ob_sval + i , j - i ) ;\n }",
        "output": "0",
        "idx": 3117
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ff_find_unused_picture ( MpegEncContext * s , int shared ) {\n int ret = find_unused_picture ( s , shared ) ;\n if ( ret >= 0 && ret < s -> picture_range_end ) {\n if ( s -> picture [ ret ] . needs_realloc ) {\n s -> picture [ ret ] . needs_realloc = 0 ;\n free_picture ( s , & s -> picture [ ret ] ) ;\n avcodec_get_frame_defaults ( & s -> picture [ ret ] . f ) ;\n }\n }\n return ret ;\n }",
        "output": "1",
        "idx": 4403
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void update_frames ( AVCodecContext * avctx ) {\n Vp3DecodeContext * s = avctx -> priv_data ;\n if ( s -> last_frame . data [ 0 ] && s -> last_frame . type != FF_BUFFER_TYPE_COPY ) ff_thread_release_buffer ( avctx , & s -> last_frame ) ;\n s -> last_frame = s -> current_frame ;\n if ( s -> keyframe ) {\n if ( s -> golden_frame . data [ 0 ] ) ff_thread_release_buffer ( avctx , & s -> golden_frame ) ;\n s -> golden_frame = s -> current_frame ;\n s -> last_frame . type = FF_BUFFER_TYPE_COPY ;\n }\n s -> current_frame . data [ 0 ] = NULL ;\n }",
        "output": "1",
        "idx": 2118
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int decode_cabac_field_decoding_flag ( H264Context * h ) {\n const long mbb_xy = h -> mb_xy - 2L * h -> mb_stride ;\n unsigned long ctx = 0 ;\n ctx += h -> mb_field_decoding_flag & ! ! h -> mb_x ;\n ctx += ( h -> cur_pic . f . mb_type [ mbb_xy ] >> 7 ) & ( h -> slice_table [ mbb_xy ] == h -> slice_num ) ;\n return get_cabac_noinline ( & h -> cabac , & ( h -> cabac_state + 70 ) [ ctx ] ) ;\n }",
        "output": "1",
        "idx": 1576
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlChar * xsltEvalXPathString ( xsltTransformContextPtr ctxt , xmlXPathCompExprPtr comp ) {\n return ( xsltEvalXPathStringNs ( ctxt , comp , 0 , NULL ) ) ;\n }",
        "output": "0",
        "idx": 1289
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_Connect_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 528 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_Connect_UUIE , Connect_UUIE_sequence ) ;\n # line 532 \"./asn1/h225/h225.cnf\" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> cs_type = H225_CONNECT ;\n if ( contains_faststart == TRUE ) g_snprintf ( h225_pi -> frame_label , 50 , \"%s OLC (%s)\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) , h225_pi -> frame_label ) ;\n else g_snprintf ( h225_pi -> frame_label , 50 , \"%s\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) ) ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 3157
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( ExternalProtocolDialogBrowserTest , TestCloseWithChecked ) {\n ShowDialog ( ) ;\n SetChecked ( true ) ;\n EXPECT_TRUE ( dialog_ -> Close ( ) ) ;\n EXPECT_TRUE ( called_ ) ;\n EXPECT_FALSE ( accept_ ) ;\n EXPECT_TRUE ( cancel_ ) ;\n EXPECT_FALSE ( dont_block_ ) ;\n histogram_tester_ . ExpectTotalCount ( ExternalProtocolHandler : : kRememberCheckboxMetric , 0 ) ;\n histogram_tester_ . ExpectTotalCount ( ExternalProtocolHandler : : kHandleStateMetric , 0 ) ;\n }",
        "output": "1",
        "idx": 3400
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_idct8x8_12_add_c ( const int16_t * input , uint8_t * dest , int stride ) {\n int16_t out [ 8 * 8 ] = {\n 0 }\n ;\n int16_t * outptr = out ;\n int i , j ;\n int16_t temp_in [ 8 ] , temp_out [ 8 ] ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) {\n idct8 ( input , outptr ) ;\n input += 8 ;\n outptr += 8 ;\n }\n for ( i = 0 ;\n i < 8 ;\n ++ i ) {\n for ( j = 0 ;\n j < 8 ;\n ++ j ) temp_in [ j ] = out [ j * 8 + i ] ;\n idct8 ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 8 ;\n ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 5 ) + dest [ j * stride + i ] ) ;\n }\n }",
        "output": "1",
        "idx": 250
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int svq3_decode_end ( AVCodecContext * avctx ) {\n SVQ3Context * s = avctx -> priv_data ;\n H264Context * h = & s -> h ;\n free_picture ( avctx , s -> cur_pic ) ;\n free_picture ( avctx , s -> next_pic ) ;\n free_picture ( avctx , s -> last_pic ) ;\n ff_h264_free_context ( h ) ;\n return 0 ;\n }",
        "output": "1",
        "idx": 1560
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int seqvideo_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n SeqVideoContext * seq = avctx -> priv_data ;\n seq -> frame . reference = 1 ;\n seq -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( avctx -> reget_buffer ( avctx , & seq -> frame ) ) {\n av_log ( seq -> avctx , AV_LOG_ERROR , \"tiertexseqvideo: reget_buffer() failed\\n\" ) ;\n return - 1 ;\n }\n if ( seqvideo_decode ( seq , buf , buf_size ) ) return AVERROR_INVALIDDATA ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = seq -> frame ;\n return buf_size ;\n }",
        "output": "1",
        "idx": 842
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rlvl_destroy ( jpc_enc_rlvl_t * rlvl ) {\n jpc_enc_band_t * band ;\n uint_fast16_t bandno ;\n if ( rlvl -> bands ) {\n for ( bandno = 0 , band = rlvl -> bands ;\n bandno < rlvl -> numbands ;\n ++ bandno , ++ band ) {\n band_destroy ( band ) ;\n }\n jas_free ( rlvl -> bands ) ;\n }\n }",
        "output": "1",
        "idx": 4450
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "double mcv_selectivity ( VariableStatData * vardata , FmgrInfo * opproc , Datum constval , bool varonleft , double * sumcommonp ) {\n double mcv_selec , sumcommon ;\n Datum * values ;\n int nvalues ;\n float4 * numbers ;\n int nnumbers ;\n int i ;\n mcv_selec = 0.0 ;\n sumcommon = 0.0 ;\n if ( HeapTupleIsValid ( vardata -> statsTuple ) && get_attstatsslot ( vardata -> statsTuple , vardata -> atttype , vardata -> atttypmod , STATISTIC_KIND_MCV , InvalidOid , NULL , & values , & nvalues , & numbers , & nnumbers ) ) {\n for ( i = 0 ;\n i < nvalues ;\n i ++ ) {\n if ( varonleft ? DatumGetBool ( FunctionCall2Coll ( opproc , DEFAULT_COLLATION_OID , values [ i ] , constval ) ) : DatumGetBool ( FunctionCall2Coll ( opproc , DEFAULT_COLLATION_OID , constval , values [ i ] ) ) ) mcv_selec += numbers [ i ] ;\n sumcommon += numbers [ i ] ;\n }\n free_attstatsslot ( vardata -> atttype , values , nvalues , numbers , nnumbers ) ;\n }\n * sumcommonp = sumcommon ;\n return mcv_selec ;\n }",
        "output": "1",
        "idx": 2323
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void print_field_types ( MYSQL_RES * result ) {\n MYSQL_FIELD * field ;\n uint i = 0 ;\n while ( ( field = mysql_fetch_field ( result ) ) ) {\n tee_fprintf ( PAGER , \"Field %3u: `%s`\\n\" \"Catalog: `%s`\\n\" \"Database: `%s`\\n\" \"Table: `%s`\\n\" \"Org_table: `%s`\\n\" \"Type: %s\\n\" \"Collation: %s (%u)\\n\" \"Length: %lu\\n\" \"Max_length: %lu\\n\" \"Decimals: %u\\n\" \"Flags: %s\\n\\n\" , ++ i , field -> name , field -> catalog , field -> db , field -> table , field -> org_table , fieldtype2str ( field -> type ) , get_charset_name ( field -> charsetnr ) , field -> charsetnr , field -> length , field -> max_length , field -> decimals , fieldflags2str ( field -> flags ) ) ;\n }\n tee_puts ( \"\" , PAGER ) ;\n }",
        "output": "0",
        "idx": 2348
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cmd_network_remove ( const char * data ) {\n IRC_CHATNET_REC * rec ;\n if ( * data == '\\0' ) cmd_return_error ( CMDERR_NOT_ENOUGH_PARAMS ) ;\n rec = ircnet_find ( data ) ;\n if ( rec == NULL ) printformat ( NULL , NULL , MSGLEVEL_CLIENTNOTICE , IRCTXT_NETWORK_NOT_FOUND , data ) ;\n else {\n server_setup_remove_chatnet ( data ) ;\n channel_setup_remove_chatnet ( data ) ;\n printformat ( NULL , NULL , MSGLEVEL_CLIENTNOTICE , IRCTXT_NETWORK_REMOVED , data ) ;\n chatnet_remove ( CHATNET ( rec ) ) ;\n }\n }",
        "output": "0",
        "idx": 2075
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , UncommittedLoadWithError ) {\n StartHttpsServer ( true ) ;\n TabStripModel * tab_strip_model = browser ( ) -> tab_strip_model ( ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , https_test_server_ -> GetURL ( \"/simple.html\" ) ) ;\n content : : WebContentsDestroyedWatcher destroyed_watcher ( tab_strip_model -> GetActiveWebContents ( ) ) ;\n EXPECT_TRUE ( tab_strip_model -> CloseWebContentsAt ( tab_strip_model -> active_index ( ) , 0 ) ) ;\n destroyed_watcher . Wait ( ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 0 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;\n }",
        "output": "1",
        "idx": 4343
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int roq_encode_init ( AVCodecContext * avctx ) {\n RoqContext * enc = avctx -> priv_data ;\n av_lfg_init ( & enc -> randctx , 1 ) ;\n enc -> framesSinceKeyframe = 0 ;\n if ( ( avctx -> width & 0xf ) || ( avctx -> height & 0xf ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Dimensions must be divisible by 16\\n\" ) ;\n return - 1 ;\n }\n if ( ( ( avctx -> width ) & ( avctx -> width - 1 ) ) || ( ( avctx -> height ) & ( avctx -> height - 1 ) ) ) av_log ( avctx , AV_LOG_ERROR , \"Warning: dimensions not power of two\\n\" ) ;\n enc -> width = avctx -> width ;\n enc -> height = avctx -> height ;\n enc -> framesSinceKeyframe = 0 ;\n enc -> first_frame = 1 ;\n enc -> last_frame = & enc -> frames [ 0 ] ;\n enc -> current_frame = & enc -> frames [ 1 ] ;\n enc -> tmpData = av_malloc ( sizeof ( RoqTempdata ) ) ;\n enc -> this_motion4 = av_mallocz ( ( enc -> width * enc -> height / 16 ) * sizeof ( motion_vect ) ) ;\n enc -> last_motion4 = av_malloc ( ( enc -> width * enc -> height / 16 ) * sizeof ( motion_vect ) ) ;\n enc -> this_motion8 = av_mallocz ( ( enc -> width * enc -> height / 64 ) * sizeof ( motion_vect ) ) ;\n enc -> last_motion8 = av_malloc ( ( enc -> width * enc -> height / 64 ) * sizeof ( motion_vect ) ) ;\n return 0 ;\n }",
        "output": "1",
        "idx": 2150
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TSReturnCode sdk_sanity_check_mbuffer ( TSMBuffer bufp ) {\n HdrHeapSDKHandle * handle = ( HdrHeapSDKHandle * ) bufp ;\n if ( ( handle == nullptr ) || ( handle -> m_heap == nullptr ) || ( handle -> m_heap -> m_magic != HDR_BUF_MAGIC_ALIVE ) ) {\n return TS_ERROR ;\n }\n return TS_SUCCESS ;\n }",
        "output": "0",
        "idx": 2322
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "enum ImapAuthRes imap_auth_login ( struct ImapData * idata , const char * method ) {\n char q_user [ SHORT_STRING ] , q_pass [ SHORT_STRING ] ;\n char buf [ STRING ] ;\n int rc ;\n if ( mutt_bit_isset ( idata -> capabilities , LOGINDISABLED ) ) {\n mutt_message ( _ ( \"LOGIN disabled on this server.\" ) ) ;\n return IMAP_AUTH_UNAVAIL ;\n }\n if ( mutt_account_getuser ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ;\n if ( mutt_account_getpass ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ;\n mutt_message ( _ ( \"Logging in...\" ) ) ;\n imap_quote_string ( q_user , sizeof ( q_user ) , idata -> conn -> account . user ) ;\n imap_quote_string ( q_pass , sizeof ( q_pass ) , idata -> conn -> account . pass ) ;\n if ( DebugLevel < IMAP_LOG_PASS ) mutt_debug ( 2 , \"Sending LOGIN command for %s...\\n\" , idata -> conn -> account . user ) ;\n snprintf ( buf , sizeof ( buf ) , \"LOGIN %s %s\" , q_user , q_pass ) ;\n rc = imap_exec ( idata , buf , IMAP_CMD_FAIL_OK | IMAP_CMD_PASS ) ;\n if ( ! rc ) {\n mutt_clear_error ( ) ;\n return IMAP_AUTH_SUCCESS ;\n }\n mutt_error ( _ ( \"Login failed.\" ) ) ;\n return IMAP_AUTH_FAILURE ;\n }",
        "output": "1",
        "idx": 1478
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_btgatt_microbit_pin_data ( tvbuff_t * tvb , packet_info * pinfo _U_ , proto_tree * tree , void * data ) {\n btatt_data_t * att_data = ( btatt_data_t * ) data ;\n proto_item * sub_item ;\n proto_tree * sub_tree ;\n gint offset = 0 ;\n gint num_pins ;\n guint32 number , value ;\n if ( bluetooth_gatt_has_no_parameter ( att_data -> opcode ) ) return - 1 ;\n num_pins = tvb_captured_length ( tvb ) / 2 ;\n for ( gint i = 0 ;\n i < num_pins ;\n i ++ ) {\n sub_item = proto_tree_add_item ( tree , hf_gatt_microbit_pin_data , tvb , offset , 2 , ENC_NA ) ;\n sub_tree = proto_item_add_subtree ( sub_item , ett_btgatt_microbit_pin_data ) ;\n proto_tree_add_item_ret_uint ( sub_tree , hf_gatt_microbit_pin_number , tvb , offset , 1 , ENC_NA , & number ) ;\n offset ++ ;\n value = tvb_get_guint8 ( tvb , offset ) * 4 ;\n proto_tree_add_uint ( sub_tree , hf_gatt_microbit_pin_value , tvb , offset , 1 , value ) ;\n offset ++ ;\n proto_item_set_text ( sub_item , \"Pin %u: %u\" , number , value ) ;\n }\n return offset ;\n }",
        "output": "0",
        "idx": 2326
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void idct_put ( MDECContext * a , int mb_x , int mb_y ) {\n int16_t ( * block ) [ 64 ] = a -> block ;\n int linesize = a -> picture . linesize [ 0 ] ;\n uint8_t * dest_y = a -> picture . data [ 0 ] + ( mb_y * 16 * linesize ) + mb_x * 16 ;\n uint8_t * dest_cb = a -> picture . data [ 1 ] + ( mb_y * 8 * a -> picture . linesize [ 1 ] ) + mb_x * 8 ;\n uint8_t * dest_cr = a -> picture . data [ 2 ] + ( mb_y * 8 * a -> picture . linesize [ 2 ] ) + mb_x * 8 ;\n a -> dsp . idct_put ( dest_y , linesize , block [ 0 ] ) ;\n a -> dsp . idct_put ( dest_y + 8 , linesize , block [ 1 ] ) ;\n a -> dsp . idct_put ( dest_y + 8 * linesize , linesize , block [ 2 ] ) ;\n a -> dsp . idct_put ( dest_y + 8 * linesize + 8 , linesize , block [ 3 ] ) ;\n if ( ! ( a -> avctx -> flags & CODEC_FLAG_GRAY ) ) {\n a -> dsp . idct_put ( dest_cb , a -> picture . linesize [ 1 ] , block [ 4 ] ) ;\n a -> dsp . idct_put ( dest_cr , a -> picture . linesize [ 2 ] , block [ 5 ] ) ;\n }\n }",
        "output": "1",
        "idx": 1971
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int file_alloc_security ( struct file * file ) {\n struct file_security_struct * fsec ;\n u32 sid = current_sid ( ) ;\n fsec = kmem_cache_zalloc ( file_security_cache , GFP_KERNEL ) ;\n if ( ! fsec ) return - ENOMEM ;\n fsec -> sid = sid ;\n fsec -> fown_sid = sid ;\n file -> f_security = fsec ;\n return 0 ;\n }",
        "output": "0",
        "idx": 874
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct archive_wstring * archive_wstring_append ( struct archive_wstring * as , const wchar_t * p , size_t s ) {\n if ( archive_wstring_ensure ( as , as -> length + s + 1 ) == NULL ) return ( NULL ) ;\n wmemmove ( as -> s + as -> length , p , s ) ;\n as -> length += s ;\n as -> s [ as -> length ] = 0 ;\n return ( as ) ;\n }",
        "output": "0",
        "idx": 1243
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int rawv6_rcv_skb ( struct sock * sk , struct sk_buff * skb ) {\n if ( ( raw6_sk ( sk ) -> checksum || sk -> sk_filter ) && skb_checksum_complete ( skb ) ) {\n atomic_inc ( & sk -> sk_drops ) ;\n kfree_skb ( skb ) ;\n return NET_RX_DROP ;\n }\n if ( sock_queue_rcv_skb ( sk , skb ) < 0 ) {\n kfree_skb ( skb ) ;\n return NET_RX_DROP ;\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 1656
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int spl_filesystem_file_is_empty_line ( spl_filesystem_object * intern TSRMLS_DC ) {\n if ( intern -> u . file . current_line ) {\n return intern -> u . file . current_line_len == 0 ;\n }\n else if ( intern -> u . file . current_zval ) {\n switch ( Z_TYPE_P ( intern -> u . file . current_zval ) ) {\n case IS_STRING : return Z_STRLEN_P ( intern -> u . file . current_zval ) == 0 ;\n case IS_ARRAY : if ( SPL_HAS_FLAG ( intern -> flags , SPL_FILE_OBJECT_READ_CSV ) && zend_hash_num_elements ( Z_ARRVAL_P ( intern -> u . file . current_zval ) ) == 1 ) {\n zval * * first = Z_ARRVAL_P ( intern -> u . file . current_zval ) -> pListHead -> pData ;\n return Z_TYPE_PP ( first ) == IS_STRING && Z_STRLEN_PP ( first ) == 0 ;\n }\n return zend_hash_num_elements ( Z_ARRVAL_P ( intern -> u . file . current_zval ) ) == 0 ;\n case IS_NULL : return 1 ;\n default : return 0 ;\n }\n }\n else {\n return 1 ;\n }\n }",
        "output": "1",
        "idx": 1344
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char * xmlrpc_normalizeBuffer ( const char * buf ) {\n char * newbuf ;\n int i , len , j = 0 ;\n len = strlen ( buf ) ;\n newbuf = ( char * ) smalloc ( sizeof ( char ) * len + 1 ) ;\n for ( i = 0 ;\n i < len ;\n i ++ ) {\n switch ( buf [ i ] ) {\n case 1 : break ;\n case 2 : break ;\n case 3 : if ( isdigit ( ( unsigned char ) buf [ i + 1 ] ) ) {\n i ++ ;\n if ( isdigit ( ( unsigned char ) buf [ i + 1 ] ) ) {\n i ++ ;\n }\n if ( buf [ i + 1 ] == ',' ) {\n i ++ ;\n if ( isdigit ( ( unsigned char ) buf [ i + 1 ] ) ) {\n i ++ ;\n }\n if ( isdigit ( ( unsigned char ) buf [ i + 1 ] ) ) {\n i ++ ;\n }\n }\n }\n break ;\n case 9 : break ;\n case 10 : break ;\n case 13 : break ;\n case 22 : break ;\n case 31 : break ;\n default : if ( buf [ i ] > 31 ) {\n newbuf [ j ] = buf [ i ] ;\n j ++ ;\n }\n }\n }\n newbuf [ j ] = 0 ;\n return ( newbuf ) ;\n }",
        "output": "0",
        "idx": 4271
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gs_main_instance * gs_main_alloc_instance ( gs_memory_t * mem ) {\n gs_main_instance * minst ;\n if ( mem == NULL ) return NULL ;\n minst = ( gs_main_instance * ) gs_alloc_bytes_immovable ( mem , sizeof ( gs_main_instance ) , \"init_main_instance\" ) ;\n if ( minst == NULL ) return NULL ;\n memcpy ( minst , & gs_main_instance_init_values , sizeof ( gs_main_instance_init_values ) ) ;\n minst -> heap = mem ;\n mem -> gs_lib_ctx -> top_of_system = minst ;\n return minst ;\n }",
        "output": "0",
        "idx": 1355
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static byte * i_alloc_byte_array ( gs_memory_t * mem , uint num_elements , uint elt_size , client_name_t cname ) {\n gs_ref_memory_t * const imem = ( gs_ref_memory_t * ) mem ;\n obj_header_t * obj ;\n # ifdef MEMENTO if ( Memento_failThisEvent ( ) ) return NULL ;\n # endif obj = alloc_obj ( imem , ( ulong ) num_elements * elt_size , & st_bytes , ALLOC_DIRECT , cname ) ;\n if_debug6m ( 'A' , mem , \"[a%d:+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\\n\" , alloc_trace_space ( imem ) , client_name_string ( cname ) , ( ulong ) num_elements * elt_size , num_elements , elt_size , ( ulong ) obj ) ;\n return ( byte * ) obj ;\n }",
        "output": "1",
        "idx": 656
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static cmsBool Read16bitTables ( cmsContext ContextID , cmsIOHANDLER * io , cmsPipeline * lut , int nChannels , int nEntries ) {\n int i ;\n cmsToneCurve * Tables [ cmsMAXCHANNELS ] ;\n if ( nEntries <= 0 ) return TRUE ;\n if ( nEntries < 2 ) return FALSE ;\n if ( nChannels > cmsMAXCHANNELS ) return FALSE ;\n memset ( Tables , 0 , sizeof ( Tables ) ) ;\n for ( i = 0 ;\n i < nChannels ;\n i ++ ) {\n Tables [ i ] = cmsBuildTabulatedToneCurve16 ( ContextID , nEntries , NULL ) ;\n if ( Tables [ i ] == NULL ) goto Error ;\n if ( ! _cmsReadUInt16Array ( io , nEntries , Tables [ i ] -> Table16 ) ) goto Error ;\n }\n if ( ! cmsPipelineInsertStage ( lut , cmsAT_END , cmsStageAllocToneCurves ( ContextID , nChannels , Tables ) ) ) goto Error ;\n for ( i = 0 ;\n i < nChannels ;\n i ++ ) cmsFreeToneCurve ( Tables [ i ] ) ;\n return TRUE ;\n Error : for ( i = 0 ;\n i < nChannels ;\n i ++ ) {\n if ( Tables [ i ] ) cmsFreeToneCurve ( Tables [ i ] ) ;\n }\n return FALSE ;\n }",
        "output": "0",
        "idx": 3482
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void free_picture ( MpegEncContext * s , Picture * pic ) {\n int i ;\n if ( pic -> f . data [ 0 ] && pic -> f . type != FF_BUFFER_TYPE_SHARED ) {\n free_frame_buffer ( s , pic ) ;\n }\n av_freep ( & pic -> mb_var ) ;\n av_freep ( & pic -> mc_mb_var ) ;\n av_freep ( & pic -> mb_mean ) ;\n av_freep ( & pic -> f . mbskip_table ) ;\n av_freep ( & pic -> qscale_table_base ) ;\n pic -> f . qscale_table = NULL ;\n av_freep ( & pic -> mb_type_base ) ;\n pic -> f . mb_type = NULL ;\n av_freep ( & pic -> f . dct_coeff ) ;\n av_freep ( & pic -> f . pan_scan ) ;\n pic -> f . mb_type = NULL ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n av_freep ( & pic -> motion_val_base [ i ] ) ;\n av_freep ( & pic -> f . ref_index [ i ] ) ;\n pic -> f . motion_val [ i ] = NULL ;\n }\n if ( pic -> f . type == FF_BUFFER_TYPE_SHARED ) {\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n pic -> f . base [ i ] = pic -> f . data [ i ] = NULL ;\n }\n pic -> f . type = 0 ;\n }\n }",
        "output": "1",
        "idx": 669
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void proto_tree_set_system_id_tvb ( field_info * fi , tvbuff_t * tvb , gint start , gint length ) {\n proto_tree_set_system_id ( fi , tvb_get_ptr ( tvb , start , length ) , length ) ;\n }",
        "output": "0",
        "idx": 70
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_max_filter_level ( const VP9_COMP * cpi ) {\n if ( cpi -> oxcf . pass == 2 ) {\n return cpi -> twopass . section_intra_rating > 8 ? MAX_LOOP_FILTER * 3 / 4 : MAX_LOOP_FILTER ;\n }\n else {\n return MAX_LOOP_FILTER ;\n }\n }",
        "output": "0",
        "idx": 4052
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE ossl_x509name_cmp ( VALUE self , VALUE other ) {\n int result ;\n result = ossl_x509name_cmp0 ( self , other ) ;\n if ( result < 0 ) return INT2FIX ( - 1 ) ;\n if ( result > 1 ) return INT2FIX ( 1 ) ;\n return INT2FIX ( 0 ) ;\n }",
        "output": "1",
        "idx": 4219
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int X509_REQ_sign_ctx ( X509_REQ * x , EVP_MD_CTX * ctx ) {\n return ASN1_item_sign_ctx ( ASN1_ITEM_rptr ( X509_REQ_INFO ) , x -> sig_alg , NULL , x -> signature , x -> req_info , ctx ) ;\n }",
        "output": "0",
        "idx": 3855
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TSReturnCode TSHttpTxnConfigIntSet ( TSHttpTxn txnp , TSOverridableConfigKey conf , TSMgmtInt value ) {\n sdk_assert ( sdk_sanity_check_txn ( txnp ) == TS_SUCCESS ) ;\n HttpSM * s = reinterpret_cast < HttpSM * > ( txnp ) ;\n OverridableDataType type ;\n s -> t_state . setup_per_txn_configs ( ) ;\n void * dest = _conf_to_memberp ( conf , s -> t_state . txn_conf , & type ) ;\n if ( ! dest ) {\n return TS_ERROR ;\n }\n switch ( type ) {\n case OVERRIDABLE_TYPE_INT : * ( static_cast < TSMgmtInt * > ( dest ) ) = value ;\n break ;\n case OVERRIDABLE_TYPE_BYTE : * ( static_cast < TSMgmtByte * > ( dest ) ) = static_cast < TSMgmtByte > ( value ) ;\n break ;\n default : return TS_ERROR ;\n }\n return TS_SUCCESS ;\n }",
        "output": "0",
        "idx": 3394
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TSReturnCode TSUuidInitialize ( TSUuid uuid , TSUuidVersion v ) {\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) uuid ) == TS_SUCCESS ) ;\n ATSUuid * u = ( ATSUuid * ) uuid ;\n u -> initialize ( v ) ;\n return u -> valid ( ) ? TS_SUCCESS : TS_ERROR ;\n }",
        "output": "0",
        "idx": 3673
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vpx_codec_err_t vpx_svc_get_layer_resolution ( const SvcContext * svc_ctx , int layer , unsigned int * width , unsigned int * height ) {\n int w , h , index , num , den ;\n const SvcInternal * const si = get_const_svc_internal ( svc_ctx ) ;\n if ( svc_ctx == NULL || si == NULL || width == NULL || height == NULL ) {\n return VPX_CODEC_INVALID_PARAM ;\n }\n if ( layer < 0 || layer >= si -> layers ) return VPX_CODEC_INVALID_PARAM ;\n index = layer + VPX_SS_MAX_LAYERS - si -> layers ;\n num = si -> scaling_factor_num [ index ] ;\n den = si -> scaling_factor_den [ index ] ;\n if ( num == 0 || den == 0 ) return VPX_CODEC_INVALID_PARAM ;\n w = si -> width * num / den ;\n h = si -> height * num / den ;\n w += w % 2 ;\n h += h % 2 ;\n * width = w ;\n * height = h ;\n return VPX_CODEC_OK ;\n }",
        "output": "1",
        "idx": 2768
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const u_char * print_sl_change ( netdissect_options * ndo , const char * str , register const u_char * cp ) {\n register u_int i ;\n if ( ( i = * cp ++ ) == 0 ) {\n i = EXTRACT_16BITS ( cp ) ;\n cp += 2 ;\n }\n ND_PRINT ( ( ndo , \" %s%d\" , str , i ) ) ;\n return ( cp ) ;\n }",
        "output": "0",
        "idx": 3741
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static guint32 pad_offset ( struct tcpinfo * tcpinfo , guint32 fpdu_total_len , guint8 pad_len ) {\n if ( ( tcpinfo -> nxtseq - MPA_CRC_LEN - MPA_MARKER_LEN ) % MPA_MARKER_INTERVAL == 0 ) {\n return fpdu_total_len - MPA_CRC_LEN - MPA_MARKER_LEN - pad_len ;\n }\n else {\n return fpdu_total_len - MPA_CRC_LEN - pad_len ;\n }\n }",
        "output": "0",
        "idx": 560
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_partial_b64x64_partition ( MODE_INFO * mi , int mis , int bh_in , int bw_in , int row8x8_remaining , int col8x8_remaining , BLOCK_SIZE bsize , MODE_INFO * * mi_8x8 ) {\n int bh = bh_in ;\n int r , c ;\n for ( r = 0 ;\n r < MI_BLOCK_SIZE ;\n r += bh ) {\n int bw = bw_in ;\n for ( c = 0 ;\n c < MI_BLOCK_SIZE ;\n c += bw ) {\n const int index = r * mis + c ;\n mi_8x8 [ index ] = mi + index ;\n mi_8x8 [ index ] -> mbmi . sb_type = find_partition_size ( bsize , row8x8_remaining - r , col8x8_remaining - c , & bh , & bw ) ;\n }\n }\n }",
        "output": "1",
        "idx": 552
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( DirectoryIterator , getFilename ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n RETURN_STRING ( intern -> u . dir . entry . d_name , 1 ) ;\n }",
        "output": "1",
        "idx": 45
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char * getPosixID ( const ILcidPosixMap * this_0 , uint32_t hostID ) {\n uint32_t i ;\n for ( i = 0 ;\n i <= this_0 -> numRegions ;\n i ++ ) {\n if ( this_0 -> regionMaps [ i ] . hostID == hostID ) {\n return this_0 -> regionMaps [ i ] . posixID ;\n }\n }\n return this_0 -> regionMaps [ 0 ] . posixID ;\n }",
        "output": "1",
        "idx": 3968
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int array_min_int16 ( const int16_t * array , int nel ) {\n int i , min = array [ 0 ] ;\n for ( i = 1 ;\n i < nel ;\n i ++ ) min = FFMIN ( array [ i ] , min ) ;\n return min ;\n }",
        "output": "1",
        "idx": 329
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int parse_CRangeCategSpec ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , const char * fmt , ... ) {\n proto_item * item ;\n proto_tree * tree ;\n va_list ap ;\n unsigned i ;\n const char * txt ;\n guint32 cRange ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CRangeCategSpec , & item , txt ) ;\n offset = parse_lcid ( tvb , offset , tree , \"lcid\" ) ;\n cRange = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_crangecategspec_crange , tvb , offset , 4 , cRange ) ;\n offset += 4 ;\n for ( i = 0 ;\n i < cRange ;\n i ++ ) {\n offset = parse_RANGEBOUNDARY ( tvb , offset , tree , pad_tree , \"aRangeBegin[%u]\" , i ) ;\n }\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }",
        "output": "1",
        "idx": 3610
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int evbuffer_expand ( struct evbuffer * buf , size_t datlen ) {\n size_t used = buf -> misalign + buf -> off ;\n assert ( buf -> totallen >= used ) ;\n if ( buf -> totallen - used >= datlen ) return ( 0 ) ;\n if ( datlen > SIZE_MAX - buf -> off ) return ( - 1 ) ;\n if ( buf -> totallen - buf -> off >= datlen ) {\n evbuffer_align ( buf ) ;\n }\n else {\n void * newbuf ;\n size_t length = buf -> totallen ;\n size_t need = buf -> off + datlen ;\n if ( length < 256 ) length = 256 ;\n if ( need < SIZE_MAX / 2 ) {\n while ( length < need ) {\n length <<= 1 ;\n }\n }\n else {\n length = need ;\n }\n if ( buf -> orig_buffer != buf -> buffer ) evbuffer_align ( buf ) ;\n if ( ( newbuf = realloc ( buf -> buffer , length ) ) == NULL ) return ( - 1 ) ;\n buf -> orig_buffer = buf -> buffer = newbuf ;\n buf -> totallen = length ;\n }\n return ( 0 ) ;\n }",
        "output": "0",
        "idx": 525
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cpu_request_exit ( void * opaque , int irq , int level ) {\n CPUMIPSState * env = cpu_single_env ;\n if ( env && level ) {\n cpu_exit ( CPU ( mips_env_get_cpu ( env ) ) ) ;\n }\n }",
        "output": "1",
        "idx": 2923
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sbr_hf_apply_noise_0 ( float ( * Y ) [ 2 ] , const float * s_m , const float * q_filt , int noise , int kx , int m_max ) {\n sbr_hf_apply_noise ( Y , s_m , q_filt , noise , 1.0 , 0.0 , m_max ) ;\n }",
        "output": "1",
        "idx": 1933
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void evsignal_dealloc ( struct event_base * base ) {\n int i = 0 ;\n if ( base -> sig . ev_signal_added ) {\n event_del ( & base -> sig . ev_signal ) ;\n base -> sig . ev_signal_added = 0 ;\n }\n for ( i = 0 ;\n i < NSIG ;\n ++ i ) {\n if ( i < base -> sig . sh_old_max && base -> sig . sh_old [ i ] != NULL ) _evsignal_restore_handler ( base , i ) ;\n }\n EVUTIL_CLOSESOCKET ( base -> sig . ev_signal_pair [ 0 ] ) ;\n base -> sig . ev_signal_pair [ 0 ] = - 1 ;\n EVUTIL_CLOSESOCKET ( base -> sig . ev_signal_pair [ 1 ] ) ;\n base -> sig . ev_signal_pair [ 1 ] = - 1 ;\n base -> sig . sh_old_max = 0 ;\n free ( base -> sig . sh_old ) ;\n }",
        "output": "1",
        "idx": 10
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _SCSUClose ( UConverter * cnv ) {\n if ( cnv -> extraInfo != NULL ) {\n if ( ! cnv -> isExtraLocal ) {\n uprv_free ( cnv -> extraInfo ) ;\n }\n cnv -> extraInfo = NULL ;\n }\n }",
        "output": "1",
        "idx": 1375
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int UnblendedCompare ( real u1 [ MmMax ] , real u2 [ MmMax ] , int cnt ) {\n int i ;\n for ( i = 0 ;\n i < cnt ;\n ++ i ) {\n if ( u1 [ i ] != u2 [ i ] ) return ( u1 [ i ] > u2 [ i ] ? 1 : - 1 ) ;\n }\n return ( 0 ) ;\n }",
        "output": "0",
        "idx": 367
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_current_cpu ( void ) {\n CPUState * cpu_single_cpu ;\n if ( ! cpu_single_env ) {\n return - 1 ;\n }\n cpu_single_cpu = ENV_GET_CPU ( cpu_single_env ) ;\n return cpu_single_cpu -> cpu_index ;\n }",
        "output": "1",
        "idx": 2655
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_PRINTER_INFO_3 ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_printer_flags , NULL ) ;\n offset = dissect_nt_sec_desc ( tvb , offset , pinfo , tree , drep , FALSE , - 1 , & spoolss_printer_access_mask_info ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 1857
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void FLOATING_POINT_RESTORE ( ) {\n }",
        "output": "0",
        "idx": 3011
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int keyring_lock ( KEYRING_HANDLE hd , int yes ) {\n KR_NAME kr ;\n int rc = 0 ;\n ( void ) hd ;\n if ( yes ) {\n for ( kr = kr_names ;\n kr ;\n kr = kr -> next ) {\n if ( ! keyring_is_writable ( kr ) ) continue ;\n if ( ! kr -> lockhd ) {\n kr -> lockhd = dotlock_create ( kr -> fname , 0 ) ;\n if ( ! kr -> lockhd ) {\n log_info ( \"can't allocate lock for '%s'\\n\" , kr -> fname ) ;\n rc = GPG_ERR_GENERAL ;\n }\n }\n }\n if ( rc ) return rc ;\n for ( kr = kr_names ;\n kr ;\n kr = kr -> next ) {\n if ( ! keyring_is_writable ( kr ) ) continue ;\n if ( kr -> is_locked ) ;\n else if ( dotlock_take ( kr -> lockhd , - 1 ) ) {\n log_info ( \"can't lock '%s'\\n\" , kr -> fname ) ;\n rc = GPG_ERR_GENERAL ;\n }\n else kr -> is_locked = 1 ;\n }\n }\n if ( rc || ! yes ) {\n for ( kr = kr_names ;\n kr ;\n kr = kr -> next ) {\n if ( ! keyring_is_writable ( kr ) ) continue ;\n if ( ! kr -> is_locked ) ;\n else if ( dotlock_release ( kr -> lockhd ) ) log_info ( \"can't unlock '%s'\\n\" , kr -> fname ) ;\n else kr -> is_locked = 0 ;\n }\n }\n return rc ;\n }",
        "output": "0",
        "idx": 1069
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t get_send_time ( ASFContext * asf , int64_t pres_time , uint64_t * offset ) {\n int i ;\n int32_t send_time = 0 ;\n * offset = asf -> data_offset + DATA_HEADER_SIZE ;\n for ( i = 0 ;\n i < asf -> next_start_sec ;\n i ++ ) {\n if ( pres_time <= asf -> index_ptr [ i ] . send_time ) break ;\n send_time = asf -> index_ptr [ i ] . send_time ;\n * offset = asf -> index_ptr [ i ] . offset ;\n }\n return send_time / 10000 ;\n }",
        "output": "0",
        "idx": 835
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __inline__ void ethtool_cmd_speed_set ( struct ethtool_cmd * ep , __u32 speed ) {\n ep -> speed = ( __u16 ) ( speed & 0xFFFF ) ;\n ep -> speed_hi = ( __u16 ) ( speed >> 16 ) ;\n }",
        "output": "1",
        "idx": 2083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GHashTable * prplcb_ui_info ( ) {\n static GHashTable * ret ;\n if ( ret == NULL ) {\n ret = g_hash_table_new ( g_str_hash , g_str_equal ) ;\n g_hash_table_insert ( ret , \"name\" , \"BitlBee\" ) ;\n g_hash_table_insert ( ret , \"version\" , BITLBEE_VERSION ) ;\n }\n return ret ;\n }",
        "output": "0",
        "idx": 3945
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline my_bool general_log_or_slow_log_tables ( const char * db , const char * table ) {\n return ( ! my_strcasecmp ( charset_info , db , \"mysql\" ) ) && ( ! my_strcasecmp ( charset_info , table , \"general_log\" ) || ! my_strcasecmp ( charset_info , table , \"slow_log\" ) ) ;\n }",
        "output": "0",
        "idx": 2343
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rawv6_init_sk ( struct sock * sk ) {\n struct raw6_sock * rp = raw6_sk ( sk ) ;\n switch ( inet_sk ( sk ) -> inet_num ) {\n case IPPROTO_ICMPV6 : rp -> checksum = 1 ;\n rp -> offset = 2 ;\n break ;\n case IPPROTO_MH : rp -> checksum = 1 ;\n rp -> offset = 4 ;\n break ;\n default : break ;\n }\n return ( 0 ) ;\n }",
        "output": "0",
        "idx": 2231
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_UnregRejectReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 614 \"./asn1/h225/h225.cnf\" gint32 value ;\n h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_UnregRejectReason , UnregRejectReason_choice , & value ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> reason = value ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 4035
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void ff_update_block_index ( MpegEncContext * s ) {\n const int block_size = 8 ;\n s -> block_index [ 0 ] += 2 ;\n s -> block_index [ 1 ] += 2 ;\n s -> block_index [ 2 ] += 2 ;\n s -> block_index [ 3 ] += 2 ;\n s -> block_index [ 4 ] ++ ;\n s -> block_index [ 5 ] ++ ;\n s -> dest [ 0 ] += 2 * block_size ;\n s -> dest [ 1 ] += block_size ;\n s -> dest [ 2 ] += block_size ;\n }",
        "output": "0",
        "idx": 1670
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_disable_segmentation ( struct segmentation * seg ) {\n seg -> enabled = 0 ;\n seg -> update_map = 0 ;\n seg -> update_data = 0 ;\n }",
        "output": "0",
        "idx": 146
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( UnloadTest , DISABLED_CrossSiteInfiniteBeforeUnloadSync ) {\n if ( base : : CommandLine : : ForCurrentProcess ( ) -> HasSwitch ( switches : : kSingleProcess ) ) return ;\n NavigateToDataURL ( INFINITE_BEFORE_UNLOAD_HTML , \"infinitebeforeunload\" ) ;\n NavigateToNolistenersFileTwice ( ) ;\n }",
        "output": "0",
        "idx": 3477
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pcnet_bcr_writew ( PCNetState * s , uint32_t rap , uint32_t val ) {\n rap &= 127 ;\n # ifdef PCNET_DEBUG_BCR printf ( \"pcnet_bcr_writew rap=%d val=0x%04x\\n\" , rap , val ) ;\n # endif switch ( rap ) {\n case BCR_SWS : if ( ! ( CSR_STOP ( s ) || CSR_SPND ( s ) ) ) return ;\n val &= ~ 0x0300 ;\n switch ( val & 0x00ff ) {\n case 0 : val |= 0x0200 ;\n break ;\n case 1 : val |= 0x0100 ;\n break ;\n case 2 : case 3 : val |= 0x0300 ;\n break ;\n default : printf ( \"Bad SWSTYLE=0x%02x\\n\" , val & 0xff ) ;\n val = 0x0200 ;\n break ;\n }\n # ifdef PCNET_DEBUG printf ( \"BCR_SWS=0x%04x\\n\" , val ) ;\n # endif case BCR_LNKST : case BCR_LED1 : case BCR_LED2 : case BCR_LED3 : case BCR_MC : case BCR_FDC : case BCR_BSBC : case BCR_EECAS : case BCR_PLAT : s -> bcr [ rap ] = val ;\n break ;\n default : break ;\n }\n }",
        "output": "0",
        "idx": 1126
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __always_inline __u32 __be32_to_cpup ( const __be32 * p ) {\n return __swab32p ( ( __u32 * ) p ) ;\n }",
        "output": "1",
        "idx": 292
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void compute_curve_gamma_table_type0 ( float gamma_table [ 256 ] ) {\n unsigned int i ;\n for ( i = 0 ;\n i < 256 ;\n i ++ ) {\n gamma_table [ i ] = i / 255. ;\n }\n }",
        "output": "0",
        "idx": 3468
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gx_ttfReader__Read ( ttfReader * self , void * p , int n ) {\n gx_ttfReader * r = ( gx_ttfReader * ) self ;\n const byte * q ;\n if ( ! r -> error ) {\n if ( r -> extra_glyph_index != - 1 ) {\n q = r -> glyph_data . bits . data + r -> pos ;\n r -> error = ( r -> glyph_data . bits . size - r -> pos < n ? gs_note_error ( gs_error_invalidfont ) : 0 ) ;\n if ( r -> error == 0 ) memcpy ( p , q , n ) ;\n }\n else {\n unsigned int cnt ;\n for ( cnt = 0 ;\n cnt < ( uint ) n ;\n cnt += r -> error ) {\n r -> error = r -> pfont -> data . string_proc ( r -> pfont , ( ulong ) r -> pos + cnt , ( ulong ) n - cnt , & q ) ;\n if ( r -> error < 0 ) break ;\n else if ( r -> error == 0 ) {\n memcpy ( ( char * ) p + cnt , q , n - cnt ) ;\n break ;\n }\n else {\n memcpy ( ( char * ) p + cnt , q , r -> error ) ;\n }\n }\n }\n }\n if ( r -> error ) {\n memset ( p , 0 , n ) ;\n return ;\n }\n r -> pos += n ;\n }",
        "output": "1",
        "idx": 888
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void t38_defragment_init ( void ) {\n reassembly_table_init ( & data_reassembly_table , & addresses_reassembly_table_functions ) ;\n }",
        "output": "0",
        "idx": 2475
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_signal_restore ( void ) {\n struct event ev ;\n struct event_base * base = event_init ( ) ;\n # ifdef HAVE_SIGACTION struct sigaction sa ;\n # endif test_ok = 0 ;\n printf ( \"Signal handler restore: \" ) ;\n # ifdef HAVE_SIGACTION sa . sa_handler = signal_cb_sa ;\n sa . sa_flags = 0x0 ;\n sigemptyset ( & sa . sa_mask ) ;\n if ( sigaction ( SIGUSR1 , & sa , NULL ) == - 1 ) goto out ;\n # else if ( signal ( SIGUSR1 , signal_cb_sa ) == SIG_ERR ) goto out ;\n # endif signal_set ( & ev , SIGUSR1 , signal_cb , & ev ) ;\n signal_add ( & ev , NULL ) ;\n signal_del ( & ev ) ;\n raise ( SIGUSR1 ) ;\n if ( test_ok != 2 ) test_ok = 0 ;\n out : event_base_free ( base ) ;\n cleanup_test ( ) ;\n return ;\n }",
        "output": "0",
        "idx": 2838
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int get_file_params_count_resume ( char * * params , int paramcount ) {\n int pos , best ;\n if ( * params [ 0 ] == '\"' ) {\n for ( pos = 0 ;\n pos < paramcount - 2 ;\n pos ++ ) {\n if ( params [ pos ] [ strlen ( params [ pos ] ) - 1 ] == '\"' && get_params_match_resume ( params , pos + 1 ) ) return pos + 1 ;\n }\n }\n best = paramcount - 2 ;\n for ( pos = paramcount - 2 ;\n pos > 0 ;\n pos -- ) {\n if ( get_params_match_resume ( params , pos ) ) best = pos ;\n }\n return best ;\n }",
        "output": "1",
        "idx": 1905
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void virtio_balloon_receive_stats ( VirtIODevice * vdev , VirtQueue * vq ) {\n VirtIOBalloon * s = DO_UPCAST ( VirtIOBalloon , vdev , vdev ) ;\n VirtQueueElement * elem = & s -> stats_vq_elem ;\n VirtIOBalloonStat stat ;\n size_t offset = 0 ;\n if ( ! virtqueue_pop ( vq , elem ) ) {\n return ;\n }\n reset_stats ( s ) ;\n while ( iov_to_buf ( elem -> out_sg , elem -> out_num , & stat , offset , sizeof ( stat ) ) == sizeof ( stat ) ) {\n uint16_t tag = tswap16 ( stat . tag ) ;\n uint64_t val = tswap64 ( stat . val ) ;\n offset += sizeof ( stat ) ;\n if ( tag < VIRTIO_BALLOON_S_NR ) s -> stats [ tag ] = val ;\n }\n s -> stats_vq_offset = offset ;\n }",
        "output": "1",
        "idx": 3912
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int gs_main_add_lib_path ( gs_main_instance * minst , const char * lpath ) {\n int first_is_here = ( r_size ( & minst -> lib_path . list ) != 0 && minst -> lib_path . container . value . refs [ 0 ] . value . bytes == ( const byte * ) gp_current_directory_name ? 1 : 0 ) ;\n int code ;\n r_set_size ( & minst -> lib_path . list , minst -> lib_path . count + first_is_here ) ;\n code = file_path_add ( minst , & minst -> lib_path , lpath ) ;\n minst -> lib_path . count = r_size ( & minst -> lib_path . list ) - first_is_here ;\n if ( code < 0 ) return code ;\n return gs_main_set_lib_paths ( minst ) ;\n }",
        "output": "0",
        "idx": 1869
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void * size_checked_realloc ( void * ptr , size_t size ) {\n if ( size > MAX_LIBXML_MALLOC ) {\n * ( volatile char * ) 0 = '\\0' ;\n return NULL ;\n }\n return realloc ( ptr , size ) ;\n }",
        "output": "1",
        "idx": 141
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_T_t35Extension ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 0U , 255U , & t35Extension , FALSE ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 3635
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_spoolss_keybuffer ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n guint32 size ;\n int end_offset ;\n if ( di -> conformant_run ) return offset ;\n offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_keybuffer_size , & size ) ;\n end_offset = offset + ( size * 2 ) ;\n if ( end_offset < offset ) {\n end_offset = tvb_reported_length_remaining ( tvb , offset ) + 1 ;\n }\n while ( offset < end_offset ) offset = dissect_spoolss_uint16uni ( tvb , offset , pinfo , tree , drep , NULL , hf_keybuffer ) ;\n return offset ;\n }",
        "output": "1",
        "idx": 2714
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_SEQUENCE_OF_MultiplePayloadStreamElementMode ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence_of ( tvb , offset , actx , tree , hf_index , ett_h245_SEQUENCE_OF_MultiplePayloadStreamElementMode , SEQUENCE_OF_MultiplePayloadStreamElementMode_sequence_of ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 4463
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ScoredHistoryMatchTest , ScoringBookmarks ) {\n base : : Time now = base : : Time : : NowFromSystemTime ( ) ;\n std : : string url_string ( \"http://fedcba\" ) ;\n const GURL url ( url_string ) ;\n history : : URLRow row ( MakeURLRow ( url_string . c_str ( ) , \"abcd bcd\" , 8 , 3 , 1 ) ) ;\n RowWordStarts word_starts ;\n PopulateWordStarts ( row , & word_starts ) ;\n WordStarts one_word_no_offset ( 1 , 0u ) ;\n VisitInfoVector visits = CreateVisitInfoVector ( 8 , 3 , now ) ;\n ScoredHistoryMatch scored ( row , visits , std : : string ( ) , ASCIIToUTF16 ( \"abc\" ) , Make1Term ( \"abc\" ) , one_word_no_offset , word_starts , false , nullptr , now ) ;\n base : : AutoReset < int > reset ( & ScoredHistoryMatch : : bookmark_value_ , 5 ) ;\n ScoredHistoryMatch scored_with_bookmark ( row , visits , std : : string ( ) , ASCIIToUTF16 ( \"abc\" ) , Make1Term ( \"abc\" ) , one_word_no_offset , word_starts , true , nullptr , now ) ;\n EXPECT_GT ( scored_with_bookmark . raw_score , scored . raw_score ) ;\n }",
        "output": "1",
        "idx": 4250
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char * get_arg ( char * line , my_bool get_next_arg ) {\n char * ptr , * start ;\n my_bool quoted = 0 , valid_arg = 0 ;\n char qtype = 0 ;\n ptr = line ;\n if ( get_next_arg ) {\n for ( ;\n * ptr ;\n ptr ++ ) ;\n if ( * ( ptr + 1 ) ) ptr ++ ;\n }\n else {\n while ( my_isspace ( charset_info , * ptr ) ) ptr ++ ;\n if ( * ptr == '\\\\' ) ptr += 2 ;\n else while ( * ptr && ! my_isspace ( charset_info , * ptr ) ) ptr ++ ;\n }\n if ( ! * ptr ) return NullS ;\n while ( my_isspace ( charset_info , * ptr ) ) ptr ++ ;\n if ( * ptr == '\\'' || * ptr == '\\\"' || * ptr == '`' ) {\n qtype = * ptr ;\n quoted = 1 ;\n ptr ++ ;\n }\n for ( start = ptr ;\n * ptr ;\n ptr ++ ) {\n if ( * ptr == '\\\\' && ptr [ 1 ] ) {\n strmov_overlapp ( ptr , ptr + 1 ) ;\n }\n else if ( ( ! quoted && * ptr == ' ' ) || ( quoted && * ptr == qtype ) ) {\n * ptr = 0 ;\n break ;\n }\n }\n valid_arg = ptr != start ;\n return valid_arg ? start : NullS ;\n }",
        "output": "1",
        "idx": 3073
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parse_content_disposition ( const char * content_disposition , const char * * filename_r ) {\n struct rfc822_parser_context parser ;\n const char * const * results , * filename2 ;\n string_t * str ;\n * filename_r = NULL ;\n if ( content_disposition == NULL ) return ;\n rfc822_parser_init ( & parser , ( const unsigned char * ) content_disposition , strlen ( content_disposition ) , NULL ) ;\n rfc822_skip_lwsp ( & parser ) ;\n str = t_str_new ( 32 ) ;\n if ( rfc822_parse_mime_token ( & parser , str ) < 0 ) {\n rfc822_parser_deinit ( & parser ) ;\n return ;\n }\n rfc2231_parse ( & parser , & results ) ;\n filename2 = NULL ;\n for ( ;\n * results != NULL ;\n results += 2 ) {\n if ( strcasecmp ( results [ 0 ] , \"filename\" ) == 0 ) {\n * filename_r = results [ 1 ] ;\n break ;\n }\n if ( strcasecmp ( results [ 0 ] , \"filename*\" ) == 0 ) filename2 = results [ 1 ] ;\n }\n if ( * filename_r == NULL ) {\n * filename_r = filename2 ;\n }\n rfc822_parser_deinit ( & parser ) ;\n }",
        "output": "0",
        "idx": 768
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int s390_virtio_console_init ( VirtIOS390Device * dev ) {\n VirtIOS390Bus * bus ;\n VirtIODevice * vdev ;\n int r ;\n bus = DO_UPCAST ( VirtIOS390Bus , bus , dev -> qdev . parent_bus ) ;\n vdev = virtio_console_init ( ( DeviceState * ) dev ) ;\n if ( ! vdev ) {\n return - 1 ;\n }\n r = s390_virtio_device_init ( dev , vdev ) ;\n if ( ! r ) {\n bus -> console = dev ;\n }\n return r ;\n }",
        "output": "1",
        "idx": 3246
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void av_image_copy_plane ( uint8_t * dst , int dst_linesize , const uint8_t * src , int src_linesize , int bytewidth , int height ) {\n if ( ! dst || ! src ) return ;\n for ( ;\n height > 0 ;\n height -- ) {\n memcpy ( dst , src , bytewidth ) ;\n dst += dst_linesize ;\n src += src_linesize ;\n }\n }",
        "output": "0",
        "idx": 2623
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( TemplateURLTest , InputEncodingBeforeSearchTerm ) {\n TemplateURLData data ;\n data . SetURL ( \"http://foox{\ninputEncoding?}\na{\nsearchTerms}\ny{\noutputEncoding?}\nb\" ) ;\n TemplateURL url ( data ) ;\n EXPECT_TRUE ( url . url_ref ( ) . IsValid ( search_terms_data_ ) ) ;\n ASSERT_TRUE ( url . url_ref ( ) . SupportsReplacement ( search_terms_data_ ) ) ;\n GURL result ( url . url_ref ( ) . ReplaceSearchTerms ( TemplateURLRef : : SearchTermsArgs ( ASCIIToUTF16 ( \"X\" ) ) , search_terms_data_ ) ) ;\n ASSERT_TRUE ( result . is_valid ( ) ) ;\n EXPECT_EQ ( \"http://fooxutf-8axyb/\" , result . spec ( ) ) ;\n }",
        "output": "0",
        "idx": 3132
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PyObject * string_ljust ( PyStringObject * self , PyObject * args ) {\n Py_ssize_t width ;\n char fillchar = ' ' ;\n if ( ! PyArg_ParseTuple ( args , \"n|c:ljust\" , & width , & fillchar ) ) return NULL ;\n if ( PyString_GET_SIZE ( self ) >= width && PyString_CheckExact ( self ) ) {\n Py_INCREF ( self ) ;\n return ( PyObject * ) self ;\n }\n return pad ( self , 0 , width - PyString_GET_SIZE ( self ) , fillchar ) ;\n }",
        "output": "0",
        "idx": 4473
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int selinux_skb_peerlbl_sid ( struct sk_buff * skb , u16 family , u32 * sid ) {\n int err ;\n u32 xfrm_sid ;\n u32 nlbl_sid ;\n u32 nlbl_type ;\n err = selinux_xfrm_skb_sid ( skb , & xfrm_sid ) ;\n if ( unlikely ( err ) ) return - EACCES ;\n err = selinux_netlbl_skbuff_getsid ( skb , family , & nlbl_type , & nlbl_sid ) ;\n if ( unlikely ( err ) ) return - EACCES ;\n err = security_net_peersid_resolve ( nlbl_sid , nlbl_type , xfrm_sid , sid ) ;\n if ( unlikely ( err ) ) {\n printk ( KERN_WARNING \"SELinux: failure in selinux_skb_peerlbl_sid(),\" \" unable to determine packet's peer label\\n\" ) ;\n return - EACCES ;\n }\n return 0 ;\n }",
        "output": "0",
        "idx": 1491
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool e1000e_ring_empty ( E1000ECore * core , const E1000E_RingInfo * r ) {\n return core -> mac [ r -> dh ] == core -> mac [ r -> dt ] ;\n }",
        "output": "1",
        "idx": 1127
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _UTF32Open ( UConverter * cnv , UConverterLoadArgs * pArgs , UErrorCode * pErrorCode ) {\n _UTF32Reset ( cnv , UCNV_RESET_BOTH ) ;\n }",
        "output": "1",
        "idx": 1512
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_init_second_pass_spatial_svc ( VP9_COMP * cpi ) {\n SVC * const svc = & cpi -> svc ;\n int i ;\n for ( i = 0 ;\n i < svc -> number_spatial_layers ;\n ++ i ) {\n TWO_PASS * const twopass = & svc -> layer_context [ i ] . twopass ;\n svc -> spatial_layer_id = i ;\n vp9_init_second_pass ( cpi ) ;\n twopass -> total_stats . spatial_layer_id = i ;\n twopass -> total_left_stats . spatial_layer_id = i ;\n }\n svc -> spatial_layer_id = 0 ;\n }",
        "output": "0",
        "idx": 872
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static UConverter * _HZ_SafeClone ( const UConverter * cnv , void * stackBuffer , int32_t * pBufferSize , UErrorCode * status ) {\n struct cloneHZStruct * localClone ;\n int32_t size , bufferSizeNeeded = sizeof ( struct cloneHZStruct ) ;\n if ( U_FAILURE ( * status ) ) {\n return 0 ;\n }\n if ( * pBufferSize == 0 ) {\n * pBufferSize = bufferSizeNeeded ;\n return 0 ;\n }\n localClone = ( struct cloneHZStruct * ) stackBuffer ;\n uprv_memcpy ( & localClone -> mydata , cnv -> extraInfo , sizeof ( UConverterDataHZ ) ) ;\n localClone -> cnv . extraInfo = & localClone -> mydata ;\n localClone -> cnv . isExtraLocal = TRUE ;\n size = ( int32_t ) ( sizeof ( UConverter ) + sizeof ( UAlignedMemory ) ) ;\n ( ( UConverterDataHZ * ) localClone -> cnv . extraInfo ) -> gbConverter = ucnv_safeClone ( ( ( UConverterDataHZ * ) cnv -> extraInfo ) -> gbConverter , & localClone -> subCnv , & size , status ) ;\n return & localClone -> cnv ;\n }",
        "output": "1",
        "idx": 2183
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cancel_file_info_for_file ( NautilusDirectory * directory , NautilusFile * file ) {\n if ( directory -> details -> get_info_file == file ) {\n file_info_cancel ( directory ) ;\n }\n }",
        "output": "0",
        "idx": 3965
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nlm_register_unmatched_res ( packet_info * pinfo , tvbuff_t * tvb , int offset ) {\n nlm_msg_res_unmatched_data umd ;\n nlm_msg_res_unmatched_data * old_umd ;\n umd . cookie_len = tvb_get_ntohl ( tvb , offset ) ;\n umd . cookie = tvb_get_ptr ( tvb , offset + 4 , - 1 ) ;\n old_umd = ( nlm_msg_res_unmatched_data * ) g_hash_table_lookup ( nlm_msg_res_unmatched , ( gconstpointer ) & umd ) ;\n if ( old_umd ) {\n nlm_msg_res_matched_data * md ;\n md = ( nlm_msg_res_matched_data * ) g_malloc ( sizeof ( nlm_msg_res_matched_data ) ) ;\n md -> req_frame = old_umd -> req_frame ;\n md -> rep_frame = pinfo -> fd -> num ;\n md -> ns = old_umd -> ns ;\n g_hash_table_insert ( nlm_msg_res_matched , GINT_TO_POINTER ( md -> req_frame ) , ( gpointer ) md ) ;\n g_hash_table_insert ( nlm_msg_res_matched , GINT_TO_POINTER ( md -> rep_frame ) , ( gpointer ) md ) ;\n g_hash_table_remove ( nlm_msg_res_unmatched , ( gconstpointer ) old_umd ) ;\n g_free ( ( gpointer ) old_umd -> cookie ) ;\n g_free ( old_umd ) ;\n }\n }",
        "output": "1",
        "idx": 917
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sig_message_public ( SERVER_REC * server , const char * msg , const char * nick , const char * address , const char * target ) {\n CHANNEL_REC * channel ;\n int own ;\n channel = channel_find ( server , target ) ;\n if ( channel != NULL ) {\n own = nick_match_msg ( channel , msg , server -> nick ) ;\n CHANNEL_LAST_MSG_ADD ( channel , nick , own ) ;\n }\n }",
        "output": "1",
        "idx": 611
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __inline__ __u32 __fswab32 ( __u32 val ) {\n # if defined ( __arch_swab32 ) return __arch_swab32 ( val ) ;\n # else return ___constant_swab32 ( val ) ;\n # endif }",
        "output": "1",
        "idx": 3483
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline uint16_t be16_to_cpu ( uint16_t v ) {\n return bswap16 ( v ) ;\n }",
        "output": "0",
        "idx": 2683
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * formboundary ( struct SessionHandle * data ) {\n return aprintf ( \"------------------------%08x%08x\" , Curl_rand ( data ) , Curl_rand ( data ) ) ;\n }",
        "output": "0",
        "idx": 2284
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tipc_nl_compat_media_set ( struct sk_buff * skb , struct tipc_nl_compat_msg * msg ) {\n struct nlattr * prop ;\n struct nlattr * media ;\n struct tipc_link_config * lc ;\n lc = ( struct tipc_link_config * ) TLV_DATA ( msg -> req ) ;\n media = nla_nest_start ( skb , TIPC_NLA_MEDIA ) ;\n if ( ! media ) return - EMSGSIZE ;\n if ( nla_put_string ( skb , TIPC_NLA_MEDIA_NAME , lc -> name ) ) return - EMSGSIZE ;\n prop = nla_nest_start ( skb , TIPC_NLA_MEDIA_PROP ) ;\n if ( ! prop ) return - EMSGSIZE ;\n __tipc_add_link_prop ( skb , msg , lc ) ;\n nla_nest_end ( skb , prop ) ;\n nla_nest_end ( skb , media ) ;\n return 0 ;\n }",
        "output": "0",
        "idx": 321
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void curl_free ( void * p ) {\n free ( p ) ;\n }",
        "output": "0",
        "idx": 3533
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlListPtr xmlListCreate ( xmlListDeallocator deallocator , xmlListDataCompare compare ) {\n xmlListPtr l ;\n if ( NULL == ( l = ( xmlListPtr ) xmlMalloc ( sizeof ( xmlList ) ) ) ) {\n xmlGenericError ( xmlGenericErrorContext , \"Cannot initialize memory for list\" ) ;\n return ( NULL ) ;\n }\n memset ( l , 0 , sizeof ( xmlList ) ) ;\n if ( NULL == ( l -> sentinel = ( xmlLinkPtr ) xmlMalloc ( sizeof ( xmlLink ) ) ) ) {\n xmlGenericError ( xmlGenericErrorContext , \"Cannot initialize memory for sentinel\" ) ;\n xmlFree ( l ) ;\n return ( NULL ) ;\n }\n l -> sentinel -> next = l -> sentinel ;\n l -> sentinel -> prev = l -> sentinel ;\n l -> sentinel -> data = NULL ;\n if ( deallocator != NULL ) l -> linkDeallocator = deallocator ;\n if ( compare != NULL ) l -> linkCompare = compare ;\n else l -> linkCompare = xmlLinkCompare ;\n return l ;\n }",
        "output": "1",
        "idx": 1940
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_date_ts ( ) {\n int rc ;\n myheader ( \"test_date_ts\" ) ;\n rc = mysql_query ( mysql , \"DROP TABLE IF EXISTS test_date\" ) ;\n myquery ( rc ) ;\n rc = mysql_query ( mysql , \"CREATE TABLE test_date(c1 TIMESTAMP, \\ c2 TIMESTAMP, \\ c3 TIMESTAMP, \\ c4 TIMESTAMP)\" ) ;\n myquery ( rc ) ;\n bind_date_conv ( 2 , FALSE ) ;\n }",
        "output": "0",
        "idx": 532
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void Type_LUTB2A_Free ( struct _cms_typehandler_struct * self , void * Ptr ) {\n cmsPipelineFree ( ( cmsPipeline * ) Ptr ) ;\n return ;\n cmsUNUSED_PARAMETER ( self ) ;\n }",
        "output": "0",
        "idx": 3496
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_T_tunnelledSignallingMessage ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 756 \"./asn1/h225/h225.cnf\" tp_handle = NULL ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_T_tunnelledSignallingMessage , T_tunnelledSignallingMessage_sequence ) ;\n return offset ;\n }",
        "output": "1",
        "idx": 1909
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern rtype gnu_dev_ ## name proto __THROW __attribute_const__ ;\n # define __SYSMACROS_IMPL_TEMPL ( rtype , name , proto ) __extension__ __extern_inline __attribute_const__ rtype __NTH ( gnu_dev_ ## name proto ) __BEGIN_DECLS __SYSMACROS_DECLARE_MAJOR ( __SYSMACROS_DECL_TEMPL )",
        "output": "1",
        "idx": 1947
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void initial_reordering_broken_cluster ( const hb_ot_shape_plan_t * plan , hb_face_t * face , hb_buffer_t * buffer , unsigned int start , unsigned int end ) {\n initial_reordering_standalone_cluster ( plan , face , buffer , start , end ) ;\n }",
        "output": "1",
        "idx": 2353
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline uint32_t be32_to_cpu ( uint32_t v ) {\n return bswap32 ( v ) ;\n }",
        "output": "0",
        "idx": 1643
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( BookmarkBubbleSignInDelegateTest , BrowserRemoved ) {\n Browser * extra_browser = CreateBrowser ( profile ( ) ) ;\n ReplaceBlank ( extra_browser ) ;\n int starting_tab_count = extra_browser -> tab_strip_model ( ) -> count ( ) ;\n scoped_ptr < BookmarkBubbleDelegate > delegate ;\n delegate . reset ( new BookmarkBubbleSignInDelegate ( browser ( ) ) ) ;\n BrowserList : : SetLastActive ( extra_browser ) ;\n browser ( ) -> tab_strip_model ( ) -> CloseAllTabs ( ) ;\n content : : RunAllPendingInMessageLoop ( ) ;\n delegate -> OnSignInLinkClicked ( ) ;\n int tab_count = extra_browser -> tab_strip_model ( ) -> count ( ) ;\n EXPECT_EQ ( starting_tab_count + 1 , tab_count ) ;\n }",
        "output": "1",
        "idx": 1982
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void virLogSourceUpdate ( virLogSourcePtr source ) {\n virLogLock ( ) ;\n if ( source -> serial < virLogFiltersSerial ) {\n unsigned int priority = virLogDefaultPriority ;\n unsigned int flags = 0 ;\n size_t i ;\n for ( i = 0 ;\n i < virLogNbFilters ;\n i ++ ) {\n if ( strstr ( source -> name , virLogFilters [ i ] -> match ) ) {\n priority = virLogFilters [ i ] -> priority ;\n flags = virLogFilters [ i ] -> flags ;\n break ;\n }\n }\n source -> priority = priority ;\n source -> flags = flags ;\n source -> serial = virLogFiltersSerial ;\n }\n virLogUnlock ( ) ;\n }",
        "output": "0",
        "idx": 1376
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void evsignal_cb ( int fd , short what , void * arg ) {\n static char signals [ 1 ] ;\n # ifdef WIN32 SSIZE_T n ;\n # else ssize_t n ;\n # endif n = recv ( fd , signals , sizeof ( signals ) , 0 ) ;\n if ( n == - 1 ) event_err ( 1 , \"%s: read\" , __func__ ) ;\n }",
        "output": "1",
        "idx": 4015
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mark_object ( struct object * obj , const struct name_path * path , const char * name , void * data ) {\n update_progress ( data ) ;\n }",
        "output": "1",
        "idx": 4354
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlLinkPtr xmlListFront ( xmlListPtr l ) {\n if ( l == NULL ) return ( NULL ) ;\n return ( l -> sentinel -> next ) ;\n }",
        "output": "1",
        "idx": 4303
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , BackgroundThenForeground_Http ) {\n StartHttpServer ( ) ;\n base : : TimeDelta upper_bound = NavigateInBackgroundAndCloseInForegroundWithTiming ( http_test_server_ -> GetURL ( \"/simple.html\" ) ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 1 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;\n int32_t bucket_min = histogram_tester_ . GetAllSamples ( internal : : kHttpEngagementHistogram ) [ 0 ] . min ;\n EXPECT_GE ( upper_bound . InMilliseconds ( ) , bucket_min ) ;\n EXPECT_LT ( 0 , bucket_min ) ;\n }",
        "output": "1",
        "idx": 3151
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vpx_svc_set_keyframe ( SvcContext * svc_ctx ) {\n SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n if ( svc_ctx == NULL || si == NULL ) return ;\n si -> frame_within_gop = 0 ;\n }",
        "output": "1",
        "idx": 3357
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_init_me_luts ( ) {\n int i ;\n for ( i = 0 ;\n i < QINDEX_RANGE ;\n ++ i ) {\n const double q = vp9_convert_qindex_to_q ( i ) ;\n sad_per_bit16lut [ i ] = ( int ) ( 0.0418 * q + 2.4107 ) ;\n sad_per_bit4lut [ i ] = ( int ) ( 0.063 * q + 2.742 ) ;\n }\n }",
        "output": "1",
        "idx": 4453
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void s_aos_reset ( stream * s ) {\n s -> position = 0 ;\n s -> srptr = s -> srlimit = s -> cbuf - 1 ;\n s -> end_status = 0 ;\n }",
        "output": "0",
        "idx": 2999
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dissect_rsvp_hello ( proto_tree * ti , proto_tree * rsvp_object_tree , tvbuff_t * tvb , int offset , int obj_length _U_ , int rsvp_class _U_ , int type ) {\n switch ( type ) {\n case 1 : case 2 : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , tvb_get_guint8 ( tvb , offset + 3 ) , \"%d - HELLO %s object\" , tvb_get_guint8 ( tvb , offset + 3 ) , type == 1 ? \"REQUEST\" : \"ACK\" ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_hello_source_instance , tvb , offset + 4 , 4 , ENC_BIG_ENDIAN ) ;\n proto_tree_add_item ( rsvp_object_tree , hf_rsvp_hello_destination_instance , tvb , offset + 8 , 4 , ENC_BIG_ENDIAN ) ;\n proto_item_append_text ( ti , \": %s. Src Instance: 0x%0x. Dest Instance: 0x%0x. \" , type == 1 ? \"REQUEST\" : \"ACK\" , tvb_get_ntohl ( tvb , offset + 4 ) , tvb_get_ntohl ( tvb , offset + 8 ) ) ;\n break ;\n default : proto_tree_add_uint_format_value ( rsvp_object_tree , hf_rsvp_ctype , tvb , offset + 3 , 1 , type , \"%d - UNKNOWN\" , type ) ;\n break ;\n }\n ;\n }",
        "output": "0",
        "idx": 69
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ProcessArchiveRestoreOptions ( Archive * AHX ) {\n ArchiveHandle * AH = ( ArchiveHandle * ) AHX ;\n RestoreOptions * ropt = AH -> public . ropt ;\n TocEntry * te ;\n teSection curSection ;\n curSection = SECTION_PRE_DATA ;\n for ( te = AH -> toc -> next ;\n te != AH -> toc ;\n te = te -> next ) {\n if ( AH -> mode != archModeRead ) {\n switch ( te -> section ) {\n case SECTION_NONE : break ;\n case SECTION_PRE_DATA : if ( curSection != SECTION_PRE_DATA ) write_msg ( modulename , \"WARNING: archive items not in correct section order\\n\" ) ;\n break ;\n case SECTION_DATA : if ( curSection == SECTION_POST_DATA ) write_msg ( modulename , \"WARNING: archive items not in correct section order\\n\" ) ;\n break ;\n case SECTION_POST_DATA : break ;\n default : exit_horribly ( modulename , \"unexpected section code %d\\n\" , ( int ) te -> section ) ;\n break ;\n }\n }\n if ( te -> section != SECTION_NONE ) curSection = te -> section ;\n te -> reqs = _tocEntryRequired ( te , curSection , ropt ) ;\n }\n if ( ropt -> strict_names ) StrictNamesCheck ( ropt ) ;\n }",
        "output": "0",
        "idx": 347
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cpu_request_exit ( void * opaque , int irq , int level ) {\n CPUPPCState * env = cpu_single_env ;\n if ( env && level ) {\n cpu_exit ( CPU ( ppc_env_get_cpu ( env ) ) ) ;\n }\n }",
        "output": "1",
        "idx": 2970
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;\n __exctype_l ( isalpha_l ) ;\n __exctype_l ( iscntrl_l ) ;\n __exctype_l ( isdigit_l ) ;\n __exctype_l ( islower_l ) ;\n __exctype_l ( isgraph_l )",
        "output": "1",
        "idx": 4082
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int libgsm_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n int i , ret ;\n LibGSMDecodeContext * s = avctx -> priv_data ;\n AVFrame * frame = data ;\n uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n int16_t * samples ;\n if ( buf_size < avctx -> block_align ) {\n av_log ( avctx , AV_LOG_ERROR , \"Packet is too small\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n frame -> nb_samples = avctx -> frame_size ;\n if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n samples = ( int16_t * ) frame -> data [ 0 ] ;\n for ( i = 0 ;\n i < avctx -> frame_size / GSM_FRAME_SIZE ;\n i ++ ) {\n if ( ( ret = gsm_decode ( s -> state , buf , samples ) ) < 0 ) return - 1 ;\n buf += GSM_BLOCK_SIZE ;\n samples += GSM_FRAME_SIZE ;\n }\n * got_frame_ptr = 1 ;\n return avctx -> block_align ;\n }",
        "output": "0",
        "idx": 3403
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , SameOrigin_Https ) {\n StartHttpsServer ( false ) ;\n NavigateTwiceInTabAndClose ( https_test_server_ -> GetURL ( \"/simple.html\" ) , https_test_server_ -> GetURL ( \"/empty.html\" ) ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 0 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 2 ) ;\n }",
        "output": "1",
        "idx": 3752
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( FilesystemIterator , key ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n if ( SPL_FILE_DIR_KEY ( intern , SPL_FILE_DIR_KEY_AS_FILENAME ) ) {\n RETURN_STRING ( intern -> u . dir . entry . d_name , 1 ) ;\n }\n else {\n spl_filesystem_object_get_file_name ( intern TSRMLS_CC ) ;\n RETURN_STRINGL ( intern -> file_name , intern -> file_name_len , 1 ) ;\n }\n }",
        "output": "1",
        "idx": 3992
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void duplicate_mode_info_in_sb ( VP9_COMMON * cm , MACROBLOCKD * xd , int mi_row , int mi_col , BLOCK_SIZE bsize ) {\n const int block_width = num_8x8_blocks_wide_lookup [ bsize ] ;\n const int block_height = num_8x8_blocks_high_lookup [ bsize ] ;\n int i , j ;\n for ( j = 0 ;\n j < block_height ;\n ++ j ) for ( i = 0 ;\n i < block_width ;\n ++ i ) {\n if ( mi_row + j < cm -> mi_rows && mi_col + i < cm -> mi_cols ) xd -> mi [ j * xd -> mi_stride + i ] = xd -> mi [ 0 ] ;\n }\n }",
        "output": "1",
        "idx": 1488
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t pointerTOCEntryCount ( const UDataMemory * pData ) {\n const PointerTOC * toc = ( PointerTOC * ) pData -> toc ;\n return ( uint32_t ) ( ( toc != NULL ) ? ( toc -> count ) : 0 ) ;\n }",
        "output": "1",
        "idx": 1063
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemuMonitorJSONAddPCINetwork ( qemuMonitorPtr mon ATTRIBUTE_UNUSED , const char * nicstr ATTRIBUTE_UNUSED , virDomainDevicePCIAddress * guestAddr ATTRIBUTE_UNUSED ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"pci_add not suppported in JSON mode\" ) ) ;\n return - 1 ;\n }",
        "output": "0",
        "idx": 1453
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sbr_turnoff ( SpectralBandReplication * sbr ) {\n sbr -> start = 0 ;\n sbr -> kx [ 1 ] = 32 ;\n sbr -> m [ 1 ] = 0 ;\n sbr -> data [ 0 ] . e_a [ 1 ] = sbr -> data [ 1 ] . e_a [ 1 ] = - 1 ;\n memset ( & sbr -> spectrum_params , - 1 , sizeof ( SpectrumParameters ) ) ;\n }",
        "output": "1",
        "idx": 545
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void evhttp_send_reply_end ( struct evhttp_request * req ) {\n struct evhttp_connection * evcon = req -> evcon ;\n if ( req -> chunked ) {\n evbuffer_add ( req -> evcon -> output_buffer , \"0\\r\\n\\r\\n\" , 5 ) ;\n evhttp_write_buffer ( req -> evcon , evhttp_send_done , NULL ) ;\n req -> chunked = 0 ;\n }\n else if ( ! event_pending ( & evcon -> ev , EV_WRITE | EV_TIMEOUT , NULL ) ) {\n evhttp_send_done ( evcon , NULL ) ;\n }\n else {\n evcon -> cb = evhttp_send_done ;\n evcon -> cb_arg = NULL ;\n }\n }",
        "output": "1",
        "idx": 1366
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void decode_flush ( AVCodecContext * avctx ) {\n KgvContext * const c = avctx -> priv_data ;\n if ( c -> prev . data [ 0 ] ) avctx -> release_buffer ( avctx , & c -> prev ) ;\n }",
        "output": "1",
        "idx": 2692
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _UTF32Reset ( UConverter * cnv , UConverterResetChoice choice ) {\n if ( choice <= UCNV_RESET_TO_UNICODE ) {\n cnv -> mode = 0 ;\n }\n if ( choice != UCNV_RESET_TO_UNICODE ) {\n cnv -> fromUnicodeStatus = UCNV_NEED_TO_WRITE_BOM ;\n }\n }",
        "output": "1",
        "idx": 1103
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void show_object ( struct object * object , const struct name_path * path , const char * last , void * data ) {\n struct bitmap * base = data ;\n bitmap_set ( base , find_object_pos ( object -> oid . hash ) ) ;\n mark_as_seen ( object ) ;\n }",
        "output": "1",
        "idx": 1166
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void copy ( LZOContext * c , int cnt ) {\n register const uint8_t * src = c -> in ;\n register uint8_t * dst = c -> out ;\n if ( cnt > c -> in_end - src ) {\n cnt = FFMAX ( c -> in_end - src , 0 ) ;\n c -> error |= AV_LZO_INPUT_DEPLETED ;\n }\n if ( cnt > c -> out_end - dst ) {\n cnt = FFMAX ( c -> out_end - dst , 0 ) ;\n c -> error |= AV_LZO_OUTPUT_FULL ;\n }\n # if defined ( INBUF_PADDED ) && defined ( OUTBUF_PADDED ) AV_COPY32U ( dst , src ) ;\n src += 4 ;\n dst += 4 ;\n cnt -= 4 ;\n if ( cnt > 0 ) # endif memcpy ( dst , src , cnt ) ;\n c -> in = src + cnt ;\n c -> out = dst + cnt ;\n }",
        "output": "1",
        "idx": 557
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dissect_llmnr_udp ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree ) {\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"LLMNR\" ) ;\n dissect_dns_common ( tvb , pinfo , tree , FALSE , FALSE , TRUE ) ;\n }",
        "output": "0",
        "idx": 3718
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void ipv6_addr_prefix ( struct in6_addr * pfx , const struct in6_addr * addr , int plen ) {\n int o = plen >> 3 , b = plen & 0x7 ;\n memset ( pfx -> s6_addr , 0 , sizeof ( pfx -> s6_addr ) ) ;\n memcpy ( pfx -> s6_addr , addr , o ) ;\n if ( b != 0 ) pfx -> s6_addr [ o ] = addr -> s6_addr [ o ] & ( 0xff00 >> b ) ;\n }",
        "output": "0",
        "idx": 1101
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_Information_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 399 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_Information_UUIE , Information_UUIE_sequence ) ;\n # line 403 \"./asn1/h225/h225.cnf\" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> cs_type = H225_INFORMATION ;\n g_snprintf ( h225_pi -> frame_label , 50 , \"%s\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) ) ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 657
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mbfl_strwidth ( mbfl_string * string ) {\n int len , n ;\n unsigned char * p ;\n mbfl_convert_filter * filter ;\n len = 0 ;\n if ( string -> len > 0 && string -> val != NULL ) {\n filter = mbfl_convert_filter_new ( string -> no_encoding , mbfl_no_encoding_wchar , filter_count_width , 0 , & len ) ;\n if ( filter == NULL ) {\n mbfl_convert_filter_delete ( filter ) ;\n return - 1 ;\n }\n p = string -> val ;\n n = string -> len ;\n while ( n > 0 ) {\n ( * filter -> filter_function ) ( * p ++ , filter ) ;\n n -- ;\n }\n mbfl_convert_filter_flush ( filter ) ;\n mbfl_convert_filter_delete ( filter ) ;\n }\n return len ;\n }",
        "output": "0",
        "idx": 2506
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , ClosedWhileHidden_Https ) {\n StartHttpsServer ( false ) ;\n base : : TimeDelta upper_bound = NavigateInForegroundAndCloseInBackgroundWithTiming ( https_test_server_ -> GetURL ( \"/simple.html\" ) ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 0 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 1 ) ;\n int32_t bucket_min = histogram_tester_ . GetAllSamples ( internal : : kHttpsEngagementHistogram ) [ 0 ] . min ;\n EXPECT_GE ( upper_bound . InMilliseconds ( ) , bucket_min ) ;\n EXPECT_LT ( 0 , bucket_min ) ;\n }",
        "output": "1",
        "idx": 2827
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vga_draw_line24_be ( VGACommonState * s1 , uint8_t * d , const uint8_t * s , int width ) {\n int w ;\n uint32_t r , g , b ;\n w = width ;\n do {\n r = s [ 0 ] ;\n g = s [ 1 ] ;\n b = s [ 2 ] ;\n ( ( uint32_t * ) d ) [ 0 ] = rgb_to_pixel32 ( r , g , b ) ;\n s += 3 ;\n d += 4 ;\n }\n while ( -- w != 0 ) ;\n }",
        "output": "1",
        "idx": 2403
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dtls1_stop_timer ( SSL * s ) {\n memset ( & s -> d1 -> timeout , 0 , sizeof ( s -> d1 -> timeout ) ) ;\n memset ( & s -> d1 -> next_timeout , 0 , sizeof ( s -> d1 -> next_timeout ) ) ;\n s -> d1 -> timeout_duration = 1 ;\n BIO_ctrl ( SSL_get_rbio ( s ) , BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT , 0 , & ( s -> d1 -> next_timeout ) ) ;\n dtls1_clear_record_buffer ( s ) ;\n }",
        "output": "1",
        "idx": 1766
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void jpc_pi_destroy ( jpc_pi_t * pi ) {\n jpc_picomp_t * picomp ;\n int compno ;\n if ( pi -> picomps ) {\n for ( compno = 0 , picomp = pi -> picomps ;\n compno < pi -> numcomps ;\n ++ compno , ++ picomp ) {\n jpc_picomp_destroy ( picomp ) ;\n }\n jas_free ( pi -> picomps ) ;\n }\n if ( pi -> pchglist ) {\n jpc_pchglist_destroy ( pi -> pchglist ) ;\n }\n jas_free ( pi ) ;\n }",
        "output": "0",
        "idx": 4257
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int build_def_list ( Picture * def , Picture * * in , int len , int is_long , int sel ) {\n int i [ 2 ] = {\n 0 }\n ;\n int index = 0 ;\n while ( i [ 0 ] < len || i [ 1 ] < len ) {\n while ( i [ 0 ] < len && ! ( in [ i [ 0 ] ] && ( in [ i [ 0 ] ] -> f . reference & sel ) ) ) i [ 0 ] ++ ;\n while ( i [ 1 ] < len && ! ( in [ i [ 1 ] ] && ( in [ i [ 1 ] ] -> f . reference & ( sel ^ 3 ) ) ) ) i [ 1 ] ++ ;\n if ( i [ 0 ] < len ) {\n in [ i [ 0 ] ] -> pic_id = is_long ? i [ 0 ] : in [ i [ 0 ] ] -> frame_num ;\n split_field_copy ( & def [ index ++ ] , in [ i [ 0 ] ++ ] , sel , 1 ) ;\n }\n if ( i [ 1 ] < len ) {\n in [ i [ 1 ] ] -> pic_id = is_long ? i [ 1 ] : in [ i [ 1 ] ] -> frame_num ;\n split_field_copy ( & def [ index ++ ] , in [ i [ 1 ] ++ ] , sel ^ 3 , 0 ) ;\n }\n }\n return index ;\n }",
        "output": "1",
        "idx": 2040
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , MAYBE_AbortClose ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n GURL url ( embedded_test_server ( ) -> GetURL ( \"/title1.html\" ) ) ;\n NavigateParams params ( browser ( ) , url , ui : : PAGE_TRANSITION_LINK ) ;\n content : : TestNavigationManager manager ( browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) , url ) ;\n Navigate ( & params ) ;\n EXPECT_TRUE ( manager . WaitForRequestStart ( ) ) ;\n browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) -> Close ( ) ;\n manager . WaitForNavigationFinished ( ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHistogramAbortCloseBeforeCommit , 1 ) ;\n }",
        "output": "0",
        "idx": 2127
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void compress_job_on_error ( AutoarCompressor * compressor , GError * error , gpointer user_data ) {\n CompressJob * compress_job = user_data ;\n char * status ;\n if ( compress_job -> total_files == 1 ) {\n status = f ( _ ( \"Error compressing \u201c%B\u201d into \u201c%B\u201d\" ) , G_FILE ( compress_job -> source_files -> data ) , compress_job -> output_file ) ;\n }\n else {\n status = f ( ngettext ( \"Error compressing %'d file into \u201c%B\u201d\" , \"Error compressing %'d files into \u201c%B\u201d\" , compress_job -> total_files ) , compress_job -> total_files , compress_job -> output_file ) ;\n }\n nautilus_progress_info_take_status ( compress_job -> common . progress , status ) ;\n run_error ( ( CommonJob * ) compress_job , g_strdup ( _ ( \"There was an error while compressing files.\" ) ) , g_strdup ( error -> message ) , NULL , FALSE , CANCEL , NULL ) ;\n abort_job ( ( CommonJob * ) compress_job ) ;\n }",
        "output": "0",
        "idx": 1923
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "byte * _gcry_mpi_get_secure_buffer ( gcry_mpi_t a , unsigned * nbytes , int * sign ) {\n return do_get_buffer ( a , nbytes , sign , 1 ) ;\n }",
        "output": "1",
        "idx": 1475
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void initial_reordering_broken_cluster ( const hb_ot_shape_plan_t * plan , hb_face_t * face , hb_buffer_t * buffer , unsigned int start , unsigned int end ) {\n initial_reordering_consonant_syllable ( plan , face , buffer , start , end ) ;\n }",
        "output": "1",
        "idx": 2508
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void parseArrayComplex ( proto_tree * tree , tvbuff_t * tvb , packet_info * pinfo , gint * pOffset , const char * szFieldName , const char * szTypeName , fctComplexTypeParser pParserFunction , const gint idx ) {\n proto_item * ti ;\n proto_tree * subtree = proto_tree_add_subtree_format ( tree , tvb , * pOffset , - 1 , idx , & ti , \"%s: Array of %s\" , szFieldName , szTypeName ) ;\n int i ;\n gint32 iLen ;\n iLen = tvb_get_letohl ( tvb , * pOffset ) ;\n proto_tree_add_item ( subtree , hf_opcua_ArraySize , tvb , * pOffset , 4 , ENC_LITTLE_ENDIAN ) ;\n if ( iLen > MAX_ARRAY_LEN ) {\n proto_tree_add_expert_format ( subtree , pinfo , & ei_array_length , tvb , * pOffset , 4 , \"Array length %d too large to process\" , iLen ) ;\n return ;\n }\n * pOffset += 4 ;\n for ( i = 0 ;\n i < iLen ;\n i ++ ) {\n char szNum [ 20 ] ;\n g_snprintf ( szNum , 20 , \"[%i]\" , i ) ;\n ( * pParserFunction ) ( subtree , tvb , pinfo , pOffset , szNum ) ;\n }\n proto_item_set_end ( ti , tvb , * pOffset ) ;\n }",
        "output": "0",
        "idx": 223
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( ProfileBrowserTest , URLFetcherUsingMainContextDuringIncognitoTeardown ) {\n Browser * incognito_browser = OpenURLOffTheRecord ( browser ( ) -> profile ( ) , GURL ( \"about:blank\" ) ) ;\n RunURLFetcherActiveDuringIncognitoTeardownTest ( incognito_browser , incognito_browser -> profile ( ) -> GetRequestContext ( ) ) ;\n }",
        "output": "1",
        "idx": 3993
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void language_destroy ( hb_language_t * l ) {\n free ( l ) ;\n }",
        "output": "1",
        "idx": 692
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PyObject * basestring_new ( PyTypeObject * type , PyObject * args , PyObject * kwds ) {\n PyErr_SetString ( PyExc_TypeError , \"The basestring type cannot be instantiated\" ) ;\n return NULL ;\n }",
        "output": "0",
        "idx": 926
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void e1000e_set_itr ( E1000ECore * core , int index , uint32_t val ) {\n uint32_t interval = val & 0xffff ;\n trace_e1000e_irq_itr_set ( val ) ;\n core -> itr_guest_value = interval ;\n core -> mac [ index ] = MAX ( interval , E1000E_MIN_XITR ) ;\n }",
        "output": "0",
        "idx": 1605
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline uint8_t vga_read_byte ( VGACommonState * vga , uint32_t addr ) {\n return vga -> vram_ptr [ addr & vga -> vbe_size_mask ] ;\n }",
        "output": "0",
        "idx": 1735
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * unescape_word ( struct Curl_easy * data , const char * inputbuff ) {\n char * newp ;\n char * dictp ;\n char * ptr ;\n int len ;\n char ch ;\n int olen = 0 ;\n newp = curl_easy_unescape ( data , inputbuff , 0 , & len ) ;\n if ( ! newp ) return NULL ;\n dictp = malloc ( ( ( size_t ) len ) * 2 + 1 ) ;\n if ( dictp ) {\n for ( ptr = newp ;\n ( ch = * ptr ) != 0 ;\n ptr ++ ) {\n if ( ( ch <= 32 ) || ( ch == 127 ) || ( ch == '\\'' ) || ( ch == '\\\"' ) || ( ch == '\\\\' ) ) {\n dictp [ olen ++ ] = '\\\\' ;\n }\n dictp [ olen ++ ] = ch ;\n }\n dictp [ olen ] = 0 ;\n }\n free ( newp ) ;\n return dictp ;\n }",
        "output": "1",
        "idx": 966
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void read_sbr_extension ( AACContext * ac , SpectralBandReplication * sbr , GetBitContext * gb , int bs_extension_id , int * num_bits_left ) {\n switch ( bs_extension_id ) {\n case EXTENSION_ID_PS : if ( ! ac -> oc [ 1 ] . m4ac . ps ) {\n av_log ( ac -> avctx , AV_LOG_ERROR , \"Parametric Stereo signaled to be not-present but was found in the bitstream.\\n\" ) ;\n skip_bits_long ( gb , * num_bits_left ) ;\n * num_bits_left = 0 ;\n }\n else {\n # if 1 * num_bits_left -= ff_ps_read_data ( ac -> avctx , gb , & sbr -> ps , * num_bits_left ) ;\n ac -> avctx -> profile = FF_PROFILE_AAC_HE_V2 ;\n # else avpriv_report_missing_feature ( ac -> avctx , \"Parametric Stereo\" ) ;\n skip_bits_long ( gb , * num_bits_left ) ;\n * num_bits_left = 0 ;\n # endif }\n break ;\n default : if ( bs_extension_id || * num_bits_left > 16 || show_bits ( gb , * num_bits_left ) ) avpriv_request_sample ( ac -> avctx , \"Reserved SBR extensions\" ) ;\n skip_bits_long ( gb , * num_bits_left ) ;\n * num_bits_left = 0 ;\n break ;\n }\n }",
        "output": "1",
        "idx": 3303
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void jbig2_set_bits ( byte * line , int x0 , int x1 ) {\n int a0 , a1 , b0 , b1 , a ;\n a0 = x0 >> 3 ;\n a1 = x1 >> 3 ;\n b0 = x0 & 7 ;\n b1 = x1 & 7 ;\n if ( a0 == a1 ) {\n line [ a0 ] |= lm [ b0 ] & rm [ b1 ] ;\n }\n else {\n line [ a0 ] |= lm [ b0 ] ;\n for ( a = a0 + 1 ;\n a < a1 ;\n a ++ ) line [ a ] = 0xFF ;\n if ( b1 ) line [ a1 ] |= rm [ b1 ] ;\n }\n }",
        "output": "1",
        "idx": 4245
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static StkId adjust_varargs ( lua_State * L , Proto * p , int actual ) {\n int i ;\n int nfixargs = p -> numparams ;\n Table * htab = NULL ;\n StkId base , fixed ;\n for ( ;\n actual < nfixargs ;\n ++ actual ) setnilvalue ( L -> top ++ ) ;\n # if defined ( LUA_COMPAT_VARARG ) if ( p -> is_vararg & VARARG_NEEDSARG ) {\n int nvar = actual - nfixargs ;\n lua_assert ( p -> is_vararg & VARARG_HASARG ) ;\n luaC_checkGC ( L ) ;\n luaD_checkstack ( L , p -> maxstacksize ) ;\n htab = luaH_new ( L , nvar , 1 ) ;\n for ( i = 0 ;\n i < nvar ;\n i ++ ) setobj2n ( L , luaH_setnum ( L , htab , i + 1 ) , L -> top - nvar + i ) ;\n setnvalue ( luaH_setstr ( L , htab , luaS_newliteral ( L , \"n\" ) ) , cast_num ( nvar ) ) ;\n }\n # endif fixed = L -> top - actual ;\n base = L -> top ;\n for ( i = 0 ;\n i < nfixargs ;\n i ++ ) {\n setobjs2s ( L , L -> top ++ , fixed + i ) ;\n setnilvalue ( fixed + i ) ;\n }\n if ( htab ) {\n sethvalue ( L , L -> top ++ , htab ) ;\n lua_assert ( iswhite ( obj2gco ( htab ) ) ) ;\n }\n return base ;\n }",
        "output": "0",
        "idx": 3310
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PyObject * checkPassword ( PyObject * self , PyObject * args ) {\n const char * user = NULL ;\n const char * pswd = NULL ;\n const char * service = NULL ;\n const char * default_realm = NULL ;\n int result = 0 ;\n if ( ! PyArg_ParseTuple ( args , \"ssss\" , & user , & pswd , & service , & default_realm ) ) return NULL ;\n result = authenticate_user_krb5pwd ( user , pswd , service , default_realm ) ;\n if ( result ) return Py_INCREF ( Py_True ) , Py_True ;\n else return NULL ;\n }",
        "output": "1",
        "idx": 1854
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void read_index ( AVIOContext * pb , AVStream * st ) {\n uint64_t timestamp = 0 ;\n int i ;\n for ( i = 0 ;\n i < st -> nb_frames ;\n i ++ ) {\n uint32_t pos = avio_rb32 ( pb ) ;\n uint32_t size = avio_rb32 ( pb ) ;\n avio_skip ( pb , 8 ) ;\n av_add_index_entry ( st , pos , timestamp , size , 0 , AVINDEX_KEYFRAME ) ;\n if ( st -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO ) {\n timestamp += size / ( st -> codecpar -> channels * 2 ) ;\n }\n else {\n timestamp ++ ;\n }\n }\n }",
        "output": "0",
        "idx": 3226
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void free_picture ( AVCodecContext * avctx , Picture * pic ) {\n int i ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n av_freep ( & pic -> motion_val_base [ i ] ) ;\n av_freep ( & pic -> f . ref_index [ i ] ) ;\n }\n av_freep ( & pic -> mb_type_base ) ;\n if ( pic -> f . data [ 0 ] ) avctx -> release_buffer ( avctx , & pic -> f ) ;\n av_freep ( & pic ) ;\n }",
        "output": "1",
        "idx": 3845
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _HZ_WriteSub ( UConverterFromUnicodeArgs * args , int32_t offsetIndex , UErrorCode * err ) {\n UConverter * cnv = args -> converter ;\n UConverterDataHZ * convData = ( UConverterDataHZ * ) cnv -> extraInfo ;\n char * p ;\n char buffer [ 4 ] ;\n p = buffer ;\n if ( convData -> isTargetUCharDBCS ) {\n * p ++ = UCNV_TILDE ;\n * p ++ = UCNV_CLOSE_BRACE ;\n convData -> isTargetUCharDBCS = FALSE ;\n }\n * p ++ = ( char ) cnv -> subChars [ 0 ] ;\n ucnv_cbFromUWriteBytes ( args , buffer , ( int32_t ) ( p - buffer ) , offsetIndex , err ) ;\n }",
        "output": "1",
        "idx": 2369
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ossl_inline void lh_ ## type ## _doall ( LHASH_OF ( type ) * lh , void ( * doall ) ( type * ) ) {\n OPENSSL_LH_doall ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNC ) doall ) ;\n }\n LHASH_OF ( type ) # define IMPLEMENT_LHASH_DOALL_ARG_CONST ( type , argtype ) int_implement_lhash_doall ( type , argtype , const type ) # define IMPLEMENT_LHASH_DOALL_ARG ( type , argtype ) int_implement_lhash_doall ( type , argtype , type ) # define int_implement_lhash_doall ( type , argtype , cbargtype ) static ossl_inline void lh_ ## type ## _doall_ ## argtype ( LHASH_OF ( type ) * lh , void ( * fn ) ( cbargtype * , argtype * ) , argtype * arg ) {\n OPENSSL_LH_doall_arg ( ( OPENSSL_LHASH * ) lh , ( OPENSSL_LH_DOALL_FUNCARG ) fn , ( void * ) arg ) ;\n }\n LHASH_OF ( type ) DEFINE_LHASH_OF ( OPENSSL_STRING )",
        "output": "1",
        "idx": 4386
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;\n __exctype_l ( isalpha_l ) ;\n __exctype_l ( iscntrl_l ) ;\n __exctype_l ( isdigit_l ) ;\n __exctype_l ( islower_l ) ;\n __exctype_l ( isgraph_l ) ;\n __exctype_l ( isprint_l ) ;\n __exctype_l ( ispunct_l )",
        "output": "1",
        "idx": 4374
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void encode_block_pass1 ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) {\n MACROBLOCK * const x = ( MACROBLOCK * ) arg ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n struct macroblock_plane * const p = & x -> plane [ plane ] ;\n struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;\n int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;\n int i , j ;\n uint8_t * dst ;\n txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & i , & j ) ;\n dst = & pd -> dst . buf [ 4 * j * pd -> dst . stride + 4 * i ] ;\n vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ;\n if ( p -> eobs [ block ] > 0 ) x -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ;\n }",
        "output": "1",
        "idx": 1751
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int remoteStreamHandleFinish ( struct qemud_client * client , struct qemud_client_stream * stream , struct qemud_client_message * msg ) {\n remote_error rerr ;\n int ret ;\n VIR_DEBUG ( \"stream=%p proc=%d serial=%d\" , stream , msg -> hdr . proc , msg -> hdr . serial ) ;\n memset ( & rerr , 0 , sizeof rerr ) ;\n stream -> closed = 1 ;\n virStreamEventRemoveCallback ( stream -> st ) ;\n ret = virStreamFinish ( stream -> st ) ;\n if ( ret < 0 ) {\n remoteDispatchConnError ( & rerr , client -> conn ) ;\n return remoteSerializeReplyError ( client , & rerr , & msg -> hdr ) ;\n }\n else {\n if ( remoteSendStreamData ( client , stream , NULL , 0 ) < 0 ) return - 1 ;\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 564
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl ) ;\n __exctype ( isdigit ) ;\n __exctype ( islower ) ;\n __exctype ( isgraph ) ;\n __exctype ( isprint ) ;\n __exctype ( ispunct ) ;\n __exctype ( isspace ) ;\n __exctype ( isupper ) ;\n __exctype ( isxdigit ) ;\n extern int tolower ( int __c ) __THROW ;\n extern int toupper ( int __c ) __THROW ;\n # ifdef __USE_ISOC99 __exctype ( isblank ) ;\n # endif # ifdef __USE_GNU extern int isctype ( int __c , int __mask ) __THROW ;\n # endif # if defined __USE_MISC || defined __USE_XOPEN extern int isascii ( int __c ) __THROW ;\n extern int toascii ( int __c ) __THROW ;\n __exctype ( _toupper )",
        "output": "1",
        "idx": 819
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , MultipleUploads ) {\n StartHttpsServer ( false ) ;\n NavigateInForegroundAndCloseWithTiming ( https_test_server_ -> GetURL ( \"/\" ) ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementSessionPercentage , 0 ) ;\n FakeUserMetricsUpload ( ) ;\n FakeUserMetricsUpload ( ) ;\n FakeUserMetricsUpload ( ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementSessionPercentage , 1 ) ;\n }",
        "output": "0",
        "idx": 2204
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool is_one_of ( const hb_glyph_info_t & info , unsigned int flags ) {\n if ( _hb_glyph_info_ligated ( & info ) ) return false ;\n return ! ! ( FLAG ( info . indic_category ( ) ) & flags ) ;\n }",
        "output": "1",
        "idx": 540
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _UTF16Open ( UConverter * cnv , UConverterLoadArgs * pArgs , UErrorCode * pErrorCode ) {\n if ( UCNV_GET_VERSION ( cnv ) <= 2 ) {\n if ( UCNV_GET_VERSION ( cnv ) == 2 && ! pArgs -> onlyTestIsLoadable ) {\n cnv -> sharedData = ( UConverterSharedData * ) & _UTF16v2Data ;\n uprv_memcpy ( cnv -> subChars , _UTF16v2Data . staticData -> subChar , UCNV_MAX_SUBCHAR_LEN ) ;\n }\n _UTF16Reset ( cnv , UCNV_RESET_BOTH ) ;\n }\n else {\n * pErrorCode = U_ILLEGAL_ARGUMENT_ERROR ;\n }\n }",
        "output": "1",
        "idx": 4105
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void prplcb_close_request ( PurpleRequestType type , void * data ) {\n struct prplcb_request_action_data * pqad ;\n struct request_input_data * ri ;\n struct purple_data * pd ;\n if ( ! data ) {\n return ;\n }\n switch ( type ) {\n case PURPLE_REQUEST_ACTION : pqad = data ;\n if ( pqad -> bee_data ) {\n query_del ( local_bee -> ui_data , pqad -> bee_data ) ;\n }\n g_free ( pqad ) ;\n break ;\n case PURPLE_REQUEST_INPUT : ri = data ;\n pd = ri -> ic -> proto_data ;\n imcb_remove_buddy ( ri -> ic , ri -> buddy , NULL ) ;\n g_free ( ri -> buddy ) ;\n g_hash_table_remove ( pd -> input_requests , GUINT_TO_POINTER ( ri -> id ) ) ;\n break ;\n default : g_free ( data ) ;\n break ;\n }\n }",
        "output": "0",
        "idx": 2935
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_OCTET_STRING_SIZE_6 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , 6 , 6 , FALSE , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 1716
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int very_broken_op ( int a , int b ) {\n int x = a * b + 200 ;\n int size ;\n const uint8_t * rtab ;\n if ( x % 400 || b % 5 ) return x / 400 ;\n x /= 400 ;\n size = tabs [ b / 5 ] . size ;\n rtab = tabs [ b / 5 ] . tab ;\n return x - rtab [ size * av_log2 ( 2 * ( x - 1 ) / size ) + ( x - 1 ) % size ] ;\n }",
        "output": "0",
        "idx": 4173
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void data_destroy_arabic ( void * data ) {\n arabic_shape_plan_t * arabic_plan = ( arabic_shape_plan_t * ) data ;\n arabic_fallback_plan_destroy ( arabic_plan -> fallback_plan ) ;\n free ( data ) ;\n }",
        "output": "1",
        "idx": 4124
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_MaintenanceLoopAck ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_MaintenanceLoopAck , MaintenanceLoopAck_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 1446
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gchar get_priority ( const guint8 * priority ) {\n static gchar priorities [ ] = \"??VDIWEFS\" ;\n if ( * priority >= ( guint8 ) sizeof ( priorities ) ) return '?' ;\n return priorities [ ( int ) * priority ] ;\n }",
        "output": "1",
        "idx": 4417
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __inline__ int TLV_SET ( void * tlv , __u16 type , void * data , __u16 len ) {\n struct tlv_desc * tlv_ptr ;\n int tlv_len ;\n tlv_len = TLV_LENGTH ( len ) ;\n tlv_ptr = ( struct tlv_desc * ) tlv ;\n tlv_ptr -> tlv_type = htons ( type ) ;\n tlv_ptr -> tlv_len = htons ( tlv_len ) ;\n if ( len && data ) {\n memcpy ( TLV_DATA ( tlv_ptr ) , data , len ) ;\n memset ( TLV_DATA ( tlv_ptr ) + len , 0 , TLV_SPACE ( len ) - tlv_len ) ;\n }\n return TLV_SPACE ( len ) ;\n }",
        "output": "0",
        "idx": 4162
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_update_zbin_extra ( VP9_COMP * cpi , MACROBLOCK * x ) {\n const int qindex = x -> q_index ;\n const int y_zbin_extra = ( cpi -> common . y_dequant [ qindex ] [ 1 ] * cpi -> zbin_mode_boost ) >> 7 ;\n const int uv_zbin_extra = ( cpi -> common . uv_dequant [ qindex ] [ 1 ] * cpi -> zbin_mode_boost ) >> 7 ;\n x -> plane [ 0 ] . zbin_extra = ( int16_t ) y_zbin_extra ;\n x -> plane [ 1 ] . zbin_extra = ( int16_t ) uv_zbin_extra ;\n x -> plane [ 2 ] . zbin_extra = ( int16_t ) uv_zbin_extra ;\n }",
        "output": "0",
        "idx": 3272
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MB_MODE_INFO * set_offsets ( VP9_COMMON * const cm , MACROBLOCKD * const xd , const TileInfo * const tile , BLOCK_SIZE bsize , int mi_row , int mi_col ) {\n const int bw = num_8x8_blocks_wide_lookup [ bsize ] ;\n const int bh = num_8x8_blocks_high_lookup [ bsize ] ;\n const int x_mis = MIN ( bw , cm -> mi_cols - mi_col ) ;\n const int y_mis = MIN ( bh , cm -> mi_rows - mi_row ) ;\n const int offset = mi_row * cm -> mi_stride + mi_col ;\n int x , y ;\n xd -> mi = cm -> mi_grid_visible + offset ;\n xd -> mi [ 0 ] = & cm -> mi [ offset ] ;\n xd -> mi [ 0 ] -> mbmi . sb_type = bsize ;\n for ( y = 0 ;\n y < y_mis ;\n ++ y ) for ( x = ! y ;\n x < x_mis ;\n ++ x ) xd -> mi [ y * cm -> mi_stride + x ] = xd -> mi [ 0 ] ;\n set_skip_context ( xd , mi_row , mi_col ) ;\n set_mi_row_col ( xd , tile , mi_row , bh , mi_col , bw , cm -> mi_rows , cm -> mi_cols ) ;\n vp9_setup_dst_planes ( xd -> plane , get_frame_new_buffer ( cm ) , mi_row , mi_col ) ;\n return & xd -> mi [ 0 ] -> mbmi ;\n }",
        "output": "1",
        "idx": 1700
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int Curl_FormInit ( struct Form * form , struct FormData * formdata ) {\n if ( ! formdata ) return 1 ;\n form -> data = formdata ;\n form -> sent = 0 ;\n form -> fp = NULL ;\n form -> fread_func = ZERO_NULL ;\n return 0 ;\n }",
        "output": "0",
        "idx": 1462
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void s390_virtio_device_update_status ( VirtIOS390Device * dev ) {\n VirtIODevice * vdev = dev -> vdev ;\n uint32_t features ;\n vdev -> status = ldub_phys ( dev -> dev_offs + VIRTIO_DEV_OFFS_STATUS ) ;\n features = ldl_phys ( dev -> feat_offs ) ;\n if ( vdev -> set_features ) {\n vdev -> set_features ( vdev , features ) ;\n }\n vdev -> guest_features = features ;\n }",
        "output": "0",
        "idx": 3691
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void create_new_objects ( void ) {\n int dbnum ;\n prep_status ( \"Restoring database schemas in the new cluster\\n\" ) ;\n for ( dbnum = 0 ;\n dbnum < old_cluster . dbarr . ndbs ;\n dbnum ++ ) {\n char sql_file_name [ MAXPGPATH ] , log_file_name [ MAXPGPATH ] ;\n DbInfo * old_db = & old_cluster . dbarr . dbs [ dbnum ] ;\n pg_log ( PG_STATUS , \"%s\" , old_db -> db_name ) ;\n snprintf ( sql_file_name , sizeof ( sql_file_name ) , DB_DUMP_FILE_MASK , old_db -> db_oid ) ;\n snprintf ( log_file_name , sizeof ( log_file_name ) , DB_DUMP_LOG_FILE_MASK , old_db -> db_oid ) ;\n parallel_exec_prog ( log_file_name , NULL , \"\\\"%s/pg_restore\\\" %s --exit-on-error --verbose --dbname \\\"%s\\\" \\\"%s\\\"\" , new_cluster . bindir , cluster_conn_opts ( & new_cluster ) , old_db -> db_name , sql_file_name ) ;\n }\n while ( reap_child ( true ) == true ) ;\n end_progress_output ( ) ;\n check_ok ( ) ;\n if ( GET_MAJOR_VERSION ( old_cluster . major_version ) < 903 ) set_frozenxids ( true ) ;\n get_db_and_rel_infos ( & new_cluster ) ;\n }",
        "output": "1",
        "idx": 3324
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * memdup ( const char * src , size_t buffer_length ) {\n size_t length ;\n bool add = FALSE ;\n char * buffer ;\n if ( buffer_length ) length = buffer_length ;\n else if ( src ) {\n length = strlen ( src ) ;\n add = TRUE ;\n }\n else return strdup ( \"\" ) ;\n buffer = malloc ( length + add ) ;\n if ( ! buffer ) return NULL ;\n memcpy ( buffer , src , length ) ;\n if ( add ) buffer [ length ] = '\\0' ;\n return buffer ;\n }",
        "output": "1",
        "idx": 1533
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tokenexec_continue ( i_ctx_t * i_ctx_p , scanner_state * pstate , bool save ) {\n os_ptr op ;\n int code ;\n pop ( 1 ) ;\n again : check_estack ( 1 ) ;\n code = gs_scan_token ( i_ctx_p , ( ref * ) ( esp + 1 ) , pstate ) ;\n op = osp ;\n switch ( code ) {\n case 0 : if ( r_is_proc ( esp + 1 ) ) {\n push ( 1 ) ;\n ref_assign ( op , esp + 1 ) ;\n code = 0 ;\n break ;\n }\n case scan_BOS : ++ esp ;\n code = o_push_estack ;\n break ;\n case scan_EOF : code = 0 ;\n break ;\n case scan_Refill : code = gs_scan_handle_refill ( i_ctx_p , pstate , save , ztokenexec_continue ) ;\n switch ( code ) {\n case 0 : goto again ;\n case o_push_estack : return code ;\n }\n break ;\n case scan_Comment : case scan_DSC_Comment : return ztoken_handle_comment ( i_ctx_p , pstate , esp + 1 , code , save , true , ztokenexec_continue ) ;\n default : gs_scanner_error_object ( i_ctx_p , pstate , & i_ctx_p -> error_object ) ;\n break ;\n }\n if ( ! save ) {\n gs_free_object ( ( ( scanner_state_dynamic * ) pstate ) -> mem , pstate , \"token_continue\" ) ;\n }\n return code ;\n }",
        "output": "1",
        "idx": 1866
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void output_stats ( FIRSTPASS_STATS * stats , struct vpx_codec_pkt_list * pktlist ) {\n struct vpx_codec_cx_pkt pkt ;\n pkt . kind = VPX_CODEC_STATS_PKT ;\n pkt . data . twopass_stats . buf = stats ;\n pkt . data . twopass_stats . sz = sizeof ( FIRSTPASS_STATS ) ;\n vpx_codec_pkt_list_add ( pktlist , & pkt ) ;\n # if OUTPUT_FPF {\n FILE * fpfile ;\n fpfile = fopen ( \"firstpass.stt\" , \"a\" ) ;\n fprintf ( fpfile , \"%12.0f %12.0f %12.0f %12.0f %12.4f %12.4f\" \"%12.4f %12.4f %12.4f %12.4f %12.4f %12.4f %12.4f\" \"%12.0f %12.0f %12.4f %12.0f %12.0f %12.4f\\n\" , stats -> frame , stats -> intra_error , stats -> coded_error , stats -> sr_coded_error , stats -> pcnt_inter , stats -> pcnt_motion , stats -> pcnt_second_ref , stats -> pcnt_neutral , stats -> MVr , stats -> mvr_abs , stats -> MVc , stats -> mvc_abs , stats -> MVrv , stats -> MVcv , stats -> mv_in_out_count , stats -> new_mv_count , stats -> count , stats -> duration ) ;\n fclose ( fpfile ) ;\n }\n # endif }",
        "output": "0",
        "idx": 1444
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void slavio_misc_init ( hwaddr base , hwaddr aux1_base , hwaddr aux2_base , qemu_irq irq , qemu_irq fdc_tc ) {\n DeviceState * dev ;\n SysBusDevice * s ;\n dev = qdev_create ( NULL , \"slavio_misc\" ) ;\n qdev_init_nofail ( dev ) ;\n s = SYS_BUS_DEVICE ( dev ) ;\n if ( base ) {\n sysbus_mmio_map ( s , 0 , base + MISC_CFG ) ;\n sysbus_mmio_map ( s , 1 , base + MISC_DIAG ) ;\n sysbus_mmio_map ( s , 2 , base + MISC_MDM ) ;\n sysbus_mmio_map ( s , 3 , base + MISC_LEDS ) ;\n sysbus_mmio_map ( s , 4 , base + MISC_SYS ) ;\n }\n if ( aux1_base ) {\n sysbus_mmio_map ( s , 5 , aux1_base ) ;\n }\n if ( aux2_base ) {\n sysbus_mmio_map ( s , 6 , aux2_base ) ;\n }\n sysbus_connect_irq ( s , 0 , irq ) ;\n sysbus_connect_irq ( s , 1 , fdc_tc ) ;\n slavio_system_powerdown = qdev_get_gpio_in ( dev , 0 ) ;\n qemu_register_powerdown_notifier ( & slavio_system_powerdown_notifier ) ;\n }",
        "output": "0",
        "idx": 3179
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_decoder_remove ( VP9Decoder * pbi ) {\n VP9_COMMON * const cm = & pbi -> common ;\n int i ;\n vp9_get_worker_interface ( ) -> end ( & pbi -> lf_worker ) ;\n vpx_free ( pbi -> lf_worker . data1 ) ;\n vpx_free ( pbi -> tile_data ) ;\n for ( i = 0 ;\n i < pbi -> num_tile_workers ;\n ++ i ) {\n VP9Worker * const worker = & pbi -> tile_workers [ i ] ;\n vp9_get_worker_interface ( ) -> end ( worker ) ;\n vpx_free ( worker -> data1 ) ;\n vpx_free ( worker -> data2 ) ;\n }\n vpx_free ( pbi -> tile_workers ) ;\n if ( pbi -> num_tile_workers > 0 ) {\n vp9_loop_filter_dealloc ( & pbi -> lf_row_sync ) ;\n }\n vp9_remove_common ( cm ) ;\n vpx_free ( pbi ) ;\n }",
        "output": "0",
        "idx": 108
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int proto_get_id_by_filter_name ( const gchar * filter_name ) {\n const protocol_t * protocol = NULL ;\n DISSECTOR_ASSERT_HINT ( filter_name , \"No filter name present\" ) ;\n protocol = ( const protocol_t * ) g_hash_table_lookup ( proto_filter_names , filter_name ) ;\n if ( protocol == NULL ) return - 1 ;\n return protocol -> proto_id ;\n }",
        "output": "0",
        "idx": 3138
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool message_search_more ( struct message_search_context * ctx , struct message_block * raw_block ) {\n struct message_block decoded_block ;\n return message_search_more_get_decoded ( ctx , raw_block , & decoded_block ) ;\n }",
        "output": "0",
        "idx": 230
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_pcp_message_pmns_child ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , int offset ) {\n proto_item * pcp_pmns_child_item ;\n proto_tree * pcp_pmns_child_tree ;\n guint32 name_len ;\n pcp_pmns_child_item = proto_tree_add_item ( tree , hf_pcp_pmns_child , tvb , offset , - 1 , ENC_NA ) ;\n pcp_pmns_child_tree = proto_item_add_subtree ( pcp_pmns_child_item , ett_pcp ) ;\n col_append_fstr ( pinfo -> cinfo , COL_INFO , \"[%s]\" , val_to_str ( PCP_PDU_PMNS_CHILD , packettypenames , \"Unknown Type:0x%02x\" ) ) ;\n proto_tree_add_item ( pcp_pmns_child_tree , hf_pcp_pmns_subtype , tvb , offset , 4 , ENC_BIG_ENDIAN ) ;\n offset += 4 ;\n proto_tree_add_item ( pcp_pmns_child_tree , hf_pcp_pmns_namelen , tvb , offset , 4 , ENC_BIG_ENDIAN ) ;\n name_len = tvb_get_ntohl ( tvb , offset ) ;\n offset += 4 ;\n proto_tree_add_item ( pcp_pmns_child_tree , hf_pcp_pmns_name , tvb , offset , name_len , ENC_ASCII | ENC_NA ) ;\n offset += 4 ;\n return offset ;\n }",
        "output": "0",
        "idx": 2282
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int check_slice_end ( RV34DecContext * r , MpegEncContext * s ) {\n int bits ;\n if ( s -> mb_y >= s -> mb_height ) return 1 ;\n if ( ! s -> mb_num_left ) return 1 ;\n if ( r -> s . mb_skip_run > 1 ) return 0 ;\n bits = get_bits_left ( & s -> gb ) ;\n if ( bits < 0 || ( bits < 8 && ! show_bits ( & s -> gb , bits ) ) ) return 1 ;\n return 0 ;\n }",
        "output": "0",
        "idx": 673
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemuMonitorTextRemoveHostNetwork ( qemuMonitorPtr mon , int vlan , const char * netname ) {\n char * cmd ;\n char * reply = NULL ;\n int ret = - 1 ;\n if ( virAsprintf ( & cmd , \"host_net_remove %d %s\" , vlan , netname ) < 0 ) {\n virReportOOMError ( ) ;\n return - 1 ;\n }\n if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( \"failed to remove host network in qemu with '%s'\" ) , cmd ) ;\n goto cleanup ;\n }\n ret = 0 ;\n cleanup : VIR_FREE ( cmd ) ;\n VIR_FREE ( reply ) ;\n return ret ;\n }",
        "output": "0",
        "idx": 2077
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int gx_ttfReader__default_get_metrics ( const ttfReader * ttf , uint glyph_index , bool bVertical , short * sideBearing , unsigned short * nAdvance ) {\n gx_ttfReader * self = ( gx_ttfReader * ) ttf ;\n float sbw [ 4 ] ;\n int sbw_offset = bVertical ;\n int code ;\n int factor = self -> pfont -> data . unitsPerEm ;\n code = self -> pfont -> data . get_metrics ( self -> pfont , glyph_index , bVertical , sbw ) ;\n if ( code < 0 ) return code ;\n * sideBearing = ( short ) floor ( sbw [ 0 + sbw_offset ] * factor + 0.5 ) ;\n * nAdvance = ( short ) floor ( sbw [ 2 + sbw_offset ] * factor + 0.5 ) ;\n return 0 ;\n }",
        "output": "0",
        "idx": 4260
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void simple_read_cb ( int fd , short event , void * arg ) {\n char buf [ 256 ] ;\n int len ;\n if ( arg == NULL ) return ;\n len = read ( fd , buf , sizeof ( buf ) ) ;\n if ( len ) {\n if ( ! called ) {\n if ( event_add ( arg , NULL ) == - 1 ) exit ( 1 ) ;\n }\n }\n else if ( called == 1 ) test_ok = 1 ;\n called ++ ;\n }",
        "output": "0",
        "idx": 326
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dump_backtrace ( void ) {\n fputs ( \"Backtrace not available.\\n\" , stderr ) ;\n }",
        "output": "0",
        "idx": 625
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ProtocolHandlerRegistryTest , RemovingHandlerMeansItCanBeAddedAgain ) {\n registry ( ) -> OnAcceptRegisterProtocolHandler ( test_protocol_handler ( ) ) ;\n ASSERT_TRUE ( registry ( ) -> CanSchemeBeOverridden ( \"test\" ) ) ;\n registry ( ) -> RemoveHandler ( test_protocol_handler ( ) ) ;\n ASSERT_TRUE ( registry ( ) -> CanSchemeBeOverridden ( \"test\" ) ) ;\n }",
        "output": "0",
        "idx": 1163
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void event_process_active ( struct event_base * base ) {\n struct event * ev ;\n struct event_list * activeq = NULL ;\n int i ;\n short ncalls ;\n for ( i = 0 ;\n i < base -> nactivequeues ;\n ++ i ) {\n if ( TAILQ_FIRST ( base -> activequeues [ i ] ) != NULL ) {\n activeq = base -> activequeues [ i ] ;\n break ;\n }\n }\n assert ( activeq != NULL ) ;\n for ( ev = TAILQ_FIRST ( activeq ) ;\n ev ;\n ev = TAILQ_FIRST ( activeq ) ) {\n if ( ev -> ev_events & EV_PERSIST ) event_queue_remove ( base , ev , EVLIST_ACTIVE ) ;\n else event_del ( ev ) ;\n ncalls = ev -> ev_ncalls ;\n ev -> ev_pncalls = & ncalls ;\n while ( ncalls ) {\n ncalls -- ;\n ev -> ev_ncalls = ncalls ;\n ( * ev -> ev_callback ) ( ( int ) ev -> ev_fd , ev -> ev_res , ev -> ev_arg ) ;\n if ( base -> event_break ) return ;\n }\n }\n }",
        "output": "1",
        "idx": 491
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void copy_sbr_grid ( SBRData * dst , const SBRData * src ) {\n dst -> bs_freq_res [ 0 ] = dst -> bs_freq_res [ dst -> bs_num_env ] ;\n dst -> t_env_num_env_old = dst -> t_env [ dst -> bs_num_env ] ;\n dst -> e_a [ 0 ] = - ( dst -> e_a [ 1 ] != dst -> bs_num_env ) ;\n memcpy ( dst -> bs_freq_res + 1 , src -> bs_freq_res + 1 , sizeof ( dst -> bs_freq_res ) - sizeof ( * dst -> bs_freq_res ) ) ;\n memcpy ( dst -> t_env , src -> t_env , sizeof ( dst -> t_env ) ) ;\n memcpy ( dst -> t_q , src -> t_q , sizeof ( dst -> t_q ) ) ;\n dst -> bs_num_env = src -> bs_num_env ;\n dst -> bs_amp_res = src -> bs_amp_res ;\n dst -> bs_num_noise = src -> bs_num_noise ;\n dst -> bs_frame_class = src -> bs_frame_class ;\n dst -> e_a [ 1 ] = src -> e_a [ 1 ] ;\n }",
        "output": "1",
        "idx": 1430
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void jpc_enc_tile_destroy ( jpc_enc_tile_t * tile ) {\n jpc_enc_tcmpt_t * tcmpt ;\n uint_fast16_t cmptno ;\n if ( tile -> tcmpts ) {\n for ( cmptno = 0 , tcmpt = tile -> tcmpts ;\n cmptno < tile -> numtcmpts ;\n ++ cmptno , ++ tcmpt ) {\n tcmpt_destroy ( tcmpt ) ;\n }\n jas_free ( tile -> tcmpts ) ;\n }\n if ( tile -> lyrsizes ) {\n jas_free ( tile -> lyrsizes ) ;\n }\n if ( tile -> pi ) {\n jpc_pi_destroy ( tile -> pi ) ;\n }\n jas_free ( tile ) ;\n }",
        "output": "1",
        "idx": 3690
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void * i_alloc_struct_array_immovable ( gs_memory_t * mem , uint num_elements , gs_memory_type_ptr_t pstype , client_name_t cname ) {\n gs_ref_memory_t * const imem = ( gs_ref_memory_t * ) mem ;\n obj_header_t * obj ;\n ulong lsize ;\n # ifdef MEMENTO if ( Memento_failThisEvent ( ) ) return NULL ;\n # endif ALLOC_CHECK_SIZE ( mem , pstype ) ;\n if ( alloc_array_check_size ( num_elements , pstype -> ssize , & lsize ) == false ) return NULL ;\n obj = alloc_obj ( imem , lsize , pstype , ALLOC_IMMOVABLE | ALLOC_DIRECT , cname ) ;\n if_debug7m ( 'A' , mem , \"[a%d|+<.]%s %s*(%lu=%u*%u) = 0x%lx\\n\" , alloc_trace_space ( imem ) , client_name_string ( cname ) , struct_type_name_string ( pstype ) , ( ulong ) num_elements * pstype -> ssize , num_elements , pstype -> ssize , ( ulong ) obj ) ;\n return ( char * ) obj ;\n }",
        "output": "0",
        "idx": 118
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ProtocolHandlerRegistryTest , TestReplaceHandler ) {\n ProtocolHandler ph1 = CreateProtocolHandler ( \"mailto\" , GURL ( \"http://test.com/%s\" ) , \"test1\" ) ;\n ProtocolHandler ph2 = CreateProtocolHandler ( \"mailto\" , GURL ( \"http://test.com/updated-url/%s\" ) , \"test2\" ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;\n ASSERT_TRUE ( registry ( ) -> AttemptReplace ( ph2 ) ) ;\n const ProtocolHandler & handler ( registry ( ) -> GetHandlerFor ( \"mailto\" ) ) ;\n ASSERT_EQ ( handler . url ( ) , ph2 . url ( ) ) ;\n }",
        "output": "1",
        "idx": 1861
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int roq_encode_end ( AVCodecContext * avctx ) {\n RoqContext * enc = avctx -> priv_data ;\n avctx -> release_buffer ( avctx , enc -> last_frame ) ;\n avctx -> release_buffer ( avctx , enc -> current_frame ) ;\n av_free ( enc -> tmpData ) ;\n av_free ( enc -> this_motion4 ) ;\n av_free ( enc -> last_motion4 ) ;\n av_free ( enc -> this_motion8 ) ;\n av_free ( enc -> last_motion8 ) ;\n return 0 ;\n }",
        "output": "1",
        "idx": 2422
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nntp_group_poll ( struct NntpData * nntp_data , int update_stat ) {\n char buf [ LONG_STRING ] = \"\" ;\n anum_t count , first , last ;\n if ( nntp_query ( nntp_data , buf , sizeof ( buf ) ) < 0 ) return - 1 ;\n if ( sscanf ( buf , \"211 \" ANUM \" \" ANUM \" \" ANUM , & count , & first , & last ) != 3 ) return 0 ;\n if ( first == nntp_data -> first_message && last == nntp_data -> last_message ) return 0 ;\n if ( last < nntp_data -> last_message ) {\n nntp_data -> last_cached = 0 ;\n if ( nntp_data -> newsrc_len ) {\n mutt_mem_realloc ( & nntp_data -> newsrc_ent , sizeof ( struct NewsrcEntry ) ) ;\n nntp_data -> newsrc_len = 1 ;\n nntp_data -> newsrc_ent [ 0 ] . first = 1 ;\n nntp_data -> newsrc_ent [ 0 ] . last = 0 ;\n }\n }\n nntp_data -> first_message = first ;\n nntp_data -> last_message = last ;\n if ( ! update_stat ) return 1 ;\n else if ( ! last || ( ! nntp_data -> newsrc_ent && ! nntp_data -> last_cached ) ) nntp_data -> unread = count ;\n else nntp_group_unread_stat ( nntp_data ) ;\n return 1 ;\n }",
        "output": "0",
        "idx": 1021
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int token_continue ( i_ctx_t * i_ctx_p , scanner_state * pstate , bool save ) {\n os_ptr op = osp ;\n int code ;\n ref token ;\n pop ( 1 ) ;\n again : code = gs_scan_token ( i_ctx_p , & token , pstate ) ;\n op = osp ;\n switch ( code ) {\n default : if ( code > 0 ) code = gs_note_error ( gs_error_syntaxerror ) ;\n gs_scanner_error_object ( i_ctx_p , pstate , & i_ctx_p -> error_object ) ;\n break ;\n case scan_BOS : code = 0 ;\n case 0 : push ( 2 ) ;\n ref_assign ( op - 1 , & token ) ;\n make_true ( op ) ;\n break ;\n case scan_EOF : push ( 1 ) ;\n make_false ( op ) ;\n code = 0 ;\n break ;\n case scan_Refill : code = gs_scan_handle_refill ( i_ctx_p , pstate , save , ztoken_continue ) ;\n switch ( code ) {\n case 0 : goto again ;\n case o_push_estack : return code ;\n }\n break ;\n }\n if ( code <= 0 && ! save ) {\n ifree_object ( pstate , \"token_continue\" ) ;\n }\n return code ;\n }",
        "output": "1",
        "idx": 1030
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int split_field_copy ( Picture * dest , Picture * src , int parity , int id_add ) {\n int match = ! ! ( src -> f . reference & parity ) ;\n if ( match ) {\n * dest = * src ;\n if ( parity != PICT_FRAME ) {\n pic_as_field ( dest , parity ) ;\n dest -> pic_id *= 2 ;\n dest -> pic_id += id_add ;\n }\n }\n return match ;\n }",
        "output": "1",
        "idx": 94
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PyObject * authGSSServerUserName ( PyObject * self , PyObject * args ) {\n gss_server_state * state ;\n PyObject * pystate ;\n if ( ! PyArg_ParseTuple ( args , \"O\" , & pystate ) ) return NULL ;\n # if PY_MAJOR_VERSION >= 3 if ( ! PyCapsule_CheckExact ( pystate ) ) {\n # else if ( ! PyCObject_Check ( pystate ) ) {\n # endif PyErr_SetString ( PyExc_TypeError , \"Expected a context object\" ) ;\n return NULL ;\n }\n # if PY_MAJOR_VERSION >= 3 state = PyCapsule_GetPointer ( pystate , NULL ) ;\n # else state = ( gss_client_state * ) PyCObject_AsVoidPtr ( pystate ) ;\n # endif if ( state == NULL ) return NULL ;\n return Py_BuildValue ( \"s\" , state -> username ) ;\n }",
        "output": "1",
        "idx": 2544
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char func_parallel ( Oid funcid ) {\n HeapTuple tp ;\n char result ;\n tp = SearchSysCache1 ( PROCOID , ObjectIdGetDatum ( funcid ) ) ;\n if ( ! HeapTupleIsValid ( tp ) ) elog ( ERROR , \"cache lookup failed for function %u\" , funcid ) ;\n result = ( ( Form_pg_proc ) GETSTRUCT ( tp ) ) -> proparallel ;\n ReleaseSysCache ( tp ) ;\n return result ;\n }",
        "output": "0",
        "idx": 2267
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void await_reference_mb_row ( H264Context * const h , Picture * ref , int mb_y ) {\n int ref_field = ref -> f . reference - 1 ;\n int ref_field_picture = ref -> field_picture ;\n int ref_height = 16 * h -> mb_height >> ref_field_picture ;\n if ( ! HAVE_THREADS || ! ( h -> avctx -> active_thread_type & FF_THREAD_FRAME ) ) return ;\n ff_thread_await_progress ( & ref -> f , FFMIN ( 16 * mb_y >> ref_field_picture , ref_height - 1 ) , ref_field_picture && ref_field ) ;\n }",
        "output": "1",
        "idx": 315
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_iht16x16_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , int stride , int eob ) {\n if ( tx_type == DCT_DCT ) {\n vp9_idct16x16_add ( input , dest , stride , eob ) ;\n }\n else {\n vp9_iht16x16_256_add ( input , dest , stride , tx_type ) ;\n }\n }",
        "output": "1",
        "idx": 933
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int gfboost_qadjust ( int qindex ) {\n const double q = vp9_convert_qindex_to_q ( qindex ) ;\n return ( int ) ( ( 0.00000828 * q * q * q ) + ( - 0.0055 * q * q ) + ( 1.32 * q ) + 79.3 ) ;\n }",
        "output": "1",
        "idx": 3810
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fz_colorspace * fz_new_cal_colorspace ( fz_context * ctx , const char * name , float * wp , float * bp , float * gamma , float * matrix ) {\n fz_colorspace * cs = NULL ;\n enum fz_colorspace_type type ;\n int num ;\n fz_cal_colorspace * cal_data ;\n if ( matrix ) {\n type = FZ_COLORSPACE_RGB ;\n num = 3 ;\n }\n else {\n type = FZ_COLORSPACE_GRAY ;\n num = 1 ;\n }\n cal_data = fz_malloc_struct ( ctx , fz_cal_colorspace ) ;\n memcpy ( & cal_data -> bp , bp , sizeof ( float ) * 3 ) ;\n memcpy ( & cal_data -> wp , wp , sizeof ( float ) * 3 ) ;\n memcpy ( & cal_data -> gamma , gamma , sizeof ( float ) * num ) ;\n if ( matrix != NULL ) memcpy ( & cal_data -> matrix , matrix , sizeof ( float ) * 9 ) ;\n cal_data -> n = num ;\n fz_try ( ctx ) cs = fz_new_colorspace ( ctx , name , type , FZ_COLORSPACE_IS_CAL , num , NULL , NULL , NULL , NULL , free_cal , cal_data , sizeof ( cal_data ) ) ;\n fz_catch ( ctx ) {\n fz_free ( ctx , cal_data ) ;\n fz_rethrow ( ctx ) ;\n }\n return cs ;\n }",
        "output": "0",
        "idx": 2855
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void segment_properties_destroy ( hb_segment_properties_t * g ) {\n free ( g ) ;\n }",
        "output": "1",
        "idx": 3715
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t U_CALLCONV _enumTypeValue ( const void * context , uint32_t value ) {\n return GET_CATEGORY ( value ) ;\n }",
        "output": "1",
        "idx": 458
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void copy_partitioning ( VP9_COMMON * cm , MODE_INFO * * mi_8x8 , MODE_INFO * * prev_mi_8x8 ) {\n const int mis = cm -> mi_stride ;\n int block_row , block_col ;\n for ( block_row = 0 ;\n block_row < 8 ;\n ++ block_row ) {\n for ( block_col = 0 ;\n block_col < 8 ;\n ++ block_col ) {\n MODE_INFO * const prev_mi = prev_mi_8x8 [ block_row * mis + block_col ] ;\n const BLOCK_SIZE sb_type = prev_mi ? prev_mi -> mbmi . sb_type : 0 ;\n if ( prev_mi ) {\n const ptrdiff_t offset = prev_mi - cm -> prev_mi ;\n mi_8x8 [ block_row * mis + block_col ] = cm -> mi + offset ;\n mi_8x8 [ block_row * mis + block_col ] -> mbmi . sb_type = sb_type ;\n }\n }\n }\n }",
        "output": "1",
        "idx": 4451
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void * size_checked_malloc ( size_t size ) {\n if ( size > MAX_LIBXML_MALLOC ) {\n * ( volatile char * ) 0 = '\\0' ;\n return NULL ;\n }\n return malloc ( size ) ;\n }",
        "output": "1",
        "idx": 1293
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool qemu_in_vcpu_thread ( void ) {\n return cpu_single_env && qemu_cpu_is_self ( ENV_GET_CPU ( cpu_single_env ) ) ;\n }",
        "output": "1",
        "idx": 1197
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void SetPixelGreen ( const Image * restrict image , const Quantum green , Quantum * restrict pixel ) {\n pixel [ image -> channel_map [ GreenPixelChannel ] . offset ] = green ;\n }",
        "output": "0",
        "idx": 1215
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int gsm_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n int res ;\n GetBitContext gb ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n int16_t * samples ;\n if ( buf_size < avctx -> block_align ) {\n av_log ( avctx , AV_LOG_ERROR , \"Packet is too small\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n frame -> nb_samples = avctx -> frame_size ;\n if ( ( res = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return res ;\n }\n samples = ( int16_t * ) frame -> data [ 0 ] ;\n switch ( avctx -> codec_id ) {\n case AV_CODEC_ID_GSM : init_get_bits ( & gb , buf , buf_size * 8 ) ;\n if ( get_bits ( & gb , 4 ) != 0xd ) av_log ( avctx , AV_LOG_WARNING , \"Missing GSM magic!\\n\" ) ;\n res = gsm_decode_block ( avctx , samples , & gb ) ;\n if ( res < 0 ) return res ;\n break ;\n case AV_CODEC_ID_GSM_MS : res = ff_msgsm_decode_block ( avctx , samples , buf ) ;\n if ( res < 0 ) return res ;\n }\n * got_frame_ptr = 1 ;\n return avctx -> block_align ;\n }",
        "output": "1",
        "idx": 3774
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char * TSHttpTxnEffectiveUrlStringGet ( TSHttpTxn txnp , int * length ) {\n sdk_assert ( TS_SUCCESS == sdk_sanity_check_txn ( txnp ) ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) length ) == TS_SUCCESS ) ;\n HttpSM * sm = reinterpret_cast < HttpSM * > ( txnp ) ;\n return sm -> t_state . hdr_info . client_request . url_string_get ( nullptr , length ) ;\n }",
        "output": "0",
        "idx": 3187
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int compress_bidder_bid ( struct archive_read_filter_bidder * self , struct archive_read_filter * filter ) {\n const unsigned char * buffer ;\n ssize_t avail ;\n int bits_checked ;\n ( void ) self ;\n buffer = __archive_read_filter_ahead ( filter , 3 , & avail ) ;\n if ( buffer == NULL ) return ( 0 ) ;\n bits_checked = 0 ;\n if ( buffer [ 0 ] != 0x1F || buffer [ 1 ] != 0x9D ) return ( 0 ) ;\n if ( buffer [ 2 ] & 0x20 ) return ( 0 ) ;\n if ( buffer [ 2 ] & 0x40 ) return ( 0 ) ;\n bits_checked += 18 ;\n return ( bits_checked ) ;\n }",
        "output": "0",
        "idx": 4013
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_swap_mi_and_prev_mi ( VP9_COMMON * cm ) {\n const int tmp = cm -> mi_idx ;\n cm -> mi_idx = cm -> prev_mi_idx ;\n cm -> prev_mi_idx = tmp ;\n cm -> mip = cm -> mip_array [ cm -> mi_idx ] ;\n cm -> prev_mip = cm -> mip_array [ cm -> prev_mi_idx ] ;\n cm -> mi_grid_base = cm -> mi_grid_base_array [ cm -> mi_idx ] ;\n cm -> prev_mi_grid_base = cm -> mi_grid_base_array [ cm -> prev_mi_idx ] ;\n cm -> mi = cm -> mip + cm -> mi_stride + 1 ;\n cm -> prev_mi = cm -> prev_mip + cm -> mi_stride + 1 ;\n cm -> mi_grid_visible = cm -> mi_grid_base + cm -> mi_stride + 1 ;\n cm -> prev_mi_grid_visible = cm -> prev_mi_grid_base + cm -> mi_stride + 1 ;\n }",
        "output": "1",
        "idx": 1058
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int virtio_console_init_pci ( PCIDevice * pci_dev ) {\n VirtIOPCIProxy * proxy = DO_UPCAST ( VirtIOPCIProxy , pci_dev , pci_dev ) ;\n VirtIODevice * vdev ;\n if ( proxy -> class_code != PCI_CLASS_COMMUNICATION_OTHER && proxy -> class_code != PCI_CLASS_DISPLAY_OTHER && proxy -> class_code != PCI_CLASS_OTHERS ) proxy -> class_code = PCI_CLASS_COMMUNICATION_OTHER ;\n vdev = virtio_console_init ( & pci_dev -> qdev ) ;\n if ( ! vdev ) {\n return - 1 ;\n }\n virtio_init_pci ( proxy , vdev , PCI_VENDOR_ID_REDHAT_QUMRANET , PCI_DEVICE_ID_VIRTIO_CONSOLE , proxy -> class_code , 0x00 ) ;\n return 0 ;\n }",
        "output": "1",
        "idx": 3877
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char * qemuMonitorJSONStringifyError ( virJSONValuePtr error ) {\n const char * klass = virJSONValueObjectGetString ( error , \"class\" ) ;\n const char * detail = NULL ;\n if ( klass ) detail = virJSONValueObjectGetString ( error , \"desc\" ) ;\n if ( ! detail ) detail = \"unknown QEMU command error\" ;\n return detail ;\n }",
        "output": "0",
        "idx": 3513
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void e1000e_update_rx_stats ( E1000ECore * core , size_t data_size , size_t data_fcs_size ) {\n e1000x_update_rx_total_stats ( core -> mac , data_size , data_fcs_size ) ;\n switch ( net_rx_pkt_get_packet_type ( core -> rx_pkt ) ) {\n case ETH_PKT_BCAST : e1000x_inc_reg_if_not_full ( core -> mac , BPRC ) ;\n break ;\n case ETH_PKT_MCAST : e1000x_inc_reg_if_not_full ( core -> mac , MPRC ) ;\n break ;\n default : break ;\n }\n }",
        "output": "0",
        "idx": 349
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean qio_channel_websock_source_check ( GSource * source ) {\n QIOChannelWebsockSource * wsource = ( QIOChannelWebsockSource * ) source ;\n GIOCondition cond = 0 ;\n if ( wsource -> wioc -> rawinput . offset || wsource -> wioc -> io_eof ) {\n cond |= G_IO_IN ;\n }\n if ( wsource -> wioc -> rawoutput . offset < QIO_CHANNEL_WEBSOCK_MAX_BUFFER ) {\n cond |= G_IO_OUT ;\n }\n return cond & wsource -> condition ;\n }",
        "output": "1",
        "idx": 2449
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_show_object ( struct object * object , const struct name_path * path , const char * last , void * data ) {\n struct bitmap_test_data * tdata = data ;\n int bitmap_pos ;\n bitmap_pos = bitmap_position ( object -> oid . hash ) ;\n if ( bitmap_pos < 0 ) die ( \"Object not in bitmap: %s\\n\" , oid_to_hex ( & object -> oid ) ) ;\n bitmap_set ( tdata -> base , bitmap_pos ) ;\n display_progress ( tdata -> prg , ++ tdata -> seen ) ;\n }",
        "output": "1",
        "idx": 1939
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( ClientHintsBrowserTest , DisregardPersistenceRequestIframe ) {\n base : : HistogramTester histogram_tester ;\n ContentSettingsForOneType host_settings ;\n HostContentSettingsMapFactory : : GetForProfile ( browser ( ) -> profile ( ) ) -> GetSettingsForOneType ( CONTENT_SETTINGS_TYPE_CLIENT_HINTS , std : : string ( ) , & host_settings ) ;\n EXPECT_EQ ( 0u , host_settings . size ( ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , accept_ch_without_lifetime_with_iframe_url ( ) ) ;\n histogram_tester . ExpectTotalCount ( \"ClientHints.UpdateEventCount\" , 0 ) ;\n content : : FetchHistogramsFromChildProcesses ( ) ;\n SubprocessMetricsProvider : : MergeHistogramDeltasForTesting ( ) ;\n histogram_tester . ExpectTotalCount ( \"ClientHints.UpdateSize\" , 0 ) ;\n histogram_tester . ExpectTotalCount ( \"ClientHints.PersistDuration\" , 0 ) ;\n }",
        "output": "0",
        "idx": 1687
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_idct4x4_1_add_c ( const int16_t * input , uint8_t * dest , int dest_stride ) {\n int i ;\n int a1 ;\n int16_t out = dct_const_round_shift ( input [ 0 ] * cospi_16_64 ) ;\n out = dct_const_round_shift ( out * cospi_16_64 ) ;\n a1 = ROUND_POWER_OF_TWO ( out , 4 ) ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n dest [ 0 ] = clip_pixel ( dest [ 0 ] + a1 ) ;\n dest [ 1 ] = clip_pixel ( dest [ 1 ] + a1 ) ;\n dest [ 2 ] = clip_pixel ( dest [ 2 ] + a1 ) ;\n dest [ 3 ] = clip_pixel ( dest [ 3 ] + a1 ) ;\n dest += dest_stride ;\n }\n }",
        "output": "1",
        "idx": 2754
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( SafeJsonParserTest , Parse ) {\n TestParse ( \"{\n}\n\" ) ;\n TestParse ( \"choke\" ) ;\n TestParse ( \"{\n\\\"awesome\\\": true}\n\" ) ;\n TestParse ( \"\\\"laser\\\"\" ) ;\n TestParse ( \"false\" ) ;\n TestParse ( \"null\" ) ;\n TestParse ( \"3.14\" ) ;\n TestParse ( \"[\" ) ;\n TestParse ( \"\\\"\" ) ;\n TestParse ( std : : string ( ) ) ;\n TestParse ( \"\u2603\" ) ;\n TestParse ( \"\\\"\u2603\\\"\" ) ;\n TestParse ( \"\\\"\\\\ufdd0\\\"\" ) ;\n TestParse ( \"\\\"\\\\ufffe\\\"\" ) ;\n TestParse ( \"\\\"\\\\ud83f\\\\udffe\\\"\" ) ;\n }",
        "output": "1",
        "idx": 1696
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _selectOutputSchema ( ArchiveHandle * AH , const char * schemaName ) {\n PQExpBuffer qry ;\n if ( ! schemaName || * schemaName == '\\0' || ( AH -> currSchema && strcmp ( AH -> currSchema , schemaName ) == 0 ) ) return ;\n qry = createPQExpBuffer ( ) ;\n appendPQExpBuffer ( qry , \"SET search_path = %s\" , fmtId ( schemaName ) ) ;\n if ( strcmp ( schemaName , \"pg_catalog\" ) != 0 ) appendPQExpBufferStr ( qry , \", pg_catalog\" ) ;\n if ( RestoringToDB ( AH ) ) {\n PGresult * res ;\n res = PQexec ( AH -> connection , qry -> data ) ;\n if ( ! res || PQresultStatus ( res ) != PGRES_COMMAND_OK ) warn_or_exit_horribly ( AH , modulename , \"could not set search_path to \\\"%s\\\": %s\" , schemaName , PQerrorMessage ( AH -> connection ) ) ;\n PQclear ( res ) ;\n }\n else ahprintf ( AH , \"%s;\n\\n\\n\" , qry -> data ) ;\n if ( AH -> currSchema ) free ( AH -> currSchema ) ;\n AH -> currSchema = pg_strdup ( schemaName ) ;\n destroyPQExpBuffer ( qry ) ;\n }",
        "output": "0",
        "idx": 1652
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "kadm5_ret_t kadm5_get_principal_keys ( void * server_handle , krb5_principal principal , krb5_keyblock * * keyblocks , int * n_keys ) {\n krb5_db_entry * kdb ;\n osa_princ_ent_rec adb ;\n kadm5_ret_t ret ;\n kadm5_server_handle_t handle = server_handle ;\n if ( keyblocks ) * keyblocks = NULL ;\n CHECK_HANDLE ( server_handle ) ;\n if ( principal == NULL ) return EINVAL ;\n if ( ( ret = kdb_get_entry ( handle , principal , & kdb , & adb ) ) ) return ( ret ) ;\n if ( keyblocks ) {\n ret = decrypt_key_data ( handle -> context , kdb -> n_key_data , kdb -> key_data , keyblocks , n_keys ) ;\n if ( ret ) goto done ;\n }\n ret = KADM5_OK ;\n done : kdb_free_entry ( handle , kdb , & adb ) ;\n return ret ;\n }",
        "output": "0",
        "idx": 4292
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool e1000e_ring_enabled ( E1000ECore * core , const E1000E_RingInfo * r ) {\n return core -> mac [ r -> dlen ] > 0 ;\n }",
        "output": "0",
        "idx": 754
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jbig2_find_changing_element ( const byte * line , int x , int w ) {\n int a , b ;\n if ( line == 0 ) return w ;\n if ( x == - 1 ) {\n a = 0 ;\n x = 0 ;\n }\n else {\n a = getbit ( line , x ) ;\n x ++ ;\n }\n while ( x < w ) {\n b = getbit ( line , x ) ;\n if ( a != b ) break ;\n x ++ ;\n }\n return x ;\n }",
        "output": "1",
        "idx": 3743
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TSVConn TSHttpConnectTransparent ( sockaddr const * client_addr , sockaddr const * server_addr ) {\n sdk_assert ( ats_is_ip ( client_addr ) ) ;\n sdk_assert ( ats_is_ip ( server_addr ) ) ;\n sdk_assert ( ! ats_is_ip_any ( client_addr ) ) ;\n sdk_assert ( ats_ip_port_cast ( client_addr ) ) ;\n sdk_assert ( ! ats_is_ip_any ( server_addr ) ) ;\n sdk_assert ( ats_ip_port_cast ( server_addr ) ) ;\n if ( plugin_http_transparent_accept ) {\n PluginVCCore * new_pvc = PluginVCCore : : alloc ( plugin_http_transparent_accept ) ;\n new_pvc -> set_active_addr ( client_addr ) ;\n new_pvc -> set_passive_addr ( server_addr ) ;\n new_pvc -> set_transparent ( true , true ) ;\n PluginVC * return_vc = new_pvc -> connect ( ) ;\n if ( return_vc != nullptr ) {\n PluginVC * other_side = return_vc -> get_other_side ( ) ;\n if ( other_side != nullptr ) {\n other_side -> set_is_internal_request ( true ) ;\n }\n }\n return reinterpret_cast < TSVConn > ( return_vc ) ;\n }\n return nullptr ;\n }",
        "output": "0",
        "idx": 3438
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void update_state_rt ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx , int mi_row , int mi_col , int bsize ) {\n VP9_COMMON * const cm = & cpi -> common ;\n MACROBLOCK * const x = & cpi -> mb ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;\n const struct segmentation * const seg = & cm -> seg ;\n * ( xd -> mi [ 0 ] ) = ctx -> mic ;\n if ( ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ ) && seg -> enabled ) {\n vp9_cyclic_refresh_update_segment ( cpi , & xd -> mi [ 0 ] -> mbmi , mi_row , mi_col , bsize , 1 ) ;\n vp9_init_plane_quantizers ( cpi , x ) ;\n }\n if ( is_inter_block ( mbmi ) ) {\n vp9_update_mv_count ( cm , xd ) ;\n if ( cm -> interp_filter == SWITCHABLE ) {\n const int pred_ctx = vp9_get_pred_context_switchable_interp ( xd ) ;\n ++ cm -> counts . switchable_interp [ pred_ctx ] [ mbmi -> interp_filter ] ;\n }\n }\n x -> skip = ctx -> skip ;\n x -> skip_txfm [ 0 ] = mbmi -> segment_id ? 0 : ctx -> skip_txfm [ 0 ] ;\n }",
        "output": "1",
        "idx": 1367
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dissect_h225_ServiceControlSession ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_ServiceControlSession , ServiceControlSession_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 2818
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void release_context ( compress_filter_context_t * ctx ) {\n xfree ( ctx ) ;\n }",
        "output": "0",
        "idx": 2161
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int jbig2_page_add_result ( Jbig2Ctx * ctx , Jbig2Page * page , Jbig2Image * image , int x , int y , Jbig2ComposeOp op ) {\n if ( page -> image == NULL ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_WARNING , - 1 , \"page info possibly missing, no image defined\" ) ;\n return 0 ;\n }\n if ( page -> striped ) {\n int new_height = y + image -> height + page -> end_row ;\n if ( page -> image -> height < new_height ) {\n jbig2_error ( ctx , JBIG2_SEVERITY_DEBUG , - 1 , \"growing page buffer to %d rows \" \"to accomodate new stripe\" , new_height ) ;\n jbig2_image_resize ( ctx , page -> image , page -> image -> width , new_height ) ;\n }\n }\n jbig2_image_compose ( ctx , page -> image , image , x , y + page -> end_row , op ) ;\n return 0 ;\n }",
        "output": "1",
        "idx": 229
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vga_draw_line16_be ( VGACommonState * s1 , uint8_t * d , const uint8_t * s , int width ) {\n int w ;\n uint32_t v , r , g , b ;\n w = width ;\n do {\n v = lduw_be_p ( ( void * ) s ) ;\n r = ( v >> 8 ) & 0xf8 ;\n g = ( v >> 3 ) & 0xfc ;\n b = ( v << 3 ) & 0xf8 ;\n ( ( uint32_t * ) d ) [ 0 ] = rgb_to_pixel32 ( r , g , b ) ;\n s += 2 ;\n d += 4 ;\n }\n while ( -- w != 0 ) ;\n }",
        "output": "1",
        "idx": 1499
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Datum ExecEvalCase ( CaseExprState * caseExpr , ExprContext * econtext , bool * isNull , ExprDoneCond * isDone ) {\n List * clauses = caseExpr -> args ;\n ListCell * clause ;\n Datum save_datum ;\n bool save_isNull ;\n if ( isDone ) * isDone = ExprSingleResult ;\n save_datum = econtext -> caseValue_datum ;\n save_isNull = econtext -> caseValue_isNull ;\n if ( caseExpr -> arg ) {\n econtext -> caseValue_datum = ExecEvalExpr ( caseExpr -> arg , econtext , & econtext -> caseValue_isNull , NULL ) ;\n }\n foreach ( clause , clauses ) {\n CaseWhenState * wclause = lfirst ( clause ) ;\n Datum clause_value ;\n clause_value = ExecEvalExpr ( wclause -> expr , econtext , isNull , NULL ) ;\n if ( DatumGetBool ( clause_value ) && ! * isNull ) {\n econtext -> caseValue_datum = save_datum ;\n econtext -> caseValue_isNull = save_isNull ;\n return ExecEvalExpr ( wclause -> result , econtext , isNull , isDone ) ;\n }\n }\n econtext -> caseValue_datum = save_datum ;\n econtext -> caseValue_isNull = save_isNull ;\n if ( caseExpr -> defresult ) {\n return ExecEvalExpr ( caseExpr -> defresult , econtext , isNull , isDone ) ;\n }\n * isNull = true ;\n return ( Datum ) 0 ;\n }",
        "output": "1",
        "idx": 2080
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline u32 ipv6_addr_hash ( const struct in6_addr * a ) {\n # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) && BITS_PER_LONG == 64 const unsigned long * ul = ( const unsigned long * ) a ;\n unsigned long x = ul [ 0 ] ^ ul [ 1 ] ;\n return ( u32 ) ( x ^ ( x >> 32 ) ) ;\n # else return ( __force u32 ) ( a -> s6_addr32 [ 0 ] ^ a -> s6_addr32 [ 1 ] ^ a -> s6_addr32 [ 2 ] ^ a -> s6_addr32 [ 3 ] ) ;\n # endif }",
        "output": "0",
        "idx": 3882
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sbr_hf_apply_noise_2 ( float ( * Y ) [ 2 ] , const float * s_m , const float * q_filt , int noise , int kx , int m_max ) {\n sbr_hf_apply_noise ( Y , s_m , q_filt , noise , - 1.0 , 0.0 , m_max ) ;\n }",
        "output": "1",
        "idx": 1115
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned long xmlHashComputeKey ( xmlHashTablePtr table , const xmlChar * name , const xmlChar * name2 , const xmlChar * name3 ) {\n unsigned long value = 0L ;\n char ch ;\n if ( name != NULL ) {\n value += 30 * ( * name ) ;\n while ( ( ch = * name ++ ) != 0 ) {\n value = value ^ ( ( value << 5 ) + ( value >> 3 ) + ( unsigned long ) ch ) ;\n }\n }\n if ( name2 != NULL ) {\n while ( ( ch = * name2 ++ ) != 0 ) {\n value = value ^ ( ( value << 5 ) + ( value >> 3 ) + ( unsigned long ) ch ) ;\n }\n }\n if ( name3 != NULL ) {\n while ( ( ch = * name3 ++ ) != 0 ) {\n value = value ^ ( ( value << 5 ) + ( value >> 3 ) + ( unsigned long ) ch ) ;\n }\n }\n return ( value % table -> size ) ;\n }",
        "output": "1",
        "idx": 2905
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static hb_glyph_position_t * glyph_position_reference ( hb_glyph_position_t * g ) {\n hb_glyph_position_t * c = ( hb_glyph_position_t * ) calloc ( 1 , sizeof ( hb_glyph_position_t ) ) ;\n if ( unlikely ( ! c ) ) return NULL ;\n * c = * g ;\n return c ;\n }",
        "output": "1",
        "idx": 83
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _slurm_rpc_sib_job_unlock ( uint32_t uid , slurm_msg_t * msg ) {\n int rc ;\n sib_msg_t * sib_msg = msg -> data ;\n if ( ! msg -> conn ) {\n error ( \"Security violation, SIB_JOB_UNLOCK RPC from uid=%d\" , uid ) ;\n slurm_send_rc_msg ( msg , ESLURM_ACCESS_DENIED ) ;\n return ;\n }\n rc = fed_mgr_job_lock_unset ( sib_msg -> job_id , sib_msg -> cluster_id ) ;\n slurm_send_rc_msg ( msg , rc ) ;\n }",
        "output": "0",
        "idx": 3140
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int i2d_DSAPrivateKey_fp ( FILE * fp , DSA * dsa ) {\n return ASN1_i2d_fp_of_const ( DSA , i2d_DSAPrivateKey , fp , dsa ) ;\n }",
        "output": "0",
        "idx": 3679
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WRITE_CLASS_ENCODER ( CephXServiceTicketRequest ) struct CephXAuthorizeReply {\n uint64_t nonce_plus_one ;\n void encode ( bufferlist & bl ) const {\n __u8 struct_v = 1 ;\n : : encode ( struct_v , bl ) ;\n : : encode ( nonce_plus_one , bl ) ;\n }\n void decode ( bufferlist : : iterator & bl ) {\n __u8 struct_v ;\n : : decode ( struct_v , bl ) ;\n : : decode ( nonce_plus_one , bl ) ;\n }\n }\n ;\n WRITE_CLASS_ENCODER ( CephXAuthorizeReply ) struct CephXAuthorizer : public AuthAuthorizer {\n private : CephContext * cct ;\n public : uint64_t nonce ;\n explicit CephXAuthorizer ( CephContext * cct_ ) : AuthAuthorizer ( CEPH_AUTH_CEPHX ) , cct ( cct_ ) , nonce ( 0 ) {\n }\n bool build_authorizer ( ) ;\n bool verify_reply ( bufferlist : : iterator & reply ) override ;\n }",
        "output": "1",
        "idx": 889
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gcry_err_code_t sexp_elements_extract ( gcry_sexp_t key_sexp , const char * element_names , gcry_mpi_t * elements , const char * algo_name ) {\n gcry_err_code_t err = 0 ;\n int i , idx ;\n const char * name ;\n gcry_sexp_t list ;\n for ( name = element_names , idx = 0 ;\n * name && ! err ;\n name ++ , idx ++ ) {\n list = gcry_sexp_find_token ( key_sexp , name , 1 ) ;\n if ( ! list ) elements [ idx ] = NULL ;\n else {\n elements [ idx ] = gcry_sexp_nth_mpi ( list , 1 , GCRYMPI_FMT_USG ) ;\n gcry_sexp_release ( list ) ;\n if ( ! elements [ idx ] ) err = GPG_ERR_INV_OBJ ;\n }\n }\n if ( ! err ) {\n for ( name = element_names , i = 0 ;\n * name ;\n name ++ , i ++ ) if ( ! elements [ i ] ) break ;\n if ( * name ) {\n err = GPG_ERR_NO_OBJ ;\n if ( algo_name && ! strcmp ( algo_name , \"RSA\" ) && ! strcmp ( element_names , \"nedpqu\" ) ) {\n if ( elements [ 0 ] && elements [ 1 ] && elements [ 2 ] && ! elements [ 3 ] && ! elements [ 4 ] && ! elements [ 5 ] ) err = 0 ;\n }\n }\n }\n if ( err ) {\n for ( i = 0 ;\n i < idx ;\n i ++ ) if ( elements [ i ] ) mpi_free ( elements [ i ] ) ;\n }\n return err ;\n }",
        "output": "1",
        "idx": 150
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int parse_one_option ( const char * option ) {\n if ( skip_prefix ( option , \"max-pack-size=\" , & option ) ) {\n unsigned long v ;\n if ( ! git_parse_ulong ( option , & v ) ) return 0 ;\n if ( v < 8192 ) {\n warning ( \"max-pack-size is now in bytes, assuming --max-pack-size=%lum\" , v ) ;\n v *= 1024 * 1024 ;\n }\n else if ( v < 1024 * 1024 ) {\n warning ( \"minimum max-pack-size is 1 MiB\" ) ;\n v = 1024 * 1024 ;\n }\n max_packsize = v ;\n }\n else if ( skip_prefix ( option , \"big-file-threshold=\" , & option ) ) {\n unsigned long v ;\n if ( ! git_parse_ulong ( option , & v ) ) return 0 ;\n big_file_threshold = v ;\n }\n else if ( skip_prefix ( option , \"depth=\" , & option ) ) {\n option_depth ( option ) ;\n }\n else if ( skip_prefix ( option , \"active-branches=\" , & option ) ) {\n option_active_branches ( option ) ;\n }\n else if ( skip_prefix ( option , \"export-pack-edges=\" , & option ) ) {\n option_export_pack_edges ( option ) ;\n }\n else if ( starts_with ( option , \"quiet\" ) ) {\n show_stats = 0 ;\n }\n else if ( starts_with ( option , \"stats\" ) ) {\n show_stats = 1 ;\n }\n else {\n return 0 ;\n }\n return 1 ;\n }",
        "output": "0",
        "idx": 2218
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int monitor_key_compare ( gconstpointer a , gconstpointer data ) {\n const Monitor * monitor ;\n const Monitor * compare_monitor ;\n monitor = a ;\n compare_monitor = data ;\n if ( monitor -> client < compare_monitor -> client ) {\n return - 1 ;\n }\n if ( monitor -> client > compare_monitor -> client ) {\n return + 1 ;\n }\n if ( monitor -> file < compare_monitor -> file ) {\n return - 1 ;\n }\n if ( monitor -> file > compare_monitor -> file ) {\n return + 1 ;\n }\n return 0 ;\n }",
        "output": "0",
        "idx": 427
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( TemplateURLParserTest , PassOnHTTPS ) {\n ASSERT_NO_FATAL_FAILURE ( ParseFile ( \"https.xml\" , nullptr ) ) ;\n EXPECT_TRUE ( template_url_ ) ;\n }",
        "output": "0",
        "idx": 3425
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void y4m_convert_mono_420jpeg ( y4m_input * _y4m , unsigned char * _dst , unsigned char * _aux ) {\n int c_sz ;\n ( void ) _aux ;\n _dst += _y4m -> pic_w * _y4m -> pic_h ;\n c_sz = ( ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ) * ( ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ) ;\n memset ( _dst , 128 , c_sz * 2 ) ;\n }",
        "output": "0",
        "idx": 2954
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nlm_register_unmatched_msg ( packet_info * pinfo , tvbuff_t * tvb , int offset ) {\n nlm_msg_res_unmatched_data * umd ;\n nlm_msg_res_unmatched_data * old_umd ;\n umd = ( nlm_msg_res_unmatched_data * ) g_malloc ( sizeof ( nlm_msg_res_unmatched_data ) ) ;\n umd -> req_frame = pinfo -> fd -> num ;\n umd -> ns = pinfo -> fd -> abs_ts ;\n umd -> cookie_len = tvb_get_ntohl ( tvb , offset ) ;\n umd -> cookie = ( const guint8 * ) tvb_memdup ( NULL , tvb , offset + 4 , umd -> cookie_len ) ;\n old_umd = ( nlm_msg_res_unmatched_data * ) g_hash_table_lookup ( nlm_msg_res_unmatched , ( gconstpointer ) umd ) ;\n if ( old_umd ) {\n g_hash_table_remove ( nlm_msg_res_unmatched , ( gconstpointer ) old_umd ) ;\n g_free ( ( gpointer ) old_umd -> cookie ) ;\n g_free ( old_umd ) ;\n }\n g_hash_table_insert ( nlm_msg_res_unmatched , ( gpointer ) umd , ( gpointer ) umd ) ;\n }",
        "output": "1",
        "idx": 4112
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_SetupAcknowledge_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 428 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_SetupAcknowledge_UUIE , SetupAcknowledge_UUIE_sequence ) ;\n # line 432 \"./asn1/h225/h225.cnf\" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> cs_type = H225_SETUP_ACK ;\n g_snprintf ( h225_pi -> frame_label , 50 , \"%s\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) ) ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 3721
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int selinux_kernel_read_file ( struct file * file , enum kernel_read_file_id id ) {\n int rc = 0 ;\n switch ( id ) {\n case READING_MODULE : rc = selinux_kernel_module_from_file ( file ) ;\n break ;\n default : break ;\n }\n return rc ;\n }",
        "output": "0",
        "idx": 2068
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rfbSetServerVersionIdentity ( rfbScreenInfoPtr screen , char * fmt , ... ) {\n char buffer [ 256 ] ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n vsnprintf ( buffer , sizeof ( buffer ) - 1 , fmt , ap ) ;\n va_end ( ap ) ;\n if ( screen -> versionString != NULL ) free ( screen -> versionString ) ;\n screen -> versionString = strdup ( buffer ) ;\n }",
        "output": "0",
        "idx": 2596
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _isoent_free ( struct isoent * isoent ) {\n struct extr_rec * er , * er_next ;\n free ( isoent -> children_sorted ) ;\n free ( isoent -> identifier ) ;\n er = isoent -> extr_rec_list . first ;\n while ( er != NULL ) {\n er_next = er -> next ;\n free ( er ) ;\n er = er_next ;\n }\n free ( isoent ) ;\n }",
        "output": "0",
        "idx": 1802
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * ts_unix_format ( netdissect_options * ndo # ifndef HAVE_PCAP_SET_TSTAMP_PRECISION _U_ # endif , int sec , int usec , char * buf ) {\n const char * format ;\n # ifdef HAVE_PCAP_SET_TSTAMP_PRECISION switch ( ndo -> ndo_tstamp_precision ) {\n case PCAP_TSTAMP_PRECISION_MICRO : format = \"%u.%06u\" ;\n break ;\n case PCAP_TSTAMP_PRECISION_NANO : format = \"%u.%09u\" ;\n break ;\n default : format = \"%u.{\nunknown}\n\" ;\n break ;\n }\n # else format = \"%u.%06u\" ;\n # endif snprintf ( buf , TS_BUF_SIZE , format , ( unsigned ) sec , ( unsigned ) usec ) ;\n return buf ;\n }",
        "output": "0",
        "idx": 1732
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pbase_tree_put ( struct pbase_tree_cache * cache ) {\n if ( ! cache -> temporary ) {\n cache -> ref -- ;\n return ;\n }\n free ( cache -> tree_data ) ;\n free ( cache ) ;\n }",
        "output": "0",
        "idx": 1438
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_idct8x8_64_add_c ( const tran_low_t * input , uint8_t * dest , int stride ) {\n tran_low_t out [ 8 * 8 ] ;\n tran_low_t * outptr = out ;\n int i , j ;\n tran_low_t temp_in [ 8 ] , temp_out [ 8 ] ;\n for ( i = 0 ;\n i < 8 ;\n ++ i ) {\n idct8 ( input , outptr ) ;\n input += 8 ;\n outptr += 8 ;\n }\n for ( i = 0 ;\n i < 8 ;\n ++ i ) {\n for ( j = 0 ;\n j < 8 ;\n ++ j ) temp_in [ j ] = out [ j * 8 + i ] ;\n idct8 ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 8 ;\n ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 5 ) + dest [ j * stride + i ] ) ;\n }\n }",
        "output": "0",
        "idx": 2471
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ilbc_encode_frame ( AVCodecContext * avctx , AVPacket * avpkt , const AVFrame * frame , int * got_packet_ptr ) {\n ILBCEncContext * s = avctx -> priv_data ;\n int ret ;\n if ( ( ret = ff_alloc_packet ( avpkt , 50 ) ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"Error getting output packet\\n\" ) ;\n return ret ;\n }\n WebRtcIlbcfix_EncodeImpl ( ( WebRtc_UWord16 * ) avpkt -> data , ( const WebRtc_Word16 * ) frame -> data [ 0 ] , & s -> encoder ) ;\n avpkt -> size = s -> encoder . no_of_bytes ;\n * got_packet_ptr = 1 ;\n return 0 ;\n }",
        "output": "0",
        "idx": 2794
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void xmlrpc_char_encode ( char * outbuffer , const char * s1 ) {\n long unsigned int i ;\n unsigned char c ;\n char buf2 [ 15 ] ;\n mowgli_string_t * s = mowgli_string_create ( ) ;\n * buf2 = '\\0' ;\n * outbuffer = '\\0' ;\n if ( ( ! ( s1 ) || ( * ( s1 ) == '\\0' ) ) ) {\n return ;\n }\n for ( i = 0 ;\n s1 [ i ] != '\\0' ;\n i ++ ) {\n c = s1 [ i ] ;\n if ( c > 127 ) {\n snprintf ( buf2 , sizeof buf2 , \"&#%d;\n\" , c ) ;\n s -> append ( s , buf2 , strlen ( buf2 ) ) ;\n }\n else if ( c == '&' ) {\n s -> append ( s , \"&amp;\n\" , 5 ) ;\n }\n else if ( c == '<' ) {\n s -> append ( s , \"&lt;\n\" , 4 ) ;\n }\n else if ( c == '>' ) {\n s -> append ( s , \"&gt;\n\" , 4 ) ;\n }\n else if ( c == '\"' ) {\n s -> append ( s , \"&quot;\n\" , 6 ) ;\n }\n else {\n s -> append_char ( s , c ) ;\n }\n }\n memcpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ;\n }",
        "output": "1",
        "idx": 837
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int i2d_PKCS8_fp ( FILE * fp , X509_SIG * p8 ) {\n return ASN1_i2d_fp_of ( X509_SIG , i2d_X509_SIG , fp , p8 ) ;\n }",
        "output": "0",
        "idx": 608
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemuMonitorJSONBlockResize ( qemuMonitorPtr mon , const char * device , unsigned long long size ) {\n int ret ;\n virJSONValuePtr cmd ;\n virJSONValuePtr reply = NULL ;\n cmd = qemuMonitorJSONMakeCommand ( \"block_resize\" , \"s:device\" , device , \"U:size\" , size * 1024 , NULL ) ;\n if ( ! cmd ) return - 1 ;\n ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;\n if ( ret == 0 ) {\n if ( qemuMonitorJSONHasError ( reply , \"CommandNotFound\" ) ) {\n ret = - 2 ;\n goto cleanup ;\n }\n ret = qemuMonitorJSONCheckError ( cmd , reply ) ;\n }\n cleanup : virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }",
        "output": "0",
        "idx": 1926
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_MINIT_FUNCTION ( uwsgi_php_minit ) {\n php_session_register_module ( & ps_mod_uwsgi ) ;\n struct uwsgi_string_list * usl = uphp . constants ;\n while ( usl ) {\n char * equal = strchr ( usl -> value , '=' ) ;\n if ( equal ) {\n size_t name_len = equal - usl -> value ;\n char * name = usl -> value ;\n char * strval = equal + 1 ;\n equal = NULL ;\n # ifndef UWSGI_PHP7 name_len = name_len + 1 ;\n # endif zend_register_string_constant ( name , name_len , strval , CONST_CS | CONST_PERSISTENT , module_number TSRMLS_CC ) ;\n }\n usl = usl -> next ;\n }\n return SUCCESS ;\n }",
        "output": "0",
        "idx": 2331
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void initial_reordering_syllable ( const hb_ot_shape_plan_t * plan , hb_face_t * face , hb_buffer_t * buffer , unsigned int start , unsigned int end ) {\n syllable_type_t syllable_type = ( syllable_type_t ) ( buffer -> info [ start ] . syllable ( ) & 0x0F ) ;\n switch ( syllable_type ) {\n case consonant_syllable : initial_reordering_consonant_syllable ( plan , face , buffer , start , end ) ;\n return ;\n case vowel_syllable : initial_reordering_vowel_syllable ( plan , face , buffer , start , end ) ;\n return ;\n case standalone_cluster : initial_reordering_standalone_cluster ( plan , face , buffer , start , end ) ;\n return ;\n case symbol_cluster : initial_reordering_symbol_cluster ( plan , face , buffer , start , end ) ;\n return ;\n case broken_cluster : initial_reordering_broken_cluster ( plan , face , buffer , start , end ) ;\n return ;\n case non_indic_cluster : initial_reordering_non_indic_cluster ( plan , face , buffer , start , end ) ;\n return ;\n }\n }",
        "output": "1",
        "idx": 2950
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline uint char_val ( char X ) {\n return ( uint ) ( X >= '0' && X <= '9' ? X - '0' : X >= 'A' && X <= 'Z' ? X - 'A' + 10 : X - 'a' + 10 ) ;\n }",
        "output": "0",
        "idx": 3301
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ossl_inline sk_ ## t1 ## _compfunc sk_ ## t1 ## _set_cmp_func ( STACK_OF ( t1 ) * sk , sk_ ## t1 ## _compfunc compare ) {\n return ( sk_ ## t1 ## _compfunc ) OPENSSL_sk_set_cmp_func ( ( OPENSSL_STACK * ) sk , ( OPENSSL_sk_compfunc ) compare ) ;\n }\n # define DEFINE_SPECIAL_STACK_OF ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , t2 , t2 ) # define DEFINE_STACK_OF ( t ) SKM_DEFINE_STACK_OF ( t , t , t ) # define DEFINE_SPECIAL_STACK_OF_CONST ( t1 , t2 ) SKM_DEFINE_STACK_OF ( t1 , const t2 , t2 ) # define DEFINE_STACK_OF_CONST ( t ) SKM_DEFINE_STACK_OF ( t , const t , t ) typedef char * OPENSSL_STRING ;\n typedef const char * OPENSSL_CSTRING ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_STRING , char ) DEFINE_SPECIAL_STACK_OF_CONST ( OPENSSL_CSTRING , char ) typedef void * OPENSSL_BLOCK ;\n DEFINE_SPECIAL_STACK_OF ( OPENSSL_BLOCK , void )",
        "output": "1",
        "idx": 1505
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_user ( const char * user , struct passwd * user_info_arg ) {\n # if ! defined ( __WIN__ ) DBUG_ASSERT ( user_info_arg != 0 ) ;\n # ifdef HAVE_INITGROUPS calling_initgroups = 1 ;\n initgroups ( ( char * ) user , user_info_arg -> pw_gid ) ;\n calling_initgroups = 0 ;\n # endif if ( setgid ( user_info_arg -> pw_gid ) == - 1 ) {\n sql_perror ( \"setgid\" ) ;\n unireg_abort ( 1 ) ;\n }\n if ( setuid ( user_info_arg -> pw_uid ) == - 1 ) {\n sql_perror ( \"setuid\" ) ;\n unireg_abort ( 1 ) ;\n }\n allow_coredumps ( ) ;\n # endif }",
        "output": "0",
        "idx": 2079
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_DialingInformationNumber ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_DialingInformationNumber , DialingInformationNumber_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 1136
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( CrossOriginXHR , FileAccess ) {\n ASSERT_TRUE ( RunExtensionTest ( \"cross_origin_xhr/file_access\" ) ) << message_ ;\n }",
        "output": "1",
        "idx": 3040
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_quantize_dc_32x32 ( const int16_t * coeff_ptr , int skip_block , const int16_t * round_ptr , const int16_t quant , int16_t * qcoeff_ptr , int16_t * dqcoeff_ptr , const int16_t dequant_ptr , uint16_t * eob_ptr ) {\n const int rc = 0 ;\n const int coeff = coeff_ptr [ rc ] ;\n const int coeff_sign = ( coeff >> 31 ) ;\n const int abs_coeff = ( coeff ^ coeff_sign ) - coeff_sign ;\n int tmp , eob = - 1 ;\n if ( ! skip_block ) {\n tmp = clamp ( abs_coeff + round_ptr [ rc != 0 ] , INT16_MIN , INT16_MAX ) ;\n tmp = ( tmp * quant ) >> 15 ;\n qcoeff_ptr [ rc ] = ( tmp ^ coeff_sign ) - coeff_sign ;\n dqcoeff_ptr [ rc ] = qcoeff_ptr [ rc ] * dequant_ptr / 2 ;\n if ( tmp ) eob = 0 ;\n }\n * eob_ptr = eob + 1 ;\n }",
        "output": "1",
        "idx": 2523
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SRP_VBASE * SRP_VBASE_new ( char * seed_key ) {\n SRP_VBASE * vb = ( SRP_VBASE * ) OPENSSL_malloc ( sizeof ( SRP_VBASE ) ) ;\n if ( vb == NULL ) return NULL ;\n if ( ! ( vb -> users_pwd = sk_SRP_user_pwd_new_null ( ) ) || ! ( vb -> gN_cache = sk_SRP_gN_cache_new_null ( ) ) ) {\n OPENSSL_free ( vb ) ;\n return NULL ;\n }\n vb -> default_g = NULL ;\n vb -> default_N = NULL ;\n vb -> seed_key = NULL ;\n if ( ( seed_key != NULL ) && ( vb -> seed_key = BUF_strdup ( seed_key ) ) == NULL ) {\n sk_SRP_user_pwd_free ( vb -> users_pwd ) ;\n sk_SRP_gN_cache_free ( vb -> gN_cache ) ;\n OPENSSL_free ( vb ) ;\n return NULL ;\n }\n return vb ;\n }",
        "output": "0",
        "idx": 3596
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int jbig2_decode_halftone_mmr ( Jbig2Ctx * ctx , const Jbig2GenericRegionParams * params , const byte * data , size_t size , Jbig2Image * image , size_t * consumed_bytes ) {\n Jbig2MmrCtx mmr ;\n const int rowstride = image -> stride ;\n byte * dst = image -> data ;\n byte * ref = NULL ;\n int y ;\n int code = 0 ;\n const uint32_t EOFB = 0x001001 ;\n jbig2_decode_mmr_init ( & mmr , image -> width , image -> height , data , size ) ;\n for ( y = 0 ;\n y < image -> height ;\n y ++ ) {\n memset ( dst , 0 , rowstride ) ;\n code = jbig2_decode_mmr_line ( & mmr , ref , dst ) ;\n if ( code < 0 ) return code ;\n ref = dst ;\n dst += rowstride ;\n }\n if ( mmr . word >> 8 == EOFB ) {\n mmr . data_index += 3 ;\n }\n * consumed_bytes += mmr . data_index + ( mmr . bit_index >> 3 ) + ( mmr . bit_index > 0 ? 1 : 0 ) ;\n return code ;\n }",
        "output": "1",
        "idx": 4046
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int send_certificate_request ( SSL * s ) {\n if ( s -> verify_mode & SSL_VERIFY_PEER && ( ( s -> session -> peer == NULL ) || ! ( s -> verify_mode & SSL_VERIFY_CLIENT_ONCE ) ) && ( ! ( s -> s3 -> tmp . new_cipher -> algorithm_auth & SSL_aNULL ) || ( s -> verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT ) ) && ! ( s -> s3 -> tmp . new_cipher -> algorithm_auth & SSL_aSRP ) && ! ( s -> s3 -> tmp . new_cipher -> algorithm_auth & SSL_aPSK ) ) {\n return 1 ;\n }\n return 0 ;\n }",
        "output": "0",
        "idx": 3532
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int xmlListCopy ( xmlListPtr cur , const xmlListPtr old ) {\n xmlLinkPtr lk ;\n if ( ( old == NULL ) || ( cur == NULL ) ) return ( 1 ) ;\n for ( lk = old -> sentinel -> next ;\n lk != old -> sentinel ;\n lk = lk -> next ) {\n if ( 0 != xmlListInsert ( cur , lk -> data ) ) {\n xmlListDelete ( cur ) ;\n return ( 1 ) ;\n }\n }\n return ( 0 ) ;\n }",
        "output": "1",
        "idx": 3989
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_rc_init_minq_luts ( ) {\n int i ;\n for ( i = 0 ;\n i < QINDEX_RANGE ;\n i ++ ) {\n const double maxq = vp9_convert_qindex_to_q ( i ) ;\n kf_low_motion_minq [ i ] = get_minq_index ( maxq , 0.000001 , - 0.0004 , 0.125 ) ;\n kf_high_motion_minq [ i ] = get_minq_index ( maxq , 0.000002 , - 0.0012 , 0.50 ) ;\n arfgf_low_motion_minq [ i ] = get_minq_index ( maxq , 0.0000015 , - 0.0009 , 0.30 ) ;\n arfgf_high_motion_minq [ i ] = get_minq_index ( maxq , 0.0000021 , - 0.00125 , 0.50 ) ;\n inter_minq [ i ] = get_minq_index ( maxq , 0.00000271 , - 0.00113 , 0.90 ) ;\n rtc_minq [ i ] = get_minq_index ( maxq , 0.00000271 , - 0.00113 , 0.70 ) ;\n }\n }",
        "output": "1",
        "idx": 915
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rfbClientPtr rfbReverseConnection ( rfbScreenInfoPtr rfbScreen , char * host , int port ) {\n int sock ;\n rfbClientPtr cl ;\n if ( ( sock = rfbConnect ( rfbScreen , host , port ) ) < 0 ) return ( rfbClientPtr ) NULL ;\n cl = rfbNewClient ( rfbScreen , sock ) ;\n if ( cl ) {\n cl -> reverseConnection = TRUE ;\n }\n return cl ;\n }",
        "output": "0",
        "idx": 2259
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void apply_frame_size ( VP9_COMMON * cm , int width , int height ) {\n if ( cm -> width != width || cm -> height != height ) {\n if ( width > cm -> width || height > cm -> height ) {\n if ( vp9_resize_frame_buffers ( cm , width , height ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , \"Failed to allocate frame buffers\" ) ;\n }\n cm -> width = width ;\n cm -> height = height ;\n vp9_update_frame_size ( cm ) ;\n }\n if ( vp9_realloc_frame_buffer ( get_frame_new_buffer ( cm ) , cm -> width , cm -> height , cm -> subsampling_x , cm -> subsampling_y , VP9_DEC_BORDER_IN_PIXELS , & cm -> frame_bufs [ cm -> new_fb_idx ] . raw_frame_buffer , cm -> get_fb_cb , cm -> cb_priv ) ) {\n vpx_internal_error ( & cm -> error , VPX_CODEC_MEM_ERROR , \"Failed to allocate frame buffer\" ) ;\n }\n }",
        "output": "1",
        "idx": 3631
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int X509_REQ_sign ( X509_REQ * x , EVP_PKEY * pkey , const EVP_MD * md ) {\n return ( ASN1_item_sign ( ASN1_ITEM_rptr ( X509_REQ_INFO ) , x -> sig_alg , NULL , x -> signature , x -> req_info , pkey , md ) ) ;\n }",
        "output": "0",
        "idx": 4071
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int16_t inverse_quant ( G726Context * c , int i ) {\n int dql , dex , dqt ;\n dql = c -> tbls . iquant [ i ] + ( c -> y >> 2 ) ;\n dex = ( dql >> 7 ) & 0xf ;\n dqt = ( 1 << 7 ) + ( dql & 0x7f ) ;\n return ( dql < 0 ) ? 0 : ( ( dqt << dex ) >> 7 ) ;\n }",
        "output": "0",
        "idx": 579
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void evhttp_handle_request ( struct evhttp_request * req , void * arg ) {\n struct evhttp * http = arg ;\n struct evhttp_cb * cb = NULL ;\n if ( req -> uri == NULL ) {\n evhttp_send_error ( req , HTTP_BADREQUEST , \"Bad Request\" ) ;\n return ;\n }\n if ( ( cb = evhttp_dispatch_callback ( & http -> callbacks , req ) ) != NULL ) {\n ( * cb -> cb ) ( req , cb -> cbarg ) ;\n return ;\n }\n if ( http -> gencb ) {\n ( * http -> gencb ) ( req , http -> gencbarg ) ;\n return ;\n }\n else {\n # define ERR_FORMAT \"<html><head>\" \"<title>404 Not Found</title>\" \"</head><body>\" \"<h1>Not Found</h1>\" \"<p>The requested URL %s was not found on this server.</p>\" \"</body></html>\\n\" char * escaped_html = evhttp_htmlescape ( req -> uri ) ;\n struct evbuffer * buf = evbuffer_new ( ) ;\n evhttp_response_code ( req , HTTP_NOTFOUND , \"Not Found\" ) ;\n evbuffer_add_printf ( buf , ERR_FORMAT , escaped_html ) ;\n free ( escaped_html ) ;\n evhttp_send_page ( req , buf ) ;\n evbuffer_free ( buf ) ;\n # undef ERR_FORMAT }\n }",
        "output": "1",
        "idx": 815
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rm_read_metadata ( AVFormatContext * s , AVIOContext * pb , int wide ) {\n char buf [ 1024 ] ;\n int i ;\n for ( i = 0 ;\n i < FF_ARRAY_ELEMS ( ff_rm_metadata ) ;\n i ++ ) {\n int len = wide ? avio_rb16 ( pb ) : avio_r8 ( pb ) ;\n get_strl ( pb , buf , sizeof ( buf ) , len ) ;\n av_dict_set ( & s -> metadata , ff_rm_metadata [ i ] , buf , 0 ) ;\n }\n }",
        "output": "0",
        "idx": 3926
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t offsetTOCEntryCount ( const UDataMemory * pData ) {\n int32_t retVal = 0 ;\n const UDataOffsetTOC * toc = ( UDataOffsetTOC * ) pData -> toc ;\n if ( toc != NULL ) {\n retVal = toc -> count ;\n }\n return retVal ;\n }",
        "output": "1",
        "idx": 527
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipvideo_decode_block_opcode_0xE_16 ( IpvideoContext * s ) {\n int x , y ;\n uint16_t pix ;\n uint16_t * pixel_ptr = ( uint16_t * ) s -> pixel_ptr ;\n pix = bytestream2_get_le16 ( & s -> stream_ptr ) ;\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n for ( x = 0 ;\n x < 8 ;\n x ++ ) pixel_ptr [ x ] = pix ;\n pixel_ptr += s -> stride ;\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 4027
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ProtocolHandlerRegistryTest , IgnoreProtocolHandler ) {\n registry ( ) -> OnIgnoreRegisterProtocolHandler ( test_protocol_handler ( ) ) ;\n ASSERT_TRUE ( registry ( ) -> IsIgnored ( test_protocol_handler ( ) ) ) ;\n registry ( ) -> RemoveIgnoredHandler ( test_protocol_handler ( ) ) ;\n ASSERT_FALSE ( registry ( ) -> IsIgnored ( test_protocol_handler ( ) ) ) ;\n }",
        "output": "0",
        "idx": 3025
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE cState_array_nl_set ( VALUE self , VALUE array_nl ) {\n unsigned long len ;\n GET_STATE ( self ) ;\n Check_Type ( array_nl , T_STRING ) ;\n len = RSTRING_LEN ( array_nl ) ;\n if ( len == 0 ) {\n if ( state -> array_nl ) {\n ruby_xfree ( state -> array_nl ) ;\n state -> array_nl = NULL ;\n }\n }\n else {\n if ( state -> array_nl ) ruby_xfree ( state -> array_nl ) ;\n state -> array_nl = strdup ( RSTRING_PTR ( array_nl ) ) ;\n state -> array_nl_len = len ;\n }\n return Qnil ;\n }",
        "output": "1",
        "idx": 582
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uchar * get_key_column ( GRANT_COLUMN * buff , size_t * length , my_bool not_used __attribute__ ( ( unused ) ) ) {\n * length = buff -> key_length ;\n return ( uchar * ) buff -> column ;\n }",
        "output": "0",
        "idx": 3122
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dissect_zcl_poll_ctrl_attr_data ( proto_tree * tree , tvbuff_t * tvb , guint * offset , guint16 attr_id _U_ , guint data_type ) {\n dissect_zcl_attr_data ( tvb , tree , offset , data_type ) ;\n }",
        "output": "0",
        "idx": 3101
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline unsigned int next_commit_index ( unsigned int idx ) {\n static const unsigned int MIN_COMMITS = 100 ;\n static const unsigned int MAX_COMMITS = 5000 ;\n static const unsigned int MUST_REGION = 100 ;\n static const unsigned int MIN_REGION = 20000 ;\n unsigned int offset , next ;\n if ( idx <= MUST_REGION ) return 0 ;\n if ( idx <= MIN_REGION ) {\n offset = idx - MUST_REGION ;\n return ( offset < MIN_COMMITS ) ? offset : MIN_COMMITS ;\n }\n offset = idx - MIN_REGION ;\n next = ( offset < MAX_COMMITS ) ? offset : MAX_COMMITS ;\n return ( next > MIN_COMMITS ) ? next : MIN_COMMITS ;\n }",
        "output": "0",
        "idx": 3680
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_T_e164Address ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_restricted_character_string ( tvb , offset , actx , tree , hf_index , 1 , 128 , FALSE , \"0123456789#*,\" , 13 , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 3789
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static guint32 get_uint32 ( tvbuff_t * tvb , gint32 offset , gint encoding ) {\n return ( ENC_BIG_ENDIAN == encoding ) ? tvb_get_ntohl ( tvb , offset ) : tvb_get_letohl ( tvb , offset ) ;\n }",
        "output": "0",
        "idx": 1192
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int test_compressed_stream_overflow ( xd3_stream * stream , int ignore ) {\n int ret ;\n int i ;\n uint8_t * buf ;\n if ( ( buf = ( uint8_t * ) malloc ( TWO_MEGS_AND_DELTA ) ) == NULL ) {\n return ENOMEM ;\n }\n memset ( buf , 0 , TWO_MEGS_AND_DELTA ) ;\n for ( i = 0 ;\n i < ( 2 << 20 ) ;\n i += 256 ) {\n int j ;\n int off = mt_random ( & static_mtrand ) % 10 ;\n for ( j = 0 ;\n j < 256 ;\n j ++ ) {\n buf [ i + j ] = j + off ;\n }\n }\n if ( SIZEOF_XOFF_T == 4 ) {\n ret = test_streaming ( stream , buf , buf + ( 1 << 20 ) , buf + ( 2 << 20 ) , ( 1 << 12 ) + 1 ) ;\n if ( ret == XD3_INVALID_INPUT && MSG_IS ( \"decoder file offset overflow\" ) ) {\n ret = 0 ;\n }\n else {\n XPR ( NT XD3_LIB_ERRMSG ( stream , ret ) ) ;\n stream -> msg = \"expected overflow condition\" ;\n ret = XD3_INTERNAL ;\n goto fail ;\n }\n }\n if ( ( ret = test_streaming ( stream , buf , buf + ( 1 << 20 ) , buf + ( 2 << 20 ) , << 12 ) ) ) {\n goto fail ;\n }\n fail : free ( buf ) ;\n return ret ;\n }",
        "output": "1",
        "idx": 920
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __inline __uint64_t __uint64_identity ( __uint64_t __x ) {\n return __x ;\n }",
        "output": "1",
        "idx": 1335
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void evhttp_send ( struct evhttp_request * req , struct evbuffer * databuf ) {\n struct evhttp_connection * evcon = req -> evcon ;\n assert ( TAILQ_FIRST ( & evcon -> requests ) == req ) ;\n if ( databuf != NULL ) evbuffer_add_buffer ( req -> output_buffer , databuf ) ;\n evhttp_make_header ( evcon , req ) ;\n evhttp_write_buffer ( evcon , evhttp_send_done , NULL ) ;\n }",
        "output": "1",
        "idx": 1350
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_INTEGER_1_32 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 1U , 32U , NULL , FALSE ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 719
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char * curl_easy_unescape ( struct Curl_easy * data , const char * string , int length , int * olen ) {\n char * str = NULL ;\n if ( length >= 0 ) {\n size_t inputlen = length ;\n size_t outputlen ;\n CURLcode res = Curl_urldecode ( data , string , inputlen , & str , & outputlen , FALSE ) ;\n if ( res ) return NULL ;\n if ( olen ) * olen = curlx_uztosi ( outputlen ) ;\n }\n return str ;\n }",
        "output": "1",
        "idx": 1514
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void decode_color_temperature ( gchar * s , guint16 value ) {\n if ( value == 0 ) {\n g_snprintf ( s , ITEM_LABEL_LENGTH , \"%u [Mired]\" , value ) ;\n }\n else {\n g_snprintf ( s , ITEM_LABEL_LENGTH , \"%u [Mired] (%u [K])\" , value , 1000000 / value ) ;\n }\n return ;\n }",
        "output": "0",
        "idx": 907
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _CompoundTextClose ( UConverter * converter ) {\n UConverterDataCompoundText * myConverterData = ( UConverterDataCompoundText * ) ( converter -> extraInfo ) ;\n int32_t i ;\n if ( converter -> extraInfo != NULL ) {\n for ( i = 0 ;\n i < NUM_OF_CONVERTERS ;\n i ++ ) {\n if ( myConverterData -> myConverterArray [ i ] != NULL ) {\n ucnv_unloadSharedDataIfReady ( myConverterData -> myConverterArray [ i ] ) ;\n }\n }\n uprv_free ( converter -> extraInfo ) ;\n }\n }",
        "output": "1",
        "idx": 2740
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void one_remote_ref ( const char * refname ) {\n struct ref * ref ;\n struct object * obj ;\n ref = alloc_ref ( refname ) ;\n if ( http_fetch_ref ( repo -> url , ref ) != 0 ) {\n fprintf ( stderr , \"Unable to fetch ref %s from %s\\n\" , refname , repo -> url ) ;\n free ( ref ) ;\n return ;\n }\n if ( repo -> can_update_info_refs && ! has_object_file ( & ref -> old_oid ) ) {\n obj = lookup_unknown_object ( ref -> old_oid . hash ) ;\n if ( obj ) {\n fprintf ( stderr , \" fetch %s for %s\\n\" , oid_to_hex ( & ref -> old_oid ) , refname ) ;\n add_fetch_request ( obj ) ;\n }\n }\n ref -> next = remote_refs ;\n remote_refs = ref ;\n }",
        "output": "0",
        "idx": 1308
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void * main_malloc ( size_t size ) {\n void * r = main_malloc1 ( size ) ;\n if ( r ) {\n IF_DEBUG ( main_mallocs += 1 ) ;\n }\n return r ;\n }",
        "output": "0",
        "idx": 4318
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileObject , eof ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n RETURN_BOOL ( php_stream_eof ( intern -> u . file . stream ) ) ;\n }",
        "output": "1",
        "idx": 4012
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int option_parse_unpack_unreachable ( const struct option * opt , const char * arg , int unset ) {\n if ( unset ) {\n unpack_unreachable = 0 ;\n unpack_unreachable_expiration = 0 ;\n }\n else {\n unpack_unreachable = 1 ;\n if ( arg ) unpack_unreachable_expiration = approxidate ( arg ) ;\n }\n return 0 ;\n }",
        "output": "0",
        "idx": 529
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST ( DownloadPrefsTest , NoAutoOpenForDisallowedFileTypes ) {\n const base : : FilePath kDangerousFilePath ( FILE_PATH_LITERAL ( \"/b/very-bad.swf\" ) ) ;\n content : : TestBrowserThreadBundle threads_are_required_for_testing_profile ;\n TestingProfile profile ;\n DownloadPrefs prefs ( & profile ) ;\n EXPECT_FALSE ( prefs . EnableAutoOpenBasedOnExtension ( kDangerousFilePath ) ) ;\n EXPECT_FALSE ( prefs . IsAutoOpenEnabledBasedOnExtension ( kDangerousFilePath ) ) ;\n }",
        "output": "0",
        "idx": 2520
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_lpf_horizontal_16_sse2 ( unsigned char * s , int p , const unsigned char * _blimit , const unsigned char * _limit , const unsigned char * _thresh , int count ) {\n if ( count == 1 ) mb_lpf_horizontal_edge_w_sse2_8 ( s , p , _blimit , _limit , _thresh ) ;\n else mb_lpf_horizontal_edge_w_sse2_16 ( s , p , _blimit , _limit , _thresh ) ;\n }",
        "output": "1",
        "idx": 3459
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int libspeex_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n LibSpeexContext * s = avctx -> priv_data ;\n AVFrame * frame = data ;\n int16_t * output ;\n int ret , consumed = 0 ;\n frame -> nb_samples = s -> frame_size ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n output = ( int16_t * ) frame -> data [ 0 ] ;\n if ( speex_bits_remaining ( & s -> bits ) < 5 || speex_bits_peek_unsigned ( & s -> bits , 5 ) == 0x1F ) {\n if ( ! buf || ! buf_size ) {\n * got_frame_ptr = 0 ;\n return buf_size ;\n }\n speex_bits_read_from ( & s -> bits , buf , buf_size ) ;\n consumed = buf_size ;\n }\n ret = speex_decode_int ( s -> dec_state , & s -> bits , output ) ;\n if ( ret <= - 2 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Error decoding Speex frame.\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( avctx -> channels == 2 ) speex_decode_stereo_int ( output , s -> frame_size , & s -> stereo ) ;\n * got_frame_ptr = 1 ;\n return consumed ;\n }",
        "output": "1",
        "idx": 1379
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned int get_joining_type ( hb_codepoint_t u , hb_unicode_general_category_t gen_cat ) {\n unsigned int j_type = joining_type ( u ) ;\n if ( likely ( j_type != JOINING_TYPE_X ) ) return j_type ;\n return ( FLAG ( gen_cat ) & ( FLAG ( HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK ) | FLAG ( HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK ) | FLAG ( HB_UNICODE_GENERAL_CATEGORY_FORMAT ) ) ) ? JOINING_TYPE_T : JOINING_TYPE_U ;\n }",
        "output": "1",
        "idx": 428
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int evbuffer_remove ( struct evbuffer * buf , void * data , size_t datlen ) {\n size_t nread = datlen ;\n if ( nread >= buf -> off ) nread = buf -> off ;\n memcpy ( data , buf -> buffer , nread ) ;\n evbuffer_drain ( buf , nread ) ;\n return ( nread ) ;\n }",
        "output": "0",
        "idx": 3937
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vpx_codec_err_t vpx_svc_set_quantizers ( SvcContext * svc_ctx , const char * quantizers ) {\n SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n if ( svc_ctx == NULL || quantizers == NULL || si == NULL ) {\n return VPX_CODEC_INVALID_PARAM ;\n }\n strncpy ( si -> quantizers , quantizers , sizeof ( si -> quantizers ) ) ;\n si -> quantizers [ sizeof ( si -> quantizers ) - 1 ] = '\\0' ;\n return VPX_CODEC_OK ;\n }",
        "output": "1",
        "idx": 4075
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void option_depth ( const char * depth ) {\n max_depth = ulong_arg ( \"--depth\" , depth ) ;\n if ( max_depth > MAX_DEPTH ) die ( \"--depth cannot exceed %u\" , MAX_DEPTH ) ;\n }",
        "output": "0",
        "idx": 477
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int TSMimeHdrFieldEqual ( TSMBuffer bufp , TSMLoc hdr_obj , TSMLoc field1_obj , TSMLoc field2_obj ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_field_handle ( field1_obj , hdr_obj ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_field_handle ( field2_obj , hdr_obj ) == TS_SUCCESS ) ;\n MIMEFieldSDKHandle * field1_handle = ( MIMEFieldSDKHandle * ) field1_obj ;\n MIMEFieldSDKHandle * field2_handle = ( MIMEFieldSDKHandle * ) field2_obj ;\n if ( ( field1_handle == nullptr ) || ( field2_handle == nullptr ) ) {\n return ( field1_handle == field2_handle ) ;\n }\n return ( field1_handle -> field_ptr == field2_handle -> field_ptr ) ;\n }",
        "output": "0",
        "idx": 1580
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE cState_array_nl_set ( VALUE self , VALUE array_nl ) {\n unsigned long len ;\n GET_STATE ( self ) ;\n Check_Type ( array_nl , T_STRING ) ;\n len = RSTRING_LEN ( array_nl ) ;\n if ( len == 0 ) {\n if ( state -> array_nl ) {\n ruby_xfree ( state -> array_nl ) ;\n state -> array_nl = NULL ;\n }\n }\n else {\n if ( state -> array_nl ) ruby_xfree ( state -> array_nl ) ;\n state -> array_nl = fstrndup ( RSTRING_PTR ( array_nl ) , len ) ;\n state -> array_nl_len = len ;\n }\n return Qnil ;\n }",
        "output": "0",
        "idx": 3462
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char * TSHttpHdrMethodGet ( TSMBuffer bufp , TSMLoc obj , int * length ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_http_hdr_handle ( obj ) == TS_SUCCESS ) ;\n sdk_assert ( sdk_sanity_check_null_ptr ( ( void * ) length ) == TS_SUCCESS ) ;\n HTTPHdr h ;\n SET_HTTP_HDR ( h , bufp , obj ) ;\n return h . method_get ( length ) ;\n }",
        "output": "0",
        "idx": 182
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mark_commit ( struct commit * c , void * data ) {\n mark_object ( & c -> object , NULL , NULL , data ) ;\n }",
        "output": "1",
        "idx": 3500
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xhci_run ( XHCIState * xhci ) {\n trace_usb_xhci_run ( ) ;\n xhci -> usbsts &= ~ USBSTS_HCH ;\n xhci -> mfindex_start = qemu_clock_get_ns ( QEMU_CLOCK_VIRTUAL ) ;\n }",
        "output": "0",
        "idx": 3062
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static enum nss_status gaih_getanswer ( const querybuf * answer1 , int anslen1 , const querybuf * answer2 , int anslen2 , const char * qname , struct gaih_addrtuple * * pat , char * buffer , size_t buflen , int * errnop , int * h_errnop , int32_t * ttlp ) {\n int first = 1 ;\n enum nss_status status = NSS_STATUS_NOTFOUND ;\n if ( anslen1 > 0 ) status = gaih_getanswer_slice ( answer1 , anslen1 , qname , & pat , & buffer , & buflen , errnop , h_errnop , ttlp , & first ) ;\n if ( ( status == NSS_STATUS_SUCCESS || status == NSS_STATUS_NOTFOUND || ( status == NSS_STATUS_TRYAGAIN && ( * errnop != ERANGE || * h_errnop == NO_RECOVERY ) ) ) && answer2 != NULL && anslen2 > 0 ) {\n enum nss_status status2 = gaih_getanswer_slice ( answer2 , anslen2 , qname , & pat , & buffer , & buflen , errnop , h_errnop , ttlp , & first ) ;\n if ( status != NSS_STATUS_SUCCESS && status2 != NSS_STATUS_NOTFOUND ) status = status2 ;\n }\n return status ;\n }",
        "output": "0",
        "idx": 2951
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _HZOpen ( UConverter * cnv , UConverterLoadArgs * pArgs , UErrorCode * errorCode ) {\n UConverter * gbConverter ;\n if ( pArgs -> onlyTestIsLoadable ) {\n ucnv_canCreateConverter ( \"GBK\" , errorCode ) ;\n return ;\n }\n gbConverter = ucnv_open ( \"GBK\" , errorCode ) ;\n if ( U_FAILURE ( * errorCode ) ) {\n return ;\n }\n cnv -> toUnicodeStatus = 0 ;\n cnv -> fromUnicodeStatus = 0 ;\n cnv -> mode = 0 ;\n cnv -> fromUChar32 = 0x0000 ;\n cnv -> extraInfo = uprv_calloc ( 1 , sizeof ( UConverterDataHZ ) ) ;\n if ( cnv -> extraInfo != NULL ) {\n ( ( UConverterDataHZ * ) cnv -> extraInfo ) -> gbConverter = gbConverter ;\n }\n else {\n ucnv_close ( gbConverter ) ;\n * errorCode = U_MEMORY_ALLOCATION_ERROR ;\n return ;\n }\n }",
        "output": "1",
        "idx": 3243
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_CloseLogicalChannelAck ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_CloseLogicalChannelAck , CloseLogicalChannelAck_sequence ) ;\n # line 554 \"../../asn1/h245/h245.cnf\" if ( h245_pi != NULL ) h245_pi -> msg_type = H245_CloseLogChnAck ;\n return offset ;\n }",
        "output": "0",
        "idx": 1070
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( WebFrameTest , ContextMenuDataNonLocatedMenu ) {\n ContextMenuWebFrameClient frame ;\n FrameTestHelpers : : WebViewHelper web_view_helper ;\n WebViewImpl * web_view = web_view_helper . Initialize ( & frame ) ;\n const std : : string & html = \"<div style='font-size: 1000%;\n line-height: 0.7em'>Select me<br/>\" \"Next line</div>\" ;\n FrameTestHelpers : : LoadHTMLString ( web_view -> MainFrameImpl ( ) , html , ToKURL ( \"about:blank\" ) ) ;\n web_view -> Resize ( WebSize ( 500 , 300 ) ) ;\n web_view -> UpdateAllLifecyclePhases ( ) ;\n RunPendingTasks ( ) ;\n web_view -> SetInitialFocus ( false ) ;\n RunPendingTasks ( ) ;\n WebMouseEvent mouse_event ( WebInputEvent : : kMouseDown , WebInputEvent : : kNoModifiers , WebInputEvent : : GetStaticTimeStampForTests ( ) ) ;\n mouse_event . button = WebMouseEvent : : Button : : kLeft ;\n mouse_event . SetPositionInWidget ( 0 , 0 ) ;\n mouse_event . click_count = 2 ;\n web_view -> HandleInputEvent ( WebCoalescedInputEvent ( mouse_event ) ) ;\n web_view -> ShowContextMenu ( kMenuSourceTouch ) ;\n RunPendingTasks ( ) ;\n web_view_helper . Reset ( ) ;\n EXPECT_EQ ( frame . GetMenuData ( ) . source_type , kMenuSourceTouch ) ;\n EXPECT_FALSE ( frame . GetMenuData ( ) . selected_text . IsEmpty ( ) ) ;\n }",
        "output": "0",
        "idx": 3375
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_T_empty_flg ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 375 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n offset = dissect_per_null ( tvb , offset , actx , tree , hf_index ) ;\n # line 379 \"./asn1/h225/h225.cnf\" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> cs_type = H225_EMPTY ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 4129
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int linux_udev_stop_event_monitor ( void ) {\n char dummy = 1 ;\n int r ;\n assert ( udev_ctx != NULL ) ;\n assert ( udev_monitor != NULL ) ;\n assert ( udev_monitor_fd != - 1 ) ;\n r = usbi_write ( udev_control_pipe [ 1 ] , & dummy , sizeof ( dummy ) ) ;\n if ( r <= 0 ) {\n usbi_warn ( NULL , \"udev control pipe signal failed\" ) ;\n }\n pthread_join ( linux_event_thread , NULL ) ;\n udev_monitor_unref ( udev_monitor ) ;\n udev_monitor = NULL ;\n udev_monitor_fd = - 1 ;\n udev_unref ( udev_ctx ) ;\n udev_ctx = NULL ;\n close ( udev_control_pipe [ 0 ] ) ;\n close ( udev_control_pipe [ 1 ] ) ;\n udev_control_pipe [ 0 ] = - 1 ;\n udev_control_pipe [ 1 ] = - 1 ;\n return LIBUSB_SUCCESS ;\n }",
        "output": "1",
        "idx": 1116
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( RecursiveDirectoryIterator , getSubPath ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n if ( intern -> u . dir . sub_path ) {\n RETURN_STRINGL ( intern -> u . dir . sub_path , intern -> u . dir . sub_path_len , 1 ) ;\n }\n else {\n RETURN_STRINGL ( \"\" , 0 , 1 ) ;\n }\n }",
        "output": "1",
        "idx": 3948
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void indent ( int32_t count , FILE * f ) {\n char c [ BUF_SIZE ] ;\n if ( count <= 0 ) {\n return ;\n }\n if ( count < BUF_SIZE ) {\n memset ( c , ( int ) ' ' , count ) ;\n fwrite ( c , sizeof ( char ) , count , f ) ;\n }\n else {\n int32_t i ;\n for ( i = 0 ;\n i < count ;\n ++ i ) putc ( ' ' , f ) ;\n }\n }",
        "output": "0",
        "idx": 4300
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int read_sbr_single_channel_element ( AACContext * ac , SpectralBandReplication * sbr , GetBitContext * gb ) {\n if ( get_bits1 ( gb ) ) skip_bits ( gb , 4 ) ;\n if ( read_sbr_grid ( ac , sbr , gb , & sbr -> data [ 0 ] ) ) return - 1 ;\n read_sbr_dtdf ( sbr , gb , & sbr -> data [ 0 ] ) ;\n read_sbr_invf ( sbr , gb , & sbr -> data [ 0 ] ) ;\n read_sbr_envelope ( sbr , gb , & sbr -> data [ 0 ] , 0 ) ;\n read_sbr_noise ( sbr , gb , & sbr -> data [ 0 ] , 0 ) ;\n if ( ( sbr -> data [ 0 ] . bs_add_harmonic_flag = get_bits1 ( gb ) ) ) get_bits1_vector ( gb , sbr -> data [ 0 ] . bs_add_harmonic , sbr -> n [ 1 ] ) ;\n return 0 ;\n }",
        "output": "1",
        "idx": 1466
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlChar * xsltEvalTemplateString ( xsltTransformContextPtr ctxt , xmlNodePtr contextNode , xmlNodePtr inst ) {\n xmlNodePtr oldInsert , insert = NULL ;\n xmlChar * ret ;\n if ( ( ctxt == NULL ) || ( contextNode == NULL ) || ( inst == NULL ) ) return ( NULL ) ;\n if ( inst -> children == NULL ) return ( NULL ) ;\n insert = xmlNewDocNode ( ctxt -> output , NULL , ( const xmlChar * ) \"fake\" , NULL ) ;\n if ( insert == NULL ) {\n xsltTransformError ( ctxt , NULL , contextNode , \"Failed to create temporary node\\n\" ) ;\n return ( NULL ) ;\n }\n oldInsert = ctxt -> insert ;\n ctxt -> insert = insert ;\n xsltApplyOneTemplate ( ctxt , contextNode , inst -> children , NULL , NULL ) ;\n ctxt -> insert = oldInsert ;\n ret = xmlNodeGetContent ( insert ) ;\n if ( insert != NULL ) xmlFreeNode ( insert ) ;\n return ( ret ) ;\n }",
        "output": "1",
        "idx": 4003
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _Latin1GetUnicodeSet ( const UConverter * cnv , const USetAdder * sa , UConverterUnicodeSet which , UErrorCode * pErrorCode ) {\n sa -> addRange ( sa -> set , 0 , 0xff ) ;\n }",
        "output": "1",
        "idx": 3687
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void show_object ( struct object * obj , const struct name_path * path , const char * last , void * data ) {\n char * name = path_name ( path , last ) ;\n add_preferred_base_object ( name ) ;\n add_object_entry ( obj -> oid . hash , obj -> type , name , 0 ) ;\n obj -> flags |= OBJECT_ADDED ;\n free ( ( char * ) name ) ;\n }",
        "output": "1",
        "idx": 2071
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_lpf_vertical_8_sse2 ( unsigned char * s , int p , const unsigned char * blimit , const unsigned char * limit , const unsigned char * thresh , int count ) {\n DECLARE_ALIGNED_ARRAY ( 8 , unsigned char , t_dst , 8 * 8 ) ;\n unsigned char * src [ 1 ] ;\n unsigned char * dst [ 1 ] ;\n ( void ) count ;\n src [ 0 ] = s - 4 ;\n dst [ 0 ] = t_dst ;\n transpose ( src , p , dst , 8 , 1 ) ;\n vp9_lpf_horizontal_8_sse2 ( t_dst + 4 * 8 , 8 , blimit , limit , thresh , 1 ) ;\n src [ 0 ] = t_dst ;\n dst [ 0 ] = s - 4 ;\n transpose ( src , 8 , dst , p , 1 ) ;\n }",
        "output": "1",
        "idx": 2217
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parse_content_disposition ( const char * content_disposition , const char * * filename_r ) {\n struct rfc822_parser_context parser ;\n const char * const * results , * filename2 ;\n string_t * str ;\n * filename_r = NULL ;\n if ( content_disposition == NULL ) return ;\n rfc822_parser_init ( & parser , ( const unsigned char * ) content_disposition , strlen ( content_disposition ) , NULL ) ;\n rfc822_skip_lwsp ( & parser ) ;\n str = t_str_new ( 32 ) ;\n if ( rfc822_parse_mime_token ( & parser , str ) < 0 ) return ;\n rfc2231_parse ( & parser , & results ) ;\n filename2 = NULL ;\n for ( ;\n * results != NULL ;\n results += 2 ) {\n if ( strcasecmp ( results [ 0 ] , \"filename\" ) == 0 ) {\n * filename_r = results [ 1 ] ;\n break ;\n }\n if ( strcasecmp ( results [ 0 ] , \"filename*\" ) == 0 ) filename2 = results [ 1 ] ;\n }\n if ( * filename_r == NULL ) {\n * filename_r = filename2 ;\n }\n }",
        "output": "1",
        "idx": 4100
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static apr_status_t modsecurity_process_phase_response_headers ( modsec_rec * msr ) {\n apr_time_t time_before ;\n apr_status_t rc = 0 ;\n if ( msr -> allow_scope == ACTION_ALLOW ) {\n if ( msr -> txcfg -> debuglog_level >= 4 ) {\n msr_log ( msr , 4 , \"Skipping phase RESPONSE_HEADERS (allow used).\" ) ;\n }\n return 0 ;\n }\n else {\n if ( msr -> txcfg -> debuglog_level >= 4 ) {\n msr_log ( msr , 4 , \"Starting phase RESPONSE_HEADERS.\" ) ;\n }\n }\n time_before = apr_time_now ( ) ;\n if ( msr -> txcfg -> ruleset != NULL ) {\n rc = msre_ruleset_process_phase ( msr -> txcfg -> ruleset , msr ) ;\n }\n msr -> time_phase3 = apr_time_now ( ) - time_before ;\n return rc ;\n }",
        "output": "0",
        "idx": 2010
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static UChar32 _Latin1GetNextUChar ( UConverterToUnicodeArgs * pArgs , UErrorCode * pErrorCode ) {\n const uint8_t * source = ( const uint8_t * ) pArgs -> source ;\n if ( source < ( const uint8_t * ) pArgs -> sourceLimit ) {\n pArgs -> source = ( const char * ) ( source + 1 ) ;\n return * source ;\n }\n * pErrorCode = U_INDEX_OUTOFBOUNDS_ERROR ;\n return 0xffff ;\n }",
        "output": "1",
        "idx": 411
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mbfl_oddlen ( mbfl_string * string ) {\n int len , n , m , k ;\n unsigned char * p ;\n const unsigned char * mbtab ;\n const mbfl_encoding * encoding ;\n if ( string == NULL ) {\n return - 1 ;\n }\n encoding = mbfl_no2encoding ( string -> no_encoding ) ;\n if ( encoding == NULL ) {\n return - 1 ;\n }\n len = 0 ;\n if ( encoding -> flag & MBFL_ENCTYPE_SBCS ) {\n return 0 ;\n }\n else if ( encoding -> flag & ( MBFL_ENCTYPE_WCS2BE | MBFL_ENCTYPE_WCS2LE ) ) {\n return len % 2 ;\n }\n else if ( encoding -> flag & ( MBFL_ENCTYPE_WCS4BE | MBFL_ENCTYPE_WCS4LE ) ) {\n return len % 4 ;\n }\n else if ( encoding -> mblen_table != NULL ) {\n mbtab = encoding -> mblen_table ;\n n = 0 ;\n p = string -> val ;\n k = string -> len ;\n if ( p != NULL ) {\n while ( n < k ) {\n m = mbtab [ * p ] ;\n n += m ;\n p += m ;\n }\n ;\n }\n return n - k ;\n }\n else {\n return 0 ;\n }\n }",
        "output": "1",
        "idx": 1790
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_quantize_dc ( const int16_t * coeff_ptr , int skip_block , const int16_t * round_ptr , const int16_t quant , int16_t * qcoeff_ptr , int16_t * dqcoeff_ptr , const int16_t dequant_ptr , uint16_t * eob_ptr ) {\n const int rc = 0 ;\n const int coeff = coeff_ptr [ rc ] ;\n const int coeff_sign = ( coeff >> 31 ) ;\n const int abs_coeff = ( coeff ^ coeff_sign ) - coeff_sign ;\n int tmp , eob = - 1 ;\n if ( ! skip_block ) {\n tmp = clamp ( abs_coeff + round_ptr [ rc != 0 ] , INT16_MIN , INT16_MAX ) ;\n tmp = ( tmp * quant ) >> 16 ;\n qcoeff_ptr [ rc ] = ( tmp ^ coeff_sign ) - coeff_sign ;\n dqcoeff_ptr [ rc ] = qcoeff_ptr [ rc ] * dequant_ptr ;\n if ( tmp ) eob = 0 ;\n }\n * eob_ptr = eob + 1 ;\n }",
        "output": "1",
        "idx": 2223
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_ParallelH245Control_item ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 361 \"./asn1/h225/h225.cnf\" tvbuff_t * h245_tvb = NULL ;\n offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , NO_BOUND , NO_BOUND , FALSE , & h245_tvb ) ;\n next_tvb_add_handle ( & h245_list , h245_tvb , ( h225_h245_in_tree ) ? tree : NULL , h245dg_handle ) ;\n return offset ;\n }",
        "output": "1",
        "idx": 1575
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int opt_show_ ## section ( const char * opt , const char * arg ) {\n mark_section_show_entries ( SECTION_ID_ ## target_section_id , 1 , NULL ) ;\n return 0 ;\n }\n DEFINE_OPT_SHOW_SECTION ( chapters , CHAPTERS ) DEFINE_OPT_SHOW_SECTION ( error , ERROR ) DEFINE_OPT_SHOW_SECTION ( format , FORMAT ) DEFINE_OPT_SHOW_SECTION ( frames , FRAMES ) DEFINE_OPT_SHOW_SECTION ( library_versions , LIBRARY_VERSIONS ) DEFINE_OPT_SHOW_SECTION ( packets , PACKETS )",
        "output": "0",
        "idx": 280
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void pkg_deleteList ( CharList * l ) {\n CharList * tmp ;\n while ( l != NULL ) {\n uprv_free ( ( void * ) l -> str ) ;\n tmp = l ;\n l = l -> next ;\n uprv_free ( tmp ) ;\n }\n }",
        "output": "0",
        "idx": 3555
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MIMEField * _mime_hdr_field_list_search_by_slotnum ( MIMEHdrImpl * mh , int slotnum ) {\n unsigned int block_num , block_index ;\n MIMEFieldBlockImpl * fblock ;\n if ( slotnum < MIME_FIELD_BLOCK_SLOTS ) {\n fblock = & ( mh -> m_first_fblock ) ;\n block_index = slotnum ;\n if ( block_index >= fblock -> m_freetop ) {\n return nullptr ;\n }\n else {\n return & ( fblock -> m_field_slots [ block_index ] ) ;\n }\n }\n else {\n block_num = slotnum / MIME_FIELD_BLOCK_SLOTS ;\n block_index = slotnum % MIME_FIELD_BLOCK_SLOTS ;\n fblock = & ( mh -> m_first_fblock ) ;\n while ( block_num -- && fblock ) {\n fblock = fblock -> m_next ;\n }\n if ( ( fblock == nullptr ) || ( block_index >= fblock -> m_freetop ) ) {\n return nullptr ;\n }\n else {\n return & ( fblock -> m_field_slots [ block_index ] ) ;\n }\n }\n }",
        "output": "0",
        "idx": 2757
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_MultiplexEntrySend ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_MultiplexEntrySend , MultiplexEntrySend_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 2237
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void hscroll ( AVCodecContext * avctx ) {\n AnsiContext * s = avctx -> priv_data ;\n int i ;\n if ( s -> y < avctx -> height - s -> font_height ) {\n s -> y += s -> font_height ;\n return ;\n }\n i = 0 ;\n for ( ;\n i < avctx -> height - s -> font_height ;\n i ++ ) memcpy ( s -> frame . data [ 0 ] + i * s -> frame . linesize [ 0 ] , s -> frame . data [ 0 ] + ( i + s -> font_height ) * s -> frame . linesize [ 0 ] , avctx -> width ) ;\n for ( ;\n i < avctx -> height ;\n i ++ ) memset ( s -> frame . data [ 0 ] + i * s -> frame . linesize [ 0 ] , DEFAULT_BG_COLOR , avctx -> width ) ;\n }",
        "output": "1",
        "idx": 387
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rpza_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n RpzaContext * s = avctx -> priv_data ;\n int ret ;\n s -> buf = buf ;\n s -> size = buf_size ;\n s -> frame . reference = 1 ;\n s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n rpza_decode_stream ( s ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return buf_size ;\n }",
        "output": "1",
        "idx": 3556
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , LoadingMetrics ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n auto waiter = CreatePageLoadMetricsWaiter ( ) ;\n waiter -> AddPageExpectation ( TimingField : : LOAD_TIMING_INFO ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( \"/title1.html\" ) ) ;\n waiter -> Wait ( ) ;\n }",
        "output": "0",
        "idx": 317
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_delta ( struct rev_info * revs , struct remote_lock * lock ) {\n int i ;\n struct commit * commit ;\n struct object_list * * p = & objects ;\n int count = 0 ;\n while ( ( commit = get_revision ( revs ) ) != NULL ) {\n p = process_tree ( commit -> tree , p , NULL , \"\" ) ;\n commit -> object . flags |= LOCAL ;\n if ( ! ( commit -> object . flags & UNINTERESTING ) ) count += add_send_request ( & commit -> object , lock ) ;\n }\n for ( i = 0 ;\n i < revs -> pending . nr ;\n i ++ ) {\n struct object_array_entry * entry = revs -> pending . objects + i ;\n struct object * obj = entry -> item ;\n const char * name = entry -> name ;\n if ( obj -> flags & ( UNINTERESTING | SEEN ) ) continue ;\n if ( obj -> type == OBJ_TAG ) {\n obj -> flags |= SEEN ;\n p = add_one_object ( obj , p ) ;\n continue ;\n }\n if ( obj -> type == OBJ_TREE ) {\n p = process_tree ( ( struct tree * ) obj , p , NULL , name ) ;\n continue ;\n }\n if ( obj -> type == OBJ_BLOB ) {\n p = process_blob ( ( struct blob * ) obj , p , NULL , name ) ;\n continue ;\n }\n die ( \"unknown pending object %s (%s)\" , oid_to_hex ( & obj -> oid ) , name ) ;\n }\n while ( objects ) {\n if ( ! ( objects -> item -> flags & UNINTERESTING ) ) count += add_send_request ( objects -> item , lock ) ;\n objects = objects -> next ;\n }\n return count ;\n }",
        "output": "1",
        "idx": 4329
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dec_lpc_spectrum_inv ( TwinContext * tctx , float * lsp , enum FrameType ftype , float * lpc ) {\n int i ;\n int size = tctx -> mtab -> size / tctx -> mtab -> fmode [ ftype ] . sub ;\n for ( i = 0 ;\n i < tctx -> mtab -> n_lsp ;\n i ++ ) lsp [ i ] = 2 * cos ( lsp [ i ] ) ;\n switch ( ftype ) {\n case FT_LONG : eval_lpcenv_2parts ( tctx , ftype , lsp , lpc , size , 8 ) ;\n break ;\n case FT_MEDIUM : eval_lpcenv_2parts ( tctx , ftype , lsp , lpc , size , 2 ) ;\n break ;\n case FT_SHORT : eval_lpcenv ( tctx , lsp , lpc ) ;\n break ;\n }\n }",
        "output": "0",
        "idx": 4014
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fixup ( UScriptRun * scriptRun , UScriptCode scriptCode ) {\n int32_t fixupSP = DEC ( scriptRun -> parenSP , scriptRun -> fixupCount ) ;\n while ( scriptRun -> fixupCount -- > 0 ) {\n fixupSP = INC1 ( fixupSP ) ;\n scriptRun -> parenStack [ fixupSP ] . scriptCode = scriptCode ;\n }\n }",
        "output": "0",
        "idx": 2411
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ProtocolHandlerRegistryTest , TestDisablePreventsHandling ) {\n ProtocolHandler ph1 = CreateProtocolHandler ( \"test\" , \"test1\" ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;\n ASSERT_TRUE ( registry ( ) -> IsHandledProtocol ( \"test\" ) ) ;\n registry ( ) -> Disable ( ) ;\n ASSERT_FALSE ( registry ( ) -> IsHandledProtocol ( \"test\" ) ) ;\n }",
        "output": "0",
        "idx": 565
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void tee_puts ( const char * s , FILE * file ) {\n fputs ( s , file ) ;\n fputc ( '\\n' , file ) ;\n if ( opt_outfile ) {\n fputs ( s , OUTFILE ) ;\n fputc ( '\\n' , OUTFILE ) ;\n }\n }",
        "output": "0",
        "idx": 3336
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "proto_item * proto_tree_add_int ( proto_tree * tree , int hfindex , tvbuff_t * tvb , gint start , gint length , gint32 value ) {\n proto_item * pi = NULL ;\n header_field_info * hfinfo ;\n CHECK_FOR_NULL_TREE ( tree ) ;\n TRY_TO_FAKE_THIS_ITEM ( tree , hfindex , hfinfo ) ;\n switch ( hfinfo -> type ) {\n case FT_INT8 : case FT_INT16 : case FT_INT24 : case FT_INT32 : pi = proto_tree_add_pi ( tree , hfinfo , tvb , start , & length ) ;\n proto_tree_set_int ( PNODE_FINFO ( pi ) , value ) ;\n break ;\n default : DISSECTOR_ASSERT_NOT_REACHED ( ) ;\n }\n return pi ;\n }",
        "output": "0",
        "idx": 4050
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void printFirst ( UBreakIterator * boundary , UChar * str ) {\n int32_t end ;\n int32_t start = ubrk_first ( boundary ) ;\n end = ubrk_next ( boundary ) ;\n printTextRange ( str , start , end ) ;\n }",
        "output": "0",
        "idx": 3220
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cirrus_mem_writeb_mode4and5_8bpp ( CirrusVGAState * s , unsigned mode , unsigned offset , uint32_t mem_value ) {\n int x ;\n unsigned val = mem_value ;\n uint8_t * dst ;\n dst = s -> vga . vram_ptr + ( offset &= s -> cirrus_addr_mask ) ;\n for ( x = 0 ;\n x < 8 ;\n x ++ ) {\n if ( val & 0x80 ) {\n * dst = s -> cirrus_shadow_gr1 ;\n }\n else if ( mode == 5 ) {\n * dst = s -> cirrus_shadow_gr0 ;\n }\n val <<= 1 ;\n dst ++ ;\n }\n memory_region_set_dirty ( & s -> vga . vram , offset , 8 ) ;\n }",
        "output": "1",
        "idx": 4407
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( FilesystemIterator , current ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n if ( SPL_FILE_DIR_CURRENT ( intern , SPL_FILE_DIR_CURRENT_AS_PATHNAME ) ) {\n spl_filesystem_object_get_file_name ( intern TSRMLS_CC ) ;\n RETURN_STRINGL ( intern -> file_name , intern -> file_name_len , 1 ) ;\n }\n else if ( SPL_FILE_DIR_CURRENT ( intern , SPL_FILE_DIR_CURRENT_AS_FILEINFO ) ) {\n spl_filesystem_object_get_file_name ( intern TSRMLS_CC ) ;\n spl_filesystem_object_create_type ( 0 , intern , SPL_FS_INFO , NULL , return_value TSRMLS_CC ) ;\n }\n else {\n RETURN_ZVAL ( getThis ( ) , 1 , 0 ) ;\n }\n }",
        "output": "1",
        "idx": 1416
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ProtocolHandlerRegistryTest , MAYBE_TestInstallDefaultHandler ) {\n RecreateRegistry ( false ) ;\n registry ( ) -> AddPredefinedHandler ( CreateProtocolHandler ( \"test\" , GURL ( \"http://test.com/%s\" ) , \"Test\" ) ) ;\n registry ( ) -> InitProtocolSettings ( ) ;\n std : : vector < std : : string > protocols ;\n registry ( ) -> GetRegisteredProtocols ( & protocols ) ;\n ASSERT_EQ ( static_cast < size_t > ( 1 ) , protocols . size ( ) ) ;\n }",
        "output": "1",
        "idx": 3223
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_ref ( VP9_COMMON * const cm , MACROBLOCKD * const xd , int idx , int mi_row , int mi_col ) {\n MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ;\n RefBuffer * ref_buffer = & cm -> frame_refs [ mbmi -> ref_frame [ idx ] - LAST_FRAME ] ;\n xd -> block_refs [ idx ] = ref_buffer ;\n if ( ! vp9_is_valid_scale ( & ref_buffer -> sf ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_UNSUP_BITSTREAM , \"Invalid scale factors\" ) ;\n if ( ref_buffer -> buf -> corrupted ) vpx_internal_error ( & cm -> error , VPX_CODEC_CORRUPT_FRAME , \"Block reference is corrupt\" ) ;\n vp9_setup_pre_planes ( xd , idx , ref_buffer -> buf , mi_row , mi_col , & ref_buffer -> sf ) ;\n xd -> corrupted |= ref_buffer -> buf -> corrupted ;\n }",
        "output": "1",
        "idx": 1851
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long srec_canonicalize_symtab ( bfd * abfd , asymbol * * alocation ) {\n bfd_size_type symcount = bfd_get_symcount ( abfd ) ;\n asymbol * csymbols ;\n unsigned int i ;\n csymbols = abfd -> tdata . srec_data -> csymbols ;\n if ( csymbols == NULL && symcount != 0 ) {\n asymbol * c ;\n struct srec_symbol * s ;\n csymbols = ( asymbol * ) bfd_alloc ( abfd , symcount * sizeof ( asymbol ) ) ;\n if ( csymbols == NULL ) return - 1 ;\n abfd -> tdata . srec_data -> csymbols = csymbols ;\n for ( s = abfd -> tdata . srec_data -> symbols , c = csymbols ;\n s != NULL ;\n s = s -> next , ++ c ) {\n c -> the_bfd = abfd ;\n c -> name = s -> name ;\n c -> value = s -> val ;\n c -> flags = BSF_GLOBAL ;\n c -> section = bfd_abs_section_ptr ;\n c -> udata . p = NULL ;\n }\n }\n for ( i = 0 ;\n i < symcount ;\n i ++ ) * alocation ++ = csymbols ++ ;\n * alocation = NULL ;\n return symcount ;\n }",
        "output": "0",
        "idx": 440
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int check_user_and_ip ( int userid , struct query * q ) {\n struct sockaddr_in * tempin ;\n if ( userid < 0 || userid >= created_users ) {\n return 1 ;\n }\n if ( ! users [ userid ] . active || users [ userid ] . disabled ) {\n return 1 ;\n }\n if ( users [ userid ] . last_pkt + 60 < time ( NULL ) ) {\n return 1 ;\n }\n if ( ! check_ip ) {\n return 0 ;\n }\n tempin = ( struct sockaddr_in * ) & ( q -> from ) ;\n return memcmp ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;\n }",
        "output": "1",
        "idx": 1315
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * pathToFullPath ( const char * path , const char * source ) {\n int32_t length ;\n int32_t newLength ;\n char * fullPath ;\n int32_t n ;\n length = ( uint32_t ) ( uprv_strlen ( path ) + 1 ) ;\n newLength = ( length + 1 + ( int32_t ) uprv_strlen ( source ) ) ;\n fullPath = ( char * ) uprv_malloc ( newLength ) ;\n if ( source != NULL ) {\n uprv_strcpy ( fullPath , source ) ;\n uprv_strcat ( fullPath , U_FILE_SEP_STRING ) ;\n }\n else {\n fullPath [ 0 ] = 0 ;\n }\n n = ( int32_t ) uprv_strlen ( fullPath ) ;\n fullPath [ n ] = 0 ;\n uprv_strcat ( fullPath , path ) ;\n # if ( U_FILE_ALT_SEP_CHAR != U_TREE_ENTRY_SEP_CHAR ) # if ( U_FILE_ALT_SEP_CHAR != U_FILE_SEP_CHAR ) for ( ;\n fullPath [ n ] ;\n n ++ ) {\n if ( fullPath [ n ] == U_FILE_ALT_SEP_CHAR ) {\n fullPath [ n ] = U_FILE_SEP_CHAR ;\n }\n }\n # endif # endif # if ( U_FILE_SEP_CHAR != U_TREE_ENTRY_SEP_CHAR ) for ( ;\n fullPath [ n ] ;\n n ++ ) {\n if ( fullPath [ n ] == U_TREE_ENTRY_SEP_CHAR ) {\n fullPath [ n ] = U_FILE_SEP_CHAR ;\n }\n }\n # endif return fullPath ;\n }",
        "output": "0",
        "idx": 4414
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main ( int argc , char * * argv ) {\n if ( argc > 1 && ! strcmp ( argv [ 1 ] , \"--verbose\" ) ) verbose = 1 ;\n else if ( argc > 1 && ! strcmp ( argv [ 1 ] , \"--debug\" ) ) verbose = debug = 1 ;\n if ( ! gcry_check_version ( GCRYPT_VERSION ) ) die ( \"version mismatch\\n\" ) ;\n gcry_control ( GCRYCTL_DISABLE_SECMEM , 0 ) ;\n gcry_control ( GCRYCTL_ENABLE_QUICK_RANDOM , 0 ) ;\n if ( debug ) gcry_control ( GCRYCTL_SET_DEBUG_FLAGS , 1u , 0 ) ;\n gcry_control ( GCRYCTL_INITIALIZATION_FINISHED , 0 ) ;\n set_get_point ( ) ;\n context_alloc ( ) ;\n context_param ( ) ;\n basic_ec_math ( ) ;\n basic_ec_math_simplified ( ) ;\n show ( \"All tests completed. Errors: %d\\n\" , error_count ) ;\n return error_count ? 1 : 0 ;\n }",
        "output": "1",
        "idx": 4108
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mc_part ( H264Context * h , int n , int square , int height , int delta , uint8_t * dest_y , uint8_t * dest_cb , uint8_t * dest_cr , int x_offset , int y_offset , qpel_mc_func * qpix_put , h264_chroma_mc_func chroma_put , qpel_mc_func * qpix_avg , h264_chroma_mc_func chroma_avg , h264_weight_func * weight_op , h264_biweight_func * weight_avg , int list0 , int list1 ) {\n if ( ( h -> use_weight == 2 && list0 && list1 && ( h -> implicit_weight [ h -> ref_cache [ 0 ] [ scan8 [ n ] ] ] [ h -> ref_cache [ 1 ] [ scan8 [ n ] ] ] [ h -> mb_y & 1 ] != 32 ) ) || h -> use_weight == 1 ) mc_part_weighted ( h , n , square , height , delta , dest_y , dest_cb , dest_cr , x_offset , y_offset , qpix_put , chroma_put , weight_op [ 0 ] , weight_op [ 1 ] , weight_avg [ 0 ] , weight_avg [ 1 ] , list0 , list1 , PIXEL_SHIFT , CHROMA_IDC ) ;\n else mc_part_std ( h , n , square , height , delta , dest_y , dest_cb , dest_cr , x_offset , y_offset , qpix_put , chroma_put , qpix_avg , chroma_avg , list0 , list1 , PIXEL_SHIFT , CHROMA_IDC ) ;\n }",
        "output": "0",
        "idx": 1844
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( SiteDetailsBrowserTest , PlatformAppsNotIsolated ) {\n if ( content : : AreAllSitesIsolatedForTesting ( ) ) return ;\n CreateAppWithSandboxPage ( \"Extension One\" ) ;\n scoped_refptr < TestMemoryDetails > details = new TestMemoryDetails ( ) ;\n details -> StartFetchAndWait ( ) ;\n EXPECT_EQ ( 0 , details -> GetOutOfProcessIframeCount ( ) ) ;\n }",
        "output": "1",
        "idx": 1066
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void graph_analysis_data_init ( void ) {\n the_tapinfo_struct . graph_analysis = ( seq_analysis_info_t * ) g_malloc ( sizeof ( seq_analysis_info_t ) ) ;\n the_tapinfo_struct . graph_analysis -> nconv = 0 ;\n the_tapinfo_struct . graph_analysis -> list = NULL ;\n the_tapinfo_struct . graph_analysis -> ht = g_hash_table_new ( g_int_hash , g_int_equal ) ;\n }",
        "output": "0",
        "idx": 708
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vp9_compute_qdelta ( const RATE_CONTROL * rc , double qstart , double qtarget ) {\n int start_index = rc -> worst_quality ;\n int target_index = rc -> worst_quality ;\n int i ;\n for ( i = rc -> best_quality ;\n i < rc -> worst_quality ;\n ++ i ) {\n start_index = i ;\n if ( vp9_convert_qindex_to_q ( i ) >= qstart ) break ;\n }\n for ( i = rc -> best_quality ;\n i < rc -> worst_quality ;\n ++ i ) {\n target_index = i ;\n if ( vp9_convert_qindex_to_q ( i ) >= qtarget ) break ;\n }\n return target_index - start_index ;\n }",
        "output": "1",
        "idx": 563
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void print_mi_data ( VP9_COMMON * cm , FILE * file , const char * descriptor , size_t member_offset ) {\n int mi_row , mi_col ;\n int mi_index = 0 ;\n MODE_INFO * * mi = cm -> mi_grid_visible ;\n int rows = cm -> mi_rows ;\n int cols = cm -> mi_cols ;\n char prefix = descriptor [ 0 ] ;\n log_frame_info ( cm , descriptor , file ) ;\n mi_index = 0 ;\n for ( mi_row = 0 ;\n mi_row < rows ;\n mi_row ++ ) {\n fprintf ( file , \"%c \" , prefix ) ;\n for ( mi_col = 0 ;\n mi_col < cols ;\n mi_col ++ ) {\n fprintf ( file , \"%2d \" , * ( ( int * ) ( ( char * ) ( & mi [ mi_index ] -> mbmi ) + member_offset ) ) ) ;\n mi_index ++ ;\n }\n fprintf ( file , \"\\n\" ) ;\n mi_index += 8 ;\n }\n fprintf ( file , \"\\n\" ) ;\n }",
        "output": "1",
        "idx": 1141
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void free_cal ( fz_context * ctx , fz_colorspace * cs ) {\n fz_cal_colorspace * cal_data = cs -> data ;\n if ( cal_data -> profile != NULL ) {\n fz_drop_buffer ( ctx , cal_data -> profile -> buffer ) ;\n fz_cmm_fin_profile ( ctx , cal_data -> profile ) ;\n fz_free ( ctx , cal_data -> profile ) ;\n }\n fz_free ( ctx , cal_data ) ;\n }",
        "output": "0",
        "idx": 1912
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static guint16 de_clg_party_sub_addr ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo , guint32 offset , guint len , gchar * add_string _U_ , int string_len _U_ ) {\n gchar * extr_addr ;\n de_sub_addr ( tvb , tree , pinfo , offset , len , & extr_addr ) ;\n if ( extr_addr && add_string ) g_snprintf ( add_string , string_len , \" - (%s)\" , extr_addr ) ;\n return ( len ) ;\n }",
        "output": "0",
        "idx": 2100
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int MBS_ReadHeader ( int fd , MBSPatchHeader * header ) {\n int s = read ( fd , header , sizeof ( MBSPatchHeader ) ) ;\n if ( s != sizeof ( MBSPatchHeader ) ) return READ_ERROR ;\n header -> slen = ntohl ( header -> slen ) ;\n header -> scrc32 = ntohl ( header -> scrc32 ) ;\n header -> dlen = ntohl ( header -> dlen ) ;\n header -> cblen = ntohl ( header -> cblen ) ;\n header -> difflen = ntohl ( header -> difflen ) ;\n header -> extralen = ntohl ( header -> extralen ) ;\n struct stat hs ;\n s = fstat ( fd , & hs ) ;\n if ( s ) return READ_ERROR ;\n if ( memcmp ( header -> tag , \"MBDIFF10\" , 8 ) != 0 ) return UNEXPECTED_ERROR ;\n if ( sizeof ( MBSPatchHeader ) + header -> cblen + header -> difflen + header -> extralen != int ( hs . st_size ) ) return UNEXPECTED_ERROR ;\n return OK ;\n }",
        "output": "1",
        "idx": 3856
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void idct_put ( ASV1Context * a , int mb_x , int mb_y ) {\n int16_t ( * block ) [ 64 ] = a -> block ;\n int linesize = a -> picture . linesize [ 0 ] ;\n uint8_t * dest_y = a -> picture . data [ 0 ] + ( mb_y * 16 * linesize ) + mb_x * 16 ;\n uint8_t * dest_cb = a -> picture . data [ 1 ] + ( mb_y * 8 * a -> picture . linesize [ 1 ] ) + mb_x * 8 ;\n uint8_t * dest_cr = a -> picture . data [ 2 ] + ( mb_y * 8 * a -> picture . linesize [ 2 ] ) + mb_x * 8 ;\n a -> dsp . idct_put ( dest_y , linesize , block [ 0 ] ) ;\n a -> dsp . idct_put ( dest_y + 8 , linesize , block [ 1 ] ) ;\n a -> dsp . idct_put ( dest_y + 8 * linesize , linesize , block [ 2 ] ) ;\n a -> dsp . idct_put ( dest_y + 8 * linesize + 8 , linesize , block [ 3 ] ) ;\n if ( ! ( a -> avctx -> flags & CODEC_FLAG_GRAY ) ) {\n a -> dsp . idct_put ( dest_cb , a -> picture . linesize [ 1 ] , block [ 4 ] ) ;\n a -> dsp . idct_put ( dest_cr , a -> picture . linesize [ 2 ] , block [ 5 ] ) ;\n }\n }",
        "output": "1",
        "idx": 1606
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vga_draw_line32_be ( VGACommonState * vga , uint8_t * d , uint32_t addr , int width ) {\n int w ;\n uint32_t r , g , b ;\n w = width ;\n do {\n r = vga_read_byte ( vga , addr + 1 ) ;\n g = vga_read_byte ( vga , addr + 2 ) ;\n b = vga_read_byte ( vga , addr + 3 ) ;\n ( ( uint32_t * ) d ) [ 0 ] = rgb_to_pixel32 ( r , g , b ) ;\n addr += 4 ;\n d += 4 ;\n }\n while ( -- w != 0 ) ;\n }",
        "output": "0",
        "idx": 1736
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static List * fetch_function_defaults ( HeapTuple func_tuple ) {\n List * defaults ;\n Datum proargdefaults ;\n bool isnull ;\n char * str ;\n proargdefaults = SysCacheGetAttr ( PROCOID , func_tuple , Anum_pg_proc_proargdefaults , & isnull ) ;\n if ( isnull ) elog ( ERROR , \"not enough default arguments\" ) ;\n str = TextDatumGetCString ( proargdefaults ) ;\n defaults = ( List * ) stringToNode ( str ) ;\n Assert ( IsA ( defaults , List ) ) ;\n pfree ( str ) ;\n return defaults ;\n }",
        "output": "0",
        "idx": 1201
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( DirectoryIterator , key ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n if ( intern -> u . dir . dirp ) {\n RETURN_LONG ( intern -> u . dir . index ) ;\n }\n else {\n RETURN_FALSE ;\n }\n }",
        "output": "1",
        "idx": 1329
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_fdct32x32_rd_c ( const int16_t * input , int16_t * out , int stride ) {\n int i , j ;\n int output [ 32 * 32 ] ;\n for ( i = 0 ;\n i < 32 ;\n ++ i ) {\n int temp_in [ 32 ] , temp_out [ 32 ] ;\n for ( j = 0 ;\n j < 32 ;\n ++ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ;\n fdct32 ( temp_in , temp_out , 0 ) ;\n for ( j = 0 ;\n j < 32 ;\n ++ j ) output [ j * 32 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] > 0 ) ) >> 2 ;\n }\n for ( i = 0 ;\n i < 32 ;\n ++ i ) {\n int temp_in [ 32 ] , temp_out [ 32 ] ;\n for ( j = 0 ;\n j < 32 ;\n ++ j ) temp_in [ j ] = output [ j + i * 32 ] ;\n fdct32 ( temp_in , temp_out , 1 ) ;\n for ( j = 0 ;\n j < 32 ;\n ++ j ) out [ j + i * 32 ] = temp_out [ j ] ;\n }\n }",
        "output": "1",
        "idx": 3826
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vga_draw_line8 ( VGACommonState * s1 , uint8_t * d , const uint8_t * s , int width ) {\n uint32_t * palette ;\n int x ;\n palette = s1 -> last_palette ;\n width >>= 3 ;\n for ( x = 0 ;\n x < width ;\n x ++ ) {\n ( ( uint32_t * ) d ) [ 0 ] = palette [ s [ 0 ] ] ;\n ( ( uint32_t * ) d ) [ 1 ] = palette [ s [ 1 ] ] ;\n ( ( uint32_t * ) d ) [ 2 ] = palette [ s [ 2 ] ] ;\n ( ( uint32_t * ) d ) [ 3 ] = palette [ s [ 3 ] ] ;\n ( ( uint32_t * ) d ) [ 4 ] = palette [ s [ 4 ] ] ;\n ( ( uint32_t * ) d ) [ 5 ] = palette [ s [ 5 ] ] ;\n ( ( uint32_t * ) d ) [ 6 ] = palette [ s [ 6 ] ] ;\n ( ( uint32_t * ) d ) [ 7 ] = palette [ s [ 7 ] ] ;\n d += 32 ;\n s += 8 ;\n }\n }",
        "output": "1",
        "idx": 803
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void selinux_sk_getsecid ( struct sock * sk , u32 * secid ) {\n if ( ! sk ) * secid = SECINITSID_ANY_SOCKET ;\n else {\n struct sk_security_struct * sksec = sk -> sk_security ;\n * secid = sksec -> sid ;\n }\n }",
        "output": "0",
        "idx": 949
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_T_guid ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 712 \"./asn1/h225/h225.cnf\" tvbuff_t * guid_tvb = NULL ;\n actx -> value_ptr = & guid_tvb ;\n offset = dissect_h225_GloballyUniqueID ( tvb , offset , actx , tree , hf_index ) ;\n if ( guid_tvb ) tvb_get_ntohguid ( guid_tvb , 0 , call_id_guid = wmem_new ( wmem_packet_scope ( ) , e_guid_t ) ) ;\n actx -> value_ptr = NULL ;\n return offset ;\n }",
        "output": "1",
        "idx": 1581
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Asn1Generic * DecodeAsn1DerSet ( const unsigned char * buffer , uint32_t max_size , uint8_t depth , uint32_t * errcode ) {\n const unsigned char * d_ptr = buffer ;\n uint32_t d_length , numbytes , el_max_size ;\n uint8_t c ;\n uint32_t seq_index ;\n Asn1Generic * node ;\n Asn1Generic * child ;\n d_ptr ++ ;\n node = Asn1GenericNew ( ) ;\n if ( node == NULL ) return NULL ;\n node -> type = ASN1_SET ;\n node -> data = NULL ;\n c = d_ptr [ 0 ] ;\n if ( ( c & ( 1 << 7 ) ) >> 7 == 0 ) {\n d_length = c ;\n d_ptr ++ ;\n }\n else {\n numbytes = c & 0x7f ;\n d_ptr ++ ;\n if ( DecodeAsn1BuildValue ( & d_ptr , & d_length , numbytes , errcode ) == - 1 ) {\n SCFree ( node ) ;\n return NULL ;\n }\n }\n node -> length = d_length + ( d_ptr - buffer ) ;\n if ( node -> length > max_size ) {\n if ( errcode ) * errcode = ERR_DER_ELEMENT_SIZE_TOO_BIG ;\n SCFree ( node ) ;\n return NULL ;\n }\n seq_index = 0 ;\n el_max_size = max_size - ( d_ptr - buffer ) ;\n child = DecodeAsn1DerGeneric ( d_ptr , el_max_size , depth , seq_index , errcode ) ;\n node -> data = child ;\n return ( Asn1Generic * ) node ;\n }",
        "output": "1",
        "idx": 2289
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ProtocolHandlerRegistryTest , TestIsEquivalentRegistered ) {\n ProtocolHandler ph1 = CreateProtocolHandler ( \"test\" , GURL ( \"http://test/%s\" ) , \"test1\" ) ;\n ProtocolHandler ph2 = CreateProtocolHandler ( \"test\" , GURL ( \"http://test/%s\" ) , \"test2\" ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;\n ASSERT_TRUE ( registry ( ) -> IsRegistered ( ph1 ) ) ;\n ASSERT_TRUE ( registry ( ) -> HasRegisteredEquivalent ( ph2 ) ) ;\n }",
        "output": "1",
        "idx": 1585
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void Type_XYZ_Free ( struct _cms_typehandler_struct * self , void * Ptr ) {\n _cmsFree ( self -> ContextID , Ptr ) ;\n }",
        "output": "0",
        "idx": 3317
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int qemuAgentIORead ( qemuAgentPtr mon ) {\n size_t avail = mon -> bufferLength - mon -> bufferOffset ;\n int ret = 0 ;\n if ( avail < 1024 ) {\n if ( VIR_REALLOC_N ( mon -> buffer , mon -> bufferLength + 1024 ) < 0 ) return - 1 ;\n mon -> bufferLength += 1024 ;\n avail += 1024 ;\n }\n while ( avail > 1 ) {\n int got ;\n got = read ( mon -> fd , mon -> buffer + mon -> bufferOffset , avail - 1 ) ;\n if ( got < 0 ) {\n if ( errno == EAGAIN ) break ;\n virReportSystemError ( errno , \"%s\" , _ ( \"Unable to read from monitor\" ) ) ;\n ret = - 1 ;\n break ;\n }\n if ( got == 0 ) break ;\n ret += got ;\n avail -= got ;\n mon -> bufferOffset += got ;\n mon -> buffer [ mon -> bufferOffset ] = '\\0' ;\n }\n # if DEBUG_IO VIR_DEBUG ( \"Now read %zu bytes of data\" , mon -> bufferOffset ) ;\n # endif return ret ;\n }",
        "output": "1",
        "idx": 4344
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_T_callSpecific ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_T_callSpecific , T_callSpecific_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 2665
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _HZReset ( UConverter * cnv , UConverterResetChoice choice ) {\n if ( choice <= UCNV_RESET_TO_UNICODE ) {\n cnv -> toUnicodeStatus = 0 ;\n cnv -> mode = 0 ;\n if ( cnv -> extraInfo != NULL ) {\n ( ( UConverterDataHZ * ) cnv -> extraInfo ) -> isStateDBCS = FALSE ;\n ( ( UConverterDataHZ * ) cnv -> extraInfo ) -> isEmptySegment = FALSE ;\n }\n }\n if ( choice != UCNV_RESET_TO_UNICODE ) {\n cnv -> fromUnicodeStatus = 0 ;\n cnv -> fromUChar32 = 0x0000 ;\n if ( cnv -> extraInfo != NULL ) {\n ( ( UConverterDataHZ * ) cnv -> extraInfo ) -> isEscapeAppended = FALSE ;\n ( ( UConverterDataHZ * ) cnv -> extraInfo ) -> targetIndex = 0 ;\n ( ( UConverterDataHZ * ) cnv -> extraInfo ) -> sourceIndex = 0 ;\n ( ( UConverterDataHZ * ) cnv -> extraInfo ) -> isTargetUCharDBCS = FALSE ;\n }\n }\n }",
        "output": "1",
        "idx": 377
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char * hfinfo_numeric_value_format ( const header_field_info * hfinfo , char buf [ 32 ] , guint32 value ) {\n int display = hfinfo -> display & FIELD_DISPLAY_E_MASK ;\n if ( hfinfo -> type == FT_FRAMENUM ) {\n display = BASE_DEC ;\n }\n if ( IS_BASE_PORT ( display ) ) {\n display = BASE_DEC ;\n }\n switch ( display ) {\n case BASE_NONE : case BASE_DEC_HEX : case BASE_OCT : case BASE_CUSTOM : display = BASE_DEC ;\n break ;\n case BASE_HEX_DEC : display = BASE_HEX ;\n break ;\n }\n return hfinfo_number_value_format_display ( hfinfo , display , buf , value ) ;\n }",
        "output": "0",
        "idx": 3599
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int gs_nulldevice ( gs_gstate * pgs ) {\n int code = 0 ;\n if ( pgs -> device == 0 || ! gx_device_is_null ( pgs -> device ) ) {\n gx_device * ndev ;\n code = gs_copydevice ( & ndev , ( const gx_device * ) & gs_null_device , pgs -> memory ) ;\n if ( code < 0 ) return code ;\n rc_init ( ndev , pgs -> memory , 0 ) ;\n if ( pgs -> device != NULL ) {\n if ( ( code = dev_proc ( pgs -> device , get_profile ) ( pgs -> device , & ( ndev -> icc_struct ) ) ) < 0 ) return code ;\n rc_increment ( ndev -> icc_struct ) ;\n set_dev_proc ( ndev , get_profile , gx_default_get_profile ) ;\n }\n if ( ( code = gs_setdevice_no_erase ( pgs , ndev ) ) < 0 ) gs_free_object ( pgs -> memory , ndev , \"gs_copydevice(device)\" ) ;\n }\n return code ;\n }",
        "output": "1",
        "idx": 4147
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void readcb ( struct bufferevent * bev , void * arg ) {\n if ( EVBUFFER_LENGTH ( bev -> input ) == 8333 ) {\n bufferevent_disable ( bev , EV_READ ) ;\n test_ok ++ ;\n }\n }",
        "output": "0",
        "idx": 782
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipvideo_decode_block_opcode_0xF ( IpvideoContext * s ) {\n int x , y ;\n unsigned char sample [ 2 ] ;\n sample [ 0 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n sample [ 1 ] = bytestream2_get_byte ( & s -> stream_ptr ) ;\n for ( y = 0 ;\n y < 8 ;\n y ++ ) {\n for ( x = 0 ;\n x < 8 ;\n x += 2 ) {\n * s -> pixel_ptr ++ = sample [ y & 1 ] ;\n * s -> pixel_ptr ++ = sample [ ! ( y & 1 ) ] ;\n }\n s -> pixel_ptr += s -> line_inc ;\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 2696
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void traverse_commit_list ( struct rev_info * revs , show_commit_fn show_commit , show_object_fn show_object , void * data ) {\n int i ;\n struct commit * commit ;\n struct strbuf base ;\n strbuf_init ( & base , PATH_MAX ) ;\n while ( ( commit = get_revision ( revs ) ) != NULL ) {\n if ( commit -> tree ) add_pending_tree ( revs , commit -> tree ) ;\n show_commit ( commit , data ) ;\n }\n for ( i = 0 ;\n i < revs -> pending . nr ;\n i ++ ) {\n struct object_array_entry * pending = revs -> pending . objects + i ;\n struct object * obj = pending -> item ;\n const char * name = pending -> name ;\n const char * path = pending -> path ;\n if ( obj -> flags & ( UNINTERESTING | SEEN ) ) continue ;\n if ( obj -> type == OBJ_TAG ) {\n obj -> flags |= SEEN ;\n show_object ( obj , NULL , name , data ) ;\n continue ;\n }\n if ( ! path ) path = \"\" ;\n if ( obj -> type == OBJ_TREE ) {\n process_tree ( revs , ( struct tree * ) obj , show_object , NULL , & base , path , data ) ;\n continue ;\n }\n if ( obj -> type == OBJ_BLOB ) {\n process_blob ( revs , ( struct blob * ) obj , show_object , NULL , path , data ) ;\n continue ;\n }\n die ( \"unknown pending object %s (%s)\" , oid_to_hex ( & obj -> oid ) , name ) ;\n }\n object_array_clear ( & revs -> pending ) ;\n strbuf_release ( & base ) ;\n }",
        "output": "1",
        "idx": 2947
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static double get_zero_motion_factor ( const FIRSTPASS_STATS * frame ) {\n const double sr_ratio = frame -> coded_error / DOUBLE_DIVIDE_CHECK ( frame -> sr_coded_error ) ;\n const double zero_motion_pct = frame -> pcnt_inter - frame -> pcnt_motion ;\n return MIN ( sr_ratio , zero_motion_pct ) ;\n }",
        "output": "1",
        "idx": 2894
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void * qemu_dummy_cpu_thread_fn ( void * arg ) {\n # ifdef _WIN32 fprintf ( stderr , \"qtest is not supported under Windows\\n\" ) ;\n exit ( 1 ) ;\n # else CPUState * cpu = arg ;\n sigset_t waitset ;\n int r ;\n qemu_mutex_lock_iothread ( ) ;\n qemu_thread_get_self ( cpu -> thread ) ;\n cpu -> thread_id = qemu_get_thread_id ( ) ;\n sigemptyset ( & waitset ) ;\n sigaddset ( & waitset , SIG_IPI ) ;\n cpu -> created = true ;\n qemu_cond_signal ( & qemu_cpu_cond ) ;\n cpu_single_env = cpu -> env_ptr ;\n while ( 1 ) {\n cpu_single_env = NULL ;\n qemu_mutex_unlock_iothread ( ) ;\n do {\n int sig ;\n r = sigwait ( & waitset , & sig ) ;\n }\n while ( r == - 1 && ( errno == EAGAIN || errno == EINTR ) ) ;\n if ( r == - 1 ) {\n perror ( \"sigwait\" ) ;\n exit ( 1 ) ;\n }\n qemu_mutex_lock_iothread ( ) ;\n cpu_single_env = cpu -> env_ptr ;\n qemu_wait_io_event_common ( cpu ) ;\n }\n return NULL ;\n # endif }",
        "output": "1",
        "idx": 546
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void * xmlListReverseSearch ( xmlListPtr l , void * data ) {\n xmlLinkPtr lk ;\n if ( l == NULL ) return ( NULL ) ;\n lk = xmlListLinkReverseSearch ( l , data ) ;\n if ( lk ) return ( lk -> data ) ;\n return NULL ;\n }",
        "output": "0",
        "idx": 33
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int xmlListPushFront ( xmlListPtr l , void * data ) {\n xmlLinkPtr lkPlace , lkNew ;\n if ( l == NULL ) return ( 0 ) ;\n lkPlace = l -> sentinel ;\n lkNew = ( xmlLinkPtr ) xmlMalloc ( sizeof ( xmlLink ) ) ;\n if ( lkNew == NULL ) {\n xmlGenericError ( xmlGenericErrorContext , \"Cannot initialize memory for new link\" ) ;\n return ( 0 ) ;\n }\n lkNew -> data = data ;\n lkNew -> next = lkPlace -> next ;\n ( lkPlace -> next ) -> prev = lkNew ;\n lkPlace -> next = lkNew ;\n lkNew -> prev = lkPlace ;\n return 1 ;\n }",
        "output": "1",
        "idx": 3628
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_idct16x16_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) {\n if ( eob == 1 ) vp9_idct16x16_1_add ( input , dest , stride ) ;\n else if ( eob <= 10 ) vp9_idct16x16_10_add ( input , dest , stride ) ;\n else vp9_idct16x16_256_add ( input , dest , stride ) ;\n }",
        "output": "1",
        "idx": 2044
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ProtocolHandlerRegistryTest , TestReplaceNonDefaultHandler ) {\n ProtocolHandler ph1 = CreateProtocolHandler ( \"mailto\" , GURL ( \"http://test.com/%s\" ) , \"test1\" ) ;\n ProtocolHandler ph2 = CreateProtocolHandler ( \"mailto\" , GURL ( \"http://test.com/updated-url/%s\" ) , \"test2\" ) ;\n ProtocolHandler ph3 = CreateProtocolHandler ( \"mailto\" , GURL ( \"http://else.com/%s\" ) , \"test3\" ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph3 ) ;\n ASSERT_TRUE ( registry ( ) -> AttemptReplace ( ph2 ) ) ;\n const ProtocolHandler & handler ( registry ( ) -> GetHandlerFor ( \"mailto\" ) ) ;\n ASSERT_EQ ( handler . url ( ) , ph3 . url ( ) ) ;\n }",
        "output": "1",
        "idx": 1621
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline hwaddr prep_IO_address ( sysctrl_t * sysctrl , hwaddr addr ) {\n if ( sysctrl -> contiguous_map == 0 ) {\n addr &= 0xFFFF ;\n }\n else {\n addr = ( addr & 0x1F ) | ( ( addr & 0x007FFF000 ) >> 7 ) ;\n }\n return addr ;\n }",
        "output": "0",
        "idx": 1234
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static OFCondition parseDummy ( unsigned char * buf , unsigned long * itemLength , unsigned long availData ) {\n unsigned short userLength ;\n if ( availData < 4 ) return makeLengthError ( \"dummy item\" , availData , 4 ) ;\n buf ++ ;\n buf ++ ;\n EXTRACT_SHORT_BIG ( buf , userLength ) ;\n buf += 2 ;\n if ( availData - 4 < userLength ) return makeLengthError ( \"dummy item\" , availData , 0 , userLength ) ;\n * itemLength = userLength + 4 ;\n return EC_Normal ;\n }",
        "output": "1",
        "idx": 2329
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_T_g7231 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_T_g7231 , T_g7231_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 3756
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_BandwidthConfirm ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_BandwidthConfirm , BandwidthConfirm_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 2573
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vp9_get_frame_buffer ( void * cb_priv , size_t min_size , vpx_codec_frame_buffer_t * fb ) {\n int i ;\n InternalFrameBufferList * const int_fb_list = ( InternalFrameBufferList * ) cb_priv ;\n if ( int_fb_list == NULL ) return - 1 ;\n for ( i = 0 ;\n i < int_fb_list -> num_internal_frame_buffers ;\n ++ i ) {\n if ( ! int_fb_list -> int_fb [ i ] . in_use ) break ;\n }\n if ( i == int_fb_list -> num_internal_frame_buffers ) return - 1 ;\n if ( int_fb_list -> int_fb [ i ] . size < min_size ) {\n int_fb_list -> int_fb [ i ] . data = ( uint8_t * ) vpx_realloc ( int_fb_list -> int_fb [ i ] . data , min_size ) ;\n if ( ! int_fb_list -> int_fb [ i ] . data ) return - 1 ;\n vpx_memset ( int_fb_list -> int_fb [ i ] . data , 0 , min_size ) ;\n int_fb_list -> int_fb [ i ] . size = min_size ;\n }\n fb -> data = int_fb_list -> int_fb [ i ] . data ;\n fb -> size = int_fb_list -> int_fb [ i ] . size ;\n int_fb_list -> int_fb [ i ] . in_use = 1 ;\n fb -> priv = & int_fb_list -> int_fb [ i ] ;\n return 0 ;\n }",
        "output": "0",
        "idx": 1668
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "REGRESSION_TEST ( SDK_API_TSIOBufferStart ) ( RegressionTest * test , int , int * pstatus ) {\n bool test_passed = false ;\n * pstatus = REGRESSION_TEST_INPROGRESS ;\n TSIOBuffer bufp = TSIOBufferSizedCreate ( TS_IOBUFFER_SIZE_INDEX_4K ) ;\n TSIOBufferReader readerp = TSIOBufferReaderAlloc ( bufp ) ;\n if ( TSIOBufferStart ( bufp ) == TSIOBufferReaderStart ( readerp ) ) {\n SDK_RPRINT ( test , \"TSIOBufferStart\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n SDK_RPRINT ( test , \"TSIOBufferReaderStart\" , \"TestCase1\" , TC_PASS , \"ok\" ) ;\n test_passed = true ;\n }\n else {\n SDK_RPRINT ( test , \"TSIOBufferStart\" , \"TestCase1\" , TC_FAIL , \"failed\" ) ;\n SDK_RPRINT ( test , \"TSIOBufferReaderStart\" , \"TestCase1\" , TC_FAIL , \"failed\" ) ;\n }\n * pstatus = ( ( test_passed == true ) ? REGRESSION_TEST_PASSED : REGRESSION_TEST_FAILED ) ;\n return ;\n }",
        "output": "0",
        "idx": 3208
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_lpf_vertical_8_dual_sse2 ( uint8_t * s , int p , const uint8_t * blimit0 , const uint8_t * limit0 , const uint8_t * thresh0 , const uint8_t * blimit1 , const uint8_t * limit1 , const uint8_t * thresh1 ) {\n DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , t_dst , 16 * 8 ) ;\n unsigned char * src [ 2 ] ;\n unsigned char * dst [ 2 ] ;\n transpose8x16 ( s - 4 , s - 4 + p * 8 , p , t_dst , 16 ) ;\n vp9_lpf_horizontal_8_dual_sse2 ( t_dst + 4 * 16 , 16 , blimit0 , limit0 , thresh0 , blimit1 , limit1 , thresh1 ) ;\n src [ 0 ] = t_dst ;\n src [ 1 ] = t_dst + 8 ;\n dst [ 0 ] = s - 4 ;\n dst [ 1 ] = s - 4 + p * 8 ;\n transpose ( src , 16 , dst , p , 2 ) ;\n }",
        "output": "1",
        "idx": 3629
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cmv_decode_intra ( CmvContext * s , const uint8_t * buf , const uint8_t * buf_end ) {\n unsigned char * dst = s -> frame . data [ 0 ] ;\n int i ;\n for ( i = 0 ;\n i < s -> avctx -> height && buf_end - buf >= s -> avctx -> width ;\n i ++ ) {\n memcpy ( dst , buf , s -> avctx -> width ) ;\n dst += s -> frame . linesize [ 0 ] ;\n buf += s -> avctx -> width ;\n }\n }",
        "output": "1",
        "idx": 3657
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int virLogOnceInit ( void ) {\n if ( virMutexInit ( & virLogMutex ) < 0 ) return - 1 ;\n virLogLock ( ) ;\n virLogDefaultPriority = VIR_LOG_DEFAULT ;\n if ( VIR_ALLOC_QUIET ( virLogRegex ) >= 0 ) {\n if ( regcomp ( virLogRegex , VIR_LOG_REGEX , REG_EXTENDED ) != 0 ) VIR_FREE ( virLogRegex ) ;\n }\n virLogUnlock ( ) ;\n return 0 ;\n }",
        "output": "1",
        "idx": 4031
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_idct4x4_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) {\n if ( eob > 1 ) vp9_idct4x4_16_add ( input , dest , stride ) ;\n else vp9_idct4x4_1_add ( input , dest , stride ) ;\n }",
        "output": "1",
        "idx": 2932
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "size_t compile_tree ( struct filter_op * * fop ) {\n int i = 1 ;\n struct filter_op * array = NULL ;\n struct unfold_elm * ue ;\n BUG_IF ( tree_root == NULL ) ;\n fprintf ( stdout , \" Unfolding the meta-tree \" ) ;\n fflush ( stdout ) ;\n unfold_blk ( & tree_root ) ;\n fprintf ( stdout , \" done.\\n\\n\" ) ;\n labels_to_offsets ( ) ;\n TAILQ_FOREACH ( ue , & unfolded_tree , next ) {\n if ( ue -> label == 0 ) {\n SAFE_REALLOC ( array , i * sizeof ( struct filter_op ) ) ;\n memcpy ( & array [ i - 1 ] , & ue -> fop , sizeof ( struct filter_op ) ) ;\n i ++ ;\n }\n }\n SAFE_REALLOC ( array , i * sizeof ( struct filter_op ) ) ;\n array [ i - 1 ] . opcode = FOP_EXIT ;\n * fop = array ;\n return ( i ) ;\n }",
        "output": "1",
        "idx": 2839
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void decode_pitch_lag_high ( int * lag_int , int * lag_frac , int pitch_index , uint8_t * base_lag_int , int subframe ) {\n if ( subframe == 0 || subframe == 2 ) {\n if ( pitch_index < 376 ) {\n * lag_int = ( pitch_index + 137 ) >> 2 ;\n * lag_frac = pitch_index - ( * lag_int << 2 ) + 136 ;\n }\n else if ( pitch_index < 440 ) {\n * lag_int = ( pitch_index + 257 - 376 ) >> 1 ;\n * lag_frac = ( pitch_index - ( * lag_int << 1 ) + 256 - 376 ) << 1 ;\n }\n else {\n * lag_int = pitch_index - 280 ;\n * lag_frac = 0 ;\n }\n * base_lag_int = av_clip ( * lag_int - 8 - ( * lag_frac < 0 ) , AMRWB_P_DELAY_MIN , AMRWB_P_DELAY_MAX - 15 ) ;\n }\n else {\n * lag_int = ( pitch_index + 1 ) >> 2 ;\n * lag_frac = pitch_index - ( * lag_int << 2 ) ;\n * lag_int += * base_lag_int ;\n }\n }",
        "output": "0",
        "idx": 1669
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int test_small_prime ( BIO * bp , BN_CTX * ctx ) {\n static const int bits = 10 ;\n int ret = 0 ;\n BIGNUM r ;\n BN_init ( & r ) ;\n if ( ! BN_generate_prime_ex ( & r , bits , 0 , NULL , NULL , NULL ) ) goto err ;\n if ( BN_num_bits ( & r ) != bits ) {\n BIO_printf ( bp , \"Expected %d bit prime, got %d bit number\\n\" , bits , BN_num_bits ( & r ) ) ;\n goto err ;\n }\n ret = 1 ;\n err : BN_clear ( & r ) ;\n return ret ;\n }",
        "output": "0",
        "idx": 1603
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dissect_h225_IntegrityMechanism ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_IntegrityMechanism , IntegrityMechanism_choice , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 454
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_pvfs_time ( tvbuff_t * tvb , proto_tree * tree , int offset , int hf_time , int hf_time_sec , int hf_time_nsec ) {\n guint32 seconds ;\n guint32 nseconds ;\n nstime_t ts ;\n proto_item * time_item ;\n proto_tree * time_tree ;\n ts . secs = seconds = tvb_get_letohl ( tvb , offset ) ;\n ts . nsecs = nseconds = tvb_get_letohl ( tvb , offset + 4 ) ;\n time_item = proto_tree_add_time ( tree , hf_time , tvb , offset , 8 , & ts ) ;\n time_tree = proto_item_add_subtree ( time_item , ett_pvfs_time ) ;\n proto_tree_add_uint ( time_tree , hf_time_sec , tvb , offset , 4 , seconds ) ;\n proto_tree_add_uint ( time_tree , hf_time_nsec , tvb , offset + 4 , 4 , nseconds ) ;\n offset += 8 ;\n return offset ;\n }",
        "output": "0",
        "idx": 1351
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int evbuffer_expand ( struct evbuffer * buf , size_t datlen ) {\n size_t need = buf -> misalign + buf -> off + datlen ;\n if ( buf -> totallen >= need ) return ( 0 ) ;\n if ( buf -> misalign >= datlen ) {\n evbuffer_align ( buf ) ;\n }\n else {\n void * newbuf ;\n size_t length = buf -> totallen ;\n if ( length < 256 ) length = 256 ;\n while ( length < need ) length <<= 1 ;\n if ( buf -> orig_buffer != buf -> buffer ) evbuffer_align ( buf ) ;\n if ( ( newbuf = realloc ( buf -> buffer , length ) ) == NULL ) return ( - 1 ) ;\n buf -> orig_buffer = buf -> buffer = newbuf ;\n buf -> totallen = length ;\n }\n return ( 0 ) ;\n }",
        "output": "1",
        "idx": 61
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fd_free ( struct FrameData * p ) {\n if ( p ) {\n if ( p -> buf ) vpx_free ( p -> buf ) ;\n vpx_free ( p ) ;\n }\n }",
        "output": "1",
        "idx": 3440
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void read_switchable_interp_probs ( FRAME_CONTEXT * fc , vp9_reader * r ) {\n int i , j ;\n for ( j = 0 ;\n j < SWITCHABLE_FILTER_CONTEXTS ;\n ++ j ) for ( i = 0 ;\n i < SWITCHABLE_FILTERS - 1 ;\n ++ i ) vp9_diff_update_prob ( r , & fc -> switchable_interp_prob [ j ] [ i ] ) ;\n }",
        "output": "0",
        "idx": 1037
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dissect_h225_GenericData ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 816 \"./asn1/h225/h225.cnf\" void * priv_data = actx -> private_data ;\n gef_ctx_t * gefx ;\n gefx = gef_ctx_get ( actx -> private_data ) ;\n if ( ! gefx ) {\n gefx = gef_ctx_alloc ( NULL , \"GenericData\" ) ;\n actx -> private_data = gefx ;\n }\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_GenericData , GenericData_sequence ) ;\n # line 826 \"./asn1/h225/h225.cnf\" actx -> private_data = priv_data ;\n return offset ;\n }",
        "output": "1",
        "idx": 404
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int parse_PropertySetArray ( tvbuff_t * tvb , int offset , int size_offset , proto_tree * parent_tree , proto_tree * pad_tree , const char * fmt , ... ) {\n const int offset_in = offset ;\n guint32 size , num ;\n int i ;\n proto_tree * tree ;\n proto_item * item ;\n const char * txt ;\n va_list ap ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CDbPropSet_Array , & item , txt ) ;\n size = tvb_get_letohl ( tvb , size_offset ) ;\n proto_tree_add_item ( tree , hf_mswsp_msg_ConnectIn_Blob1 , tvb , size_offset , 4 , ENC_LITTLE_ENDIAN ) ;\n num = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_item ( tree , hf_mswsp_msg_ConnectIn_PropSets_num , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n for ( i = 0 ;\n i < ( int ) num ;\n i ++ ) {\n offset = parse_CDbPropSet ( tvb , offset , tree , pad_tree , \"PropertySet[%d]\" , i ) ;\n }\n proto_item_set_end ( item , tvb , offset ) ;\n DISSECTOR_ASSERT ( offset - offset_in == ( int ) size ) ;\n return offset ;\n }",
        "output": "1",
        "idx": 2647
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cmd_server_connect ( const char * data ) {\n GHashTable * optlist ;\n char * addr ;\n void * free_arg ;\n if ( ! cmd_get_params ( data , & free_arg , 1 | PARAM_FLAG_OPTIONS , \"connect\" , & optlist , & addr ) ) return ;\n if ( * addr == '\\0' || g_strcmp0 ( addr , \"+\" ) == 0 ) cmd_param_error ( CMDERR_NOT_ENOUGH_PARAMS ) ;\n if ( * addr == '+' ) window_create ( NULL , FALSE ) ;\n cmd_params_free ( free_arg ) ;\n }",
        "output": "0",
        "idx": 2283
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dynstr_append_sorted ( DYNAMIC_STRING * ds , DYNAMIC_STRING * ds_input , bool keep_header ) {\n unsigned i ;\n char * start = ds_input -> str ;\n DYNAMIC_ARRAY lines ;\n DBUG_ENTER ( \"dynstr_append_sorted\" ) ;\n if ( ! * start ) DBUG_VOID_RETURN ;\n my_init_dynamic_array ( & lines , sizeof ( const char * ) , 32 , 32 ) ;\n if ( keep_header ) {\n while ( * start && * start != '\\n' ) start ++ ;\n start ++ ;\n dynstr_append_mem ( ds , ds_input -> str , start - ds_input -> str ) ;\n }\n while ( * start ) {\n char * line_end = ( char * ) start ;\n while ( * line_end && * line_end != '\\n' ) line_end ++ ;\n * line_end = 0 ;\n if ( insert_dynamic ( & lines , ( uchar * ) & start ) ) die ( \"Out of memory inserting lines to sort\" ) ;\n start = line_end + 1 ;\n }\n qsort ( lines . buffer , lines . elements , sizeof ( char * * ) , ( qsort_cmp ) comp_lines ) ;\n for ( i = 0 ;\n i < lines . elements ;\n i ++ ) {\n const char * * line = dynamic_element ( & lines , i , const char * * ) ;\n dynstr_append ( ds , * line ) ;\n dynstr_append ( ds , \"\\n\" ) ;\n }\n delete_dynamic ( & lines ) ;\n DBUG_VOID_RETURN ;\n }",
        "output": "0",
        "idx": 3702
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "guint16 de_cell_id ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len , gchar * add_string , int string_len ) {\n guint32 curr_offset ;\n curr_offset = offset ;\n curr_offset += be_cell_id_aux ( tvb , tree , pinfo , offset , len , add_string , string_len , 0x02 ) ;\n return ( curr_offset - offset ) ;\n }",
        "output": "0",
        "idx": 1311
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tgq_idct_put_mb_dconly ( TgqContext * s , int mb_x , int mb_y , const int8_t * dc ) {\n int linesize = s -> frame . linesize [ 0 ] ;\n uint8_t * dest_y = s -> frame . data [ 0 ] + ( mb_y * 16 * linesize ) + mb_x * 16 ;\n uint8_t * dest_cb = s -> frame . data [ 1 ] + ( mb_y * 8 * s -> frame . linesize [ 1 ] ) + mb_x * 8 ;\n uint8_t * dest_cr = s -> frame . data [ 2 ] + ( mb_y * 8 * s -> frame . linesize [ 2 ] ) + mb_x * 8 ;\n tgq_dconly ( s , dest_y , linesize , dc [ 0 ] ) ;\n tgq_dconly ( s , dest_y + 8 , linesize , dc [ 1 ] ) ;\n tgq_dconly ( s , dest_y + 8 * linesize , linesize , dc [ 2 ] ) ;\n tgq_dconly ( s , dest_y + 8 * linesize + 8 , linesize , dc [ 3 ] ) ;\n if ( ! ( s -> avctx -> flags & CODEC_FLAG_GRAY ) ) {\n tgq_dconly ( s , dest_cb , s -> frame . linesize [ 1 ] , dc [ 4 ] ) ;\n tgq_dconly ( s , dest_cr , s -> frame . linesize [ 2 ] , dc [ 5 ] ) ;\n }\n }",
        "output": "1",
        "idx": 4080
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_idct16x16_1_add_c ( const int16_t * input , uint8_t * dest , int stride ) {\n int i , j ;\n int a1 ;\n int16_t out = dct_const_round_shift ( input [ 0 ] * cospi_16_64 ) ;\n out = dct_const_round_shift ( out * cospi_16_64 ) ;\n a1 = ROUND_POWER_OF_TWO ( out , 6 ) ;\n for ( j = 0 ;\n j < 16 ;\n ++ j ) {\n for ( i = 0 ;\n i < 16 ;\n ++ i ) dest [ i ] = clip_pixel ( dest [ i ] + a1 ) ;\n dest += stride ;\n }\n }",
        "output": "1",
        "idx": 2279
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ref_frames ( Vp3DecodeContext * dst , Vp3DecodeContext * src ) {\n int ret ;\n if ( ( ret = ref_frame ( dst , & dst -> current_frame , & src -> current_frame ) ) < 0 || ( ret = ref_frame ( dst , & dst -> golden_frame , & src -> golden_frame ) ) < 0 || ( ret = ref_frame ( dst , & dst -> last_frame , & src -> last_frame ) ) < 0 ) return ret ;\n return 0 ;\n }",
        "output": "0",
        "idx": 3134
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _HZ_GetUnicodeSet ( const UConverter * cnv , const USetAdder * sa , UConverterUnicodeSet which , UErrorCode * pErrorCode ) {\n sa -> addRange ( sa -> set , 0 , 0x7f ) ;\n ucnv_MBCSGetFilteredUnicodeSetForUnicode ( ( ( UConverterDataHZ * ) cnv -> extraInfo ) -> gbConverter -> sharedData , sa , which , UCNV_SET_FILTER_HZ , pErrorCode ) ;\n }",
        "output": "1",
        "idx": 3171
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline guint32 gst_asf_demux_identify_guid ( const ASFGuidHash * guids , ASFGuid * guid ) {\n guint32 ret ;\n ret = gst_asf_identify_guid ( guids , guid ) ;\n GST_LOG ( \"%s 0x%08x-0x%08x-0x%08x-0x%08x\" , gst_asf_get_guid_nick ( guids , ret ) , guid -> v1 , guid -> v2 , guid -> v3 , guid -> v4 ) ;\n return ret ;\n }",
        "output": "0",
        "idx": 4412
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void setup_masks_arabic_plan ( const arabic_shape_plan_t * arabic_plan , hb_buffer_t * buffer , hb_script_t script ) {\n HB_BUFFER_ALLOCATE_VAR ( buffer , arabic_shaping_action ) ;\n arabic_joining ( buffer ) ;\n if ( script == HB_SCRIPT_MONGOLIAN ) mongolian_variation_selectors ( buffer ) ;\n unsigned int count = buffer -> len ;\n hb_glyph_info_t * info = buffer -> info ;\n for ( unsigned int i = 0 ;\n i < count ;\n i ++ ) info [ i ] . mask |= arabic_plan -> mask_array [ info [ i ] . arabic_shaping_action ( ) ] ;\n HB_BUFFER_DEALLOCATE_VAR ( buffer , arabic_shaping_action ) ;\n }",
        "output": "0",
        "idx": 2349
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static rfbBool rectSwapIfLEAndClip ( uint16_t * x , uint16_t * y , uint16_t * w , uint16_t * h , rfbClientPtr cl ) {\n int x1 = Swap16IfLE ( * x ) ;\n int y1 = Swap16IfLE ( * y ) ;\n int w1 = Swap16IfLE ( * w ) ;\n int h1 = Swap16IfLE ( * h ) ;\n rfbScaledCorrection ( cl -> scaledScreen , cl -> screen , & x1 , & y1 , & w1 , & h1 , \"rectSwapIfLEAndClip\" ) ;\n * x = x1 ;\n * y = y1 ;\n * w = w1 ;\n * h = h1 ;\n if ( * w > cl -> screen -> width - * x ) * w = cl -> screen -> width - * x ;\n if ( * w > cl -> screen -> width - * x ) return FALSE ;\n if ( * h > cl -> screen -> height - * y ) * h = cl -> screen -> height - * y ;\n if ( * h > cl -> screen -> height - * y ) return FALSE ;\n return TRUE ;\n }",
        "output": "1",
        "idx": 2133
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void write_partition ( const VP9_COMMON * const cm , const MACROBLOCKD * const xd , int hbs , int mi_row , int mi_col , PARTITION_TYPE p , BLOCK_SIZE bsize , vp9_writer * w ) {\n const int ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ;\n const vp9_prob * const probs = get_partition_probs ( cm , ctx ) ;\n const int has_rows = ( mi_row + hbs ) < cm -> mi_rows ;\n const int has_cols = ( mi_col + hbs ) < cm -> mi_cols ;\n if ( has_rows && has_cols ) {\n vp9_write_token ( w , vp9_partition_tree , probs , & partition_encodings [ p ] ) ;\n }\n else if ( ! has_rows && has_cols ) {\n assert ( p == PARTITION_SPLIT || p == PARTITION_HORZ ) ;\n vp9_write ( w , p == PARTITION_SPLIT , probs [ 1 ] ) ;\n }\n else if ( has_rows && ! has_cols ) {\n assert ( p == PARTITION_SPLIT || p == PARTITION_VERT ) ;\n vp9_write ( w , p == PARTITION_SPLIT , probs [ 2 ] ) ;\n }\n else {\n assert ( p == PARTITION_SPLIT ) ;\n }\n }",
        "output": "0",
        "idx": 3526
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dist_block ( int plane , int block , TX_SIZE tx_size , struct rdcost_block_args * args ) {\n const int ss_txfrm_size = tx_size << 1 ;\n MACROBLOCK * const x = args -> x ;\n MACROBLOCKD * const xd = & x -> e_mbd ;\n const struct macroblock_plane * const p = & x -> plane [ plane ] ;\n const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;\n int64_t this_sse ;\n int shift = tx_size == TX_32X32 ? 0 : 2 ;\n int16_t * const coeff = BLOCK_OFFSET ( p -> coeff , block ) ;\n int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ;\n args -> dist = vp9_block_error ( coeff , dqcoeff , 16 << ss_txfrm_size , & this_sse ) >> shift ;\n args -> sse = this_sse >> shift ;\n if ( x -> skip_encode && ! is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) ) {\n int64_t p = ( pd -> dequant [ 1 ] * pd -> dequant [ 1 ] * ( 1 << ss_txfrm_size ) ) >> ( shift + 2 ) ;\n args -> dist += ( p >> 4 ) ;\n args -> sse += p ;\n }\n }",
        "output": "1",
        "idx": 707
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void server_port_ready_callback ( int fd , short events , void * arg ) {\n struct evdns_server_port * port = ( struct evdns_server_port * ) arg ;\n ( void ) fd ;\n if ( events & EV_WRITE ) {\n port -> choked = 0 ;\n server_port_flush ( port ) ;\n }\n if ( events & EV_READ ) {\n server_port_read ( port ) ;\n }\n }",
        "output": "0",
        "idx": 3895
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cancel_mount_for_file ( NautilusDirectory * directory , NautilusFile * file ) {\n if ( directory -> details -> mount_state != NULL && directory -> details -> mount_state -> file == file ) {\n mount_cancel ( directory ) ;\n }\n }",
        "output": "0",
        "idx": 3921
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_loop_filter_alloc ( VP9_COMMON * cm , VP9LfSync * lf_sync , int rows , int width ) {\n lf_sync -> rows = rows ;\n # if CONFIG_MULTITHREAD {\n int i ;\n CHECK_MEM_ERROR ( cm , lf_sync -> mutex_ , vpx_malloc ( sizeof ( * lf_sync -> mutex_ ) * rows ) ) ;\n for ( i = 0 ;\n i < rows ;\n ++ i ) {\n pthread_mutex_init ( & lf_sync -> mutex_ [ i ] , NULL ) ;\n }\n CHECK_MEM_ERROR ( cm , lf_sync -> cond_ , vpx_malloc ( sizeof ( * lf_sync -> cond_ ) * rows ) ) ;\n for ( i = 0 ;\n i < rows ;\n ++ i ) {\n pthread_cond_init ( & lf_sync -> cond_ [ i ] , NULL ) ;\n }\n }\n # endif CHECK_MEM_ERROR ( cm , lf_sync -> cur_sb_col , vpx_malloc ( sizeof ( * lf_sync -> cur_sb_col ) * rows ) ) ;\n lf_sync -> sync_range = get_sync_range ( width ) ;\n }",
        "output": "1",
        "idx": 2673
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void decCopyFit ( decNumber * dest , const decNumber * src , decContext * set , Int * residue , uInt * status ) {\n dest -> bits = src -> bits ;\n dest -> exponent = src -> exponent ;\n decSetCoeff ( dest , set , src -> lsu , src -> digits , residue , status ) ;\n }",
        "output": "0",
        "idx": 4083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mime_parse_integer ( const char * & buf , const char * end , int * integer ) {\n int val ;\n bool negative ;\n negative = false ;\n while ( ( buf != end ) && * buf && ! is_digit ( * buf ) && ( * buf != '-' ) ) {\n buf += 1 ;\n }\n if ( ( buf == end ) || ( * buf == '\\0' ) ) {\n return 0 ;\n }\n if ( * buf == '-' ) {\n negative = true ;\n buf += 1 ;\n }\n val = 0 ;\n while ( ( buf != end ) && is_digit ( * buf ) ) {\n val = ( val * 10 ) + ( * buf ++ - '0' ) ;\n }\n if ( negative ) {\n * integer = - val ;\n }\n else {\n * integer = val ;\n }\n return 1 ;\n }",
        "output": "0",
        "idx": 3481
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int parse_CCategSpec ( tvbuff_t * tvb , int offset , proto_tree * parent_tree , proto_tree * pad_tree , const char * fmt , ... ) {\n proto_item * item ;\n proto_tree * tree ;\n va_list ap ;\n guint32 type ;\n const char * txt ;\n va_start ( ap , fmt ) ;\n txt = wmem_strdup_vprintf ( wmem_packet_scope ( ) , fmt , ap ) ;\n va_end ( ap ) ;\n tree = proto_tree_add_subtree ( parent_tree , tvb , offset , 0 , ett_CCategSpec , & item , txt ) ;\n type = tvb_get_letohl ( tvb , offset ) ;\n proto_tree_add_uint ( tree , hf_mswsp_ccategspec_type , tvb , offset , 4 , type ) ;\n proto_item_append_text ( item , \" Type %u\" , type ) ;\n offset += 4 ;\n offset = parse_CSort ( tvb , offset , tree , pad_tree , \"CSort\" ) ;\n offset = parse_CRangeCategSpec ( tvb , offset , tree , pad_tree , \"CRangeCategSpec\" ) ;\n proto_item_set_end ( item , tvb , offset ) ;\n return offset ;\n }",
        "output": "1",
        "idx": 1396
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_T_h245Ip6 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 348 \"./asn1/h225/h225.cnf\" tvbuff_t * value_tvb ;\n ipv6_address = ipv6_address_zeros ;\n offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , 16 , 16 , FALSE , & value_tvb ) ;\n if ( value_tvb ) tvb_get_ipv6 ( value_tvb , 0 , & ipv6_address ) ;\n return offset ;\n }",
        "output": "1",
        "idx": 1228
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void selinux_task_getsecid ( struct task_struct * p , u32 * secid ) {\n * secid = task_sid ( p ) ;\n }",
        "output": "0",
        "idx": 1314
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vdpau_h264_set_rf ( VdpReferenceFrameH264 * rf , Picture * pic , int pic_structure ) {\n VdpVideoSurface surface = ff_vdpau_get_surface_id ( pic ) ;\n if ( pic_structure == 0 ) pic_structure = pic -> f . reference ;\n rf -> surface = surface ;\n rf -> is_long_term = pic -> f . reference && pic -> long_ref ;\n rf -> top_is_reference = ( pic_structure & PICT_TOP_FIELD ) != 0 ;\n rf -> bottom_is_reference = ( pic_structure & PICT_BOTTOM_FIELD ) != 0 ;\n rf -> field_order_cnt [ 0 ] = h264_foc ( pic -> field_poc [ 0 ] ) ;\n rf -> field_order_cnt [ 1 ] = h264_foc ( pic -> field_poc [ 1 ] ) ;\n rf -> frame_idx = pic -> long_ref ? pic -> pic_id : pic -> frame_num ;\n }",
        "output": "1",
        "idx": 1237
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ttfFont__destroy ( ttfFont * self , gs_font_dir * dir ) {\n gs_memory_t * mem = dir -> memory -> stable_memory ;\n ttfFont__finit ( self ) ;\n gs_free_object ( mem , self , \"ttfFont__destroy\" ) ;\n ttfInterpreter__release ( & dir -> tti ) ;\n gx_san__release ( & dir -> san ) ;\n if ( dir -> tti == NULL && dir -> ttm != NULL ) {\n gs_free_object ( mem , dir -> ttm , \"ttfFont__destroy(gx_ttfMemory)\" ) ;\n dir -> ttm = NULL ;\n }\n }",
        "output": "0",
        "idx": 1364
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jbig2_find_changing_element_of_color ( const byte * line , int x , int w , int color ) {\n if ( line == 0 ) return w ;\n x = jbig2_find_changing_element ( line , x , w ) ;\n if ( x < w && getbit ( line , x ) != color ) x = jbig2_find_changing_element ( line , x , w ) ;\n return x ;\n }",
        "output": "1",
        "idx": 1657
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_block_thresholds ( const VP9_COMMON * cm , RD_OPT * rd ) {\n int i , bsize , segment_id ;\n for ( segment_id = 0 ;\n segment_id < MAX_SEGMENTS ;\n ++ segment_id ) {\n const int qindex = clamp ( vp9_get_qindex ( & cm -> seg , segment_id , cm -> base_qindex ) + cm -> y_dc_delta_q , 0 , MAXQ ) ;\n const int q = compute_rd_thresh_factor ( qindex ) ;\n for ( bsize = 0 ;\n bsize < BLOCK_SIZES ;\n ++ bsize ) {\n const int t = q * rd_thresh_block_size_factor [ bsize ] ;\n const int thresh_max = INT_MAX / t ;\n if ( bsize >= BLOCK_8X8 ) {\n for ( i = 0 ;\n i < MAX_MODES ;\n ++ i ) rd -> threshes [ segment_id ] [ bsize ] [ i ] = rd -> thresh_mult [ i ] < thresh_max ? rd -> thresh_mult [ i ] * t / 4 : INT_MAX ;\n }\n else {\n for ( i = 0 ;\n i < MAX_REFS ;\n ++ i ) rd -> threshes [ segment_id ] [ bsize ] [ i ] = rd -> thresh_mult_sub8x8 [ i ] < thresh_max ? rd -> thresh_mult_sub8x8 [ i ] * t / 4 : INT_MAX ;\n }\n }\n }\n }",
        "output": "1",
        "idx": 1501
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_FastStart_item ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 272 \"./asn1/h225/h225.cnf\" tvbuff_t * value_tvb = NULL ;\n char codec_str [ 50 ] ;\n h225_packet_info * h225_pi ;\n codec_str [ 0 ] = '\\0' ;\n offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , NO_BOUND , NO_BOUND , FALSE , & value_tvb ) ;\n if ( value_tvb && tvb_reported_length ( value_tvb ) ) {\n dissect_h245_FastStart_OLC ( value_tvb , actx -> pinfo , tree , codec_str ) ;\n }\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n g_snprintf ( h225_pi -> frame_label , 50 , \"%s %s\" , h225_pi -> frame_label , codec_str ) ;\n h225_pi -> is_faststart = TRUE ;\n }\n contains_faststart = TRUE ;\n return offset ;\n }",
        "output": "1",
        "idx": 2469
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ECDSA_verify ( int type , const unsigned char * dgst , int dgst_len , const unsigned char * sigbuf , int sig_len , EC_KEY * eckey ) {\n ECDSA_SIG * s ;\n int ret = - 1 ;\n s = ECDSA_SIG_new ( ) ;\n if ( s == NULL ) return ( ret ) ;\n if ( d2i_ECDSA_SIG ( & s , & sigbuf , sig_len ) == NULL ) goto err ;\n ret = ECDSA_do_verify ( dgst , dgst_len , s , eckey ) ;\n err : ECDSA_SIG_free ( s ) ;\n return ( ret ) ;\n }",
        "output": "1",
        "idx": 2019
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE cState_space_before_set ( VALUE self , VALUE space_before ) {\n unsigned long len ;\n GET_STATE ( self ) ;\n Check_Type ( space_before , T_STRING ) ;\n len = RSTRING_LEN ( space_before ) ;\n if ( len == 0 ) {\n if ( state -> space_before ) {\n ruby_xfree ( state -> space_before ) ;\n state -> space_before = NULL ;\n state -> space_before_len = 0 ;\n }\n }\n else {\n if ( state -> space_before ) ruby_xfree ( state -> space_before ) ;\n state -> space_before = strdup ( RSTRING_PTR ( space_before ) ) ;\n state -> space_before_len = len ;\n }\n return Qnil ;\n }",
        "output": "1",
        "idx": 2335
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileInfo , getFilename ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n int path_len ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n spl_filesystem_object_get_path ( intern , & path_len TSRMLS_CC ) ;\n if ( path_len && path_len < intern -> file_name_len ) {\n RETURN_STRINGL ( intern -> file_name + path_len + 1 , intern -> file_name_len - ( path_len + 1 ) , 1 ) ;\n }\n else {\n RETURN_STRINGL ( intern -> file_name , intern -> file_name_len , 1 ) ;\n }\n }",
        "output": "1",
        "idx": 1627
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_LogicalChannelRateReject ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_LogicalChannelRateReject , LogicalChannelRateReject_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 1820
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( ProfileListDesktopBrowserTest , MAYBE_SignOut ) {\n if ( ! profiles : : IsMultipleProfilesEnabled ( ) ) return ;\n ProfileManager * profile_manager = g_browser_process -> profile_manager ( ) ;\n Profile * current_profile = browser ( ) -> profile ( ) ;\n ProfileInfoCache & cache = profile_manager -> GetProfileInfoCache ( ) ;\n size_t index = cache . GetIndexOfProfileWithPath ( current_profile -> GetPath ( ) ) ;\n AvatarMenu * menu = GetAvatarMenu ( & cache ) ;\n menu -> RebuildMenu ( ) ;\n BrowserList * browser_list = BrowserList : : GetInstance ( chrome : : GetActiveDesktop ( ) ) ;\n EXPECT_EQ ( 1U , browser_list -> size ( ) ) ;\n content : : WindowedNotificationObserver window_close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , content : : Source < Browser > ( browser ( ) ) ) ;\n EXPECT_FALSE ( cache . ProfileIsSigninRequiredAtIndex ( index ) ) ;\n profiles : : LockProfile ( current_profile ) ;\n window_close_observer . Wait ( ) ;\n EXPECT_TRUE ( cache . ProfileIsSigninRequiredAtIndex ( index ) ) ;\n EXPECT_EQ ( 0U , browser_list -> size ( ) ) ;\n chrome : : HideUserManager ( ) ;\n }",
        "output": "1",
        "idx": 1153
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int selinux_file_mprotect ( struct vm_area_struct * vma , unsigned long reqprot , unsigned long prot ) {\n const struct cred * cred = current_cred ( ) ;\n if ( selinux_checkreqprot ) prot = reqprot ;\n if ( default_noexec && ( prot & PROT_EXEC ) && ! ( vma -> vm_flags & VM_EXEC ) ) {\n int rc = 0 ;\n if ( vma -> vm_start >= vma -> vm_mm -> start_brk && vma -> vm_end <= vma -> vm_mm -> brk ) {\n rc = cred_has_perm ( cred , cred , PROCESS__EXECHEAP ) ;\n }\n else if ( ! vma -> vm_file && ( ( vma -> vm_start <= vma -> vm_mm -> start_stack && vma -> vm_end >= vma -> vm_mm -> start_stack ) || vma_is_stack_for_current ( vma ) ) ) {\n rc = current_has_perm ( current , PROCESS__EXECSTACK ) ;\n }\n else if ( vma -> vm_file && vma -> anon_vma ) {\n rc = file_has_perm ( cred , vma -> vm_file , FILE__EXECMOD ) ;\n }\n if ( rc ) return rc ;\n }\n return file_map_prot_check ( vma -> vm_file , prot , vma -> vm_flags & VM_SHARED ) ;\n }",
        "output": "0",
        "idx": 46
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int remoteStreamHandleRead ( struct qemud_client * client , struct qemud_client_stream * stream ) {\n char * buffer ;\n size_t bufferLen = REMOTE_MESSAGE_PAYLOAD_MAX ;\n int ret ;\n VIR_DEBUG ( \"stream=%p\" , stream ) ;\n if ( ! stream -> tx ) return 0 ;\n if ( VIR_ALLOC_N ( buffer , bufferLen ) < 0 ) return - 1 ;\n ret = virStreamRecv ( stream -> st , buffer , bufferLen ) ;\n if ( ret == - 2 ) {\n ret = 0 ;\n }\n else if ( ret < 0 ) {\n remote_error rerr ;\n memset ( & rerr , 0 , sizeof rerr ) ;\n remoteDispatchConnError ( & rerr , NULL ) ;\n ret = remoteSerializeStreamError ( client , & rerr , stream -> procedure , stream -> serial ) ;\n }\n else {\n stream -> tx = 0 ;\n if ( ret == 0 ) stream -> recvEOF = 1 ;\n ret = remoteSendStreamData ( client , stream , buffer , ret ) ;\n }\n VIR_FREE ( buffer ) ;\n return ret ;\n }",
        "output": "1",
        "idx": 1319
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tgq_idct_put_mb_dconly ( TgqContext * s , AVFrame * frame , int mb_x , int mb_y , const int8_t * dc ) {\n int linesize = frame -> linesize [ 0 ] ;\n uint8_t * dest_y = frame -> data [ 0 ] + ( mb_y * 16 * linesize ) + mb_x * 16 ;\n uint8_t * dest_cb = frame -> data [ 1 ] + ( mb_y * 8 * frame -> linesize [ 1 ] ) + mb_x * 8 ;\n uint8_t * dest_cr = frame -> data [ 2 ] + ( mb_y * 8 * frame -> linesize [ 2 ] ) + mb_x * 8 ;\n tgq_dconly ( s , dest_y , linesize , dc [ 0 ] ) ;\n tgq_dconly ( s , dest_y + 8 , linesize , dc [ 1 ] ) ;\n tgq_dconly ( s , dest_y + 8 * linesize , linesize , dc [ 2 ] ) ;\n tgq_dconly ( s , dest_y + 8 * linesize + 8 , linesize , dc [ 3 ] ) ;\n if ( ! ( s -> avctx -> flags & CODEC_FLAG_GRAY ) ) {\n tgq_dconly ( s , dest_cb , frame -> linesize [ 1 ] , dc [ 4 ] ) ;\n tgq_dconly ( s , dest_cr , frame -> linesize [ 2 ] , dc [ 5 ] ) ;\n }\n }",
        "output": "0",
        "idx": 911
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gsm_a_dtap_mm_stat_init ( new_stat_tap_ui * new_stat , new_stat_tap_gui_init_cb gui_callback , void * gui_data ) {\n gsm_a_stat_init ( new_stat , gui_callback , gui_data , \"GSM A-I/F DTAP Mobility Management Statistics\" , gsm_a_dtap_msg_mm_strings ) ;\n }",
        "output": "0",
        "idx": 1872
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vpx_svc_release ( SvcContext * svc_ctx ) {\n SvcInternal * si ;\n if ( svc_ctx == NULL ) return ;\n si = ( SvcInternal * ) svc_ctx -> internal ;\n if ( si != NULL ) {\n fd_free ( si -> frame_temp ) ;\n fd_free_list ( si -> frame_list ) ;\n if ( si -> rc_stats_buf ) {\n free ( si -> rc_stats_buf ) ;\n }\n free ( si ) ;\n svc_ctx -> internal = NULL ;\n }\n }",
        "output": "1",
        "idx": 2781
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_copy_picture ( Picture * dst , Picture * src ) {\n * dst = * src ;\n dst -> f . type = FF_BUFFER_TYPE_COPY ;\n }",
        "output": "1",
        "idx": 1046
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const unsigned char * seq_decode_op2 ( SeqVideoContext * seq , const unsigned char * src , const unsigned char * src_end , unsigned char * dst ) {\n int i ;\n if ( src_end - src < 8 * 8 ) return NULL ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) {\n memcpy ( dst , src , 8 ) ;\n src += 8 ;\n dst += seq -> frame . linesize [ 0 ] ;\n }\n return src ;\n }",
        "output": "0",
        "idx": 2219
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vp3_decode_flush ( AVCodecContext * avctx ) {\n Vp3DecodeContext * s = avctx -> priv_data ;\n if ( s -> golden_frame . data [ 0 ] ) {\n if ( s -> golden_frame . data [ 0 ] == s -> last_frame . data [ 0 ] ) memset ( & s -> last_frame , 0 , sizeof ( AVFrame ) ) ;\n if ( s -> current_frame . data [ 0 ] == s -> golden_frame . data [ 0 ] ) memset ( & s -> current_frame , 0 , sizeof ( AVFrame ) ) ;\n ff_thread_release_buffer ( avctx , & s -> golden_frame ) ;\n }\n if ( s -> last_frame . data [ 0 ] ) {\n if ( s -> current_frame . data [ 0 ] == s -> last_frame . data [ 0 ] ) memset ( & s -> current_frame , 0 , sizeof ( AVFrame ) ) ;\n ff_thread_release_buffer ( avctx , & s -> last_frame ) ;\n }\n if ( s -> current_frame . data [ 0 ] ) ff_thread_release_buffer ( avctx , & s -> current_frame ) ;\n }",
        "output": "1",
        "idx": 4177
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sbr_sum64x5_c ( float * z ) {\n int k ;\n for ( k = 0 ;\n k < 64 ;\n k ++ ) {\n float f = z [ k ] + z [ k + 64 ] + z [ k + 128 ] + z [ k + 192 ] + z [ k + 256 ] ;\n z [ k ] = f ;\n }\n }",
        "output": "1",
        "idx": 3847
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_FacilityReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 593 \"./asn1/h225/h225.cnf\" gint32 value ;\n h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_FacilityReason , FacilityReason_choice , & value ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> reason = value ;\n }\n return offset ;\n }",
        "output": "0",
        "idx": 1522
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xsltDocumentPtr xsltNewDocument ( xsltTransformContextPtr ctxt , xmlDocPtr doc ) {\n xsltDocumentPtr cur ;\n cur = ( xsltDocumentPtr ) xmlMalloc ( sizeof ( xsltDocument ) ) ;\n if ( cur == NULL ) {\n xsltTransformError ( ctxt , NULL , ( xmlNodePtr ) doc , \"xsltNewDocument : malloc failed\\n\" ) ;\n return ( NULL ) ;\n }\n memset ( cur , 0 , sizeof ( xsltDocument ) ) ;\n cur -> doc = doc ;\n if ( ctxt != NULL ) {\n if ( ! XSLT_IS_RES_TREE_FRAG ( doc ) ) {\n cur -> next = ctxt -> docList ;\n ctxt -> docList = cur ;\n }\n }\n return ( cur ) ;\n }",
        "output": "1",
        "idx": 9
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int64_t vp9_block_error_c ( const int16_t * coeff , const int16_t * dqcoeff , intptr_t block_size , int64_t * ssz ) {\n int i ;\n int64_t error = 0 , sqcoeff = 0 ;\n for ( i = 0 ;\n i < block_size ;\n i ++ ) {\n const int diff = coeff [ i ] - dqcoeff [ i ] ;\n error += diff * diff ;\n sqcoeff += coeff [ i ] * coeff [ i ] ;\n }\n * ssz = sqcoeff ;\n return error ;\n }",
        "output": "1",
        "idx": 2261
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void generate_psnr_packet ( VP9_COMP * cpi ) {\n struct vpx_codec_cx_pkt pkt ;\n int i ;\n PSNR_STATS psnr ;\n calc_psnr ( cpi -> Source , cpi -> common . frame_to_show , & psnr ) ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) {\n pkt . data . psnr . samples [ i ] = psnr . samples [ i ] ;\n pkt . data . psnr . sse [ i ] = psnr . sse [ i ] ;\n pkt . data . psnr . psnr [ i ] = psnr . psnr [ i ] ;\n }\n pkt . kind = VPX_CODEC_PSNR_PKT ;\n vpx_codec_pkt_list_add ( cpi -> output_pkt_list , & pkt ) ;\n }",
        "output": "1",
        "idx": 1040
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dissect_mdns_udp ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree ) {\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"MDNS\" ) ;\n dissect_dns_common ( tvb , pinfo , tree , FALSE , TRUE , FALSE ) ;\n }",
        "output": "0",
        "idx": 2107
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mark_trusted_task_done ( GObject * source_object , GAsyncResult * res , gpointer user_data ) {\n MarkTrustedJob * job = user_data ;\n g_object_unref ( job -> file ) ;\n if ( job -> done_callback ) {\n job -> done_callback ( ! job_aborted ( ( CommonJob * ) job ) , job -> done_callback_data ) ;\n }\n finalize_common ( ( CommonJob * ) job ) ;\n }",
        "output": "1",
        "idx": 3835
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void evhttp_make_header_request ( struct evhttp_connection * evcon , struct evhttp_request * req ) {\n const char * method ;\n evhttp_remove_header ( req -> output_headers , \"Proxy-Connection\" ) ;\n method = evhttp_method ( req -> type ) ;\n evbuffer_add_printf ( evcon -> output_buffer , \"%s %s HTTP/%d.%d\\r\\n\" , method , req -> uri , req -> major , req -> minor ) ;\n if ( req -> type == EVHTTP_REQ_POST && evhttp_find_header ( req -> output_headers , \"Content-Length\" ) == NULL ) {\n char size [ 12 ] ;\n evutil_snprintf ( size , sizeof ( size ) , \"%ld\" , ( long ) EVBUFFER_LENGTH ( req -> output_buffer ) ) ;\n evhttp_add_header ( req -> output_headers , \"Content-Length\" , size ) ;\n }\n }",
        "output": "1",
        "idx": 2558
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void virtio_balloon_handle_output ( VirtIODevice * vdev , VirtQueue * vq ) {\n VirtIOBalloon * s = to_virtio_balloon ( vdev ) ;\n VirtQueueElement elem ;\n MemoryRegionSection section ;\n while ( virtqueue_pop ( vq , & elem ) ) {\n size_t offset = 0 ;\n uint32_t pfn ;\n while ( iov_to_buf ( elem . out_sg , elem . out_num , & pfn , offset , 4 ) == 4 ) {\n ram_addr_t pa ;\n ram_addr_t addr ;\n pa = ( ram_addr_t ) ldl_p ( & pfn ) << VIRTIO_BALLOON_PFN_SHIFT ;\n offset += 4 ;\n section = memory_region_find ( get_system_memory ( ) , pa , 1 ) ;\n if ( ! section . size || ! memory_region_is_ram ( section . mr ) ) continue ;\n addr = section . offset_within_region ;\n balloon_page ( memory_region_get_ram_ptr ( section . mr ) + addr , ! ! ( vq == s -> dvq ) ) ;\n }\n virtqueue_push ( vq , & elem , offset ) ;\n virtio_notify ( vdev , vq ) ;\n }\n }",
        "output": "1",
        "idx": 1693
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( MultiBufferTest , ReadAll ) {\n multibuffer_ . SetMaxWriters ( 1 ) ;\n size_t pos = 0 ;\n size_t end = 10000 ;\n multibuffer_ . SetFileSize ( 10000 ) ;\n multibuffer_ . SetMustReadWholeFile ( true ) ;\n media : : MultiBufferReader reader ( & multibuffer_ , pos , end , base : : Callback < void ( int64_t , int64_t ) > ( ) ) ;\n reader . SetMaxBuffer ( 2000 , 5000 ) ;\n reader . SetPreload ( 1000 , 1000 ) ;\n while ( pos < end ) {\n unsigned char buffer [ 27 ] ;\n buffer [ 17 ] = 17 ;\n size_t to_read = std : : min < size_t > ( end - pos , 17 ) ;\n int64_t bytes_read = reader . TryRead ( buffer , to_read ) ;\n if ( bytes_read ) {\n EXPECT_EQ ( buffer [ 17 ] , 17 ) ;\n for ( int64_t i = 0 ;\n i < bytes_read ;\n i ++ ) {\n uint8_t expected = static_cast < uint8_t > ( ( pos * 15485863 ) >> 16 ) ;\n EXPECT_EQ ( expected , buffer [ i ] ) << \" pos = \" << pos ;\n pos ++ ;\n }\n }\n else {\n Advance ( ) ;\n }\n }\n }",
        "output": "1",
        "idx": 3436
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct key_type * key_type_lookup ( const char * type ) {\n struct key_type * ktype ;\n down_read ( & key_types_sem ) ;\n list_for_each_entry ( ktype , & key_types_list , link ) {\n if ( strcmp ( ktype -> name , type ) == 0 ) goto found_kernel_type ;\n }\n up_read ( & key_types_sem ) ;\n ktype = ERR_PTR ( - ENOKEY ) ;\n found_kernel_type : return ktype ;\n }",
        "output": "0",
        "idx": 181
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void prplcb_conn_disconnected ( PurpleConnection * gc ) {\n struct im_connection * ic = purple_ic_by_gc ( gc ) ;\n if ( ic != NULL ) {\n imc_logout ( ic , ! gc -> wants_to_die ) ;\n }\n }",
        "output": "0",
        "idx": 2356
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fz_colorspace * fz_keep_colorspace_store_key ( fz_context * ctx , fz_colorspace * cs ) {\n return fz_keep_key_storable_key ( ctx , & cs -> key_storable ) ;\n }",
        "output": "0",
        "idx": 1946
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vga_draw_line15_be ( VGACommonState * s1 , uint8_t * d , const uint8_t * s , int width ) {\n int w ;\n uint32_t v , r , g , b ;\n w = width ;\n do {\n v = lduw_be_p ( ( void * ) s ) ;\n r = ( v >> 7 ) & 0xf8 ;\n g = ( v >> 2 ) & 0xf8 ;\n b = ( v << 3 ) & 0xf8 ;\n ( ( uint32_t * ) d ) [ 0 ] = rgb_to_pixel32 ( r , g , b ) ;\n s += 2 ;\n d += 4 ;\n }\n while ( -- w != 0 ) ;\n }",
        "output": "1",
        "idx": 1492
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE cState_indent_set ( VALUE self , VALUE indent ) {\n unsigned long len ;\n GET_STATE ( self ) ;\n Check_Type ( indent , T_STRING ) ;\n len = RSTRING_LEN ( indent ) ;\n if ( len == 0 ) {\n if ( state -> indent ) {\n ruby_xfree ( state -> indent ) ;\n state -> indent = NULL ;\n state -> indent_len = 0 ;\n }\n }\n else {\n if ( state -> indent ) ruby_xfree ( state -> indent ) ;\n state -> indent = strdup ( RSTRING_PTR ( indent ) ) ;\n state -> indent_len = len ;\n }\n return Qnil ;\n }",
        "output": "1",
        "idx": 3075
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void relocate_doit ( void * a ) {\n struct relocate_args * args = ( struct relocate_args * ) a ;\n _dl_relocate_object ( args -> l , args -> l -> l_scope , args -> reloc_mode , 0 ) ;\n }",
        "output": "0",
        "idx": 4214
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemuMonitorJSONAddPCIDisk ( qemuMonitorPtr mon ATTRIBUTE_UNUSED , const char * path ATTRIBUTE_UNUSED , const char * bus ATTRIBUTE_UNUSED , virDomainDevicePCIAddress * guestAddr ATTRIBUTE_UNUSED ) {\n qemuReportError ( VIR_ERR_INTERNAL_ERROR , \"%s\" , _ ( \"pci_add not suppported in JSON mode\" ) ) ;\n return - 1 ;\n }",
        "output": "0",
        "idx": 1837
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_LocationRejectReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 668 \"./asn1/h225/h225.cnf\" gint32 value ;\n h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_LocationRejectReason , LocationRejectReason_choice , & value ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> reason = value ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 1817
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "apr_status_t xml_cleanup ( modsec_rec * msr ) {\n if ( msr -> xml -> doc != NULL ) {\n xmlFreeDoc ( msr -> xml -> doc ) ;\n msr -> xml -> doc = NULL ;\n }\n return 1 ;\n }",
        "output": "0",
        "idx": 2565
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void evhttp_connection_fail ( struct evhttp_connection * evcon , enum evhttp_connection_error error ) {\n struct evhttp_request * req = TAILQ_FIRST ( & evcon -> requests ) ;\n void ( * cb ) ( struct evhttp_request * , void * ) ;\n void * cb_arg ;\n assert ( req != NULL ) ;\n if ( evcon -> flags & EVHTTP_CON_INCOMING ) {\n if ( evhttp_connection_incoming_fail ( req , error ) == - 1 ) evhttp_connection_free ( evcon ) ;\n return ;\n }\n cb = req -> cb ;\n cb_arg = req -> cb_arg ;\n TAILQ_REMOVE ( & evcon -> requests , req , next ) ;\n evhttp_request_free ( req ) ;\n evhttp_connection_reset ( evcon ) ;\n if ( TAILQ_FIRST ( & evcon -> requests ) != NULL ) evhttp_connection_connect ( evcon ) ;\n if ( cb != NULL ) ( * cb ) ( NULL , cb_arg ) ;\n }",
        "output": "1",
        "idx": 666
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gpgme_error_t uiserver_set_protocol ( void * engine , gpgme_protocol_t protocol ) {\n engine_uiserver_t uiserver = engine ;\n if ( protocol != GPGME_PROTOCOL_OpenPGP && protocol != GPGME_PROTOCOL_CMS && protocol != GPGME_PROTOCOL_DEFAULT ) return gpg_error ( GPG_ERR_INV_VALUE ) ;\n uiserver -> protocol = protocol ;\n return 0 ;\n }",
        "output": "0",
        "idx": 2824
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha )",
        "output": "1",
        "idx": 3859
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( TemplateURLTest , ParseURLNoTemplateEnd ) {\n TemplateURLData data ;\n data . SetURL ( \"{\n\" ) ;\n TemplateURL url ( data ) ;\n TemplateURLRef : : Replacements replacements ;\n bool valid = false ;\n EXPECT_EQ ( std : : string ( ) , url . url_ref ( ) . ParseURL ( \"{\n\" , & replacements , NULL , & valid ) ) ;\n EXPECT_TRUE ( replacements . empty ( ) ) ;\n EXPECT_FALSE ( valid ) ;\n }",
        "output": "0",
        "idx": 2037
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void xmlHashFree ( xmlHashTablePtr table , xmlHashDeallocator f ) {\n int i ;\n xmlHashEntryPtr iter ;\n xmlHashEntryPtr next ;\n int inside_table = 0 ;\n int nbElems ;\n if ( table == NULL ) return ;\n if ( table -> table ) {\n nbElems = table -> nbElems ;\n for ( i = 0 ;\n ( i < table -> size ) && ( nbElems > 0 ) ;\n i ++ ) {\n iter = & ( table -> table [ i ] ) ;\n if ( iter -> valid == 0 ) continue ;\n inside_table = 1 ;\n while ( iter ) {\n next = iter -> next ;\n if ( ( f != NULL ) && ( iter -> payload != NULL ) ) f ( iter -> payload , iter -> name ) ;\n if ( table -> dict == NULL ) {\n if ( iter -> name ) xmlFree ( iter -> name ) ;\n if ( iter -> name2 ) xmlFree ( iter -> name2 ) ;\n if ( iter -> name3 ) xmlFree ( iter -> name3 ) ;\n }\n iter -> payload = NULL ;\n if ( ! inside_table ) xmlFree ( iter ) ;\n nbElems -- ;\n inside_table = 0 ;\n iter = next ;\n }\n }\n xmlFree ( table -> table ) ;\n }\n if ( table -> dict ) xmlDictFree ( table -> dict ) ;\n xmlFree ( table ) ;\n }",
        "output": "0",
        "idx": 3404
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void auth_server_connection_disconnect ( struct auth_server_connection * conn , const char * reason ) {\n if ( ! conn -> connected ) return ;\n conn -> connected = FALSE ;\n conn -> handshake_received = FALSE ;\n conn -> version_received = FALSE ;\n conn -> has_plain_mech = FALSE ;\n conn -> server_pid = 0 ;\n conn -> connect_uid = 0 ;\n conn -> cookie = NULL ;\n array_clear ( & conn -> available_auth_mechs ) ;\n timeout_remove ( & conn -> to ) ;\n io_remove ( & conn -> io ) ;\n if ( conn -> fd != - 1 ) {\n i_stream_destroy ( & conn -> input ) ;\n o_stream_destroy ( & conn -> output ) ;\n if ( close ( conn -> fd ) < 0 ) i_error ( \"close(auth server connection) failed: %m\" ) ;\n conn -> fd = - 1 ;\n }\n auth_server_connection_remove_requests ( conn , reason ) ;\n if ( conn -> client -> connect_notify_callback != NULL ) {\n conn -> client -> connect_notify_callback ( conn -> client , FALSE , conn -> client -> connect_notify_context ) ;\n }\n }",
        "output": "0",
        "idx": 3944
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void reconstruct_inter_block ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) {\n struct inter_args * args = ( struct inter_args * ) arg ;\n VP9_COMMON * const cm = args -> cm ;\n MACROBLOCKD * const xd = args -> xd ;\n struct macroblockd_plane * const pd = & xd -> plane [ plane ] ;\n int x , y , eob ;\n txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & x , & y ) ;\n eob = vp9_decode_block_tokens ( cm , xd , plane , block , plane_bsize , x , y , tx_size , args -> r ) ;\n inverse_transform_block ( xd , plane , block , tx_size , & pd -> dst . buf [ 4 * y * pd -> dst . stride + 4 * x ] , pd -> dst . stride , eob ) ;\n * args -> eobtotal += eob ;\n }",
        "output": "0",
        "idx": 2771
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_partial_b64x64_partition ( MODE_INFO * mi , int mis , int bh_in , int bw_in , int row8x8_remaining , int col8x8_remaining , BLOCK_SIZE bsize , MODE_INFO * mi_8x8 ) {\n int bh = bh_in ;\n int r , c ;\n for ( r = 0 ;\n r < MI_BLOCK_SIZE ;\n r += bh ) {\n int bw = bw_in ;\n for ( c = 0 ;\n c < MI_BLOCK_SIZE ;\n c += bw ) {\n const int index = r * mis + c ;\n mi_8x8 [ index ] . src_mi = mi + index ;\n mi_8x8 [ index ] . src_mi -> mbmi . sb_type = find_partition_size ( bsize , row8x8_remaining - r , col8x8_remaining - c , & bh , & bw ) ;\n }\n }\n }",
        "output": "0",
        "idx": 4320
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hb_blob_t * hb_blob_reference ( hb_blob_t * blob ) {\n return hb_object_reference ( blob ) ;\n }",
        "output": "0",
        "idx": 3930
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PQExpBuffer defaultGetLocalPQExpBuffer ( void ) {\n static PQExpBuffer id_return = NULL ;\n if ( id_return ) {\n resetPQExpBuffer ( id_return ) ;\n }\n else {\n id_return = createPQExpBuffer ( ) ;\n }\n return id_return ;\n }",
        "output": "0",
        "idx": 3475
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int evhttp_parse_response_line ( struct evhttp_request * req , char * line ) {\n char * protocol ;\n char * number ;\n char * readable ;\n protocol = strsep ( & line , \" \" ) ;\n if ( line == NULL ) return ( - 1 ) ;\n number = strsep ( & line , \" \" ) ;\n if ( line == NULL ) return ( - 1 ) ;\n readable = line ;\n if ( strcmp ( protocol , \"HTTP/1.0\" ) == 0 ) {\n req -> major = 1 ;\n req -> minor = 0 ;\n }\n else if ( strcmp ( protocol , \"HTTP/1.1\" ) == 0 ) {\n req -> major = 1 ;\n req -> minor = 1 ;\n }\n else {\n event_debug ( ( \"%s: bad protocol \\\"%s\\\"\" , __func__ , protocol ) ) ;\n return ( - 1 ) ;\n }\n req -> response_code = atoi ( number ) ;\n if ( ! evhttp_valid_response_code ( req -> response_code ) ) {\n event_debug ( ( \"%s: bad response code \\\"%s\\\"\" , __func__ , number ) ) ;\n return ( - 1 ) ;\n }\n if ( ( req -> response_code_line = strdup ( readable ) ) == NULL ) event_err ( 1 , \"%s: strdup\" , __func__ ) ;\n return ( 0 ) ;\n }",
        "output": "1",
        "idx": 3719
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kadm5_free_principal ( krb5_context context , krb5_principal val ) {\n register krb5_int32 i ;\n if ( ! val ) return ;\n if ( val -> data ) {\n i = krb5_princ_size ( context , val ) ;\n while ( -- i >= 0 ) krb5_db_free ( context , krb5_princ_component ( context , val , i ) -> data ) ;\n krb5_db_free ( context , val -> data ) ;\n }\n if ( val -> realm . data ) krb5_db_free ( context , val -> realm . data ) ;\n krb5_db_free ( context , val ) ;\n }",
        "output": "0",
        "idx": 2274
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_twopass_postencode_update ( VP9_COMP * cpi ) {\n TWO_PASS * const twopass = & cpi -> twopass ;\n RATE_CONTROL * const rc = & cpi -> rc ;\n const int bits_used = rc -> base_frame_target ;\n rc -> vbr_bits_off_target += rc -> base_frame_target - rc -> projected_frame_size ;\n twopass -> bits_left = MAX ( twopass -> bits_left - bits_used , 0 ) ;\n if ( cpi -> common . frame_type != KEY_FRAME && ! vp9_is_upper_layer_key_frame ( cpi ) ) {\n twopass -> kf_group_bits -= bits_used ;\n }\n twopass -> kf_group_bits = MAX ( twopass -> kf_group_bits , 0 ) ;\n ++ twopass -> gf_group . index ;\n }",
        "output": "1",
        "idx": 1720
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void SetPixelAlpha ( const Image * restrict image , const Quantum alpha , Quantum * restrict pixel ) {\n if ( image -> channel_map [ AlphaPixelChannel ] . traits != UndefinedPixelTrait ) pixel [ image -> channel_map [ AlphaPixelChannel ] . offset ] = alpha ;\n }",
        "output": "0",
        "idx": 3175
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parse_content_type ( struct message_search_context * ctx , struct message_header_line * hdr ) {\n struct rfc822_parser_context parser ;\n string_t * content_type ;\n rfc822_parser_init ( & parser , hdr -> full_value , hdr -> full_value_len , NULL ) ;\n rfc822_skip_lwsp ( & parser ) ;\n content_type = t_str_new ( 64 ) ;\n ( void ) rfc822_parse_content_type ( & parser , content_type ) ;\n ctx -> content_type_text = strncasecmp ( str_c ( content_type ) , \"text/\" , 5 ) == 0 || strncasecmp ( str_c ( content_type ) , \"message/\" , 8 ) == 0 ;\n }",
        "output": "1",
        "idx": 1330
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ImmersiveModeControllerAshTest , EnabledCommands ) {\n ASSERT_FALSE ( controller ( ) -> IsEnabled ( ) ) ;\n EXPECT_TRUE ( chrome : : IsCommandEnabled ( browser ( ) , IDC_OPEN_CURRENT_URL ) ) ;\n EXPECT_TRUE ( chrome : : IsCommandEnabled ( browser ( ) , IDC_ABOUT ) ) ;\n EXPECT_TRUE ( chrome : : IsCommandEnabled ( browser ( ) , IDC_FOCUS_LOCATION ) ) ;\n ToggleFullscreen ( ) ;\n EXPECT_TRUE ( controller ( ) -> IsEnabled ( ) ) ;\n EXPECT_TRUE ( chrome : : IsCommandEnabled ( browser ( ) , IDC_OPEN_CURRENT_URL ) ) ;\n EXPECT_TRUE ( chrome : : IsCommandEnabled ( browser ( ) , IDC_ABOUT ) ) ;\n EXPECT_TRUE ( chrome : : IsCommandEnabled ( browser ( ) , IDC_FOCUS_LOCATION ) ) ;\n }",
        "output": "0",
        "idx": 2114
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_init_dequantizer ( VP9_COMMON * cm ) {\n int q ;\n for ( q = 0 ;\n q < QINDEX_RANGE ;\n q ++ ) {\n cm -> y_dequant [ q ] [ 0 ] = vp9_dc_quant ( q , cm -> y_dc_delta_q ) ;\n cm -> y_dequant [ q ] [ 1 ] = vp9_ac_quant ( q , 0 ) ;\n cm -> uv_dequant [ q ] [ 0 ] = vp9_dc_quant ( q , cm -> uv_dc_delta_q ) ;\n cm -> uv_dequant [ q ] [ 1 ] = vp9_ac_quant ( q , cm -> uv_ac_delta_q ) ;\n }\n }",
        "output": "1",
        "idx": 821
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void * concat_gen_fifos ( void * first , void * second ) {\n gen_fifo * pf1 ;\n gen_fifo * pf2 ;\n pf1 = first ;\n pf2 = second ;\n if ( NULL == pf1 ) return pf2 ;\n else if ( NULL == pf2 ) return pf1 ;\n CONCAT_FIFO ( * pf1 , * pf2 , link ) ;\n free ( pf2 ) ;\n return pf1 ;\n }",
        "output": "0",
        "idx": 1695
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t cpuid_entry_get_reg ( struct kvm_cpuid_entry2 * entry , int reg ) {\n uint32_t ret = 0 ;\n switch ( reg ) {\n case R_EAX : ret = entry -> eax ;\n break ;\n case R_EBX : ret = entry -> ebx ;\n break ;\n case R_ECX : ret = entry -> ecx ;\n break ;\n case R_EDX : ret = entry -> edx ;\n break ;\n }\n return ret ;\n }",
        "output": "0",
        "idx": 2766
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_IsupPrivatePartyNumber ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_IsupPrivatePartyNumber , IsupPrivatePartyNumber_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 2139
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dissect_zcl_ota_upgradeendrsp ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {\n proto_tree_add_item ( tree , hf_zbee_zcl_ota_manufacturer_code , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_ota_image_type , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n dissect_zcl_ota_file_version_field ( tvb , tree , offset ) ;\n proto_tree_add_item ( tree , hf_zbee_zcl_ota_current_time , tvb , * offset , 4 , ENC_LITTLE_ENDIAN ) ;\n * offset += 4 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_ota_upgrade_time , tvb , * offset , 4 , ENC_LITTLE_ENDIAN ) ;\n * offset += 4 ;\n }",
        "output": "0",
        "idx": 3165
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _LMBCSClose ( UConverter * _this ) {\n if ( _this -> extraInfo != NULL ) {\n ulmbcs_byte_t Ix ;\n UConverterDataLMBCS * extraInfo = ( UConverterDataLMBCS * ) _this -> extraInfo ;\n for ( Ix = 0 ;\n Ix <= ULMBCS_GRP_LAST ;\n Ix ++ ) {\n if ( extraInfo -> OptGrpConverter [ Ix ] != NULL ) ucnv_unloadSharedDataIfReady ( extraInfo -> OptGrpConverter [ Ix ] ) ;\n }\n if ( ! _this -> isExtraLocal ) {\n uprv_free ( _this -> extraInfo ) ;\n _this -> extraInfo = NULL ;\n }\n }\n }",
        "output": "1",
        "idx": 439
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipvideo_decode_block_opcode_0x2 ( IpvideoContext * s ) {\n unsigned char B ;\n int x , y ;\n if ( ! s -> is_16bpp ) {\n B = bytestream2_get_byte ( & s -> stream_ptr ) ;\n }\n else {\n B = bytestream2_get_byte ( & s -> mv_ptr ) ;\n }\n if ( B < 56 ) {\n x = 8 + ( B % 7 ) ;\n y = B / 7 ;\n }\n else {\n x = - 14 + ( ( B - 56 ) % 29 ) ;\n y = 8 + ( ( B - 56 ) / 29 ) ;\n }\n av_dlog ( NULL , \" motion byte = %d, (x, y) = (%d, %d)\\n\" , B , x , y ) ;\n return copy_from ( s , & s -> second_last_frame , x , y ) ;\n }",
        "output": "1",
        "idx": 1626
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( ProfileBrowserTest , URLFetcherUsingExtensionContextDuringShutdown ) {\n StartActiveFetcherDuringProfileShutdownTest ( browser ( ) -> profile ( ) -> GetRequestContextForExtensions ( ) ) ;\n }",
        "output": "1",
        "idx": 4218
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vp9_mv_bit_cost ( const MV * mv , const MV * ref , const int * mvjcost , int * mvcost [ 2 ] , int weight ) {\n const MV diff = {\n mv -> row - ref -> row , mv -> col - ref -> col }\n ;\n return ROUND_POWER_OF_TWO ( mv_cost ( & diff , mvjcost , mvcost ) * weight , 7 ) ;\n }",
        "output": "0",
        "idx": 484
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_initialize_me_consts ( VP9_COMP * cpi , int qindex ) {\n cpi -> mb . sadperbit16 = sad_per_bit16lut [ qindex ] ;\n cpi -> mb . sadperbit4 = sad_per_bit4lut [ qindex ] ;\n }",
        "output": "1",
        "idx": 2819
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gboolean logcat_text_time_dump_open ( wtap_dumper * wdh , int * err _U_ ) {\n struct dumper_t * dumper ;\n dumper = ( struct dumper_t * ) g_malloc ( sizeof ( struct dumper_t ) ) ;\n dumper -> type = DUMP_TIME ;\n wdh -> priv = dumper ;\n wdh -> subtype_write = logcat_dump_text ;\n wdh -> subtype_close = NULL ;\n return TRUE ;\n }",
        "output": "0",
        "idx": 1213
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vp3_init_thread_copy ( AVCodecContext * avctx ) {\n Vp3DecodeContext * s = avctx -> priv_data ;\n s -> superblock_coding = NULL ;\n s -> all_fragments = NULL ;\n s -> coded_fragment_list [ 0 ] = NULL ;\n s -> dct_tokens_base = NULL ;\n s -> superblock_fragments = NULL ;\n s -> macroblock_coding = NULL ;\n s -> motion_val [ 0 ] = NULL ;\n s -> motion_val [ 1 ] = NULL ;\n s -> edge_emu_buffer = NULL ;\n return 0 ;\n }",
        "output": "1",
        "idx": 1546
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int evhttp_del_cb ( struct evhttp * http , const char * uri ) {\n struct evhttp_cb * http_cb ;\n TAILQ_FOREACH ( http_cb , & http -> callbacks , next ) {\n if ( strcmp ( http_cb -> what , uri ) == 0 ) break ;\n }\n if ( http_cb == NULL ) return ( - 1 ) ;\n TAILQ_REMOVE ( & http -> callbacks , http_cb , next ) ;\n free ( http_cb -> what ) ;\n free ( http_cb ) ;\n return ( 0 ) ;\n }",
        "output": "0",
        "idx": 2258
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vmport_class_initfn ( ObjectClass * klass , void * data ) {\n DeviceClass * dc = DEVICE_CLASS ( klass ) ;\n dc -> realize = vmport_realizefn ;\n dc -> no_user = 1 ;\n }",
        "output": "0",
        "idx": 4432
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_pvfs_handle_extent ( tvbuff_t * tvb , proto_tree * tree , int offset , packet_info * pinfo , guint32 nCount ) {\n proto_tree * extent_tree ;\n extent_tree = proto_tree_add_subtree_format ( tree , tvb , offset , 8 , ett_pvfs_extent_item , NULL , \"Item %d\" , nCount ) ;\n offset = dissect_pvfs_fh ( tvb , offset , pinfo , extent_tree , \"first handle\" , NULL ) ;\n offset = dissect_pvfs_fh ( tvb , offset , pinfo , extent_tree , \"last handle\" , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 985
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void glyph_info_destroy ( hb_glyph_info_t * g ) {\n free ( g ) ;\n }",
        "output": "1",
        "idx": 1328
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool contain_volatile_functions_walker ( Node * node , void * context ) {\n if ( node == NULL ) return false ;\n if ( check_functions_in_node ( node , contain_volatile_functions_checker , context ) ) return true ;\n if ( IsA ( node , Query ) ) {\n return query_tree_walker ( ( Query * ) node , contain_volatile_functions_walker , context , 0 ) ;\n }\n return expression_tree_walker ( node , contain_volatile_functions_walker , context ) ;\n }",
        "output": "0",
        "idx": 3359
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int update_picture_tables ( Picture * dst , Picture * src ) {\n int i ;\n # define UPDATE_TABLE ( table ) do {\n if ( src -> table && ( ! dst -> table || dst -> table -> buffer != src -> table -> buffer ) ) {\n av_buffer_unref ( & dst -> table ) ;\n dst -> table = av_buffer_ref ( src -> table ) ;\n if ( ! dst -> table ) {\n free_picture_tables ( dst ) ;\n return AVERROR ( ENOMEM ) ;\n }\n }\n \\ }\n while ( 0 ) UPDATE_TABLE ( mb_var_buf ) ;\n UPDATE_TABLE ( mc_mb_var_buf ) ;\n UPDATE_TABLE ( mb_mean_buf ) ;\n UPDATE_TABLE ( mbskip_table_buf ) ;\n UPDATE_TABLE ( qscale_table_buf ) ;\n UPDATE_TABLE ( mb_type_buf ) ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n UPDATE_TABLE ( motion_val_buf [ i ] ) ;\n UPDATE_TABLE ( ref_index_buf [ i ] ) ;\n }\n dst -> mb_var = src -> mb_var ;\n dst -> mc_mb_var = src -> mc_mb_var ;\n dst -> mb_mean = src -> mb_mean ;\n dst -> mbskip_table = src -> mbskip_table ;\n dst -> qscale_table = src -> qscale_table ;\n dst -> mb_type = src -> mb_type ;\n for ( i = 0 ;\n i < 2 ;\n i ++ ) {\n dst -> motion_val [ i ] = src -> motion_val [ i ] ;\n dst -> ref_index [ i ] = src -> ref_index [ i ] ;\n }\n return 0 ;\n }",
        "output": "0",
        "idx": 1548
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void fz_drop_colorspace_context ( fz_context * ctx ) {\n if ( ! ctx ) return ;\n if ( fz_drop_imp ( ctx , ctx -> colorspace , & ctx -> colorspace -> ctx_refs ) ) {\n fz_drop_colorspace ( ctx , ctx -> colorspace -> gray ) ;\n fz_drop_colorspace ( ctx , ctx -> colorspace -> rgb ) ;\n fz_drop_colorspace ( ctx , ctx -> colorspace -> bgr ) ;\n fz_drop_colorspace ( ctx , ctx -> colorspace -> cmyk ) ;\n fz_drop_colorspace ( ctx , ctx -> colorspace -> lab ) ;\n fz_drop_cmm_context ( ctx ) ;\n fz_free ( ctx , ctx -> colorspace ) ;\n ctx -> colorspace = NULL ;\n }\n }",
        "output": "0",
        "idx": 3019
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GType hb_gobject_ ## name ## _get_type ( void ) \\ {\n static gsize type_id = 0 ;\n if ( g_once_init_enter ( & type_id ) ) {\n GType id = g_boxed_type_register_static ( g_intern_static_string ( \"hb_\" # name \"_t\" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;\n g_once_init_leave ( & type_id , id ) ;\n }\n return type_id ;\n \\ }\n # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer )",
        "output": "1",
        "idx": 773
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( NewAvatarMenuButtonTest , MAYBE_SignOut ) {\n if ( ! profiles : : IsMultipleProfilesEnabled ( ) ) return ;\n CreateTestingProfile ( ) ;\n ASSERT_NO_FATAL_FAILURE ( StartAvatarMenu ( ) ) ;\n BrowserList * browser_list = BrowserList : : GetInstance ( chrome : : GetActiveDesktop ( ) ) ;\n EXPECT_EQ ( 1U , browser_list -> size ( ) ) ;\n content : : WindowedNotificationObserver window_close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , content : : Source < Browser > ( browser ( ) ) ) ;\n AvatarMenu * menu = ProfileChooserView : : profile_bubble_ -> avatar_menu_ . get ( ) ;\n const AvatarMenu : : Item & menu_item_before = menu -> GetItemAt ( menu -> GetActiveProfileIndex ( ) ) ;\n EXPECT_FALSE ( menu_item_before . signin_required ) ;\n ui : : MouseEvent mouse_ev ( ui : : ET_MOUSE_RELEASED , gfx : : Point ( ) , gfx : : Point ( ) , 0 , 0 ) ;\n ProfileChooserView : : profile_bubble_ -> ButtonPressed ( ProfileChooserView : : profile_bubble_ -> lock_button_ , mouse_ev ) ;\n EXPECT_TRUE ( menu -> GetItemAt ( menu -> GetActiveProfileIndex ( ) ) . signin_required ) ;\n window_close_observer . Wait ( ) ;\n EXPECT_TRUE ( browser_list -> empty ( ) ) ;\n if ( ! UserManagerView : : IsShowing ( ) ) base : : MessageLoop : : current ( ) -> RunUntilIdle ( ) ;\n chrome : : HideUserManager ( ) ;\n }",
        "output": "1",
        "idx": 19
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static guint16 de_bcc_cause ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len , gchar * add_string _U_ , int string_len _U_ ) {\n guint32 curr_offset ;\n int curr_len ;\n curr_len = len ;\n curr_offset = offset ;\n proto_tree_add_item ( tree , hf_gsm_a_dtap_bcc_cause_structure , tvb , curr_offset , 1 , ENC_NA ) ;\n proto_tree_add_item ( tree , hf_gsm_a_dtap_bcc_cause , tvb , curr_offset , 1 , ENC_NA ) ;\n curr_offset ++ ;\n curr_len -- ;\n EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n return ( curr_offset - offset ) ;\n }",
        "output": "0",
        "idx": 3120
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dissect_h225_NonStandardParameter ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 803 \"./asn1/h225/h225.cnf\" nsp_handle = NULL ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_NonStandardParameter , NonStandardParameter_sequence ) ;\n return offset ;\n }",
        "output": "1",
        "idx": 1673
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_DestinationInfo_item ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 310 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> is_destinationInfo = TRUE ;\n }\n offset = dissect_h225_AliasAddress ( tvb , offset , actx , tree , hf_index ) ;\n return offset ;\n }",
        "output": "1",
        "idx": 1142
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int TSStatCreate ( const char * the_name , TSRecordDataType the_type , TSStatPersistence persist , TSStatSync sync ) {\n int id = ink_atomic_increment ( & api_rsb_index , 1 ) ;\n RecRawStatSyncCb syncer = RecRawStatSyncCount ;\n if ( ( sdk_sanity_check_null_ptr ( ( void * ) the_name ) != TS_SUCCESS ) || ( sdk_sanity_check_null_ptr ( ( void * ) api_rsb ) != TS_SUCCESS ) || ( id >= api_rsb -> max_stats ) ) {\n return TS_ERROR ;\n }\n switch ( sync ) {\n case TS_STAT_SYNC_SUM : syncer = RecRawStatSyncSum ;\n break ;\n case TS_STAT_SYNC_AVG : syncer = RecRawStatSyncAvg ;\n break ;\n case TS_STAT_SYNC_TIMEAVG : syncer = RecRawStatSyncHrTimeAvg ;\n break ;\n default : syncer = RecRawStatSyncCount ;\n break ;\n }\n switch ( persist ) {\n case TS_STAT_PERSISTENT : RecRegisterRawStat ( api_rsb , RECT_PLUGIN , the_name , ( RecDataT ) the_type , RECP_PERSISTENT , id , syncer ) ;\n break ;\n case TS_STAT_NON_PERSISTENT : RecRegisterRawStat ( api_rsb , RECT_PLUGIN , the_name , ( RecDataT ) the_type , RECP_NON_PERSISTENT , id , syncer ) ;\n break ;\n default : return TS_ERROR ;\n }\n return id ;\n }",
        "output": "0",
        "idx": 758
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ExternalProtocolHandlerTest , TestGetBlockStateLocalBlockStateCopiedAndResetOnProfilePref ) {\n base : : DictionaryValue prefs_local ;\n prefs_local . SetBoolean ( \"tel\" , true ) ;\n local_state_ -> Set ( prefs : : kExcludedSchemes , prefs_local ) ;\n ExternalProtocolHandler : : BlockState block_state = ExternalProtocolHandler : : GetBlockState ( \"tel\" , profile_ . get ( ) ) ;\n EXPECT_EQ ( ExternalProtocolHandler : : UNKNOWN , block_state ) ;\n EXPECT_TRUE ( local_state_ -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;\n EXPECT_FALSE ( profile_ -> GetPrefs ( ) -> GetDictionary ( prefs : : kExcludedSchemes ) -> empty ( ) ) ;\n }",
        "output": "1",
        "idx": 1065
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( AccountChooserDialogAndroidTest , CheckHistogramsReportingOnceAccountViaOnAccountClick ) {\n base : : HistogramTester histogram_tester ;\n AccountChooserDialogAndroid * dialog = CreateDialogOneAccount ( ) ;\n dialog -> OnCredentialClicked ( base : : android : : AttachCurrentThread ( ) , nullptr , , static_cast < int > ( password_manager : : CredentialType : : CREDENTIAL_TYPE_PASSWORD ) , false ) ;\n dialog -> Destroy ( base : : android : : AttachCurrentThread ( ) , nullptr ) ;\n histogram_tester . ExpectUniqueSample ( \"PasswordManager.AccountChooserDialog\" , password_manager : : metrics_util : : ACCOUNT_CHOOSER_CREDENTIAL_CHOSEN , 1 ) ;\n histogram_tester . ExpectUniqueSample ( \"PasswordManager.AccountChooserDialogOneAccount\" , password_manager : : metrics_util : : ACCOUNT_CHOOSER_CREDENTIAL_CHOSEN , 1 ) ;\n histogram_tester . ExpectTotalCount ( \"PasswordManager.AccountChooserDialogMultipleAccounts\" , 0 ) ;\n }",
        "output": "0",
        "idx": 636
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST ( BuildTime , TimeLooksValid ) {\n # if defined ( DONT_EMBED_BUILD_METADATA ) char build_time [ ] = \"08:00:00\" ;\n # else char build_time [ ] = __TIME__ ;\n # endif EXPECT_EQ ( 8u , strlen ( build_time ) ) ;\n EXPECT_EQ ( ':' , build_time [ 2 ] ) ;\n EXPECT_EQ ( ':' , build_time [ 5 ] ) ;\n }",
        "output": "1",
        "idx": 4470
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * wv_csp10_opaque_binary_tag ( tvbuff_t * tvb , guint32 offset , guint8 token , guint8 codepage , guint32 * length ) {\n guint32 data_len = tvb_get_guintvar ( tvb , offset , length ) ;\n char * str = NULL ;\n switch ( codepage ) {\n case 0 : switch ( token ) {\n case 0x0B : case 0x0F : case 0x1A : case 0x3C : str = wv_integer_from_opaque ( tvb , offset + * length , data_len ) ;\n break ;\n case 0x11 : str = wv_datetime_from_opaque ( tvb , offset + * length , data_len ) ;\n break ;\n default : break ;\n }\n break ;\n case 1 : switch ( token ) {\n case 0x1C : case 0x32 : str = wv_integer_from_opaque ( tvb , offset + * length , data_len ) ;\n break ;\n default : break ;\n }\n break ;\n case 3 : switch ( token ) {\n case 0x06 : case 0x0C : case 0x0D : case 0x0E : case 0x11 : case 0x12 : case 0x13 : str = wv_integer_from_opaque ( tvb , offset + * length , data_len ) ;\n break ;\n default : break ;\n }\n break ;\n default : break ;\n }\n if ( str == NULL ) {\n str = wmem_strdup_printf ( wmem_packet_scope ( ) , \"(%d bytes of unparsed opaque data)\" , data_len ) ;\n }\n * length += data_len ;\n return str ;\n }",
        "output": "0",
        "idx": 211
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void check_data_home ( const char * path ) {\n }",
        "output": "0",
        "idx": 2516
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipvideo_decode_block_opcode_0x6_16 ( IpvideoContext * s ) {\n signed char x , y ;\n x = bytestream2_get_byte ( & s -> stream_ptr ) ;\n y = bytestream2_get_byte ( & s -> stream_ptr ) ;\n av_dlog ( NULL , \" motion bytes = %d, %d\\n\" , x , y ) ;\n return copy_from ( s , & s -> second_last_frame , x , y ) ;\n }",
        "output": "1",
        "idx": 2711
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t u_printf_octal_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n int64_t num = args [ 0 ] . int64Value ;\n UChar result [ UPRINTF_BUFFER_SIZE ] ;\n int32_t len = UPRINTF_BUFFER_SIZE ;\n if ( info -> fIsShort ) num &= UINT16_MAX ;\n else if ( ! info -> fIsLongLong ) num &= UINT32_MAX ;\n ufmt_64tou ( result , & len , num , 8 , FALSE , info -> fPrecision == - 1 && info -> fZero ? info -> fWidth : info -> fPrecision ) ;\n if ( info -> fAlt && result [ 0 ] != 0x0030 && len < UPRINTF_BUFFER_SIZE - 1 ) {\n memmove ( result + 1 , result , len * sizeof ( UChar ) ) ;\n result [ 0 ] = 0x0030 ;\n len += 1 ;\n }\n return handler -> pad_and_justify ( context , info , result , len ) ;\n }",
        "output": "1",
        "idx": 1661
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl ) ;\n __exctype ( isdigit ) ;\n __exctype ( islower ) ;\n __exctype ( isgraph ) ;\n __exctype ( isprint ) ;\n __exctype ( ispunct )",
        "output": "1",
        "idx": 595
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void final_reordering ( const hb_ot_shape_plan_t * plan , hb_font_t * font HB_UNUSED , hb_buffer_t * buffer ) {\n unsigned int count = buffer -> len ;\n if ( unlikely ( ! count ) ) return ;\n hb_glyph_info_t * info = buffer -> info ;\n unsigned int last = 0 ;\n unsigned int last_syllable = info [ 0 ] . syllable ( ) ;\n for ( unsigned int i = 1 ;\n i < count ;\n i ++ ) if ( last_syllable != info [ i ] . syllable ( ) ) {\n final_reordering_syllable ( plan , buffer , last , i ) ;\n last = i ;\n last_syllable = info [ last ] . syllable ( ) ;\n }\n final_reordering_syllable ( plan , buffer , last , count ) ;\n HB_BUFFER_DEALLOCATE_VAR ( buffer , indic_category ) ;\n HB_BUFFER_DEALLOCATE_VAR ( buffer , indic_position ) ;\n }",
        "output": "1",
        "idx": 4372
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;\n __exctype_l ( isalpha_l ) ;\n __exctype_l ( iscntrl_l ) ;\n __exctype_l ( isdigit_l ) ;\n __exctype_l ( islower_l ) ;\n __exctype_l ( isgraph_l ) ;\n __exctype_l ( isprint_l ) ;\n __exctype_l ( ispunct_l ) ;\n __exctype_l ( isspace_l ) ;\n __exctype_l ( isupper_l )",
        "output": "1",
        "idx": 316
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cinepak_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int ret = 0 , buf_size = avpkt -> size ;\n CinepakContext * s = avctx -> priv_data ;\n s -> data = buf ;\n s -> size = buf_size ;\n if ( ( ret = ff_reget_buffer ( avctx , & s -> frame ) ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( s -> palette_video ) {\n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n if ( pal ) {\n s -> frame . palette_has_changed = 1 ;\n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n }\n }\n cinepak_decode ( s ) ;\n if ( s -> palette_video ) memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n if ( ( ret = av_frame_ref ( data , & s -> frame ) ) < 0 ) return ret ;\n * got_frame = 1 ;\n return buf_size ;\n }",
        "output": "0",
        "idx": 2854
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void curl_setup_http_get ( CURL * curl , const char * url , const char * custom_req ) {\n curl_easy_setopt ( curl , CURLOPT_HTTPGET , 1 ) ;\n curl_easy_setopt ( curl , CURLOPT_URL , url ) ;\n curl_easy_setopt ( curl , CURLOPT_CUSTOMREQUEST , custom_req ) ;\n curl_easy_setopt ( curl , CURLOPT_WRITEFUNCTION , fwrite_null ) ;\n }",
        "output": "0",
        "idx": 76
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_DestinationInfo_item ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 312 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> is_destinationInfo = TRUE ;\n }\n offset = dissect_h225_AliasAddress ( tvb , offset , actx , tree , hf_index ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 498
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pdf_run_W ( fz_context * ctx , pdf_processor * proc ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n pr -> clip = 1 ;\n pr -> clip_even_odd = 0 ;\n }",
        "output": "0",
        "idx": 3541
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dissect_zcl_energy_phase ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {\n proto_tree_add_item ( tree , hf_zbee_zcl_pwr_prof_energy_phase_id , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_pwr_prof_macro_phase_id , tvb , * offset , 1 , ENC_NA ) ;\n * offset += 1 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_pwr_prof_expect_duration , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_pwr_prof_peak_power , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_pwr_prof_energy , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_pwr_prof_max_active_delay , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n }",
        "output": "0",
        "idx": 2144
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int floor_log2 ( uint32 n ) {\n int logval = 0 ;\n if ( n == 0 ) return - 1 ;\n if ( n >= ( 1 << 16 ) ) {\n n >>= 16 ;\n logval += 16 ;\n }\n if ( n >= ( 1 << 8 ) ) {\n n >>= 8 ;\n logval += 8 ;\n }\n if ( n >= ( 1 << 4 ) ) {\n n >>= 4 ;\n logval += 4 ;\n }\n if ( n >= ( 1 << 2 ) ) {\n n >>= 2 ;\n logval += 2 ;\n }\n if ( n >= ( 1 << 1 ) ) {\n logval += 1 ;\n }\n return logval ;\n }",
        "output": "0",
        "idx": 3751
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int RECORD_LAYER_read_pending ( const RECORD_LAYER * rl ) {\n return SSL3_BUFFER_get_left ( & rl -> rbuf ) != 0 ;\n }",
        "output": "0",
        "idx": 363
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "END_TEST START_TEST ( test_find_user_by_ip ) {\n in_addr_t ip ;\n unsigned int testip ;\n ip = inet_addr ( \"127.0.0.1\" ) ;\n init_users ( ip , 27 ) ;\n users [ 0 ] . conn = CONN_DNS_NULL ;\n testip = ( unsigned int ) inet_addr ( \"10.0.0.1\" ) ;\n fail_unless ( find_user_by_ip ( testip ) == - 1 ) ;\n testip = ( unsigned int ) inet_addr ( \"127.0.0.2\" ) ;\n fail_unless ( find_user_by_ip ( testip ) == - 1 ) ;\n users [ 0 ] . active = 1 ;\n testip = ( unsigned int ) inet_addr ( \"127.0.0.2\" ) ;\n fail_unless ( find_user_by_ip ( testip ) == - 1 ) ;\n users [ 0 ] . last_pkt = time ( NULL ) ;\n testip = ( unsigned int ) inet_addr ( \"127.0.0.2\" ) ;\n fail_unless ( find_user_by_ip ( testip ) == 0 ) ;\n }",
        "output": "1",
        "idx": 2747
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int selinux_ptrace_traceme ( struct task_struct * parent ) {\n return task_has_perm ( parent , current , PROCESS__PTRACE ) ;\n }",
        "output": "0",
        "idx": 2847
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PKCS7 * d2i_PKCS7_fp ( FILE * fp , PKCS7 * * p7 ) {\n return ASN1_item_d2i_fp ( ASN1_ITEM_rptr ( PKCS7 ) , fp , p7 ) ;\n }",
        "output": "0",
        "idx": 956
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t compareMappingsBytesFirst ( const void * context , const void * left , const void * right ) {\n UCMTable * table = ( UCMTable * ) context ;\n int32_t l = * ( const int32_t * ) left , r = * ( const int32_t * ) right ;\n return compareMappings ( table , table -> mappings + l , table , table -> mappings + r , FALSE ) ;\n }",
        "output": "1",
        "idx": 4184
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_IS11172AudioCapability ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_IS11172AudioCapability , IS11172AudioCapability_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 3528
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PyObject * authGSSServerTargetName ( PyObject * self , PyObject * args ) {\n gss_server_state * state ;\n PyObject * pystate ;\n if ( ! PyArg_ParseTuple ( args , \"O\" , & pystate ) ) return NULL ;\n # if PY_MAJOR_VERSION >= 3 if ( ! PyCapsule_CheckExact ( pystate ) ) {\n # else if ( ! PyCObject_Check ( pystate ) ) {\n # endif PyErr_SetString ( PyExc_TypeError , \"Expected a context object\" ) ;\n return NULL ;\n }\n # if PY_MAJOR_VERSION >= 3 state = PyCapsule_GetPointer ( pystate , NULL ) ;\n # else state = ( gss_client_state * ) PyCObject_AsVoidPtr ( pystate ) ;\n # endif if ( state == NULL ) return NULL ;\n return Py_BuildValue ( \"s\" , state -> targetname ) ;\n }",
        "output": "1",
        "idx": 1763
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_Ind_multiplex ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_Ind_multiplex , Ind_multiplex_choice , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 371
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int SpoolssDeletePrinter_r ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep _U_ ) {\n offset = dissect_nt_policy_hnd ( tvb , offset , pinfo , tree , di , drep , hf_hnd , NULL , NULL , FALSE , FALSE ) ;\n offset = dissect_doserror ( tvb , offset , pinfo , tree , di , drep , hf_rc , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 4104
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int init_dumping ( char * database , int init_func ( char * ) ) {\n if ( mysql_select_db ( mysql , database ) ) {\n DB_error ( mysql , \"when selecting the database\" ) ;\n return 1 ;\n }\n if ( ! path && ! opt_xml ) {\n if ( opt_databases || opt_alldbs ) {\n char quoted_database_buf [ NAME_LEN * 2 + 3 ] ;\n char * qdatabase = quote_name ( database , quoted_database_buf , opt_quoted ) ;\n print_comment ( md_result_file , 0 , \"\\n--\\n-- Current Database: %s\\n--\\n\" , qdatabase ) ;\n init_func ( qdatabase ) ;\n fprintf ( md_result_file , \"\\nUSE %s;\n\\n\" , qdatabase ) ;\n check_io ( md_result_file ) ;\n }\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 3750
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int find_fp_qindex ( ) {\n int i ;\n for ( i = 0 ;\n i < QINDEX_RANGE ;\n ++ i ) if ( vp9_convert_qindex_to_q ( i ) >= 30.0 ) break ;\n if ( i == QINDEX_RANGE ) i -- ;\n return i ;\n }",
        "output": "1",
        "idx": 3507
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void tqi_idct_put ( TqiContext * t , int16_t ( * block ) [ 64 ] ) {\n MpegEncContext * s = & t -> s ;\n int linesize = t -> frame . linesize [ 0 ] ;\n uint8_t * dest_y = t -> frame . data [ 0 ] + ( s -> mb_y * 16 * linesize ) + s -> mb_x * 16 ;\n uint8_t * dest_cb = t -> frame . data [ 1 ] + ( s -> mb_y * 8 * t -> frame . linesize [ 1 ] ) + s -> mb_x * 8 ;\n uint8_t * dest_cr = t -> frame . data [ 2 ] + ( s -> mb_y * 8 * t -> frame . linesize [ 2 ] ) + s -> mb_x * 8 ;\n ff_ea_idct_put_c ( dest_y , linesize , block [ 0 ] ) ;\n ff_ea_idct_put_c ( dest_y + 8 , linesize , block [ 1 ] ) ;\n ff_ea_idct_put_c ( dest_y + 8 * linesize , linesize , block [ 2 ] ) ;\n ff_ea_idct_put_c ( dest_y + 8 * linesize + 8 , linesize , block [ 3 ] ) ;\n if ( ! ( s -> avctx -> flags & CODEC_FLAG_GRAY ) ) {\n ff_ea_idct_put_c ( dest_cb , t -> frame . linesize [ 1 ] , block [ 4 ] ) ;\n ff_ea_idct_put_c ( dest_cr , t -> frame . linesize [ 2 ] , block [ 5 ] ) ;\n }\n }",
        "output": "1",
        "idx": 1881
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cinepak_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n const uint8_t * buf = avpkt -> data ;\n int ret = 0 , buf_size = avpkt -> size ;\n CinepakContext * s = avctx -> priv_data ;\n s -> data = buf ;\n s -> size = buf_size ;\n s -> frame . reference = 1 ;\n s -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ;\n if ( ( ret = avctx -> reget_buffer ( avctx , & s -> frame ) ) ) {\n av_log ( avctx , AV_LOG_ERROR , \"reget_buffer() failed\\n\" ) ;\n return ret ;\n }\n if ( s -> palette_video ) {\n const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , NULL ) ;\n if ( pal ) {\n s -> frame . palette_has_changed = 1 ;\n memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ;\n }\n }\n cinepak_decode ( s ) ;\n if ( s -> palette_video ) memcpy ( s -> frame . data [ 1 ] , s -> pal , AVPALETTE_SIZE ) ;\n * got_frame = 1 ;\n * ( AVFrame * ) data = s -> frame ;\n return buf_size ;\n }",
        "output": "1",
        "idx": 1296
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern int name ( int , locale_t ) __THROW __exctype_l ( isalnum_l ) ;\n __exctype_l ( isalpha_l ) ;\n __exctype_l ( iscntrl_l ) ;\n __exctype_l ( isdigit_l ) ;\n __exctype_l ( islower_l ) ;\n __exctype_l ( isgraph_l ) ;\n __exctype_l ( isprint_l ) ;\n __exctype_l ( ispunct_l ) ;\n __exctype_l ( isspace_l )",
        "output": "1",
        "idx": 4349
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mark_all_files_unconfirmed ( NautilusDirectory * directory ) {\n GList * node ;\n NautilusFile * file ;\n for ( node = directory -> details -> file_list ;\n node != NULL ;\n node = node -> next ) {\n file = node -> data ;\n set_file_unconfirmed ( file , TRUE ) ;\n }\n }",
        "output": "0",
        "idx": 4142
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int jpc_ft_analyze ( jpc_fix_t * a , int xstart , int ystart , int width , int height , int stride ) {\n int numrows = height ;\n int numcols = width ;\n int rowparity = ystart & 1 ;\n int colparity = xstart & 1 ;\n int i ;\n jpc_fix_t * startptr ;\n int maxcols ;\n maxcols = ( numcols / JPC_QMFB_COLGRPSIZE ) * JPC_QMFB_COLGRPSIZE ;\n startptr = & a [ 0 ] ;\n for ( i = 0 ;\n i < maxcols ;\n i += JPC_QMFB_COLGRPSIZE ) {\n jpc_qmfb_split_colgrp ( startptr , numrows , stride , rowparity ) ;\n jpc_ft_fwdlift_colgrp ( startptr , numrows , stride , rowparity ) ;\n startptr += JPC_QMFB_COLGRPSIZE ;\n }\n if ( maxcols < numcols ) {\n jpc_qmfb_split_colres ( startptr , numrows , numcols - maxcols , stride , rowparity ) ;\n jpc_ft_fwdlift_colres ( startptr , numrows , numcols - maxcols , stride , rowparity ) ;\n }\n startptr = & a [ 0 ] ;\n for ( i = 0 ;\n i < numrows ;\n ++ i ) {\n jpc_qmfb_split_row ( startptr , numcols , colparity ) ;\n jpc_ft_fwdlift_row ( startptr , numcols , colparity ) ;\n startptr += stride ;\n }\n return 0 ;\n }",
        "output": "0",
        "idx": 770
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void * pdf_new_processor ( fz_context * ctx , int size ) {\n return Memento_label ( fz_calloc ( ctx , 1 , size ) , \"pdf_processor\" ) ;\n }",
        "output": "0",
        "idx": 4057
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern int name ( int ) __THROW __exctype ( isalnum ) ;\n __exctype ( isalpha ) ;\n __exctype ( iscntrl ) ;\n __exctype ( isdigit ) ;\n __exctype ( islower ) ;\n __exctype ( isgraph )",
        "output": "1",
        "idx": 2269
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_encode_sby_pass1 ( MACROBLOCK * x , BLOCK_SIZE bsize ) {\n vp9_subtract_plane ( x , bsize , 0 ) ;\n vp9_foreach_transformed_block_in_plane ( & x -> e_mbd , bsize , 0 , encode_block_pass1 , x ) ;\n }",
        "output": "0",
        "idx": 1937
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int encode_offset ( char * string , struct filter_op * fop ) {\n char * str , * p , * q , * tok ;\n int ret ;\n memset ( fop , 0 , sizeof ( struct filter_op ) ) ;\n str = strdup ( string ) ;\n p = ec_strtok ( str , \".\" , & tok ) ;\n q = ec_strtok ( NULL , \".\" , & tok ) ;\n if ( q == NULL ) return - E_NOTFOUND ;\n ret = get_virtualpointer ( p , q , & fop -> op . test . level , & fop -> op . test . offset , & fop -> op . test . size ) ;\n SAFE_FREE ( str ) ;\n return ret ;\n }",
        "output": "0",
        "idx": 436
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tipc_nl_compat_link_dump ( struct tipc_nl_compat_msg * msg , struct nlattr * * attrs ) {\n struct nlattr * link [ TIPC_NLA_LINK_MAX + 1 ] ;\n struct tipc_link_info link_info ;\n int err ;\n if ( ! attrs [ TIPC_NLA_LINK ] ) return - EINVAL ;\n err = nla_parse_nested ( link , TIPC_NLA_LINK_MAX , attrs [ TIPC_NLA_LINK ] , NULL ) ;\n if ( err ) return err ;\n link_info . dest = nla_get_flag ( link [ TIPC_NLA_LINK_DEST ] ) ;\n link_info . up = htonl ( nla_get_flag ( link [ TIPC_NLA_LINK_UP ] ) ) ;\n strcpy ( link_info . str , nla_data ( link [ TIPC_NLA_LINK_NAME ] ) ) ;\n return tipc_add_tlv ( msg -> rep , TIPC_TLV_LINK_INFO , & link_info , sizeof ( link_info ) ) ;\n }",
        "output": "1",
        "idx": 1686
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Asn1Generic * DecodeAsn1DerPrintableString ( const unsigned char * buffer , uint32_t max_size , uint8_t depth , uint32_t * errcode ) {\n const unsigned char * d_ptr = buffer ;\n uint32_t length , numbytes ;\n Asn1Generic * a ;\n unsigned char c ;\n d_ptr ++ ;\n c = d_ptr [ 0 ] ;\n if ( ( c & ( 1 << 7 ) ) >> 7 == 0 ) {\n length = c ;\n d_ptr ++ ;\n }\n else {\n numbytes = c & 0x7f ;\n d_ptr ++ ;\n if ( DecodeAsn1BuildValue ( & d_ptr , & length , numbytes , errcode ) == - 1 ) {\n return NULL ;\n }\n }\n if ( length > max_size ) return NULL ;\n a = Asn1GenericNew ( ) ;\n if ( a == NULL ) return NULL ;\n a -> type = ASN1_PRINTSTRING ;\n a -> strlen = length ;\n a -> str = SCMalloc ( length + 1 ) ;\n if ( a -> str == NULL ) {\n SCFree ( a ) ;\n return NULL ;\n }\n strlcpy ( a -> str , ( const char * ) d_ptr , length + 1 ) ;\n a -> str [ length ] = '\\0' ;\n d_ptr += length ;\n a -> length = ( d_ptr - buffer ) ;\n return a ;\n }",
        "output": "1",
        "idx": 1274
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int fn_printn ( netdissect_options * ndo , register const u_char * s , register u_int n , register const u_char * ep ) {\n register u_char c ;\n while ( n > 0 && ( ep == NULL || s < ep ) ) {\n n -- ;\n c = * s ++ ;\n if ( ! ND_ISASCII ( c ) ) {\n c = ND_TOASCII ( c ) ;\n ND_PRINT ( ( ndo , \"M-\" ) ) ;\n }\n if ( ! ND_ISPRINT ( c ) ) {\n c ^= 0x40 ;\n ND_PRINT ( ( ndo , \"^\" ) ) ;\n }\n ND_PRINT ( ( ndo , \"%c\" , c ) ) ;\n }\n return ( n == 0 ) ? 0 : 1 ;\n }",
        "output": "0",
        "idx": 1839
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void set_num_733 ( unsigned char * p , uint32_t value ) {\n archive_le32enc ( p , value ) ;\n archive_be32enc ( p + 4 , value ) ;\n }",
        "output": "0",
        "idx": 2707
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_T_oid ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 871 \"./asn1/h225/h225.cnf\" const gchar * oid_str = NULL ;\n gef_ctx_t * gefx ;\n offset = dissect_per_object_identifier_str ( tvb , offset , actx , tree , hf_index , & oid_str ) ;\n gefx = gef_ctx_get ( actx -> private_data ) ;\n if ( gefx ) gefx -> id = oid_str ;\n return offset ;\n }",
        "output": "1",
        "idx": 1123
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spl_ptr_llist_destroy ( spl_ptr_llist * llist TSRMLS_DC ) {\n spl_ptr_llist_element * current = llist -> head , * next ;\n spl_ptr_llist_dtor_func dtor = llist -> dtor ;\n while ( current ) {\n next = current -> next ;\n if ( current && dtor ) {\n dtor ( current TSRMLS_CC ) ;\n }\n SPL_LLIST_DELREF ( current ) ;\n current = next ;\n }\n efree ( llist ) ;\n }",
        "output": "0",
        "idx": 1620
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sbr_qmf_analysis ( AVFloatDSPContext * dsp , FFTContext * mdct , SBRDSPContext * sbrdsp , const float * in , float * x , float z [ 320 ] , float W [ 2 ] [ 32 ] [ 32 ] [ 2 ] , int buf_idx ) {\n int i ;\n memcpy ( x , x + 1024 , ( 320 - 32 ) * sizeof ( x [ 0 ] ) ) ;\n memcpy ( x + 288 , in , 1024 * sizeof ( x [ 0 ] ) ) ;\n for ( i = 0 ;\n i < 32 ;\n i ++ ) {\n dsp -> vector_fmul_reverse ( z , sbr_qmf_window_ds , x , 320 ) ;\n sbrdsp -> sum64x5 ( z ) ;\n sbrdsp -> qmf_pre_shuffle ( z ) ;\n mdct -> imdct_half ( mdct , z , z + 64 ) ;\n sbrdsp -> qmf_post_shuffle ( W [ buf_idx ] [ i ] , z ) ;\n x += 32 ;\n }\n }",
        "output": "1",
        "idx": 414
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void vmsvga_fill_rect ( struct vmsvga_state_s * s , uint32_t c , int x , int y , int w , int h ) {\n DisplaySurface * surface = qemu_console_surface ( s -> vga . con ) ;\n int bypl = surface_stride ( surface ) ;\n int width = surface_bytes_per_pixel ( surface ) * w ;\n int line = h ;\n int column ;\n uint8_t * fst ;\n uint8_t * dst ;\n uint8_t * src ;\n uint8_t col [ 4 ] ;\n col [ 0 ] = c ;\n col [ 1 ] = c >> 8 ;\n col [ 2 ] = c >> 16 ;\n col [ 3 ] = c >> 24 ;\n fst = s -> vga . vram_ptr + surface_bytes_per_pixel ( surface ) * x + bypl * y ;\n if ( line -- ) {\n dst = fst ;\n src = col ;\n for ( column = width ;\n column > 0 ;\n column -- ) {\n * ( dst ++ ) = * ( src ++ ) ;\n if ( src - col == surface_bytes_per_pixel ( surface ) ) {\n src = col ;\n }\n }\n dst = fst ;\n for ( ;\n line > 0 ;\n line -- ) {\n dst += bypl ;\n memcpy ( dst , fst , width ) ;\n }\n }\n vmsvga_update_rect_delayed ( s , x , y , w , h ) ;\n }",
        "output": "1",
        "idx": 3502
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ps2_kbd_pre_save ( void * opaque ) {\n PS2KbdState * s = ( PS2KbdState * ) opaque ;\n PS2State * ps2 = & s -> common ;\n ps2_common_post_load ( ps2 ) ;\n return 0 ;\n }",
        "output": "0",
        "idx": 215
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void init_mv ( FourXContext * f ) {\n int i ;\n for ( i = 0 ;\n i < 256 ;\n i ++ ) {\n if ( f -> version > 1 ) f -> mv [ i ] = mv [ i ] [ 0 ] + mv [ i ] [ 1 ] * f -> current_picture -> linesize [ 0 ] / 2 ;\n else f -> mv [ i ] = ( i & 15 ) - 8 + ( ( i >> 4 ) - 8 ) * f -> current_picture -> linesize [ 0 ] / 2 ;\n }\n }",
        "output": "1",
        "idx": 2376
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( SupervisedUserNavigationThrottleTest , NoNavigationObserverBlock ) {\n Profile * profile = browser ( ) -> profile ( ) ;\n SupervisedUserSettingsService * supervised_user_settings_service = SupervisedUserSettingsServiceFactory : : GetForProfile ( profile ) ;\n supervised_user_settings_service -> SetLocalSetting ( supervised_users : : kContentPackDefaultFilteringBehavior , std : : unique_ptr < base : : Value > ( new base : : Value ( SupervisedUserURLFilter : : BLOCK ) ) ) ;\n std : : unique_ptr < WebContents > web_contents ( WebContents : : Create ( WebContents : : CreateParams ( profile ) ) ) ;\n NavigationController & controller = web_contents -> GetController ( ) ;\n content : : TestNavigationObserver observer ( web_contents . get ( ) ) ;\n controller . LoadURL ( GURL ( \"http://www.example.com\" ) , content : : Referrer ( ) , ui : : PAGE_TRANSITION_TYPED , std : : string ( ) ) ;\n observer . Wait ( ) ;\n content : : NavigationEntry * entry = controller . GetActiveEntry ( ) ;\n ASSERT_TRUE ( entry ) ;\n EXPECT_EQ ( content : : PAGE_TYPE_NORMAL , entry -> GetPageType ( ) ) ;\n EXPECT_FALSE ( observer . last_navigation_succeeded ( ) ) ;\n }",
        "output": "1",
        "idx": 1992
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_iht8x8_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , int stride , int eob ) {\n if ( tx_type == DCT_DCT ) {\n vp9_idct8x8_add ( input , dest , stride , eob ) ;\n }\n else {\n vp9_iht8x8_64_add ( input , dest , stride , tx_type ) ;\n }\n }",
        "output": "1",
        "idx": 1221
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void * Type_MPE_Dup ( struct _cms_typehandler_struct * self , const void * Ptr , cmsUInt32Number n ) {\n return ( void * ) cmsPipelineDup ( ( cmsPipeline * ) Ptr ) ;\n cmsUNUSED_PARAMETER ( n ) ;\n cmsUNUSED_PARAMETER ( self ) ;\n }",
        "output": "0",
        "idx": 3238
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_ConferenceResponse ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_ConferenceResponse , ConferenceResponse_choice , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 2545
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_RegistrationRejectReason ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 679 \"./asn1/h225/h225.cnf\" gint32 value ;\n h225_packet_info * h225_pi ;\n h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h225_RegistrationRejectReason , RegistrationRejectReason_choice , & value ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> reason = value ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 351
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileInfo , getPath ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n char * path ;\n int path_len ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n path = spl_filesystem_object_get_path ( intern , & path_len TSRMLS_CC ) ;\n RETURN_STRINGL ( path , path_len , 1 ) ;\n }",
        "output": "1",
        "idx": 3373
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "zend_object_iterator * spl_filesystem_dir_get_iterator ( zend_class_entry * ce , zval * object , int by_ref TSRMLS_DC ) {\n spl_filesystem_iterator * iterator ;\n spl_filesystem_object * dir_object ;\n if ( by_ref ) {\n zend_error ( E_ERROR , \"An iterator cannot be used with foreach by reference\" ) ;\n }\n dir_object = ( spl_filesystem_object * ) zend_object_store_get_object ( object TSRMLS_CC ) ;\n iterator = spl_filesystem_object_to_iterator ( dir_object ) ;\n if ( iterator -> intern . data == NULL ) {\n iterator -> intern . data = object ;\n iterator -> intern . funcs = & spl_filesystem_dir_it_funcs ;\n iterator -> current = object ;\n }\n zval_add_ref ( & object ) ;\n return ( zend_object_iterator * ) iterator ;\n }",
        "output": "1",
        "idx": 1598
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ssl3_send_finished ( SSL * s , int a , int b , const char * sender , int slen ) {\n unsigned char * p , * d ;\n int i ;\n unsigned long l ;\n if ( s -> state == a ) {\n d = ( unsigned char * ) s -> init_buf -> data ;\n p = & ( d [ 4 ] ) ;\n i = s -> method -> ssl3_enc -> final_finish_mac ( s , sender , slen , s -> s3 -> tmp . finish_md ) ;\n s -> s3 -> tmp . finish_md_len = i ;\n memcpy ( p , s -> s3 -> tmp . finish_md , i ) ;\n p += i ;\n l = i ;\n if ( s -> type == SSL_ST_CONNECT ) {\n OPENSSL_assert ( i <= EVP_MAX_MD_SIZE ) ;\n memcpy ( s -> s3 -> previous_client_finished , s -> s3 -> tmp . finish_md , i ) ;\n s -> s3 -> previous_client_finished_len = i ;\n }\n else {\n OPENSSL_assert ( i <= EVP_MAX_MD_SIZE ) ;\n memcpy ( s -> s3 -> previous_server_finished , s -> s3 -> tmp . finish_md , i ) ;\n s -> s3 -> previous_server_finished_len = i ;\n }\n # ifdef OPENSSL_SYS_WIN16 l &= 0xffff ;\n # endif * ( d ++ ) = SSL3_MT_FINISHED ;\n l2n3 ( l , d ) ;\n s -> init_num = ( int ) l + 4 ;\n s -> init_off = 0 ;\n s -> state = b ;\n }\n return ( ssl3_do_write ( s , SSL3_RT_HANDSHAKE ) ) ;\n }",
        "output": "1",
        "idx": 3306
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vvalue_strbuf_append_blob ( wmem_strbuf_t * strbuf , void * ptr ) {\n struct data_blob * blob = ( struct data_blob * ) ptr ;\n wmem_strbuf_append_printf ( strbuf , \"size: %d\" , ( int ) blob -> size ) ;\n }",
        "output": "0",
        "idx": 2320
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_iht8x8_64_add_c ( const int16_t * input , uint8_t * dest , int stride , int tx_type ) {\n int i , j ;\n int16_t out [ 8 * 8 ] ;\n int16_t * outptr = out ;\n int16_t temp_in [ 8 ] , temp_out [ 8 ] ;\n const transform_2d ht = IHT_8 [ tx_type ] ;\n for ( i = 0 ;\n i < 8 ;\n ++ i ) {\n ht . rows ( input , outptr ) ;\n input += 8 ;\n outptr += 8 ;\n }\n for ( i = 0 ;\n i < 8 ;\n ++ i ) {\n for ( j = 0 ;\n j < 8 ;\n ++ j ) temp_in [ j ] = out [ j * 8 + i ] ;\n ht . cols ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 8 ;\n ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 5 ) + dest [ j * stride + i ] ) ;\n }\n }",
        "output": "1",
        "idx": 3304
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int i2d_EC_PUBKEY_fp ( FILE * fp , EC_KEY * eckey ) {\n return ASN1_i2d_fp_of ( EC_KEY , i2d_EC_PUBKEY , fp , eckey ) ;\n }",
        "output": "0",
        "idx": 4213
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int test_compare_files ( const char * tgt , const char * rec ) {\n FILE * orig , * recons ;\n static uint8_t obuf [ TESTBUFSIZE ] , rbuf [ TESTBUFSIZE ] ;\n xoff_t offset = 0 ;\n size_t i ;\n size_t oc , rc ;\n xoff_t diffs = 0 ;\n if ( ( orig = fopen ( tgt , \"r\" ) ) == NULL ) {\n XPR ( NT \"open %s failed\\n\" , tgt ) ;\n return get_errno ( ) ;\n }\n if ( ( recons = fopen ( rec , \"r\" ) ) == NULL ) {\n XPR ( NT \"open %s failed\\n\" , rec ) ;\n return get_errno ( ) ;\n }\n for ( ;\n ;\n ) {\n oc = fread ( obuf , 1 , TESTBUFSIZE , orig ) ;\n rc = fread ( rbuf , 1 , TESTBUFSIZE , recons ) ;\n if ( oc != rc ) {\n return XD3_INTERNAL ;\n }\n if ( oc == 0 ) {\n break ;\n }\n for ( i = 0 ;\n i < oc ;\n i += 1 ) {\n if ( obuf [ i ] != rbuf [ i ] ) {\n XPR ( NT \"byte %u (read %u @ %\" Q \"u) %d != %d\\n\" , ( int ) i , ( int ) oc , offset , obuf [ i ] , rbuf [ i ] ) ;\n diffs ++ ;\n return XD3_INTERNAL ;\n }\n }\n offset += oc ;\n }\n fclose ( orig ) ;\n fclose ( recons ) ;\n if ( diffs != 0 ) {\n return XD3_INTERNAL ;\n }\n return 0 ;\n }",
        "output": "1",
        "idx": 1421
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_OCTET_STRING_SIZE_2_32 ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , 2 , 32 , FALSE , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 1422
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rfbBool rfbSendXvp ( rfbClientPtr cl , uint8_t version , uint8_t code ) {\n rfbXvpMsg xvp ;\n xvp . type = rfbXvp ;\n xvp . pad = 0 ;\n xvp . version = version ;\n xvp . code = code ;\n LOCK ( cl -> sendMutex ) ;\n if ( rfbWriteExact ( cl , ( char * ) & xvp , sz_rfbXvpMsg ) < 0 ) {\n rfbLogPerror ( \"rfbSendXvp: write\" ) ;\n rfbCloseClient ( cl ) ;\n }\n UNLOCK ( cl -> sendMutex ) ;\n rfbStatRecordMessageSent ( cl , rfbXvp , sz_rfbXvpMsg , sz_rfbXvpMsg ) ;\n return TRUE ;\n }",
        "output": "1",
        "idx": 1747
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void setup_mi ( VP9_COMMON * cm ) {\n cm -> mi = cm -> mip + cm -> mi_stride + 1 ;\n cm -> prev_mi = cm -> prev_mip + cm -> mi_stride + 1 ;\n cm -> mi_grid_visible = cm -> mi_grid_base + cm -> mi_stride + 1 ;\n cm -> prev_mi_grid_visible = cm -> prev_mi_grid_base + cm -> mi_stride + 1 ;\n vpx_memset ( cm -> mip , 0 , cm -> mi_stride * ( cm -> mi_rows + 1 ) * sizeof ( * cm -> mip ) ) ;\n vpx_memset ( cm -> mi_grid_base , 0 , cm -> mi_stride * ( cm -> mi_rows + 1 ) * sizeof ( * cm -> mi_grid_base ) ) ;\n clear_mi_border ( cm , cm -> prev_mip ) ;\n }",
        "output": "1",
        "idx": 1193
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int proc_setconfig ( struct usb_dev_state * ps , void __user * arg ) {\n int u ;\n int status = 0 ;\n struct usb_host_config * actconfig ;\n if ( get_user ( u , ( int __user * ) arg ) ) return - EFAULT ;\n actconfig = ps -> dev -> actconfig ;\n if ( actconfig ) {\n int i ;\n for ( i = 0 ;\n i < actconfig -> desc . bNumInterfaces ;\n ++ i ) {\n if ( usb_interface_claimed ( actconfig -> interface [ i ] ) ) {\n dev_warn ( & ps -> dev -> dev , \"usbfs: interface %d claimed by %s \" \"while '%s' sets config #%d\\n\" , actconfig -> interface [ i ] -> cur_altsetting -> desc . bInterfaceNumber , actconfig -> interface [ i ] -> dev . driver -> name , current -> comm , u ) ;\n status = - EBUSY ;\n break ;\n }\n }\n }\n if ( status == 0 ) {\n if ( actconfig && actconfig -> desc . bConfigurationValue == u ) status = usb_reset_configuration ( ps -> dev ) ;\n else status = usb_set_configuration ( ps -> dev , u ) ;\n }\n return status ;\n }",
        "output": "0",
        "idx": 429
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Curl_formclean ( struct FormData * * form_ptr ) {\n struct FormData * next , * form ;\n form = * form_ptr ;\n if ( ! form ) return ;\n do {\n next = form -> next ;\n if ( form -> type <= FORM_CONTENT ) free ( form -> line ) ;\n free ( form ) ;\n }\n while ( ( form = next ) != NULL ) ;\n * form_ptr = NULL ;\n }",
        "output": "0",
        "idx": 3955
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_minq_index ( double maxq , double x3 , double x2 , double x1 ) {\n int i ;\n const double minqtarget = MIN ( ( ( x3 * maxq + x2 ) * maxq + x1 ) * maxq , maxq ) ;\n if ( minqtarget <= 2.0 ) return 0 ;\n for ( i = 0 ;\n i < QINDEX_RANGE ;\n i ++ ) if ( minqtarget <= vp9_convert_qindex_to_q ( i ) ) return i ;\n return QINDEX_RANGE - 1 ;\n }",
        "output": "1",
        "idx": 2606
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ogg_new_stream ( AVFormatContext * s , uint32_t serial ) {\n struct ogg * ogg = s -> priv_data ;\n int idx = ogg -> nstreams ;\n AVStream * st ;\n struct ogg_stream * os ;\n size_t size ;\n if ( ogg -> state ) {\n av_log ( s , AV_LOG_ERROR , \"New streams are not supposed to be added \" \"in between Ogg context save/restore operations.\\n\" ) ;\n return AVERROR_BUG ;\n }\n if ( av_size_mult ( ogg -> nstreams + 1 , sizeof ( * ogg -> streams ) , & size ) < 0 || ! ( os = av_realloc ( ogg -> streams , size ) ) ) return AVERROR ( ENOMEM ) ;\n ogg -> streams = os ;\n os = ogg -> streams + idx ;\n memset ( os , 0 , sizeof ( * os ) ) ;\n os -> serial = serial ;\n os -> bufsize = DECODER_BUFFER_SIZE ;\n os -> buf = av_malloc ( os -> bufsize + AV_INPUT_BUFFER_PADDING_SIZE ) ;\n os -> header = - 1 ;\n os -> start_granule = OGG_NOGRANULE_VALUE ;\n if ( ! os -> buf ) return AVERROR ( ENOMEM ) ;\n st = avformat_new_stream ( s , NULL ) ;\n if ( ! st ) {\n av_freep ( & os -> buf ) ;\n return AVERROR ( ENOMEM ) ;\n }\n st -> id = idx ;\n avpriv_set_pts_info ( st , 64 , 1 , 1000000 ) ;\n ogg -> nstreams ++ ;\n return idx ;\n }",
        "output": "0",
        "idx": 825
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gr_font * hb_graphite2_font_get_gr_font ( hb_font_t * font ) {\n if ( unlikely ( ! hb_graphite2_shaper_font_data_ensure ( font ) ) ) return NULL ;\n return HB_SHAPER_DATA_GET ( font ) ;\n }",
        "output": "0",
        "idx": 3255
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int task_has_system ( struct task_struct * tsk , u32 perms ) {\n u32 sid = task_sid ( tsk ) ;\n return avc_has_perm ( sid , SECINITSID_KERNEL , SECCLASS_SYSTEM , perms , NULL ) ;\n }",
        "output": "0",
        "idx": 3039
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_rfc822_parse_quoted_string ( void ) {\n const struct {\n const char * input , * output ;\n int ret ;\n }\n tests [ ] = {\n {\n \"\\\"\" , \"\" , - 1 }\n , {\n \"\\\"\\\"\" , \"\" , 0 }\n , {\n \"\\\"foo\\\"\" , \"foo\" , 0 }\n , {\n \"\\\"\\\"foo\" , \"\" , 1 }\n , {\n \"\\\"\\\"\\\"\" , \"\" , 1 }\n , {\n \"\\\"\\\\\\\"\\\"\" , \"\\\"\" , 0 }\n , {\n \"\\\"\\\\\\\\\\\"\" , \"\\\\\" , 0 }\n , {\n \"\\\"\\\\\\\\foo\\\\\\\\foo\\\\\\\\\\\"\" , \"\\\\foo\\\\foo\\\\\" , 0 }\n }\n ;\n struct rfc822_parser_context parser ;\n string_t * str = t_str_new ( 64 ) ;\n unsigned int i = 0 ;\n test_begin ( \"rfc822 parse quoted string\" ) ;\n for ( i = 0 ;\n i < N_ELEMENTS ( tests ) ;\n i ++ ) {\n rfc822_parser_init ( & parser , ( const void * ) tests [ i ] . input , strlen ( tests [ i ] . input ) , NULL ) ;\n test_assert_idx ( rfc822_parse_quoted_string ( & parser , str ) == tests [ i ] . ret , i ) ;\n test_assert_idx ( tests [ i ] . ret < 0 || strcmp ( tests [ i ] . output , str_c ( str ) ) == 0 , i ) ;\n str_truncate ( str , 0 ) ;\n }\n test_end ( ) ;\n }",
        "output": "1",
        "idx": 1458
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void write_modes_b ( VP9_COMP * cpi , const TileInfo * const tile , vp9_writer * w , TOKENEXTRA * * tok , const TOKENEXTRA * const tok_end , int mi_row , int mi_col ) {\n const VP9_COMMON * const cm = & cpi -> common ;\n MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;\n MODE_INFO * m ;\n xd -> mi = cm -> mi_grid_visible + ( mi_row * cm -> mi_stride + mi_col ) ;\n m = xd -> mi [ 0 ] ;\n set_mi_row_col ( xd , tile , mi_row , num_8x8_blocks_high_lookup [ m -> mbmi . sb_type ] , mi_col , num_8x8_blocks_wide_lookup [ m -> mbmi . sb_type ] , cm -> mi_rows , cm -> mi_cols ) ;\n if ( frame_is_intra_only ( cm ) ) {\n write_mb_modes_kf ( cm , xd , xd -> mi , w ) ;\n }\n else {\n pack_inter_mode_mvs ( cpi , m , w ) ;\n }\n assert ( * tok < tok_end ) ;\n pack_mb_tokens ( w , tok , tok_end ) ;\n }",
        "output": "1",
        "idx": 3491
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static OFCondition parseDummy ( unsigned char * buf , unsigned long * itemLength , unsigned long availData ) {\n if ( availData < 4 ) return makeLengthError ( \"dummy item\" , availData , 4 ) ;\n unsigned short userLength ;\n buf ++ ;\n buf ++ ;\n EXTRACT_SHORT_BIG ( buf , userLength ) ;\n buf += 2 ;\n * itemLength = userLength + 4 ;\n if ( availData - 4 < userLength ) return makeLengthError ( \"dummy item\" , availData , 0 , userLength ) ;\n return EC_Normal ;\n }",
        "output": "0",
        "idx": 1842
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "qemu_irq qdev_get_gpio_in ( DeviceState * dev , int n ) {\n assert ( n >= 0 && n < dev -> num_gpio_in ) ;\n return dev -> gpio_in [ n ] ;\n }",
        "output": "0",
        "idx": 269
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_T_messageContent_item ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 758 \"./asn1/h225/h225.cnf\" tvbuff_t * next_tvb = NULL ;\n offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , NO_BOUND , NO_BOUND , FALSE , & next_tvb ) ;\n next_tvb_add_handle ( & tp_list , next_tvb , ( h225_tp_in_tree ) ? tree : NULL , tp_handle ) ;\n return offset ;\n }",
        "output": "1",
        "idx": 2031
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char * mime_field_value_get ( const MIMEField * field , int * length ) {\n * length = field -> m_len_value ;\n return field -> m_ptr_value ;\n }",
        "output": "0",
        "idx": 1224
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( FilesystemIterator , getFlags ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n RETURN_LONG ( intern -> flags & ( SPL_FILE_DIR_KEY_MODE_MASK | SPL_FILE_DIR_CURRENT_MODE_MASK | SPL_FILE_DIR_OTHERS_MASK ) ) ;\n }",
        "output": "1",
        "idx": 4051
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __always_inline __u32 __le32_to_cpup ( const __le32 * p ) {\n return ( __u32 ) * p ;\n }",
        "output": "1",
        "idx": 283
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void scale_mv ( AVSContext * h , int * d_x , int * d_y , cavs_vector * src , int distp ) {\n int den = h -> scale_den [ src -> ref ] ;\n * d_x = ( src -> x * distp * den + 256 + ( src -> x >> 31 ) ) >> 9 ;\n * d_y = ( src -> y * distp * den + 256 + ( src -> y >> 31 ) ) >> 9 ;\n }",
        "output": "0",
        "idx": 2668
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_MaximumHeaderIntervalReq ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_MaximumHeaderIntervalReq , MaximumHeaderIntervalReq_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 3823
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static krb5_error_code randkey_princ ( krb5_principal princ , krb5_boolean keepold , int n_ks , krb5_key_salt_tuple * ks ) {\n if ( keepold || ks ) {\n return kadm5_randkey_principal_3 ( handle , princ , keepold , n_ks , ks , NULL , NULL ) ;\n }\n else return kadm5_randkey_principal ( handle , princ , NULL , NULL ) ;\n }",
        "output": "1",
        "idx": 3228
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_MPV_common_defaults ( MpegEncContext * s ) {\n s -> y_dc_scale_table = s -> c_dc_scale_table = ff_mpeg1_dc_scale_table ;\n s -> chroma_qscale_table = ff_default_chroma_qscale_table ;\n s -> progressive_frame = 1 ;\n s -> progressive_sequence = 1 ;\n s -> picture_structure = PICT_FRAME ;\n s -> coded_picture_number = 0 ;\n s -> picture_number = 0 ;\n s -> input_picture_number = 0 ;\n s -> picture_in_gop_number = 0 ;\n s -> f_code = 1 ;\n s -> b_code = 1 ;\n s -> picture_range_start = 0 ;\n s -> picture_range_end = MAX_PICTURE_COUNT ;\n s -> slice_context_count = 1 ;\n }",
        "output": "1",
        "idx": 3518
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mp_get_code ( MotionPixelsContext * mp , GetBitContext * gb , int size , int code ) {\n while ( get_bits1 ( gb ) ) {\n ++ size ;\n if ( size > mp -> max_codes_bits ) {\n av_log ( mp -> avctx , AV_LOG_ERROR , \"invalid code size %d/%d\\n\" , size , mp -> max_codes_bits ) ;\n return ;\n }\n code <<= 1 ;\n mp_get_code ( mp , gb , size , code + 1 ) ;\n }\n if ( mp -> current_codes_count >= MAX_HUFF_CODES ) {\n av_log ( mp -> avctx , AV_LOG_ERROR , \"too many codes\\n\" ) ;\n return ;\n }\n mp -> codes [ mp -> current_codes_count ] . code = code ;\n mp -> codes [ mp -> current_codes_count ++ ] . size = size ;\n }",
        "output": "0",
        "idx": 380
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned char * do_get_buffer ( gcry_mpi_t a , unsigned int * nbytes , int * sign , int force_secure ) {\n unsigned char * p , * buffer ;\n mpi_limb_t alimb ;\n int i ;\n size_t n ;\n if ( sign ) * sign = a -> sign ;\n * nbytes = a -> nlimbs * BYTES_PER_MPI_LIMB ;\n n = * nbytes ? * nbytes : 1 ;\n p = buffer = ( force_secure || mpi_is_secure ( a ) ) ? gcry_malloc_secure ( n ) : gcry_malloc ( n ) ;\n if ( ! buffer ) return NULL ;\n for ( i = a -> nlimbs - 1 ;\n i >= 0 ;\n i -- ) {\n alimb = a -> d [ i ] ;\n # if BYTES_PER_MPI_LIMB == 4 * p ++ = alimb >> 24 ;\n * p ++ = alimb >> 16 ;\n * p ++ = alimb >> 8 ;\n * p ++ = alimb ;\n # elif BYTES_PER_MPI_LIMB == 8 * p ++ = alimb >> 56 ;\n * p ++ = alimb >> 48 ;\n * p ++ = alimb >> 40 ;\n * p ++ = alimb >> 32 ;\n * p ++ = alimb >> 24 ;\n * p ++ = alimb >> 16 ;\n * p ++ = alimb >> 8 ;\n * p ++ = alimb ;\n # else # error please implement for this limb size . # endif }\n for ( p = buffer ;\n * nbytes && ! * p ;\n p ++ , -- * nbytes ) ;\n if ( p != buffer ) memmove ( buffer , p , * nbytes ) ;\n return buffer ;\n }",
        "output": "1",
        "idx": 3486
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlRegisterNodeFunc * __xmlRegisterNodeDefaultValue ( void ) {\n if ( IS_MAIN_THREAD ) return ( & xmlRegisterNodeDefaultValue ) ;\n else return ( & xmlGetGlobalState ( ) -> xmlRegisterNodeDefaultValue ) ;\n }",
        "output": "0",
        "idx": 988
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_Status_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 386 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_Status_UUIE , Status_UUIE_sequence ) ;\n # line 390 \"./asn1/h225/h225.cnf\" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> cs_type = H225_STATUS ;\n g_snprintf ( h225_pi -> frame_label , 50 , \"%s\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) ) ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 865
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_iht4x4_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , int stride , int eob ) {\n if ( tx_type == DCT_DCT ) vp9_idct4x4_add ( input , dest , stride , eob ) ;\n else vp9_iht4x4_16_add ( input , dest , stride , tx_type ) ;\n }",
        "output": "1",
        "idx": 64
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int proto_get_next_protocol ( void * * cookie ) {\n GList * list_item = ( GList * ) * cookie ;\n protocol_t * protocol ;\n list_item = g_list_next ( list_item ) ;\n if ( list_item == NULL ) return - 1 ;\n * cookie = list_item ;\n protocol = ( protocol_t * ) list_item -> data ;\n return protocol -> proto_id ;\n }",
        "output": "0",
        "idx": 3150
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_T_standard ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 862 \"./asn1/h225/h225.cnf\" guint32 value_int = ( guint32 ) - 1 ;\n gef_ctx_t * gefx ;\n offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_index , 0U , 16383U , & value_int , TRUE ) ;\n gefx = gef_ctx_get ( actx -> private_data ) ;\n if ( gefx ) gefx -> id = wmem_strdup_printf ( wmem_packet_scope ( ) , \"%u\" , value_int ) ;\n return offset ;\n }",
        "output": "1",
        "idx": 4345
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int decode_udvm_address_operand ( guint8 * buff , guint operand_address , guint16 * value , guint current_address ) {\n guint32 result ;\n guint16 value1 ;\n guint next_opreand_address ;\n next_opreand_address = decode_udvm_multitype_operand ( buff , operand_address , & value1 ) ;\n result = value1 & 0xffff ;\n result = result + current_address ;\n * value = result & 0xffff ;\n return next_opreand_address ;\n }",
        "output": "1",
        "idx": 4369
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kq_insert ( struct kqop * kqop , struct kevent * kev ) {\n int nevents = kqop -> nevents ;\n if ( kqop -> nchanges == nevents ) {\n struct kevent * newchange ;\n struct kevent * newresult ;\n nevents *= 2 ;\n newchange = realloc ( kqop -> changes , nevents * sizeof ( struct kevent ) ) ;\n if ( newchange == NULL ) {\n event_warn ( \"%s: malloc\" , __func__ ) ;\n return ( - 1 ) ;\n }\n kqop -> changes = newchange ;\n newresult = realloc ( kqop -> events , nevents * sizeof ( struct kevent ) ) ;\n if ( newresult == NULL ) {\n event_warn ( \"%s: malloc\" , __func__ ) ;\n return ( - 1 ) ;\n }\n kqop -> events = newresult ;\n kqop -> nevents = nevents ;\n }\n memcpy ( & kqop -> changes [ kqop -> nchanges ++ ] , kev , sizeof ( struct kevent ) ) ;\n event_debug ( ( \"%s: fd %d %s%s\" , __func__ , ( int ) kev -> ident , kev -> filter == EVFILT_READ ? \"EVFILT_READ\" : \"EVFILT_WRITE\" , kev -> flags == EV_DELETE ? \" (del)\" : \"\" ) ) ;\n return ( 0 ) ;\n }",
        "output": "0",
        "idx": 2162
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "proto_item * proto_tree_add_text_valist_internal ( proto_tree * tree , tvbuff_t * tvb , gint start , gint length , const char * format , va_list ap ) {\n proto_item * pi ;\n header_field_info * hfinfo ;\n CHECK_FOR_NULL_TREE ( tree ) ;\n TRY_TO_FAKE_THIS_ITEM ( tree , hf_text_only , hfinfo ) ;\n pi = proto_tree_add_text_node ( tree , tvb , start , length ) ;\n TRY_TO_FAKE_THIS_REPR ( pi ) ;\n proto_tree_set_representation ( pi , format , ap ) ;\n return pi ;\n }",
        "output": "1",
        "idx": 1437
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_aq_c_strength ( int q_index ) {\n int base_quant = vp9_ac_quant ( q_index , 0 ) / 4 ;\n return ( base_quant > 20 ) + ( base_quant > 45 ) ;\n }",
        "output": "1",
        "idx": 3990
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void vmsvga_copy_rect ( struct vmsvga_state_s * s , int x0 , int y0 , int x1 , int y1 , int w , int h ) {\n DisplaySurface * surface = qemu_console_surface ( s -> vga . con ) ;\n uint8_t * vram = s -> vga . vram_ptr ;\n int bypl = surface_stride ( surface ) ;\n int bypp = surface_bytes_per_pixel ( surface ) ;\n int width = bypp * w ;\n int line = h ;\n uint8_t * ptr [ 2 ] ;\n if ( y1 > y0 ) {\n ptr [ 0 ] = vram + bypp * x0 + bypl * ( y0 + h - 1 ) ;\n ptr [ 1 ] = vram + bypp * x1 + bypl * ( y1 + h - 1 ) ;\n for ( ;\n line > 0 ;\n line -- , ptr [ 0 ] -= bypl , ptr [ 1 ] -= bypl ) {\n memmove ( ptr [ 1 ] , ptr [ 0 ] , width ) ;\n }\n }\n else {\n ptr [ 0 ] = vram + bypp * x0 + bypl * y0 ;\n ptr [ 1 ] = vram + bypp * x1 + bypl * y1 ;\n for ( ;\n line > 0 ;\n line -- , ptr [ 0 ] += bypl , ptr [ 1 ] += bypl ) {\n memmove ( ptr [ 1 ] , ptr [ 0 ] , width ) ;\n }\n }\n vmsvga_update_rect_delayed ( s , x1 , y1 , w , h ) ;\n }",
        "output": "1",
        "idx": 2702
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct object_list * * process_blob ( struct blob * blob , struct object_list * * p , struct name_path * path , const char * name ) {\n struct object * obj = & blob -> object ;\n obj -> flags |= LOCAL ;\n if ( obj -> flags & ( UNINTERESTING | SEEN ) ) return p ;\n obj -> flags |= SEEN ;\n return add_one_object ( obj , p ) ;\n }",
        "output": "1",
        "idx": 1525
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void * DecoderThread ( void * p_data ) {\n decoder_t * p_dec = ( decoder_t * ) p_data ;\n decoder_owner_sys_t * p_owner = p_dec -> p_owner ;\n for ( ;\n ;\n ) {\n block_t * p_block = block_FifoGet ( p_owner -> p_fifo ) ;\n bool end_wait = ! p_block || p_block -> i_flags & BLOCK_FLAG_CORE_EOS ;\n DecoderSignalWait ( p_dec , end_wait ) ;\n if ( end_wait ) input_DecoderStopWait ( p_dec ) ;\n if ( p_block ) {\n int canc = vlc_savecancel ( ) ;\n if ( p_block -> i_flags & BLOCK_FLAG_CORE_EOS ) {\n block_Release ( p_block ) ;\n p_block = NULL ;\n }\n DecoderProcess ( p_dec , p_block ) ;\n vlc_restorecancel ( canc ) ;\n }\n }\n return NULL ;\n }",
        "output": "0",
        "idx": 682
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int NETSCAPE_SPKI_verify ( NETSCAPE_SPKI * a , EVP_PKEY * r ) {\n return ( ASN1_item_verify ( ASN1_ITEM_rptr ( NETSCAPE_SPKAC ) , a -> sig_algor , a -> signature , a -> spkac , r ) ) ;\n }",
        "output": "0",
        "idx": 2299
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_idct8x8_add ( const int16_t * input , uint8_t * dest , int stride , int eob ) {\n if ( eob == 1 ) vp9_idct8x8_1_add ( input , dest , stride ) ;\n else if ( eob <= 12 ) vp9_idct8x8_12_add ( input , dest , stride ) ;\n else vp9_idct8x8_64_add ( input , dest , stride ) ;\n }",
        "output": "1",
        "idx": 2900
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileObject , getMaxLineLen ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n if ( zend_parse_parameters_none ( ) == FAILURE ) {\n return ;\n }\n RETURN_LONG ( ( long ) intern -> u . file . max_line_len ) ;\n }",
        "output": "1",
        "idx": 4086
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PyObject * PyString_AsDecodedString ( PyObject * str , const char * encoding , const char * errors ) {\n PyObject * v ;\n v = PyString_AsDecodedObject ( str , encoding , errors ) ;\n if ( v == NULL ) goto onError ;\n # ifdef Py_USING_UNICODE if ( PyUnicode_Check ( v ) ) {\n PyObject * temp = v ;\n v = PyUnicode_AsEncodedString ( v , NULL , NULL ) ;\n Py_DECREF ( temp ) ;\n if ( v == NULL ) goto onError ;\n }\n # endif if ( ! PyString_Check ( v ) ) {\n PyErr_Format ( PyExc_TypeError , \"decoder did not return a string object (type=%.400s)\" , Py_TYPE ( v ) -> tp_name ) ;\n Py_DECREF ( v ) ;\n goto onError ;\n }\n return v ;\n onError : return NULL ;\n }",
        "output": "0",
        "idx": 650
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xsltCheckFilename ( const char * path ) {\n # ifdef HAVE_STAT struct stat stat_buffer ;\n # if defined ( WIN32 ) && ! defined ( __CYGWIN__ ) DWORD dwAttrs ;\n dwAttrs = GetFileAttributesA ( path ) ;\n if ( dwAttrs != INVALID_FILE_ATTRIBUTES ) {\n if ( dwAttrs & FILE_ATTRIBUTE_DIRECTORY ) {\n return 2 ;\n }\n }\n # endif if ( stat ( path , & stat_buffer ) == - 1 ) return 0 ;\n # ifdef S_ISDIR if ( S_ISDIR ( stat_buffer . st_mode ) ) {\n return 2 ;\n }\n # endif # endif return 1 ;\n }",
        "output": "1",
        "idx": 2251
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void intra_pred_lp_left ( uint8_t * d , uint8_t * top , uint8_t * left , int stride ) {\n int x , y ;\n for ( y = 0 ;\n y < 8 ;\n y ++ ) for ( x = 0 ;\n x < 8 ;\n x ++ ) d [ y * stride + x ] = LOWPASS ( left , y + 1 ) ;\n }",
        "output": "0",
        "idx": 3779
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void nautilus_directory_cancel ( NautilusDirectory * directory ) {\n deep_count_cancel ( directory ) ;\n directory_count_cancel ( directory ) ;\n file_info_cancel ( directory ) ;\n file_list_cancel ( directory ) ;\n link_info_cancel ( directory ) ;\n mime_list_cancel ( directory ) ;\n new_files_cancel ( directory ) ;\n extension_info_cancel ( directory ) ;\n thumbnail_cancel ( directory ) ;\n mount_cancel ( directory ) ;\n filesystem_info_cancel ( directory ) ;\n if ( waiting_directories != NULL ) {\n g_hash_table_remove ( waiting_directories , directory ) ;\n }\n async_job_wake_up ( ) ;\n }",
        "output": "0",
        "idx": 3758
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void http_large_delay_cb ( struct evhttp_request * req , void * arg ) {\n struct timeval tv ;\n timerclear ( & tv ) ;\n tv . tv_sec = 3 ;\n event_once ( - 1 , EV_TIMEOUT , http_delay_reply , req , & tv ) ;\n evhttp_connection_fail ( delayed_client , EVCON_HTTP_EOF ) ;\n }",
        "output": "0",
        "idx": 2537
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_fht8x8_c ( const int16_t * input , int16_t * output , int stride , int tx_type ) {\n if ( tx_type == DCT_DCT ) {\n vp9_fdct8x8_c ( input , output , stride ) ;\n }\n else {\n int16_t out [ 64 ] ;\n int16_t * outptr = & out [ 0 ] ;\n int i , j ;\n int16_t temp_in [ 8 ] , temp_out [ 8 ] ;\n const transform_2d ht = FHT_8 [ tx_type ] ;\n for ( i = 0 ;\n i < 8 ;\n ++ i ) {\n for ( j = 0 ;\n j < 8 ;\n ++ j ) temp_in [ j ] = input [ j * stride + i ] * 4 ;\n ht . cols ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 8 ;\n ++ j ) outptr [ j * 8 + i ] = temp_out [ j ] ;\n }\n for ( i = 0 ;\n i < 8 ;\n ++ i ) {\n for ( j = 0 ;\n j < 8 ;\n ++ j ) temp_in [ j ] = out [ j + i * 8 ] ;\n ht . rows ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 8 ;\n ++ j ) output [ j + i * 8 ] = ( temp_out [ j ] + ( temp_out [ j ] < 0 ) ) >> 1 ;\n }\n }\n }",
        "output": "1",
        "idx": 2538
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "enum message_cte message_decoder_parse_cte ( struct message_header_line * hdr ) {\n struct rfc822_parser_context parser ;\n enum message_cte message_cte ;\n string_t * value ;\n value = t_str_new ( 64 ) ;\n rfc822_parser_init ( & parser , hdr -> full_value , hdr -> full_value_len , NULL ) ;\n rfc822_skip_lwsp ( & parser ) ;\n ( void ) rfc822_parse_mime_token ( & parser , value ) ;\n message_cte = MESSAGE_CTE_UNKNOWN ;\n switch ( str_len ( value ) ) {\n case 4 : if ( i_memcasecmp ( str_data ( value ) , \"7bit\" , 4 ) == 0 || i_memcasecmp ( str_data ( value ) , \"8bit\" , 4 ) == 0 ) message_cte = MESSAGE_CTE_78BIT ;\n break ;\n case 6 : if ( i_memcasecmp ( str_data ( value ) , \"base64\" , 6 ) == 0 ) message_cte = MESSAGE_CTE_BASE64 ;\n else if ( i_memcasecmp ( str_data ( value ) , \"binary\" , 6 ) == 0 ) message_cte = MESSAGE_CTE_BINARY ;\n break ;\n case 16 : if ( i_memcasecmp ( str_data ( value ) , \"quoted-printable\" , 16 ) == 0 ) message_cte = MESSAGE_CTE_QP ;\n break ;\n }\n return message_cte ;\n }",
        "output": "1",
        "idx": 3354
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int bind_socket ( const char * address , u_short port , int reuse ) {\n int fd ;\n struct addrinfo * aitop = NULL ;\n if ( address == NULL && port == 0 ) return bind_socket_ai ( NULL , 0 ) ;\n aitop = make_addrinfo ( address , port ) ;\n if ( aitop == NULL ) return ( - 1 ) ;\n fd = bind_socket_ai ( aitop , reuse ) ;\n # ifdef HAVE_GETADDRINFO freeaddrinfo ( aitop ) ;\n # else fake_freeaddrinfo ( aitop ) ;\n # endif return ( fd ) ;\n }",
        "output": "0",
        "idx": 2227
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( ExtensionMessageBubbleViewBrowserTest , ExtensionBubbleAnchoredToExtensionAction ) {\n TestBubbleAnchoredToExtensionAction ( ) ;\n }",
        "output": "0",
        "idx": 3281
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t u_printf_ustring_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n int32_t len , written ;\n const UChar * arg = ( const UChar * ) ( args [ 0 ] . ptrValue ) ;\n if ( arg == NULL ) {\n arg = gNullStr ;\n }\n len = u_strlen ( arg ) ;\n if ( info -> fPrecision != - 1 && info -> fPrecision < len ) {\n len = info -> fPrecision ;\n }\n written = handler -> pad_and_justify ( context , info , arg , len ) ;\n return written ;\n }",
        "output": "1",
        "idx": 648
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dtap_mm_auth_fail ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_offset = offset ;\n curr_len = len ;\n is_uplink = IS_UPLINK_TRUE ;\n ELEM_MAND_V ( GSM_A_PDU_TYPE_DTAP , DE_REJ_CAUSE , NULL ) ;\n ELEM_OPT_TLV ( 0x22 , GSM_A_PDU_TYPE_DTAP , DE_AUTH_FAIL_PARAM , NULL ) ;\n EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n }",
        "output": "0",
        "idx": 1918
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_Progress_UUIE ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n # line 412 \"./asn1/h225/h225.cnf\" h225_packet_info * h225_pi ;\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_Progress_UUIE , Progress_UUIE_sequence ) ;\n # line 416 \"./asn1/h225/h225.cnf\" h225_pi = ( h225_packet_info * ) p_get_proto_data ( wmem_packet_scope ( ) , actx -> pinfo , proto_h225 , 0 ) ;\n if ( h225_pi != NULL ) {\n h225_pi -> cs_type = H225_PROGRESS ;\n if ( contains_faststart == TRUE ) g_snprintf ( h225_pi -> frame_label , 50 , \"%s OLC (%s)\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) , h225_pi -> frame_label ) ;\n else g_snprintf ( h225_pi -> frame_label , 50 , \"%s\" , val_to_str ( h225_pi -> cs_type , T_h323_message_body_vals , \"<unknown>\" ) ) ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 1803
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xhci_fire_transfer ( XHCIState * xhci , XHCITransfer * xfer , XHCIEPContext * epctx ) {\n trace_usb_xhci_xfer_start ( xfer , xfer -> epctx -> slotid , xfer -> epctx -> epid , xfer -> streamid ) ;\n return xhci_submit ( xhci , xfer , epctx ) ;\n }",
        "output": "0",
        "idx": 1688
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static double calc_correction_factor ( double err_per_mb , double err_divisor , double pt_low , double pt_high , int q ) {\n const double error_term = err_per_mb / err_divisor ;\n const double power_term = MIN ( vp9_convert_qindex_to_q ( q ) * 0.0125 + pt_low , pt_high ) ;\n if ( power_term < 1.0 ) assert ( error_term >= 0.0 ) ;\n return fclamp ( pow ( error_term , power_term ) , 0.05 , 5.0 ) ;\n }",
        "output": "1",
        "idx": 4299
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "proto_item * proto_tree_add_bytes_format ( proto_tree * tree , int hfindex , tvbuff_t * tvb , gint start , gint length , const guint8 * start_ptr , const char * format , ... ) {\n proto_item * pi ;\n va_list ap ;\n header_field_info * hfinfo ;\n gint item_length ;\n PROTO_REGISTRAR_GET_NTH ( hfindex , hfinfo ) ;\n get_hfi_length ( hfinfo , tvb , start , & length , & item_length ) ;\n test_length ( hfinfo , tvb , start , item_length ) ;\n CHECK_FOR_NULL_TREE ( tree ) ;\n TRY_TO_FAKE_THIS_ITEM ( tree , hfindex , hfinfo ) ;\n if ( start_ptr ) pi = proto_tree_add_bytes ( tree , hfindex , tvb , start , length , start_ptr ) ;\n else pi = proto_tree_add_bytes ( tree , hfindex , tvb , start , length , tvb_get_ptr ( tvb , start , length ) ) ;\n TRY_TO_FAKE_THIS_REPR ( pi ) ;\n va_start ( ap , format ) ;\n proto_tree_set_representation ( pi , format , ap ) ;\n va_end ( ap ) ;\n return pi ;\n }",
        "output": "0",
        "idx": 593
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void process_downstream_ack ( int userid , int down_seq , int down_frag ) {\n if ( users [ userid ] . outpacket . len <= 0 ) return ;\n if ( users [ userid ] . outpacket . seqno != down_seq || users [ userid ] . outpacket . fragment != down_frag ) return ;\n users [ userid ] . outpacket . offset += users [ userid ] . outpacket . sentlen ;\n users [ userid ] . outpacket . sentlen = 0 ;\n users [ userid ] . outpacket . fragment ++ ;\n users [ userid ] . outfragresent = 0 ;\n if ( users [ userid ] . outpacket . offset >= users [ userid ] . outpacket . len ) {\n users [ userid ] . outpacket . len = 0 ;\n users [ userid ] . outpacket . offset = 0 ;\n users [ userid ] . outpacket . fragment -- ;\n # ifdef OUTPACKETQ_LEN get_from_outpacketq ( userid ) ;\n # endif }\n }",
        "output": "0",
        "idx": 3091
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_ProtocolIdentifier ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_object_identifier ( tvb , offset , actx , tree , hf_index , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 762
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int evbuffer_add_vprintf ( struct evbuffer * buf , const char * fmt , va_list ap ) {\n char * buffer ;\n size_t space ;\n size_t oldoff = buf -> off ;\n int sz ;\n va_list aq ;\n evbuffer_expand ( buf , 64 ) ;\n for ( ;\n ;\n ) {\n size_t used = buf -> misalign + buf -> off ;\n buffer = ( char * ) buf -> buffer + buf -> off ;\n assert ( buf -> totallen >= used ) ;\n space = buf -> totallen - used ;\n # ifndef va_copy # define va_copy ( dst , src ) memcpy ( & ( dst ) , & ( src ) , sizeof ( va_list ) ) # endif va_copy ( aq , ap ) ;\n sz = evutil_vsnprintf ( buffer , space , fmt , aq ) ;\n va_end ( aq ) ;\n if ( sz < 0 ) return ( - 1 ) ;\n if ( ( size_t ) sz < space ) {\n buf -> off += sz ;\n if ( buf -> cb != NULL ) ( * buf -> cb ) ( buf , oldoff , buf -> off , buf -> cbarg ) ;\n return ( sz ) ;\n }\n if ( evbuffer_expand ( buf , sz + 1 ) == - 1 ) return ( - 1 ) ;\n }\n }",
        "output": "1",
        "idx": 422
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_dec_build_inter_predictors_sb ( MACROBLOCKD * xd , int mi_row , int mi_col , BLOCK_SIZE bsize ) {\n int plane ;\n const int mi_x = mi_col * MI_SIZE ;\n const int mi_y = mi_row * MI_SIZE ;\n for ( plane = 0 ;\n plane < MAX_MB_PLANE ;\n ++ plane ) {\n const BLOCK_SIZE plane_bsize = get_plane_block_size ( bsize , & xd -> plane [ plane ] ) ;\n const int num_4x4_w = num_4x4_blocks_wide_lookup [ plane_bsize ] ;\n const int num_4x4_h = num_4x4_blocks_high_lookup [ plane_bsize ] ;\n const int bw = 4 * num_4x4_w ;\n const int bh = 4 * num_4x4_h ;\n if ( xd -> mi [ 0 ] -> mbmi . sb_type < BLOCK_8X8 ) {\n int i = 0 , x , y ;\n assert ( bsize == BLOCK_8X8 ) ;\n for ( y = 0 ;\n y < num_4x4_h ;\n ++ y ) for ( x = 0 ;\n x < num_4x4_w ;\n ++ x ) dec_build_inter_predictors ( xd , plane , i ++ , bw , bh , * x , 4 * y , 4 , 4 , mi_x , mi_y ) ;\n }\n else {\n dec_build_inter_predictors ( xd , plane , 0 , bw , bh , 0 , 0 , bw , bh , mi_x , mi_y ) ;\n }\n }\n }",
        "output": "1",
        "idx": 4478
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int spl_filesystem_file_read_csv ( spl_filesystem_object * intern , char delimiter , char enclosure , char escape , zval * return_value TSRMLS_DC ) {\n int ret = SUCCESS ;\n do {\n ret = spl_filesystem_file_read ( intern , 1 TSRMLS_CC ) ;\n }\n while ( ret == SUCCESS && ! intern -> u . file . current_line_len && SPL_HAS_FLAG ( intern -> flags , SPL_FILE_OBJECT_SKIP_EMPTY ) ) ;\n if ( ret == SUCCESS ) {\n size_t buf_len = intern -> u . file . current_line_len ;\n char * buf = estrndup ( intern -> u . file . current_line , buf_len ) ;\n if ( intern -> u . file . current_zval ) {\n zval_ptr_dtor ( & intern -> u . file . current_zval ) ;\n }\n ALLOC_INIT_ZVAL ( intern -> u . file . current_zval ) ;\n php_fgetcsv ( intern -> u . file . stream , delimiter , enclosure , escape , buf_len , buf , intern -> u . file . current_zval TSRMLS_CC ) ;\n if ( return_value ) {\n if ( Z_TYPE_P ( return_value ) != IS_NULL ) {\n zval_dtor ( return_value ) ;\n ZVAL_NULL ( return_value ) ;\n }\n ZVAL_ZVAL ( return_value , intern -> u . file . current_zval , 1 , 0 ) ;\n }\n }\n return ret ;\n }",
        "output": "1",
        "idx": 497
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( ProtocolHandlerRegistryTest , TestRemovingDefaultDoesntChangeHandlers ) {\n ProtocolHandler ph1 = CreateProtocolHandler ( \"mailto\" , \"test1\" ) ;\n ProtocolHandler ph2 = CreateProtocolHandler ( \"mailto\" , \"test2\" ) ;\n ProtocolHandler ph3 = CreateProtocolHandler ( \"mailto\" , \"test3\" ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph1 ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph2 ) ;\n registry ( ) -> OnAcceptRegisterProtocolHandler ( ph3 ) ;\n registry ( ) -> RemoveHandler ( ph3 ) ;\n ProtocolHandlerRegistry : : ProtocolHandlerList handlers = registry ( ) -> GetHandlersFor ( \"mailto\" ) ;\n ASSERT_EQ ( static_cast < size_t > ( 2 ) , handlers . size ( ) ) ;\n ASSERT_EQ ( ph2 , handlers [ 0 ] ) ;\n ASSERT_EQ ( ph1 , handlers [ 1 ] ) ;\n }",
        "output": "0",
        "idx": 3264
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static TABLE * GetTable ( cmsIT8 * it8 ) {\n if ( ( it8 -> nTable >= it8 -> TablesCount ) ) {\n SynError ( it8 , \"Table %d out of sequence\" , it8 -> nTable ) ;\n return it8 -> Tab ;\n }\n return it8 -> Tab + it8 -> nTable ;\n }",
        "output": "0",
        "idx": 470
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char * debug_ntoa ( u32 address ) {\n static char buf [ 32 ] ;\n u32 a = ntohl ( address ) ;\n evutil_snprintf ( buf , sizeof ( buf ) , \"%d.%d.%d.%d\" , ( int ) ( u8 ) ( ( a >> 24 ) & 0xff ) , ( int ) ( u8 ) ( ( a >> 16 ) & 0xff ) , ( int ) ( u8 ) ( ( a >> 8 ) & 0xff ) , ( int ) ( u8 ) ( ( a ) & 0xff ) ) ;\n return buf ;\n }",
        "output": "0",
        "idx": 1295
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int jbig2_decode_generic_mmr ( Jbig2Ctx * ctx , Jbig2Segment * segment , const Jbig2GenericRegionParams * params , const byte * data , size_t size , Jbig2Image * image ) {\n Jbig2MmrCtx mmr ;\n const int rowstride = image -> stride ;\n byte * dst = image -> data ;\n byte * ref = NULL ;\n int y ;\n int code = 0 ;\n jbig2_decode_mmr_init ( & mmr , image -> width , image -> height , data , size ) ;\n for ( y = 0 ;\n y < image -> height ;\n y ++ ) {\n memset ( dst , 0 , rowstride ) ;\n code = jbig2_decode_mmr_line ( & mmr , ref , dst ) ;\n if ( code < 0 ) return code ;\n ref = dst ;\n dst += rowstride ;\n }\n return code ;\n }",
        "output": "1",
        "idx": 398
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int evdns_transmit ( void ) {\n char did_try_to_transmit = 0 ;\n if ( req_head ) {\n struct request * const started_at = req_head , * req = req_head ;\n do {\n if ( req -> transmit_me ) {\n did_try_to_transmit = 1 ;\n evdns_request_transmit ( req ) ;\n }\n req = req -> next ;\n }\n while ( req != started_at ) ;\n }\n return did_try_to_transmit ;\n }",
        "output": "0",
        "idx": 1609
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_pcp ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data ) {\n tcp_dissect_pdus ( tvb , pinfo , tree , TRUE , PCP_HEADER_LEN , get_pcp_message_len , dissect_pcp_message , data ) ;\n return tvb_captured_length ( tvb ) ;\n }",
        "output": "0",
        "idx": 2651
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int write_output ( void ) {\n int fd ;\n struct filter_op * fop ;\n struct filter_header fh ;\n size_t ninst , i ;\n u_char * data ;\n ninst = compile_tree ( & fop ) ;\n if ( fop == NULL ) return - E_NOTHANDLED ;\n fd = open ( EF_GBL_OPTIONS -> output_file , O_CREAT | O_RDWR | O_TRUNC | O_BINARY , 0644 ) ;\n ON_ERROR ( fd , - 1 , \"Can't create file %s\" , EF_GBL_OPTIONS -> output_file ) ;\n fprintf ( stdout , \" Writing output to \\'%s\\' \" , EF_GBL_OPTIONS -> output_file ) ;\n fflush ( stdout ) ;\n fh . magic = htons ( EC_FILTER_MAGIC ) ;\n strncpy ( fh . version , EC_VERSION , sizeof ( fh . version ) ) ;\n fh . data = sizeof ( fh ) ;\n data = create_data_segment ( & fh , fop , ninst ) ;\n write ( fd , & fh , sizeof ( struct filter_header ) ) ;\n write ( fd , data , fh . code - fh . data ) ;\n for ( i = 0 ;\n i <= ninst ;\n i ++ ) {\n print_progress_bar ( & fop [ i ] ) ;\n write ( fd , & fop [ i ] , sizeof ( struct filter_op ) ) ;\n }\n close ( fd ) ;\n fprintf ( stdout , \" done.\\n\\n\" ) ;\n fprintf ( stdout , \" -> Script encoded into %d instructions.\\n\\n\" , ( int ) ( i - 1 ) ) ;\n return E_SUCCESS ;\n }",
        "output": "1",
        "idx": 3445
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void proto_tree_set_oid_tvb ( field_info * fi , tvbuff_t * tvb , gint start , gint length ) {\n proto_tree_set_oid ( fi , tvb_get_ptr ( tvb , start , length ) , length ) ;\n }",
        "output": "0",
        "idx": 1200
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mem_resize ( jas_stream_memobj_t * m , int bufsize ) {\n unsigned char * buf ;\n assert ( m -> buf_ ) ;\n assert ( bufsize >= 0 ) ;\n if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) ) {\n return - 1 ;\n }\n m -> buf_ = buf ;\n m -> bufsize_ = bufsize ;\n return 0 ;\n }",
        "output": "1",
        "idx": 1503
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int decode_udvm_literal_operand ( guint8 * buff , guint operand_address , guint16 * value ) {\n guint bytecode ;\n guint16 operand ;\n guint test_bits ;\n guint offset = operand_address ;\n guint8 temp_data ;\n bytecode = buff [ operand_address ] ;\n test_bits = bytecode >> 7 ;\n if ( test_bits == 1 ) {\n test_bits = bytecode >> 6 ;\n if ( test_bits == 2 ) {\n temp_data = buff [ operand_address ] & 0x1f ;\n operand = temp_data << 8 ;\n temp_data = buff [ ( operand_address + 1 ) & 0xffff ] ;\n operand = operand | temp_data ;\n * value = operand ;\n offset = offset + 2 ;\n }\n else {\n offset ++ ;\n temp_data = buff [ operand_address ] & 0x1f ;\n operand = temp_data << 8 ;\n temp_data = buff [ ( operand_address + 1 ) & 0xffff ] ;\n operand = operand | temp_data ;\n * value = operand ;\n offset = offset + 2 ;\n }\n }\n else {\n operand = ( bytecode & 0x7f ) ;\n * value = operand ;\n offset ++ ;\n }\n return offset ;\n }",
        "output": "1",
        "idx": 711
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_iwht4x4_1_add_c ( const int16_t * in , uint8_t * dest , int dest_stride ) {\n int i ;\n int a1 , e1 ;\n int16_t tmp [ 4 ] ;\n const int16_t * ip = in ;\n int16_t * op = tmp ;\n a1 = ip [ 0 ] >> UNIT_QUANT_SHIFT ;\n e1 = a1 >> 1 ;\n a1 -= e1 ;\n op [ 0 ] = a1 ;\n op [ 1 ] = op [ 2 ] = op [ 3 ] = e1 ;\n ip = tmp ;\n for ( i = 0 ;\n i < 4 ;\n i ++ ) {\n e1 = ip [ 0 ] >> 1 ;\n a1 = ip [ 0 ] - e1 ;\n dest [ dest_stride * 0 ] = clip_pixel ( dest [ dest_stride * 0 ] + a1 ) ;\n dest [ dest_stride * 1 ] = clip_pixel ( dest [ dest_stride * 1 ] + e1 ) ;\n dest [ dest_stride * 2 ] = clip_pixel ( dest [ dest_stride * 2 ] + e1 ) ;\n dest [ dest_stride * 3 ] = clip_pixel ( dest [ dest_stride * 3 ] + e1 ) ;\n ip ++ ;\n dest ++ ;\n }\n }",
        "output": "1",
        "idx": 820
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _reconnectToDB ( ArchiveHandle * AH , const char * dbname ) {\n if ( RestoringToDB ( AH ) ) ReconnectToServer ( AH , dbname , NULL ) ;\n else {\n PQExpBuffer qry = createPQExpBuffer ( ) ;\n appendPQExpBuffer ( qry , \"\\\\connect %s\\n\\n\" , dbname ? fmtId ( dbname ) : \"-\" ) ;\n ahprintf ( AH , \"%s\" , qry -> data ) ;\n destroyPQExpBuffer ( qry ) ;\n }\n if ( AH -> currUser ) free ( AH -> currUser ) ;\n AH -> currUser = NULL ;\n if ( AH -> currSchema ) free ( AH -> currSchema ) ;\n AH -> currSchema = NULL ;\n if ( AH -> currTablespace ) free ( AH -> currTablespace ) ;\n AH -> currTablespace = NULL ;\n AH -> currWithOids = - 1 ;\n _doSetFixedOutputState ( AH ) ;\n }",
        "output": "1",
        "idx": 3160
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gint nautilus_mime_types_get_number_of_groups ( void ) {\n return G_N_ELEMENTS ( mimetype_groups ) ;\n }",
        "output": "0",
        "idx": 110
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct zip_cdir * _zip_cdir_new ( int nentry , struct zip_error * error ) {\n struct zip_cdir * cd ;\n if ( ( cd = ( struct zip_cdir * ) malloc ( sizeof ( * cd ) ) ) == NULL ) {\n _zip_error_set ( error , ZIP_ER_MEMORY , 0 ) ;\n return NULL ;\n }\n if ( ( cd -> entry = ( struct zip_dirent * ) malloc ( sizeof ( * ( cd -> entry ) ) * nentry ) ) == NULL ) {\n _zip_error_set ( error , ZIP_ER_MEMORY , 0 ) ;\n free ( cd ) ;\n return NULL ;\n }\n cd -> nentry = nentry ;\n cd -> size = cd -> offset = 0 ;\n cd -> comment = NULL ;\n cd -> comment_len = 0 ;\n return cd ;\n }",
        "output": "1",
        "idx": 2055
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void nautilus_file_operations_new_file_from_template ( GtkWidget * parent_view , GdkPoint * target_point , const char * parent_dir , const char * target_filename , const char * template_uri , NautilusCreateCallback done_callback , gpointer done_callback_data ) {\n GTask * task ;\n CreateJob * job ;\n GtkWindow * parent_window ;\n parent_window = NULL ;\n if ( parent_view ) {\n parent_window = ( GtkWindow * ) gtk_widget_get_ancestor ( parent_view , GTK_TYPE_WINDOW ) ;\n }\n job = op_job_new ( CreateJob , parent_window ) ;\n job -> done_callback = done_callback ;\n job -> done_callback_data = done_callback_data ;\n job -> dest_dir = g_file_new_for_uri ( parent_dir ) ;\n if ( target_point != NULL ) {\n job -> position = * target_point ;\n job -> has_position = TRUE ;\n }\n job -> filename = g_strdup ( target_filename ) ;\n if ( template_uri ) {\n job -> src = g_file_new_for_uri ( template_uri ) ;\n }\n if ( ! nautilus_file_undo_manager_is_operating ( ) ) {\n job -> common . undo_info = nautilus_file_undo_info_create_new ( NAUTILUS_FILE_UNDO_OP_CREATE_FILE_FROM_TEMPLATE ) ;\n }\n task = g_task_new ( NULL , job -> common . cancellable , create_task_done , job ) ;\n g_task_set_task_data ( task , job , NULL ) ;\n g_task_run_in_thread ( task , create_task_thread_func ) ;\n g_object_unref ( task ) ;\n }",
        "output": "0",
        "idx": 2609
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pdf_run_BMC ( fz_context * ctx , pdf_processor * proc , const char * tag ) {\n pdf_run_processor * pr = ( pdf_run_processor * ) proc ;\n if ( ! tag ) tag = \"UnnamedLayer\" ;\n fz_begin_layer ( ctx , pr -> dev , tag ) ;\n }",
        "output": "0",
        "idx": 1353
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( TemplateURLTest , GenerateKeyword ) {\n std : : string accept_languages = \"en,ru\" ;\n ASSERT_EQ ( ASCIIToUTF16 ( \"foo\" ) , TemplateURL : : GenerateKeyword ( GURL ( \"http://foo\" ) , accept_languages ) ) ;\n ASSERT_EQ ( ASCIIToUTF16 ( \"foo\" ) , TemplateURL : : GenerateKeyword ( GURL ( \"http://www.foo\" ) , accept_languages ) ) ;\n ASSERT_EQ ( ASCIIToUTF16 ( \"blah\" ) , TemplateURL : : GenerateKeyword ( GURL ( \"http://blah/\" ) , accept_languages ) ) ;\n ASSERT_EQ ( ASCIIToUTF16 ( \"www\" ) , TemplateURL : : GenerateKeyword ( GURL ( \"http://www.\" ) , accept_languages ) ) ;\n ASSERT_EQ ( base : : UTF8ToUTF16 ( \"\\xd0\\xb0\\xd0\\xb1\\xd0\\xb2\" ) , TemplateURL : : GenerateKeyword ( GURL ( \"http://xn--80acd\" ) , accept_languages ) ) ;\n }",
        "output": "1",
        "idx": 2976
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( PageLoadMetricsBrowserTest , Ignore204Pages ) {\n ASSERT_TRUE ( embedded_test_server ( ) -> Start ( ) ) ;\n ui_test_utils : : NavigateToURL ( browser ( ) , embedded_test_server ( ) -> GetURL ( \"/page204.html\" ) ) ;\n NavigateToUntrackedUrl ( ) ;\n EXPECT_TRUE ( NoPageLoadMetricsRecorded ( ) ) << \"Recorded metrics: \" << GetRecordedPageLoadMetricNames ( ) ;\n }",
        "output": "0",
        "idx": 3195
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE ossl_cipher_initialize ( VALUE self , VALUE str ) {\n EVP_CIPHER_CTX * ctx ;\n const EVP_CIPHER * cipher ;\n char * name ;\n unsigned char dummy_key [ EVP_MAX_KEY_LENGTH ] = {\n 0 }\n ;\n name = StringValueCStr ( str ) ;\n GetCipherInit ( self , ctx ) ;\n if ( ctx ) {\n ossl_raise ( rb_eRuntimeError , \"Cipher already inititalized!\" ) ;\n }\n AllocCipher ( self , ctx ) ;\n if ( ! ( cipher = EVP_get_cipherbyname ( name ) ) ) {\n ossl_raise ( rb_eRuntimeError , \"unsupported cipher algorithm (%\" PRIsVALUE \")\" , str ) ;\n }\n if ( EVP_CipherInit_ex ( ctx , cipher , NULL , dummy_key , NULL , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ;\n return self ;\n }",
        "output": "1",
        "idx": 106
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void inject_user ( void ) {\n size_t len ;\n len = strescape ( ( char * ) injectbuf , ( char * ) injectbuf ) ;\n if ( wdg_c1 -> flags & WDG_OBJ_FOCUSED ) {\n user_inject ( injectbuf , len , curr_conn , 1 ) ;\n }\n else if ( wdg_c2 -> flags & WDG_OBJ_FOCUSED ) {\n user_inject ( injectbuf , len , curr_conn , 2 ) ;\n }\n }",
        "output": "1",
        "idx": 2657
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h225_RasUsageInfoTypes ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h225_RasUsageInfoTypes , RasUsageInfoTypes_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 3206
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void send_protected_args ( int fd , char * args [ ] ) {\n int i ;\n # ifdef ICONV_OPTION int convert = ic_send != ( iconv_t ) - 1 ;\n xbuf outbuf , inbuf ;\n if ( convert ) alloc_xbuf ( & outbuf , 1024 ) ;\n # endif for ( i = 0 ;\n args [ i ] ;\n i ++ ) {\n }\n args [ i ] = \"rsync\" ;\n if ( DEBUG_GTE ( CMD , 1 ) ) print_child_argv ( \"protected args:\" , args + i + 1 ) ;\n do {\n if ( ! args [ i ] [ 0 ] ) write_buf ( fd , \".\" , 2 ) ;\n # ifdef ICONV_OPTION else if ( convert ) {\n INIT_XBUF_STRLEN ( inbuf , args [ i ] ) ;\n iconvbufs ( ic_send , & inbuf , & outbuf , ICB_EXPAND_OUT | ICB_INCLUDE_BAD | ICB_INCLUDE_INCOMPLETE | ICB_INIT ) ;\n outbuf . buf [ outbuf . len ] = '\\0' ;\n write_buf ( fd , outbuf . buf , outbuf . len + 1 ) ;\n outbuf . len = 0 ;\n }\n # endif else write_buf ( fd , args [ i ] , strlen ( args [ i ] ) + 1 ) ;\n }\n while ( args [ ++ i ] ) ;\n write_byte ( fd , 0 ) ;\n # ifdef ICONV_OPTION if ( convert ) free ( outbuf . buf ) ;\n # endif }",
        "output": "0",
        "idx": 4209
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vga_draw_line24_le ( VGACommonState * s1 , uint8_t * d , const uint8_t * s , int width ) {\n int w ;\n uint32_t r , g , b ;\n w = width ;\n do {\n b = s [ 0 ] ;\n g = s [ 1 ] ;\n r = s [ 2 ] ;\n ( ( uint32_t * ) d ) [ 0 ] = rgb_to_pixel32 ( r , g , b ) ;\n s += 3 ;\n d += 4 ;\n }\n while ( -- w != 0 ) ;\n }",
        "output": "1",
        "idx": 3329
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parse_content_type ( struct message_decoder_context * ctx , struct message_header_line * hdr ) {\n struct rfc822_parser_context parser ;\n const char * const * results ;\n string_t * str ;\n int ret ;\n if ( ctx -> content_type != NULL ) return ;\n rfc822_parser_init ( & parser , hdr -> full_value , hdr -> full_value_len , NULL ) ;\n rfc822_skip_lwsp ( & parser ) ;\n str = t_str_new ( 64 ) ;\n ret = rfc822_parse_content_type ( & parser , str ) ;\n ctx -> content_type = i_strdup ( str_c ( str ) ) ;\n if ( ret < 0 ) return ;\n rfc2231_parse ( & parser , & results ) ;\n for ( ;\n * results != NULL ;\n results += 2 ) {\n if ( strcasecmp ( results [ 0 ] , \"charset\" ) == 0 ) {\n ctx -> content_charset = i_strdup ( results [ 1 ] ) ;\n break ;\n }\n }\n }",
        "output": "1",
        "idx": 2689
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern rtype gnu_dev_ ## name proto __THROW __attribute_const__ ;\n # define __SYSMACROS_IMPL_TEMPL ( rtype , name , proto ) __extension__ __extern_inline __attribute_const__ rtype __NTH ( gnu_dev_ ## name proto ) __BEGIN_DECLS __SYSMACROS_DECLARE_MAJOR ( __SYSMACROS_DECL_TEMPL ) __SYSMACROS_DECLARE_MINOR ( __SYSMACROS_DECL_TEMPL ) __SYSMACROS_DECLARE_MAKEDEV ( __SYSMACROS_DECL_TEMPL )",
        "output": "1",
        "idx": 4321
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_frame_stats ( vpx_codec_ctx_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , vpx_fixed_buf_t * stats ) {\n int got_pkts = 0 ;\n vpx_codec_iter_t iter = NULL ;\n const vpx_codec_cx_pkt_t * pkt = NULL ;\n const vpx_codec_err_t res = vpx_codec_encode ( ctx , img , pts , duration , flags , deadline ) ;\n if ( res != VPX_CODEC_OK ) die_codec ( ctx , \"Failed to get frame stats.\" ) ;\n while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) {\n got_pkts = 1 ;\n if ( pkt -> kind == VPX_CODEC_STATS_PKT ) {\n const uint8_t * const pkt_buf = pkt -> data . twopass_stats . buf ;\n const size_t pkt_size = pkt -> data . twopass_stats . sz ;\n stats -> buf = realloc ( stats -> buf , stats -> sz + pkt_size ) ;\n memcpy ( ( uint8_t * ) stats -> buf + stats -> sz , pkt_buf , pkt_size ) ;\n stats -> sz += pkt_size ;\n }\n }\n return got_pkts ;\n }",
        "output": "0",
        "idx": 2840
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( TemplateURLTest , Defaults ) {\n TemplateURLData data ;\n EXPECT_FALSE ( data . show_in_default_list ) ;\n EXPECT_FALSE ( data . safe_for_autoreplace ) ;\n EXPECT_EQ ( 0 , data . prepopulate_id ) ;\n }",
        "output": "0",
        "idx": 254
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qemu_cpu_kick_self ( void ) {\n # ifndef _WIN32 assert ( cpu_single_env ) ;\n CPUState * cpu_single_cpu = ENV_GET_CPU ( cpu_single_env ) ;\n if ( ! cpu_single_cpu -> thread_kicked ) {\n qemu_cpu_kick_thread ( cpu_single_cpu ) ;\n cpu_single_cpu -> thread_kicked = true ;\n }\n # else abort ( ) ;\n # endif }",
        "output": "1",
        "idx": 3437
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int query_get_string ( MYSQL * mysql , const char * query , int column , DYNAMIC_STRING * ds ) {\n MYSQL_RES * res = NULL ;\n MYSQL_ROW row ;\n if ( mysql_query ( mysql , query ) ) {\n report_or_die ( \"'%s' failed: %d %s\" , query , mysql_errno ( mysql ) , mysql_error ( mysql ) ) ;\n return 1 ;\n }\n if ( ( res = mysql_store_result ( mysql ) ) == NULL ) {\n report_or_die ( \"Failed to store result: %d %s\" , mysql_errno ( mysql ) , mysql_error ( mysql ) ) ;\n return 1 ;\n }\n if ( ( row = mysql_fetch_row ( res ) ) == NULL ) {\n mysql_free_result ( res ) ;\n return 1 ;\n }\n init_dynamic_string ( ds , ( row [ column ] ? row [ column ] : \"NULL\" ) , ~ 0 , 32 ) ;\n mysql_free_result ( res ) ;\n return 0 ;\n }",
        "output": "0",
        "idx": 609
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( MultiBufferTest , LRUTest ) {\n int64_t max_size = 17 ;\n int64_t current_size = 0 ;\n lru_ -> IncrementMaxSize ( max_size ) ;\n multibuffer_ . SetMaxWriters ( 1 ) ;\n size_t pos = 0 ;\n size_t end = 10000 ;\n multibuffer_ . SetFileSize ( 10000 ) ;\n media : : MultiBufferReader reader ( & multibuffer_ , pos , end , base : : Callback < void ( int64_t , int64_t ) > ( ) ) ;\n reader . SetPreload ( 10000 , 10000 ) ;\n EXPECT_EQ ( current_size , lru_ -> Size ( ) ) ;\n current_size += max_size ;\n while ( AdvanceAll ( ) ) ;\n EXPECT_EQ ( current_size , lru_ -> Size ( ) ) ;\n lru_ -> IncrementMaxSize ( - max_size ) ;\n lru_ -> Prune ( 3 ) ;\n current_size -= 3 ;\n EXPECT_EQ ( current_size , lru_ -> Size ( ) ) ;\n lru_ -> Prune ( 3 ) ;\n current_size -= 3 ;\n EXPECT_EQ ( current_size , lru_ -> Size ( ) ) ;\n lru_ -> Prune ( 1000 ) ;\n EXPECT_EQ ( 0 , lru_ -> Size ( ) ) ;\n }",
        "output": "1",
        "idx": 3569
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "proto_item * proto_tree_add_text_internal ( proto_tree * tree , tvbuff_t * tvb , gint start , gint length , const char * format , ... ) {\n proto_item * pi ;\n va_list ap ;\n header_field_info * hfinfo ;\n CHECK_FOR_NULL_TREE ( tree ) ;\n TRY_TO_FAKE_THIS_ITEM ( tree , hf_text_only , hfinfo ) ;\n pi = proto_tree_add_text_node ( tree , tvb , start , length ) ;\n TRY_TO_FAKE_THIS_REPR ( pi ) ;\n va_start ( ap , format ) ;\n proto_tree_set_representation ( pi , format , ap ) ;\n va_end ( ap ) ;\n return pi ;\n }",
        "output": "1",
        "idx": 2266
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char * _UTF16GetName ( const UConverter * cnv ) {\n if ( UCNV_GET_VERSION ( cnv ) == 0 ) {\n return \"UTF-16\" ;\n }\n else if ( UCNV_GET_VERSION ( cnv ) == 1 ) {\n return \"UTF-16,version=1\" ;\n }\n else {\n return \"UTF-16,version=2\" ;\n }\n }",
        "output": "1",
        "idx": 111
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void xsltFreeStyleDocuments ( xsltStylesheetPtr style ) {\n xsltDocumentPtr doc , cur ;\n # ifdef XSLT_REFACTORED_XSLT_NSCOMP xsltNsMapPtr nsMap ;\n # endif if ( style == NULL ) return ;\n # ifdef XSLT_REFACTORED_XSLT_NSCOMP if ( XSLT_HAS_INTERNAL_NSMAP ( style ) ) nsMap = XSLT_GET_INTERNAL_NSMAP ( style ) ;\n else nsMap = NULL ;\n # endif cur = style -> docList ;\n while ( cur != NULL ) {\n doc = cur ;\n cur = cur -> next ;\n # ifdef XSLT_REFACTORED_XSLT_NSCOMP if ( nsMap ) xsltRestoreDocumentNamespaces ( nsMap , doc -> doc ) ;\n # endif xsltFreeDocumentKeys ( doc ) ;\n if ( ! doc -> main ) xmlFreeDoc ( doc -> doc ) ;\n xmlFree ( doc ) ;\n }\n }",
        "output": "1",
        "idx": 964
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __always_inline __u64 __le64_to_cpup ( const __le64 * p ) {\n return ( __u64 ) * p ;\n }",
        "output": "1",
        "idx": 3961
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int evdns_resolve_ipv6 ( const char * name , int flags , evdns_callback_type callback , void * ptr ) {\n log ( EVDNS_LOG_DEBUG , \"Resolve requested for %s\" , name ) ;\n if ( flags & DNS_QUERY_NO_SEARCH ) {\n struct request * const req = request_new ( TYPE_AAAA , name , flags , callback , ptr ) ;\n if ( req == NULL ) return ( 1 ) ;\n request_submit ( req ) ;\n return ( 0 ) ;\n }\n else {\n return ( search_request_new ( TYPE_AAAA , name , flags , callback , ptr ) ) ;\n }\n }",
        "output": "0",
        "idx": 3034
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_AddConnectionResp ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_sequence ( tvb , offset , actx , tree , hf_index , ett_h245_AddConnectionResp , AddConnectionResp_sequence ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 687
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int try_shrink_lower ( MAIN_WINDOW_REC * window , int count ) {\n MAIN_WINDOW_REC * shrink_win ;\n shrink_win = mainwindows_find_lower ( window ) ;\n if ( shrink_win != NULL ) {\n int ok ;\n GSList * shrink_list , * tmp ;\n MAIN_WINDOW_REC * win ;\n ok = TRUE ;\n shrink_list = mainwindows_get_line ( shrink_win ) ;\n for ( tmp = shrink_list ;\n tmp != NULL ;\n tmp = tmp -> next ) {\n win = tmp -> data ;\n if ( MAIN_WINDOW_TEXT_HEIGHT ( win ) - count < WINDOW_MIN_SIZE ) {\n ok = FALSE ;\n break ;\n }\n }\n if ( ok ) {\n GSList * grow_list ;\n grow_list = mainwindows_get_line ( window ) ;\n for ( tmp = shrink_list ;\n tmp != NULL ;\n tmp = tmp -> next ) {\n win = tmp -> data ;\n win -> first_line += count ;\n }\n for ( tmp = grow_list ;\n tmp != NULL ;\n tmp = tmp -> next ) {\n win = tmp -> data ;\n win -> last_line += count ;\n }\n mainwindows_resize_two ( grow_list , shrink_list , count ) ;\n g_slist_free ( grow_list ) ;\n }\n g_slist_free ( shrink_list ) ;\n return ok ;\n }\n return FALSE ;\n }",
        "output": "0",
        "idx": 3559
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tcmpt_destroy ( jpc_enc_tcmpt_t * tcmpt ) {\n jpc_enc_rlvl_t * rlvl ;\n uint_fast16_t rlvlno ;\n if ( tcmpt -> rlvls ) {\n for ( rlvlno = 0 , rlvl = tcmpt -> rlvls ;\n rlvlno < tcmpt -> numrlvls ;\n ++ rlvlno , ++ rlvl ) {\n rlvl_destroy ( rlvl ) ;\n }\n jas_free ( tcmpt -> rlvls ) ;\n }\n if ( tcmpt -> data ) {\n jas_seq2d_destroy ( tcmpt -> data ) ;\n }\n if ( tcmpt -> tsfb ) {\n jpc_tsfb_destroy ( tcmpt -> tsfb ) ;\n }\n }",
        "output": "1",
        "idx": 4149
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vp9_release_frame_buffer ( void * cb_priv , vpx_codec_frame_buffer_t * fb ) {\n InternalFrameBuffer * const int_fb = ( InternalFrameBuffer * ) fb -> priv ;\n ( void ) cb_priv ;\n if ( int_fb ) int_fb -> in_use = 0 ;\n return 0 ;\n }",
        "output": "0",
        "idx": 843
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void virtio_balloon_set_config ( VirtIODevice * vdev , const uint8_t * config_data ) {\n VirtIOBalloon * dev = to_virtio_balloon ( vdev ) ;\n struct virtio_balloon_config config ;\n memcpy ( & config , config_data , 8 ) ;\n dev -> actual = le32_to_cpu ( config . actual ) ;\n }",
        "output": "0",
        "idx": 13
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int switch_character_set_results ( MYSQL * mysql , const char * cs_name ) {\n char query_buffer [ QUERY_LENGTH ] ;\n size_t query_length ;\n if ( ! server_supports_switching_charsets ) return FALSE ;\n query_length = my_snprintf ( query_buffer , sizeof ( query_buffer ) , \"SET SESSION character_set_results = '%s'\" , ( const char * ) cs_name ) ;\n return mysql_real_query ( mysql , query_buffer , query_length ) ;\n }",
        "output": "0",
        "idx": 192
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void report_clusters_compatible ( void ) {\n if ( user_opts . check ) {\n pg_log ( PG_REPORT , \"\\n*Clusters are compatible*\\n\" ) ;\n stop_postmaster ( false ) ;\n exit ( 0 ) ;\n }\n pg_log ( PG_REPORT , \"\\n\" \"If pg_upgrade fails after this point, you must re-initdb the\\n\" \"new cluster before continuing.\\n\" ) ;\n }",
        "output": "0",
        "idx": 3002
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char * _SCSUGetName ( const UConverter * cnv ) {\n SCSUData * scsu = ( SCSUData * ) cnv -> extraInfo ;\n switch ( scsu -> locale ) {\n case l_ja : return \"SCSU,locale=ja\" ;\n default : return \"SCSU\" ;\n }\n }",
        "output": "1",
        "idx": 3149
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void decorrelate_stereo ( int32_t * buffer [ 2 ] , int nb_samples , int decorr_shift , int decorr_left_weight ) {\n int i ;\n for ( i = 0 ;\n i < nb_samples ;\n i ++ ) {\n int32_t a , b ;\n a = buffer [ 0 ] [ i ] ;\n b = buffer [ 1 ] [ i ] ;\n a -= ( b * decorr_left_weight ) >> decorr_shift ;\n b += a ;\n buffer [ 0 ] [ i ] = b ;\n buffer [ 1 ] [ i ] = a ;\n }\n }",
        "output": "0",
        "idx": 2899
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int proto_get_id_by_short_name ( const gchar * short_name ) {\n const protocol_t * protocol = NULL ;\n DISSECTOR_ASSERT_HINT ( short_name , \"No short name present\" ) ;\n protocol = ( const protocol_t * ) g_hash_table_lookup ( proto_short_names , short_name ) ;\n if ( protocol == NULL ) return - 1 ;\n return protocol -> proto_id ;\n }",
        "output": "0",
        "idx": 833
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GType hb_gobject_ ## name ## _get_type ( void ) \\ {\n static gsize type_id = 0 ;\n if ( g_once_init_enter ( & type_id ) ) {\n GType id = g_boxed_type_register_static ( g_intern_static_string ( \"hb_\" # name \"_t\" ) , ( GBoxedCopyFunc ) copy_func , ( GBoxedFreeFunc ) free_func ) ;\n g_once_init_leave ( & type_id , id ) ;\n }\n return type_id ;\n \\ }\n # define HB_DEFINE_OBJECT_TYPE ( name ) HB_DEFINE_BOXED_TYPE ( name , hb_ ## name ## _reference , hb_ ## name ## _destroy ) ;\n HB_DEFINE_OBJECT_TYPE ( buffer ) HB_DEFINE_OBJECT_TYPE ( blob )",
        "output": "1",
        "idx": 1891
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ImagingPcdDecode ( Imaging im , ImagingCodecState state , UINT8 * buf , int bytes ) {\n int x ;\n int chunk ;\n UINT8 * out ;\n UINT8 * ptr ;\n ptr = buf ;\n chunk = 3 * state -> xsize ;\n for ( ;\n ;\n ) {\n if ( bytes < chunk ) return ptr - buf ;\n out = state -> buffer ;\n for ( x = 0 ;\n x < state -> xsize ;\n x ++ ) {\n out [ 0 ] = ptr [ x ] ;\n out [ 1 ] = ptr [ ( x + 4 * state -> xsize ) / 2 ] ;\n out [ 2 ] = ptr [ ( x + 5 * state -> xsize ) / 2 ] ;\n out += 4 ;\n }\n state -> shuffle ( ( UINT8 * ) im -> image [ state -> y ] , state -> buffer , state -> xsize ) ;\n if ( ++ state -> y >= state -> ysize ) return - 1 ;\n out = state -> buffer ;\n for ( x = 0 ;\n x < state -> xsize ;\n x ++ ) {\n out [ 0 ] = ptr [ x + state -> xsize ] ;\n out [ 1 ] = ptr [ ( x + 4 * state -> xsize ) / 2 ] ;\n out [ 2 ] = ptr [ ( x + 5 * state -> xsize ) / 2 ] ;\n out += 4 ;\n }\n state -> shuffle ( ( UINT8 * ) im -> image [ state -> y ] , state -> buffer , state -> xsize ) ;\n if ( ++ state -> y >= state -> ysize ) return - 1 ;\n ptr += chunk ;\n bytes -= chunk ;\n }\n }",
        "output": "1",
        "idx": 113
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pfkey_add ( struct sock * sk , struct sk_buff * skb , const struct sadb_msg * hdr , void * const * ext_hdrs ) {\n struct net * net = sock_net ( sk ) ;\n struct xfrm_state * x ;\n int err ;\n struct km_event c ;\n x = pfkey_msg2xfrm_state ( net , hdr , ext_hdrs ) ;\n if ( IS_ERR ( x ) ) return PTR_ERR ( x ) ;\n xfrm_state_hold ( x ) ;\n if ( hdr -> sadb_msg_type == SADB_ADD ) err = xfrm_state_add ( x ) ;\n else err = xfrm_state_update ( x ) ;\n xfrm_audit_state_add ( x , err ? 0 : 1 , audit_get_loginuid ( current ) , audit_get_sessionid ( current ) , 0 ) ;\n if ( err < 0 ) {\n x -> km . state = XFRM_STATE_DEAD ;\n __xfrm_state_put ( x ) ;\n goto out ;\n }\n if ( hdr -> sadb_msg_type == SADB_ADD ) c . event = XFRM_MSG_NEWSA ;\n else c . event = XFRM_MSG_UPDSA ;\n c . seq = hdr -> sadb_msg_seq ;\n c . portid = hdr -> sadb_msg_pid ;\n km_state_notify ( x , & c ) ;\n out : xfrm_state_put ( x ) ;\n return err ;\n }",
        "output": "0",
        "idx": 1281
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_encode_intra_block_plane ( MACROBLOCK * x , BLOCK_SIZE bsize , int plane ) {\n const MACROBLOCKD * const xd = & x -> e_mbd ;\n struct encode_b_args arg = {\n x , NULL , & xd -> mi [ 0 ] -> mbmi . skip }\n ;\n vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , encode_block_intra , & arg ) ;\n }",
        "output": "1",
        "idx": 1980
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static UChar32 _UTF16GetNextUChar ( UConverterToUnicodeArgs * pArgs , UErrorCode * pErrorCode ) {\n switch ( pArgs -> converter -> mode ) {\n case 8 : return _UTF16BEGetNextUChar ( pArgs , pErrorCode ) ;\n case 9 : return _UTF16LEGetNextUChar ( pArgs , pErrorCode ) ;\n default : return UCNV_GET_NEXT_UCHAR_USE_TO_U ;\n }\n }",
        "output": "1",
        "idx": 4036
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _ASCIIGetUnicodeSet ( const UConverter * cnv , const USetAdder * sa , UConverterUnicodeSet which , UErrorCode * pErrorCode ) {\n sa -> addRange ( sa -> set , 0 , 0x7f ) ;\n }",
        "output": "1",
        "idx": 4256
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static jboolean ShouldUseSmartLockBranding ( JNIEnv * env , const JavaParamRef < jclass > & ) {\n const ProfileSyncService * sync_service = ProfileSyncServiceFactory : : GetForProfile ( ProfileManager : : GetLastUsedProfile ( ) ) ;\n return password_bubble_experiment : : IsSmartLockBrandingEnabled ( sync_service ) ;\n }",
        "output": "0",
        "idx": 3872
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool handle_new_meta_connection ( int sock ) {\n connection_t * c ;\n sockaddr_t sa ;\n int fd ;\n socklen_t len = sizeof ( sa ) ;\n fd = accept ( sock , & sa . sa , & len ) ;\n if ( fd < 0 ) {\n logger ( LOG_ERR , \"Accepting a new connection failed: %s\" , sockstrerror ( sockerrno ) ) ;\n return false ;\n }\n sockaddrunmap ( & sa ) ;\n c = new_connection ( ) ;\n c -> name = xstrdup ( \"<unknown>\" ) ;\n c -> outcipher = myself -> connection -> outcipher ;\n c -> outdigest = myself -> connection -> outdigest ;\n c -> outmaclength = myself -> connection -> outmaclength ;\n c -> outcompression = myself -> connection -> outcompression ;\n c -> address = sa ;\n c -> hostname = sockaddr2hostname ( & sa ) ;\n c -> socket = fd ;\n c -> last_ping_time = now ;\n ifdebug ( CONNECTIONS ) logger ( LOG_NOTICE , \"Connection from %s\" , c -> hostname ) ;\n configure_tcp ( c ) ;\n connection_add ( c ) ;\n c -> allow_request = ID ;\n send_id ( c ) ;\n return true ;\n }",
        "output": "1",
        "idx": 3123
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_idct4x4_16_add_c ( const int16_t * input , uint8_t * dest , int stride ) {\n int16_t out [ 4 * 4 ] ;\n int16_t * outptr = out ;\n int i , j ;\n int16_t temp_in [ 4 ] , temp_out [ 4 ] ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) {\n idct4 ( input , outptr ) ;\n input += 4 ;\n outptr += 4 ;\n }\n for ( i = 0 ;\n i < 4 ;\n ++ i ) {\n for ( j = 0 ;\n j < 4 ;\n ++ j ) temp_in [ j ] = out [ j * 4 + i ] ;\n idct4 ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 4 ;\n ++ j ) dest [ j * stride + i ] = clip_pixel ( ROUND_POWER_OF_TWO ( temp_out [ j ] , 4 ) + dest [ j * stride + i ] ) ;\n }\n }",
        "output": "1",
        "idx": 1405
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _slurm_rpc_sib_msg ( uint32_t uid , slurm_msg_t * msg ) {\n if ( ! msg -> conn ) {\n error ( \"Security violation, SIB_SUBMISSION RPC from uid=%d\" , uid ) ;\n slurm_send_rc_msg ( msg , ESLURM_ACCESS_DENIED ) ;\n return ;\n }\n fed_mgr_q_sib_msg ( msg , uid ) ;\n }",
        "output": "0",
        "idx": 39
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PyObject * string_lower ( PyStringObject * self ) {\n char * s ;\n Py_ssize_t i , n = PyString_GET_SIZE ( self ) ;\n PyObject * newobj ;\n newobj = PyString_FromStringAndSize ( NULL , n ) ;\n if ( ! newobj ) return NULL ;\n s = PyString_AS_STRING ( newobj ) ;\n Py_MEMCPY ( s , PyString_AS_STRING ( self ) , n ) ;\n for ( i = 0 ;\n i < n ;\n i ++ ) {\n int c = Py_CHARMASK ( s [ i ] ) ;\n if ( isupper ( c ) ) s [ i ] = _tolower ( c ) ;\n }\n return newobj ;\n }",
        "output": "0",
        "idx": 1742
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pdf_process_end ( fz_context * ctx , pdf_processor * proc , pdf_csi * csi ) {\n while ( csi -> gstate > 0 ) pdf_process_grestore ( ctx , proc , csi ) ;\n if ( proc -> op_END ) proc -> op_END ( ctx , proc ) ;\n }",
        "output": "0",
        "idx": 350
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * fstrndup ( const char * ptr , unsigned long len ) {\n char * result ;\n if ( len <= 0 ) return NULL ;\n result = ALLOC_N ( char , len ) ;\n memccpy ( result , ptr , 0 , len ) ;\n return result ;\n }",
        "output": "1",
        "idx": 3864
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const xmlChar * xsltEvalStaticAttrValueTemplate ( xsltStylesheetPtr style , xmlNodePtr inst , const xmlChar * name , const xmlChar * ns , int * found ) {\n const xmlChar * ret ;\n xmlChar * expr ;\n if ( ( style == NULL ) || ( inst == NULL ) || ( name == NULL ) ) return ( NULL ) ;\n expr = xsltGetNsProp ( inst , name , ns ) ;\n if ( expr == NULL ) {\n * found = 0 ;\n return ( NULL ) ;\n }\n * found = 1 ;\n ret = xmlStrchr ( expr , '{\n' ) ;\n if ( ret != NULL ) {\n xmlFree ( expr ) ;\n return ( NULL ) ;\n }\n ret = xmlDictLookup ( style -> dict , expr , - 1 ) ;\n xmlFree ( expr ) ;\n return ( ret ) ;\n }",
        "output": "1",
        "idx": 3199
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void subtract_stats ( FIRSTPASS_STATS * section , const FIRSTPASS_STATS * frame ) {\n section -> frame -= frame -> frame ;\n section -> intra_error -= frame -> intra_error ;\n section -> coded_error -= frame -> coded_error ;\n section -> sr_coded_error -= frame -> sr_coded_error ;\n section -> pcnt_inter -= frame -> pcnt_inter ;\n section -> pcnt_motion -= frame -> pcnt_motion ;\n section -> pcnt_second_ref -= frame -> pcnt_second_ref ;\n section -> pcnt_neutral -= frame -> pcnt_neutral ;\n section -> MVr -= frame -> MVr ;\n section -> mvr_abs -= frame -> mvr_abs ;\n section -> MVc -= frame -> MVc ;\n section -> mvc_abs -= frame -> mvc_abs ;\n section -> MVrv -= frame -> MVrv ;\n section -> MVcv -= frame -> MVcv ;\n section -> mv_in_out_count -= frame -> mv_in_out_count ;\n section -> new_mv_count -= frame -> new_mv_count ;\n section -> count -= frame -> count ;\n section -> duration -= frame -> duration ;\n }",
        "output": "0",
        "idx": 205
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int decode_subframe_lpc ( FLACContext * s , int32_t * decoded , int pred_order , int bps ) {\n int i ;\n int coeff_prec , qlevel ;\n int coeffs [ 32 ] ;\n for ( i = 0 ;\n i < pred_order ;\n i ++ ) {\n decoded [ i ] = get_sbits_long ( & s -> gb , bps ) ;\n }\n coeff_prec = get_bits ( & s -> gb , 4 ) + 1 ;\n if ( coeff_prec == 16 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"invalid coeff precision\\n\" ) ;\n return - 1 ;\n }\n qlevel = get_sbits ( & s -> gb , 5 ) ;\n if ( qlevel < 0 ) {\n av_log ( s -> avctx , AV_LOG_ERROR , \"qlevel %d not supported, maybe buggy stream\\n\" , qlevel ) ;\n return - 1 ;\n }\n for ( i = 0 ;\n i < pred_order ;\n i ++ ) {\n coeffs [ pred_order - i - 1 ] = get_sbits ( & s -> gb , coeff_prec ) ;\n }\n if ( decode_residuals ( s , decoded , pred_order ) < 0 ) return - 1 ;\n s -> dsp . lpc ( decoded , coeffs , pred_order , qlevel , s -> blocksize ) ;\n return 0 ;\n }",
        "output": "0",
        "idx": 11
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean logcat_binary_dump ( wtap_dumper * wdh , const struct wtap_pkthdr * phdr , const guint8 * pd , int * err ) {\n if ( phdr -> rec_type != REC_TYPE_PACKET ) {\n * err = WTAP_ERR_REC_TYPE_UNSUPPORTED ;\n return FALSE ;\n }\n if ( ! wtap_dump_file_write ( wdh , pd , phdr -> caplen , err ) ) return FALSE ;\n wdh -> bytes_dumped += phdr -> caplen ;\n return TRUE ;\n }",
        "output": "0",
        "idx": 2753
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __inline__ __u32 __arch_swab32 ( __u32 val ) {\n __asm__ ( \"bswapl %0\" : \"=r\" ( val ) : \"0\" ( val ) ) ;\n return val ;\n }",
        "output": "1",
        "idx": 499
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int _warc_bid ( struct archive_read * a , int best_bid ) {\n const char * hdr ;\n ssize_t nrd ;\n unsigned int ver ;\n ( void ) best_bid ;\n if ( ( hdr = __archive_read_ahead ( a , 12U , & nrd ) ) == NULL ) {\n return - 1 ;\n }\n else if ( nrd < 12 ) {\n return - 1 ;\n }\n ver = _warc_rdver ( hdr , nrd ) ;\n if ( ver < 1200U || ver > 10000U ) {\n return - 1 ;\n }\n return ( 64 ) ;\n }",
        "output": "0",
        "idx": 3881
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileObject , seek ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n long line_pos ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"l\" , & line_pos ) == FAILURE ) {\n return ;\n }\n if ( line_pos < 0 ) {\n zend_throw_exception_ex ( spl_ce_LogicException , 0 TSRMLS_CC , \"Can't seek file %s to negative line %ld\" , intern -> file_name , line_pos ) ;\n RETURN_FALSE ;\n }\n spl_filesystem_file_rewind ( getThis ( ) , intern TSRMLS_CC ) ;\n while ( intern -> u . file . current_line_num < line_pos ) {\n if ( spl_filesystem_file_read_line ( getThis ( ) , intern , 1 TSRMLS_CC ) == FAILURE ) {\n break ;\n }\n }\n }",
        "output": "1",
        "idx": 487
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int psf_fopen ( SF_PRIVATE * psf ) {\n psf -> error = 0 ;\n psf -> file . filedes = psf_open_fd ( & psf -> file ) ;\n if ( psf -> file . filedes == - SFE_BAD_OPEN_MODE ) {\n psf -> error = SFE_BAD_OPEN_MODE ;\n psf -> file . filedes = - 1 ;\n return psf -> error ;\n }\n ;\n if ( psf -> file . filedes == - 1 ) psf_log_syserr ( psf , errno ) ;\n return psf -> error ;\n }",
        "output": "0",
        "idx": 2526
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct im_connection * purple_ic_by_gc ( PurpleConnection * gc ) {\n return purple_ic_by_pa ( purple_connection_get_account ( gc ) ) ;\n }",
        "output": "0",
        "idx": 2974
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _UTF16LEOpen ( UConverter * cnv , UConverterLoadArgs * pArgs , UErrorCode * pErrorCode ) {\n if ( UCNV_GET_VERSION ( cnv ) <= 1 ) {\n _UTF16LEReset ( cnv , UCNV_RESET_BOTH ) ;\n }\n else {\n * pErrorCode = U_ILLEGAL_ARGUMENT_ERROR ;\n }\n }",
        "output": "1",
        "idx": 1928
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void prplcb_conn_connected ( PurpleConnection * gc ) {\n struct im_connection * ic = purple_ic_by_gc ( gc ) ;\n const char * dn ;\n set_t * s ;\n imcb_connected ( ic ) ;\n if ( ( dn = purple_connection_get_display_name ( gc ) ) && ( s = set_find ( & ic -> acc -> set , \"display_name\" ) ) ) {\n g_free ( s -> value ) ;\n s -> value = g_strdup ( dn ) ;\n }\n purple_gg_buddylist_import ( gc ) ;\n ic -> flags |= OPT_DOES_HTML ;\n }",
        "output": "0",
        "idx": 3842
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct cvec * range ( struct vars * v , celt a , celt b , int cases ) {\n int nchrs ;\n struct cvec * cv ;\n celt c , lc , uc ;\n if ( a != b && ! before ( a , b ) ) {\n ERR ( REG_ERANGE ) ;\n return NULL ;\n }\n if ( ! cases ) {\n cv = getcvec ( v , 0 , 1 ) ;\n NOERRN ( ) ;\n addrange ( cv , a , b ) ;\n return cv ;\n }\n nchrs = ( b - a + 1 ) * 2 + 4 ;\n cv = getcvec ( v , nchrs , 0 ) ;\n NOERRN ( ) ;\n for ( c = a ;\n c <= b ;\n c ++ ) {\n addchr ( cv , c ) ;\n lc = pg_wc_tolower ( ( chr ) c ) ;\n if ( c != lc ) addchr ( cv , lc ) ;\n uc = pg_wc_toupper ( ( chr ) c ) ;\n if ( c != uc ) addchr ( cv , uc ) ;\n }\n return cv ;\n }",
        "output": "1",
        "idx": 2760
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void xmlHashScan3 ( xmlHashTablePtr table , const xmlChar * name , const xmlChar * name2 , const xmlChar * name3 , xmlHashScanner f , void * data ) {\n xmlHashScanFull3 ( table , name , name2 , name3 , ( xmlHashScannerFull ) f , data ) ;\n }",
        "output": "1",
        "idx": 1060
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( MultiBufferTest , RandomTest ) {\n size_t file_size = 1000000 ;\n multibuffer_ . SetFileSize ( file_size ) ;\n multibuffer_ . SetMaxBlocksAfterDefer ( 10 ) ;\n std : : vector < ReadHelper * > read_helpers ;\n for ( size_t i = 0 ;\n i < 20 ;\n i ++ ) {\n read_helpers . push_back ( new ReadHelper ( file_size , 1000 , & multibuffer_ , & rnd_ ) ) ;\n }\n for ( int i = 0 ;\n i < 100 ;\n i ++ ) {\n for ( int j = 0 ;\n j < 100 ;\n j ++ ) {\n if ( rnd_ . Rand ( ) & 1 ) {\n if ( ! media : : writers . empty ( ) ) Advance ( ) ;\n }\n else {\n size_t j = rnd_ . Rand ( ) % read_helpers . size ( ) ;\n if ( rnd_ . Rand ( ) % 100 < 3 ) read_helpers [ j ] -> Seek ( ) ;\n read_helpers [ j ] -> StartRead ( ) ;\n }\n }\n multibuffer_ . CheckLRUState ( ) ;\n }\n multibuffer_ . CheckPresentState ( ) ;\n while ( ! read_helpers . empty ( ) ) {\n delete read_helpers . back ( ) ;\n read_helpers . pop_back ( ) ;\n }\n }",
        "output": "1",
        "idx": 1261
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void AssignNotdefNull ( SplineFont * sf , int * bygid , int iscff ) {\n int i ;\n for ( i = 0 ;\n i < sf -> glyphcnt ;\n ++ i ) if ( sf -> glyphs [ i ] != NULL ) {\n if ( bygid [ 0 ] == - 1 && strcmp ( sf -> glyphs [ i ] -> name , \".notdef\" ) == 0 ) {\n sf -> glyphs [ i ] -> ttf_glyph = 0 ;\n bygid [ 0 ] = i ;\n }\n else if ( ! iscff && bygid [ 1 ] == - 1 && ( strcmp ( sf -> glyphs [ i ] -> name , \".null\" ) == 0 || strcmp ( sf -> glyphs [ i ] -> name , \"uni0000\" ) == 0 || ( i == 1 && strcmp ( sf -> glyphs [ 1 ] -> name , \"glyph1\" ) == 0 ) ) ) {\n sf -> glyphs [ i ] -> ttf_glyph = 1 ;\n bygid [ 1 ] = i ;\n }\n else if ( ! iscff && bygid [ 2 ] == - 1 && ( strcmp ( sf -> glyphs [ i ] -> name , \"nonmarkingreturn\" ) == 0 || strcmp ( sf -> glyphs [ i ] -> name , \"uni000D\" ) == 0 || ( i == 2 && strcmp ( sf -> glyphs [ 2 ] -> name , \"glyph2\" ) == 0 ) ) ) {\n sf -> glyphs [ i ] -> ttf_glyph = 2 ;\n bygid [ 2 ] = i ;\n }\n }\n }",
        "output": "0",
        "idx": 2105
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void reset_stats ( VirtIOBalloon * dev ) {\n int i ;\n for ( i = 0 ;\n i < VIRTIO_BALLOON_S_NR ;\n dev -> stats [ i ++ ] = - 1 ) ;\n }",
        "output": "0",
        "idx": 3787
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void luaD_call ( lua_State * L , StkId func , int nResults ) {\n if ( ++ L -> nCcalls >= LUAI_MAXCCALLS ) {\n if ( L -> nCcalls == LUAI_MAXCCALLS ) luaG_runerror ( L , \"C stack overflow\" ) ;\n else if ( L -> nCcalls >= ( LUAI_MAXCCALLS + ( LUAI_MAXCCALLS >> 3 ) ) ) luaD_throw ( L , LUA_ERRERR ) ;\n }\n if ( luaD_precall ( L , func , nResults ) == PCRLUA ) luaV_execute ( L , 1 ) ;\n L -> nCcalls -- ;\n luaC_checkGC ( L ) ;\n }",
        "output": "0",
        "idx": 2234
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vp9_compute_qdelta_by_rate ( const RATE_CONTROL * rc , FRAME_TYPE frame_type , int qindex , double rate_target_ratio ) {\n int target_index = rc -> worst_quality ;\n int i ;\n const int base_bits_per_mb = vp9_rc_bits_per_mb ( frame_type , qindex , 1.0 ) ;\n const int target_bits_per_mb = ( int ) ( rate_target_ratio * base_bits_per_mb ) ;\n for ( i = rc -> best_quality ;\n i < rc -> worst_quality ;\n ++ i ) {\n target_index = i ;\n if ( vp9_rc_bits_per_mb ( frame_type , i , 1.0 ) <= target_bits_per_mb ) break ;\n }\n return target_index - qindex ;\n }",
        "output": "1",
        "idx": 1806
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hb_bool_t hb_shape_plan_execute ( hb_shape_plan_t * shape_plan , hb_font_t * font , hb_buffer_t * buffer , const hb_feature_t * features , unsigned int num_features ) {\n DEBUG_MSG_FUNC ( SHAPE_PLAN , shape_plan , \"num_features=%d shaper_func=%p\" , num_features , shape_plan -> shaper_func ) ;\n if ( unlikely ( hb_object_is_inert ( shape_plan ) || hb_object_is_inert ( font ) || hb_object_is_inert ( buffer ) ) ) return false ;\n assert ( shape_plan -> face_unsafe == font -> face ) ;\n assert ( hb_segment_properties_equal ( & shape_plan -> props , & buffer -> props ) ) ;\n # define HB_SHAPER_EXECUTE ( shaper ) HB_STMT_START {\n return HB_SHAPER_DATA ( shaper , shape_plan ) && hb_ ## shaper ## _shaper_font_data_ensure ( font ) && _hb_ ## shaper ## _shape ( shape_plan , font , buffer , features , num_features ) ;\n }\n HB_STMT_END if ( 0 ) ;\n # define HB_SHAPER_IMPLEMENT ( shaper ) else if ( shape_plan -> shaper_func == _hb_ ## shaper ## _shape ) HB_SHAPER_EXECUTE ( shaper ) ;\n # include \"hb-shaper-list.hh\" # undef HB_SHAPER_IMPLEMENT # undef HB_SHAPER_EXECUTE return false ;\n }",
        "output": "1",
        "idx": 3584
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline uint16_t vga_read_word_be ( VGACommonState * vga , uint32_t addr ) {\n uint32_t offset = addr & vga -> vbe_size_mask & ~ 1 ;\n uint16_t * ptr = ( uint16_t * ) ( vga -> vram_ptr + offset ) ;\n return lduw_be_p ( ptr ) ;\n }",
        "output": "0",
        "idx": 272
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * strsep_quotes ( char * * stringp , const char delim ) {\n char * s ;\n int c ;\n char * tok ;\n if ( ( s = * stringp ) == NULL ) return ( NULL ) ;\n for ( tok = s ;\n ;\n ) {\n if ( * s == '\\\"' ) while ( * ( ++ s ) != '\\\"' && * s != '\\0' ) ;\n c = * s ++ ;\n if ( c == delim || c == 0 ) {\n if ( c == 0 ) s = NULL ;\n else s [ - 1 ] = 0 ;\n * stringp = s ;\n return ( tok ) ;\n }\n }\n }",
        "output": "0",
        "idx": 1594
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_fdct16x16_1_c ( const int16_t * input , int16_t * output , int stride ) {\n int r , c ;\n int16_t sum = 0 ;\n for ( r = 0 ;\n r < 16 ;\n ++ r ) for ( c = 0 ;\n c < 16 ;\n ++ c ) sum += input [ r * stride + c ] ;\n output [ 0 ] = sum >> 1 ;\n output [ 1 ] = 0 ;\n }",
        "output": "1",
        "idx": 4005
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_RequestChannelCloseRejectCause ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_RequestChannelCloseRejectCause , RequestChannelCloseRejectCause_choice , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 1962
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int virLogHostnameString ( char * * rawmsg , char * * msg ) {\n char * hostname = virGetHostnameQuiet ( ) ;\n char * hoststr ;\n if ( ! hostname ) return - 1 ;\n if ( virAsprintfQuiet ( & hoststr , \"hostname: %s\" , hostname ) < 0 ) {\n VIR_FREE ( hostname ) ;\n return - 1 ;\n }\n VIR_FREE ( hostname ) ;\n if ( virLogFormatString ( msg , 0 , NULL , VIR_LOG_INFO , hoststr ) < 0 ) {\n VIR_FREE ( hoststr ) ;\n return - 1 ;\n }\n * rawmsg = hoststr ;\n return 0 ;\n }",
        "output": "1",
        "idx": 469
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_block_size ( VP9_COMP * const cpi , int mi_row , int mi_col , BLOCK_SIZE bsize ) {\n if ( cpi -> common . mi_cols > mi_col && cpi -> common . mi_rows > mi_row ) {\n MACROBLOCKD * const xd = & cpi -> mb . e_mbd ;\n set_modeinfo_offsets ( & cpi -> common , xd , mi_row , mi_col ) ;\n xd -> mi [ 0 ] . src_mi -> mbmi . sb_type = bsize ;\n duplicate_mode_info_in_sb ( & cpi -> common , xd , mi_row , mi_col , bsize ) ;\n }\n }",
        "output": "0",
        "idx": 832
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void completion_last_message_remove ( const char * nick ) {\n LAST_MSG_REC * rec ;\n g_return_if_fail ( nick != NULL ) ;\n rec = last_msg_find ( global_lastmsgs , nick ) ;\n if ( rec != NULL ) last_msg_destroy ( & global_lastmsgs , rec ) ;\n }",
        "output": "0",
        "idx": 736
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int png_decode_idat ( PNGDecContext * s , int length ) {\n int ret ;\n s -> zstream . avail_in = FFMIN ( length , bytestream2_get_bytes_left ( & s -> gb ) ) ;\n s -> zstream . next_in = s -> gb . buffer ;\n bytestream2_skip ( & s -> gb , length ) ;\n while ( s -> zstream . avail_in > 0 ) {\n ret = inflate ( & s -> zstream , Z_PARTIAL_FLUSH ) ;\n if ( ret != Z_OK && ret != Z_STREAM_END ) {\n return - 1 ;\n }\n if ( s -> zstream . avail_out == 0 ) {\n if ( ! ( s -> state & PNG_ALLIMAGE ) ) {\n png_handle_row ( s ) ;\n }\n s -> zstream . avail_out = s -> crow_size ;\n s -> zstream . next_out = s -> crow_buf ;\n }\n }\n return 0 ;\n }",
        "output": "0",
        "idx": 1217
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int com_connect ( String * buffer , char * line ) {\n char * tmp , buff [ 256 ] ;\n my_bool save_rehash = opt_rehash ;\n int error ;\n bzero ( buff , sizeof ( buff ) ) ;\n if ( buffer ) {\n tmp = strmake ( buff , line , sizeof ( buff ) - 2 ) ;\n # ifdef EXTRA_DEBUG tmp [ 1 ] = 0 ;\n # endif tmp = get_arg ( buff , 0 ) ;\n if ( tmp && * tmp ) {\n my_free ( current_db ) ;\n current_db = my_strdup ( tmp , MYF ( MY_WME ) ) ;\n tmp = get_arg ( buff , 1 ) ;\n if ( tmp ) {\n my_free ( current_host ) ;\n current_host = my_strdup ( tmp , MYF ( MY_WME ) ) ;\n }\n }\n else {\n opt_rehash = 0 ;\n }\n buffer -> length ( 0 ) ;\n }\n else opt_rehash = 0 ;\n error = sql_connect ( current_host , current_db , current_user , opt_password , 0 ) ;\n opt_rehash = save_rehash ;\n if ( connected ) {\n sprintf ( buff , \"Connection id: %lu\" , mysql_thread_id ( & mysql ) ) ;\n put_info ( buff , INFO_INFO ) ;\n sprintf ( buff , \"Current database: %.128s\\n\" , current_db ? current_db : \"*** NONE ***\" ) ;\n put_info ( buff , INFO_INFO ) ;\n }\n return error ;\n }",
        "output": "1",
        "idx": 2379
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char * rfbProcessFileTransferReadBuffer ( rfbClientPtr cl , uint32_t length ) {\n char * buffer = NULL ;\n int n = 0 ;\n FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN ( \"\" , cl , NULL ) ;\n if ( length > 0 ) {\n buffer = malloc ( length + 1 ) ;\n if ( buffer != NULL ) {\n if ( ( n = rfbReadExact ( cl , ( char * ) buffer , length ) ) <= 0 ) {\n if ( n != 0 ) rfbLogPerror ( \"rfbProcessFileTransferReadBuffer: read\" ) ;\n rfbCloseClient ( cl ) ;\n if ( buffer != NULL ) free ( buffer ) ;\n return NULL ;\n }\n buffer [ length ] = 0 ;\n }\n }\n return buffer ;\n }",
        "output": "1",
        "idx": 4459
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( HttpsEngagementPageLoadMetricsBrowserTest , OtherScheme ) {\n NavigateInForegroundAndCloseWithTiming ( GURL ( chrome : : kChromeUIVersionURL ) ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpEngagementHistogram , 0 ) ;\n histogram_tester_ . ExpectTotalCount ( internal : : kHttpsEngagementHistogram , 0 ) ;\n }",
        "output": "1",
        "idx": 1208
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int MDC2_Update ( MDC2_CTX * c , const unsigned char * in , size_t len ) {\n size_t i , j ;\n i = c -> num ;\n if ( i != 0 ) {\n if ( i + len < MDC2_BLOCK ) {\n memcpy ( & ( c -> data [ i ] ) , in , len ) ;\n c -> num += ( int ) len ;\n return 1 ;\n }\n else {\n j = MDC2_BLOCK - i ;\n memcpy ( & ( c -> data [ i ] ) , in , j ) ;\n len -= j ;\n in += j ;\n c -> num = 0 ;\n mdc2_body ( c , & ( c -> data [ 0 ] ) , MDC2_BLOCK ) ;\n }\n }\n i = len & ~ ( ( size_t ) MDC2_BLOCK - 1 ) ;\n if ( i > 0 ) mdc2_body ( c , in , i ) ;\n j = len - i ;\n if ( j > 0 ) {\n memcpy ( & ( c -> data [ 0 ] ) , & ( in [ i ] ) , j ) ;\n c -> num = ( int ) j ;\n }\n return 1 ;\n }",
        "output": "1",
        "idx": 28
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int test_sqr ( BIO * bp , BN_CTX * ctx ) {\n BIGNUM a , c , d , e ;\n int i ;\n BN_init ( & a ) ;\n BN_init ( & c ) ;\n BN_init ( & d ) ;\n BN_init ( & e ) ;\n for ( i = 0 ;\n i < num0 ;\n i ++ ) {\n BN_bntest_rand ( & a , 40 + i * 10 , 0 , 0 ) ;\n a . neg = rand_neg ( ) ;\n BN_sqr ( & c , & a , ctx ) ;\n if ( bp != NULL ) {\n if ( ! results ) {\n BN_print ( bp , & a ) ;\n BIO_puts ( bp , \" * \" ) ;\n BN_print ( bp , & a ) ;\n BIO_puts ( bp , \" - \" ) ;\n }\n BN_print ( bp , & c ) ;\n BIO_puts ( bp , \"\\n\" ) ;\n }\n BN_div ( & d , & e , & c , & a , ctx ) ;\n BN_sub ( & d , & d , & a ) ;\n if ( ! BN_is_zero ( & d ) || ! BN_is_zero ( & e ) ) {\n fprintf ( stderr , \"Square test failed!\\n\" ) ;\n return 0 ;\n }\n }\n BN_free ( & a ) ;\n BN_free ( & c ) ;\n BN_free ( & d ) ;\n BN_free ( & e ) ;\n return ( 1 ) ;\n }",
        "output": "1",
        "idx": 2342
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct config_filter_parser * const * config_filter_find_subset ( struct config_filter_context * ctx , const struct config_filter * filter ) {\n ARRAY_TYPE ( config_filter_parsers ) matches ;\n struct config_filter tmp_mask ;\n unsigned int i ;\n t_array_init ( & matches , 8 ) ;\n for ( i = 0 ;\n ctx -> parsers [ i ] != NULL ;\n i ++ ) {\n const struct config_filter * mask = & ctx -> parsers [ i ] -> filter ;\n if ( filter -> service != NULL ) {\n if ( ! config_filter_match_service ( mask , filter ) ) continue ;\n }\n tmp_mask = * mask ;\n if ( filter -> local_name == NULL ) tmp_mask . local_name = NULL ;\n if ( filter -> local_bits == 0 ) tmp_mask . local_bits = 0 ;\n if ( filter -> remote_bits == 0 ) tmp_mask . remote_bits = 0 ;\n if ( config_filter_match_rest ( & tmp_mask , filter ) ) array_append ( & matches , & ctx -> parsers [ i ] , 1 ) ;\n }\n array_sort ( & matches , config_filter_parser_cmp_rev ) ;\n array_append_zero ( & matches ) ;\n return array_idx ( & matches , 0 ) ;\n }",
        "output": "1",
        "idx": 1176
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void typhoon_register_types ( void ) {\n type_register_static ( & typhoon_pcihost_info ) ;\n }",
        "output": "0",
        "idx": 333
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_q931_ie_cs0 ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) {\n dissect_q931_IEs ( tvb , pinfo , NULL , tree , FALSE , 0 , 0 ) ;\n return tvb_captured_length ( tvb ) ;\n }",
        "output": "1",
        "idx": 179
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "List * find_nonnullable_vars ( Node * clause ) {\n return find_nonnullable_vars_walker ( clause , true ) ;\n }",
        "output": "0",
        "idx": 3834
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F ( TemplateURLParserTest , TestFirefoxEbay ) {\n ParamFilterImpl filter ( \"ebay\" , \"ebay\" ) ;\n ASSERT_NO_FATAL_FAILURE ( ParseFile ( \"firefox_ebay.xml\" , & filter ) ) ;\n ASSERT_TRUE ( template_url_ ) ;\n EXPECT_EQ ( ASCIIToUTF16 ( \"eBay\" ) , template_url_ -> short_name ( ) ) ;\n EXPECT_TRUE ( template_url_ -> url_ref ( ) . SupportsReplacement ( SearchTermsData ( ) ) ) ;\n EXPECT_EQ ( \"http://search.ebay.com/search/search.dll?query={\nsearchTerms}\n&\" \"MfcISAPICommand=GetResult&ht=1&srchdesc=n&maxRecordsReturned=300&\" \"maxRecordsPerPage=50&SortProperty=MetaEndSort\" , template_url_ -> url ( ) ) ;\n ASSERT_EQ ( 1U , template_url_ -> input_encodings ( ) . size ( ) ) ;\n EXPECT_EQ ( \"ISO-8859-1\" , template_url_ -> input_encodings ( ) [ 0 ] ) ;\n EXPECT_EQ ( GURL ( \"http://search.ebay.com/favicon.ico\" ) , template_url_ -> favicon_url ( ) ) ;\n }",
        "output": "0",
        "idx": 1752
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int prepare_bitmap_git ( void ) {\n if ( bitmap_git . loaded ) return 0 ;\n if ( ! open_pack_bitmap ( ) ) return load_pack_bitmap ( ) ;\n return - 1 ;\n }",
        "output": "0",
        "idx": 4134
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void idct_put ( MDECContext * a , AVFrame * frame , int mb_x , int mb_y ) {\n int16_t ( * block ) [ 64 ] = a -> block ;\n int linesize = frame -> linesize [ 0 ] ;\n uint8_t * dest_y = frame -> data [ 0 ] + ( mb_y * 16 * linesize ) + mb_x * 16 ;\n uint8_t * dest_cb = frame -> data [ 1 ] + ( mb_y * 8 * frame -> linesize [ 1 ] ) + mb_x * 8 ;\n uint8_t * dest_cr = frame -> data [ 2 ] + ( mb_y * 8 * frame -> linesize [ 2 ] ) + mb_x * 8 ;\n a -> dsp . idct_put ( dest_y , linesize , block [ 0 ] ) ;\n a -> dsp . idct_put ( dest_y + 8 , linesize , block [ 1 ] ) ;\n a -> dsp . idct_put ( dest_y + 8 * linesize , linesize , block [ 2 ] ) ;\n a -> dsp . idct_put ( dest_y + 8 * linesize + 8 , linesize , block [ 3 ] ) ;\n if ( ! ( a -> avctx -> flags & CODEC_FLAG_GRAY ) ) {\n a -> dsp . idct_put ( dest_cb , frame -> linesize [ 1 ] , block [ 4 ] ) ;\n a -> dsp . idct_put ( dest_cr , frame -> linesize [ 2 ] , block [ 5 ] ) ;\n }\n }",
        "output": "0",
        "idx": 2660
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct evhttp * http_setup ( short * pport , struct event_base * base ) {\n int i ;\n struct evhttp * myhttp ;\n short port = - 1 ;\n myhttp = evhttp_new ( base ) ;\n for ( i = 0 ;\n i < 50 ;\n ++ i ) {\n if ( evhttp_bind_socket ( myhttp , \"127.0.0.1\" , 8080 + i ) != - 1 ) {\n port = 8080 + i ;\n break ;\n }\n }\n if ( port == - 1 ) event_errx ( 1 , \"Could not start web server\" ) ;\n evhttp_set_cb ( myhttp , \"/test\" , http_basic_cb , NULL ) ;\n evhttp_set_cb ( myhttp , \"/chunked\" , http_chunked_cb , NULL ) ;\n evhttp_set_cb ( myhttp , \"/postit\" , http_post_cb , NULL ) ;\n evhttp_set_cb ( myhttp , \"/largedelay\" , http_large_delay_cb , NULL ) ;\n evhttp_set_cb ( myhttp , \"/\" , http_dispatcher_cb , NULL ) ;\n * pport = port ;\n return ( myhttp ) ;\n }",
        "output": "1",
        "idx": 421
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t u_printf_pointer_handler ( const u_printf_stream_handler * handler , void * context , ULocaleBundle * formatBundle , const u_printf_spec_info * info , const ufmt_args * args ) {\n UChar result [ UPRINTF_BUFFER_SIZE ] ;\n int32_t len = UPRINTF_BUFFER_SIZE ;\n ufmt_ptou ( result , & len , args [ 0 ] . ptrValue , TRUE ) ;\n return handler -> pad_and_justify ( context , info , result , len ) ;\n }",
        "output": "1",
        "idx": 3485
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sbr_hf_apply_noise_1 ( float ( * Y ) [ 2 ] , const float * s_m , const float * q_filt , int noise , int kx , int m_max ) {\n float phi_sign = 1 - 2 * ( kx & 1 ) ;\n sbr_hf_apply_noise ( Y , s_m , q_filt , noise , 0.0 , phi_sign , m_max ) ;\n }",
        "output": "1",
        "idx": 1480
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TSReturnCode sdk_sanity_check_alt_info ( TSHttpAltInfo info ) {\n if ( info == nullptr ) {\n return TS_ERROR ;\n }\n return TS_SUCCESS ;\n }",
        "output": "0",
        "idx": 147
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static UBool U_CALLCONV _enumPropertyStartsRange ( const void * context , UChar32 start , UChar32 end , uint32_t value ) {\n const USetAdder * sa = ( const USetAdder * ) context ;\n sa -> add ( sa -> set , start ) ;\n return TRUE ;\n }",
        "output": "1",
        "idx": 3026
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t vmport_cmd_ram_size ( void * opaque , uint32_t addr ) {\n CPUX86State * env = cpu_single_env ;\n env -> regs [ R_EBX ] = 0x1177 ;\n return ram_size ;\n }",
        "output": "1",
        "idx": 159
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __always_inline __u64 __be64_to_cpup ( const __be64 * p ) {\n return __swab64p ( ( __u64 * ) p ) ;\n }",
        "output": "1",
        "idx": 3442
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void encode_signal_range ( VC2EncContext * s ) {\n put_bits ( & s -> pb , 1 , ! s -> strict_compliance ) ;\n if ( ! s -> strict_compliance ) put_vc2_ue_uint ( & s -> pb , s -> bpp_idx ) ;\n }",
        "output": "0",
        "idx": 1977
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static vpx_codec_err_t ctrl_set_noise_sensitivity ( vpx_codec_alg_priv_t * ctx , va_list args ) {\n struct vp9_extracfg extra_cfg = ctx -> extra_cfg ;\n extra_cfg . noise_sensitivity = CAST ( VP8E_SET_NOISE_SENSITIVITY , args ) ;\n return update_extra_cfg ( ctx , & extra_cfg ) ;\n }",
        "output": "1",
        "idx": 2518
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cpu_halt_signal ( void * opaque , int irq , int level ) {\n if ( level && current_cpu ) {\n cpu_interrupt ( current_cpu , CPU_INTERRUPT_HALT ) ;\n }\n }",
        "output": "0",
        "idx": 1278
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char * NoMeta ( const char * str ) {\n if ( strchr ( str , '%' ) != NULL ) return \"**** CORRUPTED FORMAT STRING ***\" ;\n return str ;\n }",
        "output": "0",
        "idx": 943
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_q931_ie_cs7 ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , void * data _U_ ) {\n dissect_q931_IEs ( tvb , pinfo , NULL , tree , FALSE , 0 , 7 , NULL ) ;\n return tvb_captured_length ( tvb ) ;\n }",
        "output": "0",
        "idx": 717
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * ext_t_1_wml_10 ( tvbuff_t * tvb , guint32 value , guint32 str_tbl ) {\n char * str = wmem_strdup_printf ( wmem_packet_scope ( ) , \"Variable substitution - unescaped: '%s'\" , tvb_get_const_stringz ( tvb , str_tbl + value , NULL ) ) ;\n return str ;\n }",
        "output": "0",
        "idx": 1666
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int gdev_mem_max_height ( const gx_device_memory * dev , int width , ulong size , bool page_uses_transparency ) {\n int height ;\n ulong max_height ;\n ulong data_size ;\n if ( page_uses_transparency ) {\n max_height = size / ( bitmap_raster_pad_align ( width * dev -> color_info . depth + ESTIMATED_PDF14_ROW_SPACE ( width , dev -> color_info . num_components ) , dev -> pad , dev -> log2_align_mod ) + sizeof ( byte * ) * ( dev -> is_planar ? dev -> color_info . num_components : 1 ) ) ;\n height = ( int ) min ( max_height , max_int ) ;\n }\n else {\n max_height = size / ( bitmap_raster_pad_align ( width * dev -> color_info . depth , dev -> pad , dev -> log2_align_mod ) + sizeof ( byte * ) * ( dev -> is_planar ? dev -> color_info . num_components : 1 ) ) ;\n height = ( int ) min ( max_height , max_int ) ;\n do {\n gdev_mem_data_size ( dev , width , height , & data_size ) ;\n if ( data_size <= size ) break ;\n -- height ;\n }\n while ( data_size > size ) ;\n }\n return height ;\n }",
        "output": "0",
        "idx": 1676
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( DownloadNotificationTest , DISABLED_DiscardDangerousFile ) {\n GURL download_url ( embedded_test_server ( ) -> GetURL ( \"/downloads/dangerous/dangerous.swf\" ) ) ;\n content : : DownloadTestObserverTerminal download_terminal_observer ( GetDownloadManager ( browser ( ) ) , 1u , content : : DownloadTestObserver : : ON_DANGEROUS_DOWNLOAD_IGNORE ) ;\n CreateDownloadForBrowserAndURL ( browser ( ) , download_url ) ;\n base : : FilePath filename = download_item ( ) -> GetFileNameToReportUser ( ) ;\n EXPECT_EQ ( download : : DOWNLOAD_DANGER_TYPE_DANGEROUS_FILE , download_item ( ) -> GetDangerType ( ) ) ;\n EXPECT_TRUE ( download_item ( ) -> IsDangerous ( ) ) ;\n EXPECT_TRUE ( notification ( ) ) ;\n display_service_ -> SimulateClick ( NotificationHandler : : Type : : TRANSIENT , notification_id ( ) , 0 , base : : nullopt ) ;\n EXPECT_FALSE ( notification ( ) ) ;\n download_terminal_observer . WaitForFinished ( ) ;\n EXPECT_FALSE ( notification ( ) ) ;\n EXPECT_EQ ( 0u , GetDownloadNotifications ( ) . size ( ) ) ;\n std : : vector < download : : DownloadItem * > downloads ;\n GetDownloadManager ( browser ( ) ) -> GetAllDownloads ( & downloads ) ;\n EXPECT_EQ ( 0u , downloads . size ( ) ) ;\n EXPECT_FALSE ( base : : PathExists ( GetDownloadPath ( ) . Append ( filename . BaseName ( ) ) ) ) ;\n }",
        "output": "0",
        "idx": 1439
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_kpcr_number ( CPUX86State * env ) {\n struct kpcr {\n uint8_t fill1 [ 0x1c ] ;\n uint32_t self ;\n uint8_t fill2 [ 0x31 ] ;\n uint8_t number ;\n }\n QEMU_PACKED kpcr ;\n if ( cpu_memory_rw_debug ( env , env -> segs [ R_FS ] . base , ( void * ) & kpcr , sizeof ( kpcr ) , 0 ) < 0 || kpcr . self != env -> segs [ R_FS ] . base ) {\n return - 1 ;\n }\n return kpcr . number ;\n }",
        "output": "0",
        "idx": 4422
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __always_inline __be32 __cpu_to_be32p ( const __u32 * p ) {\n return ( __be32 ) __swab32p ( p ) ;\n }",
        "output": "1",
        "idx": 480
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void super_block_yrd ( VP9_COMP * cpi , MACROBLOCK * x , int * rate , int64_t * distortion , int * skip , int64_t * psse , BLOCK_SIZE bs , int64_t txfm_cache [ TX_MODES ] , int64_t ref_best_rd ) {\n MACROBLOCKD * xd = & x -> e_mbd ;\n int64_t sse ;\n int64_t * ret_sse = psse ? psse : & sse ;\n assert ( bs == xd -> mi [ 0 ] -> mbmi . sb_type ) ;\n if ( cpi -> sf . tx_size_search_method == USE_LARGESTALL || xd -> lossless ) {\n vpx_memset ( txfm_cache , 0 , TX_MODES * sizeof ( int64_t ) ) ;\n choose_largest_tx_size ( cpi , x , rate , distortion , skip , ret_sse , ref_best_rd , bs ) ;\n }\n else {\n choose_tx_size_from_rd ( cpi , x , rate , distortion , skip , ret_sse , txfm_cache , ref_best_rd , bs ) ;\n }\n }",
        "output": "1",
        "idx": 2381
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD ( SplFileObject , fread ) {\n spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ;\n long length = 0 ;\n if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , \"l\" , & length ) == FAILURE ) {\n return ;\n }\n if ( length <= 0 ) {\n php_error_docref ( NULL TSRMLS_CC , E_WARNING , \"Length parameter must be greater than 0\" ) ;\n RETURN_FALSE ;\n }\n Z_STRVAL_P ( return_value ) = emalloc ( length + 1 ) ;\n Z_STRLEN_P ( return_value ) = php_stream_read ( intern -> u . file . stream , Z_STRVAL_P ( return_value ) , length ) ;\n Z_STRVAL_P ( return_value ) [ Z_STRLEN_P ( return_value ) ] = 0 ;\n Z_TYPE_P ( return_value ) = IS_STRING ;\n }",
        "output": "1",
        "idx": 2927
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int remaining_bits ( WMAProDecodeCtx * s , GetBitContext * gb ) {\n return s -> buf_bit_size - get_bits_count ( gb ) ;\n }",
        "output": "0",
        "idx": 3391
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline const OldUChar * toOldUCharPtr ( const char16_t * p ) {\n # ifdef U_ALIASING_BARRIER U_ALIASING_BARRIER ( p ) ;\n # endif return reinterpret_cast < const OldUChar * > ( p ) ;\n }",
        "output": "1",
        "idx": 4118
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parse_content_type ( struct attachment_istream * astream , const struct message_header_line * hdr ) {\n struct rfc822_parser_context parser ;\n string_t * content_type ;\n if ( astream -> part . content_type != NULL ) return ;\n rfc822_parser_init ( & parser , hdr -> full_value , hdr -> full_value_len , NULL ) ;\n rfc822_skip_lwsp ( & parser ) ;\n T_BEGIN {\n content_type = t_str_new ( 64 ) ;\n ( void ) rfc822_parse_content_type ( & parser , content_type ) ;\n astream -> part . content_type = i_strdup ( str_c ( content_type ) ) ;\n }\n T_END ;\n }",
        "output": "1",
        "idx": 1513
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_pvfs2_truncate_request ( tvbuff_t * tvb , proto_tree * tree , int offset , packet_info * pinfo ) {\n offset = dissect_pvfs_fh ( tvb , offset , pinfo , tree , \"handle\" , NULL ) ;\n offset = dissect_pvfs_fs_id ( tvb , tree , offset ) ;\n offset += 4 ;\n proto_tree_add_item ( tree , hf_pvfs_size , tvb , offset , 8 , ENC_LITTLE_ENDIAN ) ;\n offset += 8 ;\n proto_tree_add_item ( tree , hf_pvfs_truncate_request_flags , tvb , offset , 4 , ENC_LITTLE_ENDIAN ) ;\n offset += 4 ;\n return offset ;\n }",
        "output": "0",
        "idx": 1297
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_fht4x4_c ( const int16_t * input , int16_t * output , int stride , int tx_type ) {\n if ( tx_type == DCT_DCT ) {\n vp9_fdct4x4_c ( input , output , stride ) ;\n }\n else {\n int16_t out [ 4 * 4 ] ;\n int16_t * outptr = & out [ 0 ] ;\n int i , j ;\n int16_t temp_in [ 4 ] , temp_out [ 4 ] ;\n const transform_2d ht = FHT_4 [ tx_type ] ;\n for ( i = 0 ;\n i < 4 ;\n ++ i ) {\n for ( j = 0 ;\n j < 4 ;\n ++ j ) temp_in [ j ] = input [ j * stride + i ] * 16 ;\n if ( i == 0 && temp_in [ 0 ] ) temp_in [ 0 ] += 1 ;\n ht . cols ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 4 ;\n ++ j ) outptr [ j * 4 + i ] = temp_out [ j ] ;\n }\n for ( i = 0 ;\n i < 4 ;\n ++ i ) {\n for ( j = 0 ;\n j < 4 ;\n ++ j ) temp_in [ j ] = out [ j + i * 4 ] ;\n ht . rows ( temp_in , temp_out ) ;\n for ( j = 0 ;\n j < 4 ;\n ++ j ) output [ j + i * 4 ] = ( temp_out [ j ] + 1 ) >> 2 ;\n }\n }\n }",
        "output": "1",
        "idx": 0
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int decode_tag ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n AVFrame * frame = data ;\n const uint8_t * buf = avpkt -> data ;\n int buf_size = avpkt -> size ;\n NellyMoserDecodeContext * s = avctx -> priv_data ;\n int blocks , i , ret ;\n float * samples_flt ;\n blocks = buf_size / NELLY_BLOCK_LEN ;\n if ( blocks <= 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"Packet is too small\\n\" ) ;\n return AVERROR_INVALIDDATA ;\n }\n if ( buf_size % NELLY_BLOCK_LEN ) {\n av_log ( avctx , AV_LOG_WARNING , \"Leftover bytes: %d.\\n\" , buf_size % NELLY_BLOCK_LEN ) ;\n }\n frame -> nb_samples = NELLY_SAMPLES * blocks ;\n if ( ( ret = ff_get_buffer ( avctx , frame ) ) < 0 ) {\n av_log ( avctx , AV_LOG_ERROR , \"get_buffer() failed\\n\" ) ;\n return ret ;\n }\n samples_flt = ( float * ) frame -> data [ 0 ] ;\n for ( i = 0 ;\n i < blocks ;\n i ++ ) {\n nelly_decode_block ( s , buf , samples_flt ) ;\n samples_flt += NELLY_SAMPLES ;\n buf += NELLY_BLOCK_LEN ;\n }\n * got_frame_ptr = 1 ;\n return buf_size ;\n }",
        "output": "1",
        "idx": 1757
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xps_draw_arc_segment ( fz_context * doc , fz_path * path , const fz_matrix * mtx , float th0 , float th1 , int iscw ) {\n float t , d ;\n fz_point p ;\n while ( th1 < th0 ) th1 += ( float ) M_PI * 2 ;\n d = ( float ) M_PI / 180 ;\n if ( iscw ) {\n for ( t = th0 + d ;\n t < th1 - d / 2 ;\n t += d ) {\n p . x = cosf ( t ) ;\n p . y = sinf ( t ) ;\n fz_transform_point ( & p , mtx ) ;\n fz_lineto ( doc , path , p . x , p . y ) ;\n }\n }\n else {\n th0 += ( float ) M_PI * 2 ;\n for ( t = th0 - d ;\n t > th1 + d / 2 ;\n t -= d ) {\n p . x = cosf ( t ) ;\n p . y = sinf ( t ) ;\n fz_transform_point ( & p , mtx ) ;\n fz_lineto ( doc , path , p . x , p . y ) ;\n }\n }\n }",
        "output": "0",
        "idx": 3307
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vpx_codec_err_t vpx_codec_enc_config_set ( vpx_codec_ctx_t * ctx , const vpx_codec_enc_cfg_t * cfg ) {\n vpx_codec_err_t res ;\n if ( ! ctx || ! ctx -> iface || ! ctx -> priv || ! cfg ) res = VPX_CODEC_INVALID_PARAM ;\n else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ;\n else res = ctx -> iface -> enc . cfg_set ( get_alg_priv ( ctx ) , cfg ) ;\n return SAVE_STATUS ( ctx , res ) ;\n }",
        "output": "0",
        "idx": 3939
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool config_filters_equal ( const struct config_filter * f1 , const struct config_filter * f2 ) {\n if ( null_strcmp ( f1 -> service , f2 -> service ) != 0 ) return FALSE ;\n if ( f1 -> remote_bits != f2 -> remote_bits ) return FALSE ;\n if ( ! net_ip_compare ( & f1 -> remote_net , & f2 -> remote_net ) ) return FALSE ;\n if ( f1 -> local_bits != f2 -> local_bits ) return FALSE ;\n if ( ! net_ip_compare ( & f1 -> local_net , & f2 -> local_net ) ) return FALSE ;\n if ( null_strcasecmp ( f1 -> local_name , f2 -> local_name ) != 0 ) return FALSE ;\n return TRUE ;\n }",
        "output": "0",
        "idx": 3192
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hb_blob_t * hb_blob_create ( const char * data , unsigned int length , hb_memory_mode_t mode , void * user_data , hb_destroy_func_t destroy ) {\n hb_blob_t * blob ;\n if ( ! length || ! ( blob = hb_object_create < hb_blob_t > ( ) ) ) {\n if ( destroy ) destroy ( user_data ) ;\n return hb_blob_get_empty ( ) ;\n }\n blob -> data = data ;\n blob -> length = length ;\n blob -> mode = mode ;\n blob -> user_data = user_data ;\n blob -> destroy = destroy ;\n if ( blob -> mode == HB_MEMORY_MODE_DUPLICATE ) {\n blob -> mode = HB_MEMORY_MODE_READONLY ;\n if ( ! _try_writable ( blob ) ) {\n hb_blob_destroy ( blob ) ;\n return hb_blob_get_empty ( ) ;\n }\n }\n return blob ;\n }",
        "output": "1",
        "idx": 3364
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rsvp_hostlist_packet ( void * pit , packet_info * pinfo , epan_dissect_t * edt _U_ , const void * vip ) {\n conv_hash_t * hash = ( conv_hash_t * ) pit ;\n const rsvp_conversation_info * rsvph = ( const rsvp_conversation_info * ) vip ;\n add_hostlist_table_data ( hash , & rsvph -> source , 0 , TRUE , 1 , pinfo -> fd -> pkt_len , & rsvp_host_dissector_info , PT_NONE ) ;\n add_hostlist_table_data ( hash , & rsvph -> destination , 0 , FALSE , 1 , pinfo -> fd -> pkt_len , & rsvp_host_dissector_info , PT_NONE ) ;\n return 1 ;\n }",
        "output": "0",
        "idx": 2890
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void xmlHashScanFull ( xmlHashTablePtr table , xmlHashScannerFull f , void * data ) {\n int i , nb ;\n xmlHashEntryPtr iter ;\n xmlHashEntryPtr next ;\n if ( table == NULL ) return ;\n if ( f == NULL ) return ;\n if ( table -> table ) {\n for ( i = 0 ;\n i < table -> size ;\n i ++ ) {\n if ( table -> table [ i ] . valid == 0 ) continue ;\n iter = & ( table -> table [ i ] ) ;\n while ( iter ) {\n next = iter -> next ;\n nb = table -> nbElems ;\n if ( ( f != NULL ) && ( iter -> payload != NULL ) ) f ( iter -> payload , data , iter -> name , iter -> name2 , iter -> name3 ) ;\n if ( nb != table -> nbElems ) {\n if ( iter == & ( table -> table [ i ] ) ) {\n if ( table -> table [ i ] . valid == 0 ) iter = NULL ;\n if ( table -> table [ i ] . next != next ) iter = & ( table -> table [ i ] ) ;\n }\n else iter = next ;\n }\n else iter = next ;\n }\n }\n }\n }",
        "output": "1",
        "idx": 1573
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dtap_sms_cp_data ( tvbuff_t * tvb , proto_tree * tree , packet_info * pinfo _U_ , guint32 offset , guint len ) {\n guint32 curr_offset ;\n guint32 consumed ;\n guint curr_len ;\n curr_offset = offset ;\n curr_len = len ;\n is_uplink = IS_UPLINK_TRUE ;\n ELEM_MAND_LV ( GSM_A_PDU_TYPE_DTAP , DE_CP_USER_DATA , NULL ) ;\n EXTRANEOUS_DATA_CHECK ( curr_len , 0 , pinfo , & ei_gsm_a_dtap_extraneous_data ) ;\n }",
        "output": "0",
        "idx": 3838
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pfkey_promisc ( struct sock * sk , struct sk_buff * skb , const struct sadb_msg * hdr , void * const * ext_hdrs ) {\n struct pfkey_sock * pfk = pfkey_sk ( sk ) ;\n int satype = hdr -> sadb_msg_satype ;\n bool reset_errno = false ;\n if ( hdr -> sadb_msg_len == ( sizeof ( * hdr ) / sizeof ( uint64_t ) ) ) {\n reset_errno = true ;\n if ( satype != 0 && satype != 1 ) return - EINVAL ;\n pfk -> promisc = satype ;\n }\n if ( reset_errno && skb_cloned ( skb ) ) skb = skb_copy ( skb , GFP_KERNEL ) ;\n else skb = skb_clone ( skb , GFP_KERNEL ) ;\n if ( reset_errno && skb ) {\n struct sadb_msg * new_hdr = ( struct sadb_msg * ) skb -> data ;\n new_hdr -> sadb_msg_errno = 0 ;\n }\n pfkey_broadcast ( skb , GFP_KERNEL , BROADCAST_ALL , NULL , sock_net ( sk ) ) ;\n return 0 ;\n }",
        "output": "0",
        "idx": 189
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_h245_IS11172_multichannelType ( tvbuff_t * tvb _U_ , int offset _U_ , asn1_ctx_t * actx _U_ , proto_tree * tree _U_ , int hf_index _U_ ) {\n offset = dissect_per_choice ( tvb , offset , actx , tree , hf_index , ett_h245_IS11172_multichannelType , IS11172_multichannelType_choice , NULL ) ;\n return offset ;\n }",
        "output": "0",
        "idx": 1920
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint16_t * build_linear_table ( int length ) {\n int i ;\n uint16_t * output = malloc ( sizeof ( uint16_t ) * length ) ;\n if ( ! output ) return NULL ;\n for ( i = 0 ;\n i < length ;\n i ++ ) {\n double x = ( ( double ) i * 65535. ) / ( double ) ( length - 1 ) ;\n uint16_fract_t input = floor ( x + .5 ) ;\n output [ i ] = input ;\n }\n return output ;\n }",
        "output": "0",
        "idx": 2759
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dissect_type_bitmap_nxt ( proto_tree * rr_tree , tvbuff_t * tvb , int cur_offset , int rr_len ) {\n int mask ;\n int i , initial_offset , rr_type ;\n guint8 bits ;\n initial_offset = cur_offset ;\n rr_type = 0 ;\n while ( rr_len != 0 ) {\n bits = tvb_get_guint8 ( tvb , cur_offset ) ;\n mask = 1 << 7 ;\n for ( i = 0 ;\n i < 8 ;\n i ++ ) {\n if ( bits & mask ) {\n proto_tree_add_uint_format ( rr_tree , hf_dns_rr_type , tvb , cur_offset , 1 , rr_type , \"RR type in bit map: %s\" , val_to_str_ext ( rr_type , & dns_types_description_vals_ext , \"Unknown (%d)\" ) ) ;\n }\n mask >>= 1 ;\n rr_type ++ ;\n }\n cur_offset += 1 ;\n rr_len -= 1 ;\n }\n return ( initial_offset - cur_offset ) ;\n }",
        "output": "0",
        "idx": 85
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gint dissect_AllJoyn_message ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gint offset ) {\n proto_item * message_item ;\n proto_tree * message_tree ;\n gint last_offset = - 1 ;\n gint packet_length ;\n gboolean is_ardp = FALSE ;\n if ( offset != 0 ) {\n is_ardp = TRUE ;\n }\n pinfo -> desegment_len = 0 ;\n packet_length = tvb_reported_length ( tvb ) ;\n col_clear ( pinfo -> cinfo , COL_INFO ) ;\n col_set_str ( pinfo -> cinfo , COL_PROTOCOL , \"ALLJOYN\" ) ;\n message_item = proto_tree_add_item ( tree , proto_AllJoyn_mess , tvb , offset , - 1 , ENC_NA ) ;\n message_tree = proto_item_add_subtree ( message_item , ett_alljoyn_mess ) ;\n while ( offset < packet_length && offset > last_offset ) {\n last_offset = offset ;\n if ( ! is_ardp ) {\n offset = handle_message_connect ( tvb , pinfo , offset , message_tree ) ;\n if ( offset >= packet_length ) {\n break ;\n }\n offset = handle_message_sasl ( tvb , pinfo , offset , message_tree ) ;\n if ( offset >= packet_length ) {\n break ;\n }\n }\n offset = handle_message_header_body ( tvb , pinfo , offset , message_tree , is_ardp ) ;\n }\n return offset ;\n }",
        "output": "0",
        "idx": 2082
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * rfc2047_decode_word ( const char * s , size_t len , enum ContentEncoding enc ) {\n const char * it = s ;\n const char * end = s + len ;\n if ( enc == ENCQUOTEDPRINTABLE ) {\n struct Buffer buf = {\n 0 }\n ;\n for ( ;\n it < end ;\n ++ it ) {\n if ( * it == '_' ) {\n mutt_buffer_addch ( & buf , ' ' ) ;\n }\n else if ( ( * it == '=' ) && ( ! ( it [ 1 ] & ~ 127 ) && hexval ( it [ 1 ] ) != - 1 ) && ( ! ( it [ 2 ] & ~ 127 ) && hexval ( it [ 2 ] ) != - 1 ) ) {\n mutt_buffer_addch ( & buf , ( hexval ( it [ 1 ] ) << 4 ) | hexval ( it [ 2 ] ) ) ;\n it += 2 ;\n }\n else {\n mutt_buffer_addch ( & buf , * it ) ;\n }\n }\n mutt_buffer_addch ( & buf , '\\0' ) ;\n return buf . data ;\n }\n else if ( enc == ENCBASE64 ) {\n char * out = mutt_mem_malloc ( 3 * len / 4 + 1 ) ;\n int dlen = mutt_b64_decode ( out , it ) ;\n if ( dlen == - 1 ) {\n FREE ( & out ) ;\n return NULL ;\n }\n out [ dlen ] = '\\0' ;\n return out ;\n }\n assert ( 0 ) ;\n return NULL ;\n }",
        "output": "1",
        "idx": 4334
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int TSMimeHdrLengthGet ( TSMBuffer bufp , TSMLoc obj ) {\n sdk_assert ( sdk_sanity_check_mbuffer ( bufp ) == TS_SUCCESS ) ;\n sdk_assert ( ( sdk_sanity_check_mime_hdr_handle ( obj ) == TS_SUCCESS ) || ( sdk_sanity_check_http_hdr_handle ( obj ) == TS_SUCCESS ) ) ;\n MIMEHdrImpl * mh = _hdr_mloc_to_mime_hdr_impl ( obj ) ;\n return mime_hdr_length_get ( mh ) ;\n }",
        "output": "0",
        "idx": 4264
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp8_mbpost_proc_across_ip_c ( unsigned char * src , int pitch , int rows , int cols , int flimit ) {\n int r , c , i ;\n unsigned char * s = src ;\n unsigned char d [ 16 ] ;\n for ( r = 0 ;\n r < rows ;\n r ++ ) {\n int sumsq = 0 ;\n int sum = 0 ;\n for ( i = - 8 ;\n i < 0 ;\n i ++ ) s [ i ] = s [ 0 ] ;\n for ( i = cols ;\n i < cols + 17 ;\n i ++ ) s [ i ] = s [ cols - 1 ] ;\n for ( i = - 8 ;\n i <= 6 ;\n i ++ ) {\n sumsq += s [ i ] * s [ i ] ;\n sum += s [ i ] ;\n d [ i + 8 ] = 0 ;\n }\n for ( c = 0 ;\n c < cols + 8 ;\n c ++ ) {\n int x = s [ c + 7 ] - s [ c - 8 ] ;\n int y = s [ c + 7 ] + s [ c - 8 ] ;\n sum += x ;\n sumsq += x * y ;\n d [ c & 15 ] = s [ c ] ;\n if ( sumsq * 15 - sum * sum < flimit ) {\n d [ c & 15 ] = ( 8 + sum + s [ c ] ) >> 4 ;\n }\n s [ c - 8 ] = d [ ( c - 8 ) & 15 ] ;\n }\n s += pitch ;\n }\n }",
        "output": "1",
        "idx": 2929
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_P ( BrowserCloseManagerWithDownloadsBrowserTest , TestWithDownloads ) {\n SetDownloadPathForProfile ( browser ( ) -> profile ( ) ) ;\n ASSERT_NO_FATAL_FAILURE ( CreateStalledDownload ( browser ( ) ) ) ;\n content : : TestNavigationObserver navigation_observer ( browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) , 1 ) ;\n TestBrowserCloseManager : : AttemptClose ( TestBrowserCloseManager : : USER_CHOICE_USER_CANCELS_CLOSE ) ;\n EXPECT_FALSE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n navigation_observer . Wait ( ) ;\n EXPECT_EQ ( GURL ( chrome : : kChromeUIDownloadsURL ) , browser ( ) -> tab_strip_model ( ) -> GetActiveWebContents ( ) -> GetURL ( ) ) ;\n RepeatedNotificationObserver close_observer ( chrome : : NOTIFICATION_BROWSER_CLOSED , 1 ) ;\n TestBrowserCloseManager : : AttemptClose ( TestBrowserCloseManager : : USER_CHOICE_USER_ALLOWS_CLOSE ) ;\n close_observer . Wait ( ) ;\n EXPECT_TRUE ( browser_shutdown : : IsTryingToQuit ( ) ) ;\n EXPECT_TRUE ( BrowserList : : GetInstance ( ) -> empty ( ) ) ;\n if ( browser_defaults : : kBrowserAliveWithNoWindows ) EXPECT_EQ ( 1 , DownloadCoreService : : NonMaliciousDownloadCountAllProfiles ( ) ) ;\n else EXPECT_EQ ( 0 , DownloadCoreService : : NonMaliciousDownloadCountAllProfiles ( ) ) ;\n }",
        "output": "1",
        "idx": 1310
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void remoteDispatchAuthError ( remote_error * rerr ) {\n remoteDispatchStringError ( rerr , VIR_ERR_AUTH_FAILED , \"authentication failed\" ) ;\n }",
        "output": "0",
        "idx": 828
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_gf_active_quality ( const RATE_CONTROL * const rc , int q ) {\n return get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , arfgf_low_motion_minq , arfgf_high_motion_minq ) ;\n }",
        "output": "1",
        "idx": 806
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IN_PROC_BROWSER_TEST_F ( UnloadTest , CrossSiteInfiniteUnloadAsync ) {\n if ( base : : CommandLine : : ForCurrentProcess ( ) -> HasSwitch ( switches : : kSingleProcess ) ) return ;\n NavigateToDataURL ( INFINITE_UNLOAD_HTML , \"infiniteunload\" ) ;\n NavigateToNolistenersFileTwiceAsync ( ) ;\n }",
        "output": "0",
        "idx": 561
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dissect_zcl_groups_view_group_response ( tvbuff_t * tvb , proto_tree * tree , guint * offset ) {\n guint attr_uint ;\n guint8 * attr_string ;\n proto_tree_add_item ( tree , hf_zbee_zcl_groups_status , tvb , * offset , 1 , ENC_LITTLE_ENDIAN ) ;\n * offset += 1 ;\n proto_tree_add_item ( tree , hf_zbee_zcl_groups_group_id , tvb , * offset , 2 , ENC_LITTLE_ENDIAN ) ;\n * offset += 2 ;\n attr_uint = tvb_get_guint8 ( tvb , * offset ) ;\n if ( attr_uint == 0xff ) attr_uint = 0 ;\n proto_tree_add_uint ( tree , hf_zbee_zcl_groups_attr_str_len , tvb , * offset , 1 , attr_uint ) ;\n * offset += 1 ;\n attr_string = tvb_get_string_enc ( wmem_packet_scope ( ) , tvb , * offset , attr_uint , ENC_ASCII ) ;\n proto_item_append_text ( tree , \", String: %s\" , attr_string ) ;\n proto_tree_add_string ( tree , hf_zbee_zcl_groups_attr_str , tvb , * offset , attr_uint , attr_string ) ;\n * offset += attr_uint ;\n }",
        "output": "0",
        "idx": 680
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vp9_lpf_vertical_4_dual_sse2 ( uint8_t * s , int p , const uint8_t * blimit0 , const uint8_t * limit0 , const uint8_t * thresh0 , const uint8_t * blimit1 , const uint8_t * limit1 , const uint8_t * thresh1 ) {\n DECLARE_ALIGNED_ARRAY ( 16 , unsigned char , t_dst , 16 * 8 ) ;\n unsigned char * src [ 2 ] ;\n unsigned char * dst [ 2 ] ;\n transpose8x16 ( s - 4 , s - 4 + p * 8 , p , t_dst , 16 ) ;\n vp9_lpf_horizontal_4_dual_sse2 ( t_dst + 4 * 16 , 16 , blimit0 , limit0 , thresh0 , blimit1 , limit1 , thresh1 ) ;\n src [ 0 ] = t_dst ;\n src [ 1 ] = t_dst + 8 ;\n dst [ 0 ] = s - 4 ;\n dst [ 1 ] = s - 4 + p * 8 ;\n transpose ( src , 16 , dst , p , 2 ) ;\n }",
        "output": "1",
        "idx": 3905
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int selinux_inet_sys_rcv_skb ( struct net * ns , int ifindex , char * addrp , u16 family , u32 peer_sid , struct common_audit_data * ad ) {\n int err ;\n u32 if_sid ;\n u32 node_sid ;\n err = sel_netif_sid ( ns , ifindex , & if_sid ) ;\n if ( err ) return err ;\n err = avc_has_perm ( peer_sid , if_sid , SECCLASS_NETIF , NETIF__INGRESS , ad ) ;\n if ( err ) return err ;\n err = sel_netnode_sid ( addrp , family , & node_sid ) ;\n if ( err ) return err ;\n return avc_has_perm ( peer_sid , node_sid , SECCLASS_NODE , NODE__RECVFROM , ad ) ;\n }",
        "output": "0",
        "idx": 515
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ps2_common_post_load ( PS2State * s ) {\n PS2Queue * q = & s -> queue ;\n int size ;\n int i ;\n int tmp_data [ PS2_QUEUE_SIZE ] ;\n size = q -> count > PS2_QUEUE_SIZE ? 0 : q -> count ;\n if ( size > 0 ) {\n for ( i = 0 ;\n i < size ;\n i ++ ) {\n tmp_data [ i ] = q -> data [ q -> rptr ] ;\n if ( ++ q -> rptr == 256 ) {\n q -> rptr = 0 ;\n }\n }\n memcpy ( q -> data , tmp_data , size ) ;\n }\n q -> rptr = 0 ;\n q -> wptr = size ;\n q -> count = size ;\n s -> update_irq ( s -> update_arg , q -> count != 0 ) ;\n }",
        "output": "1",
        "idx": 1436
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void copy_backptr ( LZOContext * c , int back , int cnt ) {\n register uint8_t * dst = c -> out ;\n if ( dst - c -> out_start < back ) {\n c -> error |= AV_LZO_INVALID_BACKPTR ;\n return ;\n }\n if ( cnt > c -> out_end - dst ) {\n cnt = FFMAX ( c -> out_end - dst , 0 ) ;\n c -> error |= AV_LZO_OUTPUT_FULL ;\n }\n av_memcpy_backptr ( dst , back , cnt ) ;\n c -> out = dst + cnt ;\n }",
        "output": "1",
        "idx": 180
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int qemuMonitorJSONSetCapabilities ( qemuMonitorPtr mon ) {\n int ret ;\n virJSONValuePtr cmd = qemuMonitorJSONMakeCommand ( \"qmp_capabilities\" , NULL ) ;\n virJSONValuePtr reply = NULL ;\n if ( ! cmd ) return - 1 ;\n ret = qemuMonitorJSONCommand ( mon , cmd , & reply ) ;\n if ( ret == 0 ) ret = qemuMonitorJSONCheckError ( cmd , reply ) ;\n virJSONValueFree ( cmd ) ;\n virJSONValueFree ( reply ) ;\n return ret ;\n }",
        "output": "0",
        "idx": 646
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int32_t U_CALLCONV compareFallbacks ( const void * context , const void * fb1 , const void * fb2 ) {\n ( void ) context ;\n return ( ( const _MBCSToUFallback * ) fb1 ) -> offset - ( ( const _MBCSToUFallback * ) fb2 ) -> offset ;\n }",
        "output": "0",
        "idx": 1748
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static UChar32 _ASCIIGetNextUChar ( UConverterToUnicodeArgs * pArgs , UErrorCode * pErrorCode ) {\n const uint8_t * source ;\n uint8_t b ;\n source = ( const uint8_t * ) pArgs -> source ;\n if ( source < ( const uint8_t * ) pArgs -> sourceLimit ) {\n b = * source ++ ;\n pArgs -> source = ( const char * ) source ;\n if ( b <= 0x7f ) {\n return b ;\n }\n else {\n UConverter * cnv = pArgs -> converter ;\n cnv -> toUBytes [ 0 ] = b ;\n cnv -> toULength = 1 ;\n * pErrorCode = U_ILLEGAL_CHAR_FOUND ;\n return 0xffff ;\n }\n }\n * pErrorCode = U_INDEX_OUTOFBOUNDS_ERROR ;\n return 0xffff ;\n }",
        "output": "1",
        "idx": 2336
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void free_mi ( VP9_COMMON * cm ) {\n int i ;\n for ( i = 0 ;\n i < 2 ;\n ++ i ) {\n vpx_free ( cm -> mip_array [ i ] ) ;\n cm -> mip_array [ i ] = NULL ;\n vpx_free ( cm -> mi_grid_base_array [ i ] ) ;\n cm -> mi_grid_base_array [ i ] = NULL ;\n }\n cm -> mip = NULL ;\n cm -> prev_mip = NULL ;\n cm -> mi_grid_base = NULL ;\n cm -> prev_mi_grid_base = NULL ;\n }",
        "output": "1",
        "idx": 2421
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int get_scale ( GetBitContext * gb , int level , int value , int log2range ) {\n if ( level < 5 ) {\n value += get_bitalloc ( gb , & dca_scalefactor , level ) ;\n value = av_clip ( value , 0 , ( 1 << log2range ) - 1 ) ;\n }\n else if ( level < 8 ) {\n if ( level + 1 > log2range ) {\n skip_bits ( gb , level + 1 - log2range ) ;\n value = get_bits ( gb , log2range ) ;\n }\n else {\n value = get_bits ( gb , level + 1 ) ;\n }\n }\n return value ;\n }",
        "output": "0",
        "idx": 912
    }
]