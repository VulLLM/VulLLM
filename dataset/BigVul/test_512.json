[
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DateTimeFieldElement::DateTimeFieldElement(Document* document, FieldOwner& fieldOwner)\n    : HTMLElement(spanTag, document)\n    , m_fieldOwner(&fieldOwner)\n {\n     setAttribute(roleAttr, \"spinbutton\");\n }\n",
        "output": "1",
        "idx": 1126
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebGL2RenderingContextBase::texImage3D(\n    GLenum target,\n    GLint level,\n    GLint internalformat,\n    GLsizei width,\n    GLsizei height,\n    GLsizei depth,\n    GLint border,\n    GLenum format,\n    GLenum type,\n    MaybeShared<DOMArrayBufferView> pixels,\n    GLuint src_offset) {\n  if (isContextLost())\n    return;\n  if (bound_pixel_unpack_buffer_) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"texImage3D\",\n                       \"a buffer is bound to PIXEL_UNPACK_BUFFER\");\n     return;\n   }\n   TexImageHelperDOMArrayBufferView(\n       kTexImage3D, target, level, internalformat, width, height, depth, border,\n       format, type, 0, 0, 0, pixels.View(), kNullNotReachable, src_offset);\n}\n",
        "output": "1",
        "idx": 342
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderViewImpl::OnSelectPopupMenuItems(\n    bool canceled,\n    const std::vector<int>& selected_indices) {\n  if (!external_popup_menu_.get())\n    return;\n\n  external_popup_menu_->DidSelectItems(canceled, selected_indices);\n  external_popup_menu_.reset();\n}\n",
        "output": "0",
        "idx": 1077
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ContextState::RestoreRenderbufferBindings() {\n  bound_renderbuffer_valid = false;\n}\n",
        "output": "0",
        "idx": 2046
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)\n{\n    size_t i = 0;\n    cJSON *n = NULL;\n    cJSON *p = NULL;\n    cJSON *a = NULL;\n\n    if ((count < 0) || (numbers == NULL))\n    {\n        return NULL;\n    }\n\n    a = cJSON_CreateArray();\n    for(i = 0; a && (i < (size_t)count); i++)\n    {\n        n = cJSON_CreateNumber(numbers[i]);\n        if (!n)\n        {\n            cJSON_Delete(a);\n            return NULL;\n        }\n        if(!i)\n        {\n            a->child = n;\n        }\n        else\n        {\n            suffix_object(p, n);\n        }\n        p = n;\n    }\n\n    return a;\n}\n",
        "output": "0",
        "idx": 1321
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CrosLibrary::TestApi::SetBrightnessLibrary(\n    BrightnessLibrary* library, bool own) {\n  library_->brightness_lib_.SetImpl(library, own);\n}\n",
        "output": "1",
        "idx": 1076
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool match_option(const char *arg, int arglen, const char *opt)\n{\n\tint len = strlen(opt);\n\n\treturn len == arglen && !strncmp(arg, opt, len);\n}\n",
        "output": "0",
        "idx": 1577
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Chapters::Display::~Display()\n{\n}\n",
        "output": "1",
        "idx": 1710
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(\n     MemoryDumpType dump_type,\n     MemoryDumpLevelOfDetail level_of_detail,\n     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {\n   auto adapter =\n       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,\n         bool success, uint64_t dump_guid,\n         mojom::GlobalMemoryDumpPtr) { callback.Run(success, dump_guid); };\n\n  QueuedRequest::Args args(dump_type, level_of_detail, {},\n                           true /* add_to_trace */, base::kNullProcessId);\n  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));\n}\n",
        "output": "1",
        "idx": 1895
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gst_pngdec_base_init (gpointer g_class)\n{\n  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);\n\n  gst_element_class_add_pad_template (element_class,\n      gst_static_pad_template_get (&gst_pngdec_src_pad_template));\n  gst_element_class_add_pad_template (element_class,\n      gst_static_pad_template_get (&gst_pngdec_sink_pad_template));\n  gst_element_class_set_details (element_class, &gst_pngdec_details);\n}\n",
        "output": "0",
        "idx": 624
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void CreateOAuth2ServiceDelegate(\n       signin::AccountConsistencyMethod account_consistency) {\n    oauth2_service_delegate_.reset(new MutableProfileOAuth2TokenServiceDelegate(\n         client_.get(), &signin_error_controller_, &account_tracker_service_,\n         token_web_data_, account_consistency, revoke_all_tokens_on_load_,\n        true /* can_revoke_credantials */));\n     base::RunLoop().RunUntilIdle();\n     oauth2_service_delegate_->AddObserver(this);\n   }\n",
        "output": "1",
        "idx": 1193
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mm_create(struct mm_master *mmalloc, size_t size)\n{\n\tvoid *address;\n\tstruct mm_master *mm;\n\n\tif (mmalloc == NULL)\n\t\tmm = xcalloc(1, sizeof(struct mm_master));\n\telse\n\t\tmm = mm_xmalloc(mmalloc, sizeof(struct mm_master));\n\n\t/*\n\t * If the memory map has a mm_master it can be completely\n\t * shared including authentication between the child\n\t * and the client.\n\t */\n\tmm->mmalloc = mmalloc;\n\n\taddress = mmap(NULL, size, PROT_WRITE|PROT_READ, MAP_ANON|MAP_SHARED,\n\t    -1, 0);\n\tif (address == MAP_FAILED)\n\t\tfatal(\"mmap(%zu): %s\", size, strerror(errno));\n\n\tmm->address = address;\n\tmm->size = size;\n\n\tRB_INIT(&mm->rb_free);\n\tRB_INIT(&mm->rb_allocated);\n\n\tmm_make_entry(mm, &mm->rb_free, address, size);\n\n\treturn (mm);\n}\n",
        "output": "0",
        "idx": 293
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " image_transform_png_set_expand_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n {\n    UNUSED(bit_depth)\n \n this->next = *that;\n *that = this;\n\n /* 'expand' should do nothing for RGBA or GA input - no tRNS and the bit\n    * depth is at least 8 already.\n    */\n return (colour_type & PNG_COLOR_MASK_ALPHA) == 0;\n}\n",
        "output": "1",
        "idx": 1219
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "EffectPaintPropertyNode* EffectPaintPropertyNode::Root() {\n  DEFINE_STATIC_REF(EffectPaintPropertyNode, root,\n                    (EffectPaintPropertyNode::Create(\n                        nullptr, State{TransformPaintPropertyNode::Root(),\n                                       ClipPaintPropertyNode::Root()})));\n   return root;\n }\n",
        "output": "1",
        "idx": 1508
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int Textfield::OnDragUpdated(const ui::DropTargetEvent& event) {\n  DCHECK(CanDrop(event.data()));\n  gfx::RenderText* render_text = GetRenderText();\n  const gfx::Range& selection = render_text->selection();\n  drop_cursor_position_ = render_text->FindCursorPosition(event.location());\n  bool in_selection =\n      !selection.is_empty() &&\n      selection.Contains(gfx::Range(drop_cursor_position_.caret_pos()));\n  drop_cursor_visible_ = !in_selection;\n  OnCaretBoundsChanged();\n  SchedulePaint();\n\n  StopBlinkingCursor();\n\n  if (initiating_drag_) {\n    if (in_selection)\n      return ui::DragDropTypes::DRAG_NONE;\n    return event.IsControlDown() ? ui::DragDropTypes::DRAG_COPY\n                                 : ui::DragDropTypes::DRAG_MOVE;\n  }\n  return ui::DragDropTypes::DRAG_COPY | ui::DragDropTypes::DRAG_MOVE;\n}\n",
        "output": "0",
        "idx": 1567
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err extr_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s;\n\n\te = gf_isom_box_parse((GF_Box**) &ptr->feci, bs);\n\tif (e) return e;\n\tif (ptr->feci->size>ptr->size) return GF_ISOM_INVALID_MEDIA;\n\tptr->data_length = (u32) (ptr->size - ptr->feci->size);\n\tptr->data = gf_malloc(sizeof(char)*ptr->data_length);\n\tgf_bs_read_data(bs, ptr->data, ptr->data_length);\n\n\treturn GF_OK;\n}\n",
        "output": "0",
        "idx": 1176
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SyncBackendHost::StartConfiguration(Callback0::Type* callback) {\n  core_thread_.message_loop()->PostTask(FROM_HERE, NewRunnableMethod(\n    core_.get(),&SyncBackendHost::Core::DoStartConfiguration, callback));\n}\n",
        "output": "0",
        "idx": 1586
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void vmxnet3_ring_init(PCIDevice *d,\n\t\t\t\t     Vmxnet3Ring *ring,\n                                     hwaddr pa,\n                                     size_t size,\n                                     size_t cell_size,\n                                     bool zero_region)\n{\n    ring->pa = pa;\n    ring->size = size;\n    ring->cell_size = cell_size;\n    ring->gen = VMXNET3_INIT_GEN;\n    ring->next = 0;\n\n    if (zero_region) {\n        vmw_shmem_set(d, pa, 0, size * cell_size);\n    }\n}\n",
        "output": "0",
        "idx": 2074
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const wbxml_decoding *get_wbxml_decoding_from_content_type (\n\t\t\t\t\t\t\t\t   const char *content_type, tvbuff_t *tvb, guint32 offset)\n{\n\tconst wbxml_decoding *map = NULL;\n\n\tDebugLog((\"get_wbxml_decoding_from_content_type: content_type = [%s]\\n\",\n\t\t  content_type));\n\tif (content_type && content_type[0]) {\n\t\tconst wbxml_literal_list *item = content_type_list;\n\n\t\twhile (item && item->content_type) {\n\t\t\tif (g_ascii_strcasecmp(content_type, item->content_type) == 0) {\n\t\t\t\t/* Try the discriminator */\n\t\t\t\tif (item->discriminator != NULL) {\n\t\t\t\t\tmap = item->discriminator(tvb, offset);\n\t\t\t\t}\n\t\t\t\tif (map == NULL) {\n\t\t\t\t\tmap = item->map;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\titem++;\n\t\t}\n\t}\n\treturn map;\n}\n",
        "output": "0",
        "idx": 1397
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SyncBackendHost::Core::RouteJsEvent(\n    const std::string& name, const JsEventDetails& details) {\n  host_->frontend_loop_->PostTask(\n      FROM_HERE, NewRunnableMethod(\n          this, &Core::RouteJsEventOnFrontendLoop, name, details));\n}\n",
        "output": "0",
        "idx": 761
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static inline void set_socket_blocking(int s, int blocking)\n {\n     int opts;\n    opts = fcntl(s, F_GETFL);\n     if (opts<0) APPL_TRACE_ERROR(\"set blocking (%s)\", strerror(errno));\n     if(blocking)\n         opts &= ~O_NONBLOCK;\n     else opts |= O_NONBLOCK;\n    if (fcntl(s, F_SETFL, opts) < 0)\n         APPL_TRACE_ERROR(\"set blocking (%s)\", strerror(errno));\n }\n",
        "output": "1",
        "idx": 1383
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool IsFormSubmit(const NavigationEntry* entry) {\n  return (ui::PageTransitionStripQualifier(entry->GetTransitionType()) ==\n          ui::PAGE_TRANSITION_FORM_SUBMIT);\n}\n",
        "output": "0",
        "idx": 598
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    ~AutoInstallCurrentThreadPlatformMock()\n    {\n        Platform::initialize(m_oldPlatform);\n    }\n",
        "output": "0",
        "idx": 1009
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RenderWidgetHostView* RenderWidgetHostImpl::GetView() const {\n  return view_;\n}\n",
        "output": "0",
        "idx": 1569
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CompositorImpl::DidInitializeLayerTreeFrameSink() {\n  layer_tree_frame_sink_request_pending_ = false;\n  has_layer_tree_frame_sink_ = true;\n  for (auto& frame_sink_id : pending_child_frame_sink_ids_)\n    AddChildFrameSink(frame_sink_id);\n\n  pending_child_frame_sink_ids_.clear();\n}\n",
        "output": "0",
        "idx": 1335
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " SPL_METHOD(RecursiveDirectoryIterator, getSubPath)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n\tif (intern->u.dir.sub_path) {\n\t\tRETURN_STRINGL(intern->u.dir.sub_path, intern->u.dir.sub_path_len, 1);\n\t} else {\n\t\tRETURN_STRINGL(\"\", 0, 1);\n\t}\n}\n",
        "output": "1",
        "idx": 93
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rose_getsockopt(struct socket *sock, int level, int optname,\n\tchar __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint val = 0;\n\tint len;\n\n\tif (level != SOL_ROSE)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tswitch (optname) {\n\tcase ROSE_DEFER:\n\t\tval = rose->defer;\n\t\tbreak;\n\n\tcase ROSE_T1:\n\t\tval = rose->t1 / HZ;\n\t\tbreak;\n\n\tcase ROSE_T2:\n\t\tval = rose->t2 / HZ;\n\t\tbreak;\n\n\tcase ROSE_T3:\n\t\tval = rose->t3 / HZ;\n\t\tbreak;\n\n\tcase ROSE_HOLDBACK:\n\t\tval = rose->hb / HZ;\n\t\tbreak;\n\n\tcase ROSE_IDLE:\n\t\tval = rose->idle / (60 * HZ);\n\t\tbreak;\n\n\tcase ROSE_QBITINCL:\n\t\tval = rose->qbitincl;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tlen = min_t(unsigned int, len, sizeof(int));\n\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\n\treturn copy_to_user(optval, &val, len) ? -EFAULT : 0;\n}\n",
        "output": "0",
        "idx": 1264
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NaClProcessHost::NaClProcessHost(const GURL& manifest_url, bool off_the_record)\n    : manifest_url_(manifest_url),\n#if defined(OS_WIN)\n      process_launched_by_broker_(false),\n#elif defined(OS_LINUX)\n      wait_for_nacl_gdb_(false),\n#endif\n      reply_msg_(NULL),\n#if defined(OS_WIN)\n      debug_exception_handler_requested_(false),\n#endif\n      internal_(new NaClInternal()),\n      ALLOW_THIS_IN_INITIALIZER_LIST(weak_factory_(this)),\n      enable_exception_handling_(false),\n      off_the_record_(off_the_record) {\n  process_.reset(content::BrowserChildProcessHost::Create(\n      content::PROCESS_TYPE_NACL_LOADER, this));\n\n  process_->SetName(net::FormatUrl(manifest_url_, std::string()));\n\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kEnableNaClExceptionHandling) ||\n       getenv(\"NACL_UNTRUSTED_EXCEPTION_HANDLING\") != NULL) {\n     enable_exception_handling_ = true;\n   }\n  enable_ipc_proxy_ = CommandLine::ForCurrentProcess()->HasSwitch(\n      switches::kEnableNaClIPCProxy);\n }\n",
        "output": "1",
        "idx": 390
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct key *request_master_key(struct encrypted_key_payload *epayload,\n\t\t\t\t      u8 **master_key, size_t *master_keylen)\n{\n\tstruct key *mkey = NULL;\n\n\tif (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,\n\t\t     KEY_TRUSTED_PREFIX_LEN)) {\n\t\tmkey = request_trusted_key(epayload->master_desc +\n\t\t\t\t\t   KEY_TRUSTED_PREFIX_LEN,\n\t\t\t\t\t   master_key, master_keylen);\n\t} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,\n\t\t\t    KEY_USER_PREFIX_LEN)) {\n\t\tmkey = request_user_key(epayload->master_desc +\n\t\t\t\t\tKEY_USER_PREFIX_LEN,\n\t\t\t\t\tmaster_key, master_keylen);\n\t} else\n\t\tgoto out;\n\n\tif (IS_ERR(mkey)) {\n\t\tint ret = PTR_ERR(mkey);\n\n\t\tif (ret == -ENOTSUPP)\n\t\t\tpr_info(\"encrypted_key: key %s not supported\",\n\t\t\t\tepayload->master_desc);\n\t\telse\n\t\t\tpr_info(\"encrypted_key: key %s not found\",\n\t\t\t\tepayload->master_desc);\n\t\tgoto out;\n\t}\n\n\tdump_master_key(*master_key, *master_keylen);\nout:\n\treturn mkey;\n}\n",
        "output": "0",
        "idx": 1813
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  std::unique_ptr<net::URLRequest> CreateAndExecuteRequest(const GURL& url) {\n    std::unique_ptr<net::URLRequest> request(context_.CreateRequest(\n        url, net::IDLE, &delegate_, TRAFFIC_ANNOTATION_FOR_TESTS));\n    request->Start();\n    drp_test_context_->RunUntilIdle();\n    return request;\n  }\n",
        "output": "0",
        "idx": 1071
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(money_format)\n{\n\tsize_t format_len = 0;\n\tchar *format, *p, *e;\n\tdouble value;\n\tzend_bool check = 0;\n\tzend_string *str;\n\tssize_t res_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sd\", &format, &format_len, &value) == FAILURE) {\n\t\treturn;\n\t}\n\n\tp = format;\n\te = p + format_len;\n\twhile ((p = memchr(p, '%', (e - p)))) {\n\t\tif (*(p + 1) == '%') {\n\t\t\tp += 2;\n\t\t} else if (!check) {\n\t\t\tcheck = 1;\n\t\t\tp++;\n\t\t} else {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Only a single %%i or %%n token can be used\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\tstr = zend_string_alloc(format_len + 1024, 0);\n\tif ((res_len = strfmon(ZSTR_VAL(str), ZSTR_LEN(str), format, value)) < 0) {\n\t\tzend_string_free(str);\n\t\tRETURN_FALSE;\n\t}\n\tZSTR_LEN(str) = (size_t)res_len;\n\tZSTR_VAL(str)[ZSTR_LEN(str)] = '\\0';\n\n\tRETURN_NEW_STR(zend_string_truncate(str, ZSTR_LEN(str), 0));\n}\n",
        "output": "0",
        "idx": 768
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ResourcePrefetchPredictor::Shutdown() {\n  history_service_observer_.RemoveAll();\n}\n",
        "output": "0",
        "idx": 1840
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mon_st_callback(stonith_t *st, stonith_event_t *e)\n{\n    char *desc = g_strdup_printf(\n        \"Operation %s requested by %s for peer %s: %s (ref=%s)\",\n        e->operation, e->origin, e->target, pcmk_strerror(e->result), e->id); \n\n    if (snmp_target) {\n        send_snmp_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);\n    }\n    if (crm_mail_to) {\n        send_smtp_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);\n    }\n    if (external_agent) {\n        send_custom_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);\n    }\n    g_free(desc);\n}\n",
        "output": "0",
        "idx": 211
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_DetachItemFromArray( cJSON *array, int which )\n{\n\tcJSON *c = array->child;\n\twhile ( c && which > 0 ) {\n\t\tc = c->next;\n\t\t--which;\n\t}\n\tif ( ! c )\n\t\treturn 0;\n\tif ( c->prev )\n\t\tc->prev->next = c->next;\n\tif ( c->next ) c->next->prev = c->prev;\n\tif ( c == array->child )\n\t\tarray->child = c->next;\n\tc->prev = c->next = 0;\n\treturn c;\n}\n",
        "output": "1",
        "idx": 373
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const SeekHead* Segment::GetSeekHead() const\n{\n    return m_pSeekHead;\n}\n",
        "output": "1",
        "idx": 679
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " SchedulerObject::_continue(std::string key, std::string &/*reason*/, std::string &text)\n {\n        PROC_ID id = getProcByString(key.c_str());\n       if (id.cluster < 0 || id.proc < 0) {\n                dprintf(D_FULLDEBUG, \"Remove: Failed to parse id: %s\\n\", key.c_str());\n                text = \"Invalid Id\";\n                return false;\n\t}\n\n\tscheduler.enqueueActOnJobMyself(id,JA_CONTINUE_JOBS,true);\n\n\treturn true;\n}\n",
        "output": "1",
        "idx": 1692
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error::Error GLES2DecoderPassthroughImpl::DoBindFragmentInputLocationCHROMIUM(\n    GLuint program,\n    GLint location,\n    const char* name) {\n  NOTIMPLEMENTED();\n  return error::kNoError;\n}\n",
        "output": "0",
        "idx": 540
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  int64 host_quota() const { return host_quota_; }\n",
        "output": "0",
        "idx": 564
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "UpdateLibrary* CrosLibrary::GetUpdateLibrary() {\n  return update_lib_.GetDefaultImpl(use_stub_impl_);\n}\n",
        "output": "1",
        "idx": 662
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "INST_HANDLER (muls) {\t// MULS Rd, Rr\n\tint d = (buf[0] >> 4 & 0x0f) + 16;\n\tint r = (buf[0] & 0x0f) + 16;\n\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", r);\t// sign extension Rr\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", d);\t// sign extension Rd\n\tESIL_A (\"*,\");\t\t\t\t\t// 0: (Rd*Rr)\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/15\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n",
        "output": "0",
        "idx": 317
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "flush_signal_handlers(struct task_struct *t, int force_default)\n{\n\tint i;\n\tstruct k_sigaction *ka = &t->sighand->action[0];\n\tfor (i = _NSIG ; i != 0 ; i--) {\n \t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n \t\t\tka->sa.sa_handler = SIG_DFL;\n \t\tka->sa.sa_flags = 0;\n \t\tsigemptyset(&ka->sa.sa_mask);\n \t\tka++;\n \t}\n}\n",
        "output": "1",
        "idx": 486
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int init_nss_hash(struct crypto_instance *instance)\n{\n\tPK11SlotInfo*\thash_slot = NULL;\n\tSECItem\t\thash_param;\n\n\tif (!hash_to_nss[instance->crypto_hash_type]) {\n\t\treturn 0;\n \t}\n \n \thash_param.type = siBuffer;\n\thash_param.data = 0;\n\thash_param.len = 0;\n \n \thash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);\n \tif (hash_slot == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Unable to find security slot (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\n\tinstance->nss_sym_key_sign = PK11_ImportSymKey(hash_slot,\n\t\t\t\t\t\t       hash_to_nss[instance->crypto_hash_type],\n\t\t\t\t\t\t       PK11_OriginUnwrap, CKA_SIGN,\n\t\t\t\t\t\t       &hash_param, NULL);\n\tif (instance->nss_sym_key_sign == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Failure to import key into NSS (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\n\tPK11_FreeSlot(hash_slot);\n\n\treturn 0;\n}\n",
        "output": "1",
        "idx": 879
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t MediaPlayer::setDataSource(\n const sp<IMediaHTTPService> &httpService,\n const char *url, const KeyedVector<String8, String8> *headers)\n{\n\n     ALOGV(\"setDataSource(%s)\", url);\n     status_t err = BAD_VALUE;\n     if (url != NULL) {\n        const sp<IMediaPlayerService>& service(getMediaPlayerService());\n         if (service != 0) {\n             sp<IMediaPlayer> player(service->create(this, mAudioSessionId));\n             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||\n (NO_ERROR != player->setDataSource(httpService, url, headers))) {\n                player.clear();\n }\n            err = attachNewPlayer(player);\n }\n }\n return err;\n}\n",
        "output": "1",
        "idx": 16
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " PHP_FUNCTION(mcrypt_module_is_block_algorithm_mode)\n {\n \tMCRYPT_GET_MODE_DIR_ARGS(modes_dir)\n \tif (mcrypt_module_is_block_algorithm_mode(module, dir) == 1) {\n \t\tRETURN_TRUE;\n \t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n",
        "output": "1",
        "idx": 1831
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rar_read_ahead(struct archive_read *a, size_t min, ssize_t *avail)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  const void *h = __archive_read_ahead(a, min, avail);\n  int ret;\n  if (avail)\n  {\n    if (a->archive.read_data_is_posix_read && *avail > (ssize_t)a->archive.read_data_requested)\n      *avail = a->archive.read_data_requested;\n    if (*avail > rar->bytes_remaining)\n      *avail = (ssize_t)rar->bytes_remaining;\n    if (*avail < 0)\n      return NULL;\n     else if (*avail == 0 && rar->main_flags & MHD_VOLUME &&\n       rar->file_flags & FHD_SPLIT_AFTER)\n     {\n       ret = archive_read_format_rar_read_header(a, a->entry);\n       if (ret == (ARCHIVE_EOF))\n       {\n         rar->has_endarc_header = 1;\n         ret = archive_read_format_rar_read_header(a, a->entry);\n       }\n       if (ret != (ARCHIVE_OK))\n         return NULL;\n       return rar_read_ahead(a, min, avail);\n    }\n  }\n  return h;\n}\n",
        "output": "1",
        "idx": 271
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned int stack_maxrandom_size(void)\n {\n\tunsigned int max = 0;\n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\tmax = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;\n \t}\n \n \treturn max;\n}\n",
        "output": "1",
        "idx": 278
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void update_group_shares_cpu(struct task_group *tg, int cpu,\n\t\t\t\t    unsigned long sd_shares,\n\t\t\t\t    unsigned long sd_rq_weight,\n\t\t\t\t    unsigned long *usd_rq_weight)\n{\n\tunsigned long shares, rq_weight;\n\tint boost = 0;\n\n\trq_weight = usd_rq_weight[cpu];\n\tif (!rq_weight) {\n\t\tboost = 1;\n\t\trq_weight = NICE_0_LOAD;\n\t}\n\n\t/*\n\t *             \\Sum_j shares_j * rq_weight_i\n\t * shares_i =  -----------------------------\n\t *                  \\Sum_j rq_weight_j\n\t */\n\tshares = (sd_shares * rq_weight) / sd_rq_weight;\n\tshares = clamp_t(unsigned long, shares, MIN_SHARES, MAX_SHARES);\n\n\tif (abs(shares - tg->se[cpu]->load.weight) >\n\t\t\tsysctl_sched_shares_thresh) {\n\t\tstruct rq *rq = cpu_rq(cpu);\n\t\tunsigned long flags;\n\n\t\traw_spin_lock_irqsave(&rq->lock, flags);\n\t\ttg->cfs_rq[cpu]->rq_weight = boost ? 0 : rq_weight;\n\t\ttg->cfs_rq[cpu]->shares = boost ? 0 : shares;\n\t\t__set_se_shares(tg->se[cpu], shares);\n\t\traw_spin_unlock_irqrestore(&rq->lock, flags);\n\t}\n}\n",
        "output": "0",
        "idx": 698
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool AXNodeObject::isModal() const {\n  if (roleValue() != DialogRole && roleValue() != AlertDialogRole)\n    return false;\n \n   if (hasAttribute(aria_modalAttr)) {\n     const AtomicString& modal = getAttribute(aria_modalAttr);\n    if (equalIgnoringCase(modal, \"true\"))\n       return true;\n    if (equalIgnoringCase(modal, \"false\"))\n       return false;\n   }\n \n  if (getNode() && isHTMLDialogElement(*getNode()))\n    return toElement(getNode())->isInTopLayer();\n\n  return false;\n}\n",
        "output": "1",
        "idx": 648
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ps_sd *ps_sd_new(ps_mm *data, const char *key)\n{\n\tphp_uint32 hv, slot;\n\tps_sd *sd;\n\tint keylen;\n\n\tkeylen = strlen(key);\n\n\tsd = mm_malloc(data->mm, sizeof(ps_sd) + keylen);\n        if (!sd) {\n                TSRMLS_FETCH();\n \n               php_error_docref(NULL TSRMLS_CC, E_WARNING, \"mm_malloc failed, avail %d, err %s\", mm_available(data->mm), mm_error());\n                return NULL;\n        }\n \n\thv = ps_sd_hash(key, keylen);\n\tslot = hv & data->hash_max;\n\n\tsd->ctime = 0;\n\tsd->hv = hv;\n\tsd->data = NULL;\n\tsd->alloclen = sd->datalen = 0;\n\n\tmemcpy(sd->key, key, keylen + 1);\n\n\tsd->next = data->hash[slot];\n\tdata->hash[slot] = sd;\n\n\tdata->hash_cnt++;\n\n\tif (!sd->next) {\n\t\tif (data->hash_cnt >= data->hash_max) {\n\t\t\thash_split(data);\n\t\t}\n\t}\n\n\tps_mm_debug((\"inserting %s(%p) into slot %d\\n\", key, sd, slot));\n\n\treturn sd;\n}\n",
        "output": "1",
        "idx": 1461
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "set_pwd ()\n{\n  SHELL_VAR *temp_var, *home_var;\n  char *temp_string, *home_string;\n\n  home_var = find_variable (\"HOME\");\n  home_string = home_var ? value_cell (home_var) : (char *)NULL;\n\n  temp_var = find_variable (\"PWD\");\n  if (temp_var && imported_p (temp_var) &&\n      (temp_string = value_cell (temp_var)) &&\n      same_file (temp_string, \".\", (struct stat *)NULL, (struct stat *)NULL))\n    set_working_directory (temp_string);\n  else if (home_string && interactive_shell && login_shell &&\n\t   same_file (home_string, \".\", (struct stat *)NULL, (struct stat *)NULL))\n    {\n      set_working_directory (home_string);\n      temp_var = bind_variable (\"PWD\", home_string, 0);\n      set_auto_export (temp_var);\n    }\n  else\n    {\n      temp_string = get_working_directory (\"shell-init\");\n      if (temp_string)\n\t{\n\t  temp_var = bind_variable (\"PWD\", temp_string, 0);\n\t  set_auto_export (temp_var);\n\t  free (temp_string);\n\t}\n    }\n\n  /* According to the Single Unix Specification, v2, $OLDPWD is an\n     `environment variable' and therefore should be auto-exported.\n     Make a dummy invisible variable for OLDPWD, and mark it as exported. */\n  temp_var = bind_variable (\"OLDPWD\", (char *)NULL, 0);\n  VSETATTR (temp_var, (att_exported | att_invisible));\n}\n",
        "output": "0",
        "idx": 1050
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " bool GesturePoint::IsSecondClickInsideManhattanSquare(\n     const TouchEvent& event) const {\n   int manhattanDistance = abs(event.x() - last_tap_position_.x()) +\n                           abs(event.y() - last_tap_position_.y());\n  return manhattanDistance < kMaximumTouchMoveInPixelsForClick;\n }\n",
        "output": "1",
        "idx": 851
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  int clear_count() const { return clear_count_; }\n",
        "output": "0",
        "idx": 712
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long long BlockGroup::GetPrevTimeCode() const\n{\n    return m_prev;\n}\n",
        "output": "1",
        "idx": 1927
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void unregisterBlobURLTask(void* context)\n {\n     OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));\n    blobRegistry().unregisterBlobURL(blobRegistryContext->url);\n }\n",
        "output": "1",
        "idx": 1851
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Document::setCompatibilityMode(CompatibilityMode mode)\n{\n    if (m_compatibilityModeLocked || mode == m_compatibilityMode)\n        return;\n    bool wasInQuirksMode = inQuirksMode();\n    m_compatibilityMode = mode;\n    selectorQueryCache()->invalidate();\n    if (inQuirksMode() != wasInQuirksMode) {\n        m_styleSheetCollection->clearPageUserSheet();\n        m_styleSheetCollection->invalidateInjectedStyleSheetCache();\n    }\n}\n",
        "output": "0",
        "idx": 1664
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GBool ArthurOutputDev::beginType3Char(GfxState *state, double x, double y,\n\t\t\t\t      double dx, double dy,\n\t\t\t\t      CharCode code, Unicode *u, int uLen)\n{\n  return gFalse;\n}\n",
        "output": "0",
        "idx": 243
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " bool MediaElementAudioSourceHandler::WouldTaintOrigin() {\n  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {\n    return false;\n  }\n  if (!MediaElement()->HasSingleSecurityOrigin()) {\n    return true;\n  }\n  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());\n }\n",
        "output": "1",
        "idx": 964
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SelectionEditor::DidSplitTextNode(const Text& old_node) {\n  if (selection_.IsNone() || !old_node.isConnected()) {\n    DidFinishDOMMutation();\n    return;\n  }\n  const Position& new_base =\n      UpdatePostionAfterAdoptingTextNodeSplit(selection_.base_, old_node);\n  const Position& new_extent =\n      UpdatePostionAfterAdoptingTextNodeSplit(selection_.extent_, old_node);\n  DidFinishTextChange(new_base, new_extent);\n}\n",
        "output": "0",
        "idx": 711
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TransportDIB::TransportDIB()\n    : address_(kInvalidAddress),\n      x_shm_(0),\n      display_(NULL),\n      size_(0) {\n}\n",
        "output": "0",
        "idx": 1323
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " bool SoundPool::unload(int sampleID)\n{\n    ALOGV(\"unload: sampleID=%d\", sampleID);\n Mutex::Autolock lock(&mLock);\n return mSamples.removeItem(sampleID);\n}\n",
        "output": "0",
        "idx": 321
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  WebsiteSettings* website_settings() {\n     if (!website_settings_.get()) {\n       website_settings_.reset(new WebsiteSettings(\n           mock_ui(), profile(), tab_specific_content_settings(),\n          infobar_service(), url(), ssl(), cert_store()));\n     }\n     return website_settings_.get();\n   }\n",
        "output": "1",
        "idx": 669
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parse_error(struct filter_parse_error *pe, int err, int pos)\n{\n\tpe->lasterr = err;\n\tpe->lasterr_pos = pos;\n}\n",
        "output": "0",
        "idx": 446
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static v8::Handle<v8::Value> methodWithCallbackArgCallback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestObj.methodWithCallbackArg\");\n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     if (args.Length() <= 0 || !args[0]->IsFunction())\n         return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());\n    RefPtr<TestCallback> callback = V8TestCallback::create(args[0], getScriptExecutionContext());\n    imp->methodWithCallbackArg(callback);\n    return v8::Handle<v8::Value>();\n}\n",
        "output": "1",
        "idx": 125
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " virtual void unsetHeap(int32_t seqNum) {\n Parcel data, reply;\n        data.writeInterfaceToken(ICrypto::getInterfaceDescriptor());\n        data.writeInt32(seqNum);\n        remote()->transact(UNSET_HEAP, data, &reply);\n return;\n }\n",
        "output": "0",
        "idx": 1469
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ps_files_valid_key(const char *key)\n{\n       size_t len;\n       const char *p;\n       char c;\n       int ret = 1;\n       for (p = key; (c = *p); p++) {\n               /* valid characters are a..z,A..Z,0..9 */\n               if (!((c >= 'a' && c <= 'z')\n                               || (c >= 'A' && c <= 'Z')\n                               || (c >= '0' && c <= '9')\n                               || c == ','\n                               || c == '-')) {\n                       ret = 0;\n                       break;\n               }\n       }\n       len = p - key;\n       /* Somewhat arbitrary length limit here, but should be way more than\n          anyone needs and avoids file-level warnings later on if we exceed MAX_PATH */\n       if (len == 0 || len > 128) {\n               ret = 0;\n       }\n       return ret;\n}\n",
        "output": "1",
        "idx": 1269
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void EditorClientBlackBerry::willSetInputMethodState()\n{\n    notImplemented();\n}\n",
        "output": "0",
        "idx": 1250
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long Chapters::Atom::ParseDisplay(\n    IMkvReader* pReader,\n    long long pos,\n    long long size)\n{\n    if (!ExpandDisplaysArray())\n        return -1;\n    Display& d = m_displays[m_displays_count++];\n    d.Init();\n    return d.Parse(pReader, pos, size);\n}\n",
        "output": "1",
        "idx": 1993
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void WebGL2RenderingContextBase::deleteVertexArray(\n     WebGLVertexArrayObject* vertex_array) {\n  if (isContextLost() || !vertex_array)\n     return;\n \n   if (!vertex_array->IsDefaultObject() &&\n      vertex_array == bound_vertex_array_object_)\n    SetBoundVertexArrayObject(nullptr);\n\n  vertex_array->DeleteObject(ContextGL());\n}\n",
        "output": "1",
        "idx": 1325
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int send_event (int fd, uint16_t type, uint16_t code, int32_t value)\n{\n struct uinput_event event;\n    BTIF_TRACE_DEBUG(\"%s type:%u code:%u value:%d\", __FUNCTION__,\n        type, code, value);\n    memset(&event, 0, sizeof(event));\n    event.type  = type;\n\n     event.code  = code;\n     event.value = value;\n \n    return write(fd, &event, sizeof(event));\n }\n",
        "output": "1",
        "idx": 197
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool nested_svm_nmi(struct vcpu_svm *svm)\n{\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn true;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))\n\t\treturn true;\n\n\tsvm->vmcb->control.exit_code = SVM_EXIT_NMI;\n\tsvm->nested.exit_required = true;\n\n\treturn false;\n}\n",
        "output": "0",
        "idx": 242
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void shmem_unacct_blocks(unsigned long flags, long pages)\n{\n\tif (flags & VM_NORESERVE)\n\t\tvm_unacct_memory(pages * VM_ACCT(PAGE_CACHE_SIZE));\n}\n",
        "output": "0",
        "idx": 1000
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int WebContentsImpl::CreateOpenerRenderViewsForRenderManager(\n    SiteInstance* instance) {\n  if (!opener_)\n    return MSG_ROUTING_NONE;\n\n  return opener_->CreateOpenerRenderViews(instance);\n}\n",
        "output": "0",
        "idx": 179
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool AutocompleteEditModel::AcceptCurrentInstantPreview() {\n  return InstantController::CommitIfCurrent(controller_->GetInstant());\n}\n",
        "output": "0",
        "idx": 1388
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ipmi_destroy_user(struct ipmi_user *user)\n {\n \t_ipmi_destroy_user(user);\n \n\tcleanup_srcu_struct(&user->release_barrier);\n \tkref_put(&user->refcount, free_user);\n \n \treturn 0;\n}\n",
        "output": "1",
        "idx": 140
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WebGLRenderingContextBase::ValidateHTMLImageElement(\n    const SecurityOrigin* security_origin,\n    const char* function_name,\n    HTMLImageElement* image,\n    ExceptionState& exception_state) {\n  if (!image || !image->CachedImage()) {\n    SynthesizeGLError(GL_INVALID_VALUE, function_name, \"no image\");\n    return false;\n  }\n  const KURL& url = image->CachedImage()->GetResponse().Url();\n  if (url.IsNull() || url.IsEmpty() || !url.IsValid()) {\n    SynthesizeGLError(GL_INVALID_VALUE, function_name, \"invalid image\");\n    return false;\n   }\n \n   if (WouldTaintOrigin(image, security_origin)) {\n    exception_state.ThrowSecurityError(\"The cross-origin image at \" +\n                                       url.ElidedString() +\n                                       \" may not be loaded.\");\n     return false;\n   }\n   return true;\n}\n",
        "output": "1",
        "idx": 233
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned long nr_iowait(void)\n{\n\tunsigned long i, sum = 0;\n\n\tfor_each_possible_cpu(i)\n\t\tsum += atomic_read(&cpu_rq(i)->nr_iowait);\n\n\treturn sum;\n}\n",
        "output": "0",
        "idx": 250
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static CallInfo *growCI (lua_State *L) {\n  if (L->size_ci > LUAI_MAXCALLS)  /* overflow while handling overflow? */\n    luaD_throw(L, LUA_ERRERR);\n  else {\n    luaD_reallocCI(L, 2*L->size_ci);\n    if (L->size_ci > LUAI_MAXCALLS)\n      luaG_runerror(L, \"stack overflow\");\n  }\n  return ++L->ci;\n}\n",
        "output": "0",
        "idx": 1438
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool cmd_ibm_sense_condition(IDEState *s, uint8_t cmd)\n{\n    switch (s->feature) {\n    case 0x01:  /* sense temperature in device */\n        s->nsector = 0x50;      /* +20 C */\n        break;\n    default:\n        ide_abort_command(s);\n        return true;\n    }\n\n    return true;\n}\n",
        "output": "0",
        "idx": 606
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RenderWidgetHostViewAndroid::RenderWidgetHostViewAndroid(\n    RenderWidgetHostImpl* widget_host,\n    ContentViewCoreImpl* content_view_core)\n    : host_(widget_host),\n      is_layer_attached_(true),\n       content_view_core_(NULL),\n       ime_adapter_android_(ALLOW_THIS_IN_INITIALIZER_LIST(this)),\n       cached_background_color_(SK_ColorWHITE),\n      texture_id_in_layer_(0) {\n   if (CompositorImpl::UsesDirectGL()) {\n     surface_texture_transport_.reset(new SurfaceTextureTransportClient());\n     layer_ = surface_texture_transport_->Initialize();\n  } else {\n    texture_layer_ = cc::TextureLayer::create(0);\n    layer_ = texture_layer_;\n  }\n\n  layer_->setContentsOpaque(true);\n  layer_->setIsDrawable(true);\n\n  host_->SetView(this);\n  SetContentViewCore(content_view_core);\n}\n",
        "output": "1",
        "idx": 1247
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __net_init nfnetlink_net_init(struct net *net)\n{\n\tstruct sock *nfnl;\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.groups\t= NFNLGRP_MAX,\n\t\t.input\t= nfnetlink_rcv,\n#ifdef CONFIG_MODULES\n\t\t.bind\t= nfnetlink_bind,\n#endif\n\t};\n\n\tnfnl = netlink_kernel_create(net, NETLINK_NETFILTER, &cfg);\n\tif (!nfnl)\n\t\treturn -ENOMEM;\n\tnet->nfnl_stash = nfnl;\n\trcu_assign_pointer(net->nfnl, nfnl);\n\treturn 0;\n}\n",
        "output": "0",
        "idx": 853
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " monitor_init(void)\n {\n\tstruct ssh *ssh = active_state;\t\t\t/* XXX */\n \tstruct monitor *mon;\n \n \tmon = xcalloc(1, sizeof(*mon));\n \tmonitor_openfds(mon, 1);\n \n\t/* Used to share zlib space across processes */\n\tif (options.compression) {\n\t\tmon->m_zback = mm_create(NULL, MM_MEMSIZE);\n\t\tmon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);\n\t\t/* Compression needs to share state across borders */\n\t\tssh_packet_set_compress_hooks(ssh, mon->m_zlib,\n\t\t    (ssh_packet_comp_alloc_func *)mm_zalloc,\n\t\t    (ssh_packet_comp_free_func *)mm_zfree);\n\t}\n \treturn mon;\n }\n",
        "output": "1",
        "idx": 1182
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GfxPatternColorSpace::getRGB(GfxColor *color, GfxRGB *rgb) {\n  rgb->r = rgb->g = rgb->b = 0;\n}\n",
        "output": "0",
        "idx": 798
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "     ~OffScreenRootWindow()\n     {\n         if (!--refCount) {\n#if PLATFORM(QT)\n            delete window;\n            window = 0;\n#elif PLATFORM(EFL)\n             XUnmapWindow(display, window);\n             XDestroyWindow(display, window);\n#endif\n         }\n     }\n",
        "output": "1",
        "idx": 1415
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fbCombineConjointOutPart (CARD8 a, CARD8 b)\n{\n    /* max (1-b/a,0) */\n    /* = 1-min(b/a,1) */\n\n    /* min (1, (1-b) / a) */\n\n    if (b >= a)\t\t    /* b >= a -> b/a >= 1 */\n\treturn 0x00;\t    /* 0 */\n    return ~FbIntDiv(b,a);   /* 1 - b/a */\n}\n",
        "output": "0",
        "idx": 1353
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t ReadBlobBlock(Image *image,unsigned char *data)\n{\n  ssize_t\n    count;\n\n  unsigned char\n    block_count;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(data != (unsigned char *) NULL);\n  count=ReadBlob(image,1,&block_count);\n  if (count != 1)\n    return(0);\n  count=ReadBlob(image,(size_t) block_count,data);\n  if (count != (ssize_t) block_count)\n    return(0);\n  return(count);\n}\n",
        "output": "0",
        "idx": 1879
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebPage::loadString(const BlackBerry::Platform::String& string, const BlackBerry::Platform::String& baseURL, const BlackBerry::Platform::String& mimeType, const BlackBerry::Platform::String& failingURL)\n{\n    d->loadString(string, baseURL, mimeType, failingURL);\n}\n",
        "output": "0",
        "idx": 218
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mrb_class_get_under(mrb_state *mrb, struct RClass *outer, const char *name)\n{\n  return class_from_sym(mrb, outer, mrb_intern_cstr(mrb, name));\n}\n",
        "output": "0",
        "idx": 2015
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " bool IsSiteMuted(const TabStripModel& tab_strip, const int index) {\n   content::WebContents* web_contents = tab_strip.GetWebContentsAt(index);\n   GURL url = web_contents->GetLastCommittedURL();\n \n  if (url.SchemeIs(content::kChromeUIScheme)) {\n    return web_contents->IsAudioMuted() &&\n           GetTabAudioMutedReason(web_contents) ==\n               TabMutedReason::CONTENT_SETTING_CHROME;\n  }\n\n  Profile* profile =\n      Profile::FromBrowserContext(web_contents->GetBrowserContext());\n  HostContentSettingsMap* settings =\n      HostContentSettingsMapFactory::GetForProfile(profile);\n  return settings->GetContentSetting(url, url, CONTENT_SETTINGS_TYPE_SOUND,\n                                     std::string()) == CONTENT_SETTING_BLOCK;\n}\n",
        "output": "1",
        "idx": 434
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t DRMSource::start(MetaData *params) {\n int32_t val;\n if (params && params->findInt32(kKeyWantsNALFragments, &val)\n && val != 0) {\n        mWantsNALFragments = true;\n } else {\n        mWantsNALFragments = false;\n }\n\n return mOriginalMediaSource->start(params);\n}\n",
        "output": "0",
        "idx": 2049
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void callWithScriptStateExecutionContextVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    ScriptState* currentState = ScriptState::current();\n    if (!currentState)\n        return;\n    ScriptState& state = *currentState;\n    ExecutionContext* scriptContext = currentExecutionContext(info.GetIsolate());\n    imp->callWithScriptStateExecutionContextVoidMethod(&state, scriptContext);\n    if (state.hadException()) {\n        v8::Local<v8::Value> exception = state.exception();\n        state.clearException();\n        throwError(exception, info.GetIsolate());\n        return;\n    }\n}\n",
        "output": "0",
        "idx": 1422
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GLSurfaceOzoneSurfacelessSurfaceImpl::Destroy() {\n  if (!context_)\n    return;\n  scoped_refptr<gfx::GLContext> previous_context = gfx::GLContext::GetCurrent();\n  scoped_refptr<gfx::GLSurface> previous_surface;\n\n  bool was_current = previous_context && previous_context->IsCurrent(nullptr) &&\n                     gfx::GLSurface::GetCurrent() == this;\n  if (!was_current) {\n    previous_surface = gfx::GLSurface::GetCurrent();\n    context_->MakeCurrent(this);\n  }\n\n  glBindFramebufferEXT(GL_FRAMEBUFFER, 0);\n  if (fbo_) {\n    glDeleteTextures(arraysize(textures_), textures_);\n    for (auto& texture : textures_)\n      texture = 0;\n    glDeleteFramebuffersEXT(1, &fbo_);\n    fbo_ = 0;\n  }\n  for (auto image : images_) {\n    if (image)\n      image->Destroy(true);\n   }\n \n   if (!was_current) {\n    previous_context->MakeCurrent(previous_surface.get());\n  } else {\n    context_->ReleaseCurrent(this);\n   }\n }\n",
        "output": "1",
        "idx": 213
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool RenderFrameHostManager::IsRendererTransferNeededForNavigation(\n    RenderFrameHostImpl* rfh,\n    const GURL& dest_url) {\n  if (!rfh->GetSiteInstance()->HasSite())\n    return false;\n\n  if (rfh->GetSiteInstance()->GetSiteURL().SchemeIs(kGuestScheme))\n    return false;\n\n  BrowserContext* context = rfh->GetSiteInstance()->GetBrowserContext();\n  if (IsCurrentlySameSite(rfh, dest_url)) {\n    return false;\n  }\n\n  if (rfh->GetSiteInstance()->RequiresDedicatedProcess() ||\n      SiteInstanceImpl::DoesSiteRequireDedicatedProcess(context,\n                                                        dest_url)) {\n    return true;\n  }\n\n  if (SiteIsolationPolicy::IsTopDocumentIsolationEnabled() &&\n      (!frame_tree_node_->IsMainFrame() ||\n       rfh->GetSiteInstance()->IsDefaultSubframeSiteInstance())) {\n    return true;\n  }\n\n  return false;\n}\n",
        "output": "0",
        "idx": 907
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Block::IsInvisible() const\n{\n    return bool(int(m_flags & 0x08) != 0);\n }\n",
        "output": "1",
        "idx": 1711
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PP_InputEvent_Type ConvertEventTypes(WebInputEvent::Type wetype) {\n  switch (wetype) {\n    case WebInputEvent::MouseDown:\n      return PP_INPUTEVENT_TYPE_MOUSEDOWN;\n    case WebInputEvent::MouseUp:\n      return PP_INPUTEVENT_TYPE_MOUSEUP;\n    case WebInputEvent::MouseMove:\n      return PP_INPUTEVENT_TYPE_MOUSEMOVE;\n    case WebInputEvent::MouseEnter:\n       return PP_INPUTEVENT_TYPE_MOUSEENTER;\n     case WebInputEvent::MouseLeave:\n       return PP_INPUTEVENT_TYPE_MOUSELEAVE;\n     case WebInputEvent::MouseWheel:\n       return PP_INPUTEVENT_TYPE_MOUSEWHEEL;\n     case WebInputEvent::RawKeyDown:\n      return PP_INPUTEVENT_TYPE_RAWKEYDOWN;\n    case WebInputEvent::KeyDown:\n      return PP_INPUTEVENT_TYPE_KEYDOWN;\n    case WebInputEvent::KeyUp:\n      return PP_INPUTEVENT_TYPE_KEYUP;\n    case WebInputEvent::Char:\n      return PP_INPUTEVENT_TYPE_CHAR;\n    case WebInputEvent::Undefined:\n    default:\n      return PP_INPUTEVENT_TYPE_UNDEFINED;\n  }\n}\n",
        "output": "1",
        "idx": 107
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CuePoint::TrackPosition::Parse(IMkvReader* pReader, long long start_,\n                                     long long size_) {\n   const long long stop = start_ + size_;\n   long long pos = start_;\n\n  m_track = -1;\n  m_pos = -1;\n  m_block = 1; // default\n\n\n   while (pos < stop) {\n     long len;\n \n    const long long id = ReadUInt(pReader, pos, len);\n    assert(id >= 0);  // TODO\n    assert((pos + len) <= stop);\n \n     pos += len;  // consume ID\n \n     const long long size = ReadUInt(pReader, pos, len);\n    assert(size >= 0);\n    assert((pos + len) <= stop);\n \n     pos += len;  // consume Size field\n    assert((pos + size) <= stop);\n \n     if (id == 0x77)  // CueTrack ID\n       m_track = UnserializeUInt(pReader, pos, size);\n\n else if (id == 0x71) // CueClusterPos ID\n      m_pos = UnserializeUInt(pReader, pos, size);\n\n else if (id == 0x1378) // CueBlockNumber\n\n       m_block = UnserializeUInt(pReader, pos, size);\n \n     pos += size;  // consume payload\n    assert(pos <= stop);\n   }\n \n  assert(m_pos >= 0);\n  assert(m_track > 0);\n }\n",
        "output": "1",
        "idx": 2033
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " std::string GetUploadData(const std::string& brand) {\n   DCHECK(!brand.empty());\n  std::string data(kPostXml);\n  const std::string placeholder(\"__BRANDCODE_PLACEHOLDER__\");\n  size_t placeholder_pos = data.find(placeholder);\n  DCHECK(placeholder_pos != std::string::npos);\n  data.replace(placeholder_pos, placeholder.size(), brand);\n  return data;\n }\n",
        "output": "1",
        "idx": 1944
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PanoramiXRenderSetPictureClipRectangles(ClientPtr client)\n{\n    REQUEST(xRenderSetPictureClipRectanglesReq);\n    int result = Success, j;\n    PanoramiXRes *pict;\n\n    REQUEST_AT_LEAST_SIZE(xRenderSetPictureClipRectanglesReq);\n\n    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);\n\n    FOR_NSCREENS_BACKWARD(j) {\n        stuff->picture = pict->info[j].id;\n        result =\n            (*PanoramiXSaveRenderVector[X_RenderSetPictureClipRectangles])\n            (client);\n        if (result != Success)\n            break;\n    }\n\n    return result;\n}\n",
        "output": "0",
        "idx": 2018
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FrameSelection::MoveRangeSelection(const VisiblePosition& base_position,\n                                        const VisiblePosition& extent_position,\n                                        TextGranularity granularity) {\n  SelectionInDOMTree new_selection =\n      SelectionInDOMTree::Builder()\n           .SetBaseAndExtentDeprecated(base_position.DeepEquivalent(),\n                                       extent_position.DeepEquivalent())\n           .SetAffinity(base_position.Affinity())\n          .SetIsHandleVisible(IsHandleVisible())\n           .Build();\n \n   if (new_selection.IsNone())\n    return;\n\n  const VisibleSelection& visible_selection =\n      CreateVisibleSelectionWithGranularity(new_selection, granularity);\n  if (visible_selection.IsNone())\n    return;\n\n  SelectionInDOMTree::Builder builder;\n  if (visible_selection.IsBaseFirst()) {\n    builder.SetBaseAndExtent(visible_selection.Start(),\n                             visible_selection.End());\n  } else {\n    builder.SetBaseAndExtent(visible_selection.End(),\n                              visible_selection.Start());\n   }\n   builder.SetAffinity(visible_selection.Affinity());\n  builder.SetIsHandleVisible(IsHandleVisible());\n   SetSelection(builder.Build(), SetSelectionData::Builder()\n                                     .SetShouldCloseTyping(true)\n                                     .SetShouldClearTypingStyle(true)\n                                     .SetGranularity(granularity)\n                                     .Build());\n }\n",
        "output": "1",
        "idx": 915
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cifs_sb_master_tlink(struct cifs_sb_info *cifs_sb)\n{\n\treturn cifs_sb->master_tlink;\n}\n",
        "output": "0",
        "idx": 1848
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int set_file_offset(stb_vorbis *f, unsigned int loc)\n{\n   #ifndef STB_VORBIS_NO_PUSHDATA_API\n   if (f->push_mode) return 0;\n   #endif\n   f->eof = 0;\n   if (USE_MEMORY(f)) {\n      if (f->stream_start + loc >= f->stream_end || f->stream_start + loc < f->stream_start) {\n         f->stream = f->stream_end;\n         f->eof = 1;\n         return 0;\n      } else {\n         f->stream = f->stream_start + loc;\n         return 1;\n      }\n   }\n   #ifndef STB_VORBIS_NO_STDIO\n   if (loc + f->f_start < loc || loc >= 0x80000000) {\n      loc = 0x7fffffff;\n      f->eof = 1;\n   } else {\n      loc += f->f_start;\n   }\n   if (!fseek(f->f, loc, SEEK_SET))\n      return 1;\n   f->eof = 1;\n   fseek(f->f, f->f_start, SEEK_END);\n   return 0;\n   #endif\n}\n",
        "output": "0",
        "idx": 802
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)\n{\n\tsapi_header_line ctr = {0};\n\tint r;\n\t\n\tctr.line = header_line;\n\tctr.line_len = header_line_len;\n\n\tr = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,\n\t\t\t&ctr TSRMLS_CC);\n\n\tif (!duplicate)\n\t\tefree(header_line);\n\n\treturn r;\n}\n",
        "output": "0",
        "idx": 1930
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TabStripGtk::TabDetachedAt(TabContents* contents, int index) {\n   GenerateIdealBounds();\n  StartRemoveTabAnimation(index, contents->web_contents());\n  GetTabAt(index)->set_closing(true);\n}\n",
        "output": "1",
        "idx": 2001
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(imagesetstyle)\n{\n\tzval *IM, *styles;\n\tgdImagePtr im;\n\tint * stylearr;\n\tint index;\n\tHashPosition pos;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ra\", &IM, &styles) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\t/* copy the style values in the stylearr */\n\tstylearr = safe_emalloc(sizeof(int), zend_hash_num_elements(HASH_OF(styles)), 0);\n\n\tzend_hash_internal_pointer_reset_ex(HASH_OF(styles), &pos);\n\n\tfor (index = 0;; zend_hash_move_forward_ex(HASH_OF(styles), &pos))\t{\n\t\tzval ** item;\n\n\t\tif (zend_hash_get_current_data_ex(HASH_OF(styles), (void **) &item, &pos) == FAILURE) {\n \t\t\tbreak;\n \t\t}\n \n\t\tconvert_to_long_ex(item);\n\t\tstylearr[index++] = Z_LVAL_PP(item);\n \t}\n \n \tgdImageSetStyle(im, stylearr, index);\n\n\tefree(stylearr);\n\n\tRETURN_TRUE;\n}\n",
        "output": "1",
        "idx": 235
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void detach_task(struct task_struct *p, struct lb_env *env)\n{\n\tlockdep_assert_held(&env->src_rq->lock);\n\n\tp->on_rq = TASK_ON_RQ_MIGRATING;\n\tdeactivate_task(env->src_rq, p, DEQUEUE_NOCLOCK);\n\tset_task_cpu(p, env->dst_cpu);\n}\n",
        "output": "0",
        "idx": 864
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen)\n{\n  char *s = NULL;\n  const char *p = mailbox;\n\n  for (s = dest; p && *p && dlen; dlen--)\n  {\n    if (*p == idata->delim)\n    {\n      *s = '/';\n      /* simple way to avoid collisions with UIDs */\n      if (*(p + 1) >= '0' && *(p + 1) <= '9')\n      {\n        if (--dlen)\n          *++s = '_';\n      }\n    }\n    else\n      *s = *p;\n    p++;\n    s++;\n  }\n  *s = '\\0';\n}\n",
        "output": "0",
        "idx": 2023
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BackendImpl::CleanupCache() {\n  DCHECK(background_queue_.BackgroundIsCurrentSequence());\n  Trace(\"Backend Cleanup\");\n  eviction_.Stop();\n  timer_.reset();\n\n  if (init_) {\n    StoreStats();\n    if (data_)\n      data_->header.crash = 0;\n\n    if (user_flags_ & kNoRandom) {\n      File::WaitForPendingIO(&num_pending_io_);\n      DCHECK(!num_refs_);\n    } else {\n      File::DropPendingIO();\n    }\n  }\n  block_files_.CloseFiles();\n  FlushIndex();\n  index_ = NULL;\n  ptr_factory_.InvalidateWeakPtrs();\n  done_.Signal();\n}\n",
        "output": "0",
        "idx": 202
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool is_ereg(u32 reg)\n{\n\treturn (1 << reg) & (BIT(BPF_REG_5) |\n\t\t\t     BIT(AUX_REG) |\n\t\t\t     BIT(BPF_REG_7) |\n\t\t\t     BIT(BPF_REG_8) |\n\t\t\t     BIT(BPF_REG_9));\n}\n",
        "output": "0",
        "idx": 249
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool RendererPermissionsPolicyDelegate::IsRestrictedUrl(\n    const GURL& document_url,\n    std::string* error) {\n  if (dispatcher_->IsExtensionActive(kWebStoreAppId)) {\n    if (error)\n      *error = errors::kCannotScriptGallery;\n     return true;\n   }\n \n  if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) {\n     if (error)\n       *error = errors::kCannotScriptNtp;\n     return true;\n  }\n\n  return false;\n}\n",
        "output": "1",
        "idx": 1390
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs4_open_confirm_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\n\t/* If this request hasn't been cancelled, do nothing */\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\t/* In case of error, no cleanup! */\n\tif (!data->rpc_done)\n \t\tgoto out_free;\n \tstate = nfs4_opendata_to_nfs4_state(data);\n \tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.open_flags);\n out_free:\n \tnfs4_opendata_put(data);\n }\n",
        "output": "1",
        "idx": 25
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool GLES2DecoderImpl::DoIsProgram(GLuint client_id) {\n  const ProgramManager::ProgramInfo* program = GetProgramInfo(client_id);\n  return program != NULL && !program->IsDeleted();\n}\n",
        "output": "0",
        "idx": 494
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ChromeClientImpl::AttachRootGraphicsLayer(GraphicsLayer* root_layer,\n                                               LocalFrame* local_frame) {\n  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV2Enabled());\n  WebLocalFrameImpl* web_frame =\n      WebLocalFrameImpl::FromFrame(local_frame)->LocalRoot();\n\n  DCHECK(web_frame->FrameWidget() || !root_layer);\n  if (web_frame->FrameWidget())\n    web_frame->FrameWidget()->SetRootGraphicsLayer(root_layer);\n}\n",
        "output": "0",
        "idx": 1625
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mp_encode_lua_table_as_map(lua_State *L, mp_buf *buf, int level) {\n    size_t len = 0;\n\n    /* First step: count keys into table. No other way to do it with the\n      * Lua API, we need to iterate a first time. Note that an alternative\n      * would be to do a single run, and then hack the buffer to insert the\n      * map opcodes for message pack. Too hackish for this lib. */\n     lua_pushnil(L);\n     while(lua_next(L,-2)) {\n         lua_pop(L,1); /* remove value, keep key for next iteration. */\n        len++;\n    }\n\n    /* Step two: actually encoding of the map. */\n    mp_encode_map(L,buf,len);\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        /* Stack: ... key value */\n        lua_pushvalue(L,-2); /* Stack: ... key value key */\n        mp_encode_lua_type(L,buf,level+1); /* encode key */\n        mp_encode_lua_type(L,buf,level+1); /* encode val */\n    }\n}\n",
        "output": "1",
        "idx": 396
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "LayoutBlockFlow::~LayoutBlockFlow()\n{\n}\n",
        "output": "0",
        "idx": 262
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  DEFINE_INLINE_TRACE() { visitor->trace(arrayBuffer); }\n",
        "output": "0",
        "idx": 2061
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\n {\n \tns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;\n \tshm_rmid(ns, shp);\n \tshm_unlock(shp);\n\tif (!is_file_hugepages(shp->shm_file))\n\t\tshmem_lock(shp->shm_file, 0, shp->mlock_user);\n \telse if (shp->mlock_user)\n\t\tuser_shm_unlock(file_inode(shp->shm_file)->i_size,\n\t\t\t\t\t\tshp->mlock_user);\n\tfput (shp->shm_file);\n \tipc_rcu_putref(shp, shm_rcu_free);\n }\n",
        "output": "1",
        "idx": 158
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   void RemoveClientSession() {\n    context_.network_message_loop()->PostTask(\n        FROM_HERE, base::Bind(\n            &ClientSession::OnConnectionClosed, client_, connection_));\n   }\n",
        "output": "1",
        "idx": 1518
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool AXNodeObject::isMenu() const {\n  return roleValue() == MenuRole;\n}\n",
        "output": "0",
        "idx": 630
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ExtensionPrefs* ExtensionService::extension_prefs() {\n  return extension_prefs_;\n}\n",
        "output": "0",
        "idx": 1243
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " status_t SampleTable::setTimeToSampleParams(\n         off64_t data_offset, size_t data_size) {\n    if (!mTimeToSample.empty() || data_size < 8) {\n         return ERROR_MALFORMED;\n     }\n \n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n\n    mTimeToSampleCount = U32_AT(&header[4]);\n if ((uint64_t)mTimeToSampleCount >\n (uint64_t)UINT32_MAX / (2 * sizeof(uint32_t))) {\n        ALOGE(\"  Error: Time-to-sample table size too large.\");\n\n return ERROR_OUT_OF_RANGE;\n }\n\n if (!mDataSource->getVector(data_offset + 8, &mTimeToSample,\n                                mTimeToSampleCount * 2)) {\n        ALOGE(\"  Error: Incomplete data read for time-to-sample table.\");\n return ERROR_IO;\n }\n\n\n     for (size_t i = 0; i < mTimeToSample.size(); ++i) {\n         mTimeToSample.editItemAt(i) = ntohl(mTimeToSample[i]);\n     }\n     return OK;\n }\n",
        "output": "1",
        "idx": 939
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vrrp_state_handler(vector_t *strvec)\n{\n\tchar *str = strvec_slot(strvec, 1);\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tif (!strcmp(str, \"MASTER\"))\n\t\tvrrp->wantstate = VRRP_STATE_MAST;\n\telse if (!strcmp(str, \"BACKUP\"))\n\t{\n\t\tif (vrrp->wantstate == VRRP_STATE_MAST)\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) state previously set as MASTER - ignoring BACKUP\", vrrp->iname);\n\t\telse\n\t\t\tvrrp->wantstate = VRRP_STATE_BACK;\n\t}\n\telse {\n\t\treport_config_error(CONFIG_GENERAL_ERROR,\"(%s) unknown state '%s', defaulting to BACKUP\", vrrp->iname, str);\n\t\tvrrp->wantstate = VRRP_STATE_BACK;\n\t}\n}\n",
        "output": "0",
        "idx": 358
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __follow_pte(struct mm_struct *mm, unsigned long address,\n\t\tpte_t **ptepp, spinlock_t **ptlp)\n{\n\tpgd_t *pgd;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *ptep;\n\n\tpgd = pgd_offset(mm, address);\n\tif (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))\n\t\tgoto out;\n\n\tpud = pud_offset(pgd, address);\n\tif (pud_none(*pud) || unlikely(pud_bad(*pud)))\n\t\tgoto out;\n\n\tpmd = pmd_offset(pud, address);\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tif (pmd_none(*pmd) || unlikely(pmd_bad(*pmd)))\n\t\tgoto out;\n\n\t/* We cannot handle huge page PFN maps. Luckily they don't exist. */\n\tif (pmd_huge(*pmd))\n\t\tgoto out;\n\n\tptep = pte_offset_map_lock(mm, pmd, address, ptlp);\n\tif (!ptep)\n\t\tgoto out;\n\tif (!pte_present(*ptep))\n\t\tgoto unlock;\n\t*ptepp = ptep;\n\treturn 0;\nunlock:\n\tpte_unmap_unlock(ptep, *ptlp);\nout:\n\treturn -EINVAL;\n}\n",
        "output": "0",
        "idx": 986
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void reflectUnsignedShortAttributeAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMSetter\");\n    CustomElementCallbackDispatcher::CallbackDeliveryScope deliveryScope;\n    TestObjectPythonV8Internal::reflectUnsignedShortAttributeAttributeSetter(jsValue, info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "output": "0",
        "idx": 574
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xfrm_exp_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\tstruct net *net = xp_net(xp);\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_polexpire_msgsize(xp), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_polexpire(skb, xp, dir, c) < 0)\n\t\tBUG();\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_EXPIRE);\n}\n",
        "output": "0",
        "idx": 970
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameHostImpl::OnJavaScriptExecuteResponse(\n    int id, const base::ListValue& result) {\n  const base::Value* result_value;\n  if (!result.Get(0, &result_value)) {\n    NOTREACHED() << \"Got bad arguments for OnJavaScriptExecuteResponse\";\n    return;\n  }\n\n  auto it = javascript_callbacks_.find(id);\n  if (it != javascript_callbacks_.end()) {\n    it->second.Run(result_value);\n    javascript_callbacks_.erase(it);\n  } else {\n    NOTREACHED() << \"Received script response for unknown request\";\n  }\n}\n",
        "output": "0",
        "idx": 441
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dcbnl_getstate(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t  u32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\t/* if (!tb[DCB_ATTR_STATE] || !netdev->dcbnl_ops->getstate) */\n\tif (!netdev->dcbnl_ops->getstate)\n\t\treturn -EOPNOTSUPP;\n\n\treturn nla_put_u8(skb, DCB_ATTR_STATE,\n\t\t\t  netdev->dcbnl_ops->getstate(netdev));\n}\n",
        "output": "0",
        "idx": 2020
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kvm_update_dr0123(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\n\tif (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)) {\n\t\tfor (i = 0; i < KVM_NR_DB_REGS; i++)\n\t\t\tvcpu->arch.eff_db[i] = vcpu->arch.db[i];\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_RELOAD;\n\t}\n}\n",
        "output": "0",
        "idx": 2090
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline bool SearchBuffer::isBadMatch(const UChar* match, size_t matchLength) const\n{\n    if (!m_targetRequiresKanaWorkaround)\n        return false;\n\n    normalizeCharacters(match, matchLength, m_normalizedMatch);\n\n    const UChar* a = m_normalizedTarget.begin();\n    const UChar* aEnd = m_normalizedTarget.end();\n\n    const UChar* b = m_normalizedMatch.begin();\n    const UChar* bEnd = m_normalizedMatch.end();\n\n    while (true) {\n        while (a != aEnd && !isKanaLetter(*a))\n            ++a;\n        while (b != bEnd && !isKanaLetter(*b))\n            ++b;\n\n        if (a == aEnd || b == bEnd) {\n            ASSERT(a == aEnd);\n            ASSERT(b == bEnd);\n            return false;\n        }\n\n        if (isSmallKanaLetter(*a) != isSmallKanaLetter(*b))\n            return true;\n        if (composedVoicedSoundMark(*a) != composedVoicedSoundMark(*b))\n            return true;\n        ++a;\n        ++b;\n\n        while (1) {\n            if (!(a != aEnd && isCombiningVoicedSoundMark(*a))) {\n                if (b != bEnd && isCombiningVoicedSoundMark(*b))\n                    return true;\n                break;\n            }\n            if (!(b != bEnd && isCombiningVoicedSoundMark(*b)))\n                return true;\n            if (*a != *b)\n                return true;\n            ++a;\n            ++b;\n        }\n    }\n}\n",
        "output": "0",
        "idx": 1991
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  views::ImageButton* close_button() const {\n    return media_controls_view_->close_button_;\n  }\n",
        "output": "1",
        "idx": 171
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebGraphicsContext3DCommandBufferImpl::OnMemoryAllocationChanged(\n    const GpuMemoryAllocation& allocation) {\n  if (memory_allocation_changed_callback_)\n    memory_allocation_changed_callback_->onMemoryAllocationChanged(\n        allocation.gpu_resource_size_in_bytes);\n}\n",
        "output": "0",
        "idx": 351
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int GetSystemMetricsInDIP(int metric) {\n  return static_cast<int>(GetSystemMetrics(metric) /\n      GetDeviceScaleFactor() + 0.5);\n}\n",
        "output": "0",
        "idx": 1224
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void PrintWebViewHelper::OnPrintForSystemDialog() {\n   blink::WebLocalFrame* frame = print_preview_context_.source_frame();\n   if (!frame) {\n     NOTREACHED();\n    return;\n  }\n  Print(frame, print_preview_context_.source_node(), false);\n}\n",
        "output": "1",
        "idx": 385
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void WaitForCopySourceReady() {\n    while (!GetRenderWidgetHostViewPort()->IsSurfaceAvailableForCopy())\n      GiveItSomeTime();\n  }\n",
        "output": "0",
        "idx": 1172
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Vp9Parser::ReadSegmentationMap() {\n   for (size_t i = 0; i < Vp9Segmentation::kNumTreeProbs; i++) {\n    segmentation_.tree_probs[i] =\n         reader_.ReadBool() ? reader_.ReadLiteral(8) : kVp9MaxProb;\n   }\n \n   for (size_t i = 0; i < Vp9Segmentation::kNumPredictionProbs; i++)\n    segmentation_.pred_probs[i] = kVp9MaxProb;\n \n  segmentation_.temporal_update = reader_.ReadBool();\n  if (segmentation_.temporal_update) {\n     for (size_t i = 0; i < Vp9Segmentation::kNumPredictionProbs; i++) {\n       if (reader_.ReadBool())\n        segmentation_.pred_probs[i] = reader_.ReadLiteral(8);\n     }\n   }\n }\n",
        "output": "1",
        "idx": 637
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int nfs4_lock_type(struct file_lock *fl, int block)\n{\n\tif ((fl->fl_type & (F_RDLCK|F_WRLCK|F_UNLCK)) == F_RDLCK)\n\t\treturn block ? NFS4_READW_LT : NFS4_READ_LT;\n\treturn block ? NFS4_WRITEW_LT : NFS4_WRITE_LT;\n}\n",
        "output": "0",
        "idx": 653
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void display_motd() {\n\tFILE *fp;\n\tint c;\n\n\tif ((fp = fopen(\"/etc/motd\", \"r\"))) {\n\t\twhile ((c = getc(fp)) != EOF) {\n\t\t\tputchar(c);\n\t\t}\n\t\tfclose(fp);\n\t}\n}\n",
        "output": "0",
        "idx": 248
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool SiteInstanceImpl::ShouldLockToOrigin(BrowserContext* browser_context,\n                                          GURL site_url) {\n  if (RenderProcessHost::run_renderer_in_process())\n    return false;\n\n  if (!DoesSiteRequireDedicatedProcess(browser_context, site_url))\n    return false;\n\n   if (site_url.SchemeIs(content::kGuestScheme))\n     return false;\n \n  if (site_url.SchemeIs(content::kChromeUIScheme))\n    return false;\n  if (!GetContentClient()->browser()->ShouldLockToOrigin(browser_context,\n                                                         site_url)) {\n    return false;\n  }\n\n  return true;\n}\n",
        "output": "1",
        "idx": 300
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t SampleTable::setCompositionTimeToSampleParams(\n off64_t data_offset, size_t data_size) {\n    ALOGI(\"There are reordered frames present.\");\n\n if (mCompositionTimeDeltaEntries != NULL || data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header))\n < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n\n size_t numEntries = U32_AT(&header[4]);\n\n if (data_size != (numEntries + 1) * 8) {\n return ERROR_MALFORMED;\n\n     }\n \n     mNumCompositionTimeDeltaEntries = numEntries;\n     mCompositionTimeDeltaEntries = new uint32_t[2 * numEntries];\n \n     if (mDataSource->readAt(\n                data_offset + 8, mCompositionTimeDeltaEntries, numEntries * 8)\n < (ssize_t)numEntries * 8) {\n delete[] mCompositionTimeDeltaEntries;\n        mCompositionTimeDeltaEntries = NULL;\n\n return ERROR_IO;\n }\n\n for (size_t i = 0; i < 2 * numEntries; ++i) {\n        mCompositionTimeDeltaEntries[i] = ntohl(mCompositionTimeDeltaEntries[i]);\n }\n\n    mCompositionDeltaLookup->setEntries(\n            mCompositionTimeDeltaEntries, mNumCompositionTimeDeltaEntries);\n\n return OK;\n}\n",
        "output": "1",
        "idx": 1441
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Tab::OnMouseReleased(const ui::MouseEvent& event) {\n  controller_->OnMouseEventInTab(this, event);\n\n  if (controller_->EndDrag(END_DRAG_COMPLETE))\n    return;\n\n  if (event.IsMiddleMouseButton()) {\n    if (HitTestPoint(event.location())) {\n      controller_->CloseTab(this, CLOSE_TAB_FROM_MOUSE);\n    } else if (closing_) {\n      gfx::Point location_in_parent = event.location();\n      ConvertPointToTarget(this, parent(), &location_in_parent);\n      Tab* closest_tab = controller_->GetTabAt(location_in_parent);\n      if (closest_tab)\n        controller_->CloseTab(closest_tab, CLOSE_TAB_FROM_MOUSE);\n    }\n  } else if (event.IsOnlyLeftMouseButton() && !event.IsShiftDown() &&\n             !IsSelectionModifierDown(event)) {\n    controller_->SelectTab(this, event);\n  }\n}\n",
        "output": "0",
        "idx": 1559
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void skcipher_release(void *private)\n {\n\tcrypto_free_skcipher(private);\n }\n",
        "output": "1",
        "idx": 1982
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " Blob::Blob(PassOwnPtr<BlobData> blobData, long long size)\n    : m_type(blobData->contentType())\n    , m_size(size)\n{\n    ASSERT(blobData);\n    ScriptWrappable::init(this);\n \n     m_internalURL = BlobURL::createInternalURL();\n    ThreadableBlobRegistry::registerBlobURL(m_internalURL, blobData);\n }\n",
        "output": "1",
        "idx": 562
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void srpt_cm_rep_error(struct ib_cm_id *cm_id)\n{\n\tpr_info(\"Received IB REP error for cm_id %p.\\n\", cm_id);\n\tsrpt_drain_channel(cm_id);\n}\n",
        "output": "0",
        "idx": 215
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IPC::PlatformFileForTransit ProxyChannelDelegate::ShareHandleWithRemote(\n    base::PlatformFile handle,\n    const IPC::SyncChannel& channel,\n    bool should_close_source) {\n  return content::BrokerGetFileHandleForProcess(handle, channel.peer_pid(),\n                                                should_close_source);\n}\n",
        "output": "1",
        "idx": 340
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "service_is_single_onion_poisoned(const rend_service_t *service)\n{\n  char *poison_fname = NULL;\n  file_status_t fstatus;\n\n  /* Passing a NULL service is a bug */\n  if (BUG(!service)) {\n    return 0;\n  }\n\n  if (rend_service_is_ephemeral(service)) {\n    return 0;\n  }\n\n  poison_fname = rend_service_sos_poison_path(service);\n\n  fstatus = file_status(poison_fname);\n  tor_free(poison_fname);\n\n  /* If this fname is occupied, the hidden service has been poisoned.\n   * fstatus can be FN_ERROR if the service directory does not exist, in that\n   * case, there is obviously no private key. */\n  if (fstatus == FN_FILE || fstatus == FN_EMPTY) {\n    return 1;\n  }\n\n  return 0;\n}\n",
        "output": "0",
        "idx": 737
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PS_SERIALIZER_DECODE_FUNC(php_serialize) /* {{{ */\n{\n\tconst char *endptr = val + vallen;\n\tzval *session_vars;\n\tphp_unserialize_data_t var_hash;\n\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tALLOC_INIT_ZVAL(session_vars);\n        if (php_var_unserialize(&session_vars, &val, endptr, &var_hash TSRMLS_CC)) {\n                var_push_dtor(&var_hash, &session_vars);\n        }\n        PHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n        if (PS(http_session_vars)) {\n                zval_ptr_dtor(&PS(http_session_vars));\n\t}\n\tif (Z_TYPE_P(session_vars) == IS_NULL) {\n\t\tarray_init(session_vars);\n\t}\n\tPS(http_session_vars) = session_vars;\n\tZEND_SET_GLOBAL_VAR_WITH_LENGTH(\"_SESSION\", sizeof(\"_SESSION\"), PS(http_session_vars), Z_REFCOUNT_P(PS(http_session_vars)) + 1, 1);\n\treturn SUCCESS;\n}\n/* }}} */\n",
        "output": "1",
        "idx": 498
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ext2_put_super (struct super_block * sb)\n{\n\tint db_count;\n\tint i;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n \n \tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n \n\text2_xattr_put_super(sb);\n \tif (!(sb->s_flags & MS_RDONLY)) {\n \t\tstruct ext2_super_block *es = sbi->s_es;\n \n\t\tspin_lock(&sbi->s_lock);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\tdb_count = sbi->s_gdb_count;\n\tfor (i = 0; i < db_count; i++)\n\t\tif (sbi->s_group_desc[i])\n\t\t\tbrelse (sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\n\tkfree(sbi->s_debts);\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tbrelse (sbi->s_sbh);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n}\n",
        "output": "1",
        "idx": 811
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "__u32 secure_ipv6_id(const __be32 daddr[4])\n{\n\tconst struct keydata *keyptr;\n\t__u32 hash[4];\n\tkeyptr = get_keyptr();\n\thash[0] = (__force __u32)daddr[0];\n\thash[1] = (__force __u32)daddr[1];\n\thash[2] = (__force __u32)daddr[2];\n\thash[3] = (__force __u32)daddr[3];\n\treturn half_md4_transform(hash, keyptr->secret);\n}\n",
        "output": "1",
        "idx": 1027
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n   RouteFunction(\n       \"OnDocumentElementCreated\",\n       base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,\n                  base::Unretained(this)));\n }\n",
        "output": "1",
        "idx": 2071
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "getnetnum(\n\tconst char *num,\n\tsockaddr_u *addr,\n\tint complain,\n\tenum gnn_type a_type\t/* ignored */\n\t)\n{\n\tNTP_REQUIRE(AF_UNSPEC == AF(addr) ||\n\t\t    AF_INET == AF(addr) ||\n\t\t    AF_INET6 == AF(addr));\n\n\tif (!is_ip_address(num, AF(addr), addr))\n\t\treturn 0;\n\n\tif (IS_IPV6(addr) && !ipv6_works)\n\t\treturn -1;\n\n# ifdef ISC_PLATFORM_HAVESALEN\n\taddr->sa.sa_len = SIZEOF_SOCKADDR(AF(addr));\n# endif\n\tSET_PORT(addr, NTP_PORT);\n\n\tDPRINTF(2, (\"getnetnum given %s, got %s\\n\", num, stoa(addr)));\n\n\treturn 1;\n}\n",
        "output": "0",
        "idx": 181
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::string SanitizeRevision(const std::string& revision) {\n  for (size_t i = 0; i < revision.length(); i++) {\n    if (!(revision[i] == '@' && i == 0)\n        && !(revision[i] >= '0' && revision[i] <= '9')\n        && !(revision[i] >= 'a' && revision[i] <= 'z')\n        && !(revision[i] >= 'A' && revision[i] <= 'Z')) {\n      return std::string();\n    }\n  }\n  return revision;\n}\n",
        "output": "1",
        "idx": 1822
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int fastcall __lock_page_killable(struct page *page)\n{\n\tDEFINE_WAIT_BIT(wait, &page->flags, PG_locked);\n\n\treturn __wait_on_bit_lock(page_waitqueue(page), &wait,\n\t\t\t\t\tsync_page_killable, TASK_KILLABLE);\n}\n",
        "output": "0",
        "idx": 397
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " pvscsi_ring_init_data(PVSCSIRingInfo *m, PVSCSICmdDescSetupRings *ri)\n {\n     int i;\n    uint32_t txr_len_log2, rxr_len_log2;\n     uint32_t req_ring_size, cmp_ring_size;\n     m->rs_pa = ri->ringsStatePPN << VMW_PAGE_SHIFT;\n \n    if ((ri->reqRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)\n        || (ri->cmpRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)) {\n        return -1;\n    }\n     req_ring_size = ri->reqRingNumPages * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n     cmp_ring_size = ri->cmpRingNumPages * PVSCSI_MAX_NUM_CMP_ENTRIES_PER_PAGE;\n     txr_len_log2 = pvscsi_log2(req_ring_size - 1);\n    }\n",
        "output": "1",
        "idx": 704
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned venc_dev::venc_flush( unsigned port)\n{\n struct v4l2_encoder_cmd enc;\n    DEBUG_PRINT_LOW(\"in %s\", __func__);\n\n    enc.cmd = V4L2_ENC_QCOM_CMD_FLUSH;\n    enc.flags = V4L2_QCOM_CMD_FLUSH_OUTPUT | V4L2_QCOM_CMD_FLUSH_CAPTURE;\n\n if (ioctl(m_nDriver_fd, VIDIOC_ENCODER_CMD, &enc)) {\n        DEBUG_PRINT_ERROR(\"Flush Port (%d) Failed \", port);\n return -1;\n }\n\n return 0;\n\n}\n",
        "output": "0",
        "idx": 1740
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_event_reset(struct perf_event *event)\n {\n \t(void)perf_event_read(event);\n \tlocal64_set(&event->count, 0);\n\tperf_event_update_userpage(event);\n}\n",
        "output": "1",
        "idx": 234
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void WebPagePrivate::didComposite()\n {\n     if (!m_page->settings()->developerExtrasEnabled())\n         return;\n    InspectorInstrumentation::didComposite(m_page);\n }\n",
        "output": "1",
        "idx": 1555
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kvm_unpin_pages(struct kvm *kvm, pfn_t pfn, unsigned long npages)\n{\n\tunsigned long i;\n\tfor (i = 0; i < npages; ++i)\n\t\tkvm_release_pfn_clean(pfn + i);\n}\n",
        "output": "1",
        "idx": 1603
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "virDomainGetJobInfo(virDomainPtr domain, virDomainJobInfoPtr info)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"info=%p\", info);\n\n    virResetLastError();\n\n    if (info)\n        memset(info, 0, sizeof(*info));\n\n    virCheckDomainReturn(domain, -1);\n    virCheckNonNullArgGoto(info, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainGetJobInfo) {\n        int ret;\n        ret = conn->driver->domainGetJobInfo(domain, info);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}\n",
        "output": "0",
        "idx": 1694
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::string GLES2Util::GetQualifiedEnumString(const EnumToString* table,\n                                              size_t count,\n                                              uint32_t value) {\n  for (const EnumToString* end = table + count; table < end; ++table) {\n    if (table->value == value) {\n      return table->name;\n    }\n  }\n  return GetStringEnum(value);\n}\n",
        "output": "0",
        "idx": 2108
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int show_traces_open(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct seq_file *m;\n\tint ret;\n\n\tif (tracing_disabled)\n\t\treturn -ENODEV;\n\n\tret = seq_open(file, &show_traces_seq_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tm = file->private_data;\n\tm->private = tr;\n\n\treturn 0;\n}\n",
        "output": "0",
        "idx": 1824
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static float CL_DemoFrameDurationSDev( void )\n{\n\tint i;\n\tint numFrames;\n\tfloat mean = 0.0f;\n\tfloat variance = 0.0f;\n\n\tif( ( clc.timeDemoFrames - 1 ) > MAX_TIMEDEMO_DURATIONS )\n\t\tnumFrames = MAX_TIMEDEMO_DURATIONS;\n\telse\n\t\tnumFrames = clc.timeDemoFrames - 1;\n\n\tfor( i = 0; i < numFrames; i++ )\n\t\tmean += clc.timeDemoDurations[ i ];\n\tmean /= numFrames;\n\n\tfor( i = 0; i < numFrames; i++ )\n\t{\n\t\tfloat x = clc.timeDemoDurations[ i ];\n\n\t\tvariance += ( ( x - mean ) * ( x - mean ) );\n\t}\n\tvariance /= numFrames;\n\n\treturn sqrt( variance );\n}\n",
        "output": "0",
        "idx": 1826
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WebContents* GetEmbedderForGuest(content::WebContents* guest) {\n  CHECK(guest);\n  return static_cast<content::WebContentsImpl*>(guest)->GetOuterWebContents();\n}\n",
        "output": "0",
        "idx": 298
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool LayoutSVGTransformableContainer::calculateLocalTransform()\n {\n     SVGGraphicsElement* element = toSVGGraphicsElement(this->element());\n     ASSERT(element);\n\n    SVGUseElement* useElement = nullptr;\n    if (isSVGUseElement(*element)) {\n        useElement = toSVGUseElement(element);\n    } else if (isSVGGElement(*element) && toSVGGElement(element)->inUseShadowTree()) {\n        SVGElement* correspondingElement = element->correspondingElement();\n        if (isSVGUseElement(correspondingElement))\n            useElement = toSVGUseElement(correspondingElement);\n    }\n\n    if (useElement) {\n        SVGLengthContext lengthContext(useElement);\n         FloatSize translation(\n             useElement->x()->currentValue()->value(lengthContext),\n             useElement->y()->currentValue()->value(lengthContext));\n         if (translation != m_additionalTranslation)\n            m_needsTransformUpdate = true;\n         m_additionalTranslation = translation;\n     }\n \n     if (!m_needsTransformUpdate)\n        return false;\n \n     m_localTransform = element->calculateAnimatedLocalTransform();\n     m_localTransform.translate(m_additionalTranslation.width(), m_additionalTranslation.height());\n     m_needsTransformUpdate = false;\n    return true;\n }\n",
        "output": "1",
        "idx": 692
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  CacheThread() : base::Thread(\"CacheThread_BlockFile\") {\n    CHECK(\n        StartWithOptions(base::Thread::Options(base::MessageLoop::TYPE_IO, 0)));\n  }\n",
        "output": "0",
        "idx": 77
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "compile_string_raw_node(StrNode* sn, regex_t* reg)\n{\n  if (sn->end <= sn->s)\n    return 0;\n\n  return add_compile_string(sn->s, 1 /* sb */, (int )(sn->end - sn->s), reg, 0);\n}\n",
        "output": "0",
        "idx": 1734
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DownloadResourceHandler::OnRequestRedirected(\n    const net::RedirectInfo& redirect_info,\n    network::ResourceResponse* response,\n    std::unique_ptr<ResourceController> controller) {\n  url::Origin new_origin(url::Origin::Create(redirect_info.new_url));\n  if (!follow_cross_origin_redirects_ &&\n      !first_origin_.IsSameOriginWith(new_origin)) {\n    base::PostTaskWithTraits(\n        FROM_HERE, {BrowserThread::UI},\n        base::BindOnce(\n            &NavigateOnUIThread, redirect_info.new_url, request()->url_chain(),\n            Referrer(GURL(redirect_info.new_referrer),\n                      Referrer::NetReferrerPolicyToBlinkReferrerPolicy(\n                          redirect_info.new_referrer_policy)),\n             GetRequestInfo()->HasUserGesture(),\n            GetRequestInfo()->GetWebContentsGetterForRequest()));\n     controller->Cancel();\n     return;\n   }\n  if (core_.OnRequestRedirected()) {\n    controller->Resume();\n  } else {\n    controller->Cancel();\n  }\n}\n",
        "output": "1",
        "idx": 627
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nfs_idmap_read_and_verify_message(struct idmap_msg *im,\n\t\tstruct idmap_msg *upcall,\n\t\tstruct key *key, struct key *authkey)\n{\n\tchar id_str[NFS_UINT_MAXLEN];\n\tsize_t len;\n\tint ret = -ENOKEY;\n\n\t/* ret = -ENOKEY */\n\tif (upcall->im_type != im->im_type || upcall->im_conv != im->im_conv)\n\t\tgoto out;\n\tswitch (im->im_conv) {\n\tcase IDMAP_CONV_NAMETOID:\n\t\tif (strcmp(upcall->im_name, im->im_name) != 0)\n\t\t\tbreak;\n\t\t/* Note: here we store the NUL terminator too */\n\t\tlen = sprintf(id_str, \"%d\", im->im_id) + 1;\n\t\tret = nfs_idmap_instantiate(key, authkey, id_str, len);\n\t\tbreak;\n\tcase IDMAP_CONV_IDTONAME:\n\t\tif (upcall->im_id != im->im_id)\n\t\t\tbreak;\n\t\tlen = strlen(im->im_name);\n\t\tret = nfs_idmap_instantiate(key, authkey, im->im_name, len);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\nout:\n\treturn ret;\n}\n",
        "output": "0",
        "idx": 173
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FrameLoader::Trace(blink::Visitor* visitor) {\n  visitor->Trace(frame_);\n   visitor->Trace(progress_tracker_);\n   visitor->Trace(document_loader_);\n   visitor->Trace(provisional_document_loader_);\n }\n",
        "output": "1",
        "idx": 583
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Platform::IntPoint InRegionScrollableArea::calculateMaximumScrollPosition(const Platform::IntSize& viewportSize, const Platform::IntSize& contentsSize, float overscrollLimitFactor) const\n{\n    ASSERT(!allowsOverscroll());\n    return Platform::IntPoint(std::max(contentsSize.width() - viewportSize.width(), 0) + overscrollLimitFactor,\n                              std::max(contentsSize.height() - viewportSize.height(), 0) + overscrollLimitFactor);\n}\n",
        "output": "1",
        "idx": 1573
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "device_constructor (GType type,\n                    guint n_construct_properties,\n                    GObjectConstructParam *construct_properties)\n{\n  Device *device;\n  DeviceClass *klass;\n\n  klass = DEVICE_CLASS (g_type_class_peek (TYPE_DEVICE));\n\n  device = DEVICE (G_OBJECT_CLASS (device_parent_class)->constructor (type,\n                                                                      n_construct_properties,\n                                                                      construct_properties));\n  return G_OBJECT (device);\n}\n",
        "output": "0",
        "idx": 1370
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BrightnessObserver::BrightnessChanged(int level, bool user_initiated) {\n  if (user_initiated)\n    BrightnessBubble::GetInstance()->ShowBubble(level, true);\n  else\n    BrightnessBubble::GetInstance()->UpdateWithoutShowingBubble(level, true);\n\n  VolumeBubble::GetInstance()->HideBubble();\n}\n",
        "output": "0",
        "idx": 1793
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderWidgetHostViewAura::UpdateExternalTexture() {\n  if (accelerated_compositing_state_changed_)\n    accelerated_compositing_state_changed_ = false;\n\n  bool is_compositing_active = host_->is_accelerated_compositing_active();\n  if (is_compositing_active && current_surface_.get()) {\n    window_->layer()->SetExternalTexture(current_surface_.get());\n    current_frame_size_ = ConvertSizeToDIP(\n        current_surface_->device_scale_factor(), current_surface_->size());\n    CheckResizeLock();\n    software_frame_manager_->DiscardCurrentFrame();\n  } else if (is_compositing_active &&\n             software_frame_manager_->HasCurrentFrame()) {\n    cc::TextureMailbox mailbox;\n    scoped_ptr<cc::SingleReleaseCallback> callback;\n    software_frame_manager_->GetCurrentFrameMailbox(&mailbox, &callback);\n    window_->layer()->SetTextureMailbox(mailbox,\n                                        callback.Pass(),\n                                        last_swapped_surface_scale_factor_);\n    current_frame_size_ = ConvertSizeToDIP(last_swapped_surface_scale_factor_,\n                                           mailbox.shared_memory_size());\n    CheckResizeLock();\n  } else {\n    window_->layer()->SetShowPaintedContent();\n    resize_lock_.reset();\n    host_->WasResized();\n    software_frame_manager_->DiscardCurrentFrame();\n  }\n}\n",
        "output": "0",
        "idx": 1369
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline unsigned long hash_name(const char *name, unsigned int *hashp)\n{\n\tunsigned long hash = init_name_hash();\n\tunsigned long len = 0, c;\n\n\tc = (unsigned char)*name;\n\tdo {\n\t\tlen++;\n\t\thash = partial_name_hash(c, hash);\n\t\tc = (unsigned char)name[len];\n\t} while (c && c != '/');\n\t*hashp = end_name_hash(hash);\n\treturn len;\n}\n",
        "output": "0",
        "idx": 1150
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n\t\tinfop, int, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n \tstruct waitid_info info = {.status = 0};\n \tlong err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);\n \tint signo = 0;\n \tif (err > 0) {\n \t\tsigno = SIGCHLD;\n \t\terr = 0;\n\t}\n\tif (!err) {\n \t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n \t\t\treturn -EFAULT;\n \t}\n\tif (!infop)\n\t\treturn err;\n\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}\n",
        "output": "1",
        "idx": 1210
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static jboolean enableNative(JNIEnv* env, jobject obj) {\n     ALOGV(\"%s:\",__FUNCTION__);\n \n     jboolean result = JNI_FALSE;\n     if (!sBluetoothInterface) return result;\n    int ret = sBluetoothInterface->enable();\n     result = (ret == BT_STATUS_SUCCESS || ret == BT_STATUS_DONE) ? JNI_TRUE : JNI_FALSE;\n     return result;\n }\n",
        "output": "1",
        "idx": 1495
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " ImageBitmapFactories::ImageBitmapLoader::ImageBitmapLoader(\n     ImageBitmapFactories& factory,\n     base::Optional<IntRect> crop_rect,\n     ScriptState* script_state,\n     const ImageBitmapOptions* options)\n    : loader_(\n           FileReaderLoader::Create(FileReaderLoader::kReadAsArrayBuffer, this)),\n       factory_(&factory),\n       resolver_(ScriptPromiseResolver::Create(script_state)),\n       crop_rect_(crop_rect),\n       options_(options) {}\n",
        "output": "1",
        "idx": 666
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long Cluster::CreateBlock(\n    long long id,\n    long long pos,   //absolute pos of payload\n    long long size,\n    long long discard_padding)\n{\n    assert((id == 0x20) || (id == 0x23));  //BlockGroup or SimpleBlock\n    if (m_entries_count < 0)  //haven't parsed anything yet\n    {\n        assert(m_entries == NULL);\n        assert(m_entries_size == 0);\n        m_entries_size = 1024;\n        m_entries = new BlockEntry*[m_entries_size];\n        m_entries_count = 0;\n    }\n    else\n    {\n        assert(m_entries);\n        assert(m_entries_size > 0);\n        assert(m_entries_count <= m_entries_size);\n        if (m_entries_count >= m_entries_size)\n        {\n            const long entries_size = 2 * m_entries_size;\n            BlockEntry** const entries = new BlockEntry*[entries_size];\n            assert(entries);\n            BlockEntry** src = m_entries;\n            BlockEntry** const src_end = src + m_entries_count;\n            BlockEntry** dst = entries;\n            while (src != src_end)\n                *dst++ = *src++;\n            delete[] m_entries;\n            m_entries = entries;\n            m_entries_size = entries_size;\n        }\n     }\n \n    if (id == 0x20)  //BlockGroup ID\n        return CreateBlockGroup(pos, size, discard_padding);\n    else  //SimpleBlock ID\n        return CreateSimpleBlock(pos, size);\n }\n",
        "output": "1",
        "idx": 782
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long long mkvparser::ReadUInt(IMkvReader* pReader, long long pos, long& len) {\n  assert(pReader);\n  assert(pos >= 0);\n  int status;\n \n   len = 1;\n   unsigned char b;\n  status = pReader->Read(pos, 1, &b);\n \n   if (status < 0)  // error or underflow\n     return status;\n\n if (status > 0) // interpreted as \"underflow\"\n return E_BUFFER_NOT_FULL;\n\n if (b == 0) // we can't handle u-int values larger than 8 bytes\n return E_FILE_FORMAT_INVALID;\n\n unsigned char m = 0x80;\n\n while (!(b & m)) {\n    m >>= 1;\n\n     ++len;\n   }\n \n   long long result = b & (~m);\n   ++pos;\n \n for (int i = 1; i < len; ++i) {\n    status = pReader->Read(pos, 1, &b);\n\n if (status < 0) {\n      len = 1;\n return status;\n }\n\n if (status > 0) {\n      len = 1;\n return E_BUFFER_NOT_FULL;\n }\n\n    result <<= 8;\n    result |= b;\n\n ++pos;\n }\n\n\n   return result;\n }\n",
        "output": "1",
        "idx": 1203
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void WtsSessionProcessDelegate::Core::KillProcess(DWORD exit_code) {\n   DCHECK(main_task_runner_->BelongsToCurrentThread());\n \n   channel_.reset();\n \n   if (launch_elevated_) {\n     if (job_.IsValid()) {\n      TerminateJobObject(job_, exit_code);\n    }\n  } else {\n    if (worker_process_.IsValid()) {\n      TerminateProcess(worker_process_, exit_code);\n    }\n  }\n}\n",
        "output": "1",
        "idx": 65
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kgdb_hw_overflow_handler(struct perf_event *event, int nmi,\n \t\tstruct perf_sample_data *data, struct pt_regs *regs)\n {\n \tstruct task_struct *tsk = current;\n\tint i;\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (breakinfo[i].enabled)\n\t\t\ttsk->thread.debugreg6 |= (DR_TRAP0 << i);\n}\n",
        "output": "1",
        "idx": 573
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static size_t safecat(char *buffer, size_t bufsize, size_t pos,\n   PNG_CONST char *cat)\n {\n    while (pos < bufsize && cat != NULL && *cat != 0)\n       buffer[pos++] = *cat++;\n\n if (pos >= bufsize)\n      pos = bufsize-1;\n\n   buffer[pos] = 0;\n return pos;\n}\n",
        "output": "1",
        "idx": 916
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct sctp_chunk *sctp_make_shutdown_ack(const struct sctp_association *asoc,\n\t\t\t\t     const struct sctp_chunk *chunk)\n{\n\tstruct sctp_chunk *retval;\n\n\tretval = sctp_make_control(asoc, SCTP_CID_SHUTDOWN_ACK, 0, 0);\n\n\t/* RFC 2960 6.4 Multi-homed SCTP Endpoints\n\t *\n\t * An endpoint SHOULD transmit reply chunks (e.g., SACK,\n\t * HEARTBEAT ACK, * etc.) to the same destination transport\n\t * address from which it * received the DATA or control chunk\n\t * to which it is replying.\n\t *\n\t * [ACK back to where the SHUTDOWN came from.]\n\t */\n\tif (retval && chunk)\n\t\tretval->transport = chunk->transport;\n\n\treturn retval;\n}\n",
        "output": "0",
        "idx": 1052
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cib_remote_dispatch(gpointer user_data)\n {\n     cib_t *cib = user_data;\n     cib_remote_opaque_t *private = cib->variant_opaque;\n \n     xmlNode *msg = NULL;\n    const char *type = NULL;\n \n     crm_info(\"Message on callback channel\");\n    msg = crm_recv_remote_msg(private->callback.session, private->callback.encrypted);\n \n    type = crm_element_value(msg, F_TYPE);\n    crm_trace(\"Activating %s callbacks...\", type);\n \n    if (safe_str_eq(type, T_CIB)) {\n        cib_native_callback(cib, msg, 0, 0);\n \n    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {\n        g_list_foreach(cib->notify_list, cib_native_notify, msg);\n \n    } else {\n        crm_err(\"Unknown message type: %s\", type);\n    }\n \n    if (msg != NULL) {\n         free_xml(msg);\n        return 0;\n     }\n    return -1;\n }\n",
        "output": "1",
        "idx": 464
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  uint64_t received_page_id() const { return received_page_id_; }\n",
        "output": "0",
        "idx": 1923
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int gdImageTileGet (gdImagePtr im, int x, int y)\n{\n\tint srcx, srcy;\n\tint tileColor,p;\n\tif (!im->tile) {\n\t\treturn -1;\n\t}\n\tsrcx = x % gdImageSX(im->tile);\n\tsrcy = y % gdImageSY(im->tile);\n\tp = gdImageGetPixel(im->tile, srcx, srcy);\n\n\tif (im->trueColor) {\n\t\tif (im->tile->trueColor) {\n\t\t\ttileColor = p;\n\t\t} else {\n\t\t\ttileColor = gdTrueColorAlpha( gdImageRed(im->tile,p), gdImageGreen(im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));\n\t\t}\n\t} else {\n\t\tif (im->tile->trueColor) {\n\t\t\ttileColor = gdImageColorResolveAlpha(im, gdTrueColorGetRed (p), gdTrueColorGetGreen (p), gdTrueColorGetBlue (p), gdTrueColorGetAlpha (p));\n\t\t} else {\n\t\t\ttileColor = p;\n\t\t\ttileColor = gdImageColorResolveAlpha(im, gdImageRed (im->tile,p), gdImageGreen (im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));\n\t\t}\n\t}\n\treturn tileColor;\n}\n",
        "output": "0",
        "idx": 928
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool generic_pkt_to_tuple(const struct sk_buff *skb,\n\t\t\t\t unsigned int dataoff,\n\t\t\t\t struct nf_conntrack_tuple *tuple)\n{\n\ttuple->src.u.all = 0;\n\ttuple->dst.u.all = 0;\n\n\treturn true;\n}\n",
        "output": "0",
        "idx": 1207
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void php_snmp_object_free_storage(void *object TSRMLS_DC)\n {\n        php_snmp_object *intern = (php_snmp_object *)object;\n        if (!intern) {\n                return;\n        }\n\n        netsnmp_session_free(&(intern->session));\n \n        zend_object_std_dtor(&intern->zo TSRMLS_CC);\n        efree(intern);\n }\n",
        "output": "1",
        "idx": 1579
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ghash_final(struct shash_desc *desc, u8 *dst)\n{\n\tstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);\n \tstruct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);\n \tu8 *buf = dctx->buffer;\n \n \tghash_flush(ctx, dctx);\n \tmemcpy(dst, buf, GHASH_BLOCK_SIZE);\n \n\treturn 0;\n}\n",
        "output": "1",
        "idx": 1572
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void PartialMagnificationController::OnWidgetDestroying(views::Widget* widget) {\n  DCHECK_EQ(widget, zoom_widget_);\n   RemoveZoomWidgetObservers();\n  zoom_widget_ = NULL;\n }\n",
        "output": "1",
        "idx": 1733
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void __ip_select_ident(struct iphdr *iph, int segs)\n {\n \tstatic u32 ip_idents_hashrnd __read_mostly;\n \tu32 hash, id;\n \n \tnet_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));\n \n \thash = jhash_3words((__force u32)iph->daddr,\n \t\t\t    (__force u32)iph->saddr,\n\t\t\t    iph->protocol,\n \t\t\t    ip_idents_hashrnd);\n \tid = ip_idents_reserve(hash, segs);\n \tiph->id = htons(id);\n}\n",
        "output": "1",
        "idx": 1342
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " OJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)\n {\n \tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n \t(void)s;\n \tif (sp->libjpeg_jpeg_query_style==0)\n \t{\n \t\tif (OJPEGDecodeRaw(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\telse\n\t{\n\t\tif (OJPEGDecodeScanlines(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\treturn(1);\n}\n",
        "output": "1",
        "idx": 133
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "     CCLayerTreeHostTest()\n         : m_beginning(false)\n         , m_endWhenBeginReturns(false)\n        , m_running(false)\n         , m_timedOut(false)\n     {\n         m_webThread = adoptPtr(webKitPlatformSupport()->createThread(\"CCLayerTreeHostTest\"));\n         WebCompositor::setThread(m_webThread.get());\n#if USE(THREADED_COMPOSITING)\n        m_settings.enableCompositorThread = true;\n#else\n        m_settings.enableCompositorThread = false;\n #endif\n     }\n",
        "output": "1",
        "idx": 969
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PPB_Buffer_Proxy::OnMsgCreate(\n    PP_Instance instance,\n    uint32_t size,\n    HostResource* result_resource,\n    ppapi::proxy::SerializedHandle* result_shm_handle) {\n  result_shm_handle->set_null_shmem();\n   HostDispatcher* dispatcher = HostDispatcher::GetForInstance(instance);\n   if (!dispatcher)\n     return;\n \n   thunk::EnterResourceCreation enter(instance);\n   if (enter.failed())\n    return;\n  PP_Resource local_buffer_resource = enter.functions()->CreateBuffer(instance,\n                                                                      size);\n  if (local_buffer_resource == 0)\n    return;\n\n  thunk::EnterResourceNoLock<thunk::PPB_BufferTrusted_API> trusted_buffer(\n      local_buffer_resource, false);\n  if (trusted_buffer.failed())\n    return;\n  int local_fd;\n  if (trusted_buffer.object()->GetSharedMemory(&local_fd) != PP_OK)\n    return;\n\n  result_resource->SetHostResource(instance, local_buffer_resource);\n\n  base::PlatformFile platform_file =\n#if defined(OS_WIN)\n      reinterpret_cast<HANDLE>(static_cast<intptr_t>(local_fd));\n#elif defined(OS_POSIX)\n      local_fd;\n#else\n  #error Not implemented.\n#endif\n  result_shm_handle->set_shmem(\n      dispatcher->ShareHandleWithRemote(platform_file, false), size);\n}\n",
        "output": "1",
        "idx": 1403
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Bool leap_year(u32 year) {\n\tyear += 1900;\n\treturn (year % 4) == 0 && ((year % 100) != 0 || (year % 400) == 0) ? GF_TRUE : GF_FALSE;\n}\n",
        "output": "0",
        "idx": 239
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int fix_log_file_owner(uid_t uid, gid_t gid)\n{\n\tint r1 = 0, r2 = 0;\n\n\tif (!(log_fp = open_log_file()))\n\t\treturn -1;\n\tr1 = fchown(fileno(log_fp), uid, gid);\n\n\tif (open_debug_log() != OK)\n\t\treturn -1;\n\tif (debug_file_fp)\n\t\tr2 = fchown(fileno(debug_file_fp), uid, gid);\n\n\t/* return 0 if both are 0 and otherwise < 0 */\n\treturn r1 < r2 ? r1 : r2;\n}\n",
        "output": "0",
        "idx": 1541
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PlatformSensorFusion::~PlatformSensorFusion() {\n  for (const auto& pair : source_sensors_)\n    pair.second->RemoveClient(this);\n}\n",
        "output": "0",
        "idx": 625
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int addrconf_ifid_gre(u8 *eui, struct net_device *dev)\n{\n\treturn __ipv6_isatap_ifid(eui, *(__be32 *)dev->dev_addr);\n}\n",
        "output": "0",
        "idx": 1420
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void CastCastView::ButtonPressed(views::Button* sender,\n                                  const ui::Event& event) {\n   DCHECK(sender == stop_button_);\n  StopCast();\n }\n",
        "output": "1",
        "idx": 838
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WebsiteSettingsPopupAndroid::~WebsiteSettingsPopupAndroid() {}\n",
        "output": "0",
        "idx": 923
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static inline void sem_getref_and_unlock(struct sem_array *sma)\n {\n\tipc_rcu_getref(sma);\n\tipc_unlock(&(sma)->sem_perm);\n }\n",
        "output": "1",
        "idx": 109
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static sk_sp<SkImage> unPremulSkImageToPremul(SkImage* input) {\n  SkImageInfo info = SkImageInfo::Make(input->width(), input->height(),\n                                       kN32_SkColorType, kPremul_SkAlphaType);\n  RefPtr<Uint8Array> dstPixels = copySkImageData(input, info);\n  if (!dstPixels)\n     return nullptr;\n   return newSkImageFromRaster(\n       info, std::move(dstPixels),\n      static_cast<size_t>(input->width()) * info.bytesPerPixel());\n }\n",
        "output": "1",
        "idx": 849
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Segment::PreloadCluster(Cluster* pCluster, ptrdiff_t idx)\n{\n    assert(pCluster);\n    assert(pCluster->m_index < 0);\n    assert(idx >= m_clusterCount);\n    const long count = m_clusterCount + m_clusterPreloadCount;\n    long& size = m_clusterSize;\n    assert(size >= count);\n    if (count >= size)\n    {\n        const long n = (size <= 0) ? 2048 : 2*size;\n        Cluster** const qq = new Cluster*[n];\n        Cluster** q = qq;\n        Cluster** p = m_clusters;\n        Cluster** const pp = p + count;\n        while (p != pp)\n            *q++ = *p++;\n        delete[] m_clusters;\n        m_clusters = qq;\n        size = n;\n    }\n     assert(m_clusters);\n \n    Cluster** const p = m_clusters + idx;\n \n    Cluster** q = m_clusters + count;\n    assert(q >= p);\n     assert(q < (m_clusters + size));\n \n    while (q > p)\n    {\n        Cluster** const qq = q - 1;\n        assert((*qq)->m_index < 0);\n \n        *q = *qq;\n        q = qq;\n     }\n \n    m_clusters[idx] = pCluster;\n    ++m_clusterPreloadCount;\n }\n",
        "output": "1",
        "idx": 381
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "String HTMLInputElement::accept() const\n{\n    return fastGetAttribute(acceptAttr);\n}\n",
        "output": "0",
        "idx": 1416
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "blink::ParsedFeaturePolicy CreateFPHeaderMatchesAll(\n    blink::mojom::FeaturePolicyFeature feature) {\n  blink::ParsedFeaturePolicy result(1);\n  result[0].feature = feature;\n  result[0].matches_all_origins = true;\n  return result;\n}\n",
        "output": "0",
        "idx": 1607
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TestBrowserWindow::~TestBrowserWindow() {}\n",
        "output": "0",
        "idx": 114
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  StatisticsCB NewStatisticsCB() {\n    return base::Bind(&MockStatisticsCB::OnStatistics,\n                      base::Unretained(&statistics_cb_));\n   }\n",
        "output": "0",
        "idx": 1423
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "report_error (const char *format, ...)\n#else\nreport_error (format, va_alist)\n     const char *format;\n     va_dcl\n#endif\n{\n  va_list args;\n\n  error_prolog (1);\n\n  SH_VA_START (args, format);\n\n  vfprintf (stderr, format, args);\n  fprintf (stderr, \"\\n\");\n \n   va_end (args);\n   if (exit_immediately_on_error)\n    exit_shell (1);\n }\n",
        "output": "1",
        "idx": 771
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void Sp_search(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tResub m;\n\n\ttext = checkstring(J, 0);\n\n\tif (js_isregexp(J, 1))\n\t\tjs_copy(J, 1);\n\telse if (js_isundefined(J, 1))\n\t\tjs_newregexp(J, \"\", 0);\n\telse\n\t\tjs_newregexp(J, js_tostring(J, 1), 0);\n \n \tre = js_toregexp(J, -1);\n \n\tif (!js_regexec(re->prog, text, &m, 0))\n \t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n \telse\n \t\tjs_pushnumber(J, -1);\n}\n",
        "output": "1",
        "idx": 1613
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cx24116_sleep(struct dvb_frontend *fe)\n{\n\tstruct cx24116_state *state = fe->demodulator_priv;\n\tstruct cx24116_cmd cmd;\n\tint ret;\n\n\tdprintk(\"%s()\\n\", __func__);\n\n\t/* Firmware CMD 36: Power config */\n\tcmd.args[0x00] = CMD_TUNERSLEEP;\n\tcmd.args[0x01] = 1;\n\tcmd.len = 0x02;\n\tret = cx24116_cmd_execute(fe, &cmd);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t/* Power off (Shutdown clocks) */\n\tcx24116_writereg(state, 0xea, 0xff);\n\tcx24116_writereg(state, 0xe1, 1);\n\tcx24116_writereg(state, 0xe0, 1);\n\n\treturn 0;\n}\n",
        "output": "0",
        "idx": 236
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "EntryInfoResult::EntryInfoResult() : error(GDATA_FILE_ERROR_FAILED) {\n}\n",
        "output": "0",
        "idx": 595
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iakerb_gss_delete_sec_context(OM_uint32 *minor_status,\n                               gss_ctx_id_t *context_handle,\n                               gss_buffer_t output_token)\n {\n    OM_uint32 major_status = GSS_S_COMPLETE;\n \n     if (output_token != GSS_C_NO_BUFFER) {\n         output_token->length = 0;\n         output_token->value = NULL;\n     }\n \n     *minor_status = 0;\n \n    if (*context_handle != GSS_C_NO_CONTEXT) {\n        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {\n            iakerb_release_context(iakerb_ctx);\n            *context_handle = GSS_C_NO_CONTEXT;\n        } else {\n            assert(iakerb_ctx->magic == KG_CONTEXT);\n            major_status = krb5_gss_delete_sec_context(minor_status,\n                                                       context_handle,\n                                                       output_token);\n        }\n    }\n    return major_status;\n }\n",
        "output": "1",
        "idx": 1037
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hid_abort_transfers(int sub_api, struct usbi_transfer *itransfer)\n{\n\tstruct libusb_transfer *transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);\n\tstruct windows_transfer_priv *transfer_priv = (struct windows_transfer_priv*)usbi_transfer_get_os_priv(itransfer);\n\tstruct windows_device_handle_priv *handle_priv = _device_handle_priv(transfer->dev_handle);\n\tHANDLE hid_handle;\n\tint current_interface;\n\tCHECK_HID_AVAILABLE;\n\tcurrent_interface = transfer_priv->interface_number;\n\thid_handle = handle_priv->interface_handle[current_interface].api_handle;\n\tCancelIo(hid_handle);\n\treturn LIBUSB_SUCCESS;\n}\n",
        "output": "1",
        "idx": 1332
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,\n\t\t\t\t\t\tvoid **list)\n{\n#if DEBUG\n\tvoid *next = *list;\n\tvoid *objp;\n\n\twhile (next) {\n\t\tobjp = next - obj_offset(cachep);\n\t\tnext = *(void **)next;\n\t\tpoison_obj(cachep, objp, POISON_FREE);\n\t}\n#endif\n}\n",
        "output": "0",
        "idx": 426
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vmx_complete_atomic_exit(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\n\tif (!(vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY\n\t      || vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI))\n\t\treturn;\n\n\tvmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\texit_intr_info = vmx->exit_intr_info;\n\n\t/* Handle machine checks before interrupts are enabled */\n\tif (is_machine_check(exit_intr_info))\n \t\tkvm_machine_check();\n \n \t/* We need to handle NMIs before interrupts are enabled */\n\tif ((exit_intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR &&\n\t    (exit_intr_info & INTR_INFO_VALID_MASK)) {\n \t\tkvm_before_handle_nmi(&vmx->vcpu);\n \t\tasm(\"int $2\");\n \t\tkvm_after_handle_nmi(&vmx->vcpu);\n\t}\n}\n",
        "output": "1",
        "idx": 255
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "authentic_get_challenge(struct sc_card *card, unsigned char *rnd, size_t len)\n{\n\t/* 'GET CHALLENGE' returns always 24 bytes */\n\tunsigned char rbuf[0x18];\n\tsize_t out_len;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = iso_ops->get_challenge(card, rbuf, sizeof rbuf);\n\tLOG_TEST_RET(card->ctx, r, \"GET CHALLENGE cmd failed\");\n\n\tif (len < (size_t) r) {\n\t\tout_len = len;\n\t} else {\n\t\tout_len = (size_t) r;\n\t}\n\tmemcpy(rnd, rbuf, out_len);\n\n\tLOG_FUNC_RETURN(card->ctx, out_len);\n}\n",
        "output": "0",
        "idx": 651
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  void (*get)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t      struct desc_ptr *ptr))\n{\n\tstruct desc_ptr desc_ptr;\n\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tctxt->op_bytes = 8;\n\tget(ctxt, &desc_ptr);\n\tif (ctxt->op_bytes == 2) {\n\t\tctxt->op_bytes = 4;\n\t\tdesc_ptr.address &= 0x00ffffff;\n \t}\n \t/* Disable writeback. */\n \tctxt->dst.type = OP_NONE;\n\treturn segmented_write(ctxt, ctxt->dst.addr.mem,\n\t\t\t       &desc_ptr, 2 + ctxt->op_bytes);\n }\n",
        "output": "1",
        "idx": 1333
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "LockContentsView::UserState::UserState(AccountId account_id)\n    : account_id(account_id) {}\n",
        "output": "1",
        "idx": 1160
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  std::string GetBody(Browser* browser) {\n    std::string body;\n    EXPECT_TRUE(content::ExecuteScriptAndExtractString(\n        browser->tab_strip_model()->GetActiveWebContents(),\n        \"window.domAutomationController.send(document.body.textContent);\",\n        &body));\n    return body;\n  }\n",
        "output": "0",
        "idx": 1630
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void iov_iter_pipe(struct iov_iter *i, int direction,\n\t\t\tstruct pipe_inode_info *pipe,\n \t\t\tsize_t count)\n {\n \tBUG_ON(direction != ITER_PIPE);\n \ti->type = direction;\n \ti->pipe = pipe;\n \ti->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\ti->iov_offset = 0;\n\ti->count = count;\n}\n",
        "output": "1",
        "idx": 1281
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload, *zap;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\tgoto error;\n\n\t/* construct a replacement payload */\n\tret = -ENOMEM;\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\tgoto error;\n\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\n\t/* check the quota and attach the new data */\n\tzap = upayload;\n\n\tret = key_payload_reserve(key, datalen);\n \n \tif (ret == 0) {\n \t\t/* attach the new data, displacing the old */\n\t\tzap = key->payload.data[0];\n \t\trcu_assign_keypointer(key, upayload);\n \t\tkey->expiry = 0;\n \t}\n\n\tif (zap)\n\t\tkfree_rcu(zap, rcu);\n\nerror:\n\treturn ret;\n}\n",
        "output": "1",
        "idx": 1654
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool FlagsState::IsRestartNeededToCommitChanges() {\n  return needs_restart_;\n}\n",
        "output": "0",
        "idx": 198
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool GDataDirectory::FromProto(const GDataDirectoryProto& proto) {\n  DCHECK(proto.gdata_entry().file_info().is_directory());\n   DCHECK(!proto.gdata_entry().has_file_specific_info());\n \n   for (int i = 0; i < proto.child_files_size(); ++i) {\n    scoped_ptr<GDataFile> file(new GDataFile(NULL, directory_service_));\n     if (!file->FromProto(proto.child_files(i))) {\n       RemoveChildren();\n       return false;\n     }\n     AddEntry(file.release());\n   }\n   for (int i = 0; i < proto.child_directories_size(); ++i) {\n    scoped_ptr<GDataDirectory> dir(new GDataDirectory(NULL,\n                                                      directory_service_));\n     if (!dir->FromProto(proto.child_directories(i))) {\n       RemoveChildren();\n       return false;\n    }\n    AddEntry(dir.release());\n  }\n\n  if (!GDataEntry::FromProto(proto.gdata_entry()))\n    return false;\n\n  return true;\n}\n",
        "output": "1",
        "idx": 672
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Editor::RevealSelectionAfterEditingOperation(\n    const ScrollAlignment& alignment,\n    RevealExtentOption reveal_extent_option) {\n  if (prevent_reveal_selection_)\n    return;\n  if (!GetFrame().Selection().IsAvailable())\n    return;\n   GetFrame().Selection().RevealSelection(alignment, reveal_extent_option);\n }\n",
        "output": "0",
        "idx": 405
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vhost_scsi_send_evt(struct vhost_scsi *vs,\n\t\t   struct vhost_scsi_tpg *tpg,\n\t\t   struct se_lun *lun,\n\t\t   u32 event,\n\t\t   u32 reason)\n{\n\tstruct vhost_scsi_evt *evt;\n\n\tevt = vhost_scsi_allocate_evt(vs, event, reason);\n\tif (!evt)\n\t\treturn;\n\n\tif (tpg && lun) {\n\t\t/* TODO: share lun setup code with virtio-scsi.ko */\n\t\t/*\n\t\t * Note: evt->event is zeroed when we allocate it and\n \t\t * lun[4-7] need to be zero according to virtio-scsi spec.\n \t\t */\n \t\tevt->event.lun[0] = 0x01;\n\t\tevt->event.lun[1] = tpg->tport_tpgt & 0xFF;\n \t\tif (lun->unpacked_lun >= 256)\n \t\t\tevt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;\n \t\tevt->event.lun[3] = lun->unpacked_lun & 0xFF;\n\t}\n\n\tllist_add(&evt->list, &vs->vs_event_list);\n\tvhost_work_queue(&vs->dev, &vs->vs_event_work);\n}\n",
        "output": "1",
        "idx": 1728
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PrintPreviewHandler::PrintPreviewHandler()\n    : print_backend_(printing::PrintBackend::CreateInstance(NULL)),\n      regenerate_preview_request_count_(0),\n      manage_printers_dialog_request_count_(0),\n      manage_cloud_printers_dialog_request_count_(0),\n      reported_failed_preview_(false),\n      has_logged_printers_count_(false) {\n  ReportUserActionHistogram(PREVIEW_STARTED);\n}\n",
        "output": "0",
        "idx": 1263
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc,\n\t\t       struct ath_node *an)\n{\n\tstruct ath_atx_tid *tid;\n\tstruct ath_atx_ac *ac;\n\tstruct ath_txq *txq;\n\tbool buffered;\n\tint tidno;\n\n \tfor (tidno = 0, tid = &an->tid[tidno];\n \t     tidno < IEEE80211_NUM_TIDS; tidno++, tid++) {\n \n\t\tif (!tid->sched)\n\t\t\tcontinue;\n \t\tac = tid->ac;\n \t\ttxq = ac->txq;\n \n \t\tath_txq_lock(sc, txq);\n \n \t\tbuffered = ath_tid_has_buffered(tid);\n \n \t\ttid->sched = false;\n\t\tlist_del(&tid->list);\n\n\t\tif (ac->sched) {\n\t\t\tac->sched = false;\n\t\t\tlist_del(&ac->list);\n\t\t}\n\n\t\tath_txq_unlock(sc, txq);\n\n\t\tieee80211_sta_set_buffered(sta, tidno, buffered);\n\t}\n}\n",
        "output": "1",
        "idx": 1876
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlFatalErrMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,\n const char *msg)\n{\n if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&\n (ctxt->instate == XML_PARSER_EOF))\n return;\n if (ctxt != NULL)\n\tctxt->errNo = error;\n    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,\n                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, \"%s\", msg);\n if (ctxt != NULL) {\n\tctxt->wellFormed = 0;\n if (ctxt->recovery == 0)\n\t    ctxt->disableSAX = 1;\n }\n}\n",
        "output": "0",
        "idx": 203
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32 SelectSamplesPerPacket(AudioParameters params) {\n  int samples = kMinSamplesPerHardwarePacket;\n  while (samples <= kMaxSamplesPerHardwarePacket &&\n         samples * base::Time::kMillisecondsPerSecond <\n         params.sample_rate * kMillisecondsPerHardwarePacket) {\n    samples *= 2;\n  }\n  return samples;\n}\n",
        "output": "0",
        "idx": 1274
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vapic_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint idx;\n\tif (!apic || !apic->vapic_addr)\n\t\treturn;\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_release_page_dirty(apic->vapic_page);\n\tmark_page_dirty(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n}\n",
        "output": "1",
        "idx": 1723
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::unique_ptr<service_manager::Service> CreateDataDecoderService() {\n  content::UtilityThread::Get()->EnsureBlinkInitialized();\n  return data_decoder::DataDecoderService::Create();\n}\n",
        "output": "0",
        "idx": 730
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void V8TestObject::ActivityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttributeAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_activityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttribute_Getter\");\n\n  ScriptState* script_state = ScriptState::ForRelevantRealm(info);\n  V8PerContextData* context_data = script_state->PerContextData();\n  if (context_data && context_data->ActivityLogger()) {\n    context_data->ActivityLogger()->LogGetter(\"TestObject.activityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttribute\");\n  }\n\n  test_object_v8_internal::ActivityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttributeAttributeGetter(info);\n}\n",
        "output": "0",
        "idx": 1615
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n \tGC_REFCOUNT(ht) = 1;\n \tGC_TYPE_INFO(ht) = IS_ARRAY;\n \tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\tht->nTableSize = zend_hash_check_size(nSize);\n \tht->nTableMask = HT_MIN_MASK;\n \tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n \tht->nNumUsed = 0;\n \tht->nNumOfElements = 0;\n \tht->nInternalPointer = HT_INVALID_IDX;\n \tht->nNextFreeElement = 0;\n \tht->pDestructor = pDestructor;\n }\n",
        "output": "1",
        "idx": 797
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CCLayerTreeHostTest::endTest()\n {\n     if (!isMainThread())\n        CCMainThread::postTask(createMainThreadTask(this, &CCLayerTreeHostTest::endTest));\n     else {\n        if (m_beginning)\n            m_endWhenBeginReturns = true;\n        else\n            onEndTest(static_cast<void*>(this));\n    }\n}\n",
        "output": "1",
        "idx": 2014
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)\n {\n\n\tif (timr->it.mmtimer.clock == TIMER_OFF) {\n\t\tcur_setting->it_interval.tv_nsec = 0;\n\t\tcur_setting->it_interval.tv_sec = 0;\n\t\tcur_setting->it_value.tv_nsec = 0;\n\t\tcur_setting->it_value.tv_sec =0;\n \t\treturn;\n \t}\n \n\tns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);\n\tns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);\n\treturn;\n }\n",
        "output": "1",
        "idx": 1214
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WebRuntimeFeatures::isPrefixedEncryptedMediaEnabled()\n{\n    return RuntimeEnabledFeatures::prefixedEncryptedMediaEnabled();\n}\n",
        "output": "0",
        "idx": 628
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void array_cleanup( char* arr[] , int arr_size)\n {\n \tint i=0;\n\tfor( i=0; i< arr_size; i++ ){ \n \t\tif( arr[i*2] ){\n \t\t\tefree( arr[i*2]);\n \t\t}\n\t}\n\tefree(arr);\n}\n",
        "output": "1",
        "idx": 1700
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType offset,\n  const int whence,void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n\n  profile=(PhotoshopProfile *) user_data;\n  switch (whence)\n  {\n    case SEEK_SET:\n    default:\n    {\n      if (offset < 0)\n        return(-1);\n      profile->offset=offset;\n      break;\n     }\n     case SEEK_CUR:\n     {\n       if ((profile->offset+offset) < 0)\n         return(-1);\n       profile->offset+=offset;\n      break;\n    }\n    case SEEK_END:\n    {\n      if (((MagickOffsetType) profile->length+offset) < 0)\n        return(-1);\n      profile->offset=profile->length+offset;\n      break;\n    }\n  }\n\n  return(profile->offset);\n}\n",
        "output": "1",
        "idx": 1964
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "FrameView::FrameView(LocalFrame* frame)\n    : m_frame(frame)\n    , m_canHaveScrollbars(true)\n    , m_slowRepaintObjectCount(0)\n    , m_hasPendingLayout(false)\n    , m_layoutSubtreeRoot(0)\n    , m_inSynchronousPostLayout(false)\n    , m_postLayoutTasksTimer(this, &FrameView::postLayoutTimerFired)\n    , m_updateWidgetsTimer(this, &FrameView::updateWidgetsTimerFired)\n    , m_isTransparent(false)\n    , m_baseBackgroundColor(Color::white)\n    , m_mediaType(\"screen\")\n    , m_overflowStatusDirty(true)\n    , m_viewportRenderer(0)\n    , m_wasScrolledByUser(false)\n    , m_inProgrammaticScroll(false)\n    , m_safeToPropagateScrollToParent(true)\n    , m_isTrackingPaintInvalidations(false)\n    , m_scrollCorner(nullptr)\n    , m_hasSoftwareFilters(false)\n    , m_visibleContentScaleFactor(1)\n     , m_inputEventsScaleFactorForEmulation(1)\n     , m_layoutSizeFixedToFrameSize(true)\n     , m_didScrollTimer(this, &FrameView::didScrollTimerFired)\n {\n     ASSERT(m_frame);\n     init();\n\n    if (!m_frame->isMainFrame())\n        return;\n\n    ScrollableArea::setVerticalScrollElasticity(ScrollElasticityAllowed);\n    ScrollableArea::setHorizontalScrollElasticity(ScrollElasticityAllowed);\n}\n",
        "output": "1",
        "idx": 68
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " php_http_url_t *php_http_url_parse(const char *str, size_t len, unsigned flags TSRMLS_DC)\n {\n\tsize_t maxlen = 3 * len;\n \tstruct parse_state *state = ecalloc(1, sizeof(*state) + maxlen);\n \n \tstate->end = str + len;\n\tstate->ptr = str;\n\tstate->flags = flags;\n\tstate->maxlen = maxlen;\n\tTSRMLS_SET_CTX(state->ts);\n\n\tif (!parse_scheme(state)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to parse URL scheme: '%s'\", state->ptr);\n\t\tefree(state);\n\t\treturn NULL;\n\t}\n\n\tif (!parse_hier(state)) {\n\t\tefree(state);\n\t\treturn NULL;\n\t}\n\n\tif (!parse_query(state)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to parse URL query: '%s'\", state->ptr);\n\t\tefree(state);\n\t\treturn NULL;\n\t}\n\n\tif (!parse_fragment(state)) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to parse URL fragment: '%s'\", state->ptr);\n\t\tefree(state);\n\t\treturn NULL;\n\t}\n\n\treturn (php_http_url_t *) state;\n}\n",
        "output": "1",
        "idx": 40
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline long decode_twos_comp(ulong c, int prec)\n {\n \tlong result;\n \tassert(prec >= 2);\n\tjas_eprintf(\"warning: support for signed data is untested\\n\");\n\tresult = (c & ((1 << (prec - 1)) - 1)) - (c & (1 << (prec - 1)));\n \treturn result;\n }\n",
        "output": "1",
        "idx": 1414
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t Parcel::readPointer(uintptr_t *pArg) const\n{\n status_t ret;\n binder_uintptr_t ptr;\n    ret = readAligned(&ptr);\n if (!ret)\n *pArg = ptr;\n return ret;\n}\n",
        "output": "0",
        "idx": 27
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat)\n {\n \tND_PRINT((ndo, \"%u.%u\", (EXTRACT_16BITS(dat) >> 8),\n \t    (EXTRACT_16BITS(dat) & 0xff)));\n }\n",
        "output": "1",
        "idx": 499
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "process(struct magic_set *ms, const char *inname, int wid)\n{\n\tconst char *type;\n\tint std_in = strcmp(inname, \"-\") == 0;\n\n\tif (wid > 0 && !bflag) {\n\t\t(void)printf(\"%s\", std_in ? \"/dev/stdin\" : inname);\n\t\tif (nulsep)\n\t\t\t(void)putc('\\0', stdout);\n\t\t(void)printf(\"%s\", separator);\n\t\t(void)printf(\"%*s \",\n\t\t    (int) (nopad ? 0 : (wid - file_mbswidth(inname))), \"\");\n\t}\n\n\ttype = magic_file(ms, std_in ? NULL : inname);\n\tif (type == NULL) {\n\t\t(void)printf(\"ERROR: %s\\n\", magic_error(ms));\n\t\treturn 1;\n\t} else {\n\t\t(void)printf(\"%s\\n\", type);\n\t\treturn 0;\n\t}\n}\n",
        "output": "0",
        "idx": 186
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)\n{\n\tstruct block_device *bdev;\n\tchar b[BDEVNAME_SIZE];\n\n\tbdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);\n\tif (IS_ERR(bdev))\n\t\tgoto fail;\n \treturn bdev;\n \n fail:\n\text3_msg(sb, \"error: failed to open journal device %s: %ld\",\n \t\t__bdevname(dev, b), PTR_ERR(bdev));\n \n \treturn NULL;\n}\n",
        "output": "1",
        "idx": 1041
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HTMLSelectElement::accessKeySetSelectedIndex(int index)\n{    \n    if (!focused())\n        accessKeyAction(false);\n    \n    const Vector<HTMLElement*>& items = listItems();\n    int listIndex = optionToListIndex(index);\n    if (listIndex >= 0) {\n        HTMLElement* element = items[listIndex];\n        if (element->hasTagName(optionTag)) {\n            if (toHTMLOptionElement(element)->selected())\n                toHTMLOptionElement(element)->setSelectedState(false);\n            else\n                selectOption(index, DispatchChangeEvent | UserDriven);\n        }\n    }\n\n    if (usesMenuList())\n        dispatchChangeEventForMenuList();\n    else\n        listBoxOnChange();\n\n    scrollToSelection();\n}\n",
        "output": "0",
        "idx": 1984
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *rfc2047_decode_word(const char *s, size_t len, enum ContentEncoding enc)\n{\n  const char *it = s;\n  const char *end = s + len;\n\n  if (enc == ENCQUOTEDPRINTABLE)\n  {\n    struct Buffer buf = { 0 };\n    for (; it < end; ++it)\n    {\n      if (*it == '_')\n      {\n        mutt_buffer_addch(&buf, ' ');\n      }\n      else if ((*it == '=') && (!(it[1] & ~127) && hexval(it[1]) != -1) &&\n               (!(it[2] & ~127) && hexval(it[2]) != -1))\n      {\n        mutt_buffer_addch(&buf, (hexval(it[1]) << 4) | hexval(it[2]));\n        it += 2;\n      }\n      else\n      {\n        mutt_buffer_addch(&buf, *it);\n      }\n    }\n    mutt_buffer_addch(&buf, '\\0');\n    return buf.data;\n   }\n   else if (enc == ENCBASE64)\n   {\n    char *out = mutt_mem_malloc(3 * len / 4 + 1);\n    int dlen = mutt_b64_decode(out, it);\n     if (dlen == -1)\n     {\n       FREE(&out);\n      return NULL;\n    }\n    out[dlen] = '\\0';\n    return out;\n  }\n\n  assert(0); /* The enc parameter has an invalid value */\n  return NULL;\n}\n",
        "output": "1",
        "idx": 1330
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GpuProcessHost::GpuProcessHost(int host_id, GpuProcessKind kind)\n    : host_id_(host_id),\n      valid_(true),\n      in_process_(false),\n      software_rendering_(false),\n      kind_(kind),\n      process_launched_(false) {\n  if (CommandLine::ForCurrentProcess()->HasSwitch(switches::kSingleProcess) ||\n      CommandLine::ForCurrentProcess()->HasSwitch(switches::kInProcessGPU))\n    in_process_ = true;\n\n  DCHECK(!in_process_ || g_gpu_process_hosts[kind] == NULL);\n\n  g_gpu_process_hosts[kind] = this;\n\n  BrowserThread::PostTask(\n      BrowserThread::UI,\n      FROM_HERE,\n      base::Bind(base::IgnoreResult(&GpuProcessHostUIShim::Create), host_id));\n\n  process_.reset(new BrowserChildProcessHostImpl(PROCESS_TYPE_GPU, this));\n}\n",
        "output": "0",
        "idx": 1372
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ssize_t rawexpread(off_t a, char *buf, size_t len, CLIENT *client) {\n\tint fhandle;\n\toff_t foffset;\n\tsize_t maxbytes;\n\n\tif(get_filepos(client->export, a, &fhandle, &foffset, &maxbytes))\n\t\treturn -1;\n\tif(maxbytes && len > maxbytes)\n\t\tlen = maxbytes;\n\n\tDEBUG(\"(READ from fd %d offset %llu len %u), \", fhandle, (long long unsigned int)foffset, (unsigned int)len);\n\n\tmyseek(fhandle, foffset);\n\treturn read(fhandle, buf, len);\n}\n",
        "output": "0",
        "idx": 1689
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " std::string MasterPreferences::GetCompressedVariationsSeed() const {\n  return ExtractPrefString(prefs::kVariationsCompressedSeed);\n }\n",
        "output": "1",
        "idx": 1385
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FrameSelection::MoveRangeSelectionExtent(const IntPoint& contents_point) {\n  if (ComputeVisibleSelectionInDOMTree().IsNone())\n    return;\n\n   SetSelection(\n       SelectionInDOMTree::Builder(\n           GetGranularityStrategy()->UpdateExtent(contents_point, frame_))\n          .SetIsHandleVisible(true)\n           .Build(),\n       SetSelectionData::Builder()\n           .SetShouldCloseTyping(true)\n           .SetShouldClearTypingStyle(true)\n           .SetDoNotClearStrategy(true)\n           .SetSetSelectionBy(SetSelectionBy::kUser)\n           .Build());\n }\n",
        "output": "1",
        "idx": 1149
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ia64_patch_vtop (unsigned long start, unsigned long end)\n{\n\ts32 *offp = (s32 *) start;\n\tu64 ip;\n\n\twhile (offp < (s32 *) end) {\n\t\tip = (u64) offp + *offp;\n\n\t\t/* replace virtual address with corresponding physical address: */\n\t\tia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));\n\t\tia64_fc((void *) ip);\n\t\t++offp;\n\t}\n\tia64_sync_i();\n \tia64_srlz_i();\n }\n",
        "output": "0",
        "idx": 78
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void checkListProperties(sqlite3 *db){\n  sqlite3 *p;\n  for(p=sqlite3BlockedList; p; p=p->pNextBlocked){\n    int seen = 0;\n    sqlite3 *p2;\n\n    /* Verify property (1) */\n    assert( p->pUnlockConnection || p->pBlockingConnection );\n\n    /* Verify property (2) */\n    for(p2=sqlite3BlockedList; p2!=p; p2=p2->pNextBlocked){\n      if( p2->xUnlockNotify==p->xUnlockNotify ) seen = 1;\n      assert( p2->xUnlockNotify==p->xUnlockNotify || !seen );\n      assert( db==0 || p->pUnlockConnection!=db );\n      assert( db==0 || p->pBlockingConnection!=db );\n    }\n  }\n}\n",
        "output": "0",
        "idx": 885
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qeth_clear_thread_start_bit(struct qeth_card *card, unsigned long thread)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&card->thread_mask_lock, flags);\n\tcard->thread_start_mask &= ~thread;\n\tspin_unlock_irqrestore(&card->thread_mask_lock, flags);\n\twake_up(&card->wait_q);\n}\n",
        "output": "0",
        "idx": 1097
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sample_hbp_handler(struct perf_event *bp, int nmi,\n \t\t\t       struct perf_sample_data *data,\n \t\t\t       struct pt_regs *regs)\n {\n\tprintk(KERN_INFO \"%s value is changed\\n\", ksym_name);\n\tdump_stack();\n\tprintk(KERN_INFO \"Dump stack from sample_hbp_handler\\n\");\n}\n",
        "output": "1",
        "idx": 699
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "INST_HANDLER (lac) {\t// LAC Z, Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 0);\t// 0: Read (RAMPZ:Z)\n\tESIL_A (\"r%d,0xff,^,&,\", d);\t\t\t// 0: (Z) & ~Rd\n\tESIL_A (\"DUP,r%d,=,\", d);\t\t\t// Rd = [0]\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 1);\t// Store in RAM\n}\n",
        "output": "0",
        "idx": 804
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static inline void VectorClamp3(DDSVector3 *value)\n {\n  value->x = MinF(1.0f,MaxF(0.0f,value->x));\n  value->y = MinF(1.0f,MaxF(0.0f,value->y));\n  value->z = MinF(1.0f,MaxF(0.0f,value->z));\n }\n",
        "output": "1",
        "idx": 332
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_accm_print(netdissect_options *ndo, const u_char *dat)\n {\n \tconst uint16_t *ptr = (const uint16_t *)dat;\n \tuint16_t val_h, val_l;\n \n \tptr++;\t\t/* skip \"Reserved\" */\n \n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n \tND_PRINT((ndo, \"send=%08x \", (val_h<<16) + val_l));\n \n \tval_h = EXTRACT_16BITS(ptr); ptr++;\n \tval_l = EXTRACT_16BITS(ptr); ptr++;\n \tND_PRINT((ndo, \"recv=%08x \", (val_h<<16) + val_l));\n}\n",
        "output": "1",
        "idx": 1761
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void smp_send_pair_fail(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  p_cb->status = p_data->status;\n  p_cb->failure = p_data->status;\n\n  SMP_TRACE_DEBUG(\"%s: status=%d failure=%d \", __func__, p_cb->status,\n                  p_cb->failure);\n\n if (p_cb->status <= SMP_MAX_FAIL_RSN_PER_SPEC &&\n      p_cb->status != SMP_SUCCESS) {\n    smp_send_cmd(SMP_OPCODE_PAIRING_FAILED, p_cb);\n    p_cb->wait_for_authorization_complete = true;\n }\n}\n",
        "output": "0",
        "idx": 1410
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  UpdateTemporaryGlobalQuotaTask(\n      QuotaManager* manager,\n      int64 new_quota,\n      QuotaCallback* callback)\n      : DatabaseTaskBase(manager),\n        new_quota_(new_quota),\n        callback_(callback) {\n    DCHECK_GE(new_quota, 0);\n  }\n",
        "output": "0",
        "idx": 1060
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int php_stream_temp_seek(php_stream *stream, off_t offset, int whence, off_t *newoffs TSRMLS_DC)\n{\n\tphp_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;\n\tint ret;\n\n\tassert(ts != NULL);\n\n\tif (!ts->innerstream) {\n\t\t*newoffs = -1;\n\t\treturn -1;\n\t}\n        ret = php_stream_seek(ts->innerstream, offset, whence);\n        *newoffs = php_stream_tell(ts->innerstream);\n        stream->eof = ts->innerstream->eof;\n        return ret;\n }\n",
        "output": "1",
        "idx": 119
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebGL2RenderingContextBase::texImage2D(GLenum target,\n                                            GLint level,\n                                            GLint internalformat,\n                                            GLsizei width,\n                                            GLsizei height,\n                                            GLint border,\n                                            GLenum format,\n                                            GLenum type,\n                                            GLintptr offset) {\n  if (isContextLost())\n    return;\n  if (!ValidateTexture2DBinding(\"texImage2D\", target))\n    return;\n  if (!bound_pixel_unpack_buffer_) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"texImage2D\",\n                       \"no bound PIXEL_UNPACK_BUFFER\");\n     return;\n   }\n   if (!ValidateTexFunc(\"texImage2D\", kTexImage, kSourceUnpackBuffer, target,\n                        level, internalformat, width, height, 1, border, format,\n                        type, 0, 0, 0))\n    return;\n  if (!ValidateValueFitNonNegInt32(\"texImage2D\", \"offset\", offset))\n    return;\n\n  ContextGL()->TexImage2D(\n      target, level, ConvertTexInternalFormat(internalformat, type), width,\n      height, border, format, type, reinterpret_cast<const void*>(offset));\n}\n",
        "output": "1",
        "idx": 1796
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void bdt_enable(void)\n{\n    bdt_log(\"ENABLE BT\");\n if (bt_enabled) {\n\n         bdt_log(\"Bluetooth is already enabled\");\n         return;\n     }\n    status = sBtInterface->enable();\n \n     check_return_status(status);\n }\n",
        "output": "1",
        "idx": 1674
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool shouldSetStrutOnBlock(const LayoutBlockFlow& block, const RootInlineBox& lineBox, LayoutUnit lineLogicalOffset, int lineIndex, LayoutUnit remainingLogicalHeight)\n{\n    bool wantsStrutOnBlock = false;\n    if (!block.style()->hasAutoOrphans() && block.style()->orphans() >= lineIndex) {\n        wantsStrutOnBlock = true;\n    } else if (lineBox == block.firstRootBox() && lineLogicalOffset == block.borderAndPaddingBefore()) {\n        LayoutUnit lineHeight = lineBox.lineBottomWithLeading() - lineBox.lineTopWithLeading();\n        LayoutUnit totalLogicalHeight = lineHeight + std::max<LayoutUnit>(0, lineLogicalOffset);\n        LayoutUnit pageLogicalHeightAtNewOffset = block.pageLogicalHeightForOffset(lineLogicalOffset + remainingLogicalHeight);\n         if (totalLogicalHeight < pageLogicalHeightAtNewOffset)\n             wantsStrutOnBlock = true;\n     }\n    if (!wantsStrutOnBlock || block.isOutOfFlowPositioned())\n        return false;\n    LayoutBlock* containingBlock = block.containingBlock();\n    return containingBlock && containingBlock->isLayoutBlockFlow();\n }\n",
        "output": "1",
        "idx": 1157
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " SPL_METHOD(FilesystemIterator, current)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n\tif (SPL_FILE_DIR_CURRENT(intern, SPL_FILE_DIR_CURRENT_AS_PATHNAME)) {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t\tRETURN_STRINGL(intern->file_name, intern->file_name_len, 1);\n\t} else if (SPL_FILE_DIR_CURRENT(intern, SPL_FILE_DIR_CURRENT_AS_FILEINFO)) {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t\tspl_filesystem_object_create_type(0, intern, SPL_FS_INFO, NULL, return_value TSRMLS_CC);\n\t} else {\n\t\tRETURN_ZVAL(getThis(), 1, 0);\n\t\t/*RETURN_STRING(intern->u.dir.entry.d_name, 1);*/\n\t}\n}\n",
        "output": "1",
        "idx": 1758
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sock_spd_release(struct splice_pipe_desc *spd, unsigned int i)\n{\n\tput_page(spd->pages[i]);\n}\n",
        "output": "0",
        "idx": 2039
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void setSerifFontFamilyWrapper(WebSettings* settings,\n                               const string16& font,\n                               UScriptCode script) {\n  settings->setSerifFontFamily(font, script);\n}\n",
        "output": "0",
        "idx": 21
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool IsValidElementName(Document* document, const String& name) {\n  bool is_valid_dom_name = Document::IsValidName(name);\n  bool is_valid_html_name = IsValidElementNamePerHTMLParser(name);\n  if (UNLIKELY(is_valid_html_name != is_valid_dom_name)) {\n    UseCounter::Count(document,\n                      is_valid_dom_name\n                          ? WebFeature::kElementNameDOMValidHTMLParserInvalid\n                          : WebFeature::kElementNameDOMInvalidHTMLParserValid);\n  }\n  return is_valid_dom_name;\n}\n",
        "output": "0",
        "idx": 715
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DevToolsWindow::Inspect(scoped_refptr<content::DevToolsAgentHost> host) {\n  DevToolsWindow::OpenDevToolsWindow(host, profile_);\n}\n",
        "output": "0",
        "idx": 837
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebDevToolsAgentImpl::didNavigate()\n{\n    ClientMessageLoopAdapter::didNavigate();\n}\n",
        "output": "0",
        "idx": 2070
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameImpl::OnCopyToFindPboard() {\n  if (frame_->HasSelection()) {\n    if (!clipboard_host_) {\n      auto* platform = RenderThreadImpl::current_blink_platform_impl();\n      platform->GetConnector()->BindInterface(platform->GetBrowserServiceName(),\n                                              &clipboard_host_);\n    }\n    base::string16 selection = frame_->SelectionAsText().Utf16();\n    clipboard_host_->WriteStringToFindPboard(selection);\n  }\n}\n",
        "output": "0",
        "idx": 2
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    StringCapturingFunction(ScriptState* scriptState, String* value)\n        : ScriptFunction(scriptState)\n        , m_value(value)\n    {\n    }\n",
        "output": "0",
        "idx": 2098
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ContentSettingsClient* FrameFetchContext::GetContentSettingsClient() const {\n  if (IsDetached())\n    return nullptr;\n  return GetFrame()->GetContentSettingsClient();\n}\n",
        "output": "0",
        "idx": 1339
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static uint32_t readU32(const uint8_t* data, size_t offset) {\n    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];\n }\n",
        "output": "1",
        "idx": 1652
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void DataReductionProxySettings::InitDataReductionProxySettings(\n     PrefService* prefs,\n    DataReductionProxyIOData* io_data,\n    std::unique_ptr<DataReductionProxyService> data_reduction_proxy_service) {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  DCHECK(prefs);\n  DCHECK(io_data);\n  DCHECK(io_data->config());\n  DCHECK(data_reduction_proxy_service);\n  prefs_ = prefs;\n   config_ = io_data->config();\n   data_reduction_proxy_service_ = std::move(data_reduction_proxy_service);\n   data_reduction_proxy_service_->AddObserver(this);\n  InitPrefMembers();\n   RecordDataReductionInit();\n \n #if defined(OS_ANDROID)\n  if (spdy_proxy_auth_enabled_.GetValue()) {\n     data_reduction_proxy_service_->compression_stats()\n         ->SetDataUsageReportingEnabled(true);\n   }\n#endif  // defined(OS_ANDROID)\n\n  for (auto& observer : observers_)\n    observer.OnSettingsInitialized();\n}\n",
        "output": "1",
        "idx": 753
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool CheckBasicProxyAuth(const AuthChallengeInfo* auth_challenge) {\n  if (!auth_challenge)\n    return false;\n  EXPECT_TRUE(auth_challenge->is_proxy);\n  EXPECT_EQ(\"myproxy:70\", auth_challenge->challenger.ToString());\n  EXPECT_EQ(\"MyRealm1\", auth_challenge->realm);\n  EXPECT_EQ(\"basic\", auth_challenge->scheme);\n  return true;\n}\n",
        "output": "0",
        "idx": 2096
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  bool StopInputMethodProcess() {\n     if (!IBusConnectionsAreAlive()) {\n       LOG(ERROR) << \"StopInputMethodProcess: IBus connection is not alive\";\n       return false;\n    }\n\n    ibus_bus_exit_async(ibus_,\n                        FALSE  /* do not restart */,\n                        -1  /* timeout */,\n                        NULL  /* cancellable */,\n                        NULL  /* callback */,\n                        NULL  /* user_data */);\n\n    if (ibus_config_) {\n      g_object_unref(ibus_config_);\n      ibus_config_ = NULL;\n    }\n     return true;\n   }\n",
        "output": "1",
        "idx": 97
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void kvm_register_target_sys_reg_table(unsigned int target,\n\t\t\t\t       struct kvm_sys_reg_target_table *table)\n{\n\ttarget_tables[target] = table;\n}\n",
        "output": "0",
        "idx": 227
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context, v8::Local<v8::Function> function)\n{\n    int scriptId = function->ScriptId();\n    if (scriptId == v8::UnboundScript::kNoScriptId)\n        return v8::Null(m_isolate);\n    int lineNumber = function->GetScriptLineNumber();\n    int columnNumber = function->GetScriptColumnNumber();\n     if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)\n         return v8::Null(m_isolate);\n     v8::Local<v8::Object> location = v8::Object::New(m_isolate);\n     if (!location->Set(context, toV8StringInternalized(m_isolate, \"scriptId\"), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))\n         return v8::Null(m_isolate);\n     if (!location->Set(context, toV8StringInternalized(m_isolate, \"lineNumber\"), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))\n        return v8::Null(m_isolate);\n    if (!location->Set(context, toV8StringInternalized(m_isolate, \"columnNumber\"), v8::Integer::New(m_isolate, columnNumber)).FromMaybe(false))\n        return v8::Null(m_isolate);\n    if (!markAsInternal(context, location, V8InternalValueType::kLocation))\n        return v8::Null(m_isolate);\n    return location;\n}\n",
        "output": "1",
        "idx": 1376
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameImpl::DidChangeCpuTiming(base::TimeDelta time) {\n  for (auto& observer : observers_)\n    observer.DidChangeCpuTiming(time);\n}\n",
        "output": "0",
        "idx": 1496
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dcputs(const char *s)\n{\n\tint len=strlen(s);\n\tdcchkstr(len);\n\tstrcat(dcptr,s);\n\tdcptr+=len;\n\tstrsize+=len;\n}\n",
        "output": "0",
        "idx": 1356
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "     void makeCurrent()\n     {\n#if PLATFORM(QT)\n        m_detachedContext = QOpenGLContext::currentContext();\n        if (m_detachedContext)\n            m_detachedSurface = m_detachedContext->surface();\n        if (m_surface && m_glContext)\n            m_glContext->makeCurrent(m_surface.get());\n#elif PLATFORM(EFL)\n         m_detachedContext = glXGetCurrentContext();\n         m_detachedSurface = glXGetCurrentDrawable();\n         if (m_surface && m_glContext)\n             glXMakeCurrent(m_display, m_surface, m_glContext);\n#endif\n     }\n",
        "output": "1",
        "idx": 265
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " bool PrintPreviewMessageHandler::OnMessageReceived(\n     const IPC::Message& message) {\n   bool handled = true;\n  IPC_BEGIN_MESSAGE_MAP(PrintPreviewMessageHandler, message)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_RequestPrintPreview,\n                        OnRequestPrintPreview)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPreviewPageCount,\n                        OnDidGetPreviewPageCount)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage,\n                        OnDidPreviewPage)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_MetafileReadyForPrinting,\n                        OnMetafileReadyForPrinting)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewFailed,\n                        OnPrintPreviewFailed)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetDefaultPageLayout,\n                        OnDidGetDefaultPageLayout)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewCancelled,\n                         OnPrintPreviewCancelled)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewInvalidPrinterSettings,\n                         OnInvalidPrinterSettings)\n     IPC_MESSAGE_UNHANDLED(handled = false)\n   IPC_END_MESSAGE_MAP()\n   return handled;\n}\n",
        "output": "1",
        "idx": 2083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebSettingsImpl::setExperimentalNotificationsEnabled(bool enabled)\n{\n    m_settings->setExperimentalNotificationsEnabled(enabled);\n}\n",
        "output": "1",
        "idx": 1318
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void svc_rdma_xdr_encode_reply_array(struct rpcrdma_write_array *ary,\n\t\t\t\t int chunks)\n{\n\tary->wc_discrim = xdr_one;\n\tary->wc_nchunks = cpu_to_be32(chunks);\n}\n",
        "output": "1",
        "idx": 163
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ProcessIdToFilterMap* GetProcessIdToFilterMap() {\n  static base::NoDestructor<ProcessIdToFilterMap> instance;\n  return instance.get();\n}\n",
        "output": "1",
        "idx": 72
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "seamless_process(STREAM s)\n {\n \tunsigned int pkglen;\n \tchar *buf;\n \n \tpkglen = s->end - s->p;\n \t/* str_handle_lines requires null terminated strings */\n\tbuf = xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\tstr_handle_lines(buf, &seamless_rest, seamless_line_handler, NULL);\n\n\txfree(buf);\n}\n",
        "output": "1",
        "idx": 1268
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Position ComputePositionForChildrenRemoval(const Position& position,\n                                                  ContainerNode& container) {\n  Node* node = position.ComputeContainerNode();\n  if (container.ContainsIncludingHostElements(*node))\n    return Position::FirstPositionInNode(container);\n  return position;\n}\n",
        "output": "0",
        "idx": 793
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PrintMsg_Print_Params::Reset() {\n  page_size = gfx::Size();\n  content_size = gfx::Size();\n  printable_area = gfx::Rect();\n  margin_top = 0;\n  margin_left = 0;\n  dpi = 0;\n  scale_factor = 1.0f;\n  rasterize_pdf = false;\n  document_cookie = 0;\n  selection_only = false;\n  supports_alpha_blend = false;\n  preview_ui_id = -1;\n  preview_request_id = 0;\n  is_first_request = false;\n  print_scaling_option = blink::kWebPrintScalingOptionSourceSize;\n  print_to_pdf = false;\n   display_header_footer = false;\n   title = base::string16();\n   url = base::string16();\n   should_print_backgrounds = false;\n   printed_doc_type = printing::SkiaDocumentType::PDF;\n }\n",
        "output": "1",
        "idx": 401
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pdf_load_version(fz_context *ctx, pdf_document *doc)\n{\n\tchar buf[20];\n\n\tfz_seek(ctx, doc->file, 0, SEEK_SET);\n\tfz_read_line(ctx, doc->file, buf, sizeof buf);\n\tif (memcmp(buf, \"%PDF-\", 5) != 0)\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"cannot recognize version marker\");\n\n\tdoc->version = 10 * (fz_atof(buf+5) + 0.05f);\n\tif (doc->version < 10 || doc->version > 17)\n\t\tif (doc->version != 20)\n\t\t\tfz_warn(ctx, \"unknown PDF version: %d.%d\", doc->version / 10, doc->version % 10);\n}\n",
        "output": "0",
        "idx": 763
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void d_instantiate(struct dentry *entry, struct inode * inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\tif (inode) {\n\t\tsecurity_d_instantiate(entry, inode);\n\t\tspin_lock(&inode->i_lock);\n\t\t__d_instantiate(entry, inode);\n\t\tspin_unlock(&inode->i_lock);\n\t}\n}\n",
        "output": "0",
        "idx": 1697
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void install_local_socket(asocket* s) {\n    adb_mutex_lock(&socket_list_lock);\n \n     s->id = local_socket_next_id++;\n \n     if (local_socket_next_id == 0) {\n        local_socket_next_id = 1;\n     }\n \n     insert_local_socket(s, &local_socket_list);\n    adb_mutex_unlock(&socket_list_lock);\n }\n",
        "output": "1",
        "idx": 222
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  return true;\n}\n",
        "output": "1",
        "idx": 1909
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void InspectorResourceAgent::markResourceAsCached(unsigned long identifier)\n{\n    m_frontend->requestServedFromCache(IdentifiersFactory::requestId(identifier));\n}\n",
        "output": "0",
        "idx": 1910
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned long long Chapters::Atom::GetUID() const\n{\n    return m_uid;\n }\n",
        "output": "1",
        "idx": 1072
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int __hid_register_driver(struct hid_driver *hdrv, struct module *owner,\n\t\tconst char *mod_name)\n{\n\tint ret;\n\n\thdrv->driver.name = hdrv->name;\n\thdrv->driver.bus = &hid_bus_type;\n\thdrv->driver.owner = owner;\n\thdrv->driver.mod_name = mod_name;\n\n\tINIT_LIST_HEAD(&hdrv->dyn_list);\n\tspin_lock_init(&hdrv->dyn_lock);\n\n\tret = driver_register(&hdrv->driver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = driver_create_file(&hdrv->driver, &driver_attr_new_id);\n\tif (ret)\n\t\tdriver_unregister(&hdrv->driver);\n\n\treturn ret;\n}\n",
        "output": "0",
        "idx": 955
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t IPCThreadState::requestDeathNotification(int32_t handle, BpBinder* proxy)\n{\n    mOut.writeInt32(BC_REQUEST_DEATH_NOTIFICATION);\n    mOut.writeInt32((int32_t)handle);\n    mOut.writePointer((uintptr_t)proxy);\n return NO_ERROR;\n}\n",
        "output": "0",
        "idx": 557
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " long ssl_get_algorithm2(SSL *s)\n        {\n        long alg2 = s->s3->tmp.new_cipher->algorithm2;\n       if (TLS1_get_version(s) >= TLS1_2_VERSION &&\n            alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF))\n                return SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256;\n        return alg2;\n\t}\n",
        "output": "1",
        "idx": 1481
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "base::PortProvider* BrowserChildProcessHost::GetPortProvider() {\n  return MachBroker::GetInstance();\n}\n",
        "output": "0",
        "idx": 920
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __detach_mounts(struct dentry *dentry)\n{\n\tstruct mountpoint *mp;\n\tstruct mount *mnt;\n\n\tnamespace_lock();\n\tmp = lookup_mountpoint(dentry);\n\tif (IS_ERR_OR_NULL(mp))\n\t\tgoto out_unlock;\n\n\tlock_mount_hash();\n\twhile (!hlist_empty(&mp->m_list)) {\n\t\tmnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);\n\t\tif (mnt->mnt.mnt_flags & MNT_UMOUNT) {\n\t\t\tstruct mount *p, *tmp;\n\t\t\tlist_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {\n\t\t\t\thlist_add_head(&p->mnt_umount.s_list, &unmounted);\n \t\t\t\tumount_mnt(p);\n \t\t\t}\n \t\t}\n\t\telse umount_tree(mnt, 0);\n \t}\n \tunlock_mount_hash();\n \tput_mountpoint(mp);\nout_unlock:\n\tnamespace_unlock();\n}\n",
        "output": "1",
        "idx": 1660
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void IndexedDBCursor::RemoveCursorFromTransaction() {\n  if (transaction_)\n    transaction_->UnregisterOpenCursor(this);\n}\n",
        "output": "1",
        "idx": 507
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ne2000_buffer_full(NE2000State *s)\n {\n     int avail, index, boundary;\n \n     index = s->curpag << 8;\n     boundary = s->boundary << 8;\n     if (index < boundary)\n        return 1;\n    return 0;\n}\n",
        "output": "1",
        "idx": 1460
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WebPagePrivate::dispatchTouchPointAsMouseEventToFullScreenPlugin(PluginView* pluginView, const Platform::TouchPoint& point)\n{\n     NPEvent npEvent;\n     NPMouseEvent mouse;\n \n    switch (point.m_state) {\n     case Platform::TouchPoint::TouchPressed:\n         mouse.type = MOUSE_BUTTON_DOWN;\n         break;\n    case Platform::TouchPoint::TouchReleased:\n        mouse.type = MOUSE_BUTTON_UP;\n        break;\n    case Platform::TouchPoint::TouchMoved:\n        mouse.type = MOUSE_MOTION;\n        break;\n    case Platform::TouchPoint::TouchStationary:\n         return true;\n     }\n \n    mouse.x = point.m_screenPos.x();\n    mouse.y = point.m_screenPos.y();\n     mouse.button = mouse.type != MOUSE_BUTTON_UP;\n     mouse.flags = 0;\n     npEvent.type = NP_MouseEvent;\n    npEvent.data = &mouse;\n\n    pluginView->dispatchFullScreenNPEvent(npEvent);\n    return true;\n}\n",
        "output": "1",
        "idx": 655
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ScreenRecorder::DoAddConnection(\n    scoped_refptr<ConnectionToClient> connection) {\n  DCHECK(network_loop_->BelongsToCurrentThread());\n  connections_.push_back(connection);\n}\n",
        "output": "1",
        "idx": 1446
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PassRefPtr<DocumentFragment> XSLTProcessor::transformToFragment(Node* sourceNode, Document* outputDoc)\n{\n    String resultMIMEType;\n    String resultString;\n    String resultEncoding;\n\n    if (outputDoc->isHTMLDocument())\n        resultMIMEType = \"text/html\";\n \n     if (!transformToString(sourceNode, resultMIMEType, resultString, resultEncoding))\n         return 0;\n    return createFragmentFromSource(resultString, resultMIMEType, outputDoc);\n }\n",
        "output": "1",
        "idx": 656
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ExtensionsGuestViewMessageFilter::FrameNavigationHelper::FrameNavigationHelper(\n    RenderFrameHost* plugin_rfh,\n    int32_t guest_instance_id,\n    int32_t element_instance_id,\n    bool is_full_page_plugin,\n    ExtensionsGuestViewMessageFilter* filter)\n    : content::WebContentsObserver(\n          content::WebContents::FromRenderFrameHost(plugin_rfh)),\n      frame_tree_node_id_(plugin_rfh->GetFrameTreeNodeId()),\n      guest_instance_id_(guest_instance_id),\n      element_instance_id_(element_instance_id),\n      is_full_page_plugin_(is_full_page_plugin),\n      filter_(filter),\n      parent_site_instance_(plugin_rfh->GetParent()->GetSiteInstance()),\n      weak_factory_(this) {\n  DCHECK(GetGuestView());\n  NavigateToAboutBlank();\n  base::PostDelayedTaskWithTraits(\n      FROM_HERE, {BrowserThread::UI},\n      base::BindOnce(&ExtensionsGuestViewMessageFilter::FrameNavigationHelper::\n                         CancelPendingTask,\n                     weak_factory_.GetWeakPtr()),\n      base::TimeDelta::FromMilliseconds(kAttachFailureDelayMS));\n}\n",
        "output": "1",
        "idx": 2068
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GaiaCookieManagerService::ForceOnCookieChangedProcessing() {\n  GURL google_url = GaiaUrls::GetInstance()->google_url();\n  std::unique_ptr<net::CanonicalCookie> cookie(net::CanonicalCookie::Create(\n      google_url, kGaiaCookieName, std::string(), \".\" + google_url.host(),\n      std::string(), base::Time(), base::Time(), false, false,\n      net::CookieSameSite::DEFAULT_MODE, false, net::COOKIE_PRIORITY_DEFAULT));\n  OnCookieChanged(*cookie, net::CookieStore::ChangeCause::UNKNOWN_DELETION);\n}\n",
        "output": "0",
        "idx": 1200
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ifb_setup(struct net_device *dev)\n{\n\t/* Initialize the device structure. */\n\tdev->destructor = free_netdev;\n\tdev->netdev_ops = &ifb_netdev_ops;\n\n\t/* Fill in device structure with ethernet-generic values. */\n\tether_setup(dev);\n\tdev->tx_queue_len = TX_Q_LIMIT;\n\n\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n \n \tdev->flags |= IFF_NOARP;\n \tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n \trandom_ether_addr(dev->dev_addr);\n }\n",
        "output": "1",
        "idx": 299
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  string cookie_value() {\n    return decoder_->cookie_value_;\n  }\n",
        "output": "0",
        "idx": 1114
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t OMXNodeInstance::getConfig(\n\n         OMX_INDEXTYPE index, void *params, size_t /* size */) {\n     Mutex::Autolock autoLock(mLock);\n \n     OMX_ERRORTYPE err = OMX_GetConfig(mHandle, index, params);\n     OMX_INDEXEXTTYPE extIndex = (OMX_INDEXEXTTYPE)index;\n if (err != OMX_ErrorNoMore) {\n        CLOG_IF_ERROR(getConfig, err, \"%s(%#x)\", asString(extIndex), index);\n }\n return StatusFromOMXError(err);\n}\n",
        "output": "1",
        "idx": 47
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void StoreAccumulatedContentLength(int received_content_length,\n                                   int original_content_length,\n                                   bool data_reduction_proxy_was_used) {\n   BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,\n       base::Bind(&UpdateContentLengthPrefs,\n                  received_content_length, original_content_length,\n                 data_reduction_proxy_was_used));\n }\n",
        "output": "1",
        "idx": 545
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "OMX_ERRORTYPE SimpleSoftOMXComponent::internalSetParameter(\n        OMX_INDEXTYPE index, const OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamPortDefinition:\n {\n\n             OMX_PARAM_PORTDEFINITIONTYPE *defParams =\n                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;\n \n             if (defParams->nPortIndex >= mPorts.size()) {\n                 return OMX_ErrorBadPortIndex;\n             }\n if (defParams->nSize != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {\n return OMX_ErrorUnsupportedSetting;\n }\n\n PortInfo *port =\n &mPorts.editItemAt(defParams->nPortIndex);\n\n if (defParams->nBufferSize > port->mDef.nBufferSize) {\n                port->mDef.nBufferSize = defParams->nBufferSize;\n }\n\n if (defParams->nBufferCountActual < port->mDef.nBufferCountMin) {\n                ALOGW(\"component requires at least %u buffers (%u requested)\",\n                        port->mDef.nBufferCountMin, defParams->nBufferCountActual);\n return OMX_ErrorUnsupportedSetting;\n }\n\n            port->mDef.nBufferCountActual = defParams->nBufferCountActual;\n return OMX_ErrorNone;\n }\n\n default:\n return OMX_ErrorUnsupportedIndex;\n }\n}\n",
        "output": "1",
        "idx": 708
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t handle_readlink(FsContext *fs_ctx, V9fsPath *fs_path,\n                               char *buf, size_t bufsz)\n{\n    int fd, ret;\n    struct handle_data *data = (struct handle_data *)fs_ctx->private;\n\n    fd = open_by_handle(data->mountfd, fs_path->data, O_PATH);\n    if (fd < 0) {\n        return fd;\n    }\n    ret = readlinkat(fd, \"\", buf, bufsz);\n    close(fd);\n    return ret;\n}\n",
        "output": "0",
        "idx": 157
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int devicenrange(i_ctx_t * i_ctx_p, ref *space, float *ptr)\n{\n    int i, limit, code;\n    PS_colour_space_t *cspace;\n\n    ref altspace;\n\n    code = array_get(imemory, space, 1, &altspace);\n    if (code < 0)\n        return code;\n\n    code = get_space_object(i_ctx_p, &altspace, &cspace);\n    if (code < 0)\n        return code;\n\n    code = cspace->numcomponents(i_ctx_p, &altspace, &limit);\n    if (code < 0)\n        return code;\n\n    for (i = 0;i < limit * 2;i+=2) {\n        ptr[i] = 0;\n        ptr[i+1] = 1;\n    }\n    return 0;\n}\n",
        "output": "0",
        "idx": 843
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bt_for_each(struct blk_mq_hw_ctx *hctx,\n\t\tstruct blk_mq_bitmap_tags *bt, unsigned int off,\n\t\tbusy_iter_fn *fn, void *data, bool reserved)\n{\n\tstruct request *rq;\n\tint bit, i;\n\n\tfor (i = 0; i < bt->map_nr; i++) {\n\t\tstruct blk_align_bitmap *bm = &bt->map[i];\n\n \t\tfor (bit = find_first_bit(&bm->word, bm->depth);\n \t\t     bit < bm->depth;\n \t\t     bit = find_next_bit(&bm->word, bm->depth, bit + 1)) {\n\t\t     \trq = blk_mq_tag_to_rq(hctx->tags, off + bit);\n \t\t\tif (rq->q == hctx->queue)\n \t\t\t\tfn(hctx, rq, data, reserved);\n \t\t}\n\n\t\toff += (1 << bt->bits_per_word);\n\t}\n}\n",
        "output": "1",
        "idx": 635
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void ChromeMockRenderThread::OnMsgOpenChannelToExtension(\n    int routing_id, const std::string& source_extension_id,\n     const std::string& target_extension_id,\n    const std::string& channel_name, int* port_id) {\n   *port_id = 0;\n }\n",
        "output": "1",
        "idx": 1221
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " SendTabToSelfInfoBarDelegate::SendTabToSelfInfoBarDelegate(\n     const SendTabToSelfEntry* entry) {\n   entry_ = entry;\n }\n",
        "output": "1",
        "idx": 868
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int opfiadd(RAsm *a, ut8 *data, const Opcode *op) {\n\tint l = 0;\n\tswitch (op->operands_count) {\n\tcase 1:\n\t\tif ( op->operands[0].type & OT_MEMORY ) {\n\t\t\tif ( op->operands[0].type & OT_WORD ) {\n\t\t\t\tdata[l++] = 0xde;\n\t\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t\t} else if ( op->operands[0].type & OT_DWORD ) {\n\t\t\t\tdata[l++] = 0xda;\n\t\t\t\tdata[l++] = 0x00 | op->operands[0].regs[0];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn l;\n}\n",
        "output": "0",
        "idx": 1379
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n {\n\tassign_eip_near(ctxt, ctxt->_eip + rel);\n }\n",
        "output": "1",
        "idx": 1099
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "format_STACK_POP(const struct ofpact_stack *a, struct ds *s)\n{\n    nxm_format_stack_pop(a, s);\n}\n",
        "output": "0",
        "idx": 890
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void usb_net_reset_in_buf(USBNetState *s)\n{\n    s->in_ptr = s->in_len = 0;\n    qemu_flush_queued_packets(qemu_get_queue(s->nic));\n}\n",
        "output": "0",
        "idx": 1257
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameHostImpl::SetCommitCallbackInterceptorForTesting(\n    CommitCallbackInterceptor* interceptor) {\n  DCHECK(!commit_callback_interceptor_ || !interceptor);\n  commit_callback_interceptor_ = interceptor;\n}\n",
        "output": "0",
        "idx": 1768
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "encode_UNROLL_XLATE(const struct ofpact_unroll_xlate *unroll OVS_UNUSED,\n                    enum ofp_version ofp_version OVS_UNUSED,\n                    struct ofpbuf *out OVS_UNUSED)\n{\n    OVS_NOT_REACHED();\n}\n",
        "output": "0",
        "idx": 829
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *path_name(const struct name_path *path, const char *name)\n{\n\tconst struct name_path *p;\n\tchar *n, *m;\n\tint nlen = strlen(name);\n\tint len = nlen + 1;\n\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len)\n\t\t\tlen += p->elem_len + 1;\n \t}\n \tn = xmalloc(len);\n \tm = n + len - (nlen + 1);\n\tstrcpy(m, name);\n \tfor (p = path; p; p = p->up) {\n \t\tif (p->elem_len) {\n \t\t\tm -= p->elem_len + 1;\n\t\t\tmemcpy(m, p->elem, p->elem_len);\n\t\t\tm[p->elem_len] = '/';\n\t\t}\n\t}\n\treturn n;\n}\n",
        "output": "1",
        "idx": 370
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HTMLInputElement::setSize(unsigned size)\n{\n    setAttribute(sizeAttr, String::number(size));\n}\n",
        "output": "0",
        "idx": 1659
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual void Observe(NotificationType type,\n                       const NotificationSource& source,\n                       const NotificationDetails& details) {\n    if (type == NotificationType::NAV_LIST_PRUNED) {\n      notification_count_++;\n      details_ = *(Details<NavigationController::PrunedDetails>(details).ptr());\n    }\n  }\n",
        "output": "0",
        "idx": 1017
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool name_is_in_groupnames(char *name, char **groupnames)\n{\n\twhile (groupnames != NULL) {\n\t\tif (strcmp(name, *groupnames) == 0)\n\t\t\treturn true;\n\t\tgroupnames++;\n\t}\n\treturn false;\n}\n",
        "output": "0",
        "idx": 1519
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderBox::panScroll(const IntPoint& source)\n{\n    if (layer())\n        layer()->panScrollFromPoint(source);\n}\n",
        "output": "0",
        "idx": 1308
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void ImageBitmapFactories::ImageBitmapLoader::Trace(blink::Visitor* visitor) {\n   visitor->Trace(factory_);\n   visitor->Trace(resolver_);\n   visitor->Trace(options_);\n}\n",
        "output": "1",
        "idx": 550
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebPluginDelegateProxy::CopyFromTransportToBacking(const gfx::Rect& rect) {\n  if (!backing_store_canvas_.get()) {\n    return;\n  }\n\n#if defined(OS_MACOSX)\n  const size_t stride =\n      skia::PlatformCanvas::StrideForWidth(plugin_rect_.width());\n  const size_t chunk_size = 4 * rect.width();\n  uint8* source_data = static_cast<uint8*>(transport_store_->memory()) +\n                       rect.y() * stride + 4 * rect.x();\n  int dest_starting_row = plugin_rect_.height() - rect.y() - 1;\n  DCHECK(backing_store_.size() > 0);\n  uint8* target_data = &(backing_store_[0]) + dest_starting_row * stride +\n                       4 * rect.x();\n  for (int row = 0; row < rect.height(); ++row) {\n    memcpy(target_data, source_data, chunk_size);\n    source_data += stride;\n    target_data -= stride;\n  }\n#else\n  BlitCanvasToCanvas(backing_store_canvas_.get(), rect,\n                     transport_store_canvas_.get(), rect.origin());\n#endif\n  backing_store_painted_ = backing_store_painted_.Union(rect);\n}\n",
        "output": "0",
        "idx": 1821
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main(int argc, char *argv[])\n{\n\tint ret;\n\tstruct lxc_lock *lock;\n\n\tlock = lxc_newlock(NULL, NULL);\n\tif (!lock) {\n\t\tfprintf(stderr, \"%d: failed to get unnamed lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tret = lxclock(lock, 0);\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to take unnamed lock (%d)\\n\", __LINE__, ret);\n\t\texit(1);\n\t}\n\n\tret = lxcunlock(lock);\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to put unnamed lock (%d)\\n\", __LINE__, ret);\n\t\texit(1);\n\t}\n\tlxc_putlock(lock);\n\n\tlock = lxc_newlock(\"/var/lib/lxc\", mycontainername);\n\tif (!lock) {\n\t\tfprintf(stderr, \"%d: failed to get lock\\n\", __LINE__);\n \t\texit(1);\n \t}\n \tstruct stat sb;\n\tchar *pathname = RUNTIME_PATH \"/lock/lxc/var/lib/lxc/\";\n \tret = stat(pathname, &sb);\n \tif (ret != 0) {\n \t\tfprintf(stderr, \"%d: filename %s not created\\n\", __LINE__,\n\t\t\tpathname);\n\t\texit(1);\n\t}\n\tlxc_putlock(lock);\n\n\ttest_two_locks();\n\n\tfprintf(stderr, \"all tests passed\\n\");\n\n\texit(ret);\n}\n",
        "output": "1",
        "idx": 462
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int BN_hex2bn(BIGNUM **bn, const char *a)\n{\n    BIGNUM *ret = NULL;\n    BN_ULONG l = 0;\n    int neg = 0, h, m, i, j, k, c;\n    int num;\n\n    if ((a == NULL) || (*a == '\\0'))\n        return (0);\n\n    if (*a == '-') {\n        neg = 1;\n        a++;\n         a++;\n     }\n \n    for (i = 0; isxdigit((unsigned char)a[i]); i++) ;\n \n     num = i + neg;\n     if (bn == NULL)\n            return (0);\n    } else {\n        ret = *bn;\n        BN_zero(ret);\n    }\n",
        "output": "1",
        "idx": 942
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AllocateDataSet(cmsIT8* it8)\n{\n    TABLE* t = GetTable(it8);\n\n    if (t -> Data) return;    // Already allocated\n\n     t-> nSamples   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_FIELDS\"));\n     t-> nPatches   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n \n    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));\n    if (t->Data == NULL) {\n \n        SynError(it8, \"AllocateDataSet: Unable to allocate data array\");\n     }\n \n }\n",
        "output": "1",
        "idx": 1932
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderWidgetHostImpl::DidNavigate(uint32_t next_source_id) {\n  current_content_source_id_ = next_source_id;\n  did_receive_first_frame_after_navigation_ = false;\n\n  if (enable_surface_synchronization_) {\n     visual_properties_ack_pending_ = false;\n    viz::LocalSurfaceId old_surface_id = view_->GetLocalSurfaceId();\n     if (view_)\n       view_->DidNavigate();\n    viz::LocalSurfaceId new_surface_id = view_->GetLocalSurfaceId();\n    if (old_surface_id == new_surface_id)\n      return;\n   } else {\n    if (last_received_content_source_id_ >= current_content_source_id_)\n      return;\n  }\n\n  if (!new_content_rendering_timeout_)\n    return;\n\n  new_content_rendering_timeout_->Start(new_content_rendering_delay_);\n}\n",
        "output": "1",
        "idx": 1289
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " rs_filter_graph(RSFilter *filter)\n {\n \tg_return_if_fail(RS_IS_FILTER(filter));\n \tGString *str = g_string_new(\"digraph G {\\n\");\n \n \trs_filter_graph_helper(str, filter);\n \n \tg_string_append_printf(str, \"}\\n\");\n\tg_file_set_contents(\"/tmp/rs-filter-graph\", str->str, str->len, NULL);\n \n\tif (0 != system(\"dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph\"))\n \t\tg_warning(\"Calling dot failed\");\n\tif (0 != system(\"gnome-open /tmp/rs-filter-graph.png\"))\n \t\tg_warning(\"Calling gnome-open failed.\");\n \n \tg_string_free(str, TRUE);\n }\n",
        "output": "1",
        "idx": 908
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void ReconfigureImpl(Handle<JSObject> object,\n Handle<FixedArrayBase> store, uint32_t entry,\n Handle<Object> value,\n PropertyAttributes attributes) {\n Handle<SeededNumberDictionary> dictionary =\n JSObject::NormalizeElements(object);\n FixedArray::cast(*store)->set(1, *dictionary);\n uint32_t length = static_cast<uint32_t>(store->length()) - 2;\n if (entry >= length) {\n      entry = dictionary->FindEntry(entry - length) + length;\n }\n SlowSloppyArgumentsElementsAccessor::ReconfigureImpl(object, store, entry,\n                                                         value, attributes);\n }\n",
        "output": "0",
        "idx": 130
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mwifiex_update_vs_ie(const u8 *ies, int ies_len,\n\t\t\t\tstruct mwifiex_ie **ie_ptr, u16 mask,\n\t\t\t\tunsigned int oui, u8 oui_type)\n{\n\tstruct ieee_types_header *vs_ie;\n\tstruct mwifiex_ie *ie = *ie_ptr;\n\tconst u8 *vendor_ie;\n\n\tvendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len);\n\tif (vendor_ie) {\n\t\tif (!*ie_ptr) {\n\t\t\t*ie_ptr = kzalloc(sizeof(struct mwifiex_ie),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!*ie_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tie = *ie_ptr;\n \t\t}\n \n \t\tvs_ie = (struct ieee_types_header *)vendor_ie;\n \t\tmemcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),\n \t\t       vs_ie, vs_ie->len + 2);\n \t\tle16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);\n\t\tie->mgmt_subtype_mask = cpu_to_le16(mask);\n\t\tie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);\n\t}\n\n\t*ie_ptr = ie;\n\treturn 0;\n}\n",
        "output": "1",
        "idx": 1251
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BOOL license_read_scope_list(wStream* s, SCOPE_LIST* scopeList)\n{\n\tUINT32 i;\n\tUINT32 scopeCount;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n \n \tStream_Read_UINT32(s, scopeCount); /* ScopeCount (4 bytes) */\n \n \tscopeList->count = scopeCount;\n \tscopeList->array = (LICENSE_BLOB*) malloc(sizeof(LICENSE_BLOB) * scopeCount);\n \n\t/* ScopeArray */\n\tfor (i = 0; i < scopeCount; i++)\n\t{\n\t\tscopeList->array[i].type = BB_SCOPE_BLOB;\n\n\t\tif (!license_read_binary_blob(s, &scopeList->array[i]))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n",
        "output": "1",
        "idx": 1665
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool effect_exists(effect_context_t *context)\n{\n struct listnode *node;\n\n    list_for_each(node, &created_effects_list) {\n effect_context_t *fx_ctxt = node_to_item(node,\n effect_context_t,\n                                                 effects_list_node);\n if (fx_ctxt == context) {\n return true;\n }\n }\n return false;\n}\n",
        "output": "0",
        "idx": 230
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool JSTestInterfaceConstructor::getOwnPropertySlot(JSCell* cell, ExecState* exec, const Identifier& propertyName, PropertySlot& slot)\n{\n    return getStaticPropertySlot<JSTestInterfaceConstructor, JSDOMWrapper>(exec, &JSTestInterfaceConstructorTable, jsCast<JSTestInterfaceConstructor*>(cell), propertyName, slot);\n}\n",
        "output": "0",
        "idx": 124
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " SPL_METHOD(SplFileObject, next)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {\n\t\tspl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC);\n\t}\n\tintern->u.file.current_line_num++;\n} /* }}} */\n\n/* {{{ proto void SplFileObject::setFlags(int flags)\n",
        "output": "1",
        "idx": 1012
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "AtomicString GetInputModeAttribute(Element* element) {\n  if (!element)\n    return AtomicString();\n\n  bool query_attribute = false;\n  if (isHTMLInputElement(*element)) {\n    query_attribute = toHTMLInputElement(*element).SupportsInputModeAttribute();\n  } else if (isHTMLTextAreaElement(*element)) {\n    query_attribute = true;\n  } else {\n    element->GetDocument().UpdateStyleAndLayoutTree();\n    if (HasEditableStyle(*element))\n      query_attribute = true;\n  }\n\n  if (!query_attribute)\n    return AtomicString();\n\n  return element->FastGetAttribute(HTMLNames::inputmodeAttr).DeprecatedLower();\n}\n",
        "output": "0",
        "idx": 383
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n \t\t\t\t   u16 selector, int seg)\n {\n \tu8 cpl = ctxt->ops->cpl(ctxt);\n \treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n \t\t\t\t\t X86_TRANSFER_NONE, NULL);\n }\n",
        "output": "1",
        "idx": 2091
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " FilePath ExtensionPrefs::GetExtensionPath(const std::string& extension_id) {\n   const DictionaryValue* dict = GetExtensionPref(extension_id);\n   std::string path;\n   if (!dict->GetString(kPrefPath, &path))\n     return FilePath();\n\n  return install_directory_.Append(FilePath::FromWStringHack(UTF8ToWide(path)));\n}\n",
        "output": "1",
        "idx": 1108
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "LayoutUnit RenderBox::computeReplacedLogicalWidthRespectingMinMaxWidth(LayoutUnit logicalWidth, ShouldComputePreferred shouldComputePreferred) const\n{\n    LayoutUnit minLogicalWidth = (shouldComputePreferred == ComputePreferred && style()->logicalMinWidth().isPercent()) || style()->logicalMinWidth().isUndefined() ? logicalWidth : computeReplacedLogicalWidthUsing(style()->logicalMinWidth());\n    LayoutUnit maxLogicalWidth = (shouldComputePreferred == ComputePreferred && style()->logicalMaxWidth().isPercent()) || style()->logicalMaxWidth().isUndefined() ? logicalWidth : computeReplacedLogicalWidthUsing(style()->logicalMaxWidth());\n    return max(minLogicalWidth, min(logicalWidth, maxLogicalWidth));\n}\n",
        "output": "0",
        "idx": 605
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void OffscreenCanvasFrameReceiverImpl::SubmitCompositorFrame(\n     const cc::SurfaceId& surface_id,\n     cc::CompositorFrame frame) {\n    cc::Surface* surface = GetSurfaceManager()->GetSurfaceForId(surface_id);\n    if (surface) {\n        surface->QueueFrame(std::move(frame), base::Closure());\n     }\n }\n",
        "output": "1",
        "idx": 1093
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void ieee80211_if_setup(struct net_device *dev)\n {\n \tether_setup(dev);\n \tdev->netdev_ops = &ieee80211_dataif_ops;\n \tdev->destructor = free_netdev;\n }\n",
        "output": "1",
        "idx": 386
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void OffscreenCanvasSurfaceImpl::Create(\n    mojo::InterfaceRequest<blink::mojom::OffscreenCanvasSurface> request) {\n  mojo::MakeStrongBinding(base::MakeUnique<OffscreenCanvasSurfaceImpl>(),\n                          std::move(request));\n}\n",
        "output": "0",
        "idx": 326
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::unique_ptr<BlobDataHandle> BlobStorageContext::GetBlobDataFromPublicURL(\n    const GURL& url) {\n  std::string uuid;\n  BlobEntry* entry = registry_.GetEntryFromURL(url, &uuid);\n  if (!entry)\n    return nullptr;\n  return CreateHandle(uuid, entry);\n}\n",
        "output": "0",
        "idx": 542
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TextAutosizer::processCluster(RenderBlock* cluster, RenderBlock* container, RenderObject* subtreeRoot, const TextAutosizingWindowInfo& windowInfo)\n{\n    ASSERT(isAutosizingCluster(cluster));\n\n    RenderBlock* lowestCommonAncestor = cluster;\n    float commonAncestorWidth = lowestCommonAncestor->contentLogicalWidth();\n\n    float multiplier = 1;\n    if (clusterShouldBeAutosized(lowestCommonAncestor, commonAncestorWidth)) {\n        int logicalWindowWidth = cluster->isHorizontalWritingMode() ? windowInfo.windowSize.width() : windowInfo.windowSize.height();\n        int logicalLayoutWidth = cluster->isHorizontalWritingMode() ? windowInfo.minLayoutSize.width() : windowInfo.minLayoutSize.height();\n        float logicalClusterWidth = std::min<float>(commonAncestorWidth, logicalLayoutWidth);\n\n        multiplier = logicalClusterWidth / logicalWindowWidth;\n        multiplier *= m_document->settings()->textAutosizingFontScaleFactor();\n        multiplier = std::max(1.0f, multiplier);\n    }\n\n    processContainer(multiplier, container, subtreeRoot, windowInfo);\n}\n",
        "output": "0",
        "idx": 2024
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nm_setting_vpn_foreach_secret (NMSettingVPN *setting,\n                               NMVPNIterFunc func,\n                               gpointer user_data)\n{\n\tg_return_if_fail (setting != NULL);\n\tg_return_if_fail (NM_IS_SETTING_VPN (setting));\n\n\tforeach_item_helper (NM_SETTING_VPN_GET_PRIVATE (setting)->secrets, func, user_data);\n}\n",
        "output": "0",
        "idx": 1008
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool SendNativeKeyEventJSONRequest(\n    AutomationMessageSender* sender,\n    int browser_index,\n    int tab_index,\n    ui::KeyboardCode key_code,\n    int modifiers,\n    std::string* error_msg) {\n  DictionaryValue dict;\n  dict.SetString(\"command\", \"SendOSLevelKeyEventToTab\");\n  dict.SetInteger(\"windex\", browser_index);\n  dict.SetInteger(\"tab_index\", tab_index);\n  dict.SetInteger(\"keyCode\", key_code);\n  dict.SetInteger(\"modifiers\", modifiers);\n  DictionaryValue reply_dict;\n  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);\n}\n",
        "output": "0",
        "idx": 820
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    StateBase* handleError(Status errorStatus, const String& message, StateBase* state)\n    {\n        ASSERT(errorStatus != Success);\n        m_status = errorStatus;\n        m_errorMessage = message;\n        while (state) {\n            StateBase* tmp = state->nextState();\n            delete state;\n            state = tmp;\n        }\n        return new ErrorState;\n    }\n",
        "output": "0",
        "idx": 1899
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,\n\t\t\tstruct sock *sk)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n \n \tev->type   = LLC_SAP_EV_TYPE_PDU;\n \tev->reason = 0;\n \tskb->sk = sk;\n \tllc_sap_state_process(sap, skb);\n }\n",
        "output": "1",
        "idx": 1696
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n {\n \tvoid* pointer;\n \n\tif (!handle)\n \t\treturn NULL;\n \n \tpointer = (void*) ~((size_t) handle->dwLower);\n\n\treturn pointer;\n}\n",
        "output": "1",
        "idx": 1151
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,\n\t\t\t   const struct qstr *name,\n\t\t\t   struct nfs4_fs_locations *fs_locations,\n\t\t\t   struct page *page)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = _nfs4_proc_fs_locations(client, dir, name,\n\t\t\t\tfs_locations, page);\n\t\ttrace_nfs4_get_fs_locations(dir, name, err);\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir), err,\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}\n",
        "output": "0",
        "idx": 2002
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CuePoint::~CuePoint()\n{\n    delete[] m_track_positions;\n}\n",
        "output": "1",
        "idx": 1035
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WebsiteSettingsPopupAndroid::WebsiteSettingsPopupAndroid(\n    JNIEnv* env,\n    jobject java_website_settings_pop,\n    content::WebContents* web_contents) {\n  content::NavigationEntry* nav_entry =\n      web_contents->GetController().GetVisibleEntry();\n  if (nav_entry == NULL)\n    return;\n\n  url_ = nav_entry->GetURL();\n\n  popup_jobject_.Reset(env, java_website_settings_pop);\n\n  presenter_.reset(new WebsiteSettings(\n       this,\n       Profile::FromBrowserContext(web_contents->GetBrowserContext()),\n       TabSpecificContentSettings::FromWebContents(web_contents),\n      InfoBarService::FromWebContents(web_contents),\n       nav_entry->GetURL(),\n       nav_entry->GetSSL(),\n       content::CertStore::GetInstance()));\n}\n",
        "output": "1",
        "idx": 2079
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error::Error GLES2DecoderPassthroughImpl::DoScheduleCALayerCHROMIUM(\n    GLuint contents_texture_id,\n    const GLfloat* contents_rect,\n    GLuint background_color,\n    GLuint edge_aa_mask,\n    const GLfloat* bounds_rect) {\n  NOTIMPLEMENTED();\n  return error::kNoError;\n}\n",
        "output": "0",
        "idx": 751
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   bool ReceiverWasAdded(const RtpTransceiverState& transceiver_state) {\n     uintptr_t receiver_id = RTCRtpReceiver::getId(\n         transceiver_state.receiver_state()->webrtc_receiver().get());\n     for (const auto& receiver : handler_->rtp_receivers_) {\n      if (receiver->Id() == receiver_id)\n        return false;\n    }\n    return true;\n  }\n",
        "output": "1",
        "idx": 307
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t eth_rx(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    struct xlx_ethlite *s = qemu_get_nic_opaque(nc);\n    unsigned int rxbase = s->rxbuf * (0x800 / 4);\n\n    /* DA filter.  */\n    if (!(buf[0] & 0x80) && memcmp(&s->conf.macaddr.a[0], buf, 6))\n        return size;\n\n    if (s->regs[rxbase + R_RX_CTRL0] & CTRL_S) {\n        D(qemu_log(\"ethlite lost packet %x\\n\", s->regs[R_RX_CTRL0]));\n        return -1;\n     }\n \n     D(qemu_log(\"%s %zd rxbase=%x\\n\", __func__, size, rxbase));\n     memcpy(&s->regs[rxbase + R_RX_BUF0], buf, size);\n \n     s->regs[rxbase + R_RX_CTRL0] |= CTRL_S;\n    /* If c_rx_pingpong was set flip buffers.  */\n    s->rxbuf ^= s->c_rx_pingpong;\n    return size;\n}\n",
        "output": "1",
        "idx": 904
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vapic_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint idx;\n\n\tif (!apic || !apic->vapic_addr)\n\t\treturn;\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_release_page_dirty(apic->vapic_page);\n\tmark_page_dirty(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n}\n",
        "output": "0",
        "idx": 537
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " SPL_METHOD(SplFileObject, valid)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {\n\t\tRETURN_BOOL(intern->u.file.current_line || intern->u.file.current_zval);\n\t} else {\n\t\tRETVAL_BOOL(!php_stream_eof(intern->u.file.stream));\n\t}\n} /* }}} */\n\n/* {{{ proto string SplFileObject::fgets()\n",
        "output": "1",
        "idx": 1357
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void SynchronousCompositorImpl::PostInvalidate() {\n   DCHECK(CalledOnValidThread());\n   DCHECK(compositor_client_);\n  compositor_client_->PostInvalidate();\n }\n",
        "output": "1",
        "idx": 152
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const std::string& WebContentsImpl::GetUserAgentOverride() const {\n  return renderer_preferences_.user_agent_override;\n}\n",
        "output": "0",
        "idx": 1632
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   void DoTest(ExternalProtocolHandler::BlockState block_state,\n               shell_integration::DefaultWebClientState os_state,\n               Action expected_action) {\n    GURL url(\"mailto:test@test.com\");\n     EXPECT_FALSE(delegate_.has_prompted());\n     EXPECT_FALSE(delegate_.has_launched());\n     EXPECT_FALSE(delegate_.has_blocked());\n\n    delegate_.set_block_state(block_state);\n    delegate_.set_os_state(os_state);\n    ExternalProtocolHandler::LaunchUrlWithDelegate(\n        url, 0, 0, ui::PAGE_TRANSITION_LINK, true, &delegate_);\n    content::RunAllTasksUntilIdle();\n\n    EXPECT_EQ(expected_action == Action::PROMPT, delegate_.has_prompted());\n    EXPECT_EQ(expected_action == Action::LAUNCH, delegate_.has_launched());\n    EXPECT_EQ(expected_action == Action::BLOCK, delegate_.has_blocked());\n  }\n",
        "output": "1",
        "idx": 469
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " set_text_distance(gs_point *pdist, double dx, double dy, const gs_matrix *pmat)\n {\n    int code = gs_distance_transform_inverse(dx, dy, pmat, pdist);\n     double rounded;\n \n     if (code == gs_error_undefinedresult) {\n         /* The CTM is degenerate.\n            Can't know the distance in user space.\n    } else if (code < 0)\n        return code;\n    /* If the distance is very close to integers, round it. */\n    if (fabs(pdist->x - (rounded = floor(pdist->x + 0.5))) < 0.0005)\n        pdist->x = rounded;\n    if (fabs(pdist->y - (rounded = floor(pdist->y + 0.5))) < 0.0005)\n        pdist->y = rounded;\n    return 0;\n}\n",
        "output": "1",
        "idx": 1566
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,\n                               xmlNodePtr cur)\n {\n     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);\n    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||\n\t(ctxt->context->node->type == XML_NAMESPACE_DECL))\n\treturn(NULL);\n     if (cur == NULL) {\n         cur = ctxt->context->node;\n         if (cur == NULL)\n             return (NULL);\n         ctxt->ancestor = cur->parent;\n     }\n     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))\n\tcur = cur->prev;\n    while (cur->prev == NULL) {\n        cur = cur->parent;\n        if (cur == NULL)\n            return (NULL);\n        if (cur == ctxt->context->doc->children)\n            return (NULL);\n        if (cur != ctxt->ancestor)\n            return (cur);\n        ctxt->ancestor = cur->parent;\n    }\n    cur = cur->prev;\n    while (cur->last != NULL)\n        cur = cur->last;\n    return (cur);\n}\n",
        "output": "1",
        "idx": 805
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PlatformSensorProviderLinux::FreeResources() {\n  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n  DCHECK(file_task_runner_);\n  Shutdown();\n  file_task_runner_->PostTask(\n      FROM_HERE, base::Bind(&PlatformSensorProviderLinux::StopPollingThread,\n                            base::Unretained(this)));\n}\n",
        "output": "0",
        "idx": 1878
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void removeElementPreservingChildren(PassRefPtr<DocumentFragment> fragment, HTMLElement* element)\n{\n    ExceptionCode ignoredExceptionCode;\n    RefPtr<Node> nextChild;\n    for (RefPtr<Node> child = element->firstChild(); child; child = nextChild) {\n        nextChild = child->nextSibling();\n        element->removeChild(child.get(), ignoredExceptionCode);\n        ASSERT(!ignoredExceptionCode);\n        fragment->insertBefore(child, element, ignoredExceptionCode);\n        ASSERT(!ignoredExceptionCode);\n    }\n    fragment->removeChild(element, ignoredExceptionCode);\n    ASSERT(!ignoredExceptionCode);\n}\n",
        "output": "1",
        "idx": 716
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "LayoutUnit RenderFlexibleBox::crossAxisExtentForChild(RenderBox* child) const\n{\n    return isHorizontalFlow() ? child->height() : child->width();\n}\n",
        "output": "0",
        "idx": 212
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  Ins_OR( INS_ARG )\n  {\n    DO_OR\n  }\n",
        "output": "0",
        "idx": 451
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " int SoundPool::load(int fd, int64_t offset, int64_t length, int priority __unused)\n {\n     ALOGV(\"load: fd=%d, offset=%\" PRId64 \", length=%\" PRId64 \", priority=%d\",\n             fd, offset, length, priority);\n    Mutex::Autolock lock(&mLock);\n    sp<Sample> sample = new Sample(++mNextSampleID, fd, offset, length);\n    mSamples.add(sample->sampleID(), sample);\n    doLoad(sample);\n    return sample->sampleID();\n}\n",
        "output": "1",
        "idx": 1581
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "media::AudioParameters GetDeviceParametersOnDeviceThread(\n    media::AudioManager* audio_manager,\n    const std::string& unique_id) {\n  DCHECK(audio_manager->GetTaskRunner()->BelongsToCurrentThread());\n  return media::AudioDeviceDescription::IsDefaultDevice(unique_id)\n             ? audio_manager->GetDefaultOutputStreamParameters()\n             : audio_manager->GetOutputStreamParameters(unique_id);\n}\n",
        "output": "1",
        "idx": 131
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DiceResponseHandler::DeleteTokenFetcher(DiceTokenFetcher* token_fetcher) {\n  for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {\n    if (it->get() == token_fetcher) {\n      token_fetchers_.erase(it);\n      return;\n    }\n  }\n  NOTREACHED();\n}\n",
        "output": "0",
        "idx": 588
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kill_something_info(int sig, struct siginfo *info, pid_t pid)\n{\n\tint ret;\n\n\tif (pid > 0) {\n\t\trcu_read_lock();\n\t\tret = kill_pid_info(sig, info, find_vpid(pid));\n\t\trcu_read_unlock();\n \t\treturn ret;\n \t}\n \n \tread_lock(&tasklist_lock);\n \tif (pid != -1) {\n \t\tret = __kill_pgrp_info(sig, info,\n\t\t\t\tpid ? find_vpid(-pid) : task_pgrp(current));\n\t} else {\n\t\tint retval = 0, count = 0;\n\t\tstruct task_struct * p;\n\n\t\tfor_each_process(p) {\n\t\t\tif (task_pid_vnr(p) > 1 &&\n\t\t\t\t\t!same_thread_group(p, current)) {\n\t\t\t\tint err = group_send_sig_info(sig, info, p);\n\t\t\t\t++count;\n\t\t\t\tif (err != -EPERM)\n\t\t\t\t\tretval = err;\n\t\t\t}\n\t\t}\n\t\tret = count ? retval : -ESRCH;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\treturn ret;\n}\n",
        "output": "1",
        "idx": 1083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "OMX_ERRORTYPE SoftRaw::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch (index) {\n case OMX_IndexParamAudioPcm:\n {\n\n             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n \n             if (pcmParams->nPortIndex != 0 && pcmParams->nPortIndex != 1) {\n                 return OMX_ErrorUndefined;\n             }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mChannelCount;\n            pcmParams->nSamplingRate = mSampleRate;\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n",
        "output": "1",
        "idx": 1398
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int parse_token(char **name, char **value, char **cp)\n{\n\tchar *end;\n\n\tif (!name || !value || !cp)\n\t\treturn -BLKID_ERR_PARAM;\n\n\tif (!(*value = strchr(*cp, '=')))\n\t\treturn 0;\n\n\t**value = '\\0';\n\t*name = strip_line(*cp);\n \t*value = skip_over_blank(*value + 1);\n \n \tif (**value == '\"') {\n\t\tend = strchr(*value + 1, '\"');\n\t\tif (!end) {\n \t\t\tDBG(READ, ul_debug(\"unbalanced quotes at: %s\", *value));\n \t\t\t*cp = *value;\n \t\t\treturn -BLKID_ERR_CACHE;\n \t\t}\n \t\t(*value)++;\n \t\t*end = '\\0';\n\t\tend++;\n \t} else {\n \t\tend = skip_over_word(*value);\n \t\tif (*end) {\n\t\t\t*end = '\\0';\n\t\t\tend++;\n\t\t}\n\t}\n\t*cp = end;\n\n\treturn 1;\n}\n",
        "output": "1",
        "idx": 1154
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ASN1_OBJECT *OBJ_txt2obj(const char *s, int no_name)\n\t{\n\tint nid = NID_undef;\n\tASN1_OBJECT *op=NULL;\n\tunsigned char *buf;\n\tunsigned char *p;\n\tconst unsigned char *cp;\n\tint i, j;\n\n\tif(!no_name) {\n\t\tif( ((nid = OBJ_sn2nid(s)) != NID_undef) ||\n\t\t\t((nid = OBJ_ln2nid(s)) != NID_undef) ) \n\t\t\t\t\treturn OBJ_nid2obj(nid);\n\t}\n\n\t/* Work out size of content octets */\n\ti=a2d_ASN1_OBJECT(NULL,0,s,-1);\n\tif (i <= 0) {\n\t\t/* Don't clear the error */\n\t\t/*ERR_clear_error();*/\n\t\treturn NULL;\n\t}\n\t/* Work out total size */\n\tj = ASN1_object_size(0,i,V_ASN1_OBJECT);\n\n\tif((buf=(unsigned char *)OPENSSL_malloc(j)) == NULL) return NULL;\n\n\tp = buf;\n\t/* Write out tag+length */\n\tASN1_put_object(&p,0,i,V_ASN1_OBJECT,V_ASN1_UNIVERSAL);\n\t/* Write out contents */\n\ta2d_ASN1_OBJECT(p,i,s,-1);\n\n\tcp=buf;\n\top=d2i_ASN1_OBJECT(NULL,&cp,j);\n\tOPENSSL_free(buf);\n\treturn op;\n\t}\n",
        "output": "0",
        "idx": 292
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvm_vm_ioctl_reinject(struct kvm *kvm,\n\t\t\t\t struct kvm_reinject_control *control)\n{\n\tif (!kvm->arch.vpit)\n\t\treturn -ENXIO;\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tkvm->arch.vpit->pit_state.pit_timer.reinject = control->pit_reinject;\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn 0;\n}\n",
        "output": "0",
        "idx": 253
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_cgroup_attach(struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\tstruct cgroup_subsys_state *css;\n\n\tcgroup_taskset_for_each(task, css, tset)\n\t\ttask_function_call(task, __perf_cgroup_move, task);\n}\n",
        "output": "0",
        "idx": 1505
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BinaryUploadService::IsAuthorized(AuthorizationCallback callback) {\n  if (!timer_.IsRunning()) {\n    timer_.Start(FROM_HERE, base::TimeDelta::FromHours(24), this,\n                 &BinaryUploadService::ResetAuthorizationData);\n  }\n\n   if (!can_upload_data_.has_value()) {\n     if (!pending_validate_data_upload_request_) {\n      std::string dm_token = GetDMToken();\n      if (dm_token.empty()) {\n         std::move(callback).Run(false);\n         return;\n       }\n\n      pending_validate_data_upload_request_ = true;\n       auto request = std::make_unique<ValidateDataUploadRequest>(base::BindOnce(\n           &BinaryUploadService::ValidateDataUploadRequestCallback,\n           weakptr_factory_.GetWeakPtr()));\n      request->set_dm_token(dm_token);\n       UploadForDeepScanning(std::move(request));\n     }\n     authorization_callbacks_.push_back(std::move(callback));\n    return;\n  }\n  std::move(callback).Run(can_upload_data_.value());\n}\n",
        "output": "1",
        "idx": 493
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ServiceWorkerDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n  if (state_ == WORKER_READY) {\n    if (sessions().size() == 1) {\n      BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,\n                               base::BindOnce(&SetDevToolsAttachedOnIO,\n                                              context_weak_, version_id_, true));\n     }\n    session->SetRenderer(RenderProcessHost::FromID(worker_process_id_),\n                         nullptr);\n     session->AttachToAgent(agent_ptr_);\n   }\n   session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(GetId())));\n  session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));\n}\n",
        "output": "1",
        "idx": 533
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void anyAttributeAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    v8SetReturnValue(info, imp->anyAttribute().v8Value());\n}\n",
        "output": "0",
        "idx": 1888
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot, int kern)\n{\n\tstruct sock *sk = sk_alloc(net, family, priority, prot, kern);\n\n\tif (!sk)\n\t\tgoto out;\n\tllc_sk_init(sk);\n\tsock_init_data(NULL, sk);\n#ifdef LLC_REFCNT_DEBUG\n\tatomic_inc(&llc_sock_nr);\n\tprintk(KERN_DEBUG \"LLC socket %p created in %s, now we have %d alive\\n\", sk,\n\t\t__func__, atomic_read(&llc_sock_nr));\n#endif\nout:\n\treturn sk;\n}\n",
        "output": "0",
        "idx": 644
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int qeth_get_initial_mtu_for_card(struct qeth_card *card)\n{\n\tswitch (card->info.type) {\n\tcase QETH_CARD_TYPE_UNKNOWN:\n\t\treturn 1500;\n\tcase QETH_CARD_TYPE_IQD:\n\t\treturn card->info.max_mtu;\n\tcase QETH_CARD_TYPE_OSD:\n\t\tswitch (card->info.link_type) {\n\t\tcase QETH_LINK_TYPE_HSTR:\n\t\tcase QETH_LINK_TYPE_LANE_TR:\n\t\t\treturn 2000;\n\t\tdefault:\n\t\t\treturn card->options.layer2 ? 1500 : 1492;\n\t\t}\n\tcase QETH_CARD_TYPE_OSM:\n\tcase QETH_CARD_TYPE_OSX:\n\t\treturn card->options.layer2 ? 1500 : 1492;\n\tdefault:\n\t\treturn 1500;\n\t}\n}\n",
        "output": "0",
        "idx": 164
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, seek)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tlong line_pos;\n \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &line_pos) == FAILURE) {\n \t\treturn;\n \t}\n \tif (line_pos < 0) {\n \t\tzend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, \"Can't seek file %s to negative line %ld\", intern->file_name, line_pos);\n\t\tRETURN_FALSE;\t\t\n \t}\n \tspl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);\n \twhile(intern->u.file.current_line_num < line_pos) {\n \t\tif (spl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC) == FAILURE) {\n \t\t\tbreak;\n\t\t}\n\t}\n} /* }}} */\n\n/* {{{ Function/Class/Method definitions */\n",
        "output": "1",
        "idx": 1491
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TypingCommand::insertText(Document& document,\n                               const String& text,\n                               Options options,\n                               TextCompositionType composition,\n                               const bool isIncrementalInsertion) {\n  LocalFrame* frame = document.frame();\n  DCHECK(frame);\n\n  if (!text.isEmpty())\n     document.frame()->spellChecker().updateMarkersForWordsAffectedByEditing(\n         isSpaceOrNewline(text[0]));\n \n  insertText(document, text,\n             frame->selection().computeVisibleSelectionInDOMTreeDeprecated(),\n             options, composition, isIncrementalInsertion);\n }\n",
        "output": "1",
        "idx": 491
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AffineTransform::recompose(const DecomposedType& decomp)\n{\n    this->setA(decomp.remainderA);\n    this->setB(decomp.remainderB);\n    this->setC(decomp.remainderC);\n    this->setD(decomp.remainderD);\n    this->setE(decomp.translateX);\n    this->setF(decomp.translateY);\n    this->rotateRadians(decomp.angle);\n    this->scale(decomp.scaleX, decomp.scaleY);\n}\n",
        "output": "0",
        "idx": 101
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ProfileSyncService::IsSyncEnabledAndLoggedIn() {\n  if (IsManaged() || sync_prefs_.IsStartSuppressed())\n    return false;\n\n  return !signin_->GetAuthenticatedUsername().empty();\n}\n",
        "output": "0",
        "idx": 1223
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void xmlrpc_char_encode(char *outbuffer, const char *s1)\n{\n\tlong unsigned int i;\n\tunsigned char c;\n\tchar buf2[15];\n\tmowgli_string_t *s = mowgli_string_create();\n\t*buf2 = '\\0';\n\t*outbuffer = '\\0';\n\n\tif ((!(s1) || (*(s1) == '\\0')))\n\t{\n\t\treturn;\n\t}\n\n\tfor (i = 0; s1[i] != '\\0'; i++)\n\t{\n\t\tc = s1[i];\n\t\tif (c > 127)\n\t\t{\n\t\t\tsnprintf(buf2, sizeof buf2, \"&#%d;\", c);\n\t\t\ts->append(s, buf2, strlen(buf2));\n\t\t}\n\t\telse if (c == '&')\n\t\t{\n\t\t\ts->append(s, \"&amp;\", 5);\n\t\t}\n\t\telse if (c == '<')\n\t\t{\n\t\t\ts->append(s, \"&lt;\", 4);\n\t\t}\n\t\telse if (c == '>')\n\t\t{\n\t\t\ts->append(s, \"&gt;\", 4);\n\t\t}\n\t\telse if (c == '\"')\n\t\t{\n\t\t\ts->append(s, \"&quot;\", 6);\n\t\t}\n\t\telse\n\t\t{\n \t\t\ts->append_char(s, c);\n \t\t}\n \t}\n \n\tmemcpy(outbuffer, s->str, XMLRPC_BUFSIZE);\n }\n",
        "output": "1",
        "idx": 337
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  LocalSiteCharacteristicsWebContentsObserver* observer() {\n    return observer_.get();\n   }\n",
        "output": "0",
        "idx": 1489
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void exit_creds(struct task_struct *tsk)\n{\n\tstruct cred *cred;\n\n\tkdebug(\"exit_creds(%u,%p,%p,{%d,%d})\", tsk->pid, tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\tcred = (struct cred *) tsk->real_cred;\n\ttsk->real_cred = NULL;\n\tvalidate_creds(cred);\n\talter_cred_subscribers(cred, -1);\n\tput_cred(cred);\n\n\tcred = (struct cred *) tsk->cred;\n\ttsk->cred = NULL;\n\tvalidate_creds(cred);\n\talter_cred_subscribers(cred, -1);\n\tput_cred(cred);\n\n\tcred = (struct cred *) tsk->replacement_session_keyring;\n\tif (cred) {\n\t\ttsk->replacement_session_keyring = NULL;\n\t\tvalidate_creds(cred);\n\t\tput_cred(cred);\n\t}\n}\n",
        "output": "0",
        "idx": 437
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void MojoJpegDecodeAccelerator::Decode(\n    const BitstreamBuffer& bitstream_buffer,\n    const scoped_refptr<VideoFrame>& video_frame) {\n  DCHECK(io_task_runner_->BelongsToCurrentThread());\n  DCHECK(jpeg_decoder_.is_bound());\n\n  DCHECK(\n      base::SharedMemory::IsHandleValid(video_frame->shared_memory_handle()));\n\n  base::SharedMemoryHandle output_handle =\n      base::SharedMemory::DuplicateHandle(video_frame->shared_memory_handle());\n  if (!base::SharedMemory::IsHandleValid(output_handle)) {\n    DLOG(ERROR) << \"Failed to duplicate handle of VideoFrame\";\n    return;\n  }\n\n   size_t output_buffer_size = VideoFrame::AllocationSize(\n       video_frame->format(), video_frame->coded_size());\n   mojo::ScopedSharedBufferHandle output_frame_handle =\n      mojo::WrapSharedMemoryHandle(output_handle, output_buffer_size,\n                                   false /* read_only */);\n \n   jpeg_decoder_->Decode(bitstream_buffer, video_frame->coded_size(),\n                        std::move(output_frame_handle),\n                        base::checked_cast<uint32_t>(output_buffer_size),\n                        base::Bind(&MojoJpegDecodeAccelerator::OnDecodeAck,\n                                   base::Unretained(this)));\n}\n",
        "output": "1",
        "idx": 1628
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bt_status_t btif_storage_add_bonded_device(bt_bdaddr_t *remote_bd_addr,\n                                           LINK_KEY link_key,\n uint8_t key_type,\n uint8_t pin_length)\n{\n bdstr_t bdstr;\n    bdaddr_to_string(remote_bd_addr, bdstr, sizeof(bdstr));\n\n     int ret = btif_config_set_int(bdstr, \"LinkKeyType\", (int)key_type);\n     ret &= btif_config_set_int(bdstr, \"PinLength\", (int)pin_length);\n     ret &= btif_config_set_bin(bdstr, \"LinkKey\", link_key, sizeof(LINK_KEY));\n     /* write bonded info immediately */\n     btif_config_flush();\n     return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;\n}\n",
        "output": "1",
        "idx": 1641
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void strictFunctionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    ExceptionState exceptionState(ExceptionState::ExecutionContext, \"strictFunction\", \"TestObject\", info.Holder(), info.GetIsolate());\n    if (UNLIKELY(info.Length() < 3)) {\n        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));\n        exceptionState.throwIfNeeded();\n        return;\n    }\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, str, info[0]);\n    V8TRYCATCH_VOID(float, a, static_cast<float>(info[1]->NumberValue()));\n    V8TRYCATCH_EXCEPTION_VOID(int, b, toInt32(info[2], exceptionState), exceptionState);\n    bool result = imp->strictFunction(str, a, b, exceptionState);\n    if (exceptionState.throwIfNeeded())\n        return;\n    v8SetReturnValueBool(info, result);\n}\n",
        "output": "0",
        "idx": 985
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DefaultAudioDestinationNode* DefaultAudioDestinationNode::Create(\n    BaseAudioContext* context,\n    const WebAudioLatencyHint& latency_hint) {\n  return MakeGarbageCollected<DefaultAudioDestinationNode>(*context,\n                                                           latency_hint);\n}\n",
        "output": "0",
        "idx": 254
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void MediaControlsProgressView::HandleSeeking(\n    const gfx::Point& location_in_bar) {\n   double seek_to_progress =\n       static_cast<double>(location_in_bar.x()) / progress_bar_->width();\n   seek_callback_.Run(seek_to_progress);\n}\n",
        "output": "1",
        "idx": 1749
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool TopSitesImpl::IsKnownURL(const GURL& url) {\n  return loaded_ && cache_->IsKnownURL(url);\n}\n",
        "output": "0",
        "idx": 9
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void detect_allow_debuggers(int argc, char **argv) {\n\tint i;\n\t\n \tfor (i = 1; i < argc; i++) {\n \t\tif (strcmp(argv[i], \"--allow-debuggers\") == 0) {\n \t\t\targ_allow_debuggers = 1;\n \t\t\tbreak;\n \t\t}\n\t\t\n\t\tif (strcmp(argv[i], \"--\") == 0)\n\t\t\tbreak;\n\t\tif (strncmp(argv[i], \"--\", 2) != 0)\n\t\t\tbreak;\n\t}\n}\n",
        "output": "1",
        "idx": 1703
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "n_tty_receive_buf_closing(struct tty_struct *tty, const unsigned char *cp,\n\t\t\t  char *fp, int count)\n{\n\tchar flag = TTY_NORMAL;\n\n\twhile (count--) {\n\t\tif (fp)\n\t\t\tflag = *fp++;\n\t\tif (likely(flag == TTY_NORMAL))\n\t\t\tn_tty_receive_char_closing(tty, *cp++);\n\t\telse\n\t\t\tn_tty_receive_char_flagged(tty, *cp++, flag);\n\t}\n}\n",
        "output": "0",
        "idx": 1310
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void InspectorTraceEvents::Did(const probe::ParseHTML& probe) {\n  TRACE_EVENT_END1(\n      \"devtools.timeline\", \"ParseHTML\", \"endData\",\n      InspectorParseHtmlEndData(probe.parser->LineNumber().ZeroBasedInt() - 1));\n  TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(\"devtools.timeline\"),\n                       \"UpdateCounters\", TRACE_EVENT_SCOPE_THREAD, \"data\",\n                       InspectorUpdateCountersEvent::Data());\n}\n",
        "output": "0",
        "idx": 105
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DevToolsDownloadManagerDelegate::OnDownloadPathGenerated(\n    uint32_t download_id,\n    const content::DownloadTargetCallback& callback,\n    const base::FilePath& suggested_path) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n \n   callback.Run(suggested_path,\n                content::DownloadItem::TARGET_DISPOSITION_OVERWRITE,\n               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,\n                suggested_path.AddExtension(FILE_PATH_LITERAL(\".crdownload\")),\n                content::DOWNLOAD_INTERRUPT_REASON_NONE);\n }\n",
        "output": "1",
        "idx": 1828
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void start_unregistering(struct ctl_table_header *p)\n{\n\t/*\n\t * if p->used is 0, nobody will ever touch that entry again;\n\t * we'll eliminate all paths to it before dropping sysctl_lock\n\t */\n\tif (unlikely(p->used)) {\n\t\tstruct completion wait;\n\t\tinit_completion(&wait);\n\t\tp->unregistering = &wait;\n\t\tspin_unlock(&sysctl_lock);\n\t\twait_for_completion(&wait);\n\t\tspin_lock(&sysctl_lock);\n\t} else {\n\t\t/* anything non-NULL; we'll never dereference it */\n\t\tp->unregistering = ERR_PTR(-EINVAL);\n\t}\n\t/*\n\t * do not remove from the list until nobody holds it; walking the\n\t * list in do_sysctl() relies on that.\n\t */\n\terase_header(p);\n}\n",
        "output": "0",
        "idx": 2038
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WallpaperManager::OnWallpaperDecoded(\n    const AccountId& account_id,\n    const wallpaper::WallpaperInfo& info,\n    bool update_wallpaper,\n    MovableOnDestroyCallbackHolder on_finish,\n    std::unique_ptr<user_manager::UserImage> user_image) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  TRACE_EVENT_ASYNC_END0(\"ui\", \"LoadAndDecodeWallpaper\", this);\n\n  if (user_image->image().isNull()) {\n    wallpaper::WallpaperInfo default_info(\n         \"\", wallpaper::WALLPAPER_LAYOUT_CENTER_CROPPED, wallpaper::DEFAULT,\n         base::Time::Now().LocalMidnight());\n     SetUserWallpaperInfo(account_id, default_info, true);\n    if (update_wallpaper)\n      DoSetDefaultWallpaper(account_id, std::move(on_finish));\n     return;\n   }\n \n  wallpaper_cache_[account_id].second = user_image->image();\n\n  if (update_wallpaper)\n    SetWallpaper(user_image->image(), info);\n}\n",
        "output": "1",
        "idx": 1647
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\n\t/* unprotected vars, we dont care of overwrites */\n \tstatic u32 challenge_timestamp;\n \tstatic unsigned int challenge_count;\n \tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 now;\n \n \t/* First check our per-socket dupack rate limit. */\n \tif (tcp_oow_rate_limited(sock_net(sk), skb,\n \t\t\t\t LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n \t\t\t\t &tp->last_oow_ack_time))\n \t\treturn;\n \n\t/* Then check the check host-wide RFC 5961 rate limit. */\n \tnow = jiffies / HZ;\n \tif (now != challenge_timestamp) {\n \t\tchallenge_timestamp = now;\n\t\tchallenge_count = 0;\n \t}\n\tif (++challenge_count <= sysctl_tcp_challenge_ack_limit) {\n \t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\n \t\ttcp_send_ack(sk);\n \t}\n}\n",
        "output": "1",
        "idx": 1959
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void addDataToStreamTask(void* context)\n {\n     OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));\n    blobRegistry().addDataToStream(blobRegistryContext->url, blobRegistryContext->streamData);\n }\n",
        "output": "1",
        "idx": 5
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "build_config(char *prefix, struct server *server)\n {\n     char *path    = NULL;\n     int path_size = strlen(prefix) + strlen(server->port) + 20;\n\n    path = ss_malloc(path_size);\n    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n    FILE *f = fopen(path, \"w+\");\n    if (f == NULL) {\n        if (verbose) {\n            LOGE(\"unable to open config file\");\n        }\n        ss_free(path);\n        return;\n    }\n     fprintf(f, \"{\\n\");\n     fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n     fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n     fprintf(f, \"\\n}\\n\");\n     fclose(f);\n     ss_free(path);\n}\n",
        "output": "1",
        "idx": 1101
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int git_index__changed_relative_to(\n\tgit_index *index, const git_oid *checksum)\n{\n\t/* attempt to update index (ignoring errors) */\n\tif (git_index_read(index, false) < 0)\n\t\tgiterr_clear();\n\n\treturn !!git_oid_cmp(&index->checksum, checksum);\n}\n",
        "output": "0",
        "idx": 525
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_METHOD(Phar, getSupportedCompression)\n{\n        if (zend_parse_parameters_none() == FAILURE) {\n                return;\n        }\n        array_init(return_value);\n        phar_request_initialize(TSRMLS_C);\n \n\tif (PHAR_G(has_zlib)) {\n\t\tadd_next_index_stringl(return_value, \"GZ\", 2, 1);\n\t}\n\n\tif (PHAR_G(has_bz2)) {\n\t\tadd_next_index_stringl(return_value, \"BZIP2\", 5, 1);\n\t}\n}\n",
        "output": "1",
        "idx": 512
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n \thdr->sadb_msg_pid = c->portid;\n \thdr->sadb_msg_version = PF_KEY_V2;\n \thdr->sadb_msg_errno = (uint8_t) 0;\n \thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n \tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n \treturn 0;\n\n}\n",
        "output": "1",
        "idx": 259
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long Chapters::Parse()\n{\n    IMkvReader* const pReader = m_pSegment->m_pReader;\n    long long pos = m_start;  // payload start\n    const long long stop = pos + m_size;  // payload stop\n    while (pos < stop)\n    {\n        long long id, size;\n        long status = ParseElementHeader(\n                        pReader,\n                        pos,\n                        stop,\n                        id,\n                        size);\n        if (status < 0)  // error\n            return status;\n        if (size == 0)  // weird\n            continue;\n        if (id == 0x05B9)  // EditionEntry ID\n        {\n            status = ParseEdition(pos, size);\n            if (status < 0)  // error\n                return status;\n        }\n        pos += size;\n        assert(pos <= stop);\n     }\n \n    assert(pos == stop);\n    return 0;\n }\n",
        "output": "1",
        "idx": 129
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct mt_connection *list_find_connection(unsigned short seskey, unsigned char *srcmac) {\n\tstruct mt_connection *p;\n\n\tDL_FOREACH(connections_head, p) {\n\t\tif (p->seskey == seskey && memcmp(srcmac, p->srcmac, ETH_ALEN) == 0) {\n\t\t\treturn p;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n",
        "output": "0",
        "idx": 112
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void charstring_end(void)\n{\n  byte *bp;\n\n  sprintf(line, \"%d \", (int) (charstring_bp - charstring_buf));\n  eexec_string(line);\n  sprintf(line, \"%s \", cs_start);\n  eexec_string(line);\n  for (bp = charstring_buf; bp < charstring_bp; bp++)\n    eexec_byte(*bp);\n}\n",
        "output": "0",
        "idx": 1411
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ParseRequestInfo(const struct mg_request_info* const request_info,\n                      std::string* method,\n                      std::vector<std::string>* path_segments,\n                      DictionaryValue** parameters,\n                      Response* const response) {\n  *method = request_info->request_method;\n  if (*method == \"HEAD\")\n    *method = \"GET\";\n  else if (*method == \"PUT\")\n    *method = \"POST\";\n\n  std::string uri(request_info->uri);\n  SessionManager* manager = SessionManager::GetInstance();\n  uri = uri.substr(manager->url_base().length());\n\n   base::SplitString(uri, '/', path_segments);\n \n   if (*method == \"POST\" && request_info->post_data_len > 0) {\n    VLOG(1) << \"...parsing request body\";\n     std::string json(request_info->post_data, request_info->post_data_len);\n    std::string error;\n    if (!ParseJSONDictionary(json, parameters, &error)) {\n       response->SetError(new Error(\n           kBadRequest,\n          \"Failed to parse command data: \" + error + \"\\n  Data: \" + json));\n       return false;\n     }\n   }\n  VLOG(1) << \"Parsed \" << method << \" \" << uri\n        << std::string(request_info->post_data, request_info->post_data_len);\n   return true;\n }\n",
        "output": "1",
        "idx": 1787
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vfio_pci_intx_mask(struct vfio_pci_device *vdev)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vdev->irqlock, flags);\n\n\t/*\n\t * Masking can come from interrupt, ioctl, or config space\n\t * via INTx disable.  The latter means this can get called\n\t * even when not using intx delivery.  In this case, just\n\t * try to have the physical bit follow the virtual bit.\n\t */\n\tif (unlikely(!is_intx(vdev))) {\n\t\tif (vdev->pci_2_3)\n\t\t\tpci_intx(pdev, 0);\n\t} else if (!vdev->ctx[0].masked) {\n\t\t/*\n\t\t * Can't use check_and_mask here because we always want to\n\t\t * mask, not just when something is pending.\n\t\t */\n\t\tif (vdev->pci_2_3)\n\t\t\tpci_intx(pdev, 0);\n\t\telse\n\t\t\tdisable_irq_nosync(pdev->irq);\n\n\t\tvdev->ctx[0].masked = true;\n\t}\n\n\tspin_unlock_irqrestore(&vdev->irqlock, flags);\n}\n",
        "output": "0",
        "idx": 582
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error_detected(uint32_t errnum, char *errstr, ...)\n{\n    va_list args;\n\n    va_start(args, errstr);\n\n    {\n        TSK_ERROR_INFO *errInfo = tsk_error_get_info();\n        char *loc_errstr = errInfo->errstr;\n\n        if (errInfo->t_errno == 0)\n            errInfo->t_errno = errnum;\n        else {\n            size_t sl = strlen(errstr);\n            snprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,\n                \" Next errnum: 0x%x \", errnum);\n        }\n        if (errstr != NULL) {\n            size_t sl = strlen(loc_errstr);\n            vsnprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,\n                errstr, args);\n        }\n    }\n\n    va_end(args);\n\n}\n",
        "output": "0",
        "idx": 90
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static grub_err_t read_foo (struct grub_disk *disk, grub_disk_addr_t sector, grub_size_t size, char *buf) {\n\tif (disk != NULL) {\n\t\tconst int blocksize = 512; // unhardcode 512\n\t\tint ret;\n\t\tRIOBind *iob = disk->data;\n\t\tif (bio) iob = bio;\n\t\tret = iob->read_at (iob->io, delta+(blocksize*sector),\n\t\t\t(ut8*)buf, size*blocksize);\n\t\tif (ret == -1)\n\t\t\treturn 1;\n\t} else eprintf (\"oops. no disk\\n\");\n\treturn 0; // 0 is ok\n }\n",
        "output": "1",
        "idx": 172
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CameraSource::signalBufferReturned(MediaBuffer *buffer) {\n    ALOGV(\"signalBufferReturned: %p\", buffer->data());\n Mutex::Autolock autoLock(mLock);\n\n     for (List<sp<IMemory> >::iterator it = mFramesBeingEncoded.begin();\n          it != mFramesBeingEncoded.end(); ++it) {\n         if ((*it)->pointer() ==  buffer->data()) {\n             releaseOneRecordingFrame((*it));\n             mFramesBeingEncoded.erase(it);\n             ++mNumFramesEncoded;\n            buffer->setObserver(0);\n            buffer->release();\n            mFrameCompleteCondition.signal();\n return;\n }\n }\n    CHECK(!\"signalBufferReturned: bogus buffer\");\n}\n",
        "output": "1",
        "idx": 1794
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Dispatcher::OnShouldSuspend(const std::string& extension_id,\n                                 uint64_t sequence_id) {\n  RenderThread::Get()->Send(\n      new ExtensionHostMsg_ShouldSuspendAck(extension_id, sequence_id));\n}\n",
        "output": "0",
        "idx": 327
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const base::Time& BaseNode::GetModificationTime() const {\n   return GetEntry()->Get(syncable::MTIME);\n }\n",
        "output": "1",
        "idx": 1968
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void renew_lease(const struct nfs_server *server, unsigned long timestamp)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\n\tif (!nfs4_has_session(clp))\n\t\tdo_renew_lease(clp, timestamp);\n}\n",
        "output": "0",
        "idx": 979
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void ReconfigureImpl(Handle<JSObject> object,\n Handle<FixedArrayBase> store, uint32_t entry,\n Handle<Object> value,\n PropertyAttributes attributes) {\n    UNREACHABLE();\n }\n",
        "output": "0",
        "idx": 1424
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static zend_always_inline uint32_t zend_array_dup_elements(HashTable *source, HashTable *target, int static_keys, int with_holes)\n{\n\tuint32_t idx = 0;\n\tBucket *p = source->arData;\n\tBucket *q = target->arData;\n\tBucket *end = p + source->nNumUsed;\n\n\tdo {\n\t\tif (!zend_array_dup_element(source, target, idx, p, q, 0, static_keys, with_holes)) {\n\t\t\tuint32_t target_idx = idx;\n\n\t\t\tidx++; p++;\n\t\t\twhile (p != end) {\n\t\t\t\tif (zend_array_dup_element(source, target, target_idx, p, q, 0, static_keys, with_holes)) {\n\t\t\t\t\tif (source->nInternalPointer == idx) {\n\t\t\t\t\t\ttarget->nInternalPointer = target_idx;\n\t\t\t\t\t}\n\t\t\t\t\ttarget_idx++; q++;\n\t\t\t\t}\n\t\t\t\tidx++; p++;\n\t\t\t}\n\t\t\treturn target_idx;\n\t\t}\n\t\tidx++; p++; q++;\n\t} while (p != end);\n\treturn idx;\n}\n",
        "output": "0",
        "idx": 1698
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void PerWorldBindingsRuntimeEnabledVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  TestObject* impl = V8TestObject::ToImpl(info.Holder());\n\n  impl->perWorldBindingsRuntimeEnabledVoidMethod();\n}\n",
        "output": "0",
        "idx": 857
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int command_read(struct pci_dev *dev, int offset, u16 *value, void *data)\n {\n\tint i;\n\tint ret;\n\tret = xen_pcibk_read_config_word(dev, offset, value, data);\n\tif (!pci_is_enabled(dev))\n\t\treturn ret;\n\tfor (i = 0; i < PCI_ROM_RESOURCE; i++) {\n\t\tif (dev->resource[i].flags & IORESOURCE_IO)\n\t\t\t*value |= PCI_COMMAND_IO;\n\t\tif (dev->resource[i].flags & IORESOURCE_MEM)\n\t\t\t*value |= PCI_COMMAND_MEMORY;\n \t}\n \n \treturn ret;\n }\n",
        "output": "1",
        "idx": 575
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool IsURLAllowedInIncognito(const GURL& url) {\n  return url.scheme() == chrome::kChromeUIScheme &&\n      (url.host() == chrome::kChromeUISettingsHost ||\n       url.host() == chrome::kChromeUIExtensionsHost ||\n       url.host() == chrome::kChromeUIBookmarksHost);\n}\n",
        "output": "0",
        "idx": 1118
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " FileStream::FileStream(base::File file,\n                        const scoped_refptr<base::TaskRunner>& task_runner)\n    : context_(base::MakeUnique<Context>(std::move(file), task_runner)) {}\n",
        "output": "1",
        "idx": 399
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void print_errors(void)\n{\n\tDPRINT(\"\");\n\tif (ST0 & ST0_ECE) {\n\t\tpr_cont(\"Recalibrate failed!\");\n\t} else if (ST2 & ST2_CRC) {\n\t\tpr_cont(\"data CRC error\");\n\t\ttell_sector();\n\t} else if (ST1 & ST1_CRC) {\n\t\tpr_cont(\"CRC error\");\n\t\ttell_sector();\n\t} else if ((ST1 & (ST1_MAM | ST1_ND)) ||\n\t\t   (ST2 & ST2_MAM)) {\n\t\tif (!probing) {\n\t\t\tpr_cont(\"sector not found\");\n\t\t\ttell_sector();\n\t\t} else\n\t\t\tpr_cont(\"probe failed...\");\n\t} else if (ST2 & ST2_WC) {\t/* seek error */\n\t\tpr_cont(\"wrong cylinder\");\n\t} else if (ST2 & ST2_BC) {\t/* cylinder marked as bad */\n\t\tpr_cont(\"bad cylinder\");\n\t} else {\n\t\tpr_cont(\"unknown error. ST[0..2] are: 0x%x 0x%x 0x%x\",\n\t\t\tST0, ST1, ST2);\n\t\ttell_sector();\n\t}\n\tpr_cont(\"\\n\");\n}\n",
        "output": "0",
        "idx": 2081
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jpeg_size(unsigned char* data, unsigned int data_size,\n                     int *width, int *height)\n{\n    int i = 0;\n    if (i + 3 < data_size && data[i] == 0xFF && data[i+1] == 0xD8 &&\n            data[i+2] == 0xFF && data[i+3] == 0xE0) {\n        i += 4;\n        if(i + 6 < data_size &&\n                data[i+2] == 'J' && data[i+3] == 'F' && data[i+4] == 'I' &&\n                data[i+5] == 'F' && data[i+6] == 0x00) {\n            unsigned short block_length = data[i] * 256 + data[i+1];\n            while(i<data_size) {\n                i+=block_length;\n                if((i + 1) >= data_size)\n                    return -1;\n                if(data[i] != 0xFF)\n                    return -1;\n                if(data[i+1] == 0xC0) {\n                    *height = data[i+5]*256 + data[i+6];\n                    *width = data[i+7]*256 + data[i+8];\n                     return 0;\n                 }\n                 i+=2;\n                block_length = data[i] * 256 + data[i+1];\n             }\n         }\n     }\n\n    return -1;\n}\n",
        "output": "1",
        "idx": 830
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned next_desc(struct vhost_virtqueue *vq, struct vring_desc *desc)\n{\n\tunsigned int next;\n\n\t/* If this descriptor says it doesn't chain, we're done. */\n\tif (!(desc->flags & cpu_to_vhost16(vq, VRING_DESC_F_NEXT)))\n\t\treturn -1U;\n\n\t/* Check they're not leading us off end of descriptors. */\n\tnext = vhost16_to_cpu(vq, desc->next);\n\t/* Make sure compiler knows to grab that: we don't want it changing! */\n\t/* We will use the result as an index in an array, so most\n\t * architectures only need a compiler barrier here. */\n\tread_barrier_depends();\n\n\treturn next;\n}\n",
        "output": "0",
        "idx": 1847
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "base::FilePath ChromeContentBrowserClient::GetShaderDiskCacheDirectory() {\n  base::FilePath user_data_dir;\n  base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);\n  DCHECK(!user_data_dir.empty());\n  return user_data_dir.Append(FILE_PATH_LITERAL(\"ShaderCache\"));\n}\n",
        "output": "0",
        "idx": 145
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gx_dc_colored_masked_get_dev_halftone(const gx_device_color * pdevc)\n{\n    return pdevc->colors.colored.c_ht;\n}\n",
        "output": "0",
        "idx": 170
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t MediaPlayerService::Client::setNextPlayer(const sp<IMediaPlayer>& player) {\n\n     ALOGV(\"setNextPlayer\");\n     Mutex::Autolock l(mLock);\n     sp<Client> c = static_cast<Client*>(player.get());\n     mNextClient = c;\n \n     if (c != NULL) {\n if (mAudioOutput != NULL) {\n            mAudioOutput->setNextOutput(c->mAudioOutput);\n } else if ((mPlayer != NULL) && !mPlayer->hardwareOutput()) {\n            ALOGE(\"no current audio output\");\n }\n\n if ((mPlayer != NULL) && (mNextClient->getPlayer() != NULL)) {\n            mPlayer->setNextPlayer(mNextClient->getPlayer());\n }\n }\n\n return OK;\n}\n",
        "output": "1",
        "idx": 1033
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool BrowserView::HasClientEdge() const {\n  return frame()->GetFrameView()->HasClientEdge();\n}\n",
        "output": "0",
        "idx": 195
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ssh_packet_backup_state(struct ssh *ssh,\n    struct ssh *backup_state)\n{\n\tstruct ssh *tmp;\n\n\tclose(ssh->state->connection_in);\n\tssh->state->connection_in = -1;\n\tclose(ssh->state->connection_out);\n\tssh->state->connection_out = -1;\n\tif (backup_state)\n\t\ttmp = backup_state;\n\telse\n\t\ttmp = ssh_alloc_session_state();\n\tbackup_state = ssh;\n\tssh = tmp;\n}\n",
        "output": "0",
        "idx": 1406
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "string16 ExtensionGlobalError::GenerateMessageSection(\n    const ExtensionIdSet* extensions,\n    int template_message_id) {\n  CHECK(extensions);\n  CHECK(template_message_id);\n  string16 message;\n\n   for (ExtensionIdSet::const_iterator iter = extensions->begin();\n        iter != extensions->end(); ++iter) {\n     const Extension* e = extension_service_->GetExtensionById(*iter, true);\n    message += l10n_util::GetStringFUTF16(\n        template_message_id,\n        string16(ASCIIToUTF16(e->name())),\n        l10n_util::GetStringUTF16(IDS_SHORT_PRODUCT_NAME));\n   }\n   return message;\n }\n",
        "output": "1",
        "idx": 1304
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " image_transform_png_set_strip_16_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n {\n    UNUSED(colour_type)\n \n this->next = *that;\n *that = this;\n\n return bit_depth > 8;\n}\n",
        "output": "1",
        "idx": 1720
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int lxc_clear_environment(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\n\tlxc_list_for_each_safe(it, &c->environment, next) {\n\t\tlxc_list_del(it);\n\t\tfree(it->elem);\n\t\tfree(it);\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "idx": 1315
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  CurrentThreadMock()\n      : task_runner_delegate_(\n            scheduler::LazySchedulerMessageLoopDelegateForTests::Create()),\n        scheduler_(\n            new scheduler::RendererSchedulerImpl(task_runner_delegate_.get())),\n        web_scheduler_(\n            new scheduler::RendererWebSchedulerImpl(scheduler_.get())),\n        web_task_runner_(\n            new scheduler::WebTaskRunnerImpl(scheduler_->DefaultTaskRunner())) {\n  }\n",
        "output": "0",
        "idx": 513
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(\n     JNIEnv* env,\n    mojo::ScopedSharedBufferMapping mapping,\n     const CreateSensorCallback& callback) {\n   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(\n       env, j_object_,\n       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));\n \n   if (sensor.obj()) {\n     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),\n         this, sensor);\n \n     callback.Run(concrete_sensor);\n  } else {\n    auto sensor_fusion_algorithm =\n        std::make_unique<OrientationQuaternionFusionAlgorithmUsingEulerAngles>(\n            true /* absolute */);\n \n    PlatformSensorFusion::Create(std::move(mapping), this,\n                                  std::move(sensor_fusion_algorithm), callback);\n   }\n }\n",
        "output": "1",
        "idx": 1803
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ext4_xattr_create_cache(char *name)\n {\n\treturn mb_cache_create(name, HASH_BUCKET_BITS);\n }\n",
        "output": "1",
        "idx": 187
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)\n {\n \tjas_matrix_t *matrix;\n \tassert(xstart <= xend && ystart <= yend);\n\tif (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) {\n\t\treturn 0;\n\t}\n\tmatrix->xstart_ = xstart;\n\tmatrix->ystart_ = ystart;\n\tmatrix->xend_ = xend;\n\tmatrix->yend_ = yend;\n \treturn matrix;\n }\n",
        "output": "1",
        "idx": 1448
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " struct bpf_map *bpf_map_get_with_uref(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_map *map;\n\n\tmap = __bpf_map_get(f);\n \tif (IS_ERR(map))\n \t\treturn map;\n \n\tbpf_map_inc(map, true);\n \tfdput(f);\n \n \treturn map;\n}\n",
        "output": "1",
        "idx": 1271
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __always_inline int __do_follow_link(struct path *path, struct nameidata *nd)\n{\n\tint error;\n\tvoid *cookie;\n\tstruct dentry *dentry = path->dentry;\n\n\ttouch_atime(path->mnt, dentry);\n\tnd_set_link(nd, NULL);\n\n\tif (path->mnt != nd->path.mnt) {\n\t\tpath_to_nameidata(path, nd);\n \t\tdget(dentry);\n \t}\n \tmntget(path->mnt);\n \tcookie = dentry->d_inode->i_op->follow_link(dentry, nd);\n \terror = PTR_ERR(cookie);\n \tif (!IS_ERR(cookie)) {\n\t\tchar *s = nd_get_link(nd);\n\t\terror = 0;\n\t\tif (s)\n\t\t\terror = __vfs_follow_link(nd, s);\n\t\telse if (nd->last_type == LAST_BIND) {\n\t\t\terror = force_reval_path(&nd->path, nd);\n\t\t\tif (error)\n\t\t\t\tpath_put(&nd->path);\n\t\t}\n\t\tif (dentry->d_inode->i_op->put_link)\n\t\t\tdentry->d_inode->i_op->put_link(dentry, nd, cookie);\n\t}\n\treturn error;\n}\n",
        "output": "1",
        "idx": 1562
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " bool MessageLoop::DoDelayedWork(TimeTicks* next_delayed_work_time) {\n  if (!nestable_tasks_allowed_ ||\n       !SweepDelayedWorkQueueAndReturnTrueIfStillHasWork()) {\n     recent_time_ = *next_delayed_work_time = TimeTicks();\n     return false;\n  }\n\n\n  TimeTicks next_run_time = delayed_work_queue_.top().delayed_run_time;\n  if (next_run_time > recent_time_) {\n    recent_time_ = TimeTicks::Now();  // Get a better view of Now();\n    if (next_run_time > recent_time_) {\n      *next_delayed_work_time = next_run_time;\n      return false;\n    }\n  }\n\n  PendingTask pending_task =\n      std::move(const_cast<PendingTask&>(delayed_work_queue_.top()));\n  delayed_work_queue_.pop();\n\n  if (SweepDelayedWorkQueueAndReturnTrueIfStillHasWork())\n    *next_delayed_work_time = delayed_work_queue_.top().delayed_run_time;\n\n  return DeferOrRunPendingTask(std::move(pending_task));\n}\n",
        "output": "1",
        "idx": 1365
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xfrm6_tunnel_spi_fini(void)\n{\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n}\n",
        "output": "1",
        "idx": 1986
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "store_image_check(PNG_CONST png_store* ps, png_const_structp pp, int iImage)\n {\n    png_const_bytep image = ps->image;\n \n if (image[-1] != 0xed || image[ps->cb_image] != 0xfe)\n      png_error(pp, \"image overwrite\");\n else\n {\n png_size_t cbRow = ps->cb_row;\n      png_uint_32 rows = ps->image_h;\n\n      image += iImage * (cbRow+5) * ps->image_h;\n\n      image += 2; /* skip image first row markers */\n\n while (rows-- > 0)\n {\n if (image[-2] != 190 || image[-1] != 239)\n            png_error(pp, \"row start overwritten\");\n\n if (image[cbRow] != 222 || image[cbRow+1] != 173 ||\n            image[cbRow+2] != 17)\n            png_error(pp, \"row end overwritten\");\n\n         image += cbRow+5;\n }\n }\n}\n",
        "output": "1",
        "idx": 1820
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GLES2DecoderImpl::DoGetTexParameteriv(\n    GLenum target, GLenum pname, GLint* params) {\n  InitTextureMaxAnisotropyIfNeeded(target, pname);\n  glGetTexParameteriv(target, pname, params);\n}\n",
        "output": "0",
        "idx": 1112
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GURL DecorateFrontendURL(const GURL& base_url) {\n  std::string frontend_url = base_url.spec();\n  std::string url_string(\n      frontend_url +\n      ((frontend_url.find(\"?\") == std::string::npos) ? \"?\" : \"&\") +\n      \"dockSide=undocked\"); // TODO(dgozman): remove this support in M38.\n  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();\n  if (command_line->HasSwitch(switches::kEnableDevToolsExperiments))\n     url_string += \"&experiments=true\";\n \n   if (command_line->HasSwitch(switches::kDevToolsFlags)) {\n    std::string flags = command_line->GetSwitchValueASCII(\n                            switches::kDevToolsFlags);\n    flags = net::EscapeQueryParamValue(flags, false);\n    url_string += \"&flags=\" + flags;\n   }\n \n #if defined(DEBUG_DEVTOOLS)\n  url_string += \"&debugFrontend=true\";\n#endif  // defined(DEBUG_DEVTOOLS)\n\n  return GURL(url_string);\n}\n",
        "output": "1",
        "idx": 1680
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   virtual bool InputMethodIsActivated(const std::string& input_method_id) {\n    scoped_ptr<InputMethodDescriptors> active_input_method_descriptors(\n        GetActiveInputMethods());\n     for (size_t i = 0; i < active_input_method_descriptors->size(); ++i) {\n       if (active_input_method_descriptors->at(i).id == input_method_id) {\n         return true;\n      }\n    }\n    return false;\n  }\n",
        "output": "1",
        "idx": 1459
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_authenc_verify(struct aead_request *req,\n\t\t\t\t authenc_ahash_t authenc_ahash_fn)\n{\n\tstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\n\tstruct authenc_request_ctx *areq_ctx = aead_request_ctx(req);\n\tu8 *ohash;\n\tu8 *ihash;\n\tunsigned int authsize;\n\n\tareq_ctx->complete = authenc_verify_ahash_done;\n\tareq_ctx->update_complete = authenc_verify_ahash_update_done;\n\n\tohash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);\n\tif (IS_ERR(ohash))\n\t\treturn PTR_ERR(ohash);\n\n\tauthsize = crypto_aead_authsize(authenc);\n\tihash = ohash + authsize;\n\tscatterwalk_map_and_copy(ihash, areq_ctx->sg, areq_ctx->cryptlen,\n\t\t\t\t authsize, 0);\n\treturn crypto_memneq(ihash, ohash, authsize) ? -EBADMSG : 0;\n}\n",
        "output": "0",
        "idx": 1444
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void acpi_os_printf(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tacpi_os_vprintf(fmt, args);\n\tva_end(args);\n}\n",
        "output": "0",
        "idx": 364
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void perf_swevent_overflow(struct perf_event *event, u64 overflow,\n\t\t\t\t    int nmi, struct perf_sample_data *data,\n \t\t\t\t    struct pt_regs *regs)\n {\n \tstruct hw_perf_event *hwc = &event->hw;\n\tint throttle = 0;\n\n\tdata->period = event->hw.last_period;\n\tif (!overflow)\n\t\toverflow = perf_swevent_set_period(event);\n\n\tif (hwc->interrupts == MAX_INTERRUPTS)\n \t\treturn;\n \n \tfor (; overflow; overflow--) {\n\t\tif (__perf_event_overflow(event, nmi, throttle,\n \t\t\t\t\t    data, regs)) {\n \t\t\t/*\n \t\t\t * We inhibit the overflow from happening when\n\t\t\t * hwc->interrupts == MAX_INTERRUPTS.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tthrottle = 1;\n\t}\n }\n",
        "output": "1",
        "idx": 1836
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool arg_type_is_refcounted(enum bpf_arg_type type)\n{\n\treturn type == ARG_PTR_TO_SOCKET;\n}\n",
        "output": "0",
        "idx": 808
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sysMapFD(int fd, MemMapping* pMap)\n{\n off_t start;\n size_t length;\n void* memPtr;\n\n    assert(pMap != NULL);\n\n if (getFileStartAndLength(fd, &start, &length) < 0)\n return -1;\n\n    memPtr = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, start);\n if (memPtr == MAP_FAILED) {\n        LOGW(\"mmap(%d, R, PRIVATE, %d, %d) failed: %s\\n\", (int) length,\n            fd, (int) start, strerror(errno));\n return -1;\n }\n\n    pMap->addr = memPtr;\n\n     pMap->length = length;\n     pMap->range_count = 1;\n     pMap->ranges = malloc(sizeof(MappedRange));\n     pMap->ranges[0].addr = memPtr;\n     pMap->ranges[0].length = length;\n \n return 0;\n}\n",
        "output": "1",
        "idx": 784
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static enum AVPixelFormat h263_get_format(AVCodecContext *avctx)\n {\n     /* MPEG-4 Studio Profile only, not supported by hardware */\n     if (avctx->bits_per_raw_sample > 8) {\n        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n         return avctx->pix_fmt;\n     }\n \n    if (avctx->codec->id == AV_CODEC_ID_MSS2)\n        return AV_PIX_FMT_YUV420P;\n\n    if (CONFIG_GRAY && (avctx->flags & AV_CODEC_FLAG_GRAY)) {\n        if (avctx->color_range == AVCOL_RANGE_UNSPECIFIED)\n            avctx->color_range = AVCOL_RANGE_MPEG;\n        return AV_PIX_FMT_GRAY8;\n    }\n\n    return avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);\n}\n",
        "output": "1",
        "idx": 1122
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *load_device_tree(const char *filename_path, int *sizep)\n{\n    int dt_size;\n    int dt_file_load_size;\n    int ret;\n    void *fdt = NULL;\n\n    *sizep = 0;\n    dt_size = get_image_size(filename_path);\n    if (dt_size < 0) {\n        error_report(\"Unable to get size of device tree file '%s'\",\n                     filename_path);\n        goto fail;\n    }\n\n    /* Expand to 2x size to give enough room for manipulation.  */\n    dt_size += 10000;\n    dt_size *= 2;\n     /* First allocate space in qemu for device tree */\n     fdt = g_malloc0(dt_size);\n \n    dt_file_load_size = load_image(filename_path, fdt);\n     if (dt_file_load_size < 0) {\n         error_report(\"Unable to open device tree file '%s'\",\n                      filename_path);\n        goto fail;\n    }\n\n    ret = fdt_open_into(fdt, fdt, dt_size);\n    if (ret) {\n        error_report(\"Unable to copy device tree in memory\");\n        goto fail;\n    }\n\n    /* Check sanity of device tree */\n    if (fdt_check_header(fdt)) {\n        error_report(\"Device tree file loaded into memory is invalid: %s\",\n                     filename_path);\n        goto fail;\n    }\n    *sizep = dt_size;\n    return fdt;\n\nfail:\n    g_free(fdt);\n    return NULL;\n}\n",
        "output": "1",
        "idx": 1435
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void DeleteImpl(Handle<JSObject> obj, uint32_t entry) {\n Handle<SeededNumberDictionary> dict(\n SeededNumberDictionary::cast(obj->elements()));\n uint32_t index = GetIndexForEntryImpl(*dict, entry);\n Handle<Object> result = SeededNumberDictionary::DeleteProperty(dict, entry);\n    USE(result);\n    DCHECK(result->IsTrue(dict->GetIsolate()));\n Handle<FixedArray> new_elements =\n SeededNumberDictionary::Shrink(dict, index);\n    obj->set_elements(*new_elements);\n }\n",
        "output": "0",
        "idx": 887
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t  proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tguint32 size;\n\tint end_offset;\n\n\tif (di->conformant_run)\n\t\treturn offset;\n\n\t/* Dissect size and data */\n\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_keybuffer_size, &size);\n\n\tend_offset = offset + (size*2);\n\tif (end_offset < offset) {\n\t\t/*\n\t\t * Overflow - make the end offset one past the end of\n\t\t * the packet data, so we throw an exception (as the\n\t\t * size is almost certainly too big).\n\t\t */\n \t\tend_offset = tvb_reported_length_remaining(tvb, offset) + 1;\n \t}\n \n\twhile (offset < end_offset)\n \t\toffset = dissect_spoolss_uint16uni(\n \t\t\ttvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);\n \n \treturn offset;\n }\n",
        "output": "1",
        "idx": 1730
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PasswordAutofillAgent::PasswordAutofillAgent(content::RenderFrame* render_frame)\n     : content::RenderFrameObserver(render_frame),\n       logging_state_active_(false),\n       was_username_autofilled_(false),\n      was_password_autofilled_(false),\n      weak_ptr_factory_(this) {\n   Send(new AutofillHostMsg_PasswordAutofillAgentConstructed(routing_id()));\n }\n",
        "output": "1",
        "idx": 1741
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "timeval_equals(struct timeval * tv0, struct timeval * tv1)\n{\n    if ( tv0->tv_sec == tv1->tv_sec && tv0->tv_usec == tv1->tv_usec )\n\treturn 1;\n    else\n\treturn 0;\n}\n",
        "output": "0",
        "idx": 764
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " PrintPreviewUI::PrintPreviewUI(content::WebUI* web_ui)\n     : ConstrainedWebDialogUI(web_ui),\n       initial_preview_start_time_(base::TimeTicks::Now()),\n       handler_(NULL),\n       source_is_modifiable_(true),\n       tab_closed_(false) {\n  Profile* profile = Profile::FromWebUI(web_ui);\n  ChromeURLDataManager::AddDataSource(profile, new PrintPreviewDataSource());\n\n   handler_ = new PrintPreviewHandler();\n   web_ui->AddMessageHandler(handler_);\n \n  preview_ui_addr_str_ = GetPrintPreviewUIAddress();\n  g_print_preview_request_id_map.Get().Set(preview_ui_addr_str_, -1);\n }\n",
        "output": "1",
        "idx": 1336
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void RegisterProperties(IBusPropList* ibus_prop_list) {\n    DLOG(INFO) << \"RegisterProperties\" << (ibus_prop_list ? \"\" : \" (clear)\");\n \n     ImePropertyList prop_list;  // our representation.\n     if (ibus_prop_list) {\n       if (!FlattenPropertyList(ibus_prop_list, &prop_list)) {\n        RegisterProperties(NULL);\n         return;\n       }\n     }\n    register_ime_properties_(language_library_, prop_list);\n  }\n",
        "output": "1",
        "idx": 509
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int transport_read_nonblocking(rdpTransport* transport)\n{\n\tint status;\n\n\tstatus = transport_read(transport, transport->ReceiveBuffer);\n\n\tif (status <= 0)\n\t\treturn status;\n\n\tStream_Seek(transport->ReceiveBuffer, status);\n\n\treturn status;\n}\n",
        "output": "0",
        "idx": 146
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GLES2DecoderImpl::DoScheduleCALayerInUseQueryCHROMIUM(\n    GLsizei count,\n    const volatile GLuint* textures) {\n  std::vector<gl::GLSurface::CALayerInUseQuery> queries;\n  queries.reserve(count);\n  for (GLsizei i = 0; i < count; ++i) {\n    gl::GLImage* image = nullptr;\n    GLuint texture_id = textures[i];\n    if (texture_id) {\n      TextureRef* ref = texture_manager()->GetTexture(texture_id);\n      if (!ref) {\n        LOCAL_SET_GL_ERROR(GL_INVALID_VALUE,\n                           \"glScheduleCALayerInUseQueryCHROMIUM\",\n                           \"unknown texture\");\n        return;\n      }\n      Texture::ImageState image_state;\n      image = ref->texture()->GetLevelImage(ref->texture()->target(), 0,\n                                            &image_state);\n    }\n    gl::GLSurface::CALayerInUseQuery query;\n    query.image = image;\n    query.texture = texture_id;\n    queries.push_back(query);\n  }\n\n  surface_->ScheduleCALayerInUseQuery(std::move(queries));\n}\n",
        "output": "0",
        "idx": 1013
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionOverloadedMethod6(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestObj::s_info))\n        return throwVMTypeError(exec);\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     DOMStringList* listArg(toDOMStringList(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n    impl->overloadedMethod(listArg);\n    return JSValue::encode(jsUndefined());\n}\n",
        "output": "1",
        "idx": 110
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "XGetModifierMapping(register Display *dpy)\n{\n    xGetModifierMappingReply rep;\n    register xReq *req;\n    unsigned long nbytes;\n    XModifierKeymap *res;\n\n    LockDisplay(dpy);\n     GetEmptyReq(GetModifierMapping, req);\n     (void) _XReply (dpy, (xReply *)&rep, 0, xFalse);\n \n    if (rep.length < (INT_MAX >> 2)) {\n \tnbytes = (unsigned long)rep.length << 2;\n \tres = Xmalloc(sizeof (XModifierKeymap));\n \tif (res)\n    } else\n\tres = NULL;\n    if ((! res) || (! res->modifiermap)) {\n\tXfree(res);\n\tres = (XModifierKeymap *) NULL;\n\t_XEatDataWords(dpy, rep.length);\n    } else {\n\t_XReadPad(dpy, (char *) res->modifiermap, (long) nbytes);\n\tres->max_keypermod = rep.numKeyPerModifier;\n    }\n\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return (res);\n}\n",
        "output": "1",
        "idx": 2086
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(pg_lo_write)\n{\n  \tzval *pgsql_id;\n  \tchar *str;\n  \tzend_long z_len;\n\tsize_t str_len, nbytes;\n\tsize_t len;\n\tpgLofp *pgsql;\n\tint argc = ZEND_NUM_ARGS();\n\n\tif (zend_parse_parameters(argc, \"rs|l\", &pgsql_id, &str, &str_len, &z_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (argc > 2) {\n\t\tif (z_len > (zend_long)str_len) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Cannot write more than buffer size %d. Tried to write %pd\", str_len, z_len);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tif (z_len < 0) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Buffer size must be larger than 0, but %pd was specified\", z_len);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tlen = z_len;\n\t}\n\telse {\n\t\tlen = str_len;\n\t}\n\n\tZEND_FETCH_RESOURCE(pgsql, pgLofp *, pgsql_id, -1, \"PostgreSQL large object\", le_lofp);\n\n\tif ((nbytes = lo_write((PGconn *)pgsql->conn, pgsql->lofd, str, len)) == -1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_LONG(nbytes);\n}\n",
        "output": "0",
        "idx": 1989
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static int inotify_release(struct inode *ignored, struct file *file)\n {\n \tstruct fsnotify_group *group = file->private_data;\n\tstruct user_struct *user = group->inotify_data.user;\n \n \tpr_debug(\"%s: group=%p\\n\", __func__, group);\n \n\tfsnotify_clear_marks_by_group(group);\n\n \t/* free this group, matching get was inotify_init->fsnotify_obtain_group */\n \tfsnotify_put_group(group);\n \n\tatomic_dec(&user->inotify_devs);\n \treturn 0;\n }\n",
        "output": "1",
        "idx": 96
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ProfileKeyedAPIFactory<BookmarksAPI>* BookmarksAPI::GetFactoryInstance() {\n  return &g_factory.Get();\n}\n",
        "output": "0",
        "idx": 1139
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RenderProcessHostImpl::TakeMetricsAllocator() {\n  return std::move(metrics_allocator_);\n}\n",
        "output": "0",
        "idx": 1291
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gfx::Size ScaleSizeToFitView(const gfx::Size& size,\n                             const gfx::Size& view_size) {\n  if ((size.width() > view_size.width() ||\n       size.height() > view_size.height()) ||\n      (size.width() < view_size.width() &&\n       size.height() < view_size.height())) {\n    const float scale =\n        std::min(view_size.width() / static_cast<float>(size.width()),\n                 view_size.height() / static_cast<float>(size.height()));\n    return gfx::ScaleToFlooredSize(size, scale);\n  }\n\n  return size;\n}\n",
        "output": "0",
        "idx": 1924
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int svc_rdma_xdr_encode_error(struct svcxprt_rdma *xprt,\n\t\t\t      struct rpcrdma_msg *rmsgp,\n\t\t\t      enum rpcrdma_errcode err, __be32 *va)\n{\n\t__be32 *startp = va;\n\t*va++ = rmsgp->rm_xid;\n\t*va++ = rmsgp->rm_vers;\n\t*va++ = xprt->sc_fc_credits;\n\t*va++ = rdma_error;\n\t*va++ = cpu_to_be32(err);\n\tif (err == ERR_VERS) {\n\t\t*va++ = rpcrdma_version;\n\t\t*va++ = rpcrdma_version;\n\t}\n\treturn (int)((unsigned long)va - (unsigned long)startp);\n}\n",
        "output": "1",
        "idx": 1516
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error::Error GLES2DecoderPassthroughImpl::DoUniform1i(GLint location, GLint x) {\n  api()->glUniform1iFn(location, x);\n  return error::kNoError;\n}\n",
        "output": "0",
        "idx": 1754
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void webkitWebViewBaseContainerAdd(GtkContainer* container, GtkWidget* widget)\n{\n    WebKitWebViewBase* webView = WEBKIT_WEB_VIEW_BASE(container);\n    WebKitWebViewBasePrivate* priv = webView->priv;\n\n    if (WEBKIT_IS_WEB_VIEW_BASE(widget)\n         && WebInspectorProxy::isInspectorPage(WEBKIT_WEB_VIEW_BASE(widget)->priv->pageProxy.get())) {\n         ASSERT(!priv->inspectorView);\n         priv->inspectorView = widget;\n        priv->inspectorViewHeight = gMinimumAttachedInspectorHeight;\n     } else {\n         GtkAllocation childAllocation;\n         gtk_widget_get_allocation(widget, &childAllocation);\n        priv->children.set(widget, childAllocation);\n    }\n\n    gtk_widget_set_parent(widget, GTK_WIDGET(container));\n}\n",
        "output": "1",
        "idx": 361
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void LinkChangeSerializerMarkupAccumulator::appendAttribute(StringBuilder& result, Element* element, const Attribute& attribute, Namespaces* namespaces)\n{\n    if (m_replaceLinks && element->isURLAttribute(attribute) && !element->isJavaScriptURLAttribute(attribute)) {\n        String completeURL = m_document->completeURL(attribute.value());\n        if (m_replaceLinks->contains(completeURL)) {\n            result.append(' ');\n            result.append(attribute.name().toString());\n            result.appendLiteral(\"=\\\"\");\n            if (!m_directoryName.isEmpty()) {\n                result.appendLiteral(\"./\");\n                result.append(m_directoryName);\n                result.append('/');\n            }\n            result.append(m_replaceLinks->get(completeURL));\n            result.appendLiteral(\"\\\"\");\n            return;\n        }\n    }\n    MarkupAccumulator::appendAttribute(result, element, attribute, namespaces);\n}\n",
        "output": "1",
        "idx": 812
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port)\n {\n\tstruct usb_serial\t*serial = port->serial;\n\tstruct usb_serial_port\t*wport;\n\twport = serial->port[1];\n\ttty_port_tty_set(&wport->port, tty);\n \treturn usb_serial_generic_open(tty, port);\n }\n",
        "output": "1",
        "idx": 585
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool SendGoBackJSONRequest(\n    AutomationMessageSender* sender,\n    int browser_index,\n    int tab_index,\n    std::string* error_msg) {\n  DictionaryValue dict;\n  dict.SetString(\"command\", \"GoBack\");\n  dict.SetInteger(\"windex\", browser_index);\n  dict.SetInteger(\"tab_index\", tab_index);\n  DictionaryValue reply_dict;\n  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);\n}\n",
        "output": "0",
        "idx": 1057
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,\n \t\t\t\t    struct net_device *ndev)\n {\n \tstruct hns_nic_priv *priv = netdev_priv(ndev);\n\tint ret;\n \n \tassert(skb->queue_mapping < ndev->ae_handle->q_num);\n\tret = hns_nic_net_xmit_hw(ndev, skb,\n\t\t\t\t  &tx_ring_data(priv, skb->queue_mapping));\n\tif (ret == NETDEV_TX_OK) {\n\t\tnetif_trans_update(ndev);\n\t\tndev->stats.tx_bytes += skb->len;\n\t\tndev->stats.tx_packets++;\n\t}\n\treturn (netdev_tx_t)ret;\n }\n",
        "output": "1",
        "idx": 480
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_wrap_iov(OM_uint32 *minor_status,\n\t\t    gss_ctx_id_t context_handle,\n\t\t    int conf_req_flag,\n\t\t    gss_qop_t qop_req,\n\t\t    int *conf_state,\n\t\t    gss_iov_buffer_desc *iov,\n \t\t    int iov_count)\n {\n \tOM_uint32 ret;\n \tret = gss_wrap_iov(minor_status,\n\t\t\t   context_handle,\n \t\t\t   conf_req_flag,\n \t\t\t   qop_req,\n \t\t\t   conf_state,\n\t\t\t   iov,\n\t\t\t   iov_count);\n\treturn (ret);\n}\n",
        "output": "1",
        "idx": 1907
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "UserCloudPolicyManagerChromeOS::UserCloudPolicyManagerChromeOS(\n    scoped_ptr<CloudPolicyStore> store,\n    scoped_ptr<CloudExternalDataManager> external_data_manager,\n    const base::FilePath& component_policy_cache_path,\n    bool wait_for_policy_fetch,\n    base::TimeDelta initial_policy_fetch_timeout,\n    const scoped_refptr<base::SequencedTaskRunner>& task_runner,\n    const scoped_refptr<base::SequencedTaskRunner>& file_task_runner,\n    const scoped_refptr<base::SequencedTaskRunner>& io_task_runner)\n    : CloudPolicyManager(\n          PolicyNamespaceKey(dm_protocol::kChromeUserPolicyType, std::string()),\n          store.get(),\n          task_runner,\n          file_task_runner,\n          io_task_runner),\n      store_(store.Pass()),\n      external_data_manager_(external_data_manager.Pass()),\n      component_policy_cache_path_(component_policy_cache_path),\n       wait_for_policy_fetch_(wait_for_policy_fetch),\n       policy_fetch_timeout_(false, false) {\n   time_init_started_ = base::Time::Now();\n  if (wait_for_policy_fetch_) {\n     policy_fetch_timeout_.Start(\n         FROM_HERE,\n         initial_policy_fetch_timeout,\n        base::Bind(&UserCloudPolicyManagerChromeOS::OnBlockingFetchTimeout,\n                   base::Unretained(this)));\n  }\n}\n",
        "output": "1",
        "idx": 1596
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " FileEntrySync* DirectoryEntrySync::getFile(const String& path, const Dictionary& options, ExceptionState& exceptionState)\n {\n     FileSystemFlags flags(options);\n    RefPtr<EntrySyncCallbackHelper> helper = EntrySyncCallbackHelper::create();\n     m_fileSystem->getFile(this, path, flags, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);\n     return static_cast<FileEntrySync*>(helper->getResult(exceptionState));\n }\n",
        "output": "1",
        "idx": 1939
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ScreenLockLibrary* CrosLibrary::GetScreenLockLibrary() {\n  return screen_lock_lib_.GetDefaultImpl(use_stub_impl_);\n}\n",
        "output": "1",
        "idx": 174
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,\n                                    float device_scale_factor,\n                                    const gfx::ColorSpace& color_space,\n                                    bool has_alpha,\n                                    bool use_stencil) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (initialize_waitable_event_) {\n     initialize_waitable_event_->Wait();\n    initialize_waitable_event_ = nullptr;\n   }\n \n   SkSurfaceCharacterization* characterization = nullptr;\n   if (characterization_.isValid()) {\n    characterization_ =\n        characterization_.createResized(size.width(), size.height());\n     RecreateRootRecorder();\n   } else {\n     characterization = &characterization_;\n    initialize_waitable_event_ = std::make_unique<base::WaitableEvent>(\n        base::WaitableEvent::ResetPolicy::MANUAL,\n        base::WaitableEvent::InitialState::NOT_SIGNALED);\n  }\n \n  auto callback = base::BindOnce(\n      &SkiaOutputSurfaceImplOnGpu::Reshape,\n      base::Unretained(impl_on_gpu_.get()), size, device_scale_factor,\n      std::move(color_space), has_alpha, use_stencil, pre_transform_,\n      characterization, initialize_waitable_event_.get());\n  ScheduleGpuTask(std::move(callback), std::vector<gpu::SyncToken>());\n }\n",
        "output": "1",
        "idx": 1506
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int search_old_relocation(struct reloc_struct_t *reloc_table, ut32 addr_to_patch, int n_reloc) {\n \tint i;\n \tfor (i = 0; i < n_reloc; i++) {\n \t\tif (addr_to_patch == reloc_table[i].data_offset) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n",
        "output": "1",
        "idx": 1650
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void GpuVideoDecodeAccelerator::OnDecode(\n    base::SharedMemoryHandle handle, int32 id, int32 size) {\n   DCHECK(video_decode_accelerator_.get());\n   video_decode_accelerator_->Decode(media::BitstreamBuffer(id, handle, size));\n }\n",
        "output": "1",
        "idx": 22
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderWidgetHostViewAura::ExtendSelectionAndDelete(\n    size_t before, size_t after) {\n  RenderFrameHostImpl* rfh = GetFocusedFrame();\n  if (rfh)\n    rfh->ExtendSelectionAndDelete(before, after);\n}\n",
        "output": "0",
        "idx": 950
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebContentsImpl::DidFailProvisionalLoadWithError(\n    RenderViewHost* render_view_host,\n    const ViewHostMsg_DidFailProvisionalLoadWithError_Params& params) {\n  VLOG(1) << \"Failed Provisional Load: \" << params.url.possibly_invalid_spec()\n          << \", error_code: \" << params.error_code\n          << \", error_description: \" << params.error_description\n          << \", is_main_frame: \" << params.is_main_frame\n          << \", showing_repost_interstitial: \" <<\n            params.showing_repost_interstitial\n          << \", frame_id: \" << params.frame_id;\n  GURL validated_url(params.url);\n  RenderProcessHost* render_process_host =\n      render_view_host->GetProcess();\n  RenderViewHost::FilterURL(render_process_host, false, &validated_url);\n\n  if (net::ERR_ABORTED == params.error_code) {\n    if (ShowingInterstitialPage()) {\n      LOG(WARNING) << \"Discarding message during interstitial.\";\n       return;\n     }\n \n     render_manager_.RendererAbortedProvisionalLoad(render_view_host);\n   }\n \n   FOR_EACH_OBSERVER(WebContentsObserver,\n                     observers_,\n                     DidFailProvisionalLoad(params.frame_id,\n                                           params.is_main_frame,\n                                           validated_url,\n                                           params.error_code,\n                                           params.error_description,\n                                           render_view_host));\n}\n",
        "output": "1",
        "idx": 1433
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ExtensionOptionsGuest::DidNavigateMainFrame(\n    const content::LoadCommittedDetails& details,\n    const content::FrameNavigateParams& params) {\n  if (attached()) {\n    auto guest_zoom_controller =\n        ui_zoom::ZoomController::FromWebContents(web_contents());\n    guest_zoom_controller->SetZoomMode(\n         ui_zoom::ZoomController::ZOOM_MODE_ISOLATED);\n     SetGuestZoomLevelToMatchEmbedder();\n \n    if (params.url.GetOrigin() != options_page_.GetOrigin()) {\n       bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(),\n                                       bad_message::EOG_BAD_ORIGIN);\n     }\n  }\n}\n",
        "output": "1",
        "idx": 1499
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CacheThru_abort(HTStream *me, HTError e)\n{\n    if (me->fp)\n\tLYCloseTempFP(me->fp);\n    if (LYCacheSourceForAborted == SOURCE_CACHE_FOR_ABORTED_DROP) {\n\tif (me->filename) {\n\t    CTRACE((tfp, \"SourceCacheWriter: Removing active file %s\\n\",\n\t\t    me->filename));\n\t    (void) LYRemoveTemp(me->filename);\n\t    FREE(me->filename);\n\t}\n\tif (me->chunk) {\n\t    CTRACE((tfp,\n\t\t    \"SourceCacheWriter: Removing active memory chunk %p\\n\",\n\t\t    (void *) me->chunk));\n\t    HTChunkFree(me->chunk);\n\t}\n    } else {\n\tme->status = HT_OK;\t/*fake it */\n\tCacheThru_do_free(me);\n    }\n    (*me->actions->_abort) (me->target, e);\n    FREE(me);\n}\n",
        "output": "0",
        "idx": 1762
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ResourceDispatcherHost::~ResourceDispatcherHost() {\n  AsyncResourceHandler::GlobalCleanup();\n   STLDeleteValues(&pending_requests_);\n \n   user_script_listener_->ShutdownMainThread();\n  std::set<ProcessRouteIDs> ids;\n  for (BlockedRequestMap::const_iterator iter = blocked_requests_map_.begin();\n       iter != blocked_requests_map_.end(); ++iter) {\n    std::pair<std::set<ProcessRouteIDs>::iterator, bool> result =\n        ids.insert(iter->first);\n    DCHECK(result.second);\n  }\n  for (std::set<ProcessRouteIDs>::const_iterator iter = ids.begin();\n       iter != ids.end(); ++iter) {\n    CancelBlockedRequestsForRoute(iter->first, iter->second);\n  }\n }\n",
        "output": "1",
        "idx": 1610
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nfsd4_close(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t    struct nfsd4_close *close)\n{\n\t__be32 status;\n\tstruct nfs4_ol_stateid *stp;\n\tstruct net *net = SVC_NET(rqstp);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tdprintk(\"NFSD: nfsd4_close on file %pd\\n\", \n\t\t\tcstate->current_fh.fh_dentry);\n\n\tstatus = nfs4_preprocess_seqid_op(cstate, close->cl_seqid,\n\t\t\t\t\t&close->cl_stateid,\n\t\t\t\t\tNFS4_OPEN_STID|NFS4_CLOSED_STID,\n\t\t\t\t\t&stp, nn);\n\tnfsd4_bump_seqid(cstate, status);\n\tif (status)\n\t\tgoto out; \n\tnfs4_inc_and_copy_stateid(&close->cl_stateid, &stp->st_stid);\n\tmutex_unlock(&stp->st_mutex);\n\n\tnfsd4_close_open_stateid(stp);\n\n\t/* put reference from nfs4_preprocess_seqid_op */\n\tnfs4_put_stid(&stp->st_stid);\nout:\n\treturn status;\n}\n",
        "output": "0",
        "idx": 312
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void checkPtrmap(\n  IntegrityCk *pCheck,   /* Integrity check context */\n  Pgno iChild,           /* Child page number */\n  u8 eType,              /* Expected pointer map type */\n  Pgno iParent           /* Expected pointer map parent page number */\n){\n  int rc;\n  u8 ePtrmapType;\n  Pgno iPtrmapParent;\n\n  rc = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &iPtrmapParent);\n  if( rc!=SQLITE_OK ){\n    if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ) pCheck->mallocFailed = 1;\n    checkAppendMsg(pCheck, \"Failed to read ptrmap key=%d\", iChild);\n    return;\n  }\n\n  if( ePtrmapType!=eType || iPtrmapParent!=iParent ){\n    checkAppendMsg(pCheck,\n      \"Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)\", \n      iChild, eType, iParent, ePtrmapType, iPtrmapParent);\n  }\n}\n",
        "output": "0",
        "idx": 1670
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " bool GesturePoint::IsInSecondClickTimeWindow() const {\n   double duration =  last_touch_time_ - last_tap_time_;\n  return duration < kMaximumSecondsBetweenDoubleClick;\n }\n",
        "output": "1",
        "idx": 1614
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WebPlugin* RenderView::CreateNPAPIPlugin(\n    WebFrame* frame,\n    const WebPluginParams& params,\n    const FilePath& path,\n    const std::string& mime_type) {\n  return new webkit::npapi::WebPluginImpl(\n      frame, params, path, mime_type, AsWeakPtr());\n}\n",
        "output": "0",
        "idx": 2013
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "     virtual void scheduleBeginFrameAndCommit()\n     {\n        CCMainThread::postTask(m_proxy->createBeginFrameAndCommitTaskOnCCThread());\n     }\n",
        "output": "1",
        "idx": 1705
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "VOID NBLSet8021QInfo(PPARANDIS_ADAPTER pContext, PNET_BUFFER_LIST pNBL, PNET_PACKET_INFO pPacketInfo)\n{\n    NDIS_NET_BUFFER_LIST_8021Q_INFO qInfo;\n    qInfo.Value = NULL;\n\n    if (IsPrioritySupported(pContext))\n        qInfo.TagHeader.UserPriority = pPacketInfo->Vlan.UserPriority;\n\n    if (IsVlanSupported(pContext))\n        qInfo.TagHeader.VlanId = pPacketInfo->Vlan.VlanId;\n\n    if(qInfo.Value != NULL)\n        pContext->extraStatistics.framesRxPriority++;\n\n    NET_BUFFER_LIST_INFO(pNBL, Ieee8021QNetBufferListInfo) = qInfo.Value;\n}\n",
        "output": "0",
        "idx": 2025
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static v8::Handle<v8::Value> acceptTransferListCallback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestSerializedScriptValueInterface.acceptTransferList\");\n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestSerializedScriptValueInterface* imp = V8TestSerializedScriptValueInterface::toNative(args.Holder());\n     MessagePortArray messagePortArrayTransferList;\n     ArrayBufferArray arrayBufferArrayTransferList;\n    if (args.Length() > 1) {\n        if (!extractTransferables(args[1], messagePortArrayTransferList, arrayBufferArrayTransferList))\n            return V8Proxy::throwTypeError(\"Could not extract transferables\");\n    }\n    bool dataDidThrow = false;\n    RefPtr<SerializedScriptValue> data = SerializedScriptValue::create(args[0], &messagePortArrayTransferList, &arrayBufferArrayTransferList, dataDidThrow, args.GetIsolate());\n    if (dataDidThrow)\n        return v8::Undefined();\n    if (args.Length() <= 1) {\n        imp->acceptTransferList(data);\n        return v8::Handle<v8::Value>();\n    }\n    imp->acceptTransferList(data, messagePortArrayTransferList);\n    return v8::Handle<v8::Value>();\n}\n",
        "output": "1",
        "idx": 407
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void br_multicast_del_pg(struct net_bridge *br,\n\t\t\t\tstruct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\n\tmp = br_mdb_ip_get(mdb, &pg->addr);\n\tif (WARN_ON(!mp))\n\t\treturn;\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p != pg)\n\t\t\tcontinue;\n\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n \t\tdel_timer(&p->timer);\n \t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n \n\t\tif (!mp->ports && !mp->mglist &&\n \t\t    netif_running(br->dev))\n \t\t\tmod_timer(&mp->timer, jiffies);\n \n\t\treturn;\n\t}\n\n\tWARN_ON(1);\n}\n",
        "output": "1",
        "idx": 1063
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool RenderFrameImpl::UniqueNameFrameAdapter::IsMainFrame() const {\n  return render_frame_->IsMainFrame();\n}\n",
        "output": "0",
        "idx": 900
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  bool IsMultiByteResponseExpected() {\n    return multibyte_response_expected_;\n  }\n",
        "output": "0",
        "idx": 713
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t Camera3Device::createDefaultRequest(int templateId,\n\n         CameraMetadata *request) {\n     ATRACE_CALL();\n     ALOGV(\"%s: for template %d\", __FUNCTION__, templateId);\n     Mutex::Autolock il(mInterfaceLock);\n     Mutex::Autolock l(mLock);\n \n switch (mStatus) {\n case STATUS_ERROR:\n            CLOGE(\"Device has encountered a serious error\");\n return INVALID_OPERATION;\n case STATUS_UNINITIALIZED:\n            CLOGE(\"Device is not initialized!\");\n return INVALID_OPERATION;\n case STATUS_UNCONFIGURED:\n case STATUS_CONFIGURED:\n case STATUS_ACTIVE:\n break;\n default:\n            SET_ERR_L(\"Unexpected status: %d\", mStatus);\n return INVALID_OPERATION;\n }\n\n if (!mRequestTemplateCache[templateId].isEmpty()) {\n *request = mRequestTemplateCache[templateId];\n return OK;\n }\n\n const camera_metadata_t *rawRequest;\n    ATRACE_BEGIN(\"camera3->construct_default_request_settings\");\n    rawRequest = mHal3Device->ops->construct_default_request_settings(\n        mHal3Device, templateId);\n    ATRACE_END();\n if (rawRequest == NULL) {\n        ALOGI(\"%s: template %d is not supported on this camera device\",\n              __FUNCTION__, templateId);\n return BAD_VALUE;\n }\n *request = rawRequest;\n    mRequestTemplateCache[templateId] = rawRequest;\n\n return OK;\n}\n",
        "output": "1",
        "idx": 1394
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TextIterator::handleTextNodeFirstLetter(RenderTextFragment* renderer)\n{\n    if (renderer->firstLetter()) {\n        RenderObject* r = renderer->firstLetter();\n        if (r->style()->visibility() != VISIBLE && !m_ignoresStyleVisibility)\n            return;\n        if (RenderText* firstLetter = firstRenderTextInFirstLetter(r)) {\n            m_handledFirstLetter = true;\n            m_remainingTextBox = m_textBox;\n            m_textBox = firstLetter->firstTextBox();\n            m_sortedTextBoxes.clear();\n            m_firstLetterText = firstLetter;\n        }\n    }\n    m_handledFirstLetter = true;\n}\n",
        "output": "0",
        "idx": 568
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void copyStereo8(\n         short *dst,\n        const int *const *src,\n         unsigned nSamples,\n         unsigned /* nChannels */) {\n     for (unsigned i = 0; i < nSamples; ++i) {\n *dst++ = src[0][i] << 8;\n *dst++ = src[1][i] << 8;\n\n     }\n }\n",
        "output": "1",
        "idx": 1297
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ACodec::UninitializedState::UninitializedState(ACodec *codec)\n : BaseState(codec) {\n}\n",
        "output": "0",
        "idx": 1124
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void invalidate_cursor1(CirrusVGAState *s)\n{\n    if (s->last_hw_cursor_size) {\n        vga_invalidate_scanlines(&s->vga,\n                                 s->last_hw_cursor_y + s->last_hw_cursor_y_start,\n                                 s->last_hw_cursor_y + s->last_hw_cursor_y_end);\n    }\n}\n",
        "output": "0",
        "idx": 188
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mm_sshpam_init_ctx(Authctxt *authctxt)\n{\n\tBuffer m;\n\tint success;\n \n \tdebug3(\"%s\", __func__);\n \tbuffer_init(&m);\n\tbuffer_put_cstring(&m, authctxt->user);\n \tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_INIT_CTX, &m);\n \tdebug3(\"%s: waiting for MONITOR_ANS_PAM_INIT_CTX\", __func__);\n \tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PAM_INIT_CTX, &m);\n\tsuccess = buffer_get_int(&m);\n\tif (success == 0) {\n\t\tdebug3(\"%s: pam_init_ctx failed\", __func__);\n\t\tbuffer_free(&m);\n\t\treturn (NULL);\n\t}\n\tbuffer_free(&m);\n\treturn (authctxt);\n}\n",
        "output": "1",
        "idx": 33
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Eina_Bool ewk_frame_back(Evas_Object* ewkFrame)\n{\n    return ewk_frame_navigate(ewkFrame, -1);\n}\n",
        "output": "0",
        "idx": 615
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "EncodedJSValue JSC_HOST_CALL JSTestObjConstructor::constructJSTestObj(ExecState* exec)\n {\n     JSTestObjConstructor* castedThis = jsCast<JSTestObjConstructor*>(exec->callee());\n     if (exec->argumentCount() < 1)\n        return throwVMError(exec, createTypeError(exec, \"Not enough arguments\"));\n     if (exec->argumentCount() <= 0 || !exec->argument(0).isFunction()) {\n         setDOMException(exec, TYPE_MISMATCH_ERR);\n         return JSValue::encode(jsUndefined());\n    }\n    RefPtr<TestCallback> testCallback = JSTestCallback::create(asObject(exec->argument(0)), castedThis->globalObject());\n    RefPtr<TestObj> object = TestObj::create(testCallback);\n    return JSValue::encode(asObject(toJS(exec, castedThis->globalObject(), object.get())));\n}\n",
        "output": "1",
        "idx": 565
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  gray_render_span( int             y,\n                    int             count,\n                    const FT_Span*  spans,\n                    PWorker         worker )\n  {\n    unsigned char*  p;\n    FT_Bitmap*      map = &worker->target;\n\n\n     /* first of all, compute the scanline offset */\n     p = (unsigned char*)map->buffer - y * map->pitch;\n     if ( map->pitch >= 0 )\n      p += ( map->rows - 1 ) * map->pitch;\n \n     for ( ; count > 0; count--, spans++ )\n     {\n      unsigned char  coverage = spans->coverage;\n\n\n      if ( coverage )\n      {\n        /* For small-spans it is faster to do it by ourselves than\n         * calling `memset'.  This is mainly due to the cost of the\n         * function call.\n         */\n        if ( spans->len >= 8 )\n          FT_MEM_SET( p + spans->x, (unsigned char)coverage, spans->len );\n        else\n        {\n          unsigned char*  q = p + spans->x;\n\n\n          switch ( spans->len )\n          {\n          case 7: *q++ = (unsigned char)coverage;\n          case 6: *q++ = (unsigned char)coverage;\n          case 5: *q++ = (unsigned char)coverage;\n          case 4: *q++ = (unsigned char)coverage;\n          case 3: *q++ = (unsigned char)coverage;\n          case 2: *q++ = (unsigned char)coverage;\n          case 1: *q   = (unsigned char)coverage;\n          default:\n            ;\n          }\n        }\n      }\n    }\n  }\n",
        "output": "1",
        "idx": 241
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void StartupBrowserCreator::AddFirstRunTab(const GURL& url) {\n  first_run_tabs_.push_back(url);\n}\n",
        "output": "0",
        "idx": 917
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void enforcedRangeLongLongAttrAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMSetter\");\n    TestObjectV8Internal::enforcedRangeLongLongAttrAttributeSetter(jsValue, info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "output": "0",
        "idx": 240
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int proc_key_users_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &proc_key_users_ops);\n}\n",
        "output": "0",
        "idx": 1683
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int hashtable_set(hashtable_t *hashtable,\n                  const char *key, size_t serial,\n                  json_t *value)\n{\n    pair_t *pair;\n    bucket_t *bucket;\n     size_t hash, index;\n \n     /* rehash if the load ratio exceeds 1 */\n    if(hashtable->size >= num_buckets(hashtable))\n         if(hashtable_do_rehash(hashtable))\n             return -1;\n \n     hash = hash_str(key);\n    index = hash % num_buckets(hashtable);\n     bucket = &hashtable->buckets[index];\n     pair = hashtable_find_pair(hashtable, bucket, key, hash);\n \n    if(pair)\n    {\n        json_decref(pair->value);\n        pair->value = value;\n    }\n    else\n    {\n        /* offsetof(...) returns the size of pair_t without the last,\n           flexible member. This way, the correct amount is\n           allocated. */\n        pair = jsonp_malloc(offsetof(pair_t, key) + strlen(key) + 1);\n        if(!pair)\n            return -1;\n\n        pair->hash = hash;\n        pair->serial = serial;\n        strcpy(pair->key, key);\n        pair->value = value;\n        list_init(&pair->list);\n\n        insert_to_bucket(hashtable, bucket, &pair->list);\n\n        hashtable->size++;\n    }\n    return 0;\n}\n",
        "output": "1",
        "idx": 1691
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " int PDFiumEngine::GetVisiblePageIndex(FPDF_PAGE page) {\n  for (int page_index : visible_pages_) {\n     if (pages_[page_index]->GetPage() == page)\n       return page_index;\n   }\n  return -1;\n}\n",
        "output": "1",
        "idx": 1810
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "content::ColorChooser* ShowColorChooser(content::WebContents* web_contents,\n                                        SkColor initial_color) {\n#if defined(USE_ASH)\n  gfx::NativeView native_view = web_contents->GetView()->GetNativeView();\n  if (GetHostDesktopTypeForNativeView(native_view) == HOST_DESKTOP_TYPE_ASH)\n    return ColorChooserAura::Open(web_contents, initial_color);\n#endif\n  return ColorChooserWin::Open(web_contents, initial_color);\n}\n",
        "output": "0",
        "idx": 1206
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void V8TestObject::Uint8ArrayMethodMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_uint8ArrayMethod\");\n\n  test_object_v8_internal::Uint8ArrayMethodMethod(info);\n}\n",
        "output": "0",
        "idx": 1294
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct edid *drm_load_edid_firmware(struct drm_connector *connector)\n{\n\tconst char *connector_name = connector->name;\n\tchar *edidname, *last, *colon, *fwstr, *edidstr, *fallback = NULL;\n\tstruct edid *edid;\n\n\tif (edid_firmware[0] == '\\0')\n\t\treturn ERR_PTR(-ENOENT);\n\n\t/*\n\t * If there are multiple edid files specified and separated\n\t * by commas, search through the list looking for one that\n\t * matches the connector.\n\t *\n\t * If there's one or more that doesn't specify a connector, keep\n \t * the last one found one as a fallback.\n \t */\n \tfwstr = kstrdup(edid_firmware, GFP_KERNEL);\n \tedidstr = fwstr;\n \n \twhile ((edidname = strsep(&edidstr, \",\"))) {\n\t\t\tif (strncmp(connector_name, edidname, colon - edidname))\n\t\t\t\tcontinue;\n\t\t\tedidname = colon + 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (*edidname != '\\0') /* corner case: multiple ',' */\n\t\t\tfallback = edidname;\n\t}\n",
        "output": "1",
        "idx": 1240
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " virtual bool DnsResolveEx(const std::string& host,\n                            std::string* ip_address_list) {\n    dns_resolves_ex.push_back(host);\n *ip_address_list = dns_resolve_ex_result;\n return !dns_resolve_ex_result.empty();\n }\n",
        "output": "0",
        "idx": 1565
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rose_add_loopback_neigh(void)\n{\n\tstruct rose_neigh *sn;\n\n\trose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_KERNEL);\n\tif (!rose_loopback_neigh)\n\t\treturn;\n\tsn = rose_loopback_neigh;\n\n\tsn->callsign  = null_ax25_address;\n\tsn->digipeat  = NULL;\n\tsn->ax25      = NULL;\n\tsn->dev       = NULL;\n\tsn->count     = 0;\n\tsn->use       = 0;\n\tsn->dce_mode  = 1;\n\tsn->loopback  = 1;\n\tsn->number    = rose_neigh_no++;\n\tsn->restarted = 1;\n\n\tskb_queue_head_init(&sn->queue);\n\n\tinit_timer(&sn->ftimer);\n\tinit_timer(&sn->t0timer);\n\n\tspin_lock_bh(&rose_neigh_list_lock);\n\tsn->next = rose_neigh_list;\n\trose_neigh_list           = sn;\n\tspin_unlock_bh(&rose_neigh_list_lock);\n}\n",
        "output": "0",
        "idx": 1903
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *gid)\n{\n\tuint32_t len;\n\t__be32 *p;\n\n\t*gid = -2;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {\n\t\tREAD_BUF(4);\n\t\tREAD32(len);\n\t\tREAD_BUF(len);\n\t\tif (len < XDR_MAX_NETOBJ) {\n\t\t\tif (nfs_map_group_to_gid(clp, (char *)p, len, gid) != 0)\n\t\t\t\tdprintk(\"%s: nfs_map_group_to_gid failed!\\n\",\n\t\t\t\t\t\t__func__);\n\t\t} else\n\t\t\tdprintk(\"%s: name too long (%u)!\\n\",\n\t\t\t\t\t__func__, len);\n\t\tbitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;\n\t}\n\tdprintk(\"%s: gid=%d\\n\", __func__, (int)*gid);\n\treturn 0;\n}\n",
        "output": "0",
        "idx": 2073
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fn_printzp(netdissect_options *ndo,\n           register const u_char *s, register u_int n,\n           register const u_char *ep)\n{\n\tregister int ret;\n\tregister u_char c;\n\n\tret = 1;\t\t\t/* assume truncated */\n\twhile (n > 0 && (ep == NULL || s < ep)) {\n\t\tn--;\n\t\tc = *s++;\n\t\tif (c == '\\0') {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ND_ISASCII(c)) {\n\t\t\tc = ND_TOASCII(c);\n\t\t\tND_PRINT((ndo, \"M-\"));\n\t\t}\n\t\tif (!ND_ISPRINT(c)) {\n\t\t\tc ^= 0x40;\t/* DEL to ?, others to alpha */\n\t\t\tND_PRINT((ndo, \"^\"));\n\t\t}\n\t\tND_PRINT((ndo, \"%c\", c));\n\t}\n\treturn (n == 0) ? 0 : ret;\n}\n",
        "output": "0",
        "idx": 971
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " views::View* LauncherView::GetAppListButtonView() const {\n   for (int i = 0; i < model_->item_count(); ++i) {\n     if (model_->items()[i].type == TYPE_APP_LIST)\n      return view_model_->view_at(i);\n  }\n\n  NOTREACHED() << \"Applist button not found\";\n  return NULL;\n}\n",
        "output": "0",
        "idx": 1830
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "FileTransfer::AddDownloadFilenameRemap(char const *source_name,char const *target_name) {\n\tif(!download_filename_remaps.IsEmpty()) {\n\t\tdownload_filename_remaps += \";\";\n\t}\n\tdownload_filename_remaps += source_name;\n\tdownload_filename_remaps += \"=\";\n\tdownload_filename_remaps += target_name;\n}\n",
        "output": "0",
        "idx": 1877
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void xdr_init_encode(struct xdr_stream *xdr, struct xdr_buf *buf, __be32 *p)\n{\n\tstruct kvec *iov = buf->head;\n\tint scratch_len = buf->buflen - buf->page_len - buf->tail[0].iov_len;\n\n\tBUG_ON(scratch_len < 0);\n\txdr->buf = buf;\n\txdr->iov = iov;\n\txdr->p = (__be32 *)((char *)iov->iov_base + iov->iov_len);\n\txdr->end = (__be32 *)((char *)iov->iov_base + scratch_len);\n\tBUG_ON(iov->iov_len > scratch_len);\n\n\tif (p != xdr->p && p != NULL) {\n\t\tsize_t len;\n\n\t\tBUG_ON(p < xdr->p || p > xdr->end);\n\t\tlen = (char *)p - (char *)xdr->p;\n\t\txdr->p = p;\n\t\tbuf->len += len;\n\t\tiov->iov_len += len;\n\t}\n}\n",
        "output": "0",
        "idx": 1306
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void echo_set_canon_col(struct n_tty_data *ldata)\n{\n\tadd_echo_byte(ECHO_OP_START, ldata);\n\tadd_echo_byte(ECHO_OP_SET_CANON_COL, ldata);\n}\n",
        "output": "0",
        "idx": 1509
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GpuCommandBufferStub::OnCommandProcessed() {\n  if (watchdog_)\n    watchdog_->CheckArmed();\n}\n",
        "output": "0",
        "idx": 1102
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "OMXNodeInstance::OMXNodeInstance(\n        OMX *owner, const sp<IOMXObserver> &observer, const char *name)\n : mOwner(owner),\n      mNodeID(0),\n\n       mHandle(NULL),\n       mObserver(observer),\n       mDying(false),\n       mBufferIDCount(0)\n {\n     mName = ADebug::GetDebugName(name);\n    DEBUG = ADebug::GetDebugLevelFromProperty(name, \"debug.stagefright.omx-debug\");\n    ALOGV(\"debug level for %s is %d\", name, DEBUG);\n    DEBUG_BUMP = DEBUG;\n    mNumPortBuffers[0] = 0;\n    mNumPortBuffers[1] = 0;\n    mDebugLevelBumpPendingBuffers[0] = 0;\n    mDebugLevelBumpPendingBuffers[1] = 0;\n    mMetadataType[0] = kMetadataBufferTypeInvalid;\n    mMetadataType[1] = kMetadataBufferTypeInvalid;\n    mSecureBufferType[0] = kSecureBufferTypeUnknown;\n    mSecureBufferType[1] = kSecureBufferTypeUnknown;\n    mIsSecure = AString(name).endsWith(\".secure\");\n}\n",
        "output": "1",
        "idx": 2075
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SProcXFixesCreatePointerBarrier(ClientPtr client)\n{\n    REQUEST(xXFixesCreatePointerBarrierReq);\n    int i;\n     int i;\n     CARD16 *in_devices = (CARD16 *) &stuff[1];\n \n     swaps(&stuff->length);\n     swaps(&stuff->num_devices);\n     REQUEST_FIXED_SIZE(xXFixesCreatePointerBarrierReq, pad_to_int32(stuff->num_devices));\n    swaps(&stuff->x1);\n    swaps(&stuff->y1);\n    swaps(&stuff->x2);\n    swaps(&stuff->y2);\n    swapl(&stuff->directions);\n    for (i = 0; i < stuff->num_devices; i++) {\n        swaps(in_devices + i);\n    }\n\n    return ProcXFixesVector[stuff->xfixesReqType] (client);\n}\n",
        "output": "1",
        "idx": 2012
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PPB_URLLoader_Impl::RunCallback(int32_t result) {\n  if (!pending_callback_.get()) {\n     CHECK(main_document_loader_);\n     return;\n   }\n   TrackedCallback::ClearAndRun(&pending_callback_, result);\n }\n",
        "output": "1",
        "idx": 877
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ArcVoiceInteractionFrameworkService::ToggleSessionFromUserInteraction() {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n\n  if (!InitiateUserInteraction(true /* is_toggle */))\n    return;\n\n  mojom::VoiceInteractionFrameworkInstance* framework_instance =\n      ARC_GET_INSTANCE_FOR_METHOD(\n          arc_bridge_service_->voice_interaction_framework(),\n          ToggleVoiceInteractionSession);\n  DCHECK(framework_instance);\n  framework_instance->ToggleVoiceInteractionSession(IsHomescreenActive());\n}\n",
        "output": "0",
        "idx": 1854
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void advance(struct pt_regs *regs)\n{\n\tregs->tpc   = regs->tnpc;\n\tregs->tnpc += 4;\n\tif (test_thread_flag(TIF_32BIT)) {\n\t\tregs->tpc &= 0xffffffff;\n\t\tregs->tnpc &= 0xffffffff;\n\t}\n}\n",
        "output": "0",
        "idx": 1707
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void Initialize(ChannelLayout channel_layout, int bits_per_channel) {\n     AudioParameters params(\n         media::AudioParameters::AUDIO_PCM_LINEAR, channel_layout,\n        kSamplesPerSecond, bits_per_channel, kRawDataSize);\n \n     algorithm_.Initialize(1, params, base::Bind(\n         &AudioRendererAlgorithmTest::EnqueueData, base::Unretained(this)));\n    EnqueueData();\n  }\n",
        "output": "1",
        "idx": 1575
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gfx::Size GLES2DecoderImpl::GetBoundReadFrameBufferSize() {\n  Framebuffer* framebuffer =\n      GetFramebufferInfoForTarget(GL_READ_FRAMEBUFFER_EXT);\n  if (framebuffer != NULL) {\n    const Framebuffer::Attachment* attachment =\n        framebuffer->GetAttachment(GL_COLOR_ATTACHMENT0);\n    if (attachment) {\n      return gfx::Size(attachment->width(), attachment->height());\n    }\n    return gfx::Size(0, 0);\n  } else if (offscreen_target_frame_buffer_.get()) {\n    return offscreen_size_;\n  } else {\n    return surface_->GetSize();\n  }\n}\n",
        "output": "0",
        "idx": 85
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ppp_gidle(unsigned int fd, unsigned int cmd,\n\t\tstruct ppp_idle32 __user *idle32)\n{\n\tstruct ppp_idle __user *idle;\n\t__kernel_time_t xmit, recv;\n\tint err;\n\n\tidle = compat_alloc_user_space(sizeof(*idle));\n\n\terr = sys_ioctl(fd, PPPIOCGIDLE, (unsigned long) idle);\n\n\tif (!err) {\n\t\tif (get_user(xmit, &idle->xmit_idle) ||\n\t\t    get_user(recv, &idle->recv_idle) ||\n\t\t    put_user(xmit, &idle32->xmit_idle) ||\n\t\t    put_user(recv, &idle32->recv_idle))\n\t\t\terr = -EFAULT;\n\t}\n\treturn err;\n}\n",
        "output": "0",
        "idx": 1977
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "native_handle* Parcel::readNativeHandle() const\n{\n int numFds, numInts;\n status_t err;\n    err = readInt32(&numFds);\n if (err != NO_ERROR) return 0;\n    err = readInt32(&numInts);\n if (err != NO_ERROR) return 0;\n\n    native_handle* h = native_handle_create(numFds, numInts);\n if (!h) {\n return 0;\n }\n\n \n     for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {\n         h->data[i] = dup(readFileDescriptor());\n        if (h->data[i] < 0) err = BAD_VALUE;\n     }\n     err = read(h->data + numFds, sizeof(int)*numInts);\n     if (err != NO_ERROR) {\n        native_handle_close(h);\n        native_handle_delete(h);\n        h = 0;\n }\n return h;\n}\n",
        "output": "1",
        "idx": 1082
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  static void CloudPrintInfoCallback(bool enabled,\n                                     const std::string& email,\n                                     const std::string& proxy_id) {\n    QuitMessageLoop();\n   }\n",
        "output": "1",
        "idx": 49
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " virtual void ResetModel() {\n    last_pts_ = 0;\n    bits_in_buffer_model_ = cfg_.rc_target_bitrate * cfg_.rc_buf_initial_sz;\n    frame_number_ = 0;\n\n     tot_frame_number_ = 0;\n     first_drop_ = 0;\n     num_drops_ = 0;\n     for (int i = 0; i < 3; ++i) {\n       bits_total_[i] = 0;\n     }\n   }\n",
        "output": "1",
        "idx": 558
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int vmcs12_write_any(struct kvm_vcpu *vcpu,\n\t\t\t\t   unsigned long field, u64 field_value){\n\tshort offset = vmcs_field_to_offset(field);\n\tchar *p = ((char *) get_vmcs12(vcpu)) + offset;\n\tif (offset < 0)\n\t\treturn offset;\n\n\tswitch (vmcs_field_width(field)) {\n\tcase VMCS_FIELD_WIDTH_U16:\n\t\t*(u16 *)p = field_value;\n\t\treturn 0;\n\tcase VMCS_FIELD_WIDTH_U32:\n\t\t*(u32 *)p = field_value;\n\t\treturn 0;\n\tcase VMCS_FIELD_WIDTH_U64:\n\t\t*(u64 *)p = field_value;\n\t\treturn 0;\n\tcase VMCS_FIELD_WIDTH_NATURAL_WIDTH:\n\t\t*(natural_width *)p = field_value;\n\t\treturn 0;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -ENOENT;\n\t}\n\n}\n",
        "output": "0",
        "idx": 69
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WallpaperManager::InitializeRegisteredDeviceWallpaper() {\n  if (user_manager::UserManager::Get()->IsUserLoggedIn())\n    return;\n\n  bool disable_boot_animation =\n      GetCommandLine()->HasSwitch(switches::kDisableBootAnimation);\n  bool show_users = true;\n  bool result = CrosSettings::Get()->GetBoolean(\n      kAccountsPrefShowUserNamesOnSignIn, &show_users);\n  DCHECK(result) << \"Unable to fetch setting \"\n                 << kAccountsPrefShowUserNamesOnSignIn;\n  const user_manager::UserList& users =\n      user_manager::UserManager::Get()->GetUsers();\n  int public_session_user_index = FindPublicSession(users);\n  if ((!show_users && public_session_user_index == -1) ||\n      !HasNonDeviceLocalAccounts(users)) {\n    if (!SetDeviceWallpaperIfApplicable(user_manager::SignInAccountId()))\n      SetDefaultWallpaperDelayed(user_manager::SignInAccountId());\n    return;\n  }\n\n  if (!disable_boot_animation) {\n    int index = public_session_user_index != -1 ? public_session_user_index : 0;\n    SetUserWallpaperDelayed(users[index]->GetAccountId());\n  }\n}\n",
        "output": "0",
        "idx": 664
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hash_foreach_mangle_dict_of_strings (gpointer key, gpointer val, gpointer user_data)\n{\n  GHashTable *out = (GHashTable*) user_data;\n  GHashTable *in_dict = (GHashTable *) val;\n  HashAndString *data = g_new0 (HashAndString, 1);\n  data->string = (gchar*) key;\n  data->hash = g_hash_table_new_full (g_str_hash, g_str_equal,\n                                            g_free, g_free);\n  g_hash_table_foreach (in_dict, hash_foreach_prepend_string, data);\n  g_hash_table_insert(out, g_strdup ((gchar*) key), data->hash);\n}\n",
        "output": "1",
        "idx": 121
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "size_t compile_tree(struct filter_op **fop)\n{\n   int i = 1;\n    struct filter_op *array = NULL;\n    struct unfold_elm *ue;\n \n   BUG_IF(tree_root == NULL);\n   \n    fprintf(stdout, \" Unfolding the meta-tree \");\n    fflush(stdout);\n     \n   /* start the recursion on the tree */\n   unfold_blk(&tree_root);\n\n   fprintf(stdout, \" done.\\n\\n\");\n\n   /* substitute the virtual labels with real offsets */\n   labels_to_offsets();\n   \n   /* convert the tailq into an array */\n   TAILQ_FOREACH(ue, &unfolded_tree, next) {\n\n      /* label == 0 means a real instruction */\n      if (ue->label == 0) {\n         SAFE_REALLOC(array, i * sizeof(struct filter_op));\n         memcpy(&array[i - 1], &ue->fop, sizeof(struct filter_op));\n         i++;\n      }\n   }\n   \n   /* always append the exit function to a script */\n   SAFE_REALLOC(array, i * sizeof(struct filter_op));\n   array[i - 1].opcode = FOP_EXIT;\n   \n   /* return the pointer to the array */\n   *fop = array;\n   \n   return (i);\n}\n",
        "output": "1",
        "idx": 1405
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " virtual void SetUp() {\n    video_ = new libvpx_test::WebMVideoSource(kVP9TestFile);\n    ASSERT_TRUE(video_ != NULL);\n\n     video_->Init();\n     video_->Begin();\n \n    vpx_codec_dec_cfg_t cfg = {0};\n     decoder_ = new libvpx_test::VP9Decoder(cfg, 0);\n     ASSERT_TRUE(decoder_ != NULL);\n   }\n",
        "output": "1",
        "idx": 1896
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "raptor_rdfxml_comment_handler(void *user_data, raptor_xml_element* xml_element,\n                              const unsigned char *s)\n{\n  raptor_parser* rdf_parser = (raptor_parser*)user_data;\n  raptor_rdfxml_parser* rdf_xml_parser;\n  raptor_rdfxml_element* element;\n\n  if(rdf_parser->failed || !xml_element)\n    return;\n\n  rdf_xml_parser = (raptor_rdfxml_parser*)rdf_parser->context;\n  element = rdf_xml_parser->current_element;\n\n  if(element) {\n    if(element->child_content_type == RAPTOR_RDFXML_ELEMENT_CONTENT_TYPE_XML_LITERAL)\n      raptor_xml_writer_comment(rdf_xml_parser->xml_writer, s);\n  }\n  \n\n#ifdef RAPTOR_DEBUG_VERBOSE\n  RAPTOR_DEBUG2(\"XML Comment '%s'\\n\", s);\n#endif\n}\n",
        "output": "0",
        "idx": 43
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err tfdt_Read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;\n\n\tif (ptr->version==1) {\n\t\tptr->baseMediaDecodeTime = gf_bs_read_u64(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t} else {\n\t\tptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t}\n\treturn GF_OK;\n}\n",
        "output": "0",
        "idx": 1043
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void LongOrNullAttributeAttributeSetter(\n    v8::Local<v8::Value> v8_value, const v8::FunctionCallbackInfo<v8::Value>& info) {\n  v8::Isolate* isolate = info.GetIsolate();\n  ALLOW_UNUSED_LOCAL(isolate);\n\n  v8::Local<v8::Object> holder = info.Holder();\n  ALLOW_UNUSED_LOCAL(holder);\n\n  TestObject* impl = V8TestObject::ToImpl(holder);\n \n   ExceptionState exception_state(isolate, ExceptionState::kSetterContext, \"TestObject\", \"longOrNullAttribute\");\n \n  int32_t cpp_value = NativeValueTraits<IDLLong>::NativeValue(info.GetIsolate(), v8_value, exception_state);\n   if (exception_state.HadException())\n     return;\n \n  bool is_null = IsUndefinedOrNull(v8_value);\n   impl->setLongOrNullAttribute(cpp_value, is_null);\n }\n",
        "output": "1",
        "idx": 1795
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void simulatePageScale(WebViewImpl* webViewImpl, float& scale)\n{\n    WebCore::IntSize scrollDelta = webViewImpl->fakePageScaleAnimationTargetPositionForTesting() - webViewImpl->mainFrameImpl()->frameView()->scrollPosition();\n    float scaleDelta = webViewImpl->fakePageScaleAnimationPageScaleForTesting() / webViewImpl->pageScaleFactor();\n    webViewImpl->applyScrollAndScale(scrollDelta, scaleDelta);\n    scale = webViewImpl->pageScaleFactor();\n}\n",
        "output": "0",
        "idx": 257
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init big_key_crypto_init(void)\n{\n\tint ret = -EINVAL;\n \n\t/* init RNG */\n\tbig_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);\n\tif (IS_ERR(big_key_rng)) {\n\t\tbig_key_rng = NULL;\n\t\treturn -EFAULT;\n \t}\n \n \t/* seed RNG */\n\tret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));\n\tif (ret)\n\t\tgoto error;\n \n \t/* init block cipher */\n\tbig_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,\n\t\t\t\t\t\t 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(big_key_skcipher)) {\n\t\tbig_key_skcipher = NULL;\n\t\tret = -EFAULT;\n\t\tgoto error;\n \t}\n \n \treturn 0;\n \nerror:\n \tcrypto_free_rng(big_key_rng);\n\tbig_key_rng = NULL;\n \treturn ret;\n }\n",
        "output": "1",
        "idx": 1769
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int asymmetric_key_match(const struct key *key,\n\t\t\t\tconst struct key_match_data *match_data)\n {\n \tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n \tconst char *description = match_data->raw_data;\n\tconst char *spec = description;\n\tconst char *id;\n\tptrdiff_t speclen;\n\n\tif (!subtype || !spec || !*spec)\n\t\treturn 0;\n\n\t/* See if the full key description matches as is */\n\tif (key->description && strcmp(key->description, description) == 0)\n\t\treturn 1;\n\n\t/* All tests from here on break the criterion description into a\n\t * specifier, a colon and then an identifier.\n\t */\n\tid = strchr(spec, ':');\n\tif (!id)\n\t\treturn 0;\n\n\tspeclen = id - spec;\n\tid++;\n\n\tif (speclen == 2 && memcmp(spec, \"id\", 2) == 0)\n\t\treturn asymmetric_keyid_match(asymmetric_key_id(key), id);\n\n\tif (speclen == subtype->name_len &&\n\t    memcmp(spec, subtype->name, speclen) == 0)\n\t\treturn 1;\n\n\treturn 0;\n}\n",
        "output": "1",
        "idx": 1524
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void NuPlayer::GenericSource::setDrmPlaybackStatusIfNeeded(int playbackStatus, int64_t position) {\n if (mDecryptHandle != NULL) {\n        mDrmManagerClient->setPlaybackStatus(mDecryptHandle, playbackStatus, position);\n }\n    mSubtitleTrack.mPackets = new AnotherPacketSource(NULL);\n    mTimedTextTrack.mPackets = new AnotherPacketSource(NULL);\n}\n",
        "output": "0",
        "idx": 2004
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void sum_update(const char *p, int32 len)\n{\n\tswitch (cursum_type) {\n\t  case CSUM_MD5:\n\t\tmd5_update(&md, (uchar *)p, len);\n\t\tbreak;\n          case CSUM_MD4:\n          case CSUM_MD4_OLD:\n          case CSUM_MD4_BUSTED:\n                if (len + sumresidue < CSUM_CHUNK) {\n                        memcpy(md.buffer + sumresidue, p, len);\n                        sumresidue += len;\n\t\t}\n\n\t\tif (sumresidue) {\n\t\t\tint32 i = CSUM_CHUNK - sumresidue;\n\t\t\tmemcpy(md.buffer + sumresidue, p, i);\n\t\t\tmdfour_update(&md, (uchar *)md.buffer, CSUM_CHUNK);\n\t\t\tlen -= i;\n\t\t\tp += i;\n\t\t}\n\n\t\twhile (len >= CSUM_CHUNK) {\n\t\t\tmdfour_update(&md, (uchar *)p, CSUM_CHUNK);\n\t\t\tlen -= CSUM_CHUNK;\n\t\t\tp += CSUM_CHUNK;\n\t\t}\n\n\t\tsumresidue = len;\n\t\tif (sumresidue)\n\t\t\tmemcpy(md.buffer, p, sumresidue);\n\t\tbreak;\n\t  case CSUM_NONE:\n\t\tbreak;\n\t}\n}\n",
        "output": "1",
        "idx": 1319
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void EnableHighDPISupport() {\n   if (IsHighDPIEnabled() &&\n      (base::win::GetVersion() < base::win::VERSION_WIN8_1)) {\n    if (!SetProcessDpiAwarenessWrapper(PROCESS_SYSTEM_DPI_AWARE)) {\n      SetProcessDPIAwareWrapper();\n    }\n   }\n }\n",
        "output": "1",
        "idx": 722
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ATSParser::PTSTimeDeltaEstablished() {\n if (mPrograms.isEmpty()) {\n return false;\n }\n\n return mPrograms.editItemAt(0)->PTSTimeDeltaEstablished();\n}\n",
        "output": "0",
        "idx": 284
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderView::printPage(WebFrame* frame) {\n  DCHECK(frame);\n  Print(frame, true);\n}\n",
        "output": "0",
        "idx": 775
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " accept_ice_connection (GIOChannel           *source,\n                        GIOCondition          condition,\n                        GsmIceConnectionData *data)\n {\n        IceListenObj    listener;\n         IceConn         ice_conn;\n         IceAcceptStatus status;\n        GsmClient      *client;\n        GsmXsmpServer  *server;\n        listener = data->listener;\n        server = data->server;\n \n         g_debug (\"GsmXsmpServer: accept_ice_connection()\");\n \n        ice_conn = IceAcceptConnection (listener, &status);\n         if (status != IceAcceptSuccess) {\n                 g_debug (\"GsmXsmpServer: IceAcceptConnection returned %d\", status);\n                 return TRUE;\n         }\n \n        client = gsm_xsmp_client_new (ice_conn);\n        ice_conn->context = client;\n        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n        /* the store will own the ref */\n        g_object_unref (client);\n \n         return TRUE;\n }\n",
        "output": "1",
        "idx": 1327
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void aes_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)\n{\n\tstruct crypto_sparc64_aes_ctx *ctx = crypto_tfm_ctx(tfm);\n\n\tctx->ops->encrypt(&ctx->key[0], (const u32 *) src, (u32 *) dst);\n}\n",
        "output": "0",
        "idx": 1719
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int __remove_suid(struct dentry *dentry, int kill)\n{\n\tstruct iattr newattrs;\n\n\tnewattrs.ia_valid = ATTR_FORCE | kill;\n\treturn notify_change(dentry, &newattrs);\n}\n",
        "output": "0",
        "idx": 2006
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebPluginImpl::didFinishLoadingFrameRequest(\n     const WebURL& url, void* notify_data) {\n   if (delegate_) {\n     delegate_->DidFinishLoadWithReason(\n        url, NPRES_DONE, reinterpret_cast<intptr_t>(notify_data));\n   }\n }\n",
        "output": "1",
        "idx": 503
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int srpt_ch_qp_rtr(struct srpt_rdma_ch *ch, struct ib_qp *qp)\n{\n\tstruct ib_qp_attr qp_attr;\n\tint attr_mask;\n\tint ret;\n\n\tqp_attr.qp_state = IB_QPS_RTR;\n\tret = ib_cm_init_qp_attr(ch->cm_id, &qp_attr, &attr_mask);\n\tif (ret)\n\t\tgoto out;\n\n\tqp_attr.max_dest_rd_atomic = 4;\n\n\tret = ib_modify_qp(qp, &qp_attr, attr_mask);\n\nout:\n\treturn ret;\n}\n",
        "output": "0",
        "idx": 12
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nested_vmx_abort(struct kvm_vcpu *vcpu, u32 indicator)\n{\n\t/* TODO: not to reset guest simply here. */\n\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\tpr_debug_ratelimited(\"kvm: nested vmx abort, indicator %d\\n\", indicator);\n}\n",
        "output": "0",
        "idx": 1894
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ptrace_triggered(struct perf_event *bp, int nmi,\n \t\t      struct perf_sample_data *data, struct pt_regs *regs)\n {\n \tstruct perf_event_attr attr;\n\n\t/*\n\t * Disable the breakpoint request here since ptrace has defined a\n\t * one-shot behaviour for breakpoint exceptions in PPC64.\n\t * The SIGTRAP signal is generated automatically for us in do_dabr().\n\t * We don't have to do anything about that here\n\t */\n\tattr = bp->attr;\n\tattr.disabled = true;\n\tmodify_user_hw_breakpoint(bp, &attr);\n}\n",
        "output": "1",
        "idx": 460
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)\n {\n\tct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,\n\t\t      sizeof(struct nfct_attr_grp_port));\n \tif (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))\n \t\treturn;\n \n \tct_build_u8(ct, ATTR_SCTP_STATE, n, NTA_SCTP_STATE);\n \tct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, n, NTA_SCTP_VTAG_ORIG);\n \tct_build_u32(ct, ATTR_SCTP_VTAG_REPL, n, NTA_SCTP_VTAG_REPL);\n}\n",
        "output": "1",
        "idx": 1259
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t sched_mc_power_savings_show(struct sysdev_class *class,\n\t\t\t\t\t   struct sysdev_class_attribute *attr,\n\t\t\t\t\t   char *page)\n{\n\treturn sprintf(page, \"%u\\n\", sched_mc_power_savings);\n}\n",
        "output": "0",
        "idx": 1599
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nm_ip4_config_get_ifindex (const NMIP4Config *config)\n{\n\treturn NM_IP4_CONFIG_GET_PRIVATE (config)->ifindex;\n}\n",
        "output": "0",
        "idx": 2030
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(openssl_x509_check_private_key)\n{\n\tzval ** zcert, **zkey;\n\tX509 * cert = NULL;\n\tEVP_PKEY * key = NULL;\n\tlong certresource = -1, keyresource = -1;\n\n\tRETVAL_FALSE;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ZZ\", &zcert, &zkey) == FAILURE) {\n\t\treturn;\n\t}\n\tcert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);\n\tif (cert == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tkey = php_openssl_evp_from_zval(zkey, 0, \"\", 1, &keyresource TSRMLS_CC);\n\tif (key) {\n\t\tRETVAL_BOOL(X509_check_private_key(cert, key));\n\t}\n\n\tif (keyresource == -1 && key) {\n\t\tEVP_PKEY_free(key);\n\t}\n\tif (certresource == -1 && cert) {\n\t\tX509_free(cert);\n\t}\n }\n",
        "output": "0",
        "idx": 476
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Eina_Bool ewk_view_back(Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    return ewk_frame_back(smartData->main_frame);\n}\n",
        "output": "0",
        "idx": 863
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static MagickBooleanType CheckMemoryOverflow(const size_t count,\n   const size_t quantum)\n {\n  size_t\n    size;\n\n  size=count*quantum;\n  if ((count == 0) || (quantum != (size/count)))\n    {\n      errno=ENOMEM;\n      return(MagickTrue);\n    }\n  return(MagickFalse);\n}\n",
        "output": "0",
        "idx": 260
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void RenderViewImpl::EnsureMediaStreamImpl() {\n  if (!RenderThreadImpl::current())  // Will be NULL during unit tests.\n    return;\n\n#if defined(ENABLE_WEBRTC)\n  if (!media_stream_dispatcher_)\n    media_stream_dispatcher_ = new MediaStreamDispatcher(this);\n\n  if (!media_stream_impl_) {\n    media_stream_impl_ = new MediaStreamImpl(\n        this,\n        media_stream_dispatcher_,\n        RenderThreadImpl::current()->video_capture_impl_manager(),\n        RenderThreadImpl::current()->GetMediaStreamDependencyFactory());\n  }\n#endif\n}\n",
        "output": "0",
        "idx": 2034
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int m_show(struct seq_file *m, void *v)\n{\n\tstruct proc_mounts *p = proc_mounts(m);\n\tstruct mount *r = list_entry(v, struct mount, mnt_list);\n\treturn p->show(m, &r->mnt);\n}\n",
        "output": "0",
        "idx": 1814
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ResourceTracker::UnrefResource(PP_Resource res) {\n  DLOG_IF(ERROR, !CheckIdType(res, PP_ID_TYPE_RESOURCE))\n      << res << \" is not a PP_Resource.\";\n  ResourceMap::iterator i = live_resources_.find(res);\n  if (i != live_resources_.end()) {\n    if (!--i->second.second) {\n      Resource* to_release = i->second.first;\n       PP_Instance instance = to_release->instance()->pp_instance();\n      to_release->LastPluginRefWasDeleted(false);\n \n      instance_map_[instance]->resources.erase(res);\n       live_resources_.erase(i);\n     }\n     return true;\n  } else {\n    return false;\n  }\n}\n",
        "output": "1",
        "idx": 1395
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gboolean Shell::OnWindowDestroyed(GtkWidget* window) {\n  delete this;\n  return FALSE;  // Don't stop this message.\n}\n",
        "output": "0",
        "idx": 844
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int create_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tstruct flush_cmd_control *fcc;\n\tint err = 0;\n\n\tif (SM_I(sbi)->fcc_info) {\n\t\tfcc = SM_I(sbi)->fcc_info;\n\t\tgoto init_thread;\n\t}\n\n\tfcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);\n\tif (!fcc)\n\t\treturn -ENOMEM;\n\tatomic_set(&fcc->issued_flush, 0);\n\tatomic_set(&fcc->issing_flush, 0);\n \tinit_waitqueue_head(&fcc->flush_wait_queue);\n \tinit_llist_head(&fcc->issue_list);\n \tSM_I(sbi)->fcc_info = fcc;\n init_thread:\n \tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n \t\t\t\t\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(fcc->f2fs_issue_flush)) {\n\t\terr = PTR_ERR(fcc->f2fs_issue_flush);\n\t\tkfree(fcc);\n\t\tSM_I(sbi)->fcc_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn err;\n}\n",
        "output": "1",
        "idx": 305
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dtls1_hm_fragment_free(hm_fragment *frag)\n{\n    if (!frag)\n        return;\n    if (frag->msg_header.is_ccs) {\n        EVP_CIPHER_CTX_free(frag->msg_header.\n                            saved_retransmit_state.enc_write_ctx);\n        EVP_MD_CTX_free(frag->msg_header.saved_retransmit_state.write_hash);\n    }\n    OPENSSL_free(frag->fragment);\n    OPENSSL_free(frag->reassembly);\n    OPENSSL_free(frag);\n}\n",
        "output": "0",
        "idx": 1510
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "METHODDEF(JDIMENSION)\nget_raw_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n/* This version is for reading raw-byte-format files with maxval = MAXJSAMPLE.\n * In this case we just read right into the JSAMPLE buffer!\n * Note that same code works for PPM and PGM files.\n */\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  return 1;\n}\n",
        "output": "0",
        "idx": 1973
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void V8TestObject::DoubleAttributeAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_doubleAttribute_Getter\");\n\n  test_object_v8_internal::DoubleAttributeAttributeGetter(info);\n}\n",
        "output": "0",
        "idx": 44
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,\n  int texel_size,ExceptionInfo *exception)\n{\n  register ssize_t\n    i;\n\n  MagickOffsetType\n    offset;\n\n  size_t\n    h,\n    w;\n\n  /*\n    Only skip mipmaps for textures and cube maps\n  */\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n\n      /*\n        Mipmapcount includes the main image, so start from one\n      */\n       for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n       {\n         offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n         w = DIV2(w);\n         h = DIV2(h);\n       }\n    }\n  return(MagickTrue);\n}\n",
        "output": "1",
        "idx": 56
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MagickExport ssize_t WriteBlobMSBSignedShort(Image *image,\n  const signed short value)\n{\n  union\n  {\n    unsigned short\n      unsigned_value;\n\n    signed short\n      signed_value;\n  } quantum;\n\n  unsigned char\n    buffer[2];\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  quantum.signed_value=value;\n  buffer[0]=(unsigned char) (quantum.unsigned_value >> 8);\n  buffer[1]=(unsigned char) quantum.unsigned_value;\n  return(WriteBlobStream(image,2,buffer));\n}\n",
        "output": "0",
        "idx": 2102
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int r_bin_mdmp_init(struct r_bin_mdmp_obj *obj) {\n\tr_bin_mdmp_init_parsing (obj);\n\n\tif (!r_bin_mdmp_init_hdr (obj)) {\n\t\teprintf (\"[ERROR] Failed to initialise header\\n\");\n\t\treturn false;\n\t}\n\n\tif (!r_bin_mdmp_init_directory (obj)) {\n\t\teprintf (\"[ERROR] Failed to initialise directory structures!\\n\");\n\t\treturn false;\n\t}\n\n\tif (!r_bin_mdmp_init_pe_bins (obj)) {\n\t\teprintf (\"[ERROR] Failed to initialise pe binaries!\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n",
        "output": "0",
        "idx": 549
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool XSSAuditor::filterFrameToken(const FilterTokenRequest& request)\n{\n    ASSERT(request.token.type() == HTMLToken::StartTag);\n    ASSERT(hasName(request.token, iframeTag) || hasName(request.token, frameTag));\n\n    bool didBlockScript = eraseAttributeIfInjected(request, srcdocAttr, String(), ScriptLikeAttribute);\n    if (isContainedInRequest(decodedSnippetForName(request)))\n        didBlockScript |= eraseAttributeIfInjected(request, srcAttr, String(), SrcLikeAttribute);\n\n    return didBlockScript;\n}\n",
        "output": "0",
        "idx": 1701
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   void FireInvalidateAll() {\n    invalidation::AckHandle ack_handle(\"fakedata\");\n    EXPECT_CALL(mock_invalidation_client_, Acknowledge(ack_handle));\n    client_.InvalidateAll(&mock_invalidation_client_, ack_handle);\n   }\n",
        "output": "1",
        "idx": 1095
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void GoBackCrossSite() {\n     NavigationEntry* entry = contents()->controller().GetEntryAtOffset(-1);\n     ASSERT_TRUE(entry);\n     contents()->controller().GoBack();\n \n    contents()->TestDidNavigate(\n        contents()->pending_rvh(), entry->page_id(), GURL(entry->url()),\n        content::PAGE_TRANSITION_TYPED);\n   }\n",
        "output": "1",
        "idx": 1279
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GLsync GLES2DecoderImpl::DoFenceSync(GLenum condition, GLbitfield flags) {\n  const char* function_name = \"glFenceSync\";\n  if (condition != GL_SYNC_GPU_COMMANDS_COMPLETE) {\n    LOCAL_SET_GL_ERROR(GL_INVALID_ENUM, function_name, \"invalid condition\");\n    return 0;\n  }\n  if (flags != 0) {\n    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, function_name, \"invalid flags\");\n    return 0;\n  }\n  return api()->glFenceSyncFn(condition, flags);\n}\n",
        "output": "0",
        "idx": 1857
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cipso_v4_map_cat_rbm_valid(const struct cipso_v4_doi *doi_def,\n\t\t\t\t      const unsigned char *bitmap,\n\t\t\t\t      u32 bitmap_len)\n{\n\tint cat = -1;\n\tu32 bitmap_len_bits = bitmap_len * 8;\n\tu32 cipso_cat_size;\n\tu32 *cipso_array;\n\n\tswitch (doi_def->type) {\n\tcase CIPSO_V4_MAP_PASS:\n\t\treturn 0;\n\tcase CIPSO_V4_MAP_TRANS:\n\t\tcipso_cat_size = doi_def->map.std->cat.cipso_size;\n\t\tcipso_array = doi_def->map.std->cat.cipso;\n\t\tfor (;;) {\n\t\t\tcat = cipso_v4_bitmap_walk(bitmap,\n\t\t\t\t\t\t   bitmap_len_bits,\n\t\t\t\t\t\t   cat + 1,\n\t\t\t\t\t\t   1);\n\t\t\tif (cat < 0)\n\t\t\t\tbreak;\n\t\t\tif (cat >= cipso_cat_size ||\n\t\t\t    cipso_array[cat] >= CIPSO_V4_INV_CAT)\n\t\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tif (cat == -1)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\treturn -EFAULT;\n}\n",
        "output": "0",
        "idx": 1751
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t show_ibdev(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct ib_ucm_device *ucm_dev;\n\n\tucm_dev = container_of(dev, struct ib_ucm_device, dev);\n\treturn sprintf(buf, \"%s\\n\", ucm_dev->ib_dev->name);\n}\n",
        "output": "0",
        "idx": 18
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "onig_free_body(regex_t* reg)\n{\n  if (IS_NOT_NULL(reg)) {\n    ops_free(reg);\n    if (IS_NOT_NULL(reg->string_pool)) {\n      xfree(reg->string_pool);\n      reg->string_pool_end = reg->string_pool = 0;\n    }\n    if (IS_NOT_NULL(reg->exact))            xfree(reg->exact);\n    if (IS_NOT_NULL(reg->repeat_range))     xfree(reg->repeat_range);\n    if (IS_NOT_NULL(reg->extp)) {\n      free_regex_ext(reg->extp);\n      reg->extp = 0;\n    }\n\n    onig_names_free(reg);\n  }\n}\n",
        "output": "0",
        "idx": 413
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void ProcessControlLaunched() {\n     base::ScopedAllowBlockingForTesting allow_blocking;\n     base::ProcessId service_pid;\n     EXPECT_TRUE(GetServiceProcessData(NULL, &service_pid));\n    EXPECT_NE(static_cast<base::ProcessId>(0), service_pid);\n#if defined(OS_WIN)\n    service_process_ =\n        base::Process::OpenWithAccess(service_pid,\n                                      SYNCHRONIZE | PROCESS_QUERY_INFORMATION);\n#else\n     service_process_ = base::Process::Open(service_pid);\n #endif\n     EXPECT_TRUE(service_process_.IsValid());\n    base::ThreadTaskRunnerHandle::Get()->PostTask(\n        FROM_HERE, base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());\n   }\n",
        "output": "1",
        "idx": 1391
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderViewHostImpl::OnTargetDropACK() {\n  NotificationService::current()->Notify(\n      NOTIFICATION_RENDER_VIEW_HOST_DID_RECEIVE_DRAG_TARGET_DROP_ACK,\n      Source<RenderViewHost>(this),\n      NotificationService::NoDetails());\n}\n",
        "output": "0",
        "idx": 1267
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool check_underflow(const struct ip6t_entry *e)\n{\n \tconst struct xt_entry_target *t;\n \tunsigned int verdict;\n \n\tif (!unconditional(&e->ipv6))\n \t\treturn false;\n \tt = ip6t_get_target_c(e);\n \tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}\n",
        "output": "1",
        "idx": 856
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void V8Window::namedPropertyGetterCustom(v8::Local<v8::Name> name, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    if (!name->IsString())\n        return;\n\n    auto nameString = name.As<v8::String>();\n    LocalDOMWindow* window = toLocalDOMWindow(V8Window::toImpl(info.Holder()));\n    if (!window)\n        return;\n\n    LocalFrame* frame = window->frame();\n    if (!frame)\n        return;\n\n    AtomicString propName = toCoreAtomicString(nameString);\n    Frame* child = frame->tree().scopedChild(propName);\n    if (child) {\n        v8SetReturnValueFast(info, child->domWindow(), window);\n        return;\n    }\n\n     if (!info.Holder()->GetRealNamedProperty(nameString).IsEmpty())\n         return;\n \n     Document* doc = frame->document();\n \n    if (doc && doc->isHTMLDocument()) {\n        if (toHTMLDocument(doc)->hasNamedItem(propName) || doc->hasElementWithId(propName)) {\n            RefPtrWillBeRawPtr<HTMLCollection> items = doc->windowNamedItems(propName);\n            if (!items->isEmpty()) {\n                if (items->hasExactlyOneItem()) {\n                    v8SetReturnValueFast(info, items->item(0), window);\n                    return;\n                }\n                v8SetReturnValueFast(info, items.release(), window);\n                return;\n            }\n        }\n    }\n}\n",
        "output": "1",
        "idx": 1075
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FS_ClearPakReferences( int flags ) {\n\tsearchpath_t *search;\n\n\tif ( !flags ) {\n\t\tflags = -1;\n\t}\n\tfor ( search = fs_searchpaths; search; search = search->next ) {\n\t\tif ( search->pack ) {\n\t\t\tsearch->pack->referenced &= ~flags;\n\t\t}\n\t}\n}\n",
        "output": "0",
        "idx": 1302
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "        ~CreateFileResult()\n        {\n        }\n",
        "output": "1",
        "idx": 1507
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlParse3986RelativeRef(xmlURIPtr uri, const char *str) {\n int ret;\n\n if ((*str == '/') && (*(str + 1) == '/')) {\n        str += 2;\n\tret = xmlParse3986Authority(uri, &str);\n if (ret != 0) return(ret);\n\tret = xmlParse3986PathAbEmpty(uri, &str);\n if (ret != 0) return(ret);\n } else if (*str == '/') {\n\tret = xmlParse3986PathAbsolute(uri, &str);\n if (ret != 0) return(ret);\n } else if (ISA_PCHAR(str)) {\n        ret = xmlParse3986PathNoScheme(uri, &str);\n if (ret != 0) return(ret);\n } else {\n /* path-empty is effectively empty */\n if (uri != NULL) {\n if (uri->path != NULL) xmlFree(uri->path);\n\t    uri->path = NULL;\n }\n }\n\n if (*str == '?') {\n\tstr++;\n\tret = xmlParse3986Query(uri, &str);\n if (ret != 0) return(ret);\n }\n if (*str == '#') {\n\tstr++;\n\tret = xmlParse3986Fragment(uri, &str);\n if (ret != 0) return(ret);\n }\n if (*str != 0) {\n\txmlCleanURI(uri);\n return(1);\n }\n return(0);\n}\n",
        "output": "0",
        "idx": 1920
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void Dispose() {\n    raw_data_ = nullptr;\n    delete this;\n  }\n",
        "output": "0",
        "idx": 1137
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mptsas_free_request(MPTSASRequest *req)\n{\n    MPTSASState *s = req->dev;\n\n    if (req->sreq != NULL) {\n        req->sreq->hba_private = NULL;\n        scsi_req_unref(req->sreq);\n        req->sreq = NULL;\n        QTAILQ_REMOVE(&s->pending, req, next);\n    }\n    qemu_sglist_destroy(&req->qsg);\n    g_free(req);\n}\n",
        "output": "0",
        "idx": 282
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __net_exit sctp_net_exit(struct net *net)\n {\n \t/* Free the local address list */\n \tsctp_free_addr_wq(net);\n \tsctp_free_local_addr_list(net);\n \n\t/* Free the control endpoint.  */\n\tinet_ctl_sock_destroy(net->sctp.ctl_sock);\n \tsctp_dbg_objcnt_exit(net);\n \n \tsctp_proc_exit(net);\n \tcleanup_sctp_mibs(net);\n \tsctp_sysctl_net_unregister(net);\n }\n",
        "output": "1",
        "idx": 1019
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool WebstoreStandaloneInstaller::EnsureUniqueInstall(\n    webstore_install::Result* reason,\n    std::string* error) {\n  InstallTracker* tracker = InstallTracker::Get(profile_);\n  DCHECK(tracker);\n\n  const ActiveInstallData* existing_install_data =\n       tracker->GetActiveInstall(id_);\n   if (existing_install_data) {\n     *reason = webstore_install::INSTALL_IN_PROGRESS;\n    *error = kInstallInProgressError;\n     return false;\n   }\n \n  ActiveInstallData install_data(id_);\n  InitInstallData(&install_data);\n  scoped_active_install_.reset(new ScopedActiveInstall(tracker, install_data));\n  return true;\n}\n",
        "output": "1",
        "idx": 757
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " SProcXFixesQueryVersion(ClientPtr client)\n {\n     REQUEST(xXFixesQueryVersionReq);\n \n     swaps(&stuff->length);\n     swapl(&stuff->majorVersion);\n    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);\n}\n",
        "output": "1",
        "idx": 1958
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u8 vhost_scsi_get_fabric_proto_ident(struct se_portal_group *se_tpg)\n{\n\tstruct vhost_scsi_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct vhost_scsi_tpg, se_tpg);\n\tstruct vhost_scsi_tport *tport = tpg->tport;\n\n\tswitch (tport->tport_proto_id) {\n\tcase SCSI_PROTOCOL_SAS:\n\t\treturn sas_get_fabric_proto_ident(se_tpg);\n\tcase SCSI_PROTOCOL_FCP:\n\t\treturn fc_get_fabric_proto_ident(se_tpg);\n\tcase SCSI_PROTOCOL_ISCSI:\n\t\treturn iscsi_get_fabric_proto_ident(se_tpg);\n\tdefault:\n\t\tpr_err(\"Unknown tport_proto_id: 0x%02x, using\"\n\t\t\t\" SAS emulation\\n\", tport->tport_proto_id);\n\t\tbreak;\n\t}\n\n\treturn sas_get_fabric_proto_ident(se_tpg);\n}\n",
        "output": "0",
        "idx": 207
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PasswordStoreLoginsChangedObserver::PasswordStoreLoginsChangedObserver(\n    AutomationProvider* automation,\n    IPC::Message* reply_message,\n    PasswordStoreChange::Type expected_type,\n    const std::string& result_key)\n    : automation_(automation->AsWeakPtr()),\n      reply_message_(reply_message),\n      expected_type_(expected_type),\n      result_key_(result_key),\n      done_event_(false, false) {\n  AddRef();\n}\n",
        "output": "0",
        "idx": 414
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ContentSecurityPolicy::BindToExecutionContext(\n    ExecutionContext* execution_context) {\n  execution_context_ = execution_context;\n  ApplyPolicySideEffectsToExecutionContext();\n}\n",
        "output": "0",
        "idx": 1065
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " SoftMPEG4Encoder::~SoftMPEG4Encoder() {\n     ALOGV(\"Destruct SoftMPEG4Encoder\");\n     releaseEncoder();\n     List<BufferInfo *> &outQueue = getPortQueue(1);\n     List<BufferInfo *> &inQueue = getPortQueue(0);\n    CHECK(outQueue.empty());\n    CHECK(inQueue.empty());\n}\n",
        "output": "1",
        "idx": 1523
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __net_exit sysctl_net_exit(struct net *net)\n{\n\tretire_sysctl_set(&net->sysctls);\n}\n",
        "output": "0",
        "idx": 1752
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool UnprivilegedProcessDelegate::CreateConnectedIpcChannel(\n    const std::string& channel_name,\n    IPC::Listener* delegate,\n    ScopedHandle* client_out,\n    scoped_ptr<IPC::ChannelProxy>* server_out) {\n  scoped_ptr<IPC::ChannelProxy> server;\n  if (!CreateIpcChannel(channel_name, kDaemonIpcSecurityDescriptor,\n                        io_task_runner_, delegate, &server)) {\n    return false;\n  }\n  std::string pipe_name(kChromePipeNamePrefix);\n  pipe_name.append(channel_name);\n  SECURITY_ATTRIBUTES security_attributes;\n  security_attributes.nLength = sizeof(security_attributes);\n  security_attributes.lpSecurityDescriptor = NULL;\n  security_attributes.bInheritHandle = TRUE;\n  ScopedHandle client;\n  client.Set(CreateFile(UTF8ToUTF16(pipe_name).c_str(),\n                        GENERIC_READ | GENERIC_WRITE,\n                        0,\n                        &security_attributes,\n                        OPEN_EXISTING,\n                        SECURITY_SQOS_PRESENT | SECURITY_IDENTIFICATION |\n                            FILE_FLAG_OVERLAPPED,\n                        NULL));\n  if (!client.IsValid())\n    return false;\n  *client_out = client.Pass();\n  *server_out = server.Pass();\n  return true;\n}\n",
        "output": "1",
        "idx": 841
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void emitnumber(JF, double num)\n{\n\tif (num == 0) {\n\t\temit(J, F, OP_NUMBER_0);\n\t\tif (signbit(num))\n\t\t\temit(J, F, OP_NEG);\n\t} else if (num == 1) {\n\t\temit(J, F, OP_NUMBER_1);\n\t} else if (num == (js_Instruction)num) {\n\t\temit(J, F, OP_NUMBER_POS);\n\t\temitraw(J, F, (js_Instruction)num);\n\t} else if (num < 0 && -num == (js_Instruction)(-num)) {\n\t\temit(J, F, OP_NUMBER_NEG);\n\t\temitraw(J, F, (js_Instruction)(-num));\n\t} else {\n\t\temit(J, F, OP_NUMBER);\n\t\temitraw(J, F, addnumber(J, F, num));\n\t}\n}\n",
        "output": "0",
        "idx": 1010
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n {\n \tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n \tstruct extent_tree *et;\n\tstruct extent_node *en;\n\tstruct extent_info ei;\n\n\tif (!f2fs_may_extent_tree(inode)) {\n\t\t/* drop largest extent */\n\t\tif (i_ext && i_ext->len) {\n\t\t\ti_ext->len = 0;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tet = __grab_extent_tree(inode);\n\n\tif (!i_ext || !i_ext->len)\n\t\treturn false;\n\n\tget_extent_info(&ei, i_ext);\n\n\twrite_lock(&et->lock);\n\tif (atomic_read(&et->node_cnt))\n\t\tgoto out;\n\n\ten = __init_extent_tree(sbi, et, &ei);\n\tif (en) {\n\t\tspin_lock(&sbi->extent_lock);\n\t\tlist_add_tail(&en->list, &sbi->extent_list);\n\t\tspin_unlock(&sbi->extent_lock);\n\t}\nout:\n\twrite_unlock(&et->lock);\n \treturn false;\n }\n",
        "output": "1",
        "idx": 1111
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int writeWepKeyRid(struct airo_info *ai, WepKeyRid *wkr, int perm, int lock)\n{\n\tint rc;\n\trc = PC4500_writerid(ai, RID_WEP_TEMP, wkr, sizeof(*wkr), lock);\n\tif (rc!=SUCCESS)\n\t\tairo_print_err(ai->dev->name, \"WEP_TEMP set %x\", rc);\n\tif (perm) {\n\t\trc = PC4500_writerid(ai, RID_WEP_PERM, wkr, sizeof(*wkr), lock);\n\t\tif (rc!=SUCCESS)\n\t\t\tairo_print_err(ai->dev->name, \"WEP_PERM set %x\", rc);\n\t}\n\treturn rc;\n}\n",
        "output": "0",
        "idx": 551
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "calc_delta_mine(unsigned long delta_exec, unsigned long weight,\n\t\tstruct load_weight *lw)\n{\n\tu64 tmp;\n\n\t/*\n\t * weight can be less than 2^SCHED_LOAD_RESOLUTION for task group sched\n\t * entities since MIN_SHARES = 2. Treat weight as 1 if less than\n\t * 2^SCHED_LOAD_RESOLUTION.\n\t */\n\tif (likely(weight > (1UL << SCHED_LOAD_RESOLUTION)))\n\t\ttmp = (u64)delta_exec * scale_load_down(weight);\n\telse\n\t\ttmp = (u64)delta_exec;\n\n\tif (!lw->inv_weight) {\n\t\tunsigned long w = scale_load_down(lw->weight);\n\n\t\tif (BITS_PER_LONG > 32 && unlikely(w >= WMULT_CONST))\n\t\t\tlw->inv_weight = 1;\n\t\telse if (unlikely(!w))\n\t\t\tlw->inv_weight = WMULT_CONST;\n\t\telse\n\t\t\tlw->inv_weight = WMULT_CONST / w;\n\t}\n\n\t/*\n\t * Check whether we'd overflow the 64-bit multiplication:\n\t */\n\tif (unlikely(tmp > WMULT_CONST))\n\t\ttmp = SRR(SRR(tmp, WMULT_SHIFT/2) * lw->inv_weight,\n\t\t\tWMULT_SHIFT/2);\n\telse\n\t\ttmp = SRR(tmp * lw->inv_weight, WMULT_SHIFT);\n\n\treturn (unsigned long)min(tmp, (u64)(unsigned long)LONG_MAX);\n}\n",
        "output": "0",
        "idx": 245
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " WebPluginResourceClient* WebPluginDelegateImpl::CreateResourceClient(\n    unsigned long resource_id, const GURL& url, bool notify_needed,\n    intptr_t notify_data, intptr_t existing_stream) {\n  if (existing_stream) {\n    NPAPI::PluginStream* plugin_stream =\n        reinterpret_cast<NPAPI::PluginStream*>(existing_stream);\n    return plugin_stream->AsResourceClient();\n  }\n \n  std::string mime_type;\n  NPAPI::PluginStreamUrl *stream = instance()->CreateStream(\n      resource_id, url, mime_type, notify_needed,\n      reinterpret_cast<void*>(notify_data));\n  return stream;\n }\n",
        "output": "1",
        "idx": 2067
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void close_all_sockets(atransport* t) {\n    asocket* s;\n\n\n     /* this is a little gross, but since s->close() *will* modify\n     ** the list out from under you, your options are limited.\n     */\n    adb_mutex_lock(&socket_list_lock);\n restart:\n     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {\n         if (s->transport == t || (s->peer && s->peer->transport == t)) {\n            local_socket_close_locked(s);\n             goto restart;\n         }\n     }\n    adb_mutex_unlock(&socket_list_lock);\n }\n",
        "output": "1",
        "idx": 1185
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int skt_write(int fd, const void *p, size_t len)\n{\n int sent;\n struct pollfd pfd;\n\n    FNLOG();\n\n    pfd.fd = fd;\n    pfd.events = POLLOUT;\n\n\n     /* poll for 500 ms */\n \n     /* send time out */\n    if (poll(&pfd, 1, 500) == 0)\n         return 0;\n \n     ts_log(\"skt_write\", len, NULL);\n \n    if ((sent = send(fd, p, len, MSG_NOSIGNAL)) == -1)\n     {\n         ERROR(\"write failed with errno=%d\\n\", errno);\n         return -1;\n }\n\n return sent;\n}\n",
        "output": "1",
        "idx": 1594
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\n\tscm->fp = UNIXCB(skb).fp;\n \tUNIXCB(skb).fp = NULL;\n \n \tfor (i = scm->fp->count-1; i >= 0; i--)\n\t\tunix_notinflight(scm->fp->fp[i]);\n }\n",
        "output": "1",
        "idx": 932
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SpeechSynthesis::trace(Visitor* visitor)\n{\n    visitor->trace(m_voiceList);\n    visitor->trace(m_utteranceQueue);\n}\n",
        "output": "0",
        "idx": 1197
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  std::string GetRequestStringForPNACL(const std::string& fragment) const {\n    return RequestString(test_page_url_ + fragment, \"navigate\", \"include\") +\n           RequestString(GetURL(\"/pnacl_url_loader.nmf\"), \"same-origin\",\n                         \"same-origin\") +\n           RequestString(GetURL(\"/pnacl_url_loader_newlib_pnacl.pexe\"),\n                         \"same-origin\", \"same-origin\");\n  }\n",
        "output": "0",
        "idx": 1127
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ssh_packet_get_compress_state(struct sshbuf *m, struct ssh *ssh)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct sshbuf *b;\n\tint r;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (state->compression_in_started) {\n\t\tif ((r = sshbuf_put_string(b, &state->compression_in_stream,\n\t\t    sizeof(state->compression_in_stream))) != 0)\n\t\t\tgoto out;\n\t} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)\n\t\tgoto out;\n\tif (state->compression_out_started) {\n\t\tif ((r = sshbuf_put_string(b, &state->compression_out_stream,\n\t\t    sizeof(state->compression_out_stream))) != 0)\n\t\t\tgoto out;\n\t} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)\n\t\tgoto out;\n\tr = sshbuf_put_stringb(m, b);\n out:\n\tsshbuf_free(b);\n\treturn r;\n}\n",
        "output": "1",
        "idx": 1266
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Browser::FindInPage(bool find_next, bool forward_direction) {\n  ShowFindBar();\n  if (find_next) {\n    string16 find_text;\n#if defined(OS_MACOSX)\n     find_text = GetFindPboardText();\n #endif\n     GetSelectedTabContentsWrapper()->\n        GetFindManager()->StartFinding(find_text,\n                                       forward_direction,\n                                       false);  // Not case sensitive.\n   }\n }\n",
        "output": "1",
        "idx": 2041
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t SampleTable::setChunkOffsetParams(\n uint32_t type, off64_t data_offset, size_t data_size) {\n if (mChunkOffsetOffset >= 0) {\n return ERROR_MALFORMED;\n }\n\n    CHECK(type == kChunkOffsetType32 || type == kChunkOffsetType64);\n\n    mChunkOffsetOffset = data_offset;\n    mChunkOffsetType = type;\n\n if (data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n\n    mNumChunkOffsets = U32_AT(&header[4]);\n\n if (mChunkOffsetType == kChunkOffsetType32) {\n if ((data_size - 8) / 4 < mNumChunkOffsets) {\n return ERROR_MALFORMED;\n }\n } else {\n if ((data_size - 8) / 8 < mNumChunkOffsets) {\n return ERROR_MALFORMED;\n }\n }\n\n return OK;\n}\n",
        "output": "0",
        "idx": 420
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MagickExport int ErrorBlob(const Image *image)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->blob != (BlobInfo *) NULL);\n  assert(image->blob->type != UndefinedStream);\n  blob_info=image->blob;\n  switch (blob_info->type)\n  {\n    case UndefinedStream:\n    case StandardStream:\n      break;\n    case FileStream:\n    case PipeStream:\n    {\n      blob_info->error=ferror(blob_info->file_info.file);\n      break;\n    }\n    case ZipStream:\n    {\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      (void) gzerror(blob_info->file_info.gzfile,&blob_info->error);\n#endif\n      break;\n    }\n    case BZipStream:\n    {\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n      (void) BZ2_bzerror(blob_info->file_info.bzfile,&blob_info->error);\n#endif\n      break;\n    }\n    case FifoStream:\n    {\n      blob_info->error=0;\n      break;\n    }\n    case BlobStream:\n      break;\n  }\n  return(blob_info->error);\n}\n",
        "output": "0",
        "idx": 707
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void update_open_stateflags(struct nfs4_state *state, mode_t open_flags)\n {\n\tswitch (open_flags) {\n \t\tcase FMODE_WRITE:\n \t\t\tstate->n_wronly++;\n \t\t\tbreak;\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly++;\n\t\t\tbreak;\n \t\tcase FMODE_READ|FMODE_WRITE:\n \t\t\tstate->n_rdwr++;\n \t}\n\tnfs4_state_set_mode_locked(state, state->state | open_flags);\n }\n",
        "output": "1",
        "idx": 1915
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void sas_scsi_clear_queue_lu(struct list_head *error_q, struct scsi_cmnd *my_cmd)\n {\n \tstruct scsi_cmnd *cmd, *n;\n \n \tlist_for_each_entry_safe(cmd, n, error_q, eh_entry) {\n \t\tif (cmd->device->sdev_target == my_cmd->device->sdev_target &&\n \t\t    cmd->device->lun == my_cmd->device->lun)\n\t\t\tsas_eh_defer_cmd(cmd);\n \t}\n }\n",
        "output": "1",
        "idx": 194
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void InfoBarContainer::ChangeTabContents(TabContents* contents) {\n   registrar_.RemoveAll();\n   RemoveAllChildViews(false);\n   tab_contents_ = contents;\n   if (tab_contents_) {\n    UpdateInfoBars();\n    Source<TabContents> tc_source(tab_contents_);\n    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_ADDED,\n                   tc_source);\n    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REMOVED,\n                   tc_source);\n    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REPLACED,\n                   tc_source);\n  }\n}\n",
        "output": "1",
        "idx": 1953
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cmsUInt32Number CMSEXPORT cmsMLUgetWide(const cmsMLU* mlu,\n                                      const char LanguageCode[3], const char CountryCode[3],\n                                      wchar_t* Buffer, cmsUInt32Number BufferSize)\n{\n    const wchar_t *Wide;\n    cmsUInt32Number  StrLen = 0;\n\n    cmsUInt16Number Lang  = _cmsAdjustEndianess16(*(cmsUInt16Number*) LanguageCode);\n    cmsUInt16Number Cntry = _cmsAdjustEndianess16(*(cmsUInt16Number*) CountryCode);\n\n    if (mlu == NULL) return 0;\n\n    Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);\n    if (Wide == NULL) return 0;\n\n    if (Buffer == NULL) return StrLen + sizeof(wchar_t);\n\n    if (BufferSize <= 0) return 0;\n\n    if (BufferSize < StrLen + sizeof(wchar_t))\n        StrLen = BufferSize - + sizeof(wchar_t);\n\n    memmove(Buffer, Wide, StrLen);\n    Buffer[StrLen / sizeof(wchar_t)] = 0;\n\n    return StrLen + sizeof(wchar_t);\n}\n",
        "output": "0",
        "idx": 1779
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PasswordAutofillAgent::UpdateStateForTextChange(\n    const WebInputElement& element) {\n  if (!element.IsTextField())\n    return;\n  WebInputElement mutable_element = element;  // We need a non-const.\n\n  const base::string16 element_value = element.Value().Utf16();\n  field_data_manager_.UpdateFieldDataMap(element, element_value,\n                                         FieldPropertiesFlags::USER_TYPED);\n\n  ProvisionallySavePassword(element.Form(), element, RESTRICTION_NONE);\n\n  if (element.IsPasswordFieldForAutofill()) {\n    auto iter = password_to_username_.find(element);\n    if (iter != password_to_username_.end()) {\n      web_input_to_password_info_[iter->second].password_was_edited_last = true;\n      mutable_element.SetAutofillState(WebAutofillState::kNotFilled);\n    }\n    GetPasswordManagerDriver()->UserModifiedPasswordField();\n  } else {\n    GetPasswordManagerDriver()->UserModifiedNonPasswordField(\n        element.UniqueRendererFormControlId(), element_value);\n  }\n}\n",
        "output": "0",
        "idx": 818
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "drive_eject_completed_cb (DBusGMethodInvocation *context,\n                          Device *device,\n                          gboolean job_was_cancelled,\n                          int status,\n                          const char *stderr,\n                          const char *stdout,\n                          gpointer user_data)\n{\n  if (WEXITSTATUS (status) == 0 && !job_was_cancelled)\n    {\n      /* TODO: probably wait for has_media to change to FALSE */\n      dbus_g_method_return (context);\n    }\n  else\n    {\n      if (job_was_cancelled)\n        {\n          throw_error (context, ERROR_CANCELLED, \"Job was cancelled\");\n        }\n      else\n        {\n          throw_error (context,\n                       ERROR_FAILED,\n                       \"Error ejecting: eject exited with exit code %d: %s\",\n                       WEXITSTATUS (status),\n                       stderr);\n        }\n    }\n}\n",
        "output": "0",
        "idx": 617
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sec_reset_state(void)\n{\n\tg_server_rdp_version = 0;\n\tg_sec_encrypt_use_count = 0;\n\tg_sec_decrypt_use_count = 0;\n\tg_licence_issued = 0;\n\tg_licence_error_result = 0;\n\tmcs_reset_state();\n}\n",
        "output": "0",
        "idx": 1933
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SIZED_STRING* yr_re_ast_extract_literal(\n    RE_AST* re_ast)\n{\n  SIZED_STRING* string;\n  RE_NODE* node = re_ast->root_node;\n\n  int i, length = 0;\n  char tmp;\n\n  while (node != NULL)\n  {\n    length++;\n\n    if (node->type == RE_NODE_LITERAL)\n      break;\n\n    if (node->type != RE_NODE_CONCAT)\n      return NULL;\n\n    if (node->right == NULL ||\n        node->right->type != RE_NODE_LITERAL)\n      return NULL;\n\n    node = node->left;\n  }\n\n  string = (SIZED_STRING*) yr_malloc(sizeof(SIZED_STRING) + length);\n\n  if (string == NULL)\n    return NULL;\n\n  string->length = 0;\n\n  node = re_ast->root_node;\n\n  while (node->type == RE_NODE_CONCAT)\n  {\n    string->c_string[string->length++] = node->right->value;\n    node = node->left;\n  }\n\n  string->c_string[string->length++] = node->value;\n\n\n  for (i = 0; i < length / 2; i++)\n  {\n    tmp = string->c_string[i];\n    string->c_string[i] = string->c_string[length - i - 1];\n    string->c_string[length - i - 1] = tmp;\n  }\n\n  return string;\n}\n",
        "output": "0",
        "idx": 1282
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void MediaElementAudioSourceHandler::Process(size_t number_of_frames) {\n  AudioBus* output_bus = Output(0).Bus();\n\n  MutexTryLocker try_locker(process_lock_);\n  if (try_locker.Locked()) {\n    if (!MediaElement() || !source_sample_rate_) {\n      output_bus->Zero();\n      return;\n    }\n\n    if (source_number_of_channels_ != output_bus->NumberOfChannels()) {\n      output_bus->Zero();\n      return;\n    }\n\n    AudioSourceProvider& provider = MediaElement()->GetAudioSourceProvider();\n    if (multi_channel_resampler_.get()) {\n      DCHECK_NE(source_sample_rate_, Context()->sampleRate());\n      multi_channel_resampler_->Process(&provider, output_bus,\n                                        number_of_frames);\n    } else {\n      DCHECK_EQ(source_sample_rate_, Context()->sampleRate());\n       provider.ProvideInput(output_bus, number_of_frames);\n     }\n    if (!PassesCORSAccessCheck()) {\n      if (maybe_print_cors_message_) {\n        maybe_print_cors_message_ = false;\n        PostCrossThreadTask(\n            *task_runner_, FROM_HERE,\n            CrossThreadBind(&MediaElementAudioSourceHandler::PrintCORSMessage,\n                            WrapRefCounted(this), current_src_string_));\n      }\n       output_bus->Zero();\n     }\n   } else {\n    output_bus->Zero();\n  }\n}\n",
        "output": "1",
        "idx": 1946
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int accept_server_socket(int sfd)\n{\n struct sockaddr_un remote;\n struct pollfd pfd;\n int fd;\n socklen_t len = sizeof(struct sockaddr_un);\n\n    BTIF_TRACE_EVENT(\"accept fd %d\", sfd);\n\n /* make sure there is data to process */\n\n     pfd.fd = sfd;\n     pfd.events = POLLIN;\n \n    if (poll(&pfd, 1, 0) == 0)\n     {\n         BTIF_TRACE_EVENT(\"accept poll timeout\");\n         return -1;\n }\n\n \n \n    if ((fd = accept(sfd, (struct sockaddr *)&remote, &len)) == -1)\n     {\n          BTIF_TRACE_ERROR(\"sock accept failed (%s)\", strerror(errno));\n          return -1;\n }\n\n\n return fd;\n}\n",
        "output": "1",
        "idx": 1500
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool tcp_prune_ofo_queue(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tbool res = false;\n\n\tif (!skb_queue_empty(&tp->out_of_order_queue)) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_OFOPRUNED);\n\t\t__skb_queue_purge(&tp->out_of_order_queue);\n\n\t\t/* Reset SACK state.  A conforming SACK implementation will\n\t\t * do the same at a timeout based retransmit.  When a connection\n\t\t * is in a sad state like this, we care only about integrity\n\t\t * of the connection not performance.\n\t\t */\n\t\tif (tp->rx_opt.sack_ok)\n\t\t\ttcp_sack_reset(&tp->rx_opt);\n\t\tsk_mem_reclaim(sk);\n\t\tres = true;\n\t}\n\treturn res;\n}\n",
        "output": "0",
        "idx": 1359
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,\n\t\t\t\t\tstruct sk_buff *skb, u16 vid)\n{\n\tstruct net_bridge_mdb_htable *mdb = rcu_dereference(br->mdb);\n\tstruct br_ip ip;\n\n\tif (br->multicast_disabled)\n\t\treturn NULL;\n\n\tif (BR_INPUT_SKB_CB(skb)->igmp)\n\t\treturn NULL;\n\n\tip.proto = skb->protocol;\n\tip.vid = vid;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tip.u.ip4 = ip_hdr(skb)->daddr;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\tip.u.ip6 = ipv6_hdr(skb)->daddr;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn br_mdb_ip_get(mdb, &ip);\n}\n",
        "output": "0",
        "idx": 1533
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "InputImeEventRouter* GetInputImeEventRouter(Profile* profile) {\n   if (!profile)\n     return nullptr;\n   return extensions::InputImeEventRouterFactory::GetInstance()->GetRouter(\n      profile->GetOriginalProfile());\n }\n",
        "output": "1",
        "idx": 1152
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  write_message( RenderState  state )\n  {\n    ADisplay  adisplay = (ADisplay)state->display.disp;\n\n\n    if ( state->message == NULL )\n    {\n      FontFace  face = &state->faces[state->face_index];\n      int       idx, total;\n\n\n      idx   = face->index;\n      total = 1;\n      while ( total + state->face_index < state->num_faces &&\n              face[total].filepath == face[0].filepath     )\n        total++;\n\n      total += idx;\n \n       state->message = state->message0;\n       if ( total > 1 )\n        sprintf( state->message0, \"%s %d/%d @ %5.1fpt\",\n                  state->filename, idx + 1, total,\n                  state->char_size );\n       else\n        sprintf( state->message0, \"%s @ %5.1fpt\",\n                  state->filename,\n                  state->char_size );\n     }\n\n    grWriteCellString( adisplay->bitmap, 0, DIM_Y - 10, state->message,\n                       adisplay->fore_color );\n\n    state->message = NULL;\n  }\n",
        "output": "1",
        "idx": 1484
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fpm_child_free(struct fpm_child_s *child) /* {{{ */\n{\n\tfree(child);\n}\n/* }}} */\n",
        "output": "0",
        "idx": 1753
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rx_cache_insert(netdissect_options *ndo,\n                const u_char *bp, const struct ip *ip, int dport)\n{\n\tstruct rx_cache_entry *rxent;\n\tconst struct rx_header *rxh = (const struct rx_header *) bp;\n\n\tif (ndo->ndo_snapend - bp + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t)))\n\t\treturn;\n\n\trxent = &rx_cache[rx_cache_next];\n\n\tif (++rx_cache_next >= RX_CACHE_SIZE)\n\t\trx_cache_next = 0;\n\n\trxent->callnum = EXTRACT_32BITS(&rxh->callNumber);\n \tUNALIGNED_MEMCPY(&rxent->client, &ip->ip_src, sizeof(uint32_t));\n \tUNALIGNED_MEMCPY(&rxent->server, &ip->ip_dst, sizeof(uint32_t));\n \trxent->dport = dport;\n\trxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);\n \trxent->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header));\n }\n",
        "output": "1",
        "idx": 670
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ResourceDispatcherHostImpl::OnSSLCertificateError(\n    net::URLRequest* request,\n    const net::SSLInfo& ssl_info,\n    bool is_hsts_host) {\n  DCHECK(request);\n  ResourceRequestInfoImpl* info = ResourceRequestInfoImpl::ForRequest(request);\n  DCHECK(info);\n  GlobalRequestID request_id(info->GetChildID(), info->GetRequestID());\n  int render_process_id;\n   int render_view_id;\n   if(!info->GetAssociatedRenderView(&render_process_id, &render_view_id))\n     NOTREACHED();\n  SSLManager::OnSSLCertificateError(ssl_delegate_weak_factory_.GetWeakPtr(),\n      request_id, info->GetResourceType(), request->url(), render_process_id,\n      render_view_id, ssl_info, is_hsts_host);\n }\n",
        "output": "1",
        "idx": 1570
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void HttpAuthFilterWhitelist::SetWhitelist(\n     const std::string& server_whitelist) {\n  rules_.ParseFromString(server_whitelist);\n }\n",
        "output": "1",
        "idx": 31
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static unsigned int seedsize(struct crypto_alg *alg)\n {\n \tstruct rng_alg *ralg = container_of(alg, struct rng_alg, base);\n \n\treturn alg->cra_rng.rng_make_random ?\n\t       alg->cra_rng.seedsize : ralg->seedsize;\n }\n",
        "output": "1",
        "idx": 523
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tcp_v4_reqsk_destructor(struct request_sock *req)\n{\n\tkfree(inet_rsk(req)->opt);\n}\n",
        "output": "0",
        "idx": 732
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nbd_negotiate_drop_sync(QIOChannel *ioc, size_t size)\n{\n    ssize_t ret;\n    uint8_t *buffer = g_malloc(MIN(65536, size));\n    while (size > 0) {\n        size_t count = MIN(65536, size);\n        ret = nbd_negotiate_read(ioc, buffer, count);\n        if (ret < 0) {\n            g_free(buffer);\n            return ret;\n        }\n        size -= count;\n    }\n    g_free(buffer);\n    return 0;\n}\n",
        "output": "1",
        "idx": 710
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "entry_guard_obeys_restriction(const entry_guard_t *guard,\n                              const entry_guard_restriction_t *rst)\n{\n  tor_assert(guard);\n   if (! rst)\n     return 1; // No restriction?  No problem.\n \n   return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN);\n }\n",
        "output": "1",
        "idx": 750
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const PPB_NaCl_Private* GetNaclInterface() {\n  pp::Module *module = pp::Module::Get();\n  CHECK(module);\n  return static_cast<const PPB_NaCl_Private*>(\n      module->GetBrowserInterface(PPB_NACL_PRIVATE_INTERFACE));\n}\n",
        "output": "1",
        "idx": 336
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct dentry *udf_fh_to_parent(struct super_block *sb,\n\t\t\t\t       struct fid *fid, int fh_len, int fh_type)\n{\n\tif (fh_len != 5 || fh_type != FILEID_UDF_WITH_PARENT)\n\t\treturn NULL;\n\n\treturn udf_nfs_get_inode(sb, fid->udf.parent_block,\n\t\t\t\t fid->udf.parent_partref,\n\t\t\t\t fid->udf.parent_generation);\n}\n",
        "output": "0",
        "idx": 1676
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vapic_enter(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct page *page;\n\tif (!apic || !apic->vapic_addr)\n\t\treturn 0;\n\tpage = gfn_to_page(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn -EFAULT;\n\tvcpu->arch.apic->vapic_page = page;\n\treturn 0;\n}\n",
        "output": "1",
        "idx": 1004
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ShelfLayoutManager::ProcessGestureEventOfAutoHideShelf(\n    ui::GestureEvent* event,\n    aura::Window* target) {\n  const bool is_shelf_window = IsShelfWindow(target);\n  if (IsVisible() || in_shutdown_) {\n    if (!is_shelf_window && !IsStatusAreaWindow(target) &&\n        visibility_state() == SHELF_AUTO_HIDE &&\n        state_.auto_hide_state == SHELF_AUTO_HIDE_SHOWN &&\n        event->type() == ui::ET_GESTURE_TAP) {\n      UpdateAutoHideState();\n    }\n    return;\n  }\n\n  if (is_shelf_window) {\n    ui::GestureEvent event_in_screen(*event);\n    gfx::Point location_in_screen(event->location());\n    ::wm::ConvertPointToScreen(target, &location_in_screen);\n    event_in_screen.set_location(location_in_screen);\n    if (ProcessGestureEvent(event_in_screen))\n      event->StopPropagation();\n  }\n}\n",
        "output": "0",
        "idx": 746
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " int re_yyget_lineno  (yyscan_t yyscanner)\n {\n     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n         if (! YY_CURRENT_BUFFER)\n             return 0;\n     \n    return yylineno;\n}\n",
        "output": "1",
        "idx": 1364
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char *func_id_name(int id)\n{\n\tBUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);\n\n\tif (id >= 0 && id < __BPF_FUNC_MAX_ID && func_id_str[id])\n\t\treturn func_id_str[id];\n\telse\n\t\treturn \"unknown\";\n}\n",
        "output": "0",
        "idx": 200
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bt_status_t btif_hh_execute_service(BOOLEAN b_enable)\n{\n if (b_enable)\n {\n /* Enable and register with BTA-HH */\n          BTA_HhEnable(BTUI_HH_SECURITY, bte_hh_evt);\n }\n else {\n /* Disable HH */\n         BTA_HhDisable();\n }\n return BT_STATUS_SUCCESS;\n}\n",
        "output": "0",
        "idx": 1967
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_maintenance_mode(void *send_info, bool enable)\n{\n\tstruct smi_info   *smi_info = send_info;\n\n\tif (!enable)\n\t\tatomic_set(&smi_info->req_events, 0);\n}\n",
        "output": "0",
        "idx": 676
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int WebContentsImpl::DownloadImage(\n    const GURL& url,\n    bool is_favicon,\n    uint32_t max_bitmap_size,\n    bool bypass_cache,\n    const WebContents::ImageDownloadCallback& callback) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  static int next_image_download_id = 0;\n  const image_downloader::ImageDownloaderPtr& mojo_image_downloader =\n      GetMainFrame()->GetMojoImageDownloader();\n  const int download_id = ++next_image_download_id;\n  if (!mojo_image_downloader) {\n     BrowserThread::PostTask(\n         BrowserThread::UI, FROM_HERE,\n        base::Bind(&WebContents::ImageDownloadCallback::Run,\n                   base::Owned(new ImageDownloadCallback(callback)),\n                   download_id, 400, url, std::vector<SkBitmap>(),\n                   std::vector<gfx::Size>()));\n     return download_id;\n   }\n \n  image_downloader::DownloadRequestPtr req =\n      image_downloader::DownloadRequest::New();\n\n  req->url = mojo::String::From(url);\n  req->is_favicon = is_favicon;\n  req->max_bitmap_size = max_bitmap_size;\n   req->bypass_cache = bypass_cache;\n \n   mojo_image_downloader->DownloadImage(\n      std::move(req),\n      base::Bind(&DidDownloadImage, callback, download_id, url));\n   return download_id;\n }\n",
        "output": "1",
        "idx": 89
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void EncoderTest::InitializeConfig() {\n   const vpx_codec_err_t res = codec_->DefaultEncoderConfig(&cfg_, 0);\n   ASSERT_EQ(VPX_CODEC_OK, res);\n }\n",
        "output": "1",
        "idx": 2019
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool XSSAuditor::FilterInputToken(const FilterTokenRequest& request) {\n  DCHECK_EQ(request.token.GetType(), HTMLToken::kStartTag);\n  DCHECK(HasName(request.token, inputTag));\n\n  return EraseAttributeIfInjected(request, formactionAttr, kURLWithUniqueOrigin,\n                                  kSrcLikeAttributeTruncation);\n}\n",
        "output": "0",
        "idx": 1816
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NDIS_STATUS ParaNdis6_ReceivePauseRestart(\n    PARANDIS_ADAPTER *pContext,\n    BOOLEAN bPause,\n    ONPAUSECOMPLETEPROC Callback\n    )\n{\n    NDIS_STATUS status = NDIS_STATUS_SUCCESS;\n\n    if (bPause)\n    {\n        CNdisPassiveWriteAutoLock tLock(pContext->m_PauseLock);\n\n        ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 1, 0, 0);\n        if (pContext->m_upstreamPacketPending != 0)\n        {\n            pContext->ReceiveState = srsPausing;\n            pContext->ReceivePauseCompletionProc = Callback;\n            status = NDIS_STATUS_PENDING;\n        }\n        else\n        {\n            ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 0, 0, 0);\n            pContext->ReceiveState = srsDisabled;\n        }\n    }\n    else\n    {\n        ParaNdis_DebugHistory(pContext, hopInternalReceiveResume, NULL, 0, 0, 0);\n        pContext->ReceiveState = srsEnabled;\n    }\n    return status;\n}\n",
        "output": "0",
        "idx": 1557
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int store_xauthority(void) {\n\tfs_build_mnt_dir();\n \n \tchar *src;\n \tchar *dest = RUN_XAUTHORITY_FILE;\n \tFILE *fp = fopen(dest, \"w\");\n \tif (fp) {\n \t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0600);\n\t\tfclose(fp);\n\t}\n\t\n\tif (asprintf(&src, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\tfprintf(stderr, \"Warning: invalid .Xauthority file\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0600);\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\t\n\treturn 0;\n}\n",
        "output": "1",
        "idx": 285
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char *default_charset(void)\n{\n# if defined HAVE_LIBCHARSET_H && defined HAVE_LOCALE_CHARSET\n\treturn locale_charset();\n# elif defined HAVE_LANGINFO_H && defined HAVE_NL_LANGINFO\n\treturn nl_langinfo(CODESET);\n# else\n\treturn \"\"; /* Works with (at the very least) gnu iconv... */\n# endif\n}\n",
        "output": "0",
        "idx": 996
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   void SetManualFallbacksForFilling(bool enabled) {\n     if (enabled) {\n       scoped_feature_list_.InitAndEnableFeature(\n          password_manager::features::kEnableManualFallbacksFilling);\n     } else {\n       scoped_feature_list_.InitAndDisableFeature(\n          password_manager::features::kEnableManualFallbacksFilling);\n     }\n   }\n",
        "output": "1",
        "idx": 1275
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ForeignSessionHelper::ForeignSessionHelper(Profile* profile)\n    : profile_(profile) {\n  sync_sessions::SessionSyncService* service =\n      SessionSyncServiceFactory::GetInstance()->GetForProfile(profile);\n\n  if (service) {\n    foreign_session_updated_subscription_ =\n        service->SubscribeToForeignSessionsChanged(base::BindRepeating(\n            &ForeignSessionHelper::FireForeignSessionCallback,\n            base::Unretained(this)));\n  }\n}\n",
        "output": "0",
        "idx": 539
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SProcRenderCreateRadialGradient (ClientPtr client)\n{\n    register int n;\n    int len;\n    REQUEST (xRenderCreateRadialGradientReq);\n    REQUEST_AT_LEAST_SIZE (xRenderCreateRadialGradientReq);\n\n    swaps(&stuff->length, n);\n    swapl(&stuff->pid, n);\n    swapl(&stuff->inner.x, n);\n    swapl(&stuff->inner.y, n);\n    swapl(&stuff->outer.x, n);\n    swapl(&stuff->outer.y, n);\n    swapl(&stuff->inner_radius, n);\n    swapl(&stuff->outer_radius, n);\n    swapl(&stuff->nStops, n);\n\n    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);\n    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))\n\treturn BadLength;\n    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))\n        return BadLength;\n\n    swapStops(stuff+1, stuff->nStops);\n\n    return (*ProcRenderVector[stuff->renderReqType]) (client);\n}\n",
        "output": "0",
        "idx": 1622
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderView::OnFillPasswordForm(\n    const webkit_glue::PasswordFormFillData& form_data) {\n#if defined(WEBKIT_BUG_41283_IS_FIXED)\n  password_autocomplete_manager_.ReceivedPasswordFormFillData(webview(),\n                                                              form_data);\n#else\n  webkit_glue::FillPasswordForm(this->webview(), form_data);\n#endif\n}\n",
        "output": "0",
        "idx": 1140
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PreconnectManager::StartPreconnectUrl(\n    const GURL& url,\n    bool allow_credentials,\n    net::NetworkIsolationKey network_isolation_key) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  if (!url.SchemeIsHTTPOrHTTPS())\n    return;\n  PreresolveJobId job_id = preresolve_jobs_.Add(std::make_unique<PreresolveJob>(\n      url.GetOrigin(), 1, allow_credentials, std::move(network_isolation_key),\n      nullptr));\n  queued_jobs_.push_front(job_id);\n\n  TryToLaunchPreresolveJobs();\n}\n",
        "output": "0",
        "idx": 496
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "val_wrap_iov_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t context_handle,\n    int conf_req_flag,\n    gss_qop_t qop_req,\n    int *conf_state,\n    gss_iov_buffer_desc *iov,\n    int iov_count)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (iov == GSS_C_NO_IOV_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    return (GSS_S_COMPLETE);\n}\n",
        "output": "0",
        "idx": 696
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int i8042_start(struct serio *serio)\n {\n \tstruct i8042_port *port = serio->port_data;\n \n \tport->exists = true;\n\tmb();\n \treturn 0;\n }\n",
        "output": "1",
        "idx": 1775
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mp_decode_to_lua_array(lua_State *L, mp_cur *c, size_t len) {\n    assert(len <= UINT_MAX);\n     int index = 1;\n \n     lua_newtable(L);\n     while(len--) {\n         lua_pushnumber(L,index++);\n         mp_decode_to_lua_type(L,c);\n        if (c->err) return;\n        lua_settable(L,-3);\n    }\n}\n",
        "output": "1",
        "idx": 1582
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  cff_decoder_init( CFF_Decoder*    decoder,\n                    TT_Face         face,\n                    CFF_Size        size,\n                    CFF_GlyphSlot   slot,\n                    FT_Bool         hinting,\n                    FT_Render_Mode  hint_mode )\n  {\n    CFF_Font  cff = (CFF_Font)face->extra.data;\n\n\n    /* clear everything */\n    FT_MEM_ZERO( decoder, sizeof ( *decoder ) );\n\n    /* initialize builder */\n    cff_builder_init( &decoder->builder, face, size, slot, hinting );\n\n    /* initialize Type2 decoder */\n    decoder->cff          = cff;\n    decoder->num_globals  = cff->global_subrs_index.count;\n    decoder->globals      = cff->global_subrs;\n    decoder->globals_bias = cff_compute_bias(\n                              cff->top_font.font_dict.charstring_type,\n                              decoder->num_globals );\n\n    decoder->hint_mode    = hint_mode;\n  }\n",
        "output": "0",
        "idx": 1155
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " bool PluginInstance::Start(const GURL& url,\n                            char** const param_names,\n                            char** const param_values,\n                           int param_count,\n                           bool load_manually) {\n  load_manually_ = load_manually;\n  unsigned short mode = load_manually_ ? NP_FULL : NP_EMBED;\n  npp_->ndata = this;\n\n  NPError err = NPP_New(mode, param_count,\n      const_cast<char **>(param_names), const_cast<char **>(param_values));\n  return err == NPERR_NO_ERROR;\n}\n",
        "output": "0",
        "idx": 1790
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ApiTestEnvironment::RunPromisesAgain() {\n  env()->isolate()->RunMicrotasks();\n  base::MessageLoop::current()->PostTask(\n      FROM_HERE, base::Bind(&ApiTestEnvironment::RunPromisesAgain,\n                            base::Unretained(this)));\n}\n",
        "output": "0",
        "idx": 1985
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_entry *l2e)\n{\n\tint\terror = 0;\n\tstruct cxio_rdev *rdev;\n\n\trdev = (struct cxio_rdev *)tdev->ulp;\n\tif (cxio_fatal_error(rdev)) {\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n \terror = l2t_send(tdev, skb, l2e);\n \tif (error < 0)\n \t\tkfree_skb(skb);\n\treturn error;\n }\n",
        "output": "1",
        "idx": 967
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateObject( void )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item )\n\t\titem->type = cJSON_Object;\n\treturn item;\n}\n",
        "output": "1",
        "idx": 674
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DrawingBuffer::DrawingBuffer(\n    std::unique_ptr<WebGraphicsContext3DProvider> context_provider,\n    std::unique_ptr<Extensions3DUtil> extensions_util,\n    Client* client,\n    bool discard_framebuffer_supported,\n     bool want_alpha_channel,\n     bool premultiplied_alpha,\n     PreserveDrawingBuffer preserve,\n    WebGLVersion web_gl_version,\n     bool want_depth,\n     bool want_stencil,\n     ChromiumImageUsage chromium_image_usage,\n     const CanvasColorParams& color_params)\n     : client_(client),\n       preserve_drawing_buffer_(preserve),\n      web_gl_version_(web_gl_version),\n       context_provider_(WTF::WrapUnique(new WebGraphicsContext3DProviderWrapper(\n           std::move(context_provider)))),\n       gl_(this->ContextProvider()->ContextGL()),\n      extensions_util_(std::move(extensions_util)),\n      discard_framebuffer_supported_(discard_framebuffer_supported),\n      want_alpha_channel_(want_alpha_channel),\n      premultiplied_alpha_(premultiplied_alpha),\n      software_rendering_(this->ContextProvider()->IsSoftwareRendering()),\n      want_depth_(want_depth),\n      want_stencil_(want_stencil),\n      color_space_(color_params.GetGfxColorSpace()),\n      chromium_image_usage_(chromium_image_usage) {\n  TRACE_EVENT_INSTANT0(\"test_gpu\", \"DrawingBufferCreation\",\n                       TRACE_EVENT_SCOPE_GLOBAL);\n}\n",
        "output": "1",
        "idx": 2026
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BlacklistAddOneDll(const wchar_t* module_name,\n                        bool check_in_browser,\n                        sandbox::TargetPolicy* policy) {\n  HMODULE module = check_in_browser ? ::GetModuleHandleW(module_name) : NULL;\n  if (!module) {\n    std::wstring name(module_name);\n    size_t period = name.rfind(L'.');\n    DCHECK_NE(std::string::npos, period);\n    DCHECK_LE(3U, (name.size() - period));\n    if (period <= 8)\n      return;\n    for (int ix = 0; ix < 3; ++ix) {\n      const wchar_t suffix[] = {'~', ('1' + ix), 0};\n      std::wstring alt_name = name.substr(0, 6) + suffix;\n      alt_name += name.substr(period, name.size());\n      if (check_in_browser) {\n        module = ::GetModuleHandleW(alt_name.c_str());\n        if (!module)\n          return;\n        if (!IsExpandedModuleName(module, module_name))\n          return;\n      }\n      policy->AddDllToUnload(alt_name.c_str());\n    }\n  }\n  policy->AddDllToUnload(module_name);\n  DVLOG(1) << \"dll to unload found: \" << module_name;\n  return;\n}\n",
        "output": "0",
        "idx": 867
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameDevToolsAgentHost::DestroyOnRenderFrameGone() {\n   scoped_refptr<RenderFrameDevToolsAgentHost> protect(this);\n   if (IsAttached())\n     RevokePolicy();\n  ForceDetachAllClients();\n   frame_host_ = nullptr;\n   agent_ptr_.reset();\n   SetFrameTreeNode(nullptr);\n  Release();\n}\n",
        "output": "1",
        "idx": 765
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)\n\n {\n     const char *perm = \"add\";\n \n    if (uid >= AID_APP) {\n         return 0; /* Don't allow apps to register services */\n     }\n \n return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;\n}\n",
        "output": "1",
        "idx": 1079
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameImpl::OnGetSerializedHtmlWithLocalLinks(\n    const std::map<GURL, base::FilePath>& url_to_local_path,\n    const std::map<int, base::FilePath>& frame_routing_id_to_local_path) {\n  LinkRewritingDelegate delegate(url_to_local_path,\n                                 frame_routing_id_to_local_path);\n\n  WebFrameSerializer::Serialize(GetWebFrame(),\n                                this,  // WebFrameSerializerClient.\n                                &delegate);\n}\n",
        "output": "0",
        "idx": 268
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "conv_swap4bytes(const UChar* s, const UChar* end, UChar* conv)\n{\n  while (s < end) {\n    *conv++ = s[3];\n    *conv++ = s[2];\n    *conv++ = s[1];\n    *conv++ = s[0];\n    s += 4;\n  }\n}\n",
        "output": "0",
        "idx": 1428
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Condor_Auth_SSL::decrypt(unsigned char* input, int input_len, \n\t\t\t\t\t\t\tunsigned char* & output, int& output_len)\n{\n\treturn encrypt_or_decrypt(false,input,input_len,output,output_len);\n}\n",
        "output": "0",
        "idx": 1776
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WebMouseEvent* BuildMouseEvent(const PP_InputEvent& event) {\n  WebMouseEvent* mouse_event = new WebMouseEvent();\n  switch (event.type) {\n    case PP_INPUTEVENT_TYPE_MOUSEDOWN:\n      mouse_event->type = WebInputEvent::MouseDown;\n      break;\n    case PP_INPUTEVENT_TYPE_MOUSEUP:\n      mouse_event->type = WebInputEvent::MouseUp;\n      break;\n    case PP_INPUTEVENT_TYPE_MOUSEMOVE:\n      mouse_event->type = WebInputEvent::MouseMove;\n      break;\n    case PP_INPUTEVENT_TYPE_MOUSEENTER:\n      mouse_event->type = WebInputEvent::MouseEnter;\n      break;\n     case PP_INPUTEVENT_TYPE_MOUSELEAVE:\n       mouse_event->type = WebInputEvent::MouseLeave;\n       break;\n     default:\n       NOTREACHED();\n   }\n  mouse_event->timeStampSeconds = event.time_stamp;\n  mouse_event->modifiers = event.u.mouse.modifier;\n  mouse_event->button =\n      static_cast<WebMouseEvent::Button>(event.u.mouse.button);\n  mouse_event->x = static_cast<int>(event.u.mouse.x);\n  mouse_event->y = static_cast<int>(event.u.mouse.y);\n  mouse_event->clickCount = event.u.mouse.click_count;\n  return mouse_event;\n}\n",
        "output": "1",
        "idx": 772
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "png_set_tIME(png_structp png_ptr, png_infop info_ptr, png_timep mod_time)\n{\n   png_debug1(1, \"in %s storage function\", \"tIME\");\n\n   if (png_ptr == NULL || info_ptr == NULL ||\n        (png_ptr->mode & PNG_WROTE_tIME))\n       return;\n \n    png_memcpy(&(info_ptr->mod_time), mod_time, png_sizeof(png_time));\n    info_ptr->valid |= PNG_INFO_tIME;\n }\n",
        "output": "1",
        "idx": 115
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WebInputEvent* CreateWebInputEvent(const PP_InputEvent& event) {\n  scoped_ptr<WebInputEvent> web_input_event;\n  switch (event.type) {\n    case PP_INPUTEVENT_TYPE_UNDEFINED:\n      return NULL;\n    case PP_INPUTEVENT_TYPE_MOUSEDOWN:\n    case PP_INPUTEVENT_TYPE_MOUSEUP:\n     case PP_INPUTEVENT_TYPE_MOUSEMOVE:\n     case PP_INPUTEVENT_TYPE_MOUSEENTER:\n     case PP_INPUTEVENT_TYPE_MOUSELEAVE:\n       web_input_event.reset(BuildMouseEvent(event));\n       break;\n     case PP_INPUTEVENT_TYPE_MOUSEWHEEL:\n      web_input_event.reset(BuildMouseWheelEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_RAWKEYDOWN:\n    case PP_INPUTEVENT_TYPE_KEYDOWN:\n    case PP_INPUTEVENT_TYPE_KEYUP:\n      web_input_event.reset(BuildKeyEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_CHAR:\n      web_input_event.reset(BuildCharEvent(event));\n      break;\n  }\n \n   return web_input_event.release();\n }\n",
        "output": "1",
        "idx": 185
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " do_prefetch_tables (const void *gcmM, size_t gcmM_size)\n {\n   prefetch_table(gcmM, gcmM_size);\n  prefetch_table(gcmR, sizeof(gcmR));\n }\n",
        "output": "1",
        "idx": 1399
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameImpl::BubbleLogicalScrollInParentFrame(\n    blink::WebScrollDirection direction,\n    blink::WebScrollGranularity granularity) {\n  DCHECK(IsLocalRoot());\n  DCHECK(!IsMainFrame());\n  Send(new FrameHostMsg_BubbleLogicalScrollInParentFrame(routing_id_, direction,\n                                                         granularity));\n}\n",
        "output": "0",
        "idx": 1242
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint8_t CSPSourceList::hashAlgorithmsUsed() const\n{\n    return m_hashAlgorithmsUsed;\n}\n",
        "output": "0",
        "idx": 1241
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool tailmatch(const char *little, const char *bigone)\n {\n  size_t littlelen = strlen(little);\n  size_t biglen = strlen(bigone);\n \n  if(littlelen > biglen)\n     return FALSE;\n \n  return Curl_raw_equal(little, bigone+biglen-littlelen) ? TRUE : FALSE;\n }\n",
        "output": "1",
        "idx": 581
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FrameLoader::loadArchive(PassRefPtr<Archive> prpArchive)\n{\n    RefPtr<Archive> archive = prpArchive;\n    \n    ArchiveResource* mainResource = archive->mainResource();\n    ASSERT(mainResource);\n    if (!mainResource)\n        return;\n        \n    SubstituteData substituteData(mainResource->data(), mainResource->mimeType(), mainResource->textEncoding(), KURL());\n    \n    ResourceRequest request(mainResource->url());\n#if PLATFORM(MAC)\n    request.applyWebArchiveHackForMail();\n#endif\n\n    RefPtr<DocumentLoader> documentLoader = m_client->createDocumentLoader(request, substituteData);\n    documentLoader->addAllArchiveResources(archive.get());\n    load(documentLoader.get());\n}\n",
        "output": "0",
        "idx": 1537
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void get_timewait4_sock(struct inet_timewait_sock *tw,\n\t\t\t       struct seq_file *f, int i, int *len)\n{\n\t__be32 dest, src;\n\t__u16 destp, srcp;\n\tint ttd = tw->tw_ttd - jiffies;\n\n\tif (ttd < 0)\n\t\tttd = 0;\n\n\tdest  = tw->tw_daddr;\n\tsrc   = tw->tw_rcv_saddr;\n\tdestp = ntohs(tw->tw_dport);\n\tsrcp  = ntohs(tw->tw_sport);\n\n\tseq_printf(f, \"%4d: %08X:%04X %08X:%04X\"\n\t\t\" %02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %p%n\",\n\t\ti, src, srcp, dest, destp, tw->tw_substate, 0, 0,\n\t\t3, jiffies_to_clock_t(ttd), 0, 0, 0, 0,\n\t\tatomic_read(&tw->tw_refcnt), tw, len);\n}\n",
        "output": "0",
        "idx": 682
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "atol10(const char *p, size_t char_cnt)\n{\n \tuint64_t l;\n \tint digit;\n \n \tl = 0;\n \tdigit = *p - '0';\n \twhile (digit >= 0 && digit < 10  && char_cnt-- > 0) {\n\t\tl = (l * 10) + digit;\n\t\tdigit = *++p - '0';\n\t}\n\treturn (l);\n}\n",
        "output": "1",
        "idx": 1960
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void BlobURLRegistry::unregisterURL(const KURL& url)\n {\n    ThreadableBlobRegistry::unregisterBlobURL(url);\n }\n",
        "output": "1",
        "idx": 2022
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool HpackDecoder::DecodeNextIndexedHeader(HpackInputStream* input_stream) {\n  uint32 index = 0;\n  if (!input_stream->DecodeNextUint32(&index))\n    return false;\n\n  HpackEntry* entry = header_table_.GetByIndex(index);\n   if (entry == NULL)\n     return false;\n \n  HandleHeaderRepresentation(entry->name(), entry->value());\n  return true;\n }\n",
        "output": "1",
        "idx": 1605
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t SampleTable::setTimeToSampleParams(\n off64_t data_offset, size_t data_size) {\n if (mTimeToSample != NULL || data_size < 8) {\n return ERROR_MALFORMED;\n }\n\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n\n     }\n \n     mTimeToSampleCount = U32_AT(&header[4]);\n    uint64_t allocSize = mTimeToSampleCount * 2 * sizeof(uint32_t);\n     if (allocSize > SIZE_MAX) {\n         return ERROR_OUT_OF_RANGE;\n     }\n    mTimeToSample = new uint32_t[mTimeToSampleCount * 2];\n\n size_t size = sizeof(uint32_t) * mTimeToSampleCount * 2;\n if (mDataSource->readAt(\n                data_offset + 8, mTimeToSample, size) < (ssize_t)size) {\n return ERROR_IO;\n }\n\n for (uint32_t i = 0; i < mTimeToSampleCount * 2; ++i) {\n        mTimeToSample[i] = ntohl(mTimeToSample[i]);\n }\n\n return OK;\n}\n",
        "output": "1",
        "idx": 995
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void PrintPreviewUI::ClearAllPreviewData() {\n  print_preview_data_service()->RemoveEntry(preview_ui_addr_str_);\n }\n",
        "output": "1",
        "idx": 497
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " FrameImpl::FrameImpl(std::unique_ptr<content::WebContents> web_contents,\n                     chromium::web::FrameObserverPtr observer)\n    : web_contents_(std::move(web_contents)), observer_(std::move(observer)) {\n  Observe(web_contents.get());\n }\n",
        "output": "1",
        "idx": 902
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n \tif (out == NULL) {\n \t\treturn NULL;\n \t}\n\tgdImageWebpCtx(im, out, quality);\n\trv = gdDPExtractData(out, size);\n \tout->gd_free(out);\n \treturn rv;\n }\n",
        "output": "1",
        "idx": 2037
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " BaseRenderingContext2D::BaseRenderingContext2D()\n    : clip_antialiasing_(kNotAntiAliased) {\n   state_stack_.push_back(CanvasRenderingContext2DState::Create());\n }\n",
        "output": "1",
        "idx": 1640
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SpeechSynthesis::handleSpeakingCompleted(SpeechSynthesisUtterance* utterance, bool errorOccurred)\n {\n     ASSERT(utterance);\n \n     bool didJustFinishCurrentUtterance = false;\n    if (utterance == currentSpeechUtterance()) {\n        m_utteranceQueue.removeFirst();\n        didJustFinishCurrentUtterance = true;\n    }\n\n    fireEvent(errorOccurred ? EventTypeNames::error : EventTypeNames::end, utterance, 0, String());\n\n    if (didJustFinishCurrentUtterance && !m_utteranceQueue.isEmpty())\n        startSpeakingImmediately();\n}\n",
        "output": "1",
        "idx": 1554
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void NavigationController::GoToIndex(int index) {\n  if (index < 0 || index >= static_cast<int>(entries_.size())) {\n    NOTREACHED();\n    return;\n  }\n\n  if (transient_entry_index_ != -1) {\n    if (index == transient_entry_index_) {\n      return;\n    }\n    if (index > transient_entry_index_) {\n      index--;\n     }\n   }\n \n  if (tab_contents_->interstitial_page()) {\n    if (index == GetCurrentEntryIndex() - 1) {\n      tab_contents_->interstitial_page()->DontProceed();\n      return;\n    } else {\n      tab_contents_->interstitial_page()->CancelForNavigation();\n    }\n  }\n   DiscardNonCommittedEntries();\n \n   pending_entry_index_ = index;\n  entries_[pending_entry_index_]->set_transition_type(\n      content::PageTransitionFromInt(\n          entries_[pending_entry_index_]->transition_type() |\n          content::PAGE_TRANSITION_FORWARD_BACK));\n  NavigateToPendingEntry(NO_RELOAD);\n}\n",
        "output": "1",
        "idx": 1979
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *EscapeParenthesis(const char *source)\n{\n  char\n    *destination;\n\n  register char\n    *q;\n\n  register const char\n    *p;\n\n  size_t\n    length;\n\n  assert(source != (const char *) NULL);\n  length=0;\n  for (p=source; *p != '\\0'; p++)\n  {\n    if ((*p == '\\\\') || (*p == '(') || (*p == ')'))\n      {\n        if (~length < 1)\n          ThrowFatalException(ResourceLimitFatalError,\"UnableToEscapeString\");\n        length++;\n      }\n    length++;\n  }\n  destination=(char *) NULL;\n  if (~length >= (MagickPathExtent-1))\n    destination=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n      sizeof(*destination));\n  if (destination == (char *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"UnableToEscapeString\");\n  *destination='\\0';\n  q=destination;\n  for (p=source; *p != '\\0'; p++)\n  {\n    if ((*p == '\\\\') || (*p == '(') || (*p == ')'))\n      *q++='\\\\';\n    *q++=(*p);\n  }\n  *q='\\0';\n  return(destination);\n}\n",
        "output": "0",
        "idx": 1493
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   static void TearDownTestCase() {\n    vpx_free(source_data_);\n    source_data_ = NULL;\n    vpx_free(reference_data_);\n    reference_data_ = NULL;\n   }\n",
        "output": "1",
        "idx": 1062
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tight_fill_palette(VncState *vs, int x, int y,\n                              size_t count, uint32_t *bg, uint32_t *fg,\n                              VncPalette **palette)\n{\n    int max;\n\n    max = count / tight_conf[vs->tight.compression].idx_max_colors_divisor;\n    if (max < 2 &&\n        count >= tight_conf[vs->tight.compression].mono_min_rect_size) {\n        max = 2;\n    }\n    if (max >= 256) {\n         max = 256;\n     }\n \n    switch(vs->clientds.pf.bytes_per_pixel) {\n     case 4:\n         return tight_fill_palette32(vs, x, y, max, count, bg, fg, palette);\n     case 2:\n        return tight_fill_palette16(vs, x, y, max, count, bg, fg, palette);\n    default:\n        max = 2;\n        return tight_fill_palette8(vs, x, y, max, count, bg, fg, palette);\n    }\n    return 0;\n}\n",
        "output": "1",
        "idx": 1852
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rdpsnddbg_process(STREAM s)\n{\n\tunsigned int pkglen;\n \tstatic char *rest = NULL;\n \tchar *buf;\n \n \tpkglen = s->end - s->p;\n \t/* str_handle_lines requires null terminated strings */\n \tbuf = (char *) xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\n\tstr_handle_lines(buf, &rest, rdpsnddbg_line_handler, NULL);\n\n\txfree(buf);\n}\n",
        "output": "1",
        "idx": 1916
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yyscanner)\n{\n\tstruct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\t(void)yyg;\n\n\tint i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n}\n",
        "output": "0",
        "idx": 1825
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool AppCacheDatabase::FindEntriesForCache(int64_t cache_id,\n                                           std::vector<EntryRecord>* records) {\n  DCHECK(records && records->empty());\n  if (!LazyOpen(kDontCreate))\n     return false;\n \n   static const char kSql[] =\n      \"SELECT cache_id, url, flags, response_id, response_size FROM Entries\"\n       \"  WHERE cache_id = ?\";\n \n   sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));\n  statement.BindInt64(0, cache_id);\n\n  while (statement.Step()) {\n    records->push_back(EntryRecord());\n    ReadEntryRecord(statement, &records->back());\n    DCHECK(records->back().cache_id == cache_id);\n  }\n\n  return statement.Succeeded();\n}\n",
        "output": "1",
        "idx": 303
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DOMWindow* Document::open(v8::Isolate* isolate,\n                          const USVStringOrTrustedURL& string_or_url,\n                          const AtomicString& name,\n                          const AtomicString& features,\n                          ExceptionState& exception_state) {\n  if (!domWindow()) {\n    exception_state.ThrowDOMException(DOMExceptionCode::kInvalidAccessError,\n                                      \"The document has no window associated.\");\n    return nullptr;\n  }\n\n  return domWindow()->open(isolate, string_or_url, name, features,\n                           exception_state);\n}\n",
        "output": "0",
        "idx": 290
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Editor::replaceSelectionWithText(const String& text,\n                                      bool selectReplacement,\n                                      bool smartReplace,\n                                      InputEvent::InputType inputType) {\n  replaceSelectionWithFragment(createFragmentFromText(selectedRange(), text),\n                               selectReplacement, smartReplace, true,\n                               inputType);\n}\n",
        "output": "0",
        "idx": 1437
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long Track::GetFirst(const BlockEntry*& pBlockEntry) const {\n const Cluster* pCluster = m_pSegment->GetFirst();\n\n for (int i = 0;;) {\n if (pCluster == NULL) {\n      pBlockEntry = GetEOS();\n return 1;\n }\n\n if (pCluster->EOS()) {\n if (m_pSegment->DoneParsing()) {\n        pBlockEntry = GetEOS();\n return 1;\n }\n\n      pBlockEntry = 0;\n return E_BUFFER_NOT_FULL;\n }\n\n long status = pCluster->GetFirst(pBlockEntry);\n\n if (status < 0) // error\n return status;\n\n if (pBlockEntry == 0) { // empty cluster\n      pCluster = m_pSegment->GetNext(pCluster);\n continue;\n }\n\n for (;;) {\n const Block* const pBlock = pBlockEntry->GetBlock();\n      assert(pBlock);\n\n const long long tn = pBlock->GetTrackNumber();\n\n if ((tn == m_info.number) && VetEntry(pBlockEntry))\n return 0;\n\n const BlockEntry* pNextEntry;\n\n      status = pCluster->GetNext(pBlockEntry, pNextEntry);\n\n if (status < 0) // error\n return status;\n\n if (pNextEntry == 0)\n break;\n\n      pBlockEntry = pNextEntry;\n }\n\n ++i;\n\n if (i >= 100)\n break;\n\n    pCluster = m_pSegment->GetNext(pCluster);\n }\n\n\n  pBlockEntry = GetEOS(); // so we can return a non-NULL value\n return 1;\n}\n",
        "output": "0",
        "idx": 13
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _close_pgsql_plink(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n{\n\tPGconn *link = (PGconn *)rsrc->ptr;\n\tPGresult *res;\n\n\twhile ((res = PQgetResult(link))) {\n\t\tPQclear(res);\n\t}\n\tPQfinish(link);\n\tPGG(num_persistent)--;\n\tPGG(num_links)--;\n}\n",
        "output": "0",
        "idx": 566
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::string ExtractResourceId(const GURL& url) {\n  return net::UnescapeURLComponent(url.ExtractFileName(),\n                                   net::UnescapeRule::URL_SPECIAL_CHARS);\n}\n",
        "output": "0",
        "idx": 314
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ftrace_regex_lseek(struct file *file, loff_t offset, int whence)\n {\n \tloff_t ret;\n \n\tif (file->f_mode & FMODE_READ)\n\t\tret = seq_lseek(file, offset, whence);\n\telse\n\t\tfile->f_pos = ret = 1;\n\n\treturn ret;\n}\n",
        "output": "1",
        "idx": 981
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parse_instruction_ids(struct ofpbuf *payload, bool loose, uint32_t *insts)\n{\n    *insts = 0;\n    while (payload->size > 0) {\n        enum ovs_instruction_type inst;\n        enum ofperr error;\n        uint64_t ofpit;\n\n        /* OF1.3 and OF1.4 aren't clear about padding in the instruction IDs.\n         * It seems clear that they aren't padded to 8 bytes, though, because\n         * both standards say that \"non-experimenter instructions are 4 bytes\"\n         * and do not mention any padding before the first instruction ID.\n         * (There wouldn't be any point in padding to 8 bytes if the IDs were\n         * aligned on an odd 4-byte boundary.)\n         *\n         * Anyway, we just assume they're all glommed together on byte\n         * boundaries. */\n        error = ofpprop_pull__(payload, NULL, 1, 0x10000, &ofpit);\n        if (error) {\n            return error;\n        }\n\n        error = ovs_instruction_type_from_inst_type(&inst, ofpit);\n        if (!error) {\n            *insts |= 1u << inst;\n        } else if (!loose) {\n            return error;\n        }\n    }\n    return 0;\n}\n",
        "output": "0",
        "idx": 1724
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ZIPARCHIVE_METHOD(addEmptyDir)\n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tchar *dirname;\n\tsize_t   dirname_len;\n\tint idx;\n\tstruct zip_stat sb;\n\tchar *s;\n\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\n\tZIP_FROM_OBJECT(intern, self);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"s\",\n\t\t\t\t&dirname, &dirname_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (dirname_len<1) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (dirname[dirname_len-1] != '/') {\n\t\ts=(char *)emalloc(dirname_len+2);\n\t\tstrcpy(s, dirname);\n\t\ts[dirname_len] = '/';\n\t\ts[dirname_len+1] = '\\0';\n\t} else {\n\t\ts = dirname;\n\t}\n\n\tidx = zip_stat(intern, s, 0, &sb);\n\tif (idx >= 0) {\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tif (zip_add_dir(intern, (const char *)s) == -1) {\n\t\t\tRETVAL_FALSE;\n\t\t}\n\t\tzip_error_clear(intern);\n\t\tRETVAL_TRUE;\n\t}\n\n\tif (s != dirname) {\n\t\tefree(s);\n\t}\n}\n",
        "output": "0",
        "idx": 693
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct in6_addr *ndp_msg_opt_route_prefix(struct ndp_msg *msg, int offset)\n{\n\tstatic struct in6_addr prefix;\n\tstruct __nd_opt_route_info *ri =\n\t\t\tndp_msg_payload_opts_offset(msg, offset);\n\n\tmemset(&prefix, 0, sizeof(prefix));\n\tmemcpy(&prefix, &ri->nd_opt_ri_prefix, (ri->nd_opt_ri_len - 1) << 3);\n\treturn &prefix;\n}\n",
        "output": "0",
        "idx": 345
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned writeSignature(ucvector* out)\n{\n  /*8 bytes PNG signature, aka the magic bytes*/\n  if (!ucvector_push_back(out, 137)) return 83;\n  if (!ucvector_push_back(out, 80)) return 83;\n  if (!ucvector_push_back(out, 78)) return 83;\n  if (!ucvector_push_back(out, 71)) return 83;\n  if (!ucvector_push_back(out, 13)) return 83;\n  if (!ucvector_push_back(out, 10)) return 83;\n  if (!ucvector_push_back(out, 26)) return 83;\n  if (!ucvector_push_back(out, 10)) return 83;\n\n  return 0;\n}\n",
        "output": "0",
        "idx": 1875
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "juniper_pppoe_atm_print(netdissect_options *ndo,\n                        const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n\tuint16_t extracted_ethertype;\n\n        l2info.pictype = DLT_JUNIPER_PPPOE_ATM;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n \n         p+=l2info.header_len;\n \n         extracted_ethertype = EXTRACT_16BITS(p);\n         /* this DLT contains nothing but raw PPPoE frames,\n          * prepended with a type field*/\n        if (ethertype_print(ndo, extracted_ethertype,\n                              p+ETHERTYPE_LEN,\n                              l2info.length-ETHERTYPE_LEN,\n                              l2info.caplen-ETHERTYPE_LEN,\n                              NULL, NULL) == 0)\n            /* ether_type not known, probably it wasn't one */\n             ND_PRINT((ndo, \"unknown ethertype 0x%04x\", extracted_ethertype));\n \n         return l2info.header_len;\n }\n",
        "output": "1",
        "idx": 1249
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "qedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t\tconst char *fmt, ...)\n {\n \tva_list va;\n \tstruct va_format vaf;\n\tchar nfunc[32];\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n \n \tva_start(va, fmt);\n \n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & QEDI_LOG_NOTICE))\n\t\tgoto ret;\n \n \tif (likely(qedi) && likely(qedi->pdev))\n \t\tpr_notice(\"[%s]:[%s:%d]:%d: %pV\",\n\t\t\t  dev_name(&qedi->pdev->dev), nfunc, line,\n \t\t\t  qedi->host_no, &vaf);\n \telse\n\t\tpr_notice(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\n \n ret:\n \tva_end(va);\n}\n",
        "output": "1",
        "idx": 1868
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\n\tremain = dp->logicalSize - dp->pos;\n \tif(remain >= len) {\n \t\trlen = len;\n \t} else {\n\t\tif(remain == 0) {\n \t\t\t/* 2.0.34: EOF is incorrect. We use 0 for\n \t\t\t * errors and EOF, just like fileGetbuf,\n \t\t\t * which is a simple fread() wrapper.\n\t\t\t * TBB. Original bug report: Daniel Cowgill. */\n\t\t\treturn 0; /* NOT EOF */\n\t\t}\n\n\t\trlen = remain;\n\t}\n\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\n\treturn rlen;\n}\n",
        "output": "1",
        "idx": 322
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void WebPluginDelegateProxy::OnGetWindowScriptNPObject(\n    int route_id, bool* success, intptr_t* npobject_ptr) {\n   *success = false;\n   NPObject* npobject = NULL;\n   if (plugin_)\n    npobject = plugin_->GetWindowScriptNPObject();\n\n  if (!npobject)\n    return;\n\n   window_script_object_ = (new NPObjectStub(\n       npobject, channel_host_.get(), route_id, 0, page_url_))->AsWeakPtr();\n   *success = true;\n  *npobject_ptr = reinterpret_cast<intptr_t>(npobject);\n }\n",
        "output": "1",
        "idx": 642
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "map_id_range_down_base(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)\n{\n\tunsigned idx;\n\tu32 first, last, id2;\n\n\tid2 = id + count - 1;\n\n\t/* Find the matching extent */\n\tfor (idx = 0; idx < extents; idx++) {\n\t\tfirst = map->extent[idx].first;\n\t\tlast = first + map->extent[idx].count - 1;\n\t\tif (id >= first && id <= last &&\n\t\t    (id2 >= first && id2 <= last))\n\t\t\treturn &map->extent[idx];\n\t}\n\treturn NULL;\n}\n",
        "output": "0",
        "idx": 421
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int store_asoundrc(void) {\n\tfs_build_mnt_dir();\n \n \tchar *src;\n \tchar *dest = RUN_ASOUNDRC_FILE;\n \tFILE *fp = fopen(dest, \"w\");\n \tif (fp) {\n \t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n\t\tfclose(fp);\n\t}\n\t\n\tif (asprintf(&src, \"%s/.asoundrc\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t\n\tstruct stat s;\n\tif (stat(src, &s) == 0) {\n\t\tif (is_link(src)) {\n\t\t\t/* coverity[toctou] */\n\t\t\tchar* rp = realpath(src, NULL);\n\t\t\tif (!rp) {\n\t\t\t\tfprintf(stderr, \"Error: Cannot access %s\\n\", src);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {\n\t\t\t\tfprintf(stderr, \"Error: .asoundrc is a symbolic link pointing to a file outside home directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tfree(rp);\n\t\t}\n\n\t\tcopy_file_as_user(src, dest, getuid(), getgid(), 0644);\n\t\tfs_logger2(\"clone\", dest);\n\t\treturn 1; // file copied\n\t}\n\t\n\treturn 0;\n}\n",
        "output": "1",
        "idx": 457
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "armv6_pmcr_has_overflowed(unsigned long pmcr)\n{\n\treturn pmcr & ARMV6_PMCR_OVERFLOWED_MASK;\n}\n",
        "output": "0",
        "idx": 60
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int lxc_clear_config_network(struct lxc_conf *c)\n{\n\tstruct lxc_list *it,*next;\n\tlxc_list_for_each_safe(it, &c->network, next) {\n\t\tlxc_remove_nic(it);\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "idx": 1853
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SpoolssSetPrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t       proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)\n{\n\tguint32 level;\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_level, &level);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", level %d\", level);\n\n\toffset = dissect_SPOOL_PRINTER_INFO(\n\t\ttvb, offset, pinfo, tree, di, drep);\n\n\toffset = dissect_ndr_uint32(\n\t\ttvb, offset, pinfo, tree, di, drep,\n\t\thf_setprinter_cmd, NULL);\n\n\treturn offset;\n}\n",
        "output": "0",
        "idx": 1699
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *eval_map_start(struct seq_file *m, loff_t *pos)\n{\n\tunion trace_eval_map_item *v;\n\tloff_t l = 0;\n\n\tmutex_lock(&trace_eval_mutex);\n\n\tv = trace_eval_maps;\n\tif (v)\n\t\tv++;\n\n\twhile (v && l < *pos) {\n\t\tv = eval_map_next(m, v, &l);\n\t}\n\n\treturn v;\n}\n",
        "output": "0",
        "idx": 1377
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_cipher rcipher;\n \n\tsnprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"cipher\");\n \n \trcipher.blocksize = alg->cra_blocksize;\n \trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n\trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\n\t\t    sizeof(struct crypto_report_cipher), &rcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n",
        "output": "1",
        "idx": 348
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int decode_create(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)\n{\n\t__be32 *p;\n\tuint32_t bmlen;\n\tint status;\n\n\tstatus = decode_op_hdr(xdr, OP_CREATE);\n\tif (status)\n\t\treturn status;\n\tif ((status = decode_change_info(xdr, cinfo)))\n\t\treturn status;\n\tREAD_BUF(4);\n\tREAD32(bmlen);\n\tREAD_BUF(bmlen << 2);\n\treturn 0;\n}\n",
        "output": "0",
        "idx": 1549
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderViewImpl::DidFlushPaint() {\n  pepper_helper_->ViewFlushedPaint();\n\n  if (!webview())\n    return;\n\n  WebFrame* main_frame = webview()->mainFrame();\n\n  if (!main_frame->provisionalDataSource()) {\n    WebDataSource* ds = main_frame->dataSource();\n    DocumentState* document_state = DocumentState::FromDataSource(ds);\n\n    Time now = Time::Now();\n    if (document_state->first_paint_time().is_null()) {\n      document_state->set_first_paint_time(now);\n    }\n    if (document_state->first_paint_after_load_time().is_null() &&\n        !document_state->finish_load_time().is_null()) {\n      document_state->set_first_paint_after_load_time(now);\n    }\n  }\n}\n",
        "output": "0",
        "idx": 623
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t driver_override_show(struct device *dev,\n \t\t\t\t    struct device_attribute *attr, char *buf)\n {\n \tstruct platform_device *pdev = to_platform_device(dev);\n \n\treturn sprintf(buf, \"%s\\n\", pdev->driver_override);\n }\n",
        "output": "1",
        "idx": 749
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,\n const char *msg,\n const xmlChar * info1, const xmlChar * info2,\n const xmlChar * info3)\n{\n if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&\n (ctxt->instate == XML_PARSER_EOF))\n return;\n if (ctxt != NULL)\n\tctxt->errNo = error;\n    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,\n                    XML_ERR_ERROR, NULL, 0, (const char *) info1,\n (const char *) info2, (const char *) info3, 0, 0, msg,\n                    info1, info2, info3);\n if (ctxt != NULL)\n\tctxt->nsWellFormed = 0;\n}\n",
        "output": "0",
        "idx": 1534
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   void TestPlaybackRate(double playback_rate) {\n    static const int kDefaultBufferSize = kSamplesPerSecond / 10;\n    static const int kDefaultFramesRequested = 5 * kSamplesPerSecond;\n \n     TestPlaybackRate(playback_rate, kDefaultBufferSize,\n                      kDefaultFramesRequested);\n  }\n",
        "output": "1",
        "idx": 502
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void fpm_child_init(struct fpm_worker_pool_s *wp) /* {{{ */\n {\n \tfpm_globals.max_requests = wp->config->pm_max_requests;\n \n \tif (0 > fpm_stdio_init_child(wp)  ||\n \t    0 > fpm_log_init_child(wp)    ||\n\t    0 > fpm_status_init_child(wp) ||\n\t    0 > fpm_unix_init_child(wp)   ||\n\t    0 > fpm_signals_init_child()  ||\n\t    0 > fpm_env_init_child(wp)    ||\n\t    0 > fpm_php_init_child(wp)) {\n\n\t\tzlog(ZLOG_ERROR, \"[pool %s] child failed to initialize\", wp->config->name);\n\t\texit(FPM_EXIT_SOFTWARE);\n\t}\n}\n/* }}} */\n",
        "output": "1",
        "idx": 548
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   virtual void SetUp() {\n    fwd_txfm_ = GET_PARAM(0);\n\n     inv_txfm_ = GET_PARAM(1);\n     version_  = GET_PARAM(2);  // 0: high precision forward transform\n   }\n",
        "output": "1",
        "idx": 1443
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "receive_carbon(void **state)\n{\n    prof_input(\"/carbons on\");\n\n    prof_connect();\n    assert_true(stbbr_received(\n        \"<iq id='*' type='set'><enable xmlns='urn:xmpp:carbons:2'/></iq>\"\n    ));\n\n    stbbr_send(\n        \"<presence to='stabber@localhost' from='buddy1@localhost/mobile'>\"\n            \"<priority>10</priority>\"\n            \"<status>On my mobile</status>\"\n        \"</presence>\"\n    );\n    assert_true(prof_output_exact(\"Buddy1 (mobile) is online, \\\"On my mobile\\\"\"));\n    prof_input(\"/msg Buddy1\");\n     assert_true(prof_output_exact(\"unencrypted\"));\n \n     stbbr_send(\n        \"<message type='chat' to='stabber@localhost/profanity' from='buddy1@localhost'>\"\n             \"<received xmlns='urn:xmpp:carbons:2'>\"\n                 \"<forwarded xmlns='urn:xmpp:forward:0'>\"\n                     \"<message id='prof_msg_7' xmlns='jabber:client' type='chat' lang='en' to='stabber@localhost/profanity' from='buddy1@localhost/mobile'>\"\n                        \"<body>test carbon from recipient</body>\"\n                    \"</message>\"\n                \"</forwarded>\"\n            \"</received>\"\n        \"</message>\"\n    );\n\n    assert_true(prof_output_regex(\"Buddy1/mobile: .+test carbon from recipient\"));\n}\n",
        "output": "1",
        "idx": 1553
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,\n \t\t    gfp_t gfp, struct dma_attrs *attrs)\n {\n\tpgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);\n \tvoid *memory;\n \n \tif (dma_alloc_from_coherent(dev, size, handle, &memory))\n\t\treturn memory;\n\n\treturn __dma_alloc(dev, size, handle, gfp, prot, false,\n\t\t\t   __builtin_return_address(0));\n}\n",
        "output": "1",
        "idx": 1467
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline void PulseAudioMixer::MainloopLock() const {\n   pa_threaded_mainloop_lock(pa_mainloop_);\n   ++mainloop_lock_count_;\n }\n",
        "output": "1",
        "idx": 54
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FillMiscNavigationParams(const CommonNavigationParams& common_params,\n                              const CommitNavigationParams& commit_params,\n                              blink::WebNavigationParams* navigation_params) {\n  navigation_params->navigation_timings = BuildNavigationTimings(\n      common_params.navigation_start, commit_params.navigation_timing,\n      common_params.input_start);\n\n  navigation_params->is_user_activated =\n      commit_params.was_activated == WasActivatedOption::kYes;\n\n  if (commit_params.origin_to_commit) {\n    navigation_params->origin_to_commit =\n        commit_params.origin_to_commit.value();\n  }\n}\n",
        "output": "0",
        "idx": 2059
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebSocketJob::OnConnected(\n    SocketStream* socket, int max_pending_send_allowed) {\n  if (state_ == CLOSED)\n    return;\n  DCHECK_EQ(CONNECTING, state_);\n  if (delegate_)\n    delegate_->OnConnected(socket, max_pending_send_allowed);\n}\n",
        "output": "0",
        "idx": 1110
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "base::string16 AuthenticatorBlePairingBeginSheetModel::GetStepDescription()\n    const {\n  return l10n_util::GetStringUTF16(IDS_WEBAUTHN_BLE_PAIRING_BEGIN_DESCRIPTION);\n}\n",
        "output": "0",
        "idx": 232
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n {\n\treturn usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t       RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,\n\t\t\t       indx, 0, data, size, 500);\n }\n",
        "output": "1",
        "idx": 281
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool GLES2DecoderImpl::DoIsShader(GLuint client_id) {\n  return GetShaderInfo(client_id) != NULL;\n}\n",
        "output": "0",
        "idx": 910
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void UserSelectionScreen::OnBeforeUserRemoved(const AccountId& account_id) {\n  for (user_manager::UserList::iterator it = users_.begin(); it != users_.end();\n       ++it) {\n     if ((*it)->GetAccountId() == account_id) {\n       users_.erase(it);\n       break;\n    }\n  }\n}\n",
        "output": "1",
        "idx": 736
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int invalidate_partition(struct gendisk *disk, int partno)\n{\n\tint res = 0;\n\tstruct block_device *bdev = bdget_disk(disk, partno);\n\tif (bdev) {\n\t\tfsync_bdev(bdev);\n\t\tres = __invalidate_device(bdev, true);\n\t\tbdput(bdev);\n\t}\n\treturn res;\n}\n",
        "output": "0",
        "idx": 267
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean nbd_negotiate_continue(QIOChannel *ioc,\n                                       GIOCondition condition,\n                                       void *opaque)\n{\n    qemu_coroutine_enter(opaque);\n    return TRUE;\n}\n",
        "output": "1",
        "idx": 1672
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void UnloadController::TabDetachedAt(TabContents* contents, int index) {\n   TabDetachedImpl(contents);\n }\n",
        "output": "1",
        "idx": 1539
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sector_t swapdev_block(int type, pgoff_t offset)\n{\n\tstruct block_device *bdev;\n\n\tif ((unsigned int)type >= nr_swapfiles)\n\t\treturn 0;\n\tif (!(swap_info[type]->flags & SWP_WRITEOK))\n\t\treturn 0;\n\treturn map_swap_entry(swp_entry(type, offset), &bdev);\n}\n",
        "output": "0",
        "idx": 1736
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ExtensionServiceBackend::LoadSingleExtension(const FilePath& path_in) {\n  CHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));\n\n  FilePath extension_path = path_in;\n  file_util::AbsolutePath(&extension_path);\n\n  int flags = Extension::ShouldAlwaysAllowFileAccess(Extension::LOAD) ?\n      Extension::ALLOW_FILE_ACCESS : Extension::NO_FLAGS;\n  if (Extension::ShouldDoStrictErrorChecking(Extension::LOAD))\n    flags |= Extension::STRICT_ERROR_CHECKS;\n  std::string error;\n  scoped_refptr<const Extension> extension(extension_file_util::LoadExtension(\n      extension_path,\n      Extension::LOAD,\n      flags,\n      &error));\n\n  if (!extension) {\n    if (!BrowserThread::PostTask(\n            BrowserThread::UI, FROM_HERE,\n            NewRunnableMethod(\n                this,\n                &ExtensionServiceBackend::ReportExtensionLoadError,\n                extension_path, error)))\n      NOTREACHED() << error;\n    return;\n  }\n\n  if (!BrowserThread::PostTask(\n           BrowserThread::UI, FROM_HERE,\n           NewRunnableMethod(\n               this,\n              &ExtensionServiceBackend::OnExtensionInstalled,\n               extension)))\n     NOTREACHED();\n }\n",
        "output": "1",
        "idx": 1785
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int shm_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\n\tif (!sfd->file->f_op->fsync)\n\t\treturn -EINVAL;\n\treturn sfd->file->f_op->fsync(sfd->file, start, end, datasync);\n}\n",
        "output": "0",
        "idx": 1258
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " SPL_METHOD(GlobIterator, count)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n\tif (php_stream_is(intern->u.dir.dirp ,&php_glob_stream_ops)) {\n\t\tRETURN_LONG(php_glob_stream_get_count(intern->u.dir.dirp, NULL));\n\t} else {\n\t\t/* should not happen */\n\t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"GlobIterator lost glob state\");\n\t}\n}\n",
        "output": "1",
        "idx": 57
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void ExtensionViewGuest::DidNavigateMainFrame(\n     const content::LoadCommittedDetails& details,\n     const content::FrameNavigateParams& params) {\n  if (attached() && (params.url.GetOrigin() != url_.GetOrigin())) {\n     bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(),\n                                     bad_message::EVG_BAD_ORIGIN);\n   }\n}\n",
        "output": "1",
        "idx": 17
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void put_crypt_info(struct fscrypt_info *ci)\n{\n \tif (!ci)\n \t\treturn;\n \n\tkey_put(ci->ci_keyring_key);\n \tcrypto_free_skcipher(ci->ci_ctfm);\n \tkmem_cache_free(fscrypt_info_cachep, ci);\n }\n",
        "output": "1",
        "idx": 362
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebProcessProxy::addExistingWebPage(WebPageProxy* webPage, uint64_t pageID)\n{\n     m_pageMap.set(pageID, webPage);\n     globalPageMap().set(pageID, webPage);\n #if PLATFORM(MAC)\n    if (pageIsProcessSuppressible(webPage));\n         m_processSuppressiblePages.add(pageID);\n     updateProcessSuppressionState();\n #endif\n}\n",
        "output": "1",
        "idx": 1644
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool use_goto_tb(DisasContext *s, target_ulong pc)\n{\n#ifndef CONFIG_USER_ONLY\n    return (pc & TARGET_PAGE_MASK) == (s->tb->pc & TARGET_PAGE_MASK) ||\n           (pc & TARGET_PAGE_MASK) == (s->pc_start & TARGET_PAGE_MASK);\n#else\n    return true;\n#endif\n}\n",
        "output": "0",
        "idx": 1604
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned long iov_iter_alignment(const struct iov_iter *i)\n{\n\tconst struct iovec *iov = i->iov;\n\tunsigned long res;\n\tsize_t size = i->count;\n\tsize_t n;\n\n\tif (!size)\n\t\treturn 0;\n\n\tres = (unsigned long)iov->iov_base + i->iov_offset;\n\tn = iov->iov_len - i->iov_offset;\n\tif (n >= size)\n\t\treturn res | size;\n\tsize -= n;\n\tres |= n;\n\twhile (size > (++iov)->iov_len) {\n\t\tres |= (unsigned long)iov->iov_base | iov->iov_len;\n\t\tsize -= iov->iov_len;\n\t}\n\tres |= (unsigned long)iov->iov_base | size;\n\treturn res;\n}\n",
        "output": "0",
        "idx": 1781
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fbStore_x1r5g5b5 (FbBits *bits, const CARD32 *values, int x, int width, miIndexedPtr indexed)\n{\n    int i;\n    CARD16  *pixel = ((CARD16 *) bits) + x;\n    for (i = 0; i < width; ++i) {\n        Split(READ(values + i));\n        WRITE(pixel++, ((r << 7) & 0x7c00) |\n\t      ((g << 2) & 0x03e0) |\n\t      ((b >> 3)         ));\n    }\n}\n",
        "output": "0",
        "idx": 1531
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HostPortAllocatorSession::OnSessionRequestDone(\n    UrlFetcher* url_fetcher,\n    const net::URLRequestStatus& status,\n    int response_code,\n    const std::string& response) {\n  url_fetchers_.erase(url_fetcher);\n  delete url_fetcher;\n \n  if (response_code != net::HTTP_OK) {\n     LOG(WARNING) << \"Received error when allocating relay session: \"\n                 << response_code;\n     TryCreateRelaySession();\n     return;\n   }\n \n   ReceiveSessionResponse(response);\n }\n",
        "output": "1",
        "idx": 99
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hash_recvmsg(struct kiocb *unused, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tunsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));\n\tint err;\n\n\tif (len > ds)\n\t\tlen = ds;\n \telse if (len < ds)\n \t\tmsg->msg_flags |= MSG_TRUNC;\n \n\tmsg->msg_namelen = 0;\n \tlock_sock(sk);\n \tif (ctx->more) {\n \t\tctx->more = 0;\n\t\tahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);\n\t\terr = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),\n\t\t\t\t\t\t &ctx->completion);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\terr = memcpy_toiovec(msg->msg_iov, ctx->result, len);\n\nunlock:\n\trelease_sock(sk);\n\n\treturn err ?: len;\n}\n",
        "output": "1",
        "idx": 1502
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_swevent_del(struct perf_event *event, int flags)\n{\n\thlist_del_rcu(&event->hlist_entry);\n}\n",
        "output": "0",
        "idx": 1400
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)\n{\n  struct Context *ctx = (struct Context *) data;\n  if (!ctx)\n    return -1;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  if (!pop_data)\n    return -1;\n\n#ifdef USE_HCACHE\n  /* keep hcache file if hcache == bcache */\n  if (strcmp(HC_FNAME \".\" HC_FEXT, id) == 0)\n    return 0;\n#endif\n\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    /* if the id we get is known for a header: done (i.e. keep in cache) */\n    if (ctx->hdrs[i]->data && (mutt_str_strcmp(ctx->hdrs[i]->data, id) == 0))\n      return 0;\n  }\n\n   /* message not found in context -> remove it from cache\n    * return the result of bcache, so we stop upon its first error\n    */\n  return mutt_bcache_del(bcache, id);\n }\n",
        "output": "1",
        "idx": 1844
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dns_resolver_match(const struct key *key,\n\t\t   const struct key_match_data *match_data)\n {\n \tint slen, dlen, ret = 0;\n \tconst char *src = key->description, *dsp = match_data->raw_data;\n\n\tkenter(\"%s,%s\", src, dsp);\n\n\tif (!src || !dsp)\n\t\tgoto no_match;\n\n\tif (strcasecmp(src, dsp) == 0)\n\t\tgoto matched;\n\n\tslen = strlen(src);\n\tdlen = strlen(dsp);\n\tif (slen <= 0 || dlen <= 0)\n\t\tgoto no_match;\n\tif (src[slen - 1] == '.')\n\t\tslen--;\n\tif (dsp[dlen - 1] == '.')\n\t\tdlen--;\n\tif (slen != dlen || strncasecmp(src, dsp, slen) != 0)\n\t\tgoto no_match;\n\nmatched:\n\tret = 1;\nno_match:\n\tkleave(\" = %d\", ret);\n \treturn ret;\n }\n",
        "output": "1",
        "idx": 88
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " image_transform_png_set_scale_16_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n {\n    UNUSED(colour_type)\n \n this->next = *that;\n *that = this;\n\n return bit_depth > 8;\n}\n",
        "output": "1",
        "idx": 1688
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void InputMethodBase::OnInputMethodChanged() const {\n   TextInputClient* client = GetTextInputClient();\n  if (client && client->GetTextInputType() != TEXT_INPUT_TYPE_NONE)\n     client->OnInputMethodChanged();\n }\n",
        "output": "1",
        "idx": 2066
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize)\n{\n\treturn (0);\n}\n",
        "output": "0",
        "idx": 452
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE2(listen, int, fd, int, backlog)\n{\n\tstruct socket *sock;\n\tint err, fput_needed;\n\tint somaxconn;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock) {\n\t\tsomaxconn = sock_net(sock->sk)->core.sysctl_somaxconn;\n\t\tif ((unsigned int)backlog > somaxconn)\n\t\t\tbacklog = somaxconn;\n\n\t\terr = security_socket_listen(sock, backlog);\n\t\tif (!err)\n\t\t\terr = sock->ops->listen(sock, backlog);\n\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n",
        "output": "0",
        "idx": 709
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static bool HasElementImpl(Isolate* isolate, Handle<JSObject> holder,\n uint32_t index,\n Handle<FixedArrayBase> backing_store,\n PropertyFilter filter = ALL_PROPERTIES) {\n return Subclass::GetEntryForIndexImpl(isolate, *holder, *backing_store,\n                                          index, filter) != kMaxUInt32;\n }\n",
        "output": "0",
        "idx": 526
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static bool HasEntryImpl(Isolate* isolate, FixedArrayBase* backing_store,\n uint32_t entry) {\n return !BackingStore::cast(backing_store)->is_the_hole(isolate, entry);\n }\n",
        "output": "0",
        "idx": 1772
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cannotBeFunction(Parse *pParse, struct SrcList_item *pFrom){\n  if( pFrom->fg.isTabFunc ){\n    sqlite3ErrorMsg(pParse, \"'%s' is not a function\", pFrom->zName);\n    return 1;\n  }\n  return 0;\n}\n",
        "output": "0",
        "idx": 724
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateString( const char *string )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item ) {\n\t\titem->type = cJSON_String;\n\t\titem->valuestring = cJSON_strdup( string );\n\t}\n\treturn item;\n}\n",
        "output": "1",
        "idx": 2055
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)\n{\n    char * const s = b->ptr;\n    const int blen = (int)buffer_string_length(b);\n    const int used = qs < 0 ? blen : qs;\n    int j = i;\n    for (; i < used; ++i, ++j) {\n        s[j] = s[i];\n        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {\n            s[j] = '/';\n            i+=2;\n         }\n     }\n     if (qs >= 0) {\n        memmove(s+j, s+qs, blen - qs);\n        j += blen - qs;\n     }\n     buffer_string_set_length(b, j);\n     return qs;\n}\n",
        "output": "1",
        "idx": 918
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)\n{\n\tunsigned long val;\n\tvoid *ptr = NULL;\n\n\tif (!atomic_pool) {\n\t\tWARN(1, \"coherent pool not initialised!\\n\");\n\t\treturn NULL;\n\t}\n\n\tval = gen_pool_alloc(atomic_pool, size);\n\tif (val) {\n\t\tphys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);\n \n \t\t*ret_page = phys_to_page(phys);\n \t\tptr = (void *)val;\n\t\tif (flags & __GFP_ZERO)\n\t\t\tmemset(ptr, 0, size);\n \t}\n \n \treturn ptr;\n}\n",
        "output": "1",
        "idx": 1936
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RootWindowHostWin::SetCapture() {\n  if (!has_capture_) {\n    has_capture_ = true;\n    ::SetCapture(hwnd());\n  }\n}\n",
        "output": "0",
        "idx": 1662
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void die(const char *fmt, ...) {\n    va_list ap;\n    va_start(ap, fmt);\n    vprintf(fmt, ap);\n    if(fmt[strlen(fmt)-1] != '\\n')\n        printf(\"\\n\");\n    exit(EXIT_FAILURE);\n}\n",
        "output": "1",
        "idx": 1866
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void LocalFileSystem::deleteFileSystem(ExecutionContext* context, FileSystemType type, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)\n{\n    RefPtrWillBeRawPtr<ExecutionContext> contextPtr(context);\n     ASSERT(context);\n     ASSERT_WITH_SECURITY_IMPLICATION(context->isDocument());\n \n    RefPtr<CallbackWrapper> wrapper = adoptRef(new CallbackWrapper(callbacks));\n     requestFileSystemAccessInternal(context,\n         bind(&LocalFileSystem::deleteFileSystemInternal, this, contextPtr, type, wrapper),\n         bind(&LocalFileSystem::fileSystemNotAllowedInternal, this, contextPtr, wrapper));\n}\n",
        "output": "1",
        "idx": 1806
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  TestResultCallback()\n      : callback_(base::Bind(&TestResultCallback::SetResult,\n                             base::Unretained(this))) {}\n",
        "output": "1",
        "idx": 720
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void PartialMagnificationController::OnWindowDestroying(aura::Window* window) {\n   CloseMagnifierWindow();\n \n   aura::Window* new_root_window = GetCurrentRootWindow();\n   if (new_root_window != window)\n    SwitchTargetRootWindow(new_root_window);\n }\n",
        "output": "1",
        "idx": 819
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::string GetStoreIdFromProfile(Profile* profile) {\n   DCHECK(profile);\n   return profile->IsOffTheRecord() ?\n       kOffTheRecordProfileStoreId : kOriginalProfileStoreId;\n}\n",
        "output": "1",
        "idx": 84
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "png_get_filter_type(png_structp png_ptr, png_infop info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return info_ptr->filter_type;\n\n   return (0);\n}\n",
        "output": "0",
        "idx": 1343
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void addr_hash_set(u32 *mask, const u8 *addr)\n{\n\tint n = ether_crc(ETH_ALEN, addr) >> 26;\n\tmask[n >> 5] |= (1 << (n & 31));\n}\n",
        "output": "0",
        "idx": 2107
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,\n\t\t   struct br_ip *group, int type)\n {\n \tstruct br_mdb_entry entry;\n \n \tentry.ifindex = port->dev->ifindex;\n \tentry.addr.proto = group->proto;\n \tentry.addr.u.ip4 = group->u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tentry.addr.u.ip6 = group->u.ip6;\n#endif\n\t__br_mdb_notify(dev, &entry, type);\n}\n",
        "output": "1",
        "idx": 814
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err grpl_dump(GF_Box *a, FILE * trace)\n{\n\tgf_isom_box_dump_start(a, \"GroupListBox\", trace);\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"GroupListBox\", a, trace);\n\treturn GF_OK;\n}\n",
        "output": "0",
        "idx": 1642
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,\n PixelFormat format, uint32_t usage) {\n Parcel data, reply;\n        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());\n        data.writeInt32(static_cast<int32_t>(async));\n        data.writeUint32(width);\n        data.writeUint32(height);\n        data.writeInt32(static_cast<int32_t>(format));\n        data.writeUint32(usage);\n status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &reply);\n if (result != NO_ERROR) {\n            ALOGE(\"allocateBuffers failed to transact: %d\", result);\n }\n }\n",
        "output": "0",
        "idx": 134
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t kvm_get_exit_reason(struct kvm_vcpu *vcpu)\n{\n\tstruct exit_ctl_data *p_exit_data;\n\n\tp_exit_data = kvm_get_exit_data(vcpu);\n\treturn p_exit_data->exit_reason;\n}\n",
        "output": "0",
        "idx": 645
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const Chapters::Display* Chapters::Atom::GetDisplay(int index) const\n{\n    if (index < 0)\n        return NULL;\n    if (index >= m_displays_count)\n        return NULL;\n    return m_displays + index;\n}\n",
        "output": "1",
        "idx": 927
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static int atusb_get_and_show_revision(struct atusb *atusb)\n {\n \tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char buffer[3];\n \tint ret;\n \n \t/* Get a couple of the ATMega Firmware values */\n \tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n \t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\tif (ret >= 0) {\n\t\tatusb->fw_ver_maj = buffer[0];\n\t\tatusb->fw_ver_min = buffer[1];\n\t\tatusb->fw_hw_type = buffer[2];\n\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware: major: %u, minor: %u, hardware type: %u\\n\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);\n\t}\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n \t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n \t}\n \n \treturn ret;\n }\n",
        "output": "1",
        "idx": 269
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __exit tcm_loop_fabric_exit(void)\n{\n\ttcm_loop_deregister_configfs();\n\ttcm_loop_release_core_bus();\n\tkmem_cache_destroy(tcm_loop_cmd_cache);\n}\n",
        "output": "0",
        "idx": 850
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  ~ConnectionFilterController() {}\n",
        "output": "0",
        "idx": 874
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PDFiumEngine::OnDocumentComplete() {\n  if (!doc_ || !form_) {\n    file_access_.m_FileLen = doc_loader_.document_size();\n    if (!fpdf_availability_) {\n      fpdf_availability_ = FPDFAvail_Create(&file_availability_, &file_access_);\n      DCHECK(fpdf_availability_);\n    }\n    LoadDocument();\n    return;\n  }\n\n  FinishLoadingDocument();\n}\n",
        "output": "0",
        "idx": 192
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "string16 ExtensionInstallUI::Prompt::GetHeading(std::string extension_name)\n    const {\n   if (type_ == INLINE_INSTALL_PROMPT) {\n     return UTF8ToUTF16(extension_name);\n   } else {\n    return l10n_util::GetStringFUTF16(\n        kHeadingIds[type_], UTF8ToUTF16(extension_name));\n  }\n}\n",
        "output": "1",
        "idx": 1253
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WebMediaPlayer* RenderView::createMediaPlayer(\n    WebFrame* frame, WebMediaPlayerClient* client) {\n  FOR_EACH_OBSERVER(\n      RenderViewObserver, observers_, WillCreateMediaPlayer(frame, client));\n\n  scoped_ptr<media::MessageLoopFactory> message_loop_factory(\n      new media::MessageLoopFactoryImpl());\n  scoped_ptr<media::FilterCollection> collection(\n      new media::FilterCollection());\n\n  const CommandLine* cmd_line = CommandLine::ForCurrentProcess();\n  if (!cmd_line->HasSwitch(switches::kDisableAudio)) {\n    collection->AddAudioRenderer(new AudioRendererImpl());\n  }\n\n  scoped_refptr<webkit_glue::WebVideoRenderer> video_renderer;\n  bool pts_logging = cmd_line->HasSwitch(switches::kEnableVideoLogging);\n  scoped_refptr<webkit_glue::VideoRendererImpl> renderer(\n      new webkit_glue::VideoRendererImpl(pts_logging));\n  collection->AddVideoRenderer(renderer);\n  video_renderer = renderer;\n\n  scoped_ptr<webkit_glue::WebMediaPlayerImpl> result(\n      new webkit_glue::WebMediaPlayerImpl(client,\n                                          collection.release(),\n                                          message_loop_factory.release(),\n                                          media_stream_impl_.get()));\n  if (!result->Initialize(frame,\n                          cmd_line->HasSwitch(switches::kSimpleDataSource),\n                          video_renderer)) {\n    return NULL;\n  }\n  return result.release();\n}\n",
        "output": "0",
        "idx": 1842
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "w3m_exit(int i)\n{\n#ifdef USE_MIGEMO\n    init_migemo();\t\t/* close pipe to migemo */\n#endif\n    stopDownload();\n    deleteFiles();\n#ifdef USE_SSL\n    free_ssl_ctx();\n#endif\n    disconnectFTP();\n#ifdef USE_NNTP\n    disconnectNews();\n #endif\n #ifdef __MINGW32_VERSION\n     WSACleanup();\n #endif\n     exit(i);\n }\n",
        "output": "1",
        "idx": 1893
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " Node::InsertionNotificationRequest HTMLBodyElement::insertedInto(ContainerNode* insertionPoint)\n {\n     HTMLElement::insertedInto(insertionPoint);\n    if (insertionPoint->inDocument()) {\n        Element* ownerElement = document().ownerElement();\n        if (isHTMLFrameElementBase(ownerElement)) {\n            HTMLFrameElementBase& ownerFrameElement = toHTMLFrameElementBase(*ownerElement);\n            int marginWidth = ownerFrameElement.marginWidth();\n            if (marginWidth != -1)\n                setIntegralAttribute(marginwidthAttr, marginWidth);\n            int marginHeight = ownerFrameElement.marginHeight();\n            if (marginHeight != -1)\n                setIntegralAttribute(marginheightAttr, marginHeight);\n        }\n    }\n    return InsertionDone;\n }\n",
        "output": "1",
        "idx": 1134
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void TranslateInfoBarBase::Layout() {\n  InfoBar::Layout();\n \n   gfx::Size icon_ps = icon_->GetPreferredSize();\n  icon_->SetBounds(InfoBar::kHorizontalPadding, InfoBar::OffsetY(this, icon_ps),\n      icon_ps.width(), icon_ps.height());\n }\n",
        "output": "1",
        "idx": 1303
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n {\n\treturn usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\n\t\t\t       RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,\n\t\t\t       indx, 0, data, size, 500);\n }\n",
        "output": "1",
        "idx": 875
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool BrowserCommandController::IsCommandEnabled(int id) const {\n  return command_updater_.IsCommandEnabled(id);\n}\n",
        "output": "0",
        "idx": 175
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_caller_uid (GDBusMethodInvocation *context, gint *uid)\n {\n        PolkitSubject *subject;\n        PolkitSubject *process;\n \n        subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (context));\n        process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, NULL);\n        if (!process) {\n                g_object_unref (subject);\n                 return FALSE;\n         }\n \n        *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));\n        g_object_unref (subject);\n        g_object_unref (process);\n \n         return TRUE;\n }\n",
        "output": "1",
        "idx": 406
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int l2tp_ip6_backlog_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tint rc;\n\n\t/* Charge it to the socket, dropping if the queue is full. */\n\trc = sock_queue_rcv_skb(sk, skb);\n\tif (rc < 0)\n\t\tgoto drop;\n\n\treturn 0;\n\ndrop:\n\tIP_INC_STATS(&init_net, IPSTATS_MIB_INDISCARDS);\n\tkfree_skb(skb);\n\treturn -1;\n}\n",
        "output": "0",
        "idx": 128
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ParamTraits<AudioParameters>::Read(const Message* m,\n                                        PickleIterator* iter,\n                                        AudioParameters* r) {\n  int format, channel_layout, sample_rate, bits_per_sample,\n      frames_per_buffer, channels;\n\n  if (!m->ReadInt(iter, &format) ||\n      !m->ReadInt(iter, &channel_layout) ||\n      !m->ReadInt(iter, &sample_rate) ||\n      !m->ReadInt(iter, &bits_per_sample) ||\n      !m->ReadInt(iter, &frames_per_buffer) ||\n      !m->ReadInt(iter, &channels))\n    return false;\n   r->Reset(static_cast<AudioParameters::Format>(format),\n            static_cast<ChannelLayout>(channel_layout),\n            sample_rate, bits_per_sample, frames_per_buffer);\n   return true;\n }\n",
        "output": "1",
        "idx": 1238
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderBlockFlow::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)\n{\n    RenderBlock::styleDidChange(diff, oldStyle);\n\n     bool canPropagateFloatIntoSibling = !isFloatingOrOutOfFlowPositioned() && !avoidsFloats();\n    if (diff == StyleDifferenceLayout && s_canPropagateFloatIntoSibling && !canPropagateFloatIntoSibling && hasOverhangingFloats()) {\n         RenderBlockFlow* parentBlockFlow = this;\n         const FloatingObjectSet& floatingObjectSet = m_floatingObjects->set();\n         FloatingObjectSetIterator end = floatingObjectSet.end();\n\n        for (RenderObject* curr = parent(); curr && !curr->isRenderView(); curr = curr->parent()) {\n            if (curr->isRenderBlockFlow()) {\n                RenderBlockFlow* currBlock = toRenderBlockFlow(curr);\n\n                if (currBlock->hasOverhangingFloats()) {\n                    for (FloatingObjectSetIterator it = floatingObjectSet.begin(); it != end; ++it) {\n                        RenderBox* renderer = (*it)->renderer();\n                        if (currBlock->hasOverhangingFloat(renderer)) {\n                            parentBlockFlow = currBlock;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        parentBlockFlow->markAllDescendantsWithFloatsForLayout();\n         parentBlockFlow->markSiblingsWithFloatsForLayout();\n     }\n \n    if (diff == StyleDifferenceLayout || !oldStyle)\n         createOrDestroyMultiColumnFlowThreadIfNeeded();\n }\n",
        "output": "1",
        "idx": 1239
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " checked_xcalloc (size_t num, size_t size)\n {\n    alloc_limit_assert (\"checked_xcalloc\", (num *size));\n     return xcalloc (num, size);\n }\n",
        "output": "1",
        "idx": 1120
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PasswordGenerationUIData GetTestGenerationUIData2() {\n  PasswordForm form;\n  form.form_data = autofill::FormData();\n  form.form_data.action = GURL(\"http://www.example2.com/accounts/Login\");\n  form.form_data.origin = GURL(\"http://www.example2.com/accounts/LoginAuth\");\n  PasswordGenerationUIData data;\n  data.password_form = form;\n  data.generation_element = ASCIIToUTF16(\"testelement2\");\n  data.max_length = 11;\n  return data;\n}\n",
        "output": "1",
        "idx": 487
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sas_unregister_common_dev(struct asd_sas_port *port, struct domain_device *dev)\n{\n\tstruct sas_ha_struct *ha = port->ha;\n\n\tsas_notify_lldd_dev_gone(dev);\n\tif (!dev->parent)\n\t\tdev->port->port_dev = NULL;\n\telse\n\t\tlist_del_init(&dev->siblings);\n\n\tspin_lock_irq(&port->dev_list_lock);\n\tlist_del_init(&dev->dev_list_node);\n\tif (dev_is_sata(dev))\n\t\tsas_ata_end_eh(dev->sata_dev.ap);\n\tspin_unlock_irq(&port->dev_list_lock);\n\n\tspin_lock_irq(&ha->lock);\n\tif (dev->dev_type == SAS_END_DEVICE &&\n\t    !list_empty(&dev->ssp_dev.eh_list_node)) {\n\t\tlist_del_init(&dev->ssp_dev.eh_list_node);\n\t\tha->eh_active--;\n\t}\n\tspin_unlock_irq(&ha->lock);\n\n \tsas_put_device(dev);\n }\n",
        "output": "0",
        "idx": 1188
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool SocketStream::is_secure() const {\n  return url_.SchemeIs(\"wss\");\n }\n",
        "output": "0",
        "idx": 19
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_tiffUnmapProc(thandle_t fd, void* base, toff_t size)\n{\n\t(void) fd;\n\t(void) size;\n\tUnmapViewOfFile(base);\n}\n",
        "output": "0",
        "idx": 1463
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void sched_destroy_group(struct task_group *tg)\n{\n\tunsigned long flags;\n\tint i;\n\n\t/* end participation in shares distribution */\n\tfor_each_possible_cpu(i)\n\t\tunregister_fair_sched_group(tg, i);\n\n\tspin_lock_irqsave(&task_group_lock, flags);\n\tlist_del_rcu(&tg->list);\n\tlist_del_rcu(&tg->siblings);\n\tspin_unlock_irqrestore(&task_group_lock, flags);\n\n\t/* wait for possible concurrent references to cfs_rqs complete */\n\tcall_rcu(&tg->rcu, free_sched_group_rcu);\n}\n",
        "output": "0",
        "idx": 1556
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nl80211_valid_4addr(struct cfg80211_registered_device *rdev,\n\t\t\t       struct net_device *netdev, u8 use_4addr,\n\t\t\t       enum nl80211_iftype iftype)\n{\n\tif (!use_4addr) {\n\t\tif (netdev && (netdev->priv_flags & IFF_BRIDGE_PORT))\n\t\t\treturn -EBUSY;\n\t\treturn 0;\n\t}\n\n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_AP)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_STATION)\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n",
        "output": "0",
        "idx": 828
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int _our_safe_pcap_next_ex(pcap_t *pcap, struct pcap_pkthdr **pkthdr,\n        const u_char **pktdata, const char *funcname,\n        const int line, const char *file)\n{\n    int res = pcap_next_ex(pcap, pkthdr, pktdata);\n\n    if (*pktdata && *pkthdr) {\n        if ((*pkthdr)->len > MAXPACKET) {\n            fprintf(stderr, \"safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\\n\",\n                    file, funcname, line, (*pkthdr)->len, MAXPACKET);\n             exit(-1);\n         }\n \n        if ((*pkthdr)->len < (*pkthdr)->caplen) {\n            fprintf(stderr, \"safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: packet length %u is less than capture length %u\\n\",\n                     file, funcname, line, (*pkthdr)->len, (*pkthdr)->caplen);\n             exit(-1);\n         }\n    }\n\n    return res;\n}\n",
        "output": "1",
        "idx": 79
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)\n{\n   struct virgl_gl_ctx_param ctx_params;\n   int i;\n   if (blit_ctx->initialised) {\n      vrend_clicbs->make_current(0, blit_ctx->gl_context);\n       return;\n    }\n \n    ctx_params.shared = true;\n    ctx_params.major_ver = VREND_GL_VER_MAJOR;\n    ctx_params.minor_ver = VREND_GL_VER_MINOR;\n\n   vrend_clicbs->make_current(0, blit_ctx->gl_context);\n   glGenVertexArrays(1, &blit_ctx->vaoid);\n   glGenFramebuffers(1, &blit_ctx->fb_id);\n\n   glGenBuffers(1, &blit_ctx->vbo_id);\n   blit_build_vs_passthrough(blit_ctx);\n\n   for (i = 0; i < 4; i++)\n      blit_ctx->vertices[i][0][3] = 1; /*v.w*/\n   glBindVertexArray(blit_ctx->vaoid);\n   glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);\n}\n",
        "output": "1",
        "idx": 409
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HTMLFormControlElement::parseAttribute(const QualifiedName& name, const AtomicString& value)\n{\n    if (name == formAttr) {\n        formAttributeChanged();\n        UseCounter::count(document(), UseCounter::FormAttribute);\n    } else if (name == disabledAttr) {\n        bool oldDisabled = m_disabled;\n        m_disabled = !value.isNull();\n        if (oldDisabled != m_disabled)\n            disabledAttributeChanged();\n    } else if (name == readonlyAttr) {\n        bool wasReadOnly = m_isReadOnly;\n         m_isReadOnly = !value.isNull();\n         if (wasReadOnly != m_isReadOnly) {\n             setNeedsWillValidateCheck();\n            setNeedsStyleRecalc(SubtreeStyleChange, StyleChangeReasonForTracing::fromAttribute(name));\n             if (layoutObject())\n                 LayoutTheme::theme().controlStateChanged(*layoutObject(), ReadOnlyControlState);\n         }\n    } else if (name == requiredAttr) {\n        bool wasRequired = m_isRequired;\n        m_isRequired = !value.isNull();\n        if (wasRequired != m_isRequired)\n            requiredAttributeChanged();\n        UseCounter::count(document(), UseCounter::RequiredAttribute);\n    } else if (name == autofocusAttr) {\n        HTMLElement::parseAttribute(name, value);\n        UseCounter::count(document(), UseCounter::AutoFocusAttribute);\n    } else {\n        HTMLElement::parseAttribute(name, value);\n    }\n}\n",
        "output": "1",
        "idx": 854
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void br_multicast_group_expired(unsigned long data)\n{\n\tstruct net_bridge_mdb_entry *mp = (void *)data;\n\tstruct net_bridge *br = mp->br;\n\tstruct net_bridge_mdb_htable *mdb;\n\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) || timer_pending(&mp->timer))\n\t\tgoto out;\n\n\tif (!hlist_unhashed(&mp->mglist))\n\t\thlist_del_init(&mp->mglist);\n\n\tif (mp->ports)\n\t\tgoto out;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\n\thlist_del_rcu(&mp->hlist[mdb->ver]);\n\tmdb->size--;\n\n\tdel_timer(&mp->query_timer);\n\tcall_rcu_bh(&mp->rcu, br_multicast_free_group);\n\nout:\n\tspin_unlock(&br->multicast_lock);\n}\n",
        "output": "0",
        "idx": 1871
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Plugin::~Plugin() {\n  int64_t shutdown_start = NaClGetTimeOfDayMicroseconds();\n\n  PLUGIN_PRINTF((\"Plugin::~Plugin (this=%p, scriptable_plugin=%p)\\n\",\n                 static_cast<void*>(this),\n                 static_cast<void*>(scriptable_plugin())));\n  pnacl_coordinator_.reset(NULL);\n  if (ppapi_proxy_ != NULL) {\n    HistogramTimeLarge(\n        \"NaCl.ModuleUptime.Normal\",\n        (shutdown_start - ready_time_) / NACL_MICROS_PER_MILLI);\n  }\n\n  url_downloaders_.erase(url_downloaders_.begin(), url_downloaders_.end());\n\n  ShutdownProxy();\n  ScriptablePlugin* scriptable_plugin_ = scriptable_plugin();\n  ScriptablePlugin::Unref(&scriptable_plugin_);\n\n  ShutDownSubprocesses();\n\n  delete wrapper_factory_;\n  delete[] argv_;\n  delete[] argn_;\n\n  HistogramTimeSmall(\n      \"NaCl.Perf.ShutdownTime.Total\",\n      (NaClGetTimeOfDayMicroseconds() - shutdown_start)\n          / NACL_MICROS_PER_MILLI);\n\n  PLUGIN_PRINTF((\"Plugin::~Plugin (this=%p, return)\\n\",\n                 static_cast<void*>(this)));\n}\n",
        "output": "0",
        "idx": 83
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GpuProcessHostUIShim::OnAcceleratedSurfaceNew(\n    const GpuHostMsg_AcceleratedSurfaceNew_Params& params) {\n  RenderWidgetHostViewPort* view = GetRenderWidgetHostViewFromSurfaceID(\n       params.surface_id);\n   if (!view)\n     return;\n   view->AcceleratedSurfaceNew(\n      params.width, params.height, params.surface_handle);\n }\n",
        "output": "1",
        "idx": 1764
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SafeBrowsingBlockingPageV2::PopulateStringDictionary(\n    DictionaryValue* strings,\n    const string16& title,\n    const string16& headline,\n    const string16& description1,\n    const string16& description2,\n    const string16& description3) {\n  strings->SetString(\"title\", title);\n  strings->SetString(\"headLine\", headline);\n  strings->SetString(\"description1\", description1);\n  strings->SetString(\"description2\", description2);\n  strings->SetString(\"description3\", description3);\n  strings->SetBoolean(\"proceedDisabled\",\n                      IsPrefEnabled(prefs::kSafeBrowsingProceedAnywayDisabled));\n  strings->SetBoolean(\"isMainFrame\", is_main_frame_load_blocked_);\n  strings->SetBoolean(\"isPhishing\", interstitial_type_ == TYPE_PHISHING);\n\n  strings->SetString(\"back_button\",\n      l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_BACK_BUTTON));\n  strings->SetString(\"seeMore\", l10n_util::GetStringUTF16(\n      IDS_SAFE_BROWSING_MALWARE_V2_SEE_MORE));\n  strings->SetString(\"proceed\",\n      l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_V2_PROCEED_LINK));\n\n  URLDataSource::SetFontAndTextDirection(strings);\n}\n",
        "output": "0",
        "idx": 738
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xfs_perag_set_reclaim_tag(\n\tstruct xfs_perag\t*pag)\n{\n\tstruct xfs_mount\t*mp = pag->pag_mount;\n\n\tlockdep_assert_held(&pag->pag_ici_lock);\n\tif (pag->pag_ici_reclaimable++)\n\t\treturn;\n\n\t/* propagate the reclaim tag up into the perag radix tree */\n\tspin_lock(&mp->m_perag_lock);\n\tradix_tree_tag_set(&mp->m_perag_tree, pag->pag_agno,\n\t\t\t   XFS_ICI_RECLAIM_TAG);\n\tspin_unlock(&mp->m_perag_lock);\n\n\t/* schedule periodic background inode reclaim */\n\txfs_reclaim_work_queue(mp);\n\n\ttrace_xfs_perag_set_reclaim(mp, pag->pag_agno, -1, _RET_IP_);\n}\n",
        "output": "0",
        "idx": 1802
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void unmap_mapping_range_tree(struct rb_root *root,\n\t\t\t\t\t    struct zap_details *details)\n{\n\tstruct vm_area_struct *vma;\n\tpgoff_t vba, vea, zba, zea;\n\n\tvma_interval_tree_foreach(vma, root,\n\t\t\tdetails->first_index, details->last_index) {\n\n\t\tvba = vma->vm_pgoff;\n\t\tvea = vba + vma_pages(vma) - 1;\n\t\t/* Assume for now that PAGE_CACHE_SHIFT == PAGE_SHIFT */\n\t\tzba = details->first_index;\n\t\tif (zba < vba)\n\t\t\tzba = vba;\n\t\tzea = details->last_index;\n\t\tif (zea > vea)\n\t\t\tzea = vea;\n\n\t\tunmap_mapping_range_vma(vma,\n\t\t\t((zba - vba) << PAGE_SHIFT) + vma->vm_start,\n\t\t\t((zea - vba + 1) << PAGE_SHIFT) + vma->vm_start,\n\t\t\t\tdetails);\n\t}\n}\n",
        "output": "0",
        "idx": 482
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    FinishCompleteLoginParams::~FinishCompleteLoginParams() {}\n",
        "output": "0",
        "idx": 1288
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cfg_keys(struct cryp_ctx *ctx)\n{\n\tint i;\n\tint num_of_regs = ctx->keylen / 8;\n\tu32 swapped_key[CRYP_MAX_KEY_SIZE / 4];\n\tint cryp_error = 0;\n\n\tdev_dbg(ctx->device->dev, \"[%s]\", __func__);\n\n\tif (mode_is_aes(ctx->config.algomode)) {\n\t\tswap_words_in_key_and_bits_in_byte((u8 *)ctx->key,\n\t\t\t\t\t\t   (u8 *)swapped_key,\n\t\t\t\t\t\t   ctx->keylen);\n\t} else {\n\t\tfor (i = 0; i < ctx->keylen / 4; i++)\n\t\t\tswapped_key[i] = uint8p_to_uint32_be(ctx->key + i*4);\n\t}\n\n\tfor (i = 0; i < num_of_regs; i++) {\n\t\tcryp_error = set_key(ctx->device,\n\t\t\t\t     *(((u32 *)swapped_key)+i*2),\n\t\t\t\t     *(((u32 *)swapped_key)+i*2+1),\n\t\t\t\t     (enum cryp_key_reg_index) i);\n\n\t\tif (cryp_error != 0) {\n\t\t\tdev_err(ctx->device->dev, \"[%s]: set_key() failed!\",\n\t\t\t\t\t__func__);\n\t\t\treturn cryp_error;\n\t\t}\n\t}\n\treturn cryp_error;\n}\n",
        "output": "0",
        "idx": 1366
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Node* Range::pastLastNode() const\n{\n    if (!m_start.container() || !m_end.container())\n        return 0;\n    if (m_end.container()->offsetInCharacters())\n        return m_end.container()->traverseNextSibling();\n    if (Node* child = m_end.container()->childNode(m_end.offset()))\n        return child;\n    return m_end.container()->traverseNextSibling();\n}\n",
        "output": "0",
        "idx": 1568
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " av_cold void ff_mpv_idct_init(MpegEncContext *s)\n {\n     ff_idctdsp_init(&s->idsp, s->avctx);\n \n     /* load & permutate scantables\n     * note: only wmv uses different ones\n     */\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);\n    }\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n}\n",
        "output": "1",
        "idx": 310
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void didFinishLoadForFrame(WKPageRef page, WKFrameRef frame, WKTypeRef userData, const void* clientInfo)\n{\n    if (!WKFrameIsMainFrame(frame))\n        return;\n\n    webkitWebViewLoadChanged(WEBKIT_WEB_VIEW(clientInfo), WEBKIT_LOAD_FINISHED);\n}\n",
        "output": "0",
        "idx": 852
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "notify_setup(void)\n{\n\tif (pipe(notify_pipe) < 0) {\n\t\terror(\"pipe(notify_pipe) failed %s\", strerror(errno));\n\t} else if ((fcntl(notify_pipe[0], F_SETFD, FD_CLOEXEC) == -1) ||\n\t    (fcntl(notify_pipe[1], F_SETFD, FD_CLOEXEC) == -1)) {\n\t\terror(\"fcntl(notify_pipe, F_SETFD) failed %s\", strerror(errno));\n\t\tclose(notify_pipe[0]);\n\t\tclose(notify_pipe[1]);\n\t} else {\n\t\tset_nonblock(notify_pipe[0]);\n\t\tset_nonblock(notify_pipe[1]);\n\t\treturn;\n\t}\n\tnotify_pipe[0] = -1;\t/* read end */\n\tnotify_pipe[1] = -1;\t/* write end */\n}\n",
        "output": "0",
        "idx": 1067
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "my_object_dict_of_dicts (MyObject *obj, GHashTable *in,\n                                GHashTable **out, GError **error)\n{\n  *out = g_hash_table_new_full (g_str_hash, g_str_equal,\n\t\t\t\t(GDestroyNotify) g_free,\n                                (GDestroyNotify) g_hash_table_destroy);\n  g_hash_table_foreach (in, hash_foreach_mangle_dict_of_strings, *out);\n  return TRUE;\n}\n",
        "output": "1",
        "idx": 166
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int authenticate_and_decrypt_nss_2_0 (\n\tstruct crypto_instance *instance,\n\tunsigned char *buf,\n\tint *buf_len)\n{\n\tif (hash_to_nss[instance->crypto_hash_type]) {\n\t\tunsigned char\ttmp_hash[hash_len[instance->crypto_hash_type]];\n\t\tunsigned char\t*hash = buf;\n\t\tunsigned char\t*data = hash + hash_len[instance->crypto_hash_type];\n\t\tint\t\tdatalen = *buf_len - hash_len[instance->crypto_hash_type];\n\n\t\tif (calculate_nss_hash(instance, data, datalen, tmp_hash) < 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (memcmp(tmp_hash, hash, hash_len[instance->crypto_hash_type]) != 0) {\n\t\t\tlog_printf(instance->log_level_error, \"Digest does not match\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemmove(buf, data, datalen);\n\t\t*buf_len = datalen;\n\t}\n\n\tif (decrypt_nss(instance, buf, buf_len) < 0) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n",
        "output": "0",
        "idx": 445
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void VarianceTest<VarianceFunctionType>::ZeroTest() {\n   for (int i = 0; i <= 255; ++i) {\n    memset(src_, i, block_size_);\n     for (int j = 0; j <= 255; ++j) {\n      memset(ref_, j, block_size_);\n       unsigned int sse;\n       unsigned int var;\n      REGISTER_STATE_CHECK(var = variance_(src_, width_, ref_, width_, &sse));\n      EXPECT_EQ(0u, var) << \"src values: \" << i << \"ref values: \" << j;\n     }\n   }\n }\n",
        "output": "1",
        "idx": 690
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GahpServer::RemoveGahpClient()\n{\n\tm_reference_count--;\n\n\tif ( m_reference_count <= 0 ) {\n\t\tm_deleteMeTid = daemonCore->Register_Timer( 30,\n\t\t\t\t\t\t\t\t(TimerHandlercpp)&GahpServer::DeleteMe,\n\t\t\t\t\t\t\t\t\"GahpServer::DeleteMe\", (Service*)this );\n\t}\n}\n",
        "output": "0",
        "idx": 442
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)\n {\n \tint ret;\n \n \tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n \t\t\t      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,\n\t\t\t      indx, &data, 1, 1000);\n \tif (ret < 0)\n \t\tnetif_dbg(pegasus, drv, pegasus->net,\n \t\t\t  \"%s returned %d\\n\", __func__, ret);\n \treturn ret;\n }\n",
        "output": "1",
        "idx": 618
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static int getStrrtokenPos(char* str, int savedPos)\n {\n \tint result =-1;\n \tint i;\n \tfor(i=savedPos-1; i>=0; i--) {\n \t\tif(isIDSeparator(*(str+i)) ){\n \t\t\t/* delimiter found; check for singleton */\n\t\t\tif(i>=2 && isIDSeparator(*(str+i-2)) ){\n\t\t\t\t/* a singleton; so send the position of token before the singleton */\n\t\t\t\tresult = i-2;\n\t\t\t} else {\n\t\t\t\tresult = i;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(result < 1){\n\t\t/* Just in case inavlid locale e.g. '-x-xyz' or '-sl_Latn' */\n\t\tresult =-1;\n\t}\n\treturn result;\n}\n",
        "output": "1",
        "idx": 1408
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void conditionalAttr1AttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    ExceptionState exceptionState(ExceptionState::SetterContext, \"conditionalAttr1\", \"TestObject\", info.Holder(), info.GetIsolate());\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt32(jsValue, exceptionState), exceptionState);\n    imp->setConditionalAttr1(cppValue);\n}\n",
        "output": "0",
        "idx": 962
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t   gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n\t\t   int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n\n    status = val_unwrap_iov_args(minor_status, context_handle, NULL,\n\t\t\t\t qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;\n    if (mech->gss_verify_mic_iov == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_verify_mic_iov(minor_status, ctx->internal_ctx_id,\n\t\t\t\t      qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}\n",
        "output": "1",
        "idx": 154
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void drop_privileges(char *username) {\n\tstruct passwd *user = (struct passwd *) getpwnam(username);\n\tif (user == NULL) {\n\t\tfprintf(stderr, _(\"Failed dropping privileges. The user %s is not a valid username on local system.\\n\"), username);\n\t\texit(1);\n\t}\n\tif (getuid() == 0) {\n\t\t/* process is running as root, drop privileges */\n\t\tif (setgid(user->pw_gid) != 0) {\n\t\t\tfprintf(stderr, _(\"setgid: Error dropping group privileges\\n\"));\n\t\t\texit(1);\n\t\t}\n\t\tif (setuid(user->pw_uid) != 0) {\n\t\t\tfprintf(stderr, _(\"setuid: Error dropping user privileges\\n\"));\n\t\t\texit(1);\n\t\t}\n\t\t/* Verify if the privileges were developed. */\n\t\tif (setuid(0) != -1) {\n\t\t\tfprintf(stderr, _(\"Failed to drop privileges\\n\"));\n\t\t\texit(1);\n\t\t}\n\t}\n}\n",
        "output": "0",
        "idx": 111
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void BufferQueueConsumer::dump(String8& result, const char* prefix) const {\n    mCore->dump(result, prefix);\n }\n",
        "output": "1",
        "idx": 1667
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebContentsImpl::RenderViewForInterstitialPageCreated(\n    RenderViewHost* render_view_host) {\n  FOR_EACH_OBSERVER(WebContentsObserver, observers_,\n                    RenderViewForInterstitialPageCreated(render_view_host));\n}\n",
        "output": "0",
        "idx": 840
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "my_object_many_args (MyObject *obj, guint32 x, const char *str, double trouble, double *d_ret, char **str_ret, GError **error)\n{\n  *d_ret = trouble + (x * 2);\n  *str_ret = g_ascii_strup (str, -1);\n  return TRUE;\n}\n",
        "output": "1",
        "idx": 63
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char *set_async_filter(cmd_parms *cmd, void *dummy,\n                                             const char *arg)\n{\n    core_server_config *conf =\n    ap_get_core_module_config(cmd->server->module_config);\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n\n    if (err) {\n        return err;\n    }\n\n    if (ap_cstr_casecmp(arg, \"network\") == 0) {\n        conf->async_filter = AP_FTYPE_NETWORK;\n    }\n    else if (ap_cstr_casecmp(arg, \"connection\") == 0) {\n        conf->async_filter = AP_FTYPE_CONNECTION;\n    }\n    else if (ap_cstr_casecmp(arg, \"request\") == 0) {\n        conf->async_filter = 0;\n    }\n    else {\n        return \"AsyncFilter must be 'network', 'connection' or 'request'\";\n    }\n    conf->async_filter_set = 1;\n\n    return NULL;\n}\n",
        "output": "0",
        "idx": 1132
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual void SetUpCommandLine(CommandLine* command_line) {\n    GpuFeatureTest::SetUpCommandLine(command_line);\n    command_line->AppendSwitch(switches::kDisableExperimentalWebGL);\n  }\n",
        "output": "0",
        "idx": 556
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static v8::Handle<v8::Value> enabledAtRuntimeMethod2Callback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestObj.enabledAtRuntimeMethod2\");\n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(int, intArg, V8int::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8int::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);\n     imp->enabledAtRuntimeMethod2(intArg);\n    return v8::Handle<v8::Value>();\n}\n",
        "output": "1",
        "idx": 1427
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "add_cipher_name_to_ary(const OBJ_NAME *name, VALUE ary)\n{\n    rb_ary_push(ary, rb_str_new2(name->name));\n    return NULL;\n}\n",
        "output": "0",
        "idx": 1629
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PaletteTool::~PaletteTool() {}\n",
        "output": "0",
        "idx": 654
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "init_ext2_xattr(void)\n {\n\text2_xattr_cache = mb_cache_create(\"ext2_xattr\", 6);\n\tif (!ext2_xattr_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n }\n",
        "output": "1",
        "idx": 727
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool vmxnet3_interrupt_asserted(VMXNET3State *s, int lidx)\n{\n    return s->interrupt_states[lidx].is_asserted;\n}\n",
        "output": "0",
        "idx": 76
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vips_malloc( VipsObject *object, size_t size )\n {\n \tvoid *buf;\n \n\tbuf = g_malloc( size );\n \n         if( object ) {\n \t\tg_signal_connect( object, \"postclose\", \n\t\t\tG_CALLBACK( vips_malloc_cb ), buf );\n\t\tobject->local_memory += size;\n\t}\n\n\treturn( buf );\n}\n",
        "output": "1",
        "idx": 150
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ObserverOnLogoAvailable(LogoObserver* observer,\n                             bool from_cache,\n                             LogoCallbackReason type,\n                             const base::Optional<Logo>& logo) {\n  switch (type) {\n    case LogoCallbackReason::DISABLED:\n    case LogoCallbackReason::CANCELED:\n    case LogoCallbackReason::FAILED:\n      break;\n    case LogoCallbackReason::REVALIDATED:\n      break;\n    case LogoCallbackReason::DETERMINED:\n      observer->OnLogoAvailable(logo ? &logo.value() : nullptr, from_cache);\n      break;\n  }\n  if (!from_cache) {\n    observer->OnObserverRemoved();\n  }\n}\n",
        "output": "1",
        "idx": 792
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SplitString(const std::wstring& str,\n                 wchar_t c,\n                 std::vector<std::wstring>* r) {\n  SplitStringT(str, c, true, r);\n}\n",
        "output": "1",
        "idx": 1368
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static double abserr(PNG_CONST png_modifier *pm, int in_depth, int out_depth)\n {\n    /* Absolute error permitted in linear values - affected by the bit depth of\n     * the calculations.\n    */\n if (pm->assume_16_bit_calculations ||\n (pm->calculations_use_input_precision ? in_depth : out_depth) == 16)\n return pm->maxabs16;\n else\n\n       return pm->maxabs8;\n }\n",
        "output": "1",
        "idx": 108
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gpgsm_reset (void *engine)\n{\n  engine_gpgsm_t gpgsm = engine;\n\n  /* IF we have an active connection we must send a reset because we\n     need to reset the list of signers.  Note that RESET does not\n     reset OPTION commands. */\n  return (gpgsm->assuan_ctx\n          ? gpgsm_assuan_simple_command (gpgsm->assuan_ctx, \"RESET\",\n                                         NULL, NULL)\n          : 0);\n}\n",
        "output": "0",
        "idx": 1292
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ProcEstablishConnection(ClientPtr client)\n{\n    const char *reason;\n    char *auth_proto, *auth_string;\n    xConnClientPrefix *prefix;\n\n    REQUEST(xReq);\n\n     prefix = (xConnClientPrefix *) ((char *) stuff + sz_xReq);\n     auth_proto = (char *) prefix + sz_xConnClientPrefix;\n     auth_string = auth_proto + pad_to_int32(prefix->nbytesAuthProto);\n    if ((prefix->majorVersion != X_PROTOCOL) ||\n         (prefix->minorVersion != X_PROTOCOL_REVISION))\n         reason = \"Protocol version mismatch\";\n     else\n\n    return (SendConnSetup(client, reason));\n}\n",
        "output": "1",
        "idx": 691
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameImpl::OnJavaScriptExecuteRequestInIsolatedWorld(\n    const base::string16& jscript,\n    int id,\n    bool notify_result,\n    int world_id) {\n  TRACE_EVENT_INSTANT0(\"test_tracing\",\n                       \"OnJavaScriptExecuteRequestInIsolatedWorld\",\n                       TRACE_EVENT_SCOPE_THREAD);\n\n  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||\n      world_id > ISOLATED_WORLD_ID_MAX) {\n    NOTREACHED();\n    return;\n  }\n\n  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());\n  WebScriptSource script = WebScriptSource(jscript);\n  JavaScriptIsolatedWorldRequest* request = new JavaScriptIsolatedWorldRequest(\n      id, notify_result, routing_id_, weak_factory_.GetWeakPtr());\n  frame_->requestExecuteScriptInIsolatedWorld(world_id, &script, 1, 0, false,\n                                              request);\n}\n",
        "output": "0",
        "idx": 447
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DistillerNativeJavaScript::BindFunctionToObject(\n    v8::Local<v8::Object> javascript_object,\n    const std::string& name,\n    const base::Callback<Sig> callback) {\n  v8::Isolate* isolate = javascript_object->GetIsolate();\n  javascript_object->Set(\n      gin::StringToSymbol(isolate, name),\n      gin::CreateFunctionTemplate(isolate, callback)->GetFunction());\n }\n",
        "output": "0",
        "idx": 801
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void LaunchDownloadOverwriteInfoBar(\n    JNIEnv* env,\n    const JavaParamRef<jclass>& clazz,\n    const JavaParamRef<jobject>& delegate,\n    const JavaParamRef<jobject>& tab,\n    const JavaParamRef<jobject>& download_info,\n    const JavaParamRef<jstring>& jfile_name,\n    const JavaParamRef<jstring>& jdir_name,\n    const JavaParamRef<jstring>& jdir_full_path) {\n  TabAndroid* tab_android = TabAndroid::GetNativeTab(env, tab);\n\n  std::string file_name =\n      base::android::ConvertJavaStringToUTF8(env, jfile_name);\n  std::string dir_name = base::android::ConvertJavaStringToUTF8(env, jdir_name);\n  std::string dir_full_path =\n      base::android::ConvertJavaStringToUTF8(env, jdir_full_path);\n\n  chrome::android::AndroidDownloadManagerOverwriteInfoBarDelegate::Create(\n      InfoBarService::FromWebContents(tab_android->web_contents()), file_name,\n      dir_name, dir_full_path, delegate, download_info);\n}\n",
        "output": "0",
        "idx": 1170
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GDataEntry* GDataEntry::FromDocumentEntry(\n    GDataDirectory* parent,\n    DocumentEntry* doc,\n    GDataDirectoryService* directory_service) {\n  DCHECK(doc);\n  if (doc->is_folder())\n    return GDataDirectory::FromDocumentEntry(parent, doc, directory_service);\n  else if (doc->is_hosted_document() || doc->is_file())\n    return GDataFile::FromDocumentEntry(parent, doc, directory_service);\n  return NULL;\n}\n",
        "output": "1",
        "idx": 1344
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int perf_event_refresh(struct perf_event *event, int refresh)\n{\n\t/*\n\t * not supported on inherited events\n\t */\n\tif (event->attr.inherit || !is_sampling_event(event))\n\t\treturn -EINVAL;\n\n\tatomic_add(refresh, &event->event_limit);\n\tperf_event_enable(event);\n\n\treturn 0;\n}\n",
        "output": "0",
        "idx": 759
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static NetworkRoamingState ParseRoamingState(\n    const std::string& roaming_state) {\n    if (roaming_state == kRoamingStateHome)\n    return ROAMING_STATE_HOME;\n  if (roaming_state == kRoamingStateRoaming)\n    return ROAMING_STATE_ROAMING;\n  if (roaming_state == kRoamingStateUnknown)\n    return ROAMING_STATE_UNKNOWN;\n  return ROAMING_STATE_UNKNOWN;\n}\n",
        "output": "0",
        "idx": 252
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "v8::Handle<v8::Value> V8WebGLRenderingContext::getAttachedShadersCallback(const v8::Arguments& args)\n{\n     INC_STATS(\"DOM.WebGLRenderingContext.getAttachedShaders()\");\n \n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n \n     ExceptionCode ec = 0;\n     WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());\n    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLProgram::HasInstance(args[0])) {\n        V8Proxy::throwTypeError();\n        return notHandledByInterceptor();\n    }\n    WebGLProgram* program = V8WebGLProgram::HasInstance(args[0]) ? V8WebGLProgram::toNative(v8::Handle<v8::Object>::Cast(args[0])) : 0;\n    Vector<RefPtr<WebGLShader> > shaders;\n    bool succeed = context->getAttachedShaders(program, shaders, ec);\n    if (ec) {\n        V8Proxy::setDOMException(ec, args.GetIsolate());\n        return v8::Null();\n    }\n    if (!succeed)\n        return v8::Null();\n    v8::Local<v8::Array> array = v8::Array::New(shaders.size());\n    for (size_t ii = 0; ii < shaders.size(); ++ii)\n        array->Set(v8::Integer::New(ii), toV8(shaders[ii].get(), args.GetIsolate()));\n    return array;\n}\n",
        "output": "1",
        "idx": 870
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int read_int32_info (WavpackStream *wps, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd->byte_length;\n    char *byteptr = (char *)wpmd->data;\n\n    if (bytecnt != 4)\n        return FALSE;\n\n    wps->int32_sent_bits = *byteptr++;\n    wps->int32_zeros = *byteptr++;\n    wps->int32_ones = *byteptr++;\n    wps->int32_dups = *byteptr;\n\n    return TRUE;\n}\n",
        "output": "0",
        "idx": 1479
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void AppCacheGroup::RemoveCache(AppCache* cache) {\n   DCHECK(cache->associated_hosts().empty());\n   if (cache == newest_complete_cache_) {\n    CancelUpdate();\n     AppCache* tmp_cache = newest_complete_cache_;\n     newest_complete_cache_ = nullptr;\n     tmp_cache->set_owning_group(nullptr);  // may cause this group to be deleted\n   } else {\n     scoped_refptr<AppCacheGroup> protect(this);\n\n    Caches::iterator it =\n        std::find(old_caches_.begin(), old_caches_.end(), cache);\n    if (it != old_caches_.end()) {\n      AppCache* tmp_cache = *it;\n      old_caches_.erase(it);\n      tmp_cache->set_owning_group(nullptr);  // may cause group to be released\n    }\n\n    if (!is_obsolete() && old_caches_.empty() &&\n        !newly_deletable_response_ids_.empty()) {\n      storage_->DeleteResponses(manifest_url_, newly_deletable_response_ids_);\n      newly_deletable_response_ids_.clear();\n    }\n  }\n}\n",
        "output": "1",
        "idx": 1999
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const base::FilePath& DriveFsHost::GetMountPath() const {\n  DCHECK(IsMounted());\n  return mount_state_->mount_path();\n}\n",
        "output": "0",
        "idx": 1512
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NetworkThrottleManagerImpl::NetworkThrottleManagerImpl()\n     : lifetime_median_estimate_(PercentileEstimator::kMedianPercentile,\n                                 kInitialMedianInMs),\n       outstanding_recomputation_timer_(\n          base::MakeUnique<base::Timer>(false /* retain_user_task */,\n                                         false /* is_repeating */)),\n       tick_clock_(new base::DefaultTickClock()),\n       weak_ptr_factory_(this) {}\n",
        "output": "1",
        "idx": 403
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ossl_cipher_initialize(VALUE self, VALUE str)\n{\n     EVP_CIPHER_CTX *ctx;\n     const EVP_CIPHER *cipher;\n     char *name;\n    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };\n \n     name = StringValueCStr(str);\n     GetCipherInit(self, ctx);\n    if (ctx) {\n\tossl_raise(rb_eRuntimeError, \"Cipher already inititalized!\");\n    }\n    AllocCipher(self, ctx);\n     if (!(cipher = EVP_get_cipherbyname(name))) {\n \tossl_raise(rb_eRuntimeError, \"unsupported cipher algorithm (%\"PRIsVALUE\")\", str);\n     }\n    /*\n     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some\n     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]\n     *\n     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows\n     * uninitialized key, but other EVPs (such as AES) does not allow it.\n     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we\n     * set the data filled with \"\\0\" as the key by default.\n     */\n    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)\n \tossl_raise(eCipherError, NULL);\n \n     return self;\n}\n",
        "output": "1",
        "idx": 178
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void MockWebRTCPeerConnectionHandler::setRemoteDescription(const WebRTCVoidRequest& request, const WebRTCSessionDescriptionDescriptor& remoteDescription)\n{\n    if (!remoteDescription.isNull() && remoteDescription.type() == \"answer\") {\n        m_remoteDescription = remoteDescription;\n        postTask(new RTCVoidRequestTask(this, request, true));\n     } else\n        postTask(new RTCVoidRequestTask(this, request, false));\n}\n",
        "output": "1",
        "idx": 20
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool is_valid(const char *test_name) {\n for (size_t i = 0; i < sanity_suite_size; ++i) {\n if (!strcmp(test_name, sanity_suite[i].function_name)) {\n return true;\n }\n }\n for (size_t i = 0; i < test_suite_size; ++i) {\n if (!strcmp(test_name, test_suite[i].function_name)) {\n return true;\n }\n }\n return false;\n}\n",
        "output": "0",
        "idx": 1911
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderBox::paintRootBoxFillLayers(const PaintInfo& paintInfo)\n{\n    if (paintInfo.skipRootBackground())\n        return;\n\n    RenderObject* rootBackgroundRenderer = rendererForRootBackground();\n\n    const FillLayer* bgLayer = rootBackgroundRenderer->style()->backgroundLayers();\n    Color bgColor = rootBackgroundRenderer->resolveColor(CSSPropertyBackgroundColor);\n\n    paintFillLayers(paintInfo, bgColor, bgLayer, view()->backgroundRect(this), BackgroundBleedNone, CompositeSourceOver, rootBackgroundRenderer);\n}\n",
        "output": "0",
        "idx": 1900
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool RenderFrameImpl::ShouldDisplayErrorPageForFailedLoad(\n    int error_code,\n    const GURL& unreachable_url) {\n  if (error_code == net::ERR_ABORTED)\n    return false;\n\n  if (error_code == net::ERR_BLOCKED_BY_CLIENT &&\n      render_view_->renderer_preferences_.disable_client_blocked_error_page) {\n    return false;\n  }\n\n  if (GetContentClient()->renderer()->ShouldSuppressErrorPage(\n          this, unreachable_url)) {\n    return false;\n  }\n\n  if (RenderThreadImpl::current() &&\n      RenderThreadImpl::current()->layout_test_mode()) {\n    return false;\n  }\n\n  return true;\n}\n",
        "output": "0",
        "idx": 889
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SkiaOutputSurfaceImplTest::UnblockMainThread() {\n  DCHECK(!wait_.IsSignaled());\n  wait_.Signal();\n}\n",
        "output": "0",
        "idx": 1538
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ExtensionTtsController::Stop() {\n  if (current_utterance_ && !current_utterance_->extension_id().empty()) {\n    current_utterance_->profile()->GetExtensionEventRouter()->\n        DispatchEventToExtension(\n            current_utterance_->extension_id(),\n            events::kOnStop,\n            \"[]\",\n            current_utterance_->profile(),\n            GURL());\n  } else {\n    GetPlatformImpl()->clear_error();\n    GetPlatformImpl()->StopSpeaking();\n   }\n \n  if (current_utterance_)\n    current_utterance_->set_error(kSpeechInterruptedError);\n  FinishCurrentUtterance();\n  ClearUtteranceQueue();\n}\n",
        "output": "1",
        "idx": 919
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int save_avio_options(AVFormatContext *s)\n{\n    HLSContext *c = s->priv_data;\n    static const char *opts[] = {\n        \"headers\", \"http_proxy\", \"user_agent\", \"user-agent\", \"cookies\", NULL };\n    const char **opt = opts;\n    uint8_t *buf;\n    int ret = 0;\n\n    while (*opt) {\n        if (av_opt_get(s->pb, *opt, AV_OPT_SEARCH_CHILDREN | AV_OPT_ALLOW_NULL, &buf) >= 0) {\n            ret = av_dict_set(&c->avio_opts, *opt, buf,\n                              AV_DICT_DONT_STRDUP_VAL);\n            if (ret < 0)\n                return ret;\n        }\n        opt++;\n    }\n\n    return ret;\n}\n",
        "output": "0",
        "idx": 695
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void save_text_if_changed(const char *name, const char *new_value)\n{\n    /* a text value can't be change if the file is not loaded */\n    /* returns NULL if the name is not found; otherwise nonzero */\n    if (!g_hash_table_lookup(g_loaded_texts, name))\n        return;\n\n    const char *old_value = g_cd ? problem_data_get_content_or_NULL(g_cd, name) : \"\";\n    if (!old_value)\n        old_value = \"\";\n    if (strcmp(new_value, old_value) != 0)\n    {\n        struct dump_dir *dd = wizard_open_directory_for_writing(g_dump_dir_name);\n        if (dd)\n            dd_save_text(dd, name, new_value);\n \n         dd_close(dd);\n        problem_data_reload_from_dump_dir();\n        update_gui_state_from_problem_data(/* don't update selected event */ 0);\n     }\n }\n",
        "output": "1",
        "idx": 1961
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " TemplateURLRef::SearchTermsArgs::ContextualSearchParams::ContextualSearchParams(\n     int version,\n     const std::string& selection,\n     const std::string& base_page_url,\n    int now_on_tap_version)\n     : version(version),\n       start(base::string16::npos),\n       end(base::string16::npos),\n       selection(selection),\n       base_page_url(base_page_url),\n      now_on_tap_version(now_on_tap_version) {}\n",
        "output": "1",
        "idx": 1663
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ChromotingInstance::Init(uint32_t argc,\n                              const char* argn[],\n                              const char* argv[]) {\n  CHECK(!initialized_);\n  initialized_ = true;\n\n  VLOG(1) << \"Started ChromotingInstance::Init\";\n\n  if (!media::IsMediaLibraryInitialized()) {\n    LOG(ERROR) << \"Media library not initialized.\";\n     return false;\n   }\n \n  net::EnableSSLServerSockets();\n\n  context_.Start();\n\n  scoped_refptr<FrameConsumerProxy> consumer_proxy =\n      new FrameConsumerProxy(plugin_task_runner_);\n  rectangle_decoder_ = new RectangleUpdateDecoder(context_.main_task_runner(),\n                                                  context_.decode_task_runner(),\n                                                  consumer_proxy);\n  view_.reset(new PepperView(this, &context_, rectangle_decoder_.get()));\n  consumer_proxy->Attach(view_->AsWeakPtr());\n\n  return true;\n}\n",
        "output": "1",
        "idx": 1635
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void br_netfilter_rtable_init(struct net_bridge *br)\n{\n\tstruct rtable *rt = &br->fake_rtable;\n\n\tatomic_set(&rt->dst.__refcnt, 1);\n\trt->dst.dev = br->dev;\n\trt->dst.path = &rt->dst;\n\tdst_metric_set(&rt->dst, RTAX_MTU, 1500);\n\trt->dst.flags\t= DST_NOXFRM;\n\trt->dst.ops = &fake_dst_ops;\n}\n",
        "output": "0",
        "idx": 439
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " bool Extension::HasAPIPermission(const std::string& function_name) const {\n   base::AutoLock auto_lock(runtime_data_lock_);\n   return runtime_data_.GetActivePermissions()->\n      HasAccessToFunction(function_name);\n }\n",
        "output": "1",
        "idx": 1378
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GpuChannelHost* RenderThreadImpl::EstablishGpuChannelSync(\n    content::CauseForGpuLaunch cause_for_gpu_launch) {\n  if (gpu_channel_.get()) {\n    if (gpu_channel_->state() == GpuChannelHost::kUnconnected ||\n        gpu_channel_->state() == GpuChannelHost::kConnected)\n      return GetGpuChannel();\n\n    gpu_channel_ = NULL;\n  }\n\n   int client_id = 0;\n   IPC::ChannelHandle channel_handle;\n  base::ProcessHandle renderer_process_for_gpu;\n   content::GPUInfo gpu_info;\n   if (!Send(new GpuHostMsg_EstablishGpuChannel(cause_for_gpu_launch,\n                                                &client_id,\n                                                &channel_handle,\n                                               &renderer_process_for_gpu,\n                                                &gpu_info)) ||\n      channel_handle.name.empty() ||\n #if defined(OS_POSIX)\n       channel_handle.socket.fd == -1 ||\n #endif\n      renderer_process_for_gpu == base::kNullProcessHandle) {\n     gpu_channel_ = NULL;\n     return NULL;\n  }\n\n  gpu_channel_ = new GpuChannelHost(this, 0, client_id);\n  gpu_channel_->set_gpu_info(gpu_info);\n   content::GetContentClient()->SetGpuInfo(gpu_info);\n \n  gpu_channel_->Connect(channel_handle, renderer_process_for_gpu);\n \n   return GetGpuChannel();\n }\n",
        "output": "1",
        "idx": 1815
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Mutex& threadSetMutex()\n{\n    AtomicallyInitializedStaticReference(Mutex, mutex, new Mutex);\n    return mutex;\n}\n",
        "output": "0",
        "idx": 657
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void iwjpeg_scan_exif(struct iwjpegrcontext *rctx,\n\t\tconst iw_byte *d, size_t d_len)\n{\n\tstruct iw_exif_state e;\n\tiw_uint32 ifd;\n\n\tif(d_len<8) return;\n\n\tiw_zeromem(&e,sizeof(struct iw_exif_state));\n\te.d = d;\n\te.d_len = d_len;\n \n \te.endian = d[0]=='I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG;\n \n\tifd = iw_get_ui32_e(&d[4],e.endian);\n \n \tiwjpeg_scan_exif_ifd(rctx,&e,ifd);\n }\n",
        "output": "1",
        "idx": 1952
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "HTMLAllCollection* Document::all() {\n  return EnsureCachedCollection<HTMLAllCollection>(kDocAll);\n}\n",
        "output": "0",
        "idx": 621
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "v8::Handle<v8::Value> V8XMLHttpRequest::openCallback(const v8::Arguments& args)\n{\n    INC_STATS(\"DOM.XMLHttpRequest.open()\");\n \n     if (args.Length() < 2)\n        return V8Proxy::throwNotEnoughArgumentsError();\n \n     XMLHttpRequest* xmlHttpRequest = V8XMLHttpRequest::toNative(args.Holder());\n \n    String method = toWebCoreString(args[0]);\n    String urlstring = toWebCoreString(args[1]);\n    ScriptExecutionContext* context = getScriptExecutionContext();\n    if (!context)\n        return v8::Undefined();\n\n    KURL url = context->completeURL(urlstring);\n\n    ExceptionCode ec = 0;\n\n    if (args.Length() >= 3) {\n        bool async = args[2]->BooleanValue();\n\n        if (args.Length() >= 4 && !args[3]->IsUndefined()) {\n            String user = toWebCoreStringWithNullCheck(args[3]);\n            \n            if (args.Length() >= 5 && !args[4]->IsUndefined()) {\n                String passwd = toWebCoreStringWithNullCheck(args[4]);\n                xmlHttpRequest->open(method, url, async, user, passwd, ec);\n            } else\n                xmlHttpRequest->open(method, url, async, user, ec);\n        } else\n            xmlHttpRequest->open(method, url, async, ec);\n    } else\n        xmlHttpRequest->open(method, url, ec);\n\n    if (ec)\n        return throwError(ec, args.GetIsolate());\n\n    return v8::Undefined();\n}\n",
        "output": "1",
        "idx": 6
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static v8::Handle<v8::Value> methodWithNonOptionalArgAndOptionalArgCallback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestObj.methodWithNonOptionalArgAndOptionalArg\");\n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(int, nonOpt, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));\n     if (args.Length() <= 1) {\n        imp->methodWithNonOptionalArgAndOptionalArg(nonOpt);\n        return v8::Handle<v8::Value>();\n    }\n    EXCEPTION_BLOCK(int, opt, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));\n    imp->methodWithNonOptionalArgAndOptionalArg(nonOpt, opt);\n    return v8::Handle<v8::Value>();\n}\n",
        "output": "1",
        "idx": 1576
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int NaClIPCAdapter::RewrittenMessage::Read(char* dest_buffer,\n                                           size_t dest_buffer_size) {\n  CHECK(data_len_ >= data_read_cursor_);\n  size_t bytes_to_write = std::min(dest_buffer_size,\n                                   data_len_ - data_read_cursor_);\n  if (bytes_to_write == 0)\n    return 0;\n\n  memcpy(dest_buffer, &data_[data_read_cursor_], bytes_to_write);\n  data_read_cursor_ += bytes_to_write;\n  return static_cast<int>(bytes_to_write);\n}\n",
        "output": "0",
        "idx": 1578
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GesturePoint::GesturePoint()\n     : first_touch_time_(0.0),\n       last_touch_time_(0.0),\n       last_tap_time_(0.0),\n      velocity_calculator_(kBufferedPoints) {\n }\n",
        "output": "1",
        "idx": 1305
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FileSystemOperation::GetUsageAndQuotaThenRunTask(\n    const GURL& origin, FileSystemType type,\n    const base::Closure& task,\n    const base::Closure& error_callback) {\n  quota::QuotaManagerProxy* quota_manager_proxy =\n      file_system_context()->quota_manager_proxy();\n  if (!quota_manager_proxy ||\n      !file_system_context()->GetQuotaUtil(type)) {\n    operation_context_.set_allowed_bytes_growth(kint64max);\n    task.Run();\n    return;\n  }\n\n  TaskParamsForDidGetQuota params;\n  params.origin = origin;\n  params.type = type;\n  params.task = task;\n  params.error_callback = error_callback;\n\n  DCHECK(quota_manager_proxy);\n  DCHECK(quota_manager_proxy->quota_manager());\n  quota_manager_proxy->quota_manager()->GetUsageAndQuota(\n       origin,\n       FileSystemTypeToQuotaStorageType(type),\n       base::Bind(&FileSystemOperation::DidGetUsageAndQuotaAndRunTask,\n                 base::Unretained(this), params));\n }\n",
        "output": "1",
        "idx": 663
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "aodv_extension(netdissect_options *ndo,\n               const struct aodv_ext *ep, u_int length)\n {\n \tconst struct aodv_hello *ah;\n \n \tswitch (ep->type) {\n \tcase AODV_EXT_HELLO:\n \t\tah = (const struct aodv_hello *)(const void *)ep;\n \t\tND_TCHECK(*ah);\n \t\tif (length < sizeof(struct aodv_hello))\n \t\t\tgoto trunc;\n \t\tND_PRINT((ndo, \"\\n\\text HELLO %ld ms\",\n \t\t    (unsigned long)EXTRACT_32BITS(&ah->interval)));\n \t\tbreak;\n\n\tdefault:\n\t\tND_PRINT((ndo, \"\\n\\text %u %u\", ep->type, ep->length));\n\t\tbreak;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \" [|hello]\"));\n}\n",
        "output": "1",
        "idx": 226
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " bool AudioHandler::VerifyMixerConnection() {\n  PulseAudioMixer::State mixer_state = mixer_->CheckState();\n  if (mixer_state == PulseAudioMixer::READY)\n     return true;\n   if (connected_) {\n     connected_ = false;\n    LOG(ERROR) << \"Lost connection to PulseAudio\";\n   } else {\n     LOG(ERROR) << \"Mixer not valid\";\n   }\n \n  if ((mixer_state == PulseAudioMixer::INITIALIZING) ||\n      (mixer_state == PulseAudioMixer::SHUTTING_DOWN))\n     return false;\n \n   if (reconnect_tries_ < kMaxReconnectTries) {\n     reconnect_tries_++;\n    VLOG(1) << \"Re-connecting to PulseAudio attempt \" << reconnect_tries_ << \"/\"\n             << kMaxReconnectTries;\n    mixer_.reset(new PulseAudioMixer());\n    connected_ = mixer_->InitSync();\n     if (connected_) {\n       reconnect_tries_ = 0;\n       return true;\n     }\n    LOG(ERROR) << \"Unable to re-connect to PulseAudio\";\n   }\n   return false;\n }\n",
        "output": "1",
        "idx": 1593
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parse_field(netdissect_options *ndo, const char **pptr, int *len)\n {\n     const char *s;\n \n    if (*len <= 0 || !pptr || !*pptr)\n\treturn NULL;\n    if (*pptr > (const char *) ndo->ndo_snapend)\n\treturn NULL;\n     s = *pptr;\n    while (*pptr <= (const char *) ndo->ndo_snapend && *len >= 0 && **pptr) {\n \t(*pptr)++;\n \t(*len)--;\n     }\n     (*pptr)++;\n     (*len)--;\n    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)\n\treturn NULL;\n     return s;\n }\n",
        "output": "1",
        "idx": 463
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int entersafe_process_fci(struct sc_card *card, struct sc_file *file,\n\t\t\t\t\t\t  const u8 *buf, size_t buflen)\n{\n\t int r;\n\n\t assert(file);\n\t SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\t r = iso_ops->process_fci(card,file,buf,buflen);\n\t SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"Process fci failed\");\n\n\t if(file->namelen)\n\t {\n\t\t  file->type = SC_FILE_TYPE_DF;\n\t\t  file->ef_structure = SC_FILE_EF_UNKNOWN;\n\t }\n\t else\n\t {\n\t\t  file->type = SC_FILE_TYPE_WORKING_EF;\n\t\t  file->ef_structure = SC_FILE_EF_TRANSPARENT;\n\t }\n\n\t SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}\n",
        "output": "0",
        "idx": 443
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DecoderTest::RunLoop(CompressedVideoSource *video) {\n  vpx_codec_dec_cfg_t dec_cfg = {0};\n  Decoder* const decoder = codec_->CreateDecoder(dec_cfg, 0);\n   ASSERT_TRUE(decoder != NULL);\n \n  for (video->Begin(); video->cxdata(); video->Next()) {\n     PreDecodeFrameHook(*video, decoder);\n    vpx_codec_err_t res_dec = decoder->DecodeFrame(video->cxdata(),\n                                                   video->frame_size());\n    ASSERT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();\n \n     DxDataIterator dec_iter = decoder->GetDxData();\n     const vpx_image_t *img = NULL;\n\n\n     while ((img = dec_iter.Next()))\n       DecompressedFrameHook(*img, video->frame_number());\n   }\n   delete decoder;\n }\n",
        "output": "1",
        "idx": 1260
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){\n     long i;\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n         long a = *(long*)(src+i);\n         long b = *(long*)(dst+i);\n         *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] += src[i+0];\n}\n",
        "output": "1",
        "idx": 1763
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TIFFFdOpen(int fd, const char* name, const char* mode)\n{\n\tTIFF* tif;\n\n\ttif = TIFFClientOpen(name, mode,  ddd\n\t    (thandle_t) fd,\n\t    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,\n\t    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);\n\tif (tif)\n\t\ttif->tif_fd = fd;\n\treturn (tif);\n}\n",
        "output": "0",
        "idx": 1883
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void streamFreeCG(streamCG *cg) {\n    raxFreeWithCallback(cg->pel,(void(*)(void*))streamFreeNACK);\n    raxFreeWithCallback(cg->consumers,(void(*)(void*))streamFreeConsumer);\n    zfree(cg);\n}\n",
        "output": "0",
        "idx": 1969
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ofproto_port_get_stp_stats(struct ofproto *ofproto, ofp_port_t ofp_port,\n                           struct ofproto_port_stp_stats *s)\n{\n    struct ofport *ofport = ofproto_get_port(ofproto, ofp_port);\n    if (!ofport) {\n        VLOG_WARN_RL(&rl, \"%s: cannot get STP stats on nonexistent \"\n                     \"port %\"PRIu32, ofproto->name, ofp_port);\n        return ENODEV;\n    }\n\n    return (ofproto->ofproto_class->get_stp_port_stats\n            ? ofproto->ofproto_class->get_stp_port_stats(ofport, s)\n            : EOPNOTSUPP);\n}\n",
        "output": "0",
        "idx": 685
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int midi_setup_channel_pressure(struct _mdi *mdi, uint8_t channel,\n                                       uint8_t pressure) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, pressure);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_channel_pressure;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = pressure;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}\n",
        "output": "0",
        "idx": 1865
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BrowserViewRenderer::DidDestroyCompositor(\n     content::SynchronousCompositor* compositor) {\n   TRACE_EVENT0(\"android_webview\", \"BrowserViewRenderer::DidDestroyCompositor\");\n   DCHECK(compositor_);\n   compositor_ = NULL;\n }\n",
        "output": "1",
        "idx": 489
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Chunk::Chunk(Container* parent, WEBP_MetaHandler* handler)\n{\n    this->needsRewrite = (parent) ? parent->needsRewrite : false;\n    this->parent = parent;\n\n    XMP_IO* file = handler->parent->ioRef;\n    this->pos = file->Offset();\n\n    this->tag = XIO::ReadUns32_LE(file);\n\n    this->size = XIO::ReadUns32_LE(file);\n\n    if ((this->pos + this->size + 8) > handler->initialFileSize) {\n        XMP_Throw(\"Bad RIFF chunk size\", kXMPErr_BadFileFormat);\n    }\n\n    this->data.reserve((XMP_Int32) this->size);\n    this->data.assign((XMP_Int32) this->size, '\\0');\n    file->ReadAll((void*)this->data.data(), (XMP_Int32) this->size);\n\n    if (this->size & 1) {\n        file->Seek(1, kXMP_SeekFromCurrent);\n    }\n}\n",
        "output": "0",
        "idx": 1465
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void InterstitialPageImpl::InterstitialPageRVHDelegateView::ShowPopupMenu(\n    RenderFrameHost* render_frame_host,\n    const gfx::Rect& bounds,\n    int item_height,\n    double item_font_size,\n    int selected_item,\n    const std::vector<MenuItem>& items,\n    bool right_aligned,\n    bool allow_multiple_selection) {\n  NOTREACHED() << \"InterstitialPage does not support showing popup menus.\";\n}\n",
        "output": "0",
        "idx": 419
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rle_patch_file_size(struct iwbmpwcontext *wctx,size_t rlesize)\n{\n\tiw_byte buf[4];\n\tsize_t fileheader_size;\n\tint ret;\n\n\tif(!wctx->iodescr->seek_fn) {\n\t\tiw_set_error(wctx->ctx,\"Writing compressed BMP requires a seek function\");\n\t\treturn 0;\n\t}\n\n\tif(wctx->include_file_header) {\n\t\tret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,2,SEEK_SET);\n\t\tif(!ret) return 0;\n\t\tiw_set_ui32le(buf,(unsigned int)(14+wctx->header_size+wctx->bitfields_size+wctx->palsize+rlesize));\n\t\tiwbmp_write(wctx,buf,4);\n\t\tfileheader_size = 14;\n\t}\n\telse {\n\t\tfileheader_size = 0;\n\t}\n\n\tret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);\n\tif(!ret) return 0;\n\tiw_set_ui32le(buf,(unsigned int)rlesize);\n\tiwbmp_write(wctx,buf,4);\n\n\t(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,0,SEEK_END);\n\treturn 1;\n}\n",
        "output": "0",
        "idx": 1708
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int parse_sliteral(char **c, char **dst)\n{\n\tstruct token t;\n\tchar *s = *c;\n\n\tget_token(c, &t, L_SLITERAL);\n\n\tif (t.type != T_STRING) {\n\t\tprintf(\"Expected string literal: %.*s\\n\", (int)(*c - s), s);\n\t\treturn -EINVAL;\n\t}\n\n\t*dst = t.val;\n\n\treturn 1;\n}\n",
        "output": "0",
        "idx": 2031
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "des3_encrypt_ecb(const unsigned char *key, int keysize,\n\t\tconst unsigned char *input, int length, unsigned char *output)\n{\n\tunsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };\n\tunsigned char bKey[24] = { 0 };\n\n\tif (keysize == 16) {\n\t\tmemcpy(&bKey[0], key, 16);\n\t\tmemcpy(&bKey[16], key, 8);\n\t}\n\telse {\n\t\tmemcpy(&bKey[0], key, 24);\n\t}\n\n\treturn openssl_enc(EVP_des_ede3(), bKey, iv, input, length, output);\n}\n",
        "output": "0",
        "idx": 1462
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GooString *JBIG2Stream::getPSFilter(int psLevel, char *indent) {\n  return NULL;\n}\n",
        "output": "0",
        "idx": 1619
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WorkerProcessLauncher::Core::Send(IPC::Message* message) {\n  DCHECK(caller_task_runner_->BelongsToCurrentThread());\n\n  if (ipc_enabled_) {\n    launcher_delegate_->Send(message);\n  } else {\n    delete message;\n  }\n}\n",
        "output": "0",
        "idx": 786
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ChromeInvalidationClient::ReissueRegistrations(\n    invalidation::InvalidationClient* client,\n     const std::string& prefix,\n     int prefix_length) {\n   DCHECK(CalledOnValidThread());\n   DVLOG(1) << \"AllRegistrationsLost\";\n   registration_manager_->MarkAllRegistrationsLost();\n }\n",
        "output": "1",
        "idx": 963
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void prefetch_enc(void)\n {\n  prefetch_table((const void *)encT, sizeof(encT));\n }\n",
        "output": "1",
        "idx": 1746
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extern \"C\" void RIL_setcallbacks (const RIL_RadioFunctions *callbacks) {\n    memcpy(&s_callbacks, callbacks, sizeof (RIL_RadioFunctions));\n}\n",
        "output": "0",
        "idx": 53
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Vp9Parser::ReadSegmentation() {\n  segmentation_.update_map = false;\n  segmentation_.update_data = false;\n \n  segmentation_.enabled = reader_.ReadBool();\n  if (!segmentation_.enabled)\n     return;\n \n  segmentation_.update_map = reader_.ReadBool();\n  if (segmentation_.update_map)\n    ReadSegmentationMap();\n \n  segmentation_.update_data = reader_.ReadBool();\n  if (segmentation_.update_data)\n    ReadSegmentationData();\n }\n",
        "output": "1",
        "idx": 1823
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::wstring DetermineChannel(const InstallConstants& mode,\n                              bool system_level,\n                              bool from_binaries,\n                              std::wstring* update_ap,\n                              std::wstring* update_cohort_name) {\n  if (!kUseGoogleUpdateIntegration)\n    return std::wstring();\n\n  std::wstring client_state(from_binaries\n                                ? GetBinariesClientStateKeyPath()\n                                : GetClientStateKeyPath(mode.app_guid));\n  std::wstring ap_value;\n  nt::QueryRegValueSZ(system_level ? nt::HKLM : nt::HKCU, nt::WOW6432,\n                      client_state.c_str(), kRegValueAp, &ap_value);\n  if (update_ap)\n    *update_ap = ap_value;\n\n  if (update_cohort_name) {\n    nt::QueryRegValueSZ(system_level ? nt::HKLM : nt::HKCU, nt::WOW6432,\n                        client_state.append(L\"\\\\cohort\").c_str(), kRegValueName,\n                        update_cohort_name);\n  }\n\n  switch (mode.channel_strategy) {\n    case ChannelStrategy::UNSUPPORTED:\n      assert(false);\n      break;\n    case ChannelStrategy::ADDITIONAL_PARAMETERS:\n      return ChannelFromAdditionalParameters(mode, ap_value);\n    case ChannelStrategy::FIXED:\n      return mode.default_channel_name;\n  }\n\n  return std::wstring();\n}\n",
        "output": "0",
        "idx": 1515
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void AppShortcutManager::OnceOffCreateShortcuts() {\n  bool was_enabled = prefs_->GetBoolean(prefs::kAppShortcutsHaveBeenCreated);\n#if defined(OS_MACOSX)\n  bool is_now_enabled = apps::IsAppShimsEnabled();\n#else\n  bool is_now_enabled = true;\n#endif  // defined(OS_MACOSX)\n  if (was_enabled != is_now_enabled)\n    prefs_->SetBoolean(prefs::kAppShortcutsHaveBeenCreated, is_now_enabled);\n  if (was_enabled || !is_now_enabled)\n     return;\n \n   extensions::ExtensionSystem* extension_system;\n  ExtensionServiceInterface* extension_service;\n  if (!(extension_system = extensions::ExtensionSystem::Get(profile_)) ||\n      !(extension_service = extension_system->extension_service()))\n    return;\n\n  const extensions::ExtensionSet* apps = extension_service->extensions();\n  for (extensions::ExtensionSet::const_iterator it = apps->begin();\n       it != apps->end(); ++it) {\n    if (ShouldCreateShortcutFor(profile_, it->get()))\n      CreateShortcutsInApplicationsMenu(profile_, it->get());\n  }\n}\n",
        "output": "1",
        "idx": 681
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PreconnectManager::Start(const GURL& url,\n                              std::vector<PreconnectRequest> requests) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n  const std::string host = url.host();\n  if (preresolve_info_.find(host) != preresolve_info_.end())\n    return;\n\n  auto iterator_and_whether_inserted = preresolve_info_.emplace(\n      host, std::make_unique<PreresolveInfo>(url, requests.size()));\n  PreresolveInfo* info = iterator_and_whether_inserted.first->second.get();\n \n   for (auto request_it = requests.begin(); request_it != requests.end();\n        ++request_it) {\n    DCHECK(request_it->origin.GetOrigin() == request_it->origin);\n     PreresolveJobId job_id = preresolve_jobs_.Add(\n         std::make_unique<PreresolveJob>(std::move(*request_it), info));\n     queued_jobs_.push_back(job_id);\n  }\n\n  TryToLaunchPreresolveJobs();\n}\n",
        "output": "1",
        "idx": 64
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void VideoCaptureImpl::OnBufferCreated(int32_t buffer_id,\n                                       mojo::ScopedSharedBufferHandle handle) {\n  DVLOG(1) << __func__ << \" buffer_id: \" << buffer_id;\n  DCHECK(io_thread_checker_.CalledOnValidThread());\n  DCHECK(handle.is_valid());\n \n   base::SharedMemoryHandle memory_handle;\n   size_t memory_size = 0;\n  bool read_only_flag = false;\n \n   const MojoResult result = mojo::UnwrapSharedMemoryHandle(\n      std::move(handle), &memory_handle, &memory_size, &read_only_flag);\n   DCHECK_EQ(MOJO_RESULT_OK, result);\n   DCHECK_GT(memory_size, 0u);\n \n   std::unique_ptr<base::SharedMemory> shm(\n       new base::SharedMemory(memory_handle, true /* read_only */));\n   if (!shm->Map(memory_size)) {\n    DLOG(ERROR) << \"OnBufferCreated: Map failed.\";\n    return;\n  }\n  const bool inserted =\n      client_buffers_\n          .insert(std::make_pair(buffer_id,\n                                 new ClientBuffer(std::move(shm), memory_size)))\n          .second;\n  DCHECK(inserted);\n}\n",
        "output": "1",
        "idx": 536
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void CallbackAndDie(bool succeeded) {\n    v8::Isolate* isolate = context_->isolate();\n    v8::HandleScope handle_scope(isolate);\n    v8::Local<v8::Value> args[] = {v8::Boolean::New(isolate, succeeded)};\n    context_->CallFunction(v8::Local<v8::Function>::New(isolate, callback_),\n                           arraysize(args), args);\n     delete this;\n   }\n",
        "output": "1",
        "idx": 1995
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void TextTrack::addCue(TextTrackCue* cue) {\n   DCHECK(cue);\n \n  if (std::isnan(cue->startTime()) || std::isnan(cue->endTime()) ||\n      cue->startTime() < 0 || cue->endTime() < 0)\n     return;\n \n\n\n\n  if (TextTrack* cue_track = cue->track())\n    cue_track->removeCue(cue, ASSERT_NO_EXCEPTION);\n\n  cue->SetTrack(this);\n  EnsureTextTrackCueList()->Add(cue);\n\n  if (GetCueTimeline() && mode_ != DisabledKeyword())\n    GetCueTimeline()->AddCue(this, cue);\n}\n",
        "output": "1",
        "idx": 1475
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void locationWithCallWithAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n {\n     TestObjectPython* proxyImp = V8TestObjectPython::toNative(info.Holder());\n    TestNode* imp = WTF::getPtr(proxyImp->locationWithCallWith());\n     if (!imp)\n         return;\n     V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, cppValue, jsValue);\n    imp->setHrefCallWith(callingDOMWindow(info.GetIsolate()), enteredDOMWindow(info.GetIsolate()), cppValue);\n}\n",
        "output": "1",
        "idx": 612
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AutocompleteProvider::AddProviderInfo(\n    ProvidersInfo* provider_info) const {\n}\n",
        "output": "1",
        "idx": 1639
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void TestObjectConstructorGetter(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    v8::Handle<v8::Value> data = info.Data();\n    ASSERT(data->IsExternal());\n    V8PerContextData* perContextData = V8PerContextData::from(info.Holder()->CreationContext());\n    if (!perContextData)\n        return;\n    v8SetReturnValue(info, perContextData->constructorForType(WrapperTypeInfo::unwrap(data)));\n}\n",
        "output": "0",
        "idx": 1731
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vsock_enqueue_accept(struct sock *listener, struct sock *connected)\n{\n\tstruct vsock_sock *vlistener;\n\tstruct vsock_sock *vconnected;\n\n\tvlistener = vsock_sk(listener);\n\tvconnected = vsock_sk(connected);\n\n\tsock_hold(connected);\n\tsock_hold(listener);\n\tlist_add_tail(&vconnected->accept_queue, &vlistener->accept_queue);\n}\n",
        "output": "0",
        "idx": 1337
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "store_current_palette(png_store *ps, int *npalette)\n{\n /* This is an internal error (the call has been made outside a read\n\n     * operation.)\n     */\n    if (ps->current == NULL)\n       store_log(ps, ps->pread, \"no current stream for palette\", 1);\n \n    /* The result may be null if there is no palette. */\n    *npalette = ps->current->npalette;\n return ps->current->palette;\n}\n",
        "output": "1",
        "idx": 417
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    StateBase* writeBlob(v8::Handle<v8::Value> value, StateBase* next)\n    {\n        Blob* blob = V8Blob::toNative(value.As<v8::Object>());\n        if (!blob)\n            return 0;\n         if (blob->hasBeenClosed())\n             return handleError(DataCloneError, \"A Blob object has been closed, and could therefore not be cloned.\", next);\n         int blobIndex = -1;\n        m_blobDataHandles.add(blob->uuid(), blob->blobDataHandle());\n         if (appendBlobInfo(blob->uuid(), blob->type(), blob->size(), &blobIndex))\n             m_writer.writeBlobIndex(blobIndex);\n         else\n            m_writer.writeBlob(blob->uuid(), blob->type(), blob->size());\n        return 0;\n    }\n",
        "output": "1",
        "idx": 688
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ept_set_mmio_spte_mask(void)\n{\n\t/*\n\t * EPT Misconfigurations can be generated if the value of bits 2:0\n\t * of an EPT paging-structure entry is 110b (write/execute).\n\t * Also, magic bits (0x3ull << 62) is set to quickly identify mmio\n\t * spte.\n\t */\n\tkvm_mmu_set_mmio_spte_mask((0x3ull << 62) | 0x6ull);\n}\n",
        "output": "0",
        "idx": 787
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static int ohci_bus_start(OHCIState *ohci)\n {\n    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n                    ohci_frame_boundary,\n                    ohci);\n    if (ohci->eof_timer == NULL) {\n        trace_usb_ohci_bus_eof_timer_failed(ohci->name);\n        ohci_die(ohci);\n        return 0;\n    }\n     trace_usb_ohci_start(ohci->name);\n \n     /* Delay the first SOF event by one frame time as\n\n    if (ohci->eof_timer == NULL) {\n        trace_usb_ohci_bus_eof_timer_failed(ohci->name);\n        ohci_die(ohci);\n        return 0;\n    }\n\n    trace_usb_ohci_start(ohci->name);\n\n    /* Delay the first SOF event by one frame time as\n static void ohci_bus_stop(OHCIState *ohci)\n {\n     trace_usb_ohci_stop(ohci->name);\n    if (ohci->eof_timer) {\n        timer_del(ohci->eof_timer);\n        timer_free(ohci->eof_timer);\n    }\n    ohci->eof_timer = NULL;\n }\n \n /* Sets a flag in a port status register but only set it if the port is\n}\n",
        "output": "1",
        "idx": 633
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BrowserInit::LaunchWithProfile::~LaunchWithProfile() {\n}\n",
        "output": "0",
        "idx": 567
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned long ring_buffer_size(struct ring_buffer *buffer, int cpu)\n{\n\t/*\n\t * Earlier, this method returned\n\t *\tBUF_PAGE_SIZE * buffer->nr_pages\n\t * Since the nr_pages field is now removed, we have converted this to\n\t * return the per cpu buffer value.\n\t */\n\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\treturn 0;\n\n\treturn BUF_PAGE_SIZE * buffer->buffers[cpu]->nr_pages;\n}\n",
        "output": "0",
        "idx": 1432
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CSSStyleSheet* Document::createEmptyCSSStyleSheet(\n    ScriptState* script_state,\n    ExceptionState& exception_state) {\n  return Document::createEmptyCSSStyleSheet(\n      script_state, CSSStyleSheetInit::Create(), exception_state);\n}\n",
        "output": "0",
        "idx": 905
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void NetworkReaderProxy::OnGetContent(scoped_ptr<std::string> data) {\n   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));\n   DCHECK(data && !data->empty());\n \n   pending_data_.push_back(data.release());\n   if (!buffer_) {\n    return;\n  }\n\n  int result = ReadInternal(&pending_data_, buffer_.get(), buffer_length_);\n  remaining_content_length_ -= result;\n  DCHECK_GE(remaining_content_length_, 0);\n\n  buffer_ = NULL;\n  buffer_length_ = 0;\n  DCHECK(!callback_.is_null());\n  base::ResetAndReturn(&callback_).Run(result);\n}\n",
        "output": "1",
        "idx": 519
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int Browser::GetContentRestrictionsForSelectedTab() {\n  int content_restrictions = 0;\n  TabContents* current_tab = GetSelectedTabContents();\n  if (current_tab) {\n    content_restrictions = current_tab->content_restrictions();\n    NavigationEntry* active_entry = current_tab->controller().GetActiveEntry();\n    if (!SavePackage::IsSavableURL(active_entry ? active_entry->url() : GURL()))\n      content_restrictions |= CONTENT_RESTRICTION_SAVE;\n  }\n  return content_restrictions;\n}\n",
        "output": "0",
        "idx": 1626
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SplashOutputDev::clipToStrokePath(GfxState *state) {\n  SplashPath *path, *path2;\n\n  path = convertPath(state, state->getPath());\n  path2 = splash->makeStrokePath(path);\n  delete path;\n  splash->clipToPath(path2, gFalse);\n  delete path2;\n}\n",
        "output": "0",
        "idx": 2043
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void HandleMousePressEvent(int x, int y) {\n    WebMouseEvent event(\n        WebInputEvent::kMouseDown, WebFloatPoint(x, y), WebFloatPoint(x, y),\n        WebPointerProperties::Button::kLeft, 0,\n        WebInputEvent::Modifiers::kLeftButtonDown, CurrentTimeTicksInSeconds());\n    event.SetFrameScale(1);\n    GetEventHandler().HandleMousePressEvent(event);\n  }\n",
        "output": "0",
        "idx": 1030
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool AutofillDownloadManager::StartUploadRequest(\n    const FormStructure& form,\n    bool form_was_autofilled,\n    const FieldTypeSet& available_field_types) {\n  if (next_upload_request_ > base::Time::Now()) {\n    VLOG(1) << \"AutofillDownloadManager: Upload request is throttled.\";\n    return false;\n  }\n\n   double upload_rate = form_was_autofilled ? GetPositiveUploadRate() :\n                                              GetNegativeUploadRate();\n  if (base::RandDouble() > upload_rate) {\n     VLOG(1) << \"AutofillDownloadManager: Upload request is ignored.\";\n     return false;\n  }\n\n  std::string form_xml;\n  if (!form.EncodeUploadRequest(available_field_types, form_was_autofilled,\n                                &form_xml))\n    return false;\n\n  FormRequestData request_data;\n  request_data.form_signatures.push_back(form.FormSignature());\n  request_data.request_type = AutofillDownloadManager::REQUEST_UPLOAD;\n\n  return StartRequest(form_xml, request_data);\n}\n",
        "output": "1",
        "idx": 1273
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "freeimage(Image *image)\n{\n   freebuffer(image);\n   png_image_free(&image->image);\n\n if (image->input_file != NULL)\n {\n      fclose(image->input_file);\n      image->input_file = NULL;\n }\n\n if (image->input_memory != NULL)\n {\n      free(image->input_memory);\n      image->input_memory = NULL;\n      image->input_memory_size = 0;\n }\n\n \n    if (image->tmpfile_name[0] != 0 && (image->opts & KEEP_TMPFILES) == 0)\n    {\n      remove(image->tmpfile_name);\n       image->tmpfile_name[0] = 0;\n    }\n }\n",
        "output": "1",
        "idx": 1759
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PDFiumEngine::GetTextRunInfo(int page_index,\n                                  int start_char_index,\n                                  uint32_t* out_len,\n                                  double* out_font_size,\n                                  pp::FloatRect* out_bounds) {\n  DCHECK(PageIndexInBounds(page_index));\n  return pages_[page_index]->GetTextRunInfo(start_char_index, out_len,\n                                            out_font_size, out_bounds);\n}\n",
        "output": "0",
        "idx": 1086
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ThreadableBlobRegistry::registerBlobURL(SecurityOrigin* origin, const KURL& url, const KURL& srcURL)\n {\n     if (origin && BlobURL::getOrigin(url) == \"null\")\n         originMap()->add(url.string(), origin);\n \n    if (isMainThread())\n        blobRegistry().registerBlobURL(url, srcURL);\n    else {\n         OwnPtr<BlobRegistryContext> context = adoptPtr(new BlobRegistryContext(url, srcURL));\n         callOnMainThread(&registerBlobURLFromTask, context.leakPtr());\n     }\n}\n",
        "output": "1",
        "idx": 475
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool CanRendererHandleEvent(const ui::MouseEvent* event) {\n  if (event->type() == ui::ET_MOUSE_CAPTURE_CHANGED)\n    return false;\n\n#if defined(OS_WIN)\n  switch (event->native_event().message) {\n    case WM_XBUTTONDOWN:\n    case WM_XBUTTONUP:\n     case WM_XBUTTONDBLCLK:\n     case WM_NCMOUSELEAVE:\n     case WM_NCMOUSEMOVE:\n     case WM_NCXBUTTONDOWN:\n     case WM_NCXBUTTONUP:\n     case WM_NCXBUTTONDBLCLK:\n      return false;\n    default:\n      break;\n  }\n#endif\n  return true;\n}\n",
        "output": "1",
        "idx": 2063
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int handle_vmptrst(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t vmcs_gva;\n\tstruct x86_exception e;\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n \tif (get_vmx_mem_address(vcpu, exit_qualification,\n \t\t\tvmx_instruction_info, true, &vmcs_gva))\n \t\treturn 1;\n\t/* ok to use *_system, as hardware has verified cpl=0 */\n \tif (kvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, vmcs_gva,\n \t\t\t\t (void *)&to_vmx(vcpu)->nested.current_vmptr,\n \t\t\t\t sizeof(u64), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}\n",
        "output": "1",
        "idx": 2017
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "analyze_stack(int cpu, struct task_struct *task, unsigned long *stack,\n\t      unsigned long **stack_end, unsigned long *irq_stack,\n\t      unsigned *used, char **id)\n{\n\tunsigned long addr;\n\n\taddr = ((unsigned long)stack & (~(THREAD_SIZE - 1)));\n\tif ((unsigned long)task_stack_page(task) == addr)\n\t\treturn STACK_IS_NORMAL;\n\n\t*stack_end = in_exception_stack(cpu, (unsigned long)stack,\n\t\t\t\t\tused, id);\n\tif (*stack_end)\n\t\treturn STACK_IS_EXCEPTION;\n\n\tif (!irq_stack)\n\t\treturn STACK_IS_NORMAL;\n\n\t*stack_end = irq_stack;\n\tirq_stack = irq_stack - irq_stack_size;\n\n\tif (in_irq_stack(stack, irq_stack, *stack_end))\n\t\treturn STACK_IS_IRQ;\n\n\treturn STACK_IS_UNKNOWN;\n}\n",
        "output": "0",
        "idx": 790
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void FireInvalidateUnknownVersion(const char* type_name) {\n    const invalidation::ObjectId object_id(\n        ipc::invalidation::ObjectSource::CHROME_SYNC, type_name);\n    invalidation::AckHandle ack_handle(\"fakedata\");\n    EXPECT_CALL(mock_invalidation_client_, Acknowledge(ack_handle));\n    client_.InvalidateUnknownVersion(&mock_invalidation_client_, object_id,\n                                      ack_handle);\n   }\n",
        "output": "1",
        "idx": 641
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int udp6_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_printf(seq,\n\t\t\t   \"  sl  \"\n\t\t\t   \"local_address                         \"\n\t\t\t   \"remote_address                        \"\n\t\t\t   \"st tx_queue rx_queue tr tm->when retrnsmt\"\n\t\t\t   \"   uid  timeout inode ref pointer drops\\n\");\n\telse\n\t\tudp6_sock_seq_show(seq, v, ((struct udp_iter_state *)seq->private)->bucket);\n\treturn 0;\n}\n",
        "output": "0",
        "idx": 484
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual void TabMoved(\n      TabContentsWrapper* contents, int from_index, int to_index) {\n    State* s = new State(contents, to_index, MOVE);\n    s->src_index = from_index;\n    states_.push_back(s);\n  }\n",
        "output": "0",
        "idx": 205
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void put_unused_buffer(QEMUFile *f, void *pv, size_t size)\n{\n    static const uint8_t buf[1024];\n    int block_len;\n\n    while (size > 0) {\n        block_len = MIN(sizeof(buf), size);\n        size -= block_len;\n        qemu_put_buffer(f, buf, block_len);\n    }\n}\n",
        "output": "0",
        "idx": 1181
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int arcmsr_hbaA_handle_isr(struct AdapterControlBlock *acb)\n{\n\tuint32_t outbound_intstatus;\n\tstruct MessageUnit_A __iomem *reg = acb->pmuA;\n\toutbound_intstatus = readl(&reg->outbound_intstatus) &\n\t\tacb->outbound_int_enable;\n\tif (!(outbound_intstatus & ARCMSR_MU_OUTBOUND_HANDLE_INT))\n\t\treturn IRQ_NONE;\n\tdo {\n\t\twritel(outbound_intstatus, &reg->outbound_intstatus);\n\t\tif (outbound_intstatus & ARCMSR_MU_OUTBOUND_DOORBELL_INT)\n\t\t\tarcmsr_hbaA_doorbell_isr(acb);\n\t\tif (outbound_intstatus & ARCMSR_MU_OUTBOUND_POSTQUEUE_INT)\n\t\t\tarcmsr_hbaA_postqueue_isr(acb);\n\t\tif (outbound_intstatus & ARCMSR_MU_OUTBOUND_MESSAGE0_INT)\n\t\t\tarcmsr_hbaA_message_isr(acb);\n\t\toutbound_intstatus = readl(&reg->outbound_intstatus) &\n\t\t\tacb->outbound_int_enable;\n\t} while (outbound_intstatus & (ARCMSR_MU_OUTBOUND_DOORBELL_INT\n\t\t| ARCMSR_MU_OUTBOUND_POSTQUEUE_INT\n\t\t| ARCMSR_MU_OUTBOUND_MESSAGE0_INT));\n\treturn IRQ_HANDLED;\n}\n",
        "output": "0",
        "idx": 1421
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned int readuint(FILE * f, int bigendian)\n{\n    unsigned char c1, c2, c3, c4;\n    if (!fread(&c1, 1, 1, f)) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if (!fread(&c2, 1, 1, f)) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if (!fread(&c3, 1, 1, f)) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if (!fread(&c4, 1, 1, f)) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0;\n    }\n    if (bigendian) {\n        return (unsigned int)(c1 << 24) + (unsigned int)(c2 << 16) + (unsigned int)(\n                   c3 << 8) + c4;\n    } else {\n        return (unsigned int)(c4 << 24) + (unsigned int)(c3 << 16) + (unsigned int)(\n                   c2 << 8) + c1;\n    }\n}\n",
        "output": "0",
        "idx": 1407
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ssh_channelcmp(void *av, void *bv)\n{\n    struct ssh_channel *a = (struct ssh_channel *) av;\n    struct ssh_channel *b = (struct ssh_channel *) bv;\n    if (a->localid < b->localid)\n\treturn -1;\n    if (a->localid > b->localid)\n\treturn +1;\n    return 0;\n}\n",
        "output": "0",
        "idx": 371
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(\n     mojom::PaymentHandlerResponsePtr response) {\n  DCHECK(delegate_);\n   if (delegate_ != nullptr) {\n     delegate_->OnInstrumentDetailsReady(response->method_name,\n                                         response->stringified_details);\n    delegate_ = nullptr;\n  }\n}\n",
        "output": "1",
        "idx": 38
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " ServiceWorkerHandler::ServiceWorkerHandler()\n     : DevToolsDomainHandler(ServiceWorker::Metainfo::domainName),\n       enabled_(false),\n      process_(nullptr),\n       weak_factory_(this) {}\n",
        "output": "1",
        "idx": 323
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int BackendImpl::CheckAllEntries() {\n  int num_dirty = 0;\n  int num_entries = 0;\n  DCHECK(mask_ < std::numeric_limits<uint32_t>::max());\n  for (unsigned int i = 0; i <= mask_; i++) {\n    Addr address(data_->table[i]);\n    if (!address.is_initialized())\n      continue;\n    for (;;) {\n      scoped_refptr<EntryImpl> cache_entry;\n      int ret = NewEntry(address, &cache_entry);\n      if (ret) {\n        STRESS_NOTREACHED();\n        return ret;\n      }\n\n      if (cache_entry->dirty())\n        num_dirty++;\n      else if (CheckEntry(cache_entry.get()))\n        num_entries++;\n      else\n        return ERR_INVALID_ENTRY;\n\n      DCHECK_EQ(i, cache_entry->entry()->Data()->hash & mask_);\n      address.set_value(cache_entry->GetNextAddress());\n      if (!address.is_initialized())\n        break;\n    }\n  }\n\n  Trace(\"CheckAllEntries End\");\n  if (num_entries + num_dirty != data_->header.num_entries) {\n    LOG(ERROR) << \"Number of entries \" << num_entries << \" \" << num_dirty <<\n                  \" \" << data_->header.num_entries;\n    DCHECK_LT(num_entries, data_->header.num_entries);\n    return ERR_NUM_ENTRIES_MISMATCH;\n  }\n\n  return num_dirty;\n}\n",
        "output": "0",
        "idx": 1648
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Editor::ChangeSelectionAfterCommand(\n    const SelectionInDOMTree& new_selection,\n    const SetSelectionData& options) {\n  if (new_selection.IsNone())\n    return;\n\n   bool selection_did_not_change_dom_position =\n       new_selection == GetFrame().Selection().GetSelectionInDOMTree();\n   GetFrame().Selection().SetSelection(\n      SelectionInDOMTree::Builder(new_selection)\n          .SetIsHandleVisible(GetFrame().Selection().IsHandleVisible())\n          .Build(),\n      options);\n \n  if (selection_did_not_change_dom_position) {\n    Client().RespondToChangedSelection(\n        frame_, GetFrame().Selection().GetSelectionInDOMTree().Type());\n  }\n}\n",
        "output": "1",
        "idx": 1419
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool isUserInteractionEventForSlider(Event* event, LayoutObject* layoutObject) {\n  if (isUserInteractionEvent(event))\n    return true;\n\n  LayoutSliderItem slider = LayoutSliderItem(toLayoutSlider(layoutObject));\n  if (!slider.isNull() && !slider.inDragMode())\n    return false;\n \n   const AtomicString& type = event->type();\n   return type == EventTypeNames::mouseover ||\n         type == EventTypeNames::mouseout || type == EventTypeNames::mousemove;\n }\n",
        "output": "1",
        "idx": 427
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Textfield::SetColor(SkColor value) {\n  GetRenderText()->SetColor(value);\n  cursor_view_.layer()->SetColor(value);\n  SchedulePaint();\n}\n",
        "output": "0",
        "idx": 1858
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int collationMatch(const char *zColl, Index *pIndex){\n  int i;\n  assert( zColl!=0 );\n  for(i=0; i<pIndex->nColumn; i++){\n    const char *z = pIndex->azColl[i];\n    assert( z!=0 || pIndex->aiColumn[i]<0 );\n    if( pIndex->aiColumn[i]>=0 && 0==sqlite3StrICmp(z, zColl) ){\n      return 1;\n    }\n  }\n  return 0;\n}\n",
        "output": "0",
        "idx": 315
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\t\tvoid CWebServer::Cmd_GetAuth(WebEmSession & session, const request& req, Json::Value &root)\n\t\t{\n\t\t\troot[\"status\"] = \"OK\";\n\t\t\troot[\"title\"] = \"GetAuth\";\n\t\t\tif (session.rights != -1)\n\t\t\t{\n\t\t\t\troot[\"version\"] = szAppVersion;\n\t\t\t}\n\t\t\troot[\"user\"] = session.username;\n\t\t\troot[\"rights\"] = session.rights;\n\t\t}\n",
        "output": "0",
        "idx": 11
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mk_request_premature_close(int http_status, struct client_session *cs)\n{\n    struct session_request *sr;\n    struct mk_list *sr_list = &cs->request_list;\n    struct mk_list *host_list = &config->hosts;\n\n    /*\n     * If the connection is too premature, we need to allocate a temporal session_request\n     * to do not break the plugins stages\n     */\n    if (mk_list_is_empty(sr_list) == 0) {\n        sr = &cs->sr_fixed;\n        memset(sr, 0, sizeof(struct session_request));\n        mk_request_init(sr);\n        mk_list_add(&sr->_head, &cs->request_list);\n    }\n    else {\n        sr = mk_list_entry_first(sr_list, struct session_request, _head);\n    }\n\n    /* Raise error */\n    if (http_status > 0) {\n        if (!sr->host_conf) {\n            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);\n        }\n        mk_request_error(http_status, cs, sr);\n\n        /* STAGE_40, request has ended */\n        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, cs->socket,\n                            NULL, cs, sr);\n    }\n\n    /* STAGE_50, connection closed  and remove client_session*/\n    mk_plugin_stage_run(MK_PLUGIN_STAGE_50, cs->socket, NULL, NULL, NULL);\n    mk_session_remove(cs->socket);\n}\n",
        "output": "0",
        "idx": 1525
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool GLES2Decoder::GetServiceTextureId(uint32_t client_texture_id,\n                                       uint32_t* service_texture_id) {\n  return false;\n}\n",
        "output": "0",
        "idx": 95
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_timer_user_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tint err;\n\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n \t\treturn -ENOMEM;\n \tspin_lock_init(&tu->qlock);\n \tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->tread_sem);\n \ttu->ticks = 1;\n \ttu->queue_size = 128;\n \ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;\n}\n",
        "output": "1",
        "idx": 799
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int find_hole(void)\n{\n   unsigned x;\n   int      y, z;\n   for (z = -1, y = INT_MAX, x = 0; x < FP_ENTRIES; x++) {\n       if (fp_cache[x].lru_count < y && fp_cache[x].lock == 0) {\n          z = x;\n          y = fp_cache[x].lru_count;\n       }\n   }\n\n   /* decrease all */\n   for (x = 0; x < FP_ENTRIES; x++) {\n      if (fp_cache[x].lru_count > 3) {\n         --(fp_cache[x].lru_count);\n      }\n   }\n\n   /* free entry z */\n   if (z >= 0 && fp_cache[z].g) {\n      mp_clear(&fp_cache[z].mu);\n      wc_ecc_del_point(fp_cache[z].g);\n      fp_cache[z].g  = NULL;\n      for (x = 0; x < (1U<<FP_LUT); x++) {\n         wc_ecc_del_point(fp_cache[z].LUT[x]);\n         fp_cache[z].LUT[x] = NULL;\n      }\n      fp_cache[z].lru_count = 0;\n   }\n   return z;\n}\n",
        "output": "0",
        "idx": 990
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dispatchSimAuthentication(Parcel &p, RequestInfo *pRI)\n{\n    RIL_SimAuthentication pf;\n int32_t  t;\n status_t status;\n\n    memset(&pf, 0, sizeof(pf));\n\n    status = p.readInt32(&t);\n    pf.authContext = (int) t;\n    pf.authData = strdupReadString(p);\n    pf.aid = strdupReadString(p);\n\n    startRequest;\n    appendPrintBuf(\"authContext=%s, authData=%s, aid=%s\", pf.authContext, pf.authData, pf.aid);\n    closeRequest;\n    printRequest(pRI->token, pRI->pCI->requestNumber);\n\n if (status != NO_ERROR) {\n goto invalid;\n }\n    CALL_ONREQUEST(pRI->pCI->requestNumber, &pf, sizeof(pf), pRI, pRI->socket_id);\n\n#ifdef MEMSET_FREED\n    memsetString(pf.authData);\n    memsetString(pf.aid);\n#endif\n\n    free(pf.authData);\n    free(pf.aid);\n\n#ifdef MEMSET_FREED\n    memset(&pf, 0, sizeof(pf));\n#endif\n\n return;\ninvalid:\n    invalidCommandBlock(pRI);\n return;\n}\n",
        "output": "0",
        "idx": 1015
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " int __glXDispSwap_CreateContext(__GLXclientState *cl, GLbyte *pc)\n {\n     xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n \n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->context);\n     __GLX_SWAP_INT(&req->visual);\n    return __glXDisp_CreateContext(cl, pc);\n}\n",
        "output": "1",
        "idx": 495
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long Track::GetNumber() const\n{\n    return m_info.number;\n}\n",
        "output": "1",
        "idx": 261
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *val)\n{\n\tunsigned char buf[2];\n\tunsigned char ibuf[2];\n\n\ttuner_dbg(\"%s %04x called\\n\", __func__, reg);\n\n\tbuf[0] = reg >> 8;\n\tbuf[1] = (unsigned char) reg;\n\n\tif (i2c_send_recv(priv, buf, 2, ibuf, 2) != 2)\n\t\treturn -EIO;\n\n\t*val = (ibuf[1]) | (ibuf[0] << 8);\n\treturn 0;\n}\n",
        "output": "0",
        "idx": 982
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void RTCSessionDescriptionRequestImpl::requestFailed(const String& error)\n {\n     if (m_errorCallback)\n        m_errorCallback->handleEvent(error);\n \n     clear();\n }\n",
        "output": "1",
        "idx": 424
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline u64 __scale_tsc(u64 ratio, u64 tsc)\n{\n\treturn mul_u64_u64_shr(tsc, ratio, kvm_tsc_scaling_ratio_frac_bits);\n}\n",
        "output": "0",
        "idx": 622
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void SyncManager::SyncInternal::OnIPAddressChangedImpl() {\n   DCHECK(thread_checker_.CalledOnValidThread());\n  connection_manager()->CheckServerReachable();\n }\n",
        "output": "1",
        "idx": 1717
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void DidReceiveData(const char* buffer, int length, int data_offset) {\n    DCHECK(channel_ != NULL);\n    DCHECK_GT(length, 0);\n    std::vector<char> data;\n    data.resize(static_cast<size_t>(length));\n    memcpy(&data.front(), buffer, length);\n    scoped_refptr<PluginChannelHost> channel_ref(channel_);\n    channel_->Send(new PluginMsg_DidReceiveData(instance_id_, resource_id_,\n                                                data, data_offset));\n  }\n",
        "output": "0",
        "idx": 123
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "InterstitialPageImpl::~InterstitialPageImpl() {\n  frame_tree_.reset();\n}\n",
        "output": "0",
        "idx": 1191
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int verify_newpolicy_info(struct xfrm_userpolicy_info *p)\n{\n\tswitch (p->share) {\n\tcase XFRM_SHARE_ANY:\n\tcase XFRM_SHARE_SESSION:\n\tcase XFRM_SHARE_USER:\n\tcase XFRM_SHARE_UNIQUE:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (p->action) {\n\tcase XFRM_POLICY_ALLOW:\n\tcase XFRM_POLICY_BLOCK:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (p->sel.family) {\n\tcase AF_INET:\n\t\tbreak;\n\n\tcase AF_INET6:\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tbreak;\n#else\n\t\treturn  -EAFNOSUPPORT;\n#endif\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn verify_policy_dir(p->dir);\n}\n",
        "output": "0",
        "idx": 1109
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int setup_dev_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console)\n{\n\tchar path[MAXPATHLEN];\n\tstruct stat s;\n\tint ret;\n\n\tret = snprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\n\tif (access(path, F_OK)) {\n\t\tWARN(\"rootfs specified but no console found at '%s'\", path);\n\t\treturn 0;\n\t}\n\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\n\tif (stat(path, &s)) {\n\t\tSYSERROR(\"failed to stat '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif (chmod(console->name, s.st_mode)) {\n\t\tSYSERROR(\"failed to set mode '0%o' to '%s'\",\n\t\t\t s.st_mode, console->name);\n \t\treturn -1;\n \t}\n \n\tif (mount(console->name, path, \"none\", MS_BIND, 0)) {\n \t\tERROR(\"failed to mount '%s' on '%s'\", console->name, path);\n \t\treturn -1;\n \t}\n\n\tINFO(\"console has been setup\");\n\treturn 0;\n}\n",
        "output": "1",
        "idx": 515
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void WebPluginDelegateImpl::SendJavaScriptStream(const GURL& url,\n                                                  const std::string& result,\n                                                  bool success,\n                                                 bool notify_needed,\n                                                 intptr_t notify_data) {\n  instance()->SendJavaScriptStream(url, result, success, notify_needed,\n                                   notify_data);\n }\n",
        "output": "1",
        "idx": 1602
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline bool is_hsr_master(struct net_device *dev)\n{\n\treturn (dev->netdev_ops->ndo_start_xmit == hsr_dev_xmit);\n}\n",
        "output": "0",
        "idx": 891
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pdf_run_v(fz_context *ctx, pdf_processor *proc, float x2, float y2, float x3, float y3)\n{\n\tpdf_run_processor *pr = (pdf_run_processor *)proc;\n\tfz_curvetov(ctx, pr->path, x2, y2, x3, y3);\n}\n",
        "output": "0",
        "idx": 67
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t ib_uverbs_comp_event_read(struct file *filp, char __user *buf,\n\t\t\t\t\t size_t count, loff_t *pos)\n{\n\tstruct ib_uverbs_completion_event_file *comp_ev_file =\n\t\tfilp->private_data;\n\n\treturn ib_uverbs_event_read(&comp_ev_file->ev_queue,\n\t\t\t\t    comp_ev_file->uobj.ufile, filp,\n\t\t\t\t    buf, count, pos,\n\t\t\t\t    sizeof(struct ib_uverbs_comp_event_desc));\n}\n",
        "output": "0",
        "idx": 961
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "FFmpegVideoDecodeEngine::FFmpegVideoDecodeEngine()\n    : codec_context_(NULL),\n      event_handler_(NULL),\n      frame_rate_numerator_(0),\n      frame_rate_denominator_(0),\n      pending_input_buffers_(0),\n      pending_output_buffers_(0),\n      output_eos_reached_(false),\n      flush_pending_(false) {\n}\n",
        "output": "0",
        "idx": 1686
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual void SetUpCommandLine(CommandLine* command_line) {\n    GpuFeatureTest::SetUpCommandLine(command_line);\n    command_line->AppendSwitch(switches::kEnableThreadedCompositing);\n  }\n",
        "output": "1",
        "idx": 1966
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ReleaseProcessIfNeeded() {\n  content::UtilityThread::Get()->ReleaseProcessIfNeeded();\n}\n",
        "output": "0",
        "idx": 647
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RTCPeerConnection::setRemoteDescription(PassRefPtr<RTCSessionDescription> prpSessionDescription, PassRefPtr<VoidCallback> successCallback, PassRefPtr<RTCErrorCallback> errorCallback, ExceptionCode& ec)\n{\n    if (m_readyState == ReadyStateClosing || m_readyState == ReadyStateClosed) {\n        ec = INVALID_STATE_ERR;\n        return;\n    }\n    RefPtr<RTCSessionDescription> sessionDescription = prpSessionDescription;\n    if (!sessionDescription) {\n        ec = TYPE_MISMATCH_ERR;\n        return;\n    }\n    RefPtr<RTCVoidRequestImpl> request = RTCVoidRequestImpl::create(scriptExecutionContext(), successCallback, errorCallback);\n    m_peerHandler->setRemoteDescription(request.release(), sessionDescription->descriptor());\n}\n",
        "output": "1",
        "idx": 1371
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n\n \tif (flags & MSG_CMSG_COMPAT)\n \t\treturn -EINVAL;\n \n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT,\n\t\t\t\t      (struct timespec *) timeout);\n \tif (timeout == NULL)\n \t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n \t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n \n\tif (get_compat_timespec(&ktspec, timeout))\n \t\treturn -EFAULT;\n \n \tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n \t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n \t\tdatagrams = -EFAULT;\n \n \treturn datagrams;\n}\n",
        "output": "1",
        "idx": 473
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AppControllerImpl::LaunchApp(const std::string& app_id) {\n   app_service_proxy_->Launch(app_id, ui::EventFlags::EF_NONE,\n                              apps::mojom::LaunchSource::kFromAppListGrid,\n                              display::kDefaultDisplayId);\n }\n",
        "output": "1",
        "idx": 86
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_seq_device_dev_free(struct snd_device *device)\n {\n \tstruct snd_seq_device *dev = device->device_data;\n \n \tput_device(&dev->dev);\n \treturn 0;\n }\n",
        "output": "1",
        "idx": 1169
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ahci_restart(IDEDMA *dma)\n{\n    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);\n    int i;\n\n    for (i = 0; i < AHCI_MAX_CMDS; i++) {\n        NCQTransferState *ncq_tfs = &ad->ncq_tfs[i];\n        if (ncq_tfs->halt) {\n            execute_ncq_command(ncq_tfs);\n        }\n    }\n}\n",
        "output": "0",
        "idx": 1675
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool  PrintWebViewHelper::PrintPreviewContext::IsFinalPageRendered() const {\n  return static_cast<size_t>(current_page_index_) == pages_to_render_.size();\n}\n",
        "output": "0",
        "idx": 204
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dm_lock_md_type(struct mapped_device *md)\n{\n\tmutex_lock(&md->type_lock);\n}\n",
        "output": "0",
        "idx": 1038
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,\n\t\t\t    int *addr_len, int peer)\n{\n\tstruct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct hci_dev *hdev = hci_pi(sk)->hdev;\n\n\tBT_DBG(\"sock %p sk %p\", sock, sk);\n\n\tif (!hdev)\n\t\treturn -EBADFD;\n\n\tlock_sock(sk);\n\n \t*addr_len = sizeof(*haddr);\n \thaddr->hci_family = AF_BLUETOOTH;\n \thaddr->hci_dev    = hdev->id;\n \n \trelease_sock(sk);\n \treturn 0;\n}\n",
        "output": "1",
        "idx": 813
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void DraggedTabGtk::SetContainerColorMap() {\n  GdkScreen* screen = gtk_widget_get_screen(container_);\n  GdkColormap* colormap = gdk_screen_get_rgba_colormap(screen);\n\n  if (!colormap)\n    colormap = gdk_screen_get_rgb_colormap(screen);\n\n  gtk_widget_set_colormap(container_, colormap);\n}\n",
        "output": "0",
        "idx": 1584
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u64 vmac(unsigned char m[], unsigned int mbytes,\n\t\t\tconst unsigned char n[16], u64 *tagl,\n\t\t\tstruct vmac_ctx_t *ctx)\n{\n\tu64 *in_n, *out_p;\n\tu64 p, h;\n\tint i;\n\n\tin_n = ctx->__vmac_ctx.cached_nonce;\n\tout_p = ctx->__vmac_ctx.cached_aes;\n\n\ti = n[15] & 1;\n\tif ((*(u64 *)(n+8) != in_n[1]) || (*(u64 *)(n) != in_n[0])) {\n\t\tin_n[0] = *(u64 *)(n);\n\t\tin_n[1] = *(u64 *)(n+8);\n\t\t((unsigned char *)in_n)[15] &= 0xFE;\n\t\tcrypto_cipher_encrypt_one(ctx->child,\n\t\t\t(unsigned char *)out_p, (unsigned char *)in_n);\n\n\t\t((unsigned char *)in_n)[15] |= (unsigned char)(1-i);\n\t}\n\tp = be64_to_cpup(out_p + i);\n\th = vhash(m, mbytes, (u64 *)0, &ctx->__vmac_ctx);\n\treturn le64_to_cpu(p + h);\n}\n",
        "output": "0",
        "idx": 1843
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void jas_matrix_divpow2(jas_matrix_t *matrix, int n)\n {\n\tint i;\n\tint j;\n \tjas_seqent_t *rowstart;\n\tint rowstep;\n \tjas_seqent_t *data;\n \n \tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t*data = (*data >= 0) ? ((*data) >> n) :\n\t\t\t\t  (-((-(*data)) >> n));\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "output": "1",
        "idx": 2078
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Browser::IsPopup(const TabContents* source) const {\n  return !!(type() & TYPE_POPUP);\n}\n",
        "output": "0",
        "idx": 2058
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int shutdown_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\n\t/*\n\t * VMCB is undefined after a SHUTDOWN intercept\n\t * so reinitialize it.\n\t */\n\tclear_page(svm->vmcb);\n\tinit_vmcb(svm);\n\n\tkvm_run->exit_reason = KVM_EXIT_SHUTDOWN;\n\treturn 0;\n}\n",
        "output": "0",
        "idx": 1818
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   void AddSimpleRectChunk(TestPaintArtifact& artifact) {\n    artifact\n        .Chunk(TransformPaintPropertyNode::Root(),\n               ClipPaintPropertyNode::Root(), EffectPaintPropertyNode::Root())\n         .RectDrawing(FloatRect(100, 100, 200, 100), Color::kBlack);\n   }\n",
        "output": "1",
        "idx": 1051
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int xt_compat_check_entry_offsets(const void *base,\n \t\t\t\t  unsigned int target_offset,\n \t\t\t\t  unsigned int next_offset)\n {\n \tconst struct compat_xt_entry_target *t;\n \tconst char *e = base;\n \n \tif (target_offset + sizeof(*t) > next_offset)\n \t\treturn -EINVAL;\n \n\tt = (void *)(e + target_offset);\n\tif (t->u.target_size < sizeof(*t))\n\t\treturn -EINVAL;\n\n\tif (target_offset + t->u.target_size > next_offset)\n\t\treturn -EINVAL;\n\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&\n\t    target_offset + sizeof(struct compat_xt_standard_target) != next_offset)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n",
        "output": "1",
        "idx": 1677
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GahpClient::clear_pending()\n{\n\tif ( pending_reqid ) {\n\t\tif (server->requestTable->remove(pending_reqid) == 0) {\n\t\t\tserver->requestTable->insert(pending_reqid,NULL);\n\t\t}\n\t}\n\tpending_reqid = 0;\n\tif (pending_result) delete pending_result;\n\tpending_result = NULL;\n\tfree(pending_command);\n\tpending_command = NULL;\n\tif (pending_args) free(pending_args);\n\tpending_args = NULL;\n\tpending_timeout = 0;\n\tif (pending_submitted_to_gahp) {\n\t\tserver->num_pending_requests--;\n\t}\n\tpending_submitted_to_gahp = false;\n\tif ( pending_timeout_tid != -1 ) {\n\t\tdaemonCore->Cancel_Timer(pending_timeout_tid);\n\t\tpending_timeout_tid = -1;\n\t}\n}\n",
        "output": "0",
        "idx": 2093
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QQuickWebViewPrivate::~QQuickWebViewPrivate()\n{\n    webPageProxy->close();\n}\n",
        "output": "0",
        "idx": 335
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ep_rbtree_insert(struct eventpoll *ep, struct epitem *epi)\n{\n\tint kcmp;\n\tstruct rb_node **p = &ep->rbr.rb_node, *parent = NULL;\n\tstruct epitem *epic;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tepic = rb_entry(parent, struct epitem, rbn);\n\t\tkcmp = ep_cmp_ffd(&epi->ffd, &epic->ffd);\n\t\tif (kcmp > 0)\n\t\t\tp = &parent->rb_right;\n\t\telse\n\t\t\tp = &parent->rb_left;\n\t}\n\trb_link_node(&epi->rbn, parent, p);\n\trb_insert_color(&epi->rbn, &ep->rbr);\n}\n",
        "output": "0",
        "idx": 1797
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " image_transform_png_set_expand_16_add(image_transform *this,\n    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)\n {\n    UNUSED(colour_type)\n \n this->next = *that;\n *that = this;\n\n /* expand_16 does something unless the bit depth is already 16. */\n return bit_depth < 16;\n}\n",
        "output": "1",
        "idx": 341
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char* Track::GetLanguage() const\n{\n    return m_info.language;\n}\n",
        "output": "1",
        "idx": 117
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void CheckTMPrediction() const {\n for (int p = 0; p < num_planes_; p++)\n for (int y = 0; y < block_size_; y++)\n for (int x = 0; x < block_size_; x++) {\n const int expected = ClipByte(data_ptr_[p][x - stride_]\n + data_ptr_[p][stride_ * y - 1]\n - data_ptr_[p][-1 - stride_]);\n          ASSERT_EQ(expected, data_ptr_[p][y * stride_ + x]);\n }\n }\n",
        "output": "0",
        "idx": 1938
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SSLClientSocketOpenSSL::OnSendComplete(int result) {\n  if (next_handshake_state_ == STATE_HANDSHAKE) {\n    OnHandshakeIOComplete(result);\n    return;\n  }\n\n  int rv_read = ERR_IO_PENDING;\n  int rv_write = ERR_IO_PENDING;\n  bool network_moved;\n  do {\n    if (user_read_buf_.get())\n      rv_read = DoPayloadRead();\n    if (user_write_buf_.get())\n      rv_write = DoPayloadWrite();\n    network_moved = DoTransportIO();\n  } while (rv_read == ERR_IO_PENDING && rv_write == ERR_IO_PENDING &&\n           (user_read_buf_.get() || user_write_buf_.get()) && network_moved);\n\n  base::WeakPtr<SSLClientSocketOpenSSL> guard(weak_factory_.GetWeakPtr());\n  if (user_read_buf_.get() && rv_read != ERR_IO_PENDING)\n    DoReadCallback(rv_read);\n\n  if (!guard.get())\n    return;\n\n  if (user_write_buf_.get() && rv_write != ERR_IO_PENDING)\n    DoWriteCallback(rv_write);\n}\n",
        "output": "0",
        "idx": 1563
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AppControllerImpl::BindRequest(mojom::AppControllerRequest request) {\n   bindings_.AddBinding(this, std::move(request));\n }\n",
        "output": "1",
        "idx": 1620
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pgp_free_blob(pgp_blob_t *blob)\n{\n\tif (blob) {\n\t\tif (blob->parent) {\n\t\t\tpgp_blob_t **p;\n\n\t\t\t/* remove blob from list of parent's children */\n\t\t\tfor (p = &blob->parent->files; *p != NULL && *p != blob; p = &(*p)->next)\n\t\t\t\t;\n\t\t\tif (*p == blob)\n\t\t\t\t*p = blob->next;\n\t\t}\n\n\t\tsc_file_free(blob->file);\n\t\tif (blob->data)\n\t\t\tfree(blob->data);\n\t\tfree(blob);\n\t}\n}\n",
        "output": "0",
        "idx": 571
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rxrpc_destroy(struct key *key)\n{\n\trxrpc_free_token_list(key->payload.data);\n}\n",
        "output": "0",
        "idx": 842
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void BrowserPpapiHostImpl::DeleteInstance(PP_Instance instance) {\n   auto it = instance_map_.find(instance);\n  DCHECK(it != instance_map_.end());\n  for (auto& observer : it->second->observer_list)\n    observer.OnHostDestroyed();\n \n  instance_map_.erase(it);\n }\n",
        "output": "1",
        "idx": 1178
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned long klsi_105_status2linestate(const __u16 status)\n{\n\tunsigned long res = 0;\n\n\tres =   ((status & KL5KUSB105A_DSR) ? TIOCM_DSR : 0)\n\t      | ((status & KL5KUSB105A_CTS) ? TIOCM_CTS : 0)\n\t      ;\n\n\treturn res;\n}\n",
        "output": "0",
        "idx": 1358
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void SetMetrics(OomInterventionMetrics metrics) {\n    metrics_ = std::make_unique<OomInterventionMetrics>();\n    *metrics_ = metrics;\n  }\n",
        "output": "0",
        "idx": 563
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n {\n \tgdImagePtr pim = 0, tim = im;\n \tint interlace, BitsPerPixel;\n\tinterlace = im->interlace;\n\tif (im->trueColor) {\n\t\t/* Expensive, but the only way that produces an\n\t\t\tacceptable result: mix down to a palette\n \t\t\tbased temporary image. */\n \t\tpim = gdImageCreatePaletteFromTrueColor(im, 1, 256);\n \t\tif (!pim) {\n\t\t\treturn;\n \t\t}\n \t\ttim = pim;\n \t}\n\tBitsPerPixel = colorstobpp(tim->colorsTotal);\n\t/* All set, let's do it. */\n\tGIFEncode(\n\t\tout, tim->sx, tim->sy, tim->interlace, 0, tim->transparent, BitsPerPixel,\n\t\ttim->red, tim->green, tim->blue, tim);\n\tif (pim) {\n \t\t/* Destroy palette based temporary image. */\n \t\tgdImageDestroy(\tpim);\n \t}\n }\n",
        "output": "1",
        "idx": 1770
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " e1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r)\n {\n    return core->mac[r->dh] == core->mac[r->dt];\n }\n",
        "output": "1",
        "idx": 948
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ipgre_tap_setup(struct net_device *dev)\n{\n\n\tether_setup(dev);\n\n\tdev->netdev_ops\t\t= &ipgre_tap_netdev_ops;\n\tdev->destructor \t= ipgre_dev_free;\n\n\tdev->iflink\t\t= 0;\n\tdev->features\t\t|= NETIF_F_NETNS_LOCAL;\n}\n",
        "output": "0",
        "idx": 343
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int tls1_set_server_sigalgs(SSL *s)\n{\n    int al;\n    size_t i;\n    /* Clear any shared sigtnature algorithms */\n     if (s->cert->shared_sigalgs) {\n         OPENSSL_free(s->cert->shared_sigalgs);\n         s->cert->shared_sigalgs = NULL;\n     }\n     /* Clear certificate digests and validity flags */\n     for (i = 0; i < SSL_PKEY_NUM; i++) {\n        s->cert->pkeys[i].valid_flags = 0;\n    }\n\n    /* If sigalgs received process it. */\n    if (s->cert->peer_sigalgs) {\n        if (!tls1_process_sigalgs(s)) {\n            SSLerr(SSL_F_TLS1_SET_SERVER_SIGALGS, ERR_R_MALLOC_FAILURE);\n            al = SSL_AD_INTERNAL_ERROR;\n            goto err;\n        }\n        /* Fatal error is no shared signature algorithms */\n        if (!s->cert->shared_sigalgs) {\n            SSLerr(SSL_F_TLS1_SET_SERVER_SIGALGS,\n                   SSL_R_NO_SHARED_SIGATURE_ALGORITHMS);\n            al = SSL_AD_ILLEGAL_PARAMETER;\n            goto err;\n        }\n    } else\n        ssl_cert_set_default_md(s->cert);\n    return 1;\n err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    return 0;\n}\n",
        "output": "1",
        "idx": 1053
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void enforcedRangeByteAttrAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    ExceptionState exceptionState(ExceptionState::SetterContext, \"enforcedRangeByteAttr\", \"TestObject\", info.Holder(), info.GetIsolate());\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt8(jsValue, EnforceRange, exceptionState), exceptionState);\n    imp->setEnforcedRangeByteAttr(cppValue);\n}\n",
        "output": "0",
        "idx": 1021
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void lsi_bad_selection(LSIState *s, uint32_t id)\n{\n    trace_lsi_bad_selection(id);\n    lsi_script_scsi_interrupt(s, 0, LSI_SIST1_STO);\n    lsi_disconnect(s);\n}\n",
        "output": "0",
        "idx": 1522
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FragmentPaintPropertyTreeBuilder::UpdateFragmentClip() {\n  DCHECK(properties_);\n\n   if (NeedsPaintPropertyUpdate()) {\n     if (context_.fragment_clip) {\n       OnUpdateClip(properties_->UpdateFragmentClip(\n          context_.current.clip,\n           ClipPaintPropertyNode::State{context_.current.transform,\n                                        ToClipRect(*context_.fragment_clip)}));\n     } else {\n      OnClearClip(properties_->ClearFragmentClip());\n    }\n  }\n\n  if (properties_->FragmentClip())\n    context_.current.clip = properties_->FragmentClip();\n}\n",
        "output": "1",
        "idx": 71
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " SPL_METHOD(SplFileObject, getMaxLineLen)\n {\n \tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n \tif (zend_parse_parameters_none() == FAILURE) {\n \t\treturn;\n \t}\n\n\tRETURN_LONG((long)intern->u.file.max_line_len);\n} /* }}} */\n\n/* {{{ proto bool SplFileObject::hasChildren()\n",
        "output": "1",
        "idx": 570
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Document* LocalDOMWindow::InstallNewDocument(const String& mime_type,\n                                             const DocumentInit& init,\n                                             bool force_xhtml) {\n  DCHECK_EQ(init.GetFrame(), GetFrame());\n\n  ClearDocument();\n\n  document_ = CreateDocument(mime_type, init, force_xhtml);\n  event_queue_ = DOMWindowEventQueue::Create(document_.Get());\n  document_->Initialize();\n\n  if (!GetFrame())\n    return document_;\n\n  GetFrame()->GetScriptController().UpdateDocument();\n  document_->UpdateViewportDescription();\n\n  if (GetFrame()->GetPage() && GetFrame()->View()) {\n    GetFrame()->GetPage()->GetChromeClient().InstallSupplements(*GetFrame());\n\n    if (ScrollingCoordinator* scrolling_coordinator =\n            GetFrame()->GetPage()->GetScrollingCoordinator()) {\n      scrolling_coordinator->ScrollableAreaScrollbarLayerDidChange(\n          GetFrame()->View(), kHorizontalScrollbar);\n      scrolling_coordinator->ScrollableAreaScrollbarLayerDidChange(\n          GetFrame()->View(), kVerticalScrollbar);\n      scrolling_coordinator->ScrollableAreaScrollLayerDidChange(\n          GetFrame()->View());\n     }\n   }\n \n  GetFrame()->Selection().UpdateSecureKeyboardEntryIfActive();\n   if (GetFrame()->IsCrossOriginSubframe())\n     document_->RecordDeferredLoadReason(WouldLoadReason::kCreated);\n \n  return document_;\n}\n",
        "output": "1",
        "idx": 938
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void svc_rdma_destroy_maps(struct svcxprt_rdma *xprt)\n{\n\twhile (!list_empty(&xprt->sc_maps)) {\n\t\tstruct svc_rdma_req_map *map;\n\t\tmap = list_first_entry(&xprt->sc_maps,\n\t\t\t\t       struct svc_rdma_req_map, free);\n\t\tlist_del(&map->free);\n\t\tkfree(map);\n\t}\n}\n",
        "output": "1",
        "idx": 1655
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void* JSArray::subclassData() const\n{\n    return m_storage->subclassData;\n}\n",
        "output": "0",
        "idx": 461
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameDevToolsAgentHost::InspectElement(\n    DevToolsSession* session,\n    int x,\n    int y) {\n\n  if (frame_tree_node_) {\n    if (auto* main_view =\n            frame_tree_node_->frame_tree()->GetMainFrame()->GetView()) {\n      gfx::Point transformed_point = gfx::ToRoundedPoint(\n          main_view->TransformRootPointToViewCoordSpace(gfx::PointF(x, y)));\n      x = transformed_point.x();\n      y = transformed_point.y();\n    }\n  }\n\n  session->InspectElement(gfx::Point(x, y));\n}\n",
        "output": "0",
        "idx": 48
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void bnep_net_setup(struct net_device *dev)\n{\n\n\tmemset(dev->broadcast, 0xff, ETH_ALEN);\n \tdev->addr_len = ETH_ALEN;\n \n \tether_setup(dev);\n \tdev->netdev_ops = &bnep_netdev_ops;\n \n \tdev->watchdog_timeo  = HZ * 2;\n}\n",
        "output": "1",
        "idx": 723
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WorkerThread::shutdown()\n{\n    ASSERT(isCurrentThread());\n    {\n        MutexLocker lock(m_threadStateMutex);\n        ASSERT(!m_shutdown);\n        m_shutdown = true;\n    }\n\n    PlatformThreadData::current().threadTimers().setSharedTimer(nullptr);\n    workerGlobalScope()->dispose();\n    willDestroyIsolate();\n\n    workerReportingProxy().willDestroyWorkerGlobalScope();\n\n#if !ENABLE(OILPAN)\n    ASSERT(m_workerGlobalScope->hasOneRef());\n#endif\n    m_workerGlobalScope->notifyContextDestroyed();\n    m_workerGlobalScope = nullptr;\n\n    backingThread().removeTaskObserver(m_microtaskRunner.get());\n    backingThread().shutdown();\n    destroyIsolate();\n\n    m_microtaskRunner = nullptr;\n\n    workerReportingProxy().workerThreadTerminated();\n\n    m_terminationEvent->signal();\n\n    PlatformThreadData::current().destroy();\n}\n",
        "output": "0",
        "idx": 547
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WebContents* TabsCaptureVisibleTabFunction::GetWebContentsForID(\n    int window_id,\n    std::string* error) {\n  Browser* browser = NULL;\n  if (!GetBrowserFromWindowID(chrome_details_, window_id, &browser, error))\n    return nullptr;\n\n  WebContents* contents = browser->tab_strip_model()->GetActiveWebContents();\n  if (!contents) {\n    *error = \"No active web contents to capture\";\n    return nullptr;\n  }\n \n   if (!extension()->permissions_data()->CanCaptureVisiblePage(\n           contents->GetLastCommittedURL(),\n          SessionTabHelper::IdForTab(contents).id(), error)) {\n     return nullptr;\n   }\n   return contents;\n}\n",
        "output": "1",
        "idx": 1322
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n {\n \tunsigned char *buf;\n \n\tassert(bufsize >= 0);\n \n\tJAS_DBGLOG(100, (\"mem_resize(%p, %d)\\n\", m, bufsize));\n \tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n \t  bufsize) {\n \t\tJAS_DBGLOG(100, (\"mem_resize realloc failed\\n\"));\n\t\treturn -1;\n\t}\n\tJAS_DBGLOG(100, (\"mem_resize realloc succeeded\\n\"));\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}\n",
        "output": "1",
        "idx": 862
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )\n{\n    SQLWCHAR *chr;\n    int len = 0;\n \n     if ( !in )\n     {\n        return in;\n     }\n     \n     while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;\n    }\n\n    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));\n\n    len = 0;\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        chr[ len ] = in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = 0;\n    chr[ len ++ ] = 0;\n\n    return chr;\n}\n",
        "output": "1",
        "idx": 132
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "INST_HANDLER (sleep) {\t// SLEEP\n\tESIL_A (\"BREAK\");\n}\n",
        "output": "0",
        "idx": 2042
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual void SetImePropertyActivated(const std::string& key,\n                                       bool activated) {\n    if (!initialized_successfully_)\n       return;\n \n     DCHECK(!key.empty());\n    chromeos::SetImePropertyActivated(\n        input_method_status_connection_, key.c_str(), activated);\n   }\n",
        "output": "1",
        "idx": 279
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long long BlockGroup::GetNextTimeCode() const\n{\n    return m_next;\n}\n",
        "output": "1",
        "idx": 1449
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void InspectorResourceAgent::frameScheduledNavigation(Frame* frame, double)\n{\n    RefPtr<TypeBuilder::Network::Initiator> initiator = buildInitiatorObject(frame->document(), FetchInitiatorInfo());\n    m_frameNavigationInitiatorMap.set(m_pageAgent->frameId(frame), initiator);\n}\n",
        "output": "0",
        "idx": 404
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_zip_cdir_new(int nentry, struct zip_error *error)\n{\n    struct zip_cdir *cd;\n    \n    if ((cd=(struct zip_cdir *)malloc(sizeof(*cd))) == NULL) {\n\t_zip_error_set(error, ZIP_ER_MEMORY, 0);\n        return NULL;\n     }\n \n    if ((cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*nentry))\n        == NULL) {\n        _zip_error_set(error, ZIP_ER_MEMORY, 0);\n        free(cd);\n\treturn NULL;\n    }\n\n    /* entries must be initialized by caller */\n\n    cd->nentry = nentry;\n    cd->size = cd->offset = 0;\n    cd->comment = NULL;\n    cd->comment_len = 0;\n\n    return cd;\n}\n",
        "output": "1",
        "idx": 576
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct sctp_association *sctp_id2assoc(struct sock *sk, sctp_assoc_t id)\n{\n\tstruct sctp_association *asoc = NULL;\n\n\t/* If this is not a UDP-style socket, assoc id should be ignored. */\n\tif (!sctp_style(sk, UDP)) {\n\t\t/* Return NULL if the socket state is not ESTABLISHED. It\n\t\t * could be a TCP-style listening socket or a socket which\n\t\t * hasn't yet called connect() to establish an association.\n\t\t */\n\t\tif (!sctp_sstate(sk, ESTABLISHED) && !sctp_sstate(sk, CLOSING))\n\t\t\treturn NULL;\n\n\t\t/* Get the first and the only association from the list. */\n\t\tif (!list_empty(&sctp_sk(sk)->ep->asocs))\n\t\t\tasoc = list_entry(sctp_sk(sk)->ep->asocs.next,\n\t\t\t\t\t  struct sctp_association, asocs);\n\t\treturn asoc;\n\t}\n\n\t/* Otherwise this is a UDP-style socket. */\n\tif (!id || (id == (sctp_assoc_t)-1))\n\t\treturn NULL;\n\n\tspin_lock_bh(&sctp_assocs_id_lock);\n\tasoc = (struct sctp_association *)idr_find(&sctp_assocs_id, (int)id);\n\tspin_unlock_bh(&sctp_assocs_id_lock);\n\n\tif (!asoc || (asoc->base.sk != sk) || asoc->base.dead)\n\t\treturn NULL;\n\n\treturn asoc;\n}\n",
        "output": "0",
        "idx": 1551
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int proc_control_compat(struct usb_dev_state *ps,\n\t\t\t\tstruct usbdevfs_ctrltransfer32 __user *p32)\n{\n\tstruct usbdevfs_ctrltransfer __user *p;\n\t__u32 udata;\n\tp = compat_alloc_user_space(sizeof(*p));\n\tif (copy_in_user(p, p32, (sizeof(*p32) - sizeof(compat_caddr_t))) ||\n\t    get_user(udata, &p32->data) ||\n\t    put_user(compat_ptr(udata), &p->data))\n\t\treturn -EFAULT;\n\treturn proc_control(ps, p);\n}\n",
        "output": "0",
        "idx": 789
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void* NPN_GetJavaEnv() {\n  DLOG(INFO) << \"NPN_GetJavaEnv is not implemented.\";\n  return NULL;\n}\n",
        "output": "0",
        "idx": 1771
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static int hns_xgmac_get_sset_count(int stringset)\n {\n\tif (stringset == ETH_SS_STATS)\n \t\treturn ARRAY_SIZE(g_xgmac_stats_string);\n \n \treturn 0;\n}\n",
        "output": "1",
        "idx": 488
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(imagecopyresampled)\n{\n\tzval *SIM, *DIM;\n\tlong SX, SY, SW, SH, DX, DY, DW, DH;\n\tgdImagePtr im_dst, im_src;\n\tint srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rrllllllll\", &DIM, &SIM, &DX, &DY, &SX, &SY, &DW, &DH, &SW, &SH) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, \"Image\", le_gd);\n\tZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, \"Image\", le_gd);\n\n\tsrcX = SX;\n\tsrcY = SY;\n\tsrcH = SH;\n\tsrcW = SW;\n\tdstX = DX;\n\tdstY = DY;\n\tdstH = DH;\n\tdstW = DW;\n\n\tgdImageCopyResampled(im_dst, im_src, dstX, dstY, srcX, srcY, dstW, dstH, srcW, srcH);\n\n\tRETURN_TRUE;\n}\n",
        "output": "0",
        "idx": 524
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* buffer, size_t length)\n {\n }\n",
        "output": "1",
        "idx": 944
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void FragmentPaintPropertyTreeBuilder::UpdateClipPathClip(\n    bool spv1_compositing_specific_pass) {\n  bool is_spv1_composited =\n      object_.HasLayer() &&\n      ToLayoutBoxModelObject(object_).Layer()->GetCompositedLayerMapping();\n  if (is_spv1_composited != spv1_compositing_specific_pass)\n    return;\n\n  if (NeedsPaintPropertyUpdate()) {\n    if (!NeedsClipPathClip(object_)) {\n      OnClearClip(properties_->ClearClipPathClip());\n    } else {\n      ClipPaintPropertyNode::State state;\n      state.local_transform_space = context_.current.transform;\n       state.clip_rect =\n           FloatRoundedRect(FloatRect(*fragment_data_.ClipPathBoundingBox()));\n       state.clip_path = fragment_data_.ClipPathPath();\n      OnUpdateClip(properties_->UpdateClipPathClip(context_.current.clip,\n                                                    std::move(state)));\n     }\n   }\n\n  if (properties_->ClipPathClip() && !spv1_compositing_specific_pass) {\n    context_.current.clip = context_.absolute_position.clip =\n        context_.fixed_position.clip = properties_->ClipPathClip();\n  }\n}\n",
        "output": "1",
        "idx": 1222
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {\n        int r;\n\n        assert(p);\n        assert(key);\n\n        /* Checks if the specified packet is a reply for the specified\n         * key and the specified key is the only one in the question\n         * section. */\n\n        if (DNS_PACKET_QR(p) != 1)\n                return 0;\n\n        /* Let's unpack the packet, if that hasn't happened yet. */\n        r = dns_packet_extract(p);\n         if (r < 0)\n                 return r;\n \n         if (p->question->n_keys != 1)\n                 return 0;\n \n        return dns_resource_key_equal(p->question->keys[0], key);\n}\n",
        "output": "1",
        "idx": 208
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int rt_scope(int ifa_scope)\n{\n\tif (ifa_scope & IFA_HOST)\n\t\treturn RT_SCOPE_HOST;\n\telse if (ifa_scope & IFA_LINK)\n\t\treturn RT_SCOPE_LINK;\n\telse if (ifa_scope & IFA_SITE)\n\t\treturn RT_SCOPE_SITE;\n\telse\n\t\treturn RT_SCOPE_UNIVERSE;\n}\n",
        "output": "0",
        "idx": 1564
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void* ipc_alloc(int size)\n {\n\tvoid* out;\n \tif(size > PAGE_SIZE)\n \t\tout = vmalloc(size);\n \telse\n\t\tout = kmalloc(size, GFP_KERNEL);\n\treturn out;\n}\n",
        "output": "1",
        "idx": 1440
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_rx_flow_off(struct caifsock *cf_sk)\n{\n\t clear_bit(RX_FLOW_ON_BIT,\n\t\t (void *) &cf_sk->flow_state);\n}\n",
        "output": "0",
        "idx": 721
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void close_table_device(struct table_device *td, struct mapped_device *md)\n{\n\tif (!td->dm_dev.bdev)\n\t\treturn;\n\n\tbd_unlink_disk_holder(td->dm_dev.bdev, dm_disk(md));\n\tblkdev_put(td->dm_dev.bdev, td->dm_dev.mode | FMODE_EXCL);\n\tput_dax(td->dm_dev.dax_dev);\n\ttd->dm_dev.bdev = NULL;\n\ttd->dm_dev.dax_dev = NULL;\n}\n",
        "output": "0",
        "idx": 586
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void EmbeddedWorkerContextClient::OnSendMessageToWorker(\n     int thread_id,\n     int embedded_worker_id,\n    int request_id,\n    const IPC::Message& message) {\n  if (!script_context_)\n    return;\n  DCHECK_EQ(embedded_worker_id_, embedded_worker_id);\n  script_context_->OnMessageReceived(request_id, message);\n}\n",
        "output": "0",
        "idx": 1061
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HeapAllocator::backingFree(void* address) {\n  if (!address)\n    return;\n\n  ThreadState* state = ThreadState::current();\n  if (state->sweepForbidden())\n    return;\n  ASSERT(!state->isInGC());\n\n  BasePage* page = pageFromObject(address);\n  if (page->isLargeObjectPage() || page->arena()->getThreadState() != state)\n     return;\n \n   HeapObjectHeader* header = HeapObjectHeader::fromPayload(address);\n  ASSERT(header->checkHeader());\n   NormalPageArena* arena = static_cast<NormalPage*>(page)->arenaForNormalPage();\n   state->promptlyFreed(header->gcInfoIndex());\n   arena->promptlyFreeObject(header);\n}\n",
        "output": "1",
        "idx": 921
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "scoped_refptr<PrintBackend> PrintBackend::CreateInstance(\n    const base::DictionaryValue* print_backend_settings) {\n  return new PrintBackendWin;\n}\n",
        "output": "0",
        "idx": 415
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void copy_asoundrc(void) {\n\tchar *src = RUN_ASOUNDRC_FILE ;\n \tchar *dest;\n \tif (asprintf(&dest, \"%s/.asoundrc\", cfg.homedir) == -1)\n \t\terrExit(\"asprintf\");\n \tif (is_link(dest)) {\n \t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", dest);\n \t\texit(1);\n \t}\n \n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\tdrop_privs(0);\n\t\tint rv = copy_file(src, dest);\n\t\tif (rv)\n\t\t\tfprintf(stderr, \"Warning: cannot transfer .asoundrc in private home directory\\n\");\n\t\telse {\n\t\t\tfs_logger2(\"clone\", dest);\n\t\t}\n\t\t_exit(0);\n\t}\n\twaitpid(child, NULL, 0);\n\tif (chown(dest, getuid(), getgid()) < 0)\n\t\terrExit(\"chown\");\n\tif (chmod(dest, S_IRUSR | S_IWUSR) < 0)\n\t\terrExit(\"chmod\");\n \n \tunlink(src);\n}\n",
        "output": "1",
        "idx": 1046
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)\n {\n     if (!enabled()) {\n         NOTREACHED();\n         return v8::Null(m_isolate);\n     }\n     v8::Local<v8::Value> argv[] = { object };\n     v8::Local<v8::Value> location = callDebuggerMethod(\"getGeneratorObjectLocation\", 1, argv).ToLocalChecked();\n    if (!location->IsObject())\n         return v8::Null(m_isolate);\n    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);\n    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))\n         return v8::Null(m_isolate);\n    return location;\n }\n",
        "output": "1",
        "idx": 1829
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool AsyncPixelTransfersCompletedQuery::End(\n    base::subtle::Atomic32 submit_count) {\n  AsyncMemoryParams mem_params;\n  Buffer buffer = manager()->decoder()->GetSharedMemoryBuffer(shm_id());\n  if (!buffer.shared_memory)\n    return false;\n  mem_params.shared_memory = buffer.shared_memory;\n   mem_params.shm_size = buffer.size;\n   mem_params.shm_data_offset = shm_offset();\n   mem_params.shm_data_size = sizeof(QuerySync);\n \n   observer_ = new AsyncPixelTransferCompletionObserverImpl(submit_count);\n \n  manager()->decoder()->GetAsyncPixelTransferManager()\n      ->AsyncNotifyCompletion(mem_params, observer_);\n\n  return AddToPendingTransferQueue(submit_count);\n}\n",
        "output": "1",
        "idx": 394
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "AP_DECLARE(int) ap_some_auth_required(request_rec *r)\n{\n    /* Is there a require line configured for the type of *this* req? */\n    if (ap__authz_ap_some_auth_required) {\n        return ap__authz_ap_some_auth_required(r);\n    }\n    else\n        return 0;\n}\n",
        "output": "0",
        "idx": 363
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " PageInfoUI::IdentityInfo::IdentityInfo()\n     : identity_status(PageInfo::SITE_IDENTITY_STATUS_UNKNOWN),\n      safe_browsing_status(PageInfo::SAFE_BROWSING_STATUS_NONE),\n       connection_status(PageInfo::SITE_CONNECTION_STATUS_UNKNOWN),\n       show_ssl_decision_revoke_button(false),\n       show_change_password_buttons(false) {}\n",
        "output": "1",
        "idx": 620
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_1_6_dummy(kadm5_principal_ent_t entry, long mask,\n                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)\n{\n    int i;\n     char *password = *passptr;\n \n     /* Old-style randkey operations disallowed tickets to start. */\n    if (!(mask & KADM5_ATTRIBUTES) ||\n         !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))\n         return;\n \n    /* The 1.6 dummy password was the octets 1..255. */\n    for (i = 0; (unsigned char) password[i] == i + 1; i++);\n    if (password[i] != '\\0' || i != 255)\n        return;\n\n    /* This will make the caller use a random password instead. */\n    *passptr = NULL;\n}\n",
        "output": "1",
        "idx": 1760
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " bool ClipboardUtil::HasFilenames(IDataObject* data_object) {\n   DCHECK(data_object);\n  return HasData(data_object, Clipboard::GetCFHDropFormatType());\n }\n",
        "output": "1",
        "idx": 458
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API int r_flag_rename(RFlag *f, RFlagItem *item, const char *name) {\n\tif (!f || !item || !name || !*name) {\n\t\treturn false;\n\t}\n#if 0\n\tut64 off = item->offset;\n\tint size = item->size;\n\tr_flag_unset (f, item);\n\tr_flag_set (f, name, off, size);\n\treturn true;\n#else\n\tht_delete (f->ht_name, item->name);\n\tif (!set_name (item, name)) {\n\t\treturn false;\n\t}\n\tht_insert (f->ht_name, item->name, item);\n#endif\n\treturn true;\n}\n",
        "output": "0",
        "idx": 909
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  _bdf_list_join( _bdf_list_t*    list,\n                  int             c,\n                  unsigned long  *alen )\n  {\n    unsigned long  i, j;\n    char           *fp, *dp;\n\n\n    *alen = 0;\n\n    if ( list == 0 || list->used == 0 )\n      return 0;\n\n    dp = list->field[0];\n    for ( i = j = 0; i < list->used; i++ )\n    {\n      fp = list->field[i];\n      while ( *fp )\n        dp[j++] = *fp++;\n\n      if ( i + 1 < list->used )\n        dp[j++] = (char)c;\n    }\n    if ( dp != empty )\n      dp[j] = 0;\n\n    *alen = j;\n    return dp;\n  }\n",
        "output": "0",
        "idx": 719
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  static void UpdatePropertyCallback(IBusPanelService* panel,\n                                     IBusProperty* ibus_prop,\n                                     gpointer user_data) {\n    g_return_if_fail(user_data);\n    InputMethodStatusConnection* self\n        = static_cast<InputMethodStatusConnection*>(user_data);\n    self->UpdateProperty(ibus_prop);\n   }\n",
        "output": "1",
        "idx": 98
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void CheckMaybeActivateDataReductionProxy(bool initially_enabled,\n                                            bool request_succeeded,\n                                            bool expected_enabled,\n                                            bool expected_restricted,\n                                            bool expected_fallback_restricted) {\n    test_context_->SetDataReductionProxyEnabled(initially_enabled);\n    test_context_->config()->UpdateConfigForTesting(initially_enabled,\n                                                    request_succeeded, true);\n    ExpectSetProxyPrefs(expected_enabled, false);\n     settings_->MaybeActivateDataReductionProxy(false);\n     test_context_->RunUntilIdle();\n   }\n",
        "output": "0",
        "idx": 324
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __meminit __add_zone(struct zone *zone, unsigned long phys_start_pfn)\n{\n\tstruct pglist_data *pgdat = zone->zone_pgdat;\n\tint nr_pages = PAGES_PER_SECTION;\n\tint nid = pgdat->node_id;\n\tint zone_type;\n\tunsigned long flags;\n\n\tzone_type = zone - pgdat->node_zones;\n\tif (!zone->wait_table) {\n\t\tint ret;\n\n\t\tret = init_currently_empty_zone(zone, phys_start_pfn,\n\t\t\t\t\t\tnr_pages, MEMMAP_HOTPLUG);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tpgdat_resize_lock(zone->zone_pgdat, &flags);\n\tgrow_zone_span(zone, phys_start_pfn, phys_start_pfn + nr_pages);\n\tgrow_pgdat_span(zone->zone_pgdat, phys_start_pfn,\n\t\t\tphys_start_pfn + nr_pages);\n\tpgdat_resize_unlock(zone->zone_pgdat, &flags);\n\tmemmap_init_zone(nr_pages, nid, zone_type,\n\t\t\t phys_start_pfn, MEMMAP_HOTPLUG);\n\treturn 0;\n}\n",
        "output": "0",
        "idx": 333
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  explicit TestWindowObserver(aura::Window* window_to_observe)\n      : window_(window_to_observe) {\n    window_->AddObserver(this);\n  }\n",
        "output": "0",
        "idx": 972
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int x509_check_wildcard( const char *cn, mbedtls_x509_buf *name )\n{\n    size_t i;\n    size_t cn_idx = 0, cn_len = strlen( cn );\n\n    if( name->len < 3 || name->p[0] != '*' || name->p[1] != '.' )\n        return( 0 );\n\n    for( i = 0; i < cn_len; ++i )\n    {\n        if( cn[i] == '.' )\n        {\n            cn_idx = i;\n            break;\n        }\n    }\n\n    if( cn_idx == 0 )\n        return( -1 );\n\n    if( cn_len - cn_idx == name->len - 1 &&\n        x509_memcasecmp( name->p + 1, cn + cn_idx, name->len - 1 ) == 0 )\n    {\n        return( 0 );\n    }\n\n    return( -1 );\n}\n",
        "output": "0",
        "idx": 1750
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n {\n \tint start = 0;\n \tu32 prev_legacy, cur_legacy;\n \tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n \tprev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tcur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tif (!prev_legacy && cur_legacy)\n\t\tstart = 1;\n \tmemcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,\n \t       sizeof(kvm->arch.vpit->pit_state.channels));\n \tkvm->arch.vpit->pit_state.flags = ps->flags;\n\tkvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);\n \tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n \treturn 0;\n }\n",
        "output": "1",
        "idx": 803
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " bool ChildProcessSecurityPolicyImpl::CanSetAsOriginHeader(int child_id,\n                                                           const GURL& url) {\n   if (!url.is_valid())\n    return false;  // Can't set invalid URLs as origin headers.\n\n  if (url == kAboutSrcDocURL)\n    return false;\n \n  if (CanCommitURL(child_id, url))\n     return true;\n \n  {\n    base::AutoLock lock(lock_);\n    if (base::ContainsKey(schemes_okay_to_appear_as_origin_headers_,\n                          url.scheme())) {\n      return true;\n    }\n  }\n  return false;\n}\n",
        "output": "1",
        "idx": 658
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " PP_Bool LaunchSelLdr(PP_Instance instance,\n                     const char* alleged_url,\n                     int socket_count,\n                      void* imc_handles) {\n   std::vector<nacl::FileDescriptor> sockets;\n   IPC::Sender* sender = content::RenderThread::Get();\n   if (sender == NULL)\n     sender = g_background_thread_sender.Pointer()->get();\n \n  IPC::ChannelHandle channel_handle;\n   if (!sender->Send(new ChromeViewHostMsg_LaunchNaCl(\n          GURL(alleged_url), socket_count, &sockets,\n          &channel_handle))) {\n     return PP_FALSE;\n  }\n  bool invalid_handle = channel_handle.name.empty();\n#if defined(OS_POSIX)\n  if (!invalid_handle)\n    invalid_handle = (channel_handle.socket.fd == -1);\n#endif\n  if (!invalid_handle)\n    g_channel_handle_map.Get()[instance] = channel_handle;\n \n   CHECK(static_cast<int>(sockets.size()) == socket_count);\n   for (int i = 0; i < socket_count; i++) {\n    static_cast<nacl::Handle*>(imc_handles)[i] =\n        nacl::ToNativeHandle(sockets[i]);\n  }\n\n   return PP_TRUE;\n }\n",
        "output": "1",
        "idx": 161
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "acpi_os_create_cache(char *name, u16 size, u16 depth, acpi_cache_t ** cache)\n{\n\t*cache = kmem_cache_create(name, size, 0, 0, NULL);\n\tif (*cache == NULL)\n\t\treturn AE_ERROR;\n\telse\n\t\treturn AE_OK;\n}\n",
        "output": "0",
        "idx": 896
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int muscle_card_extract_key(sc_card_t *card, sc_cardctl_muscle_key_info_t *info)\n{\n\t/* CURRENTLY DONT SUPPORT EXTRACTING PRIVATE KEYS... */\n\tswitch(info->keyType) {\n\tcase 1: /* RSA */\n\t\treturn msc_extract_rsa_public_key(card,\n\t\t\tinfo->keyLocation,\n\t\t\t&info->modLength,\n\t\t\t&info->modValue,\n\t\t\t&info->expLength,\n\t\t\t&info->expValue);\n\tdefault:\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\t}\n}\n",
        "output": "0",
        "idx": 1805
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool xmp_init()\n{\n     RESET_ERROR;\n     try {\n         bool result = SXMPFiles::Initialize(kXMPFiles_IgnoreLocalText);\n         SXMPMeta::SetDefaultErrorCallback(&_xmp_error_callback, nullptr, 1);\n         return result;\n        SXMPMeta::SetDefaultErrorCallback(&_xmp_error_callback, nullptr, 1);\n        return result;\n    }\n    catch (const XMP_Error &e) {\n        set_error(e);\n    }\n    return false;\n}\n",
        "output": "1",
        "idx": 160
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "blink::WebPlugin* RenderFrameImpl::CreatePlugin(\n    const blink::WebPluginParams& params) {\n  blink::WebPlugin* plugin = nullptr;\n  if (GetContentClient()->renderer()->OverrideCreatePlugin(this, params,\n                                                           &plugin)) {\n    return plugin;\n  }\n\n  if (params.mime_type.ContainsOnlyASCII() &&\n      params.mime_type.Ascii() == kBrowserPluginMimeType) {\n    BrowserPluginDelegate* delegate =\n        GetContentClient()->renderer()->CreateBrowserPluginDelegate(\n            this, WebPluginInfo(), kBrowserPluginMimeType, GURL(params.url));\n    return BrowserPluginManager::Get()->CreateBrowserPlugin(\n        this, delegate->GetWeakPtr());\n  }\n\n#if BUILDFLAG(ENABLE_PLUGINS)\n  WebPluginInfo info;\n  std::string mime_type;\n  bool found = false;\n  Send(new FrameHostMsg_GetPluginInfo(\n      routing_id_, params.url, frame_->Top()->GetSecurityOrigin(),\n      params.mime_type.Utf8(), &found, &info, &mime_type));\n  if (!found)\n    return nullptr;\n\n  WebPluginParams params_to_use = params;\n  params_to_use.mime_type = WebString::FromUTF8(mime_type);\n  return CreatePlugin(info, params_to_use, nullptr /* throttler */);\n#else\n  return nullptr;\n#endif  // BUILDFLAG(ENABLE_PLUGINS)\n}\n",
        "output": "0",
        "idx": 2044
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void SSLManager::OnSSLCertificateError(\n    base::WeakPtr<SSLErrorHandler::Delegate> delegate,\n     const content::GlobalRequestID& id,\n     const ResourceType::Type resource_type,\n     const GURL& url,\n    int render_process_id,\n    int render_view_id,\n    const net::SSLInfo& ssl_info,\n    bool fatal) {\n  DCHECK(delegate);\n  DVLOG(1) << \"OnSSLCertificateError() cert_error: \"\n           << net::MapCertStatusToNetError(ssl_info.cert_status)\n           << \" id: \" << id.child_id << \",\" << id.request_id\n           << \" resource_type: \" << resource_type\n           << \" url: \" << url.spec()\n           << \" render_process_id: \" << render_process_id\n           << \" render_view_id: \" << render_view_id\n           << \" cert_status: \" << std::hex << ssl_info.cert_status;\n\n  BrowserThread::PostTask(\n      BrowserThread::UI, FROM_HERE,\n      base::Bind(&SSLCertErrorHandler::Dispatch,\n                 new SSLCertErrorHandler(delegate,\n                                         id,\n                                         resource_type,\n                                         url,\n                                         render_process_id,\n                                         render_view_id,\n                                         ssl_info,\n                                         fatal)));\n}\n",
        "output": "1",
        "idx": 1657
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CloseFds(const std::vector<int>& fds) {\n  for (const auto& it : fds) {\n    PCHECK(0 == IGNORE_EINTR(close(it)));\n  }\n}\n",
        "output": "0",
        "idx": 1833
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "krb5_gss_process_context_token(minor_status, context_handle,\n                               token_buffer)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t token_buffer;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 majerr;\n \n     ctx = (krb5_gss_ctx_id_t) context_handle;\n \n    if (! ctx->established) {\n         *minor_status = KG_CTX_INCOMPLETE;\n         return(GSS_S_NO_CONTEXT);\n     }\n \n     /* \"unseal\" the token */\n \n     if (GSS_ERROR(majerr = kg_unseal(minor_status, context_handle,\n                                     token_buffer,\n                                     GSS_C_NO_BUFFER, NULL, NULL,\n                                      KG_TOK_DEL_CTX)))\n         return(majerr);\n \n    /* that's it.  delete the context */\n    return(krb5_gss_delete_sec_context(minor_status, &context_handle,\n                                       GSS_C_NO_BUFFER));\n }\n",
        "output": "1",
        "idx": 594
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void die_if_data_is_missing(GHashTable *problem_info)\n{\n    gboolean missing_data = FALSE;\n    gchar **pstring;\n    static const gchar *const needed[] = {\n        FILENAME_TYPE,\n        FILENAME_REASON,\n        /* FILENAME_BACKTRACE, - ECC errors have no such elements */\n        /* FILENAME_EXECUTABLE, */\n        NULL\n    };\n\n    for (pstring = (gchar**) needed; *pstring; pstring++)\n    {\n        if (!g_hash_table_lookup(problem_info, *pstring))\n        {\n            error_msg(\"Element '%s' is missing\", *pstring);\n            missing_data = TRUE;\n        }\n    }\n\n    if (missing_data)\n        error_msg_and_die(\"Some data is missing, aborting\");\n}\n",
        "output": "0",
        "idx": 1430
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_control(png_const_structrp png_ptr)\n{\n\n    /* This just returns the (file*).  The chunk and idat control structures\n     * don't always exist.\n     */\n   struct control *control = png_voidcast(struct control*,\n       png_get_error_ptr(png_ptr));\n    return &control->file;\n }\n",
        "output": "1",
        "idx": 1346
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int adjust_insn_aux_data(struct bpf_verifier_env *env, u32 prog_len,\n\t\t\t\tu32 off, u32 cnt)\n{\n\tstruct bpf_insn_aux_data *new_data, *old_data = env->insn_aux_data;\n\n\tif (cnt == 1)\n\t\treturn 0;\n\tnew_data = vzalloc(sizeof(struct bpf_insn_aux_data) * prog_len);\n\tif (!new_data)\n\t\treturn -ENOMEM;\n\tmemcpy(new_data, old_data, sizeof(struct bpf_insn_aux_data) * off);\n\tmemcpy(new_data + off + cnt - 1, old_data + off,\n\t       sizeof(struct bpf_insn_aux_data) * (prog_len - off - cnt + 1));\n\tenv->insn_aux_data = new_data;\n\tvfree(old_data);\n\treturn 0;\n}\n",
        "output": "0",
        "idx": 952
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AXObject::tokenVectorFromAttribute(Vector<String>& tokens,\n                                        const QualifiedName& attribute) const {\n  Node* node = this->getNode();\n  if (!node || !node->isElementNode())\n    return;\n\n  String attributeValue = getAttribute(attribute).getString();\n  if (attributeValue.isEmpty())\n    return;\n\n  attributeValue.simplifyWhiteSpace();\n  attributeValue.split(' ', tokens);\n}\n",
        "output": "0",
        "idx": 607
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "v8::Handle<v8::Value> V8Proxy::throwNotEnoughArgumentsError()\n {\n    return throwError(TypeError, \"Not enough arguments\");\n }\n",
        "output": "1",
        "idx": 1396
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void QuotaManager::GetUsageAndQuotaForEviction(\n    const GetUsageAndQuotaForEvictionCallback& callback) {\n  DCHECK(io_thread_->BelongsToCurrentThread());\n  GetUsageAndQuotaInternal(\n      GURL(), kStorageTypeTemporary, true /* global */, callback);\n}\n",
        "output": "0",
        "idx": 522
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dbus_object_create_path_vrrp(void)\n{\n\treturn g_strconcat(DBUS_VRRP_OBJECT_ROOT,\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t  global_data->network_namespace ? \"/\" : \"\", global_data->network_namespace ? global_data->network_namespace : \"\",\n#endif\n\t\t\t  global_data->instance_name ? \"/\" : \"\", global_data->instance_name ? global_data->instance_name : \"\",\n\n\t\t\t  \"/Vrrp\", NULL);\n}\n",
        "output": "0",
        "idx": 998
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void CachingPermutedEntropyProvider::RegisterPrefs(\n     PrefRegistrySimple* registry) {\n  registry->RegisterStringPref(prefs::kVariationsPermutedEntropyCache,\n                               std::string());\n }\n",
        "output": "1",
        "idx": 1912
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ContentSecurityPolicy::usesStyleHashAlgorithms(uint8_t algorithms) {\n  m_styleHashAlgorithmsUsed |= algorithms;\n}\n",
        "output": "0",
        "idx": 2082
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(gdImagePtr) gdImageCreateFromWebpPtr (int size, void *data)\n{\n\tgdImagePtr im;\n\tgdIOCtx *in = gdNewDynamicCtxEx(size, data, 0);\n\tif (!in)\n\t\treturn 0;\n\tim = gdImageCreateFromWebpCtx(in);\n\tin->gd_free(in);\n\treturn im;\n}\n",
        "output": "0",
        "idx": 591
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = NULL;\n\n    if ((object == NULL) || (name == NULL))\n    {\n        return NULL;\n    }\n\n     current_element = object->child;\n     if (case_sensitive)\n     {\n        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))\n         {\n             current_element = current_element->next;\n         }\n    }\n    else\n    {\n        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))\n        {\n            current_element = current_element->next;\n         }\n     }\n \n     return current_element;\n }\n",
        "output": "1",
        "idx": 1972
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ewk_view_scroll(Evas_Object* ewkView, Evas_Coord deltaX, Evas_Coord deltaY, Evas_Coord scrollX, Evas_Coord scrollY, Evas_Coord scrollWidth, Evas_Coord scrollHeight, Evas_Coord centerX, Evas_Coord centerY, Evas_Coord centerWidth, Evas_Coord centerHeight, bool mainFrame)\n{\n    DBG(\"ewkView=%p, delta: %d,%d, scroll: %d,%d+%dx%d, clip: %d,%d+%dx%d\",\n        ewkView, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);\n\n    if ((scrollX != centerX) || (scrollY != centerY) || (scrollWidth != centerWidth) || (scrollHeight != centerHeight))\n        WRN(\"scroll region and clip are different! %d,%d+%dx%d and %d,%d+%dx%d\",\n            scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);\n\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv);\n    EINA_SAFETY_ON_TRUE_RETURN(!deltaX && !deltaY);\n\n    _ewk_view_scroll_add(priv, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, mainFrame);\n\n    _ewk_view_smart_changed(smartData);\n}\n",
        "output": "0",
        "idx": 1362
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::wstring GetChromeChannelName() {\n  return InstallDetails::Get().channel();\n}\n",
        "output": "0",
        "idx": 1130
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int TabStripModel::GetIndexOfTabContents(\n    const TabContentsWrapper* contents) const {\n  int index = 0;\n  TabContentsDataVector::const_iterator iter = contents_data_.begin();\n  for (; iter != contents_data_.end(); ++iter, ++index) {\n    if ((*iter)->contents == contents)\n      return index;\n  }\n  return kNoTab;\n}\n",
        "output": "0",
        "idx": 1864
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ResourceMessageFilter::OnClipboardIsFormatAvailable(\n    Clipboard::FormatType format, Clipboard::Buffer buffer,\n    IPC::Message* reply) {\n  const bool result = GetClipboard()->IsFormatAvailable(format, buffer);\n  ViewHostMsg_ClipboardIsFormatAvailable::WriteReplyParams(reply, result);\n  Send(reply);\n}\n",
        "output": "0",
        "idx": 553
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char *string_of_NPNVariable(int variable)\n{\n  const char *str;\n\n  switch (variable) {\n#define _(VAL) case VAL: str = #VAL; break;\n\t_(NPNVxDisplay);\n\t_(NPNVxtAppContext);\n\t_(NPNVnetscapeWindow);\n\t_(NPNVjavascriptEnabledBool);\n\t_(NPNVasdEnabledBool);\n\t_(NPNVisOfflineBool);\n\t_(NPNVserviceManager);\n\t_(NPNVDOMElement);\n\t_(NPNVDOMWindow);\n\t_(NPNVToolkit);\n\t_(NPNVSupportsXEmbedBool);\n \t_(NPNVWindowNPObject);\n \t_(NPNVPluginElementNPObject);\n \t_(NPNVSupportsWindowless);\n #undef _\n   default:\n \tswitch (variable & 0xff) {\n#define _(VAL, VAR) case VAL: str = #VAR; break\n\t  _(10, NPNVserviceManager);\n\t  _(11, NPNVDOMElement);\n\t  _(12, NPNVDOMWindow);\n\t  _(13, NPNVToolkit);\n#undef _\n\tdefault:\n\t  str = \"<unknown variable>\";\n\t  break;\n\t}\n\tbreak;\n  }\n\n  return str;\n}\n",
        "output": "1",
        "idx": 468
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long futex_wait_restart(struct restart_block *restart)\n{\n\tu32 __user *uaddr = (u32 __user *)restart->futex.uaddr;\n\tint fshared = 0;\n\tktime_t t, *tp = NULL;\n\n\tif (restart->futex.flags & FLAGS_HAS_TIMEOUT) {\n\t\tt.tv64 = restart->futex.time;\n\t\ttp = &t;\n\t}\n\trestart->fn = do_no_restart_syscall;\n\tif (restart->futex.flags & FLAGS_SHARED)\n\t\tfshared = 1;\n\treturn (long)futex_wait(uaddr, fshared, restart->futex.val, tp,\n\t\t\t\trestart->futex.bitset,\n\t\t\t\trestart->futex.flags & FLAGS_CLOCKRT);\n}\n",
        "output": "0",
        "idx": 1713
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SyncBackendHost::HandleConnectionStatusChangeOnFrontendLoop(\n    sync_api::ConnectionStatus status) {\n  if (!frontend_)\n    return;\n\n  DCHECK_EQ(MessageLoop::current(), frontend_loop_);\n\n  frontend_->OnConnectionStatusChange(status);\n}\n",
        "output": "0",
        "idx": 432
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {\n  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();\n  if (!compositor->InCompositingMode())\n    return;\n\n  if (UsesCompositedScrolling()) {\n     DCHECK(Layer()->HasCompositedLayerMapping());\n     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();\n     bool handled_scroll =\n        Layer()->IsRootLayer() && scrolling_coordinator &&\n         scrolling_coordinator->UpdateCompositedScrollOffset(this);\n \n     if (!handled_scroll) {\n      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {\n        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(\n            kGraphicsLayerUpdateSubtree);\n      }\n      compositor->SetNeedsCompositingUpdate(\n          kCompositingUpdateAfterGeometryChange);\n    }\n\n    if (Layer()->IsRootLayer()) {\n      LocalFrame* frame = GetLayoutBox()->GetFrame();\n      if (frame && frame->View() &&\n          frame->View()->HasViewportConstrainedObjects()) {\n        Layer()->SetNeedsCompositingInputsUpdate();\n      }\n    }\n  } else {\n    Layer()->SetNeedsCompositingInputsUpdate();\n  }\n}\n",
        "output": "1",
        "idx": 1384
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cfundecs(JF, js_Ast *list)\n{\n\twhile (list) {\n\t\tjs_Ast *stm = list->a;\n\t\tif (stm->type == AST_FUNDEC) {\n\t\t\temitline(J, F, stm);\n\t\t\temitfunction(J, F, newfun(J, stm->line, stm->a, stm->b, stm->c, 0, F->strict));\n\t\t\temitline(J, F, stm);\n\t\t\temit(J, F, OP_SETLOCAL);\n\t\t\temitarg(J, F, addlocal(J, F, stm->a, 0));\n\t\t\temit(J, F, OP_POP);\n\t\t}\n\t\tlist = list->b;\n\t}\n}\n",
        "output": "0",
        "idx": 1580
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dev_get_valid_name(struct net *net, const char *name, char *buf,\n\t\t\t      bool fmt)\n{\n\tif (!dev_valid_name(name))\n\t\treturn -EINVAL;\n\n\tif (fmt && strchr(name, '%'))\n\t\treturn __dev_alloc_name(net, name, buf);\n\telse if (__dev_get_by_name(net, name))\n\t\treturn -EEXIST;\n\telse if (buf != name)\n\t\tstrlcpy(buf, name, IFNAMSIZ);\n\n\treturn 0;\n}\n",
        "output": "0",
        "idx": 1161
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void InspectorOverlay::update()\n{\n    if (isEmpty()) {\n        m_client->hideHighlight();\n        return;\n    }\n\n    FrameView* view = m_page->mainFrame()->view();\n    if (!view)\n        return;\n    IntRect viewRect = view->visibleContentRect();\n    FrameView* overlayView = overlayPage()->mainFrame()->view();\n\n    IntSize frameViewFullSize = view->visibleContentRect(ScrollableArea::IncludeScrollbars).size();\n    IntSize size = m_size.isEmpty() ? frameViewFullSize : m_size;\n    size.scale(m_page->pageScaleFactor());\n    overlayView->resize(size);\n\n    reset(size, m_size.isEmpty() ? IntSize() : frameViewFullSize, viewRect.x(), viewRect.y());\n\n    drawGutter();\n    drawNodeHighlight();\n    drawQuadHighlight();\n     if (!m_inspectModeEnabled)\n         drawPausedInDebuggerMessage();\n     drawViewSize();\n    drawOverridesMessage();\n \n     overlayPage()->mainFrame()->document()->recalcStyle(Force);\n    if (overlayView->needsLayout())\n        overlayView->layout();\n\n    m_client->highlight();\n}\n",
        "output": "1",
        "idx": 1025
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebContentsImpl::OnDidDownloadImage(\n    int id,\n    int http_status_code,\n    const GURL& image_url,\n    int requested_size,\n    const std::vector<SkBitmap>& bitmaps) {\n  ImageDownloadMap::iterator iter = image_download_map_.find(id);\n  if (iter == image_download_map_.end()) {\n    return;\n  }\n  if (!iter->second.is_null()) {\n    iter->second.Run(id, http_status_code, image_url, requested_size, bitmaps);\n  }\n  image_download_map_.erase(id);\n}\n",
        "output": "0",
        "idx": 377
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " bool IsTraceEventArgsWhitelisted(const char* category_group_name,\n                                 const char* event_name) {\n   if (base::MatchPattern(category_group_name, \"toplevel\") &&\n       base::MatchPattern(event_name, \"*\")) {\n     return true;\n   }\n \n   return false;\n }\n",
        "output": "1",
        "idx": 1739
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " PassRefPtr<DocumentFragment> Range::createContextualFragment(const String& markup, ExceptionCode& ec)\n {\n     if (!m_start.container()) {\n        ec = INVALID_STATE_ERR;\n        return 0;\n    }\n\n    Node* element = m_start.container()->isElementNode() ? m_start.container() : m_start.container()->parentNode();\n    if (!element || !element->isHTMLElement()) {\n        ec = NOT_SUPPORTED_ERR;\n         return 0;\n     }\n \n    RefPtr<DocumentFragment> fragment = createDocumentFragmentForElement(markup, toElement(element), AllowScriptingContentAndDoNotMarkAlreadyStarted);\n \n     if (!fragment) {\n         ec = NOT_SUPPORTED_ERR;\n        return 0;\n    }\n\n    return fragment.release();\n}\n",
        "output": "1",
        "idx": 365
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint32 PluginInstance::ScheduleTimer(uint32 interval,\n                                     NPBool repeat,\n                                     void (*func)(NPP id, uint32 timer_id)) {\n  uint32 timer_id;\n  timer_id = next_timer_id_;\n  ++next_timer_id_;\n  DCHECK(next_timer_id_ != 0);\n\n  TimerInfo info;\n  info.interval = interval;\n  info.repeat = repeat;\n   timers_[timer_id] = info;\n \n  message_loop_->PostDelayedTask(FROM_HERE,\n                                 NewRunnableMethod(this,\n                                                   &PluginInstance::OnTimerCall,\n                                                   func,\n                                                   npp_,\n                                                   timer_id),\n                                 interval);\n   return timer_id;\n }\n",
        "output": "1",
        "idx": 289
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)\n{\n\tstruct keydata *keyptr = get_keyptr();\n\tu32 hash[4];\n\t/*\n\t *  Pick a unique starting offset for each ephemeral port search\n\t *  (saddr, daddr, dport) and 48bits of random data.\n\t */\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = (__force u32)dport ^ keyptr->secret[10];\n\thash[3] = keyptr->secret[11];\n\treturn half_md4_transform(hash, keyptr->secret);\n}\n",
        "output": "1",
        "idx": 1280
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int import_iovec(int type, const struct iovec __user * uvector,\n\t\t unsigned nr_segs, unsigned fast_segs,\n\t\t struct iovec **iov, struct iov_iter *i)\n{\n\tssize_t n;\n\tstruct iovec *p;\n\tn = rw_copy_check_uvector(type, uvector, nr_segs, fast_segs,\n\t\t\t\t  *iov, &p);\n\tif (n < 0) {\n\t\tif (p != *iov)\n\t\t\tkfree(p);\n\t\t*iov = NULL;\n\t\treturn n;\n\t}\n\tiov_iter_init(i, type, p, nr_segs, n);\n\t*iov = p == *iov ? NULL : p;\n\treturn 0;\n}\n",
        "output": "0",
        "idx": 1081
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SampleTable::SampleTable(const sp<DataSource> &source)\n : mDataSource(source),\n      mChunkOffsetOffset(-1),\n      mChunkOffsetType(0),\n      mNumChunkOffsets(0),\n      mSampleToChunkOffset(-1),\n      mNumSampleToChunkOffsets(0),\n      mSampleSizeOffset(-1),\n\n       mSampleSizeFieldSize(0),\n       mDefaultSampleSize(0),\n       mNumSampleSizes(0),\n       mTimeToSampleCount(0),\n       mTimeToSample(),\n       mSampleTimeEntries(NULL),\n      mCompositionTimeDeltaEntries(NULL),\n      mNumCompositionTimeDeltaEntries(0),\n      mCompositionDeltaLookup(new CompositionDeltaLookup),\n      mSyncSampleOffset(-1),\n      mNumSyncSamples(0),\n      mSyncSamples(NULL),\n      mLastSyncSampleIndex(0),\n      mSampleToChunkEntries(NULL) {\n    mSampleIterator = new SampleIterator(this);\n}\n",
        "output": "1",
        "idx": 296
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void ChromeContentRendererClient::RenderViewCreated(RenderView* render_view) {\n   ContentSettingsObserver* content_settings =\n       new ContentSettingsObserver(render_view);\n  new DevToolsAgent(render_view);\n   new ExtensionHelper(render_view, extension_dispatcher_.get());\n   new PageLoadHistograms(render_view, histogram_snapshots_.get());\n   new PrintWebViewHelper(render_view);\n  new SearchBox(render_view);\n  new SpellCheckProvider(render_view, spellcheck_.get());\n#if defined(ENABLE_SAFE_BROWSING)\n  safe_browsing::MalwareDOMDetails::Create(render_view);\n#endif\n\n#if defined(OS_MACOSX)\n  new TextInputClientObserver(render_view);\n#endif  // defined(OS_MACOSX)\n\n  PasswordAutofillManager* password_autofill_manager =\n      new PasswordAutofillManager(render_view);\n  AutofillAgent* autofill_agent = new AutofillAgent(render_view,\n                                                    password_autofill_manager);\n  PageClickTracker* page_click_tracker = new PageClickTracker(render_view);\n  page_click_tracker->AddListener(password_autofill_manager);\n  page_click_tracker->AddListener(autofill_agent);\n\n  TranslateHelper* translate = new TranslateHelper(render_view, autofill_agent);\n  new ChromeRenderViewObserver(\n      render_view, content_settings, extension_dispatcher_.get(), translate);\n\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kDomAutomationController)) {\n    new AutomationRendererHelper(render_view);\n  }\n}\n",
        "output": "1",
        "idx": 675
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderFrameImpl::FrameFocused() {\n  Send(new FrameHostMsg_FrameFocused(routing_id_));\n}\n",
        "output": "0",
        "idx": 833
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BluetoothDeviceChromeOS::RequestPinCode(\n    const dbus::ObjectPath& device_path,\n    const PinCodeCallback& callback) {\n  DCHECK(agent_.get());\n  DCHECK(device_path == object_path_);\n  VLOG(1) << object_path_.value() << \": RequestPinCode\";\n  UMA_HISTOGRAM_ENUMERATION(\"Bluetooth.PairingMethod\",\n                            UMA_PAIRING_METHOD_REQUEST_PINCODE,\n                            UMA_PAIRING_METHOD_COUNT);\n  DCHECK(pairing_delegate_);\n  DCHECK(pincode_callback_.is_null());\n  pincode_callback_ = callback;\n  pairing_delegate_->RequestPinCode(this);\n  pairing_delegate_used_ = true;\n}\n",
        "output": "1",
        "idx": 2047
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PrintPreviewMessageHandler::OnInvalidPrinterSettings(int document_cookie) {\n  StopWorker(document_cookie);\n  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n  if (!print_preview_ui)\n    return;\n  print_preview_ui->OnInvalidPrinterSettings();\n}\n",
        "output": "0",
        "idx": 156
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DOMHandler::DOMHandler()\n     : DevToolsDomainHandler(DOM::Metainfo::domainName),\n      host_(nullptr) {\n}\n",
        "output": "1",
        "idx": 1331
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool RenderViewHostManager::ShouldReuseWebUI(\n    const NavigationEntry* curr_entry,\n    const NavigationEntryImpl* new_entry) const {\n  NavigationControllerImpl& controller =\n      delegate_->GetControllerForRenderManager();\n  return curr_entry && web_ui_.get() &&\n      (WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(\n          controller.GetBrowserContext(), curr_entry->GetURL()) ==\n       WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(\n          controller.GetBrowserContext(), new_entry->GetURL()));\n}\n",
        "output": "0",
        "idx": 368
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RenderBlock::styleWillChange(StyleDifference diff, const RenderStyle& newStyle)\n{\n    RenderStyle* oldStyle = style();\n \n     setReplaced(newStyle.isDisplayInlineType());\n \n    if (oldStyle && parent() && diff == StyleDifferenceLayout && oldStyle->position() != newStyle.position()) {\n         if (newStyle.position() == StaticPosition)\n            removePositionedObjects(0, NewContainingBlock);\n        else if (oldStyle->position() == StaticPosition) {\n            RenderObject* cb = parent();\n            while (cb && (cb->style()->position() == StaticPosition || (cb->isInline() && !cb->isReplaced())) && !cb->isRenderView()) {\n                if (cb->style()->position() == RelativePosition && cb->isInline() && !cb->isReplaced()) {\n                    cb = cb->containingBlock();\n                    break;\n                }\n                cb = cb->parent();\n            }\n\n            if (cb->isRenderBlock())\n                toRenderBlock(cb)->removePositionedObjects(this, NewContainingBlock);\n        }\n    }\n\n    RenderBox::styleWillChange(diff, newStyle);\n}\n",
        "output": "1",
        "idx": 1074
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void QQuickWebViewPrivate::setNeedsDisplay()\n{\n    Q_Q(QQuickWebView);\n    if (renderToOffscreenBuffer()) {\n        QImage dummyImage(1, 1, QImage::Format_ARGB32);\n        QPainter painter(&dummyImage);\n        q->page()->d->paint(&painter);\n        return;\n    }\n\n    q->page()->update();\n}\n",
        "output": "0",
        "idx": 1090
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " String InspectorPageAgent::CachedResourceTypeJson(\n     const Resource& cached_resource) {\n  return ResourceTypeJson(CachedResourceType(cached_resource));\n }\n",
        "output": "1",
        "idx": 1766
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n \t\tunsigned int *rsize)\n {\n\tif (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {\n \t\thid_info(hdev, \"fixing up Cherry Cymotion report descriptor\\n\");\n \t\trdesc[11] = rdesc[16] = 0xff;\n \t\trdesc[12] = rdesc[17] = 0x03;\n\t}\n\treturn rdesc;\n}\n",
        "output": "1",
        "idx": 778
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    LineLayoutState(bool fullLayout, LayoutUnit& repaintLogicalTop, LayoutUnit& repaintLogicalBottom, RenderFlowThread* flowThread)\n        : m_lastFloat(0)\n        , m_endLine(0)\n        , m_floatIndex(0)\n        , m_endLineLogicalTop(0)\n        , m_endLineMatched(false)\n        , m_checkForFloatsFromLastLine(false)\n        , m_isFullLayout(fullLayout)\n        , m_repaintLogicalTop(repaintLogicalTop)\n        , m_repaintLogicalBottom(repaintLogicalBottom)\n        , m_adjustedLogicalLineTop(0)\n        , m_usesRepaintBounds(false)\n        , m_flowThread(flowThread)\n    { }\n",
        "output": "0",
        "idx": 683
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void OfflinePageModelTaskified::OnTaskQueueIsIdle() {}\n",
        "output": "0",
        "idx": 1084
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t OMXNodeInstance::allocateBufferWithBackup(\n        OMX_U32 portIndex, const sp<IMemory> &params,\n        OMX::buffer_id *buffer, OMX_U32 allottedSize) {\n Mutex::Autolock autoLock(mLock);\n if (allottedSize > params->size()) {\n\n         return BAD_VALUE;\n     }\n \n    BufferMeta *buffer_meta = new BufferMeta(params, true);\n \n     OMX_BUFFERHEADERTYPE *header;\n \n    OMX_ERRORTYPE err = OMX_AllocateBuffer(\n            mHandle, &header, portIndex, buffer_meta, allottedSize);\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR(allocateBufferWithBackup, err,\n                SIMPLE_BUFFER(portIndex, (size_t)allottedSize, params->pointer()));\n delete buffer_meta;\n        buffer_meta = NULL;\n\n *buffer = 0;\n\n return StatusFromOMXError(err);\n }\n\n    CHECK_EQ(header->pAppPrivate, buffer_meta);\n\n *buffer = makeBufferID(header);\n\n    addActiveBuffer(portIndex, *buffer);\n\n    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());\n if (bufferSource != NULL && portIndex == kPortIndexInput) {\n        bufferSource->addCodecBuffer(header);\n }\n\n    CLOG_BUFFER(allocateBufferWithBackup, NEW_BUFFER_FMT(*buffer, portIndex, \"%zu@%p :> %u@%p\",\n            params->size(), params->pointer(), allottedSize, header->pBuffer));\n\n return OK;\n}\n",
        "output": "1",
        "idx": 1367
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline unsigned long perf_ip_adjust(struct pt_regs *regs)\n{\n\tunsigned long mmcra = regs->dsisr;\n\n\tif ((mmcra & MMCRA_SAMPLE_ENABLE) && !(ppmu->flags & PPMU_ALT_SIPR)) {\n\t\tunsigned long slot = (mmcra & MMCRA_SLOT) >> MMCRA_SLOT_SHIFT;\n\t\tif (slot > 1)\n\t\t\treturn 4 * (slot - 1);\n\t}\n\treturn 0;\n}\n",
        "output": "0",
        "idx": 677
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   static void TearDownTestCase() {\n     vpx_free(input_ - 1);\n     input_ = NULL;\n     vpx_free(output_);\n     output_ = NULL;\n   }\n",
        "output": "1",
        "idx": 866
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {\n  if (url.ProtocolIsData()) {\n    return false;\n  }\n  Document* document = GetDocument();\n  if (document && document->GetSecurityOrigin()) {\n    return !document->GetSecurityOrigin()->CanRequest(url);\n  }\n  return true;\n}\n",
        "output": "1",
        "idx": 357
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual void AddObserver(Observer* observer) {\n     if (!observers_.size()) {\n       observer->FirstObserverIsAdded(this);\n     }\n     observers_.AddObserver(observer);\n   }\n",
        "output": "1",
        "idx": 739
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "double json_real_value(const json_t *json)\n{\n    if(!json_is_real(json))\n        return 0;\n\n    return json_to_real(json)->value;\n}\n",
        "output": "0",
        "idx": 1328
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void toggle_fpga_eeprom_bus(bool cpu_own)\n {\n\tqrio_gpio_direction_output(GPIO_A, PROM_SEL_L, !cpu_own);\n }\n",
        "output": "1",
        "idx": 1470
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static void prefetch_dec(void)\n {\n   prefetch_table((const void *)&dec_tables, sizeof(dec_tables));\n }\n",
        "output": "1",
        "idx": 1131
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void put_mspel8_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)\n{\n    uint8_t halfH[88];\n    uint8_t halfV[64];\n    uint8_t halfHV[64];\n    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);\n    wmv2_mspel8_v_lowpass(halfV, src+1, 8, stride, 8);\n    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);\n    put_pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);\n}\n",
        "output": "0",
        "idx": 1934
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "timeval_to_jiffies(const struct timeval *value)\n{\n\tunsigned long sec = value->tv_sec;\n\tlong usec = value->tv_usec;\n\n\tif (sec >= MAX_SEC_IN_JIFFIES){\n\t\tsec = MAX_SEC_IN_JIFFIES;\n\t\tusec = 0;\n\t}\n\treturn (((u64)sec * SEC_CONVERSION) +\n\t\t(((u64)usec * USEC_CONVERSION + USEC_ROUND) >>\n\t\t (USEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;\n}\n",
        "output": "0",
        "idx": 1887
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " base::string16 GetApplicationNameForProtocol(const GURL& url) {\n  base::string16 application_name;\n   if (base::win::GetVersion() >= base::win::VERSION_WIN8) {\n    application_name = GetAppForProtocolUsingAssocQuery(url);\n     if (!application_name.empty())\n       return application_name;\n   }\n\n  return GetAppForProtocolUsingRegistry(url);\n}\n",
        "output": "1",
        "idx": 1492
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MagickExport const PixelPacket *GetVirtualPixelQueue(const Image *image)\n{\n  CacheInfo\n    *restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->methods.get_virtual_pixels_handler !=\n       (GetVirtualPixelsHandler) NULL)\n    return(cache_info->methods.get_virtual_pixels_handler(image));\n  assert(id < (int) cache_info->number_threads);\n  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));\n}\n",
        "output": "0",
        "idx": 1023
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void DOMStorageContextWrapper::Shutdown() {\n  DCHECK(context_.get());\n  mojo_task_runner_->PostTask(\n      FROM_HERE, base::BindOnce(&LocalStorageContextMojo::ShutdownAndDelete,\n                                base::Unretained(mojo_state_)));\n  mojo_state_ = nullptr;\n   if (mojo_session_state_) {\n     mojo_task_runner_->PostTask(\n         FROM_HERE, base::BindOnce(&SessionStorageContextMojo::ShutdownAndDelete,\n                                   base::Unretained(mojo_session_state_)));\n     mojo_session_state_ = nullptr;\n   }\n   memory_pressure_listener_.reset();\n  context_->task_runner()->PostShutdownBlockingTask(\n      FROM_HERE, DOMStorageTaskRunner::PRIMARY_SEQUENCE,\n      base::BindOnce(&DOMStorageContextImpl::Shutdown, context_));\n }\n",
        "output": "1",
        "idx": 999
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "aura::Window* PartialMagnificationController::GetCurrentRootWindow() {\n  aura::Window::Windows root_windows = Shell::GetAllRootWindows();\n  for (aura::Window::Windows::const_iterator iter = root_windows.begin();\n       iter != root_windows.end(); ++iter) {\n    aura::Window* root_window = *iter;\n    if (root_window->ContainsPointInRoot(\n            root_window->GetHost()->dispatcher()->GetLastMouseLocationInRoot()))\n      return root_window;\n  }\n  return NULL;\n}\n",
        "output": "1",
        "idx": 745
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "v8::Local<v8::Object> V8InjectedScriptHost::create(v8::Local<v8::Context> context, V8InspectorImpl* inspector)\n {\n     v8::Isolate* isolate = inspector->isolate();\n     v8::Local<v8::Object> injectedScriptHost = v8::Object::New(isolate);\n     v8::Local<v8::External> debuggerExternal = v8::External::New(isolate, inspector);\n     setFunctionProperty(context, injectedScriptHost, \"internalConstructorName\", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);\n     setFunctionProperty(context, injectedScriptHost, \"formatAccessorsAsProperties\", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"subtype\", V8InjectedScriptHost::subtypeCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"getInternalProperties\", V8InjectedScriptHost::getInternalPropertiesCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"objectHasOwnProperty\", V8InjectedScriptHost::objectHasOwnPropertyCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"bind\", V8InjectedScriptHost::bindCallback, debuggerExternal);\n    setFunctionProperty(context, injectedScriptHost, \"proxyTargetValue\", V8InjectedScriptHost::proxyTargetValueCallback, debuggerExternal);\n    return injectedScriptHost;\n}\n",
        "output": "1",
        "idx": 87
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " queue_unlock(struct futex_q *q, struct futex_hash_bucket *hb)\n {\n \tspin_unlock(&hb->lock);\n\tdrop_futex_key_refs(&q->key);\n }\n",
        "output": "1",
        "idx": 477
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "status_t BufferQueueConsumer::disconnect() {\n    ATRACE_CALL();\n\n    BQ_LOGV(\"disconnect(C)\");\n\n Mutex::Autolock lock(mCore->mMutex);\n\n if (mCore->mConsumerListener == NULL) {\n        BQ_LOGE(\"disconnect(C): no consumer is connected\");\n return BAD_VALUE;\n }\n\n    mCore->mIsAbandoned = true;\n    mCore->mConsumerListener = NULL;\n    mCore->mQueue.clear();\n    mCore->freeAllBuffersLocked();\n    mCore->mDequeueCondition.broadcast();\n return NO_ERROR;\n}\n",
        "output": "0",
        "idx": 1352
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ssl3_send_alert(SSL *s, int level, int desc)\n{\n    /* Map tls/ssl alert value to correct one */\n    desc = s->method->ssl3_enc->alert_value(desc);\n    if (s->version == SSL3_VERSION && desc == SSL_AD_PROTOCOL_VERSION)\n        desc = SSL_AD_HANDSHAKE_FAILURE; /* SSL 3.0 does not have\n                                          * protocol_version alerts */\n                                           * protocol_version alerts */\n     if (desc < 0)\n         return -1;\n    /* If a fatal one, remove from cache */\n    if ((level == 2) && (s->session != NULL))\n        SSL_CTX_remove_session(s->session_ctx, s->session);\n \n     s->s3->alert_dispatch = 1;\n     s->s3->send_alert[0] = level;\n     * else data is still being written out, we will get written some time in\n     * the future\n     */\n    return -1;\n}\n",
        "output": "1",
        "idx": 1412
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tun_net_init(struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\tswitch (tun->flags & TUN_TYPE_MASK) {\n\tcase TUN_TUN_DEV:\n\t\tdev->netdev_ops = &tun_netdev_ops;\n\n\t\t/* Point-to-Point TUN Device */\n\t\tdev->hard_header_len = 0;\n\t\tdev->addr_len = 0;\n\t\tdev->mtu = 1500;\n\n\t\t/* Zero header length */\n\t\tdev->type = ARPHRD_NONE;\n\t\tdev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\t\tdev->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */\n\t\tbreak;\n\n\tcase TUN_TAP_DEV:\n \t\tdev->netdev_ops = &tap_netdev_ops;\n \t\t/* Ethernet TAP Device */\n \t\tether_setup(dev);\n \n \t\trandom_ether_addr(dev->dev_addr);\n \n\t\tdev->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */\n\t\tbreak;\n\t}\n}\n",
        "output": "1",
        "idx": 686
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ShelfLayoutManager* GetShelfLayoutManager() {\n  return AshTestBase::GetPrimaryShelf()->shelf_layout_manager();\n}\n",
        "output": "0",
        "idx": 1735
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MagickExport void *DetachBlob(BlobInfo *blob_info)\n{\n  void\n    *data;\n\n  assert(blob_info != (BlobInfo *) NULL);\n  if (blob_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n   if (blob_info->mapped != MagickFalse)\n     {\n       (void) UnmapBlob(blob_info->data,blob_info->length);\n       RelinquishMagickResource(MapResource,blob_info->length);\n     }\n   blob_info->mapped=MagickFalse;\n  blob_info->length=0;\n  blob_info->offset=0;\n  blob_info->eof=MagickFalse;\n  blob_info->error=0;\n  blob_info->exempt=MagickFalse;\n  blob_info->type=UndefinedStream;\n  blob_info->file_info.file=(FILE *) NULL;\n  data=blob_info->data;\n  blob_info->data=(unsigned char *) NULL;\n  blob_info->stream=(StreamHandler) NULL;\n  blob_info->custom_stream=(CustomStreamInfo *) NULL;\n  return(data);\n}\n",
        "output": "1",
        "idx": 744
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *item )\n{\n\tcJSON_AddItemToObject( object, string, create_reference( item ) );\n}\n",
        "output": "1",
        "idx": 1005
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ProcRenderCreateConicalGradient(ClientPtr client)\n{\n    PicturePtr pPicture;\n    int len;\n    int error = 0;\n    xFixed *stops;\n    xRenderColor *colors;\n\n    REQUEST(xRenderCreateConicalGradientReq);\n\n    REQUEST_AT_LEAST_SIZE(xRenderCreateConicalGradientReq);\n\n    LEGAL_NEW_RESOURCE(stuff->pid, client);\n\n    len = (client->req_len << 2) - sizeof(xRenderCreateConicalGradientReq);\n    if (stuff->nStops > UINT32_MAX / (sizeof(xFixed) + sizeof(xRenderColor)))\n        return BadLength;\n    if (len != stuff->nStops * (sizeof(xFixed) + sizeof(xRenderColor)))\n        return BadLength;\n\n    stops = (xFixed *) (stuff + 1);\n    colors = (xRenderColor *) (stops + stuff->nStops);\n\n    pPicture =\n        CreateConicalGradientPicture(stuff->pid, &stuff->center, stuff->angle,\n                                     stuff->nStops, stops, colors, &error);\n    if (!pPicture)\n        return error;\n    /* security creation/labeling check */\n    error = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, PictureType,\n                     pPicture, RT_NONE, NULL, DixCreateAccess);\n    if (error != Success)\n        return error;\n    if (!AddResource(stuff->pid, PictureType, (void *) pPicture))\n        return BadAlloc;\n    return Success;\n}\n",
        "output": "0",
        "idx": 510
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static enum test_return test_binary_replaceq(void) {\n    return test_binary_replace_impl(\"test_binary_replaceq\",\n                                    PROTOCOL_BINARY_CMD_REPLACEQ);\n}\n",
        "output": "0",
        "idx": 1138
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Chapters::Chapters(\n    Segment* pSegment,\n    long long payload_start,\n    long long payload_size,\n    long long element_start,\n    long long element_size) :\n    m_pSegment(pSegment),\n    m_start(payload_start),\n    m_size(payload_size),\n    m_element_start(element_start),\n    m_element_size(element_size),\n    m_editions(NULL),\n    m_editions_size(0),\n    m_editions_count(0)\n{\n}\n",
        "output": "1",
        "idx": 958
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int spl_filesystem_file_is_empty_line(spl_filesystem_object *intern TSRMLS_DC) /* {{{ */\n{\n\tif (intern->u.file.current_line) {\n\t\treturn intern->u.file.current_line_len == 0;\n\t} else if (intern->u.file.current_zval) {\n\t\tswitch(Z_TYPE_P(intern->u.file.current_zval)) {\n\t\tcase IS_STRING:\n\t\t\treturn Z_STRLEN_P(intern->u.file.current_zval) == 0;\n\t\tcase IS_ARRAY:\n \t\t\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV)\n \t\t\t&& zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 1) {\n \t\t\t\tzval ** first = Z_ARRVAL_P(intern->u.file.current_zval)->pListHead->pData;\n \t\t\t\treturn Z_TYPE_PP(first) == IS_STRING && Z_STRLEN_PP(first) == 0;\n \t\t\t}\n \t\t\treturn zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 0;\n\t\tcase IS_NULL:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\treturn 1;\n\t}\n}\n/* }}} */\n",
        "output": "1",
        "idx": 1360
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Document::InitContentSecurityPolicy(\n    ContentSecurityPolicy* csp,\n    const ContentSecurityPolicy* policy_to_inherit,\n    const ContentSecurityPolicy* previous_document_csp) {\n   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());\n \n   GetContentSecurityPolicy()->BindToExecutionContext(this);\n \n  if (policy_to_inherit) {\n     GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n  } else {\n    if (frame_) {\n       Frame* inherit_from = frame_->Tree().Parent()\n                                 ? frame_->Tree().Parent()\n                                 : frame_->Client()->Opener();\n       if (inherit_from && frame_ != inherit_from) {\n         DCHECK(inherit_from->GetSecurityContext() &&\n                inherit_from->GetSecurityContext()->GetContentSecurityPolicy());\n        policy_to_inherit =\n            inherit_from->GetSecurityContext()->GetContentSecurityPolicy();\n       }\n     }\n    if (!policy_to_inherit)\n      policy_to_inherit = previous_document_csp;\n    if (policy_to_inherit &&\n        (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||\n         url_.ProtocolIs(\"blob\") || url_.ProtocolIs(\"filesystem\")))\n      GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n  }\n  if (policy_to_inherit && IsPluginDocument())\n    GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);\n }\n",
        "output": "1",
        "idx": 1870
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " bool BluetoothDeviceChromeOS::ExpectingConfirmation() const {\n  return !confirmation_callback_.is_null();\n }\n",
        "output": "1",
        "idx": 320
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void init_once(void *foo)\n{\n\tstruct ext4_inode_info *ei = (struct ext4_inode_info *) foo;\n\n \tINIT_LIST_HEAD(&ei->i_orphan);\n \tinit_rwsem(&ei->xattr_sem);\n \tinit_rwsem(&ei->i_data_sem);\n \tinode_init_once(&ei->vfs_inode);\n }\n",
        "output": "1",
        "idx": 880
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HWNDMessageHandler::Init(HWND parent, const gfx::Rect& bounds) {\n  TRACE_EVENT0(\"views\", \"HWNDMessageHandler::Init\");\n  GetMonitorAndRects(bounds.ToRECT(), &last_monitor_, &last_monitor_rect_,\n                     &last_work_area_);\n \n   WindowImpl::Init(parent, bounds);\n }\n",
        "output": "1",
        "idx": 947
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xdr_dpol_arg(XDR *xdrs, dpol_arg *objp)\n{\n\tif (!xdr_ui_4(xdrs, &objp->api_version)) {\n\t\treturn (FALSE);\n\t}\n\tif (!xdr_nullstring(xdrs, &objp->name)) {\n\t\treturn (FALSE);\n\t}\n\treturn (TRUE);\n}\n",
        "output": "0",
        "idx": 636
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)\n{\n\tint r;\n\n\tmutex_lock(&kvm->slots_lock);\n\tr = __x86_set_memory_region(kvm, id, gpa, size);\n\tmutex_unlock(&kvm->slots_lock);\n\n\treturn r;\n}\n",
        "output": "0",
        "idx": 1980
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static EAS_I16 ConvertLFOPhaseIncrement (EAS_I32 pitchCents)\n{\n\n /* check range */\n if (pitchCents > MAX_LFO_FREQUENCY_IN_PITCHCENTS)\n        pitchCents = MAX_LFO_FREQUENCY_IN_PITCHCENTS;\n if (pitchCents < MIN_LFO_FREQUENCY_IN_PITCHCENTS)\n        pitchCents = MIN_LFO_FREQUENCY_IN_PITCHCENTS;\n\n /* double the rate and divide by frame rate by subtracting in log domain */\n    pitchCents = pitchCents - dlsLFOFrequencyConvert;\n\n /* convert to phase increment */\n return (EAS_I16) EAS_Calculate2toX(pitchCents);\n}\n",
        "output": "0",
        "idx": 580
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int generate_key(DH *dh)\n{\n     int ok = 0;\n     int generate_new_key = 0;\n     unsigned l;\n    BN_CTX *ctx;\n     BN_MONT_CTX *mont = NULL;\n     BIGNUM *pub_key = NULL, *priv_key = NULL;\n \n     ctx = BN_CTX_new();\n     if (ctx == NULL)\n         goto err;\n        generate_new_key = 1;\n    } else\n",
        "output": "1",
        "idx": 694
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int32_t InputHandler::finishComposition()\n{\n    if (!isActiveTextEdit())\n        return -1;\n\n    if (!compositionActive())\n        return 0;\n\n    removeAttributedTextMarker();\n\n    InputLog(LogLevelInfo, \"InputHandler::finishComposition completed\");\n\n    return 0;\n}\n",
        "output": "0",
        "idx": 288
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "size_t ndp_msg_payload_len(struct ndp_msg *msg)\n{\n\treturn msg->len;\n}\n",
        "output": "0",
        "idx": 1202
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ZEND_API int zend_declare_property_double(zend_class_entry *ce, const char *name, int name_length, double value, int access_type TSRMLS_DC) /* {{{ */\n{\n\tzval *property;\n\n\tif (ce->type & ZEND_INTERNAL_CLASS) {\n\t\tALLOC_PERMANENT_ZVAL(property);\n\t} else {\n\t\tALLOC_ZVAL(property);\n\t}\n\tINIT_PZVAL(property);\n\tZVAL_DOUBLE(property, value);\n\treturn zend_declare_property(ce, name, name_length, property, access_type TSRMLS_CC);\n}\n/* }}} */\n",
        "output": "0",
        "idx": 209
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TabStrip::SetDropArrow(\n    const base::Optional<BrowserRootView::DropIndex>& index) {\n  if (!index) {\n    controller_->OnDropIndexUpdate(-1, false);\n    drop_arrow_.reset();\n    return;\n  }\n\n  controller_->OnDropIndexUpdate(index->value, index->drop_before);\n\n  if (drop_arrow_ && (index == drop_arrow_->index))\n    return;\n\n  bool is_beneath;\n  gfx::Rect drop_bounds =\n      GetDropBounds(index->value, index->drop_before, &is_beneath);\n\n  if (!drop_arrow_) {\n    drop_arrow_ = std::make_unique<DropArrow>(*index, !is_beneath, GetWidget());\n  } else {\n    drop_arrow_->index = *index;\n    if (is_beneath == drop_arrow_->point_down) {\n      drop_arrow_->point_down = !is_beneath;\n      drop_arrow_->arrow_view->SetImage(\n          GetDropArrowImage(drop_arrow_->point_down));\n    }\n  }\n\n  drop_arrow_->arrow_window->SetBounds(drop_bounds);\n  drop_arrow_->arrow_window->Show();\n}\n",
        "output": "0",
        "idx": 1981
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "on_unregister_handler(TCMUService1HandlerManager1 *interface,\n\t\t      GDBusMethodInvocation *invocation,\n\t\t      gchar *subtype,\n\t\t      gpointer user_data)\n{\n\tstruct tcmur_handler *handler = find_handler_by_subtype(subtype);\n\tstruct dbus_info *info = handler ? handler->opaque : NULL;\n\n\tif (!handler) {\n\t\tg_dbus_method_invocation_return_value(invocation,\n\t\t\tg_variant_new(\"(bs)\", FALSE,\n \t\t\t\t      \"unknown subtype\"));\n \t\treturn TRUE;\n \t}\n \tdbus_unexport_handler(handler);\n\ttcmur_unregister_handler(handler);\n \tg_bus_unwatch_name(info->watcher_id);\n \tg_free(info);\n \tg_free(handler);\n\tg_dbus_method_invocation_return_value(invocation,\n\t\tg_variant_new(\"(bs)\", TRUE, \"succeeded\"));\n\treturn TRUE;\n}\n",
        "output": "1",
        "idx": 1850
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void DistillerNativeJavaScript::EnsureServiceConnected() {\n  if (!distiller_js_service_) {\n     render_frame_->GetServiceRegistry()->ConnectToRemoteService(\n         mojo::GetProxy(&distiller_js_service_));\n   }\n }\n",
        "output": "1",
        "idx": 228
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,\n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n \tmant = JPC_QCX_GETMANT(refstepsize);\n \tnumbands = 3 * numrlvls - 2;\n \tfor (bandno = 0; bandno < numbands; ++bandno) {\n////jas_eprintf(\"DEBUG %d %d %d %d %d\\n\", bandno, expn, numrlvls, bandno, ((numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))));\n \t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +\n \t\t  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));\n \t}\n}\n",
        "output": "1",
        "idx": 350
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void VerifyPrintPreviewInvalidPrinterSettings(bool settings_invalid) {\n    bool print_preview_invalid_printer_settings =\n        (render_thread_->sink().GetUniqueMessageMatching(\n            PrintHostMsg_PrintPreviewInvalidPrinterSettings::ID) != NULL);\n    EXPECT_EQ(settings_invalid, print_preview_invalid_printer_settings);\n  }\n",
        "output": "0",
        "idx": 1089
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool CanUseExistingResource(const net::HttpResponseInfo* http_info) {\n  if (!http_info->headers || http_info->headers->RequiresValidation(\n                                 http_info->request_time,\n                                 http_info->response_time, base::Time::Now())) {\n    return false;\n  }\n\n  std::string value;\n  size_t iter = 0;\n  while (http_info->headers->EnumerateHeader(&iter, \"vary\", &value)) {\n    if (!base::EqualsCaseInsensitiveASCII(value, \"Accept-Encoding\") &&\n        !base::EqualsCaseInsensitiveASCII(value, \"Origin\")) {\n      return false;\n    }\n  }\n  return true;\n}\n",
        "output": "0",
        "idx": 1055
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(grapheme_strpos)\n{\n\tunsigned char *haystack, *needle;\n        int haystack_len, needle_len;\n        unsigned char *found;\n        long loffset = 0;\n       int32_t offset = 0;\n        int ret_pos;\n \n        if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss|l\", (char **)&haystack, &haystack_len, (char **)&needle, &needle_len, &loffset) == FAILURE) {\n\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \"grapheme_strpos: unable to parse input param\", 0 TSRMLS_CC );\n\n\t\tRETURN_FALSE;\n\t}\n\n\tif ( OUTSIDE_STRING(loffset, haystack_len) ) {\n\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR, \"grapheme_strpos: Offset not contained in string\", 1 TSRMLS_CC );\n\n\t\tRETURN_FALSE;\n\t}\n \n        /* we checked that it will fit: */\n        offset = (int32_t) loffset;\n \n        /* the offset is 'grapheme count offset' so it still might be invalid - we'll check it later */\n \n\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR, \"grapheme_strpos: Empty delimiter\", 1 TSRMLS_CC );\n\n\t\tRETURN_FALSE;\n\t}\n",
        "output": "1",
        "idx": 3
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MagickExport MagickBooleanType IsMonochromeImage(const Image *image,\n  ExceptionInfo *exception)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->type == BilevelType)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n",
        "output": "0",
        "idx": 1312
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void HandleCompleteLogin(const base::ListValue* args) {\n#if defined(OS_CHROMEOS)\n    oauth2_delegate_.reset(new InlineLoginUIOAuth2Delegate(web_ui()));\n    oauth2_token_fetcher_.reset(new chromeos::OAuth2TokenFetcher(\n        oauth2_delegate_.get(), profile_->GetRequestContext()));\n    oauth2_token_fetcher_->StartExchangeFromCookies();\n#elif !defined(OS_ANDROID)\n    const base::DictionaryValue* dict = NULL;\n    string16 email;\n    string16 password;\n    if (!args->GetDictionary(0, &dict) || !dict ||\n        !dict->GetString(\"email\", &email) ||\n        !dict->GetString(\"password\", &password)) {\n      NOTREACHED();\n      return;\n    }\n\n    new OneClickSigninSyncStarter(\n        profile_, NULL, \"0\" /* session_index 0 for the default user */,\n         UTF16ToASCII(email), UTF16ToASCII(password),\n         OneClickSigninSyncStarter::SYNC_WITH_DEFAULT_SETTINGS,\n         true /* force_same_tab_navigation */,\n        OneClickSigninSyncStarter::NO_CONFIRMATION);\n     web_ui()->CallJavascriptFunction(\"inline.login.closeDialog\");\n #endif\n   }\n",
        "output": "1",
        "idx": 1163
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool OmniboxViewViews::IsImeShowingPopup() const {\n#if defined(OS_CHROMEOS)\n  return ime_candidate_window_open_;\n#else\n  const views::InputMethod* input_method = this->GetInputMethod();\n  return input_method && input_method->IsCandidatePopupOpen();\n#endif\n}\n",
        "output": "0",
        "idx": 1141
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xfs_handlereq_to_dentry(\n\tstruct file\t\t*parfilp,\n\txfs_fsop_handlereq_t\t*hreq)\n{\n\treturn xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);\n}\n",
        "output": "0",
        "idx": 810
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RunCallbacksWithDisabled(LogoCallbacks callbacks) {\n  if (callbacks.on_cached_encoded_logo_available) {\n    std::move(callbacks.on_cached_encoded_logo_available)\n        .Run(LogoCallbackReason::DISABLED, base::nullopt);\n  }\n  if (callbacks.on_cached_decoded_logo_available) {\n    std::move(callbacks.on_cached_decoded_logo_available)\n        .Run(LogoCallbackReason::DISABLED, base::nullopt);\n  }\n  if (callbacks.on_fresh_encoded_logo_available) {\n    std::move(callbacks.on_fresh_encoded_logo_available)\n        .Run(LogoCallbackReason::DISABLED, base::nullopt);\n  }\n  if (callbacks.on_fresh_decoded_logo_available) {\n    std::move(callbacks.on_fresh_decoded_logo_available)\n        .Run(LogoCallbackReason::DISABLED, base::nullopt);\n  }\n}\n",
        "output": "1",
        "idx": 1466
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static int sgi_clock_set(clockid_t clockid, struct timespec *tp)\n {\n \n \tu64 nsec;\n\tu64 rem;\n \n \tnsec = rtc_time() * sgi_clock_period;\n \n\tsgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n \n \tif (rem <= tp->tv_nsec)\n \t\tsgi_clock_offset.tv_nsec = tp->tv_sec - rem;\n\telse {\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;\n\t\tsgi_clock_offset.tv_sec--;\n\t}\n\treturn 0;\n}\n",
        "output": "1",
        "idx": 1716
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ssl3_read_internal(SSL *s, void *buf, int len, int peek)\n\t{\n\tint ret;\n\t\n\tclear_sys_error();\n\tif (s->s3->renegotiate) ssl3_renegotiate_check(s);\n\ts->s3->in_read_app_data=1;\n\tret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);\n\tif ((ret == -1) && (s->s3->in_read_app_data == 2))\n\t\t{\n\t\t/* ssl3_read_bytes decided to call s->handshake_func, which\n\t\t * called ssl3_read_bytes to read handshake data.\n\t\t * However, ssl3_read_bytes actually found application data\n\t\t * and thinks that application data makes sense here; so disable\n\t\t * handshake processing and try to read application data again. */\n\t\ts->in_handshake++;\n\t\tret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);\n\t\ts->in_handshake--;\n\t\t}\n\telse\n\t\ts->s3->in_read_app_data=0;\n\n\treturn(ret);\n\t}\n",
        "output": "0",
        "idx": 225
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void withActiveWindowAndFirstWindowAttributeAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMGetter\");\n    TestObjectV8Internal::withActiveWindowAndFirstWindowAttributeAttributeGetter(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
        "output": "0",
        "idx": 1922
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int unix_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sock *tsk;\n\tstruct sk_buff *skb;\n\tint err;\n\n\terr = -EOPNOTSUPP;\n\tif (sock->type != SOCK_STREAM && sock->type != SOCK_SEQPACKET)\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tif (sk->sk_state != TCP_LISTEN)\n\t\tgoto out;\n\n\t/* If socket state is TCP_LISTEN it cannot change (for now...),\n\t * so that no locks are necessary.\n\t */\n\n\tskb = skb_recv_datagram(sk, 0, flags&O_NONBLOCK, &err);\n\tif (!skb) {\n\t\t/* This means receive shutdown. */\n\t\tif (err == 0)\n\t\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttsk = skb->sk;\n\tskb_free_datagram(sk, skb);\n\twake_up_interruptible(&unix_sk(sk)->peer_wait);\n\n\t/* attach accepted sock to socket */\n\tunix_state_lock(tsk);\n\tnewsock->state = SS_CONNECTED;\n\tsock_graft(tsk, newsock);\n\tunix_state_unlock(tsk);\n\treturn 0;\n\nout:\n\treturn err;\n}\n",
        "output": "0",
        "idx": 1590
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\tsecurity_key_free(key);\n\n\t\t/* deal with the user's key tracking and quota */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n \t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n \t\t\tatomic_dec(&key->user->nikeys);\n \n\t\tkey_user_put(key->user);\n \t\t/* now throw away the key memory */\n \t\tif (key->type->destroy)\n \t\t\tkey->type->destroy(key);\n \n \t\tkfree(key->description);\n \n #ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}\n",
        "output": "1",
        "idx": 1256
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " InterstitialPage* WebContentsImpl::GetInterstitialPage() const {\n  return GetRenderManager()->interstitial_page();\n }\n",
        "output": "1",
        "idx": 1401
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GetIntersection (uint64 start1, uint32 length1, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *intersectLength)\n{\n\tuint64 end1 = start1 + length1 - 1;\n\tuint64 intersectEnd = (end1 <= end2) ? end1 : end2;\n\n\t*intersectStart = (start1 >= start2) ? start1 : start2;\n\t*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);\n\n\tif (*intersectLength == 0)\n\t\t*intersectStart = start1;\n}\n",
        "output": "0",
        "idx": 216
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static v8::Handle<v8::Value> convert4Callback(const v8::Arguments& args)\n {\n     INC_STATS(\"DOM.TestObj.convert4\");\n     if (args.Length() < 1)\n        return V8Proxy::throwNotEnoughArgumentsError();\n     TestObj* imp = V8TestObj::toNative(args.Holder());\n     EXCEPTION_BLOCK(d*, , V8d::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8d::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);\n     imp->convert4();\n    return v8::Handle<v8::Value>();\n}\n",
        "output": "1",
        "idx": 1232
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " static int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n \tut8 op_MSB,op_LSB;\n \tint ret;\n\tif (!data)\n \t\treturn 0;\n \tmemset (op, '\\0', sizeof (RAnalOp));\n \top->addr = addr;\n \top->type = R_ANAL_OP_TYPE_UNK;\n\top->jump = op->fail = -1;\n\top->ptr = op->val = -1;\n\n\top->size = 2;\n\n\top_MSB = anal->big_endian? data[0]: data[1];\n\top_LSB = anal->big_endian? data[1]: data[0];\n\tret =  first_nibble_decode[(op_MSB>>4) & 0x0F](anal, op, (ut16)(op_MSB<<8 | op_LSB));\n\treturn ret;\n}\n",
        "output": "1",
        "idx": 1928
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " bool InputWindowInfo::frameContainsPoint(int32_t x, int32_t y) const {\n    return x >= frameLeft && x <= frameRight\n            && y >= frameTop && y <= frameBottom;\n }\n",
        "output": "1",
        "idx": 1059
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)\n {\n \tstruct crypto_report_akcipher rakcipher;\n \n\tstrlcpy(rakcipher.type, \"akcipher\", sizeof(rakcipher.type));\n \n \tif (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,\n \t\t    sizeof(struct crypto_report_akcipher), &rakcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n",
        "output": "1",
        "idx": 1611
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_framing_type_print(netdissect_options *ndo, const u_char *dat)\n {\n \tconst uint32_t *ptr = (const uint32_t *)dat;\n \n \tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_ASYNC_MASK) {\n \t\tND_PRINT((ndo, \"A\"));\n \t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_SYNC_MASK) {\n\t\tND_PRINT((ndo, \"S\"));\n\t}\n}\n",
        "output": "1",
        "idx": 1199
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void disk_seqf_stop(struct seq_file *seqf, void *v)\n{\n\tstruct class_dev_iter *iter = seqf->private;\n\n\t/* stop is called even after start failed :-( */\n \tif (iter) {\n \t\tclass_dev_iter_exit(iter);\n \t\tkfree(iter);\n \t}\n }\n",
        "output": "1",
        "idx": 206
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GpuCommandBufferStub::OnCreateTransferBuffer(int32 size,\n                                                   int32 id_request,\n                                                   IPC::Message* reply_message) {\n   TRACE_EVENT0(\"gpu\", \"GpuCommandBufferStub::OnCreateTransferBuffer\");\n  if (command_buffer_.get()) {\n    int32 id = command_buffer_->CreateTransferBuffer(size, id_request);\n    GpuCommandBufferMsg_CreateTransferBuffer::WriteReplyParams(\n        reply_message, id);\n  } else {\n    reply_message->set_reply_error();\n  }\n  Send(reply_message);\n}\n",
        "output": "1",
        "idx": 1996
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)\n {\n \t__issue_discard_cmd(sbi, false);\n \t__drop_discard_cmd(sbi);\n\t__wait_discard_cmd(sbi, false);\n }\n",
        "output": "1",
        "idx": 1774
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void BluetoothDeviceChromeOS::UnregisterAgent() {\n  if (!agent_.get())\n    return;\n  DCHECK(pairing_delegate_);\n  DCHECK(pincode_callback_.is_null());\n  DCHECK(passkey_callback_.is_null());\n  DCHECK(confirmation_callback_.is_null());\n  pairing_delegate_->DismissDisplayOrConfirm();\n  pairing_delegate_ = NULL;\n  agent_.reset();\n  VLOG(1) << object_path_.value() << \": Unregistering pairing agent\";\n  DBusThreadManager::Get()->GetBluetoothAgentManagerClient()->\n      UnregisterAgent(\n          dbus::ObjectPath(kAgentPath),\n          base::Bind(&base::DoNothing),\n          base::Bind(&BluetoothDeviceChromeOS::OnUnregisterAgentError,\n                     weak_ptr_factory_.GetWeakPtr()));\n}\n",
        "output": "1",
        "idx": 2051
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "u32 ip_mtu_from_fib_result(struct fib_result *res, __be32 daddr)\n{\n\tstruct fib_info *fi = res->fi;\n\tstruct fib_nh *nh = &fi->fib_nh[res->nh_sel];\n\tstruct net_device *dev = nh->nh_dev;\n\tu32 mtu = 0;\n\n\tif (dev_net(dev)->ipv4.sysctl_ip_fwd_use_pmtu ||\n\t    fi->fib_metrics->metrics[RTAX_LOCK - 1] & (1 << RTAX_MTU))\n\t\tmtu = fi->fib_mtu;\n\n\tif (likely(!mtu)) {\n\t\tstruct fib_nh_exception *fnhe;\n\n\t\tfnhe = find_exception(nh, daddr);\n\t\tif (fnhe && !time_after_eq(jiffies, fnhe->fnhe_expires))\n\t\t\tmtu = fnhe->fnhe_pmtu;\n\t}\n\n\tif (likely(!mtu))\n\t\tmtu = min(READ_ONCE(dev->mtu), IP_MAX_MTU);\n\n\treturn mtu - lwtunnel_headroom(nh->nh_lwtstate, mtu);\n}\n",
        "output": "0",
        "idx": 1949
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "my_object_str_hash_len (MyObject *obj, GHashTable *table, guint *len, GError **error)\n{\n  *len = 0;\n  g_hash_table_foreach (table, hash_foreach, len);\n  return TRUE;\n}\n",
        "output": "1",
        "idx": 1296
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RTCVoidRequestImpl::~RTCVoidRequestImpl()\n{\n}\n",
        "output": "0",
        "idx": 1633
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "StateChangeReason DiscardReasonToStateChangeReason(DiscardReason reason) {\n  switch (reason) {\n    case DiscardReason::kExternal:\n      return StateChangeReason::EXTENSION_INITIATED;\n    case DiscardReason::kProactive:\n      return StateChangeReason::BROWSER_INITIATED;\n    case DiscardReason::kUrgent:\n      return StateChangeReason::SYSTEM_MEMORY_PRESSURE;\n   }\n }\n",
        "output": "0",
        "idx": 659
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_exsltDateTruncateDate (exsltDateValPtr dt, exsltDateType type)\n{\n    if (dt == NULL)\n        return 1;\n\n    if ((type & XS_TIME) != XS_TIME) {\n        dt->value.date.hour = 0;\n        dt->value.date.min  = 0;\n        dt->value.date.sec  = 0.0;\n     }\n \n     if ((type & XS_GDAY) != XS_GDAY)\n        dt->value.date.day = 0;\n \n     if ((type & XS_GMONTH) != XS_GMONTH)\n        dt->value.date.mon = 0;\n \n     if ((type & XS_GYEAR) != XS_GYEAR)\n         dt->value.date.year = 0;\n\n    dt->type = type;\n\n    return 0;\n}\n",
        "output": "1",
        "idx": 1992
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void sco_connect_cfm(struct hci_conn *hcon, __u8 status)\n{\n\tBT_DBG(\"hcon %p bdaddr %pMR status %d\", hcon, &hcon->dst, status);\n\tif (!status) {\n\t\tstruct sco_conn *conn;\n\n\t\tconn = sco_conn_add(hcon);\n\t\tif (conn)\n\t\t\tsco_conn_ready(conn);\n\t} else\n\t\tsco_conn_del(hcon, bt_to_errno(status));\n}\n",
        "output": "0",
        "idx": 1142
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void LocalFileSystem::fileSystemNotAllowedInternal(\n     PassRefPtrWillBeRawPtr<ExecutionContext> context,\n    PassRefPtr<CallbackWrapper> callbacks)\n {\n     context->postTask(createCrossThreadTask(&reportFailure, callbacks->release(), FileError::ABORT_ERR));\n }\n",
        "output": "1",
        "idx": 1345
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GURL DevToolsWindow::GetDevToolsURL(Profile* profile,\n                                    const GURL& base_url,\n                                    bool shared_worker_frontend,\n                                    bool v8_only_frontend,\n                                    const std::string& remote_frontend,\n                                    bool can_dock) {\n  if (base_url.SchemeIs(\"data\"))\n    return base_url;\n\n  std::string frontend_url(\n      !remote_frontend.empty() ?\n          remote_frontend :\n          base_url.is_empty() ? chrome::kChromeUIDevToolsURL : base_url.spec());\n  std::string url_string(\n      frontend_url +\n      ((frontend_url.find(\"?\") == std::string::npos) ? \"?\" : \"&\"));\n  if (shared_worker_frontend)\n    url_string += \"&isSharedWorker=true\";\n  if (v8_only_frontend)\n    url_string += \"&v8only=true\";\n  if (remote_frontend.size()) {\n    url_string += \"&remoteFrontend=true\";\n  } else {\n    url_string += \"&remoteBase=\" + DevToolsUI::GetRemoteBaseURL().spec();\n   }\n   if (can_dock)\n     url_string += \"&can_dock=true\";\n  return GURL(url_string);\n }\n",
        "output": "1",
        "idx": 1693
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void servers_init(void)\n{\n\tsettings_add_bool(\"server\", \"resolve_prefer_ipv6\", FALSE);\n\tsettings_add_bool(\"server\", \"resolve_reverse_lookup\", FALSE);\n\tlookup_servers = servers = NULL;\n\n\tsignal_add(\"chat protocol deinit\", (SIGNAL_FUNC) sig_chat_protocol_deinit);\n\n\tservers_reconnect_init();\n\tservers_setup_init();\n}\n",
        "output": "0",
        "idx": 922
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "net::BackoffEntry* DataReductionProxyConfigServiceClient::GetBackoffEntry() {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  return &backoff_entry_;\n}\n",
        "output": "0",
        "idx": 313
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void MediaInterfaceProxy::CreateCdm(\n     media::mojom::ContentDecryptionModuleRequest request) {\n   DCHECK(thread_checker_.CalledOnValidThread());\n  GetMediaInterfaceFactory()->CreateCdm(std::move(request));\n }\n",
        "output": "1",
        "idx": 1049
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int des_setkey(struct crypto_tfm *tfm, const u8 *key,\n\t\t      unsigned int keylen)\n{\n\tstruct des_ctx *dctx = crypto_tfm_ctx(tfm);\n\tu32 *flags = &tfm->crt_flags;\n\tu32 tmp[DES_EXPKEY_WORDS];\n\tint ret;\n\n\t/* Expand to tmp */\n\tret = des_ekey(tmp, key);\n\n\tif (unlikely(ret == 0) && (*flags & CRYPTO_TFM_REQ_WEAK_KEY)) {\n\t\t*flags |= CRYPTO_TFM_RES_WEAK_KEY;\n\t\treturn -EINVAL;\n\t}\n\n\t/* Copy to output */\n\tmemcpy(dctx->expkey, tmp, sizeof(dctx->expkey));\n\n\treturn 0;\n}\n",
        "output": "0",
        "idx": 1685
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void OomInterventionImpl::ReportMemoryStats(\n    OomInterventionMetrics& current_memory) {\n  UMA_HISTOGRAM_MEMORY_MB(\n      \"Memory.Experimental.OomIntervention.RendererBlinkUsage\",\n      current_memory.current_blink_usage_kb / 1024);\n  UMA_HISTOGRAM_MEMORY_LARGE_MB(\n      \"Memory.Experimental.OomIntervention.\"\n      \"RendererPrivateMemoryFootprint\",\n      current_memory.current_private_footprint_kb / 1024);\n  UMA_HISTOGRAM_MEMORY_MB(\n      \"Memory.Experimental.OomIntervention.RendererSwapFootprint\",\n      current_memory.current_swap_kb / 1024);\n  UMA_HISTOGRAM_MEMORY_LARGE_MB(\n      \"Memory.Experimental.OomIntervention.RendererVmSize\",\n      current_memory.current_vm_size_kb / 1024);\n\n  CrashMemoryMetricsReporterImpl::Instance().WriteIntoSharedMemory(\n      current_memory);\n}\n",
        "output": "0",
        "idx": 1839
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void account_numa_dequeue(struct rq *rq, struct task_struct *p)\n{\n}\n",
        "output": "0",
        "idx": 989
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint64_t ahci_mem_read_32(void *opaque, hwaddr addr)\n{\n    AHCIState *s = opaque;\n    uint32_t val = 0;\n\n    if (addr < AHCI_GENERIC_HOST_CONTROL_REGS_MAX_ADDR) {\n        switch (addr) {\n        case HOST_CAP:\n            val = s->control_regs.cap;\n            break;\n        case HOST_CTL:\n            val = s->control_regs.ghc;\n            break;\n        case HOST_IRQ_STAT:\n            val = s->control_regs.irqstatus;\n            break;\n        case HOST_PORTS_IMPL:\n            val = s->control_regs.impl;\n            break;\n        case HOST_VERSION:\n            val = s->control_regs.version;\n            break;\n        }\n\n        DPRINTF(-1, \"(addr 0x%08X), val 0x%08X\\n\", (unsigned) addr, val);\n    } else if ((addr >= AHCI_PORT_REGS_START_ADDR) &&\n               (addr < (AHCI_PORT_REGS_START_ADDR +\n                (s->ports * AHCI_PORT_ADDR_OFFSET_LEN)))) {\n        val = ahci_port_read(s, (addr - AHCI_PORT_REGS_START_ADDR) >> 7,\n                             addr & AHCI_PORT_ADDR_OFFSET_MASK);\n    }\n\n    return val;\n}\n",
        "output": "0",
        "idx": 742
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " const CuePoint* Cues::GetLast() const {\n  if (m_cue_points == NULL)\n     return NULL;\n \n  if (m_count <= 0)\n    return NULL;\n#if 0\n    LoadCuePoint();  //init cues\n    const size_t count = m_count + m_preload_count;\n    if (count == 0)  //weird\n        return NULL;\n    const size_t index = count - 1;\n    CuePoint* const* const pp = m_cue_points;\n    assert(pp);\n    CuePoint* const pCP = pp[index];\n    assert(pCP);\n    pCP->Load(m_pSegment->m_pReader);\n    assert(pCP->GetTimeCode() >= 0);\n#else\n   const long index = m_count - 1;\n \n   CuePoint* const* const pp = m_cue_points;\n  assert(pp);\n \n   CuePoint* const pCP = pp[index];\n  assert(pCP);\n  assert(pCP->GetTimeCode() >= 0);\n#endif\n \n   return pCP;\n }\n",
        "output": "1",
        "idx": 816
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " void HTMLImportsController::Dispose() {\n  for (const auto& loader : loaders_)\n    loader->Dispose();\n  loaders_.clear();\n \n   if (root_) {\n     root_->Dispose();\n    root_.Clear();\n  }\n}\n",
        "output": "1",
        "idx": 1542
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " int mif_validate(jas_stream_t *in)\n {\n\tuchar buf[MIF_MAGICLEN];\n \tuint_fast32_t magic;\n \tint i;\n \tint n;\n\n\tassert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);\n\n\t/* Read the validation data (i.e., the data used for detecting\n\t  the format). */\n\tif ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {\n\t\treturn -1;\n\t}\n\n\t/* Put the validation data back onto the stream, so that the\n\t  stream position will not be changed. */\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Was enough data read? */\n\tif (n < MIF_MAGICLEN) {\n\t\treturn -1;\n\t}\n\n\t/* Compute the signature value. */\n\tmagic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |\n\t  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |\n\t  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |\n\t  buf[3];\n\n\t/* Ensure that the signature is correct for this format. */\n\tif (magic != MIF_MAGIC) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n",
        "output": "1",
        "idx": 702
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    DictionaryValue* ToValue() const {\n      DictionaryValue* value = new DictionaryValue();\n      value->SetInteger(\"totalCount\", total_count);\n      value->SetString(\"payload\", payload);\n      return value;\n    }\n",
        "output": "0",
        "idx": 1798
    }
]