[
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int get_v4l2_input32(struct v4l2_input *kp, struct v4l2_input32 __user *up)\n{\n\tif (copy_from_user(kp, up, sizeof(*up)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
        "output": "1",
        "idx": 540
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,\n\t\t\t int *qerr, u32 *salt)\n{\n\tstruct tcf_result res;\n\tint result;\n\n\tresult = tcf_classify(skb, fl, &res, false);\n\tif (result >= 0) {\n#ifdef CONFIG_NET_CLS_ACT\n\t\tswitch (result) {\n\t\tcase TC_ACT_STOLEN:\n\t\tcase TC_ACT_QUEUED:\n\t\tcase TC_ACT_TRAP:\n\t\t\t*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;\n\t\t\t/* fall through */\n\t\tcase TC_ACT_SHOT:\n\t\t\treturn false;\n\t\t}\n#endif\n\t\t*salt = TC_H_MIN(res.classid);\n\t\treturn true;\n\t}\n\treturn false;\n}",
        "output": "0",
        "idx": 3021
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "auto ReferenceHandle::Get(Local<Value> key_handle, MaybeLocal<Object> maybe_options) -> Local<Value> {\n\treturn ThreePhaseTask::Run<async, GetRunner>(*isolate, *this, key_handle, maybe_options, inherit);\n}",
        "output": "1",
        "idx": 2718
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_ns_and_type_ex(xmlNodePtr node, char *ns, char *type)\n{\n\tsmart_str nstype = {0};\n\tget_type_str(node, ns, type, &nstype);\n\tset_xsi_type(node, nstype.c);\n\tsmart_str_free(&nstype);\n}",
        "output": "0",
        "idx": 551
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tstruct s_smc *smc = netdev_priv(dev);\n\tskfddi_priv *lp = &smc->os;\n\tstruct s_skfp_ioctl ioc;\n\tint status = 0;\n\n\tif (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))\n\t\treturn -EFAULT;\n\n\tswitch (ioc.cmd) {\n\tcase SKFP_GET_STATS:\t/* Get the driver statistics */\n\t\tioc.len = sizeof(lp->MacStat);\n\t\tstatus = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)\n\t\t\t\t? -EFAULT : 0;\n\t\tbreak;\n\tcase SKFP_CLR_STATS:\t/* Zero out the driver statistics */\n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tmemset(&lp->MacStat, 0, sizeof(lp->MacStat));\n\t\t} else {\n\t\t\tstatus = -EPERM;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"ioctl for %s: unknow cmd: %04x\\n\", dev->name, ioc.cmd);\n\t\tstatus = -EOPNOTSUPP;\n\n\t}\t\t\t// switch\n\n\treturn status;\n}\t\t\t\t// skfp_ioctl",
        "output": "1",
        "idx": 3632
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "network_init ()\n{\n#ifdef HAVE_GNUTLS\n    char *ca_path, *ca_path2;\n\n    gnutls_global_init ();\n    gnutls_certificate_allocate_credentials (&gnutls_xcred);\n    \n    ca_path = string_expand_home (CONFIG_STRING(config_network_gnutls_ca_file));\n    if (ca_path)\n    {\n        ca_path2 = string_replace (ca_path, \"%h\", weechat_home);\n        if (ca_path2)\n        {\n            gnutls_certificate_set_x509_trust_file (gnutls_xcred, ca_path2,\n                                                    GNUTLS_X509_FMT_PEM);\n            free (ca_path2);\n        }\n        free (ca_path);\n    }\n    gnutls_certificate_client_set_retrieve_function (gnutls_xcred,\n                                                     &hook_connect_gnutls_set_certificates);\n    network_init_ok = 1;\n#endif\n#ifdef HAVE_GCRYPT\n    gcry_check_version (GCRYPT_VERSION);\n    gcry_control (GCRYCTL_DISABLE_SECMEM, 0);\n    gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n}",
        "output": "1",
        "idx": 133
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tcp_v6_reqsk_destructor(struct request_sock *req)\n{\n\tkfree(inet_rsk(req)->ipv6_opt);\n\tkfree_skb(inet_rsk(req)->pktopts);\n}",
        "output": "0",
        "idx": 2294
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rose_start_t1timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tdel_timer(&rose->timer);\n\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t1;\n\n\tadd_timer(&rose->timer);\n}",
        "output": "1",
        "idx": 394
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err gf_bin128_parse(const char *string, bin128 value)\n{\n\tu32 len;\n\tu32\ti=0;\n\tif (!strnicmp(string, \"0x\", 2)) string += 2;\n\tlen = (u32) strlen(string);\n\tif (len >= 32) {\n\t\tu32 j;\n\t\tfor (j=0; j<len; j+=2) {\n\t\t\tu32 v;\n\t\t\tchar szV[5];\n\n\t\t\twhile (string[j] && !isalnum(string[j]))\n\t\t\t\tj++;\n\t\t\tif (!string[j])\n\t\t\t\tbreak;\n\t\t\tsprintf(szV, \"%c%c\", string[j], string[j+1]);\n\t\t\tsscanf(szV, \"%x\", &v);\n\t\t\tvalue[i] = v;\n\t\t\ti++;\n\t\t}\n\t}\n\tif (i != 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[CORE] 128bit blob is not 16-bytes long: %s\\n\", string));\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}",
        "output": "1",
        "idx": 260
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_copyDropTableSpaceStmt(const DropTableSpaceStmt *from)\n{\n\tDropTableSpaceStmt *newnode = makeNode(DropTableSpaceStmt);\n\n\tCOPY_STRING_FIELD(tablespacename);\n\tCOPY_SCALAR_FIELD(missing_ok);\n\n\treturn newnode;\n}",
        "output": "0",
        "idx": 251
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NetClientState *qemu_get_subqueue(NICState *nic, int queue_index)\n{\n    return nic->ncs + queue_index;\n}",
        "output": "0",
        "idx": 2728
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rtreeCheckReset(RtreeCheck *pCheck, sqlite3_stmt *pStmt){\n  int rc = sqlite3_reset(pStmt);\n  if( pCheck->rc==SQLITE_OK ) pCheck->rc = rc;\n}",
        "output": "0",
        "idx": 718
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char *crypto_default_geniv(const struct crypto_alg *alg)\n{\n\tif (((alg->cra_flags & CRYPTO_ALG_TYPE_MASK) ==\n\t     CRYPTO_ALG_TYPE_BLKCIPHER ? alg->cra_blkcipher.ivsize :\n\t\t\t\t\t alg->cra_ablkcipher.ivsize) !=\n\t    alg->cra_blocksize)\n\t\treturn \"chainiv\";\n\n\treturn alg->cra_flags & CRYPTO_ALG_ASYNC ?\n\t       \"eseqiv\" : skcipher_default_geniv;\n}",
        "output": "0",
        "idx": 704
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Bigint *\nBalloc(int k)\n{\n    int x;\n    Bigint *rv;\n#ifndef Omit_Private_Memory\n    size_t len;\n#endif\n\n    ACQUIRE_DTOA_LOCK(0);\n    if ((rv = freelist[k]) != 0) {\n        freelist[k] = rv->next;\n    }\n    else {\n        x = 1 << k;\n#ifdef Omit_Private_Memory\n        rv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(ULong));\n#else\n        len = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)\n                /sizeof(double);\n        if (pmem_next - private_mem + len <= PRIVATE_mem) {\n            rv = (Bigint*)pmem_next;\n            pmem_next += len;\n        }\n        else\n            rv = (Bigint*)MALLOC(len*sizeof(double));\n#endif\n        rv->k = k;\n        rv->maxwds = x;\n    }\n    FREE_DTOA_LOCK(0);\n    rv->sign = rv->wds = 0;\n    return rv;",
        "output": "1",
        "idx": 1883
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *alg,\n                                      X509_ALGOR **pmaskHash)\n{\n    const unsigned char *p;\n    int plen;\n    RSA_PSS_PARAMS *pss;\n\n    *pmaskHash = NULL;\n\n    if (!alg->parameter || alg->parameter->type != V_ASN1_SEQUENCE)\n        return NULL;\n    p = alg->parameter->value.sequence->data;\n    plen = alg->parameter->value.sequence->length;\n    pss = d2i_RSA_PSS_PARAMS(NULL, &p, plen);\n\n    if (!pss)\n        return NULL;\n\n    if (pss->maskGenAlgorithm) {\n        ASN1_TYPE *param = pss->maskGenAlgorithm->parameter;\n        if (OBJ_obj2nid(pss->maskGenAlgorithm->algorithm) == NID_mgf1\n            && param->type == V_ASN1_SEQUENCE) {\n            p = param->value.sequence->data;\n            plen = param->value.sequence->length;\n            *pmaskHash = d2i_X509_ALGOR(NULL, &p, plen);\n        }\n    }\n\n    return pss;\n}",
        "output": "1",
        "idx": 2142
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void term_destination (j_compress_ptr cinfo)\n{\n\tmy_dest_ptr dest = (my_dest_ptr) cinfo->dest;\n\tsize_t datacount = OUTPUT_BUF_SIZE - dest->pub.free_in_buffer;\n\n\t/* Write any data remaining in the buffer */\n\tif (datacount > 0 && ((size_t)gdPutBuf (dest->buffer, datacount, dest->outfile) != datacount)) {\n\t\tERREXIT (cinfo, JERR_FILE_WRITE);\n\t}\n}",
        "output": "0",
        "idx": 1317
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tftp_send_next_block(struct tftp_session *spt,\n                                 struct tftp_t *recv_tp)\n{\n    struct mbuf *m;\n    struct tftp_t *tp;\n    int nobytes;\n\n    m = m_get(spt->slirp);\n\n    if (!m) {\n        return;\n    }\n\n    tp = tftp_prep_mbuf_data(spt, m);\n\n    tp->tp_op = htons(TFTP_DATA);\n    tp->x.tp_data.tp_block_nr = htons((spt->block_nr + 1) & 0xffff);\n\n    nobytes = tftp_read_data(spt, spt->block_nr, tp->x.tp_data.tp_buf,\n                             spt->block_size);\n\n    if (nobytes < 0) {\n        m_free(m);\n\n        /* send \"file not found\" error back */\n\n        tftp_send_error(spt, 1, \"File not found\", tp);\n\n        return;\n    }\n\n    m->m_len = sizeof(struct tftp_t) - (TFTP_BLOCKSIZE_MAX - nobytes) -\n               sizeof(struct udphdr);\n    tftp_udp_output(spt, m, recv_tp);\n\n    if (nobytes == spt->block_size) {\n        tftp_session_update(spt);\n    } else {\n        tftp_session_terminate(spt);\n    }\n\n    spt->block_nr++;\n}",
        "output": "1",
        "idx": 1349
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void QPaintEngineEx::drawLines(const QLineF *lines, int lineCount)\n{\n    int elementCount = lineCount << 1;\n    while (elementCount > 0) {\n        int count = qMin(elementCount, 32);\n\n        QVectorPath path((const qreal *) lines, count, qpaintengineex_line_types_16,\n                         QVectorPath::LinesHint);\n        stroke(path, state()->pen);\n\n        elementCount -= 32;\n        lines += 16;\n    }\n}",
        "output": "0",
        "idx": 1067
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  const TracingConnectionManagerConfig* tracingConfig() override { return tracing_config_.get(); }",
        "output": "0",
        "idx": 2239
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __exit inet6_exit(void)\n{\n\tif (disable_ipv6_mod)\n\t\treturn;\n\n\t/* First of all disallow new sockets creation. */\n\tsock_unregister(PF_INET6);\n\t/* Disallow any further netlink messages */\n\trtnl_unregister_all(PF_INET6);\n\n\tudpv6_exit();\n\tudplitev6_exit();\n\ttcpv6_exit();\n\n\t/* Cleanup code parts. */\n\tipv6_packet_cleanup();\n\tipv6_frag_exit();\n\tipv6_exthdrs_exit();\n\taddrconf_cleanup();\n\tip6_flowlabel_cleanup();\n\tip6_route_cleanup();\n#ifdef CONFIG_PROC_FS\n\n\t/* Cleanup code parts. */\n\tif6_proc_exit();\n\tipv6_misc_proc_exit();\n\tudplite6_proc_exit();\n\traw6_proc_exit();\n#endif\n\tipv6_netfilter_fini();\n\tigmp6_cleanup();\n\tndisc_cleanup();\n\tip6_mr_cleanup();\n\ticmpv6_cleanup();\n\trawv6_exit();\n\n\tunregister_pernet_subsys(&inet6_net_ops);\n\tproto_unregister(&rawv6_prot);\n\tproto_unregister(&udplitev6_prot);\n\tproto_unregister(&udpv6_prot);\n\tproto_unregister(&tcpv6_prot);\n\n\trcu_barrier(); /* Wait for completion of call_rcu()'s */\n}",
        "output": "1",
        "idx": 3143
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool io_wq_work_match_all(struct io_wq_work *work, void *data)\n{\n\treturn true;\n}",
        "output": "0",
        "idx": 391
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n{\n    pair_t *pair;\n    size_t hash;\n    bucket_t *bucket;\n\n    hash = hash_str(key);\n    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return NULL;\n\n    return &pair->list;\n}",
        "output": "1",
        "idx": 622
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(pcntl_strerror)\n{\n        long error;\n\n        if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &error) == FAILURE) {\n                RETURN_FALSE;\n        }\n\n        RETURN_STRING(strerror(error), 1);\n}",
        "output": "0",
        "idx": 672
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jas_icccurv_input(jas_iccattrval_t *attrval, jas_stream_t *in,\n  int cnt)\n{\n\tjas_icccurv_t *curv = &attrval->data.curv;\n\tunsigned int i;\n\n\tcurv->numents = 0;\n\tcurv->ents = 0;\n\n\tif (jas_iccgetuint32(in, &curv->numents))\n\t\tgoto error;\n\tif (!(curv->ents = jas_malloc(curv->numents * sizeof(jas_iccuint16_t))))\n\t\tgoto error;\n\tfor (i = 0; i < curv->numents; ++i) {\n\t\tif (jas_iccgetuint16(in, &curv->ents[i]))\n\t\t\tgoto error;\n\t}\n\n\tif (JAS_CAST(int, 4 + 2 * curv->numents) != cnt)\n\t\tgoto error;\n\treturn 0;\n\nerror:\n\tjas_icccurv_destroy(attrval);\n\treturn -1;\n}",
        "output": "1",
        "idx": 3681
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int gem_context_register(struct i915_gem_context *ctx,\n\t\t\t\tstruct drm_i915_file_private *fpriv)\n{\n\tint ret;\n\n\tctx->file_priv = fpriv;\n\tif (ctx->ppgtt)\n\t\tctx->ppgtt->vm.file = fpriv;\n\n\tctx->pid = get_task_pid(current, PIDTYPE_PID);\n\tctx->name = kasprintf(GFP_KERNEL, \"%s[%d]\",\n\t\t\t      current->comm, pid_nr(ctx->pid));\n\tif (!ctx->name) {\n\t\tret = -ENOMEM;\n\t\tgoto err_pid;\n\t}\n\n\t/* And finally expose ourselves to userspace via the idr */\n\tret = idr_alloc(&fpriv->context_idr, ctx,\n\t\t\tDEFAULT_CONTEXT_HANDLE, 0, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto err_name;\n\n\tctx->user_handle = ret;\n\n\treturn 0;\n\nerr_name:\n\tkfree(fetch_and_zero(&ctx->name));\nerr_pid:\n\tput_pid(fetch_and_zero(&ctx->pid));\n\treturn ret;\n}",
        "output": "1",
        "idx": 3077
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "f_pyeval(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n\n    if (p_pyx == 0)\n\tp_pyx = 2;\n\n    str = tv_get_string_buf(&argvars[0], buf);\n    do_pyeval(str, rettv);\n}",
        "output": "1",
        "idx": 1520
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\tSilenceMessage(const std::string& mask, const std::string& flags)\n\t\t: ClientProtocol::Message(\"SILENCE\")\n\t{\n\t\tPushParam(mask);\n\t\tPushParam(flags);\n\t}",
        "output": "0",
        "idx": 3308
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool LBPEvaluator::Feature :: read(const FileNode& node )\n{\n    FileNode rnode = node[CC_RECT];\n    FileNodeIterator it = rnode.begin();\n    it >> rect.x >> rect.y >> rect.width >> rect.height;\n    return true;\n}",
        "output": "1",
        "idx": 3714
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    bool contains(const T& pixel, t& x, t& y, t& z) const {\n      const ulongT wh = (ulongT)_width*_height, whd = wh*_depth, siz = whd*_spectrum;\n      const T *const ppixel = &pixel;\n      if (is_empty() || ppixel<_data || ppixel>=_data + siz) return false;\n      ulongT off = ((ulongT)(ppixel - _data))%whd;\n      const ulongT nz = off/wh;\n      off%=wh;\n      const ulongT ny = off/_width, nx = off%_width;\n      x = (t)nx; y = (t)ny; z = (t)nz;\n      return true;\n    }",
        "output": "0",
        "idx": 2420
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PS_CREATE_SID_FUNC(mm)\n{\n\tchar *sid;\n\tint maxfail = 3;\n\tPS_MM_DATA;\n\n\tdo {\n\t\tsid = php_session_create_id((void **)&data, newlen TSRMLS_CC);\n\t\t/* Check collision */\n\t\tif (ps_mm_key_exists(data, sid TSRMLS_CC) == SUCCESS) {\n\t\t\tif (sid) {\n\t\t\t\tefree(sid);\n\t\t\t\tsid = NULL;\n\t\t\t}\n\t\t\tif (!(maxfail--)) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t} while(!sid);\n\n\treturn sid;\n}",
        "output": "0",
        "idx": 2371
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int virtbt_setup_realtek(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\n\t/* Read ROM Version */\n\tskb = __hci_cmd_sync(hdev, 0xfc6d, 0, NULL, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tbt_dev_info(hdev, \"ROM version %u\", *((__u8 *) (skb->data + 1)));\n\n\tkfree_skb(skb);\n\treturn 0;\n}",
        "output": "0",
        "idx": 1988
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void net_tx_pkt_dump(struct NetTxPkt *pkt)\n{\n#ifdef NET_TX_PKT_DEBUG\n    assert(pkt);\n\n    printf(\"TX PKT: hdr_len: %d, pkt_type: 0x%X, l2hdr_len: %lu, \"\n        \"l3hdr_len: %lu, payload_len: %u\\n\", pkt->hdr_len, pkt->packet_type,\n        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len,\n        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len, pkt->payload_len);\n#endif\n}",
        "output": "0",
        "idx": 1635
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ip_vs_lookup_real_service(int af, __u16 protocol,\n\t\t\t  const union nf_inet_addr *daddr,\n\t\t\t  __be16 dport)\n{\n\tunsigned hash;\n\tstruct ip_vs_dest *dest;\n\n\t/*\n\t *\tCheck for \"full\" addressed entries\n\t *\tReturn the first found entry\n\t */\n\thash = ip_vs_rs_hashkey(af, daddr, dport);\n\n\tread_lock(&__ip_vs_rs_lock);\n\tlist_for_each_entry(dest, &ip_vs_rtable[hash], d_list) {\n\t\tif ((dest->af == af)\n\t\t    && ip_vs_addr_equal(af, &dest->addr, daddr)\n\t\t    && (dest->port == dport)\n\t\t    && ((dest->protocol == protocol) ||\n\t\t\tdest->vfwmark)) {\n\t\t\t/* HIT */\n\t\t\tread_unlock(&__ip_vs_rs_lock);\n\t\t\treturn dest;\n\t\t}\n\t}\n\tread_unlock(&__ip_vs_rs_lock);\n\n\treturn NULL;\n}",
        "output": "0",
        "idx": 2207
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t pipe_get_pages(struct iov_iter *i,\n\t\t   struct page **pages, size_t maxsize, unsigned maxpages,\n\t\t   size_t *start)\n{\n\tunsigned int iter_head, npages;\n\tsize_t capacity;\n\n\tif (!sanity(i))\n\t\treturn -EFAULT;\n\n\tdata_start(i, &iter_head, start);\n\t/* Amount of free space: some of this one + all after this one */\n\tnpages = pipe_space_for_user(iter_head, i->pipe->tail, i->pipe);\n\tcapacity = min(npages, maxpages) * PAGE_SIZE - *start;\n\n\treturn __pipe_get_pages(i, min(maxsize, capacity), pages, iter_head, start);\n}",
        "output": "0",
        "idx": 759
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rb_str_buf_cat2(str, ptr)\n    VALUE str;\n    const char *ptr;\n{\n    return rb_str_buf_cat(str, ptr, strlen(ptr));\n}",
        "output": "0",
        "idx": 2079
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void process_blob(struct rev_info *revs,\n\t\t\t struct blob *blob,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *path,\n\t\t\t const char *name,\n\t\t\t void *cb_data)\n{\n\tstruct object *obj = &blob->object;\n\n\tif (!revs->blob_objects)\n\t\treturn;\n\tif (!obj)\n\t\tdie(\"bad blob object\");\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn;\n\tobj->flags |= SEEN;\n\tshow(obj, path, name, cb_data);\n}",
        "output": "1",
        "idx": 3117
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static size_t php_bz2iop_read(php_stream *stream, char *buf, size_t count TSRMLS_DC)\n{\n\tstruct php_bz2_stream_data_t *self = (struct php_bz2_stream_data_t *) stream->abstract;\n\tsize_t ret;\n\t\n\tret = BZ2_bzread(self->bz_file, buf, count);\n\n\tif (ret == 0) {\n\t\tstream->eof = 1;\n\t}\n\n\treturn ret;\n}",
        "output": "1",
        "idx": 1010
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "set_unused_field_bp(unsigned char *bp, int from, int to)\n{\n\tmemset(bp + from, 0, to - from + 1);\n}",
        "output": "0",
        "idx": 652
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct timerqueue_node *timerqueue_getnext(struct timerqueue_head *head)\n{\n\treturn head->next;\n}",
        "output": "1",
        "idx": 725
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void svm_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)\n{\n\treturn;\n}",
        "output": "0",
        "idx": 1401
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RsaAdjustPrimeCandidate(\n\t\t\tbigNum          prime,\n\t\t\tSEED_COMPAT_LEVEL seedCompatLevel  // IN: compatibility level; libtpms added\n\t\t\t)\n{\n    switch (seedCompatLevel) {\n    case SEED_COMPAT_LEVEL_ORIGINAL:\n        RsaAdjustPrimeCandidate_PreRev155(prime);\n        break;\n    /* case SEED_COMPAT_LEVEL_LAST: */\n    case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX:\n        RsaAdjustPrimeCandidate_New(prime);\n        break;\n    default:\n        FAIL(FATAL_ERROR_INTERNAL);\n    }\n}",
        "output": "1",
        "idx": 118
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {\n\t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\t\tcomplete(&task->slow_task->completion);\n\t}\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n}",
        "output": "0",
        "idx": 2690
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CopySendString(CopyState cstate, const char *str)\n{\n\tappendBinaryStringInfo(cstate->fe_msgbuf, str, strlen(str));\n}",
        "output": "0",
        "idx": 875
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool bvec_gap_to_prev(struct request_queue *q,\n\t\tstruct bio_vec *bprv, unsigned int offset)\n{\n\tif (!queue_virt_boundary(q))\n\t\treturn false;\n\treturn __bvec_gap_to_prev(q, bprv, offset);\n}",
        "output": "0",
        "idx": 3721
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "handle_raw_ping(struct query *q, int dns_fd, int userid)\n{\n\tif (check_user_and_ip(userid, q) != 0) {\n\t\treturn;\n\t}\n\n\t/* Update query and time info for user */\n\tusers[userid].last_pkt = time(NULL);\n\tmemcpy(&(users[userid].q), q, sizeof(struct query));\n\n\tif (debug >= 1) {\n\t\tfprintf(stderr, \"IN   ping raw, from user %d\\n\", userid);\n\t}\n\n\t/* Send ping reply */\n\tsend_raw(dns_fd, NULL, 0, userid, RAW_HDR_CMD_PING, q);\n}",
        "output": "1",
        "idx": 510
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cp1251_get_case_fold_codes_by_str(OnigCaseFoldType flag,\n    const OnigUChar* p, const OnigUChar* end, OnigCaseFoldCodeItem items[])\n{\n  return onigenc_get_case_fold_codes_by_str_with_map(\n\t     sizeof(CaseFoldMap)/sizeof(OnigPairCaseFoldCodes), CaseFoldMap, 0,\n\t     flag, p, end, items);\n}",
        "output": "0",
        "idx": 188
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int qrtr_connect(struct socket *sock, struct sockaddr *saddr,\n\t\t\tint len, int flags)\n{\n\tDECLARE_SOCKADDR(struct sockaddr_qrtr *, addr, saddr);\n\tstruct qrtr_sock *ipc = qrtr_sk(sock->sk);\n\tstruct sock *sk = sock->sk;\n\tint rc;\n\n\tif (len < sizeof(*addr) || addr->sq_family != AF_QIPCRTR)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tsk->sk_state = TCP_CLOSE;\n\tsock->state = SS_UNCONNECTED;\n\n\trc = qrtr_autobind(sock);\n\tif (rc) {\n\t\trelease_sock(sk);\n\t\treturn rc;\n\t}\n\n\tipc->peer = *addr;\n\tsock->state = SS_CONNECTED;\n\tsk->sk_state = TCP_ESTABLISHED;\n\n\trelease_sock(sk);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2118
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gdm_session_authorize (GdmSession *self,\n                       const char *service_name)\n{\n        GdmSessionConversation *conversation;\n\n        g_return_if_fail (GDM_IS_SESSION (self));\n\n        conversation = find_conversation_by_name (self, service_name);\n        if (conversation != NULL) {\n                gdm_dbus_worker_call_authorize (conversation->worker_proxy,\n                                                NULL,\n                                                (GAsyncReadyCallback) on_authorize_cb,\n                                                conversation);\n        }\n}",
        "output": "1",
        "idx": 493
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int uvc_reset_resume(struct usb_interface *intf)\n{\n\treturn __uvc_resume(intf, 1);\n}",
        "output": "0",
        "idx": 1805
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QPDFWriter::unparseObject(QPDFObjectHandle object, int level,\n\t\t\t  unsigned int flags)\n{\n    unparseObject(object, level, flags, 0, false);\n}",
        "output": "1",
        "idx": 3561
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TPMI_SH_AUTH_SESSION_Unmarshal(TPMI_SH_AUTH_SESSION *target, BYTE **buffer, INT32 *size, BOOL allowPwd)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPM_HANDLE_Unmarshal(target, buffer, size);  \n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tBOOL isNotHmacSession = (*target < HMAC_SESSION_FIRST ) || (*target > HMAC_SESSION_LAST);\n\tBOOL isNotPolicySession = (*target < POLICY_SESSION_FIRST) || (*target > POLICY_SESSION_LAST);\n\tBOOL isNotLegalPwd = (*target != TPM_RS_PW) || !allowPwd;\n\tif (isNotHmacSession &&\n\t    isNotPolicySession &&\n\t    isNotLegalPwd) {\n\t    rc = TPM_RC_VALUE;\n\t}\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 3009
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int options_parse(CONF_TYPE type) {\n    SERVICE_OPTIONS *section;\n\n    options_defaults();\n    section=&new_service_options;\n    if(options_file(configuration_file, type, &section))\n        return 1;\n    if(init_section(1, &section))\n        return 1;\n\n    s_log(LOG_NOTICE, \"Configuration successful\");\n    return 0;\n}",
        "output": "1",
        "idx": 3287
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bgp_attr_atomic (struct peer *peer, bgp_size_t length, \n\t\t struct attr *attr, u_char flag, u_char *startp)\n{\n  bgp_size_t total;\n\n  total = length + (CHECK_FLAG (flag, BGP_ATTR_FLAG_EXTLEN) ? 4 : 3);\n  /* Flag checks. */\n  if (bgp_attr_flag_invalid (peer, BGP_ATTR_ATOMIC_AGGREGATE, flag))\n    return bgp_attr_malformed (peer, BGP_ATTR_ATOMIC_AGGREGATE, flag,\n                               BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,\n                               startp, total);\n  \n  /* Length check. */\n  if (length != 0)\n    {\n      zlog (peer->log, LOG_ERR, \"ATOMIC_AGGREGATE attribute length isn't 0 [%u]\", length);\n      return bgp_attr_malformed (peer, BGP_ATTR_ATOMIC_AGGREGATE, flag,\n                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n                                 startp, total);\n    }\n\n  /* Set atomic aggregate flag. */\n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE);\n\n  return BGP_ATTR_PARSE_PROCEED;\n}",
        "output": "1",
        "idx": 1087
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "output_buffer& HandShakeBase::get(output_buffer& out) const\n{\n    return out;\n}",
        "output": "0",
        "idx": 2344
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int i2d_TS_RESP_fp(FILE *fp, TS_RESP *a)\n\t{\n\treturn ASN1_i2d_fp(i2d_TS_RESP, fp, (unsigned char *) a);\n\t}",
        "output": "0",
        "idx": 1231
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int get_compat_mq_attr(struct mq_attr *attr,\n\t\t\tconst struct compat_mq_attr __user *uattr)\n{\n\tstruct compat_mq_attr v;\n\n\tif (copy_from_user(&v, uattr, sizeof(*uattr)))\n\t\treturn -EFAULT;\n\n\tmemset(attr, 0, sizeof(*attr));\n\tattr->mq_flags = v.mq_flags;\n\tattr->mq_maxmsg = v.mq_maxmsg;\n\tattr->mq_msgsize = v.mq_msgsize;\n\tattr->mq_curmsgs = v.mq_curmsgs;\n\treturn 0;\n}",
        "output": "0",
        "idx": 371
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bdrv_acct_start(BlockDriverState *bs, BlockAcctCookie *cookie, int64_t bytes,\n        enum BlockAcctType type)\n{\n    assert(type < BDRV_MAX_IOTYPE);\n\n    cookie->bytes = bytes;\n    cookie->start_time_ns = get_clock();\n    cookie->type = type;\n}",
        "output": "0",
        "idx": 3433
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pq_setkeepaliveswin32(Port *port, int idle, int interval)\n{\n\tstruct tcp_keepalive ka;\n\tDWORD\t\tretsize;\n\n\tif (idle <= 0)\n\t\tidle = 2 * 60 * 60;\t\t/* default = 2 hours */\n\tif (interval <= 0)\n\t\tinterval = 1;\t\t\t/* default = 1 second */\n\n\tka.onoff = 1;\n\tka.keepalivetime = idle * 1000;\n\tka.keepaliveinterval = interval * 1000;\n\n\tif (WSAIoctl(port->sock,\n\t\t\t\t SIO_KEEPALIVE_VALS,\n\t\t\t\t (LPVOID) &ka,\n\t\t\t\t sizeof(ka),\n\t\t\t\t NULL,\n\t\t\t\t 0,\n\t\t\t\t &retsize,\n\t\t\t\t NULL,\n\t\t\t\t NULL)\n\t\t!= 0)\n\t{\n\t\telog(LOG, \"WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui\",\n\t\t\t WSAGetLastError());\n\t\treturn STATUS_ERROR;\n\t}\n\tif (port->keepalives_idle != idle)\n\t\tport->keepalives_idle = idle;\n\tif (port->keepalives_interval != interval)\n\t\tport->keepalives_interval = interval;\n\treturn STATUS_OK;\n}",
        "output": "0",
        "idx": 1595
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ext4_valid_extent(struct inode *inode, struct ext4_extent *ext)\n{\n\text4_fsblk_t block = ext4_ext_pblock(ext);\n\tint len = ext4_ext_get_actual_len(ext);\n\text4_lblk_t lblock = le32_to_cpu(ext->ee_block);\n\n\t/*\n\t * We allow neither:\n\t *  - zero length\n\t *  - overflow/wrap-around\n\t */\n\tif (lblock + len <= lblock)\n\t\treturn 0;\n\treturn ext4_data_block_valid(EXT4_SB(inode->i_sb), block, len);\n}",
        "output": "1",
        "idx": 475
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "read_timeout(void *arg)\n{\n  FILE *f;\n  double temp, comp;\n\n  f = fopen(filename, \"r\");\n\n  if (f && fscanf(f, \"%lf\", &temp) == 1) {\n    comp = get_tempcomp(temp);\n\n    if (fabs(comp) <= MAX_COMP) {\n      comp = LCL_SetTempComp(comp);\n\n      DEBUG_LOG(\"tempcomp updated to %f for %f\", comp, temp);\n\n      if (logfileid != -1) {\n        struct timespec now;\n\n        LCL_ReadCookedTime(&now, NULL);\n        LOG_FileWrite(logfileid, \"%s %11.4e %11.4e\",\n            UTI_TimeToLogForm(now.tv_sec), temp, comp);\n      }\n    } else {\n      LOG(LOGS_WARN, \"Temperature compensation of %.3f ppm exceeds sanity limit of %.1f\",\n          comp, MAX_COMP);\n    }\n  } else {\n    LOG(LOGS_WARN, \"Could not read temperature from %s\", filename);\n  }\n\n  if (f)\n    fclose(f);\n\n  timeout_id = SCH_AddTimeoutByDelay(update_interval, read_timeout, NULL);\n}",
        "output": "1",
        "idx": 2125
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void svhandler_flash_pgm_word(void) {\n  uint32_t dst = _param_1;\n  uint32_t src = _param_2;\n\n  // Do not allow firmware to erase bootstrap or bootloader sectors.\n  if ((dst >= BSTRP_FLASH_SECT_START) &&\n      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {\n    return;\n  }\n\n  if ((dst >= BLDR_FLASH_SECT_START) &&\n      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {\n    return;\n  }\n\n  // Unlock flash.\n  flash_clear_status_flags();\n  flash_unlock();\n\n  // Flash write.\n  flash_program_word(dst, src);\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n\n  // Wait for any write operation to complete.\n  flash_wait_for_last_operation();\n\n  // Disable writes to flash.\n  FLASH_CR &= ~FLASH_CR_PG;\n\n  // Lock flash register\n  FLASH_CR |= FLASH_CR_LOCK;\n}",
        "output": "1",
        "idx": 1497
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "__acquires(&pool->lock)\n{\nrestart:\n\tspin_unlock_irq(&pool->lock);\n\n\t/* if we don't make progress in MAYDAY_INITIAL_TIMEOUT, call for help */\n\tmod_timer(&pool->mayday_timer, jiffies + MAYDAY_INITIAL_TIMEOUT);\n\n\twhile (true) {\n\t\tif (create_worker(pool) || !need_to_create_worker(pool))\n\t\t\tbreak;\n\n\t\tschedule_timeout_interruptible(CREATE_COOLDOWN);\n\n\t\tif (!need_to_create_worker(pool))\n\t\t\tbreak;\n\t}\n\n\tdel_timer_sync(&pool->mayday_timer);\n\tspin_lock_irq(&pool->lock);\n\t/*\n\t * This is necessary even after a new worker was just successfully\n\t * created as @pool->lock was dropped and the new worker might have\n\t * already become busy.\n\t */\n\tif (need_to_create_worker(pool))\n\t\tgoto restart;\n}",
        "output": "0",
        "idx": 2202
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_P(ProxyProtocolTest, V2ParseExtensions) {\n  // A well-formed ipv4/tcp with a pair of TLV extensions is accepted\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49,\n                                0x54, 0x0a, 0x21, 0x11, 0x00, 0x14, 0x01, 0x02, 0x03, 0x04,\n                                0x00, 0x01, 0x01, 0x02, 0x03, 0x05, 0x00, 0x02};\n  constexpr uint8_t tlv[] = {0x0, 0x0, 0x1, 0xff};\n\n  constexpr uint8_t data[] = {'D', 'A', 'T', 'A'};\n\n  connect();\n  write(buffer, sizeof(buffer));\n  dispatcher_->run(Event::Dispatcher::RunType::NonBlock);\n  for (int i = 0; i < 2; i++) {\n    write(tlv, sizeof(tlv));\n  }\n  write(data, sizeof(data));\n  expectData(\"DATA\");\n  disconnect();\n}",
        "output": "0",
        "idx": 2264
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int is_same_network(struct ieee80211_network *src,\n\t\t\t\t  struct ieee80211_network *dst)\n{\n\t/* A network is only a duplicate if the channel, BSSID, and ESSID\n\t * all match.  We treat all <hidden> with the same BSSID and channel\n\t * as one network */\n\treturn ((src->ssid_len == dst->ssid_len) &&\n\t\t(src->channel == dst->channel) &&\n\t\t!compare_ether_addr(src->bssid, dst->bssid) &&\n\t\t!memcmp(src->ssid, dst->ssid, src->ssid_len));\n}",
        "output": "0",
        "idx": 1615
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    CImg<Tfloat> get_resize_object3d() const {\n      return CImg<Tfloat>(*this,false).resize_object3d();\n    }",
        "output": "0",
        "idx": 2927
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned find_get_pages_tag(struct address_space *mapping, pgoff_t *index,\n\t\t\tint tag, unsigned int nr_pages, struct page **pages)\n{\n\tunsigned int i;\n\tunsigned int ret;\n\tunsigned int nr_found;\n\n\trcu_read_lock();\nrestart:\n\tnr_found = radix_tree_gang_lookup_tag_slot(&mapping->page_tree,\n\t\t\t\t(void ***)pages, *index, nr_pages, tag);\n\tret = 0;\n\tfor (i = 0; i < nr_found; i++) {\n\t\tstruct page *page;\nrepeat:\n\t\tpage = radix_tree_deref_slot((void **)pages[i]);\n\t\tif (unlikely(!page))\n\t\t\tcontinue;\n\t\t/*\n\t\t * this can only trigger if nr_found == 1, making livelock\n\t\t * a non issue.\n\t\t */\n\t\tif (unlikely(page == RADIX_TREE_RETRY))\n\t\t\tgoto restart;\n\n\t\tif (!page_cache_get_speculative(page))\n\t\t\tgoto repeat;\n\n\t\t/* Has the page moved? */\n\t\tif (unlikely(page != *((void **)pages[i]))) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tpages[ret] = page;\n\t\tret++;\n\t}\n\trcu_read_unlock();\n\n\tif (ret)\n\t\t*index = pages[ret - 1]->index + 1;\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 1788
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "init_syntax_once ()\n{\n   register int c;\n   static int done;\n\n   if (done)\n     return;\n\n   bzero (re_syntax_table, sizeof re_syntax_table);\n\n   for (c = 'a'; c <= 'z'; c++)\n     re_syntax_table[c] = Sword;\n\n   for (c = 'A'; c <= 'Z'; c++)\n     re_syntax_table[c] = Sword;\n\n   for (c = '0'; c <= '9'; c++)\n     re_syntax_table[c] = Sword;\n\n   re_syntax_table['_'] = Sword;\n\n   done = 1;\n}",
        "output": "1",
        "idx": 3512
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    inline CmdLine::CmdLine() :\n        port(DefaultDBPort), rest(false), jsonp(false), indexBuildRetry(true), quiet(false),\n        noTableScan(false), prealloc(true), preallocj(true), smallfiles(sizeof(int*) == 4),\n        configsvr(false), quota(false), quotaFiles(8), cpu(false),\n        durOptions(0), objcheck(false), oplogSize(0), defaultProfile(0),\n        slowMS(100), defaultLocalThresholdMillis(15), pretouch(0), moveParanoia( true ),\n        syncdelay(60), noUnixSocket(false), doFork(0), socket(\"/tmp\"), maxConns(DEFAULT_MAX_CONN),\n        logAppend(false), logWithSyslog(false)\n    {\n        started = time(0);\n\n        journalCommitInterval = 0; // 0 means use default\n        dur = false;\n#if defined(_DURABLEDEFAULTON)\n        dur = true;\n#endif\n        if( sizeof(void*) == 8 )\n            dur = true;\n#if defined(_DURABLEDEFAULTOFF)\n        dur = false;\n#endif\n\n#ifdef MONGO_SSL\n        sslOnNormalPorts = false;\n#endif\n    }",
        "output": "1",
        "idx": 696
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dev_disable_lro(struct net_device *dev)\n{\n\t/*\n\t * If we're trying to disable lro on a vlan device\n\t * use the underlying physical device instead\n\t */\n\tif (is_vlan_dev(dev))\n\t\tdev = vlan_dev_real_dev(dev);\n\n\t/* the same for macvlan devices */\n\tif (netif_is_macvlan(dev))\n\t\tdev = macvlan_dev_real_dev(dev);\n\n\tdev->wanted_features &= ~NETIF_F_LRO;\n\tnetdev_update_features(dev);\n\n\tif (unlikely(dev->features & NETIF_F_LRO))\n\t\tnetdev_WARN(dev, \"failed to disable LRO!\\n\");\n}",
        "output": "0",
        "idx": 874
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,\n                                          unsigned char *buf,\n                                          size_t *olen )\n{\n    unsigned char *p = buf;\n\n    if( ssl->handshake->new_session_ticket == 0 )\n    {\n        *olen = 0;\n        return;\n    }\n\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"server hello, adding session ticket extension\" ) );\n\n    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, p, 0 );\n    p += 2;\n\n    *p++ = 0x00;\n    *p++ = 0x00;\n\n    *olen = 4;\n}",
        "output": "0",
        "idx": 571
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CtcpParser::sendCtcpEvent(CtcpEvent *e) {\n  CoreNetwork *net = coreNetwork(e);\n  if(e->type() == EventManager::CtcpEvent) {\n    QByteArray quotedReply;\n    QString bufname = nickFromMask(e->prefix());\n    if(e->ctcpType() == CtcpEvent::Query && !e->reply().isNull()) {\n      if(_replies.contains(e->uuid()))\n        _replies[e->uuid()].replies << lowLevelQuote(pack(net->serverEncode(e->ctcpCmd()),\n                                                          net->userEncode(bufname, e->reply())));\n      else\n        // reply not caused by a request processed in here, so send it off immediately\n        reply(net, bufname, e->ctcpCmd(), e->reply());\n    }\n  } else if(e->type() == EventManager::CtcpEventFlush && _replies.contains(e->uuid())) {\n    CtcpReply reply = _replies.take(e->uuid());\n    if(reply.replies.count())\n      packedReply(net, reply.bufferName, reply.replies);\n  }\n}",
        "output": "0",
        "idx": 1765
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct razer_report razer_chroma_extended_matrix_get_brightness(unsigned char variable_storage, unsigned char led_id)\n{\n    struct razer_report report = get_razer_report(0x0F, 0x84, 0x03);\n    report.transaction_id.id = 0x3F;\n\n    report.arguments[0] = variable_storage;\n    report.arguments[1] = led_id;\n\n    return report;\n}",
        "output": "0",
        "idx": 2213
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void show_entry(struct diff_options *opt, const char *prefix, struct tree_desc *desc,\n\t\t       const char *base, int baselen)\n{\n\tunsigned mode;\n\tconst char *path;\n\tconst unsigned char *sha1 = tree_entry_extract(desc, &path, &mode);\n\n\tif (DIFF_OPT_TST(opt, RECURSIVE) && S_ISDIR(mode)) {\n\t\tenum object_type type;\n\t\tint pathlen = tree_entry_len(path, sha1);\n\t\tchar *newbase = malloc_base(base, baselen, path, pathlen);\n\t\tstruct tree_desc inner;\n\t\tvoid *tree;\n\t\tunsigned long size;\n\n\t\ttree = read_sha1_file(sha1, &type, &size);\n\t\tif (!tree || type != OBJ_TREE)\n\t\t\tdie(\"corrupt tree sha %s\", sha1_to_hex(sha1));\n\n\t\tinit_tree_desc(&inner, tree, size);\n\t\tshow_tree(opt, prefix, &inner, newbase, baselen + 1 + pathlen);\n\n\t\tfree(tree);\n\t\tfree(newbase);\n\t} else {\n\t\topt->add_remove(opt, prefix[0], mode, sha1, base, path);\n\t}\n}",
        "output": "1",
        "idx": 1940
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void MainWindow::removeCustomProfiles(const QStringList &profiles, QDir& dir, QMenu *menu, QAction *action)\n{\n    foreach(const QString& profile, profiles) {\n        // Remove the file.\n        dir.remove(profile);\n        // Locate the menu item.\n        foreach (QAction* a, menu->actions()) {\n            if (a->text() == profile) {\n                // Remove the menu item.\n                delete a;\n                break;\n            }\n        }\n    }\n    // If no more custom video modes.\n    if (menu->actions().size() == 3) {\n        // Remove the Remove action and separator.\n        menu->removeAction(action);\n        foreach (QAction* a, menu->actions()) {\n            if (a->isSeparator()) {\n                delete a;\n                break;\n            }\n        }\n    }\n}",
        "output": "0",
        "idx": 1813
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parse_content_range(URLContext *h, const char *p)\n{\n    HTTPContext *s = h->priv_data;\n    const char *slash;\n\n    if (!strncmp(p, \"bytes \", 6)) {\n        p     += 6;\n        s->off = strtoll(p, NULL, 10);\n        if ((slash = strchr(p, '/')) && strlen(slash) > 0)\n            s->filesize = strtoll(slash + 1, NULL, 10);\n    }\n    if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))\n        h->is_streamed = 0; /* we _can_ in fact seek */\n}",
        "output": "1",
        "idx": 3486
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_metadata_handler_start (RsvgSaxHandler * self, const char *name, RsvgPropertyBag * atts)\n{\n    RsvgSaxHandlerMetadata *z = (RsvgSaxHandlerMetadata *) self;\n    RsvgHandle *ctx = z->ctx;\n\n    g_string_append_printf (ctx->priv->metadata, \"<%s \", name);\n    rsvg_property_bag_enumerate (atts, rsvg_metadata_props_enumerate, ctx->priv->metadata);\n    g_string_append (ctx->priv->metadata, \">\\n\");\n}",
        "output": "0",
        "idx": 2844
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int encrypted_init(struct encrypted_key_payload *epayload,\n\t\t\t  const char *key_desc, const char *format,\n\t\t\t  const char *master_desc, const char *datalen,\n\t\t\t  const char *hex_encoded_iv)\n{\n\tint ret = 0;\n\n\tif (format && !strcmp(format, key_format_ecryptfs)) {\n\t\tret = valid_ecryptfs_desc(key_desc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tecryptfs_fill_auth_tok((struct ecryptfs_auth_tok *)epayload->payload_data,\n\t\t\t\t       key_desc);\n\t}\n\n\t__ekey_init(epayload, format, master_desc, datalen);\n\tif (!hex_encoded_iv) {\n\t\tget_random_bytes(epayload->iv, ivsize);\n\n\t\tget_random_bytes(epayload->decrypted_data,\n\t\t\t\t epayload->decrypted_datalen);\n\t} else\n\t\tret = encrypted_key_decrypt(epayload, format, hex_encoded_iv);\n\treturn ret;\n}",
        "output": "0",
        "idx": 1780
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void isis_notif_lsp_error(const struct isis_circuit *circuit,\n\t\t\t  const uint8_t *lsp_id, const char *raw_pdu,\n\t\t\t  size_t raw_pdu_len,\n\t\t\t  __attribute__((unused)) uint32_t offset,\n\t\t\t  __attribute__((unused)) uint8_t tlv_type)\n{\n\tconst char *xpath = \"/frr-isisd:lsp-error-detected\";\n\tstruct list *arguments = yang_data_list_new();\n\tchar xpath_arg[XPATH_MAXLEN];\n\tstruct yang_data *data;\n\tstruct isis_area *area = circuit->area;\n\n\tnotif_prep_instance_hdr(xpath, area, \"default\", arguments);\n\tnotif_prepr_iface_hdr(xpath, circuit, arguments);\n\tsnprintf(xpath_arg, sizeof(xpath_arg), \"%s/lsp-id\", xpath);\n\tdata = yang_data_new_string(xpath_arg, rawlspid_print(lsp_id));\n\tlistnode_add(arguments, data);\n\tsnprintf(xpath_arg, sizeof(xpath_arg), \"%s/raw-pdu\", xpath);\n\tdata = yang_data_new(xpath_arg, raw_pdu);\n\tlistnode_add(arguments, data);\n\t/* ignore offset and tlv_type which cannot be set properly */\n\n\thook_call(isis_hook_lsp_error, circuit, lsp_id, raw_pdu, raw_pdu_len);\n\n\tnb_notification_send(xpath, arguments);\n}",
        "output": "1",
        "idx": 2948
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void free_nested(struct vcpu_vmx *vmx)\n{\n\tif (!vmx->nested.vmxon)\n\t\treturn;\n\n\tvmx->nested.vmxon = false;\n\tnested_release_vmcs12(vmx);\n\tif (enable_shadow_vmcs)\n\t\tfree_vmcs(vmx->nested.current_shadow_vmcs);\n\t/* Unpin physical memory we referred to in current vmcs02 */\n\tif (vmx->nested.apic_access_page) {\n\t\tnested_release_page(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page = NULL;\n\t}\n\tif (vmx->nested.virtual_apic_page) {\n\t\tnested_release_page(vmx->nested.virtual_apic_page);\n\t\tvmx->nested.virtual_apic_page = NULL;\n\t}\n\n\tnested_free_all_saved_vmcss(vmx);\n}",
        "output": "0",
        "idx": 1110
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int parse_value_and_bound(const string &input, long *output, const long lower_bound, const long upper_bound, const long default_val)\n{\n  if (!input.empty()) {\n    char *endptr;\n    *output = strtol(input.c_str(), &endptr, 10);\n    if (endptr) {\n      if (endptr == input.c_str()) return -EINVAL;\n      while (*endptr && isspace(*endptr)) // ignore white space\n        endptr++;\n      if (*endptr) {\n        return -EINVAL;\n      }\n    }\n    if(*output > upper_bound) {\n      *output = upper_bound;\n    }\n    if(*output < lower_bound) {\n      *output = lower_bound;\n    }\n  } else {\n    *output = default_val;\n  }\n\n  return 0;\n}",
        "output": "1",
        "idx": 488
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static RzList *relocs(RzBinFile *bf) {\n\trz_return_val_if_fail(bf && bf->o, NULL);\n\tQnxObj *qo = bf->o->bin_obj;\n\treturn rz_list_clone(qo->fixups);\n}",
        "output": "1",
        "idx": 1254
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "f_listener_flush(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    buf_T\t*buf = curbuf;\n\n    if (in_vim9script() && check_for_opt_buffer_arg(argvars, 0) == FAIL)\n\treturn;\n\n    if (argvars[0].v_type != VAR_UNKNOWN)\n    {\n\tbuf = get_buf_arg(&argvars[0]);\n\tif (buf == NULL)\n\t    return;\n    }\n    invoke_listeners(buf);\n}",
        "output": "0",
        "idx": 1295
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_seq_ioctl_running_mode(struct snd_seq_client *client, void  *arg)\n{\n\tstruct snd_seq_running_info *info = arg;\n\tstruct snd_seq_client *cptr;\n\tint err = 0;\n\n\t/* requested client number */\n\tcptr = snd_seq_client_use_ptr(info->client);\n\tif (cptr == NULL)\n\t\treturn -ENOENT;\t\t/* don't change !!! */\n\n#ifdef SNDRV_BIG_ENDIAN\n\tif (!info->big_endian) {\n\t\terr = -EINVAL;\n\t\tgoto __err;\n\t}\n#else\n\tif (info->big_endian) {\n\t\terr = -EINVAL;\n\t\tgoto __err;\n\t}\n\n#endif\n\tif (info->cpu_mode > sizeof(long)) {\n\t\terr = -EINVAL;\n\t\tgoto __err;\n\t}\n\tcptr->convert32 = (info->cpu_mode < sizeof(long));\n __err:\n\tsnd_seq_client_unlock(cptr);\n\treturn err;\n}",
        "output": "0",
        "idx": 3702
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u64 *fast_pf_get_last_sptep(struct kvm_vcpu *vcpu, gpa_t gpa, u64 *spte)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tu64 old_spte;\n\tu64 *sptep = NULL;\n\n\tfor_each_shadow_entry_lockless(vcpu, gpa, iterator, old_spte) {\n\t\tsptep = iterator.sptep;\n\t\t*spte = old_spte;\n\t}\n\n\treturn sptep;\n}",
        "output": "0",
        "idx": 793
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE1(inotify_init1, int, flags)\n{\n\tstruct fsnotify_group *group;\n\tstruct user_struct *user;\n\tint ret;\n\n\t/* Check the IN_* constants for consistency.  */\n\tBUILD_BUG_ON(IN_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(IN_NONBLOCK != O_NONBLOCK);\n\n\tif (flags & ~(IN_CLOEXEC | IN_NONBLOCK))\n\t\treturn -EINVAL;\n\n\tuser = get_current_user();\n\tif (unlikely(atomic_read(&user->inotify_devs) >=\n\t\t\tinotify_max_user_instances)) {\n\t\tret = -EMFILE;\n\t\tgoto out_free_uid;\n\t}\n\n\t/* fsnotify_obtain_group took a reference to group, we put this when we kill the file in the end */\n\tgroup = inotify_new_group(user, inotify_max_queued_events);\n\tif (IS_ERR(group)) {\n\t\tret = PTR_ERR(group);\n\t\tgoto out_free_uid;\n\t}\n\n\tatomic_inc(&user->inotify_devs);\n\n\tret = anon_inode_getfd(\"inotify\", &inotify_fops, group,\n\t\t\t\t  O_RDONLY | flags);\n\tif (ret >= 0)\n\t\treturn ret;\n\n\tatomic_dec(&user->inotify_devs);\nout_free_uid:\n\tfree_uid(user);\n\treturn ret;\n}",
        "output": "1",
        "idx": 2515
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void drop_sysctl_table(struct ctl_table_header *header)\n{\n\tstruct ctl_dir *parent = header->parent;\n\n\tif (--header->nreg)\n\t\treturn;\n\n\tput_links(header);\n\tstart_unregistering(header);\n\tif (!--header->count)\n\t\tkfree_rcu(header, rcu);\n\n\tif (parent)\n\t\tdrop_sysctl_table(&parent->header);\n}",
        "output": "1",
        "idx": 2077
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "remove_msix_remapping(const struct acrn_vm *vm, uint16_t phys_bdf, uint32_t entry_nr)\n{\n\tstruct ptirq_remapping_info *entry;\n\tDEFINE_MSI_SID(phys_sid, phys_bdf, entry_nr);\n\tstruct intr_source intr_src;\n\n\tentry = find_ptirq_entry(PTDEV_INTR_MSI, &phys_sid, NULL);\n\tif ((entry != NULL) && (entry->vm == vm)) {\n\t\tif (is_entry_active(entry)) {\n\t\t\t/*TODO: disable MSIX device when HV can in future */\n\t\t\tptirq_deactivate_entry(entry);\n\t\t}\n\n\t\tintr_src.is_msi = true;\n\t\tintr_src.src.msi.value = entry->phys_sid.msi_id.bdf;\n\t\tdmar_free_irte(&intr_src, entry->irte_idx);\n\n\t\tdev_dbg(DBG_LEVEL_IRQ, \"VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d\",\n\t\t\tvm->vm_id, entry->virt_sid.msi_id.bdf, phys_bdf, entry_nr);\n\n\t\tptirq_release_entry(entry);\n\t}\n\n}",
        "output": "0",
        "idx": 1681
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void gf_dom_event_remove_all_listeners(GF_DOMEventTarget *event_target)\n{\n\twhile (gf_list_count(event_target->listeners)) {\n\t\tGF_Node *n = (GF_Node *)gf_list_get(event_target->listeners, 0);\n\t\tgf_dom_listener_del(n, event_target);\n\t}\n}",
        "output": "1",
        "idx": 302
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void put_fc_log(struct fs_context *fc)\n{\n\tstruct fc_log *log = fc->log.log;\n\tint i;\n\n\tif (log) {\n\t\tif (refcount_dec_and_test(&log->usage)) {\n\t\t\tfc->log.log = NULL;\n\t\t\tfor (i = 0; i <= 7; i++)\n\t\t\t\tif (log->need_free & (1 << i))\n\t\t\t\t\tkfree(log->buffer[i]);\n\t\t\tkfree(log);\n\t\t}\n\t}\n}",
        "output": "0",
        "idx": 3139
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hasstop (GPtrArray * lookin)\n{\n    unsigned int i;\n    for (i = 0; i < lookin->len; i++) {\n        if (!strcmp (((RsvgNode *) g_ptr_array_index (lookin, i))->type->str, \"stop\"))\n            return 1;\n    }\n    return 0;\n}",
        "output": "1",
        "idx": 1734
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *get_pid_environ_val(pid_t pid,char *val){\n  int temp_size = 500;\n  char *temp = malloc(temp_size);\n  \n  int i=0;\n  int foundit=0;\n  FILE *fp;\n\n  sprintf(temp,\"/proc/%d/environ\",pid);\n\n  fp=fopen(temp,\"r\");\n  if(fp==NULL)\n    return NULL;\n\n  \n  for(;;){\n    \n    if (i >= temp_size) {\n      temp_size *= 2;\n      temp = realloc(temp, temp_size);\n    }\n      \n    temp[i]=fgetc(fp);    \n\n    if(foundit==1 && (temp[i]==0 || temp[i]=='\\0' || temp[i]==EOF)){\n      char *ret;\n      temp[i]=0;\n      ret=malloc(strlen(temp)+10);\n      sprintf(ret,\"%s\",temp);\n      fclose(fp);\n      return ret;\n    }\n\n    switch(temp[i]){\n    case EOF:\n      fclose(fp);\n      return NULL;\n    case '=':\n      temp[i]=0;\n      if(!strcmp(temp,val)){\n\tfoundit=1;\n      }\n      i=0;\n      break;\n    case '\\0':\n      i=0;\n      break;\n    default:\n      i++;\n    }\n  }\n}",
        "output": "0",
        "idx": 650
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ia64_patch_vtop (unsigned long start, unsigned long end)\n{\n\ts32 *offp = (s32 *) start;\n\tu64 ip;\n\n\twhile (offp < (s32 *) end) {\n\t\tip = (u64) offp + *offp;\n\n\t\t/* replace virtual address with corresponding physical address: */\n\t\tia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));\n\t\tia64_fc((void *) ip);\n\t\t++offp;\n\t}\n\tia64_sync_i();\n\tia64_srlz_i();\n}",
        "output": "0",
        "idx": 275
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int output_frame(H264Context *h, AVFrame *dst, Picture *srcp)\n{\n    AVFrame *src = &srcp->f;\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(src->format);\n    int i;\n    int ret = av_frame_ref(dst, src);\n    if (ret < 0)\n        return ret;\n\n    av_dict_set(&dst->metadata, \"stereo_mode\", ff_h264_sei_stereo_mode(h), 0);\n\n    if (!srcp->crop)\n        return 0;\n\n    for (i = 0; i < desc->nb_components; i++) {\n        int hshift = (i > 0) ? desc->log2_chroma_w : 0;\n        int vshift = (i > 0) ? desc->log2_chroma_h : 0;\n        int off    = ((srcp->crop_left >> hshift) << h->pixel_shift) +\n                      (srcp->crop_top  >> vshift) * dst->linesize[i];\n        dst->data[i] += off;\n    }\n    return 0;\n}",
        "output": "0",
        "idx": 3711
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void file_change(struct diff_options *options,\n\t\t unsigned old_mode, unsigned new_mode,\n\t\t const unsigned char *old_sha1,\n\t\t const unsigned char *new_sha1,\n\t\t const char *base, const char *path)\n{\n\ttree_difference = REV_TREE_DIFFERENT;\n\tDIFF_OPT_SET(options, HAS_CHANGES);\n}",
        "output": "1",
        "idx": 2461
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void forward_timer_base(struct timer_base *base)\n{\n\tunsigned long jnow = READ_ONCE(jiffies);\n\n\t/*\n\t * We only forward the base when it's idle and we have a delta between\n\t * base clock and jiffies.\n\t */\n\tif (!base->is_idle || (long) (jnow - base->clk) < 2)\n\t\treturn;\n\n\t/*\n\t * If the next expiry value is > jiffies, then we fast forward to\n\t * jiffies otherwise we forward to the next expiry value.\n\t */\n\tif (time_after(base->next_expiry, jnow))\n\t\tbase->clk = jnow;\n\telse\n\t\tbase->clk = base->next_expiry;\n}",
        "output": "0",
        "idx": 3369
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *print_number( cJSON *item )\n{\n\tchar *str;\n\tdouble f, f2;\n\tint64_t i;\n\n\tstr = (char*) cJSON_malloc( 64 );\n\tif ( str ) {\n\t\tf = item->valuefloat;\n\t\ti = f;\n\t\tf2 = i;\n\t\tif ( f2 == f && item->valueint >= LLONG_MIN && item->valueint <= LLONG_MAX )\n\t\t\tsprintf( str, \"%lld\", (long long) item->valueint );\n\t\telse\n\t\t\tsprintf( str, \"%g\", item->valuefloat );\n\t}\n\treturn str;\n}",
        "output": "1",
        "idx": 2225
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_be_int (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} /* header_put_be_int */",
        "output": "1",
        "idx": 2084
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int qxl_destroy_primary(PCIQXLDevice *d, qxl_async_io async)\n{\n    if (d->mode == QXL_MODE_UNDEFINED) {\n        return 0;\n    }\n    trace_qxl_destroy_primary(d->id);\n    d->mode = QXL_MODE_UNDEFINED;\n    qemu_spice_destroy_primary_surface(&d->ssd, 0, async);\n    qxl_spice_reset_cursor(d);\n    return 1;\n}",
        "output": "0",
        "idx": 2841
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "handle_moverect(VTermRect dest, VTermRect src, void *user)\n{\n    term_T\t*term = (term_T *)user;\n    int\t\tcount = src.start_row - dest.start_row;\n\n    /* Scrolling up is done much more efficiently by deleting lines instead of\n     * redrawing the text. But avoid doing this multiple times, postpone until\n     * the redraw happens. */\n    if (dest.start_col == src.start_col\n\t    && dest.end_col == src.end_col\n\t    && dest.start_row < src.start_row)\n    {\n\tif (dest.start_row == 0)\n\t    term->tl_postponed_scroll += count;\n\telse\n\t    term_scroll_up(term, dest.start_row, count);\n    }\n\n    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, dest.start_row);\n    term->tl_dirty_row_end = MIN(term->tl_dirty_row_end, dest.end_row);\n    set_dirty_snapshot(term);\n\n    /* Note sure if the scrolling will work correctly, let's do a complete\n     * redraw later. */\n    redraw_buf_later(term->tl_buffer, NOT_VALID);\n    return 1;\n}",
        "output": "0",
        "idx": 1939
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ip6_output(struct sk_buff *skb)\n{\n\tif (skb->len > dst_mtu(skb->dst) || dst_allfrag(skb->dst))\n\t\treturn ip6_fragment(skb, ip6_output2);\n\telse\n\t\treturn ip6_output2(skb);\n}",
        "output": "1",
        "idx": 1224
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void testCacheManager::setUp()\n{\n    Mem::Init();\n}",
        "output": "1",
        "idx": 794
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct dst_entry *rxe_find_route6(struct net_device *ndev,\n\t\t\t\t\t struct in6_addr *saddr,\n\t\t\t\t\t struct in6_addr *daddr)\n{\n\treturn NULL;\n}",
        "output": "1",
        "idx": 159
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int efi_capsule_release(struct inode *inode, struct file *file)\n{\n\tstruct capsule_info *cap_info = file->private_data;\n\n\tkfree(cap_info->pages);\n\tkfree(cap_info->phys);\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\treturn 0;\n}",
        "output": "1",
        "idx": 2631
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "asmlinkage void do_notify_resume(struct pt_regs *regs, u32 thread_info_flags)\n{\n\t/* Pending single-step? */\n\tif (thread_info_flags & _TIF_SINGLESTEP) {\n#ifndef CONFIG_MN10300_USING_JTAG\n\t\tregs->epsw |= EPSW_T;\n\t\tclear_thread_flag(TIF_SINGLESTEP);\n#else\n\t\tBUG(); /* no h/w single-step if using JTAG unit */\n#endif\n\t}\n\n\t/* deal with pending signal delivery */\n\tif (thread_info_flags & (_TIF_SIGPENDING | _TIF_RESTORE_SIGMASK))\n\t\tdo_signal(regs);\n\n\tif (thread_info_flags & _TIF_NOTIFY_RESUME) {\n\t\tclear_thread_flag(TIF_NOTIFY_RESUME);\n\t\ttracehook_notify_resume(__frame);\n\t}\n}",
        "output": "1",
        "idx": 3705
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hb_buffer_clear( HB_Buffer buffer )\n{\n  buffer->in_length = 0;\n  buffer->out_length = 0;\n  buffer->in_pos = 0;\n  buffer->out_pos = 0;\n  buffer->out_string = buffer->in_string;\n  buffer->separate_out = FALSE;\n  buffer->max_ligID = 0;\n}",
        "output": "1",
        "idx": 250
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ASN1_TYPE *PKCS7_get_attribute(PKCS7_SIGNER_INFO *si, int nid)\n{\n    return get_attribute(si->unauth_attr, nid);\n}",
        "output": "0",
        "idx": 3127
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "png_fixed(png_const_structrp png_ptr, double fp, png_const_charp text)\n{\n   double r = floor(100000 * fp + .5);\n\n   if (r > 2147483647. || r < -2147483648.)\n      png_fixed_error(png_ptr, text);\n\n#  ifndef PNG_ERROR_TEXT_SUPPORTED\n   PNG_UNUSED(text)\n#  endif\n\n   return (png_fixed_point)r;\n}",
        "output": "0",
        "idx": 641
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  inline bool get_glyph (hb_codepoint_t  unicode,\n\t\t\t hb_codepoint_t  variation_selector,\n\t\t\t hb_codepoint_t *glyph) const\n  {\n    if (unlikely (variation_selector))\n    {\n      switch (this->uvs_table->get_glyph_variant (unicode,\n\t\t\t\t\t\t  variation_selector,\n\t\t\t\t\t\t  glyph))\n      {\n\tcase OT::GLYPH_VARIANT_NOT_FOUND:\treturn false;\n\tcase OT::GLYPH_VARIANT_FOUND:\t\treturn true;\n\tcase OT::GLYPH_VARIANT_USE_DEFAULT:\tbreak;\n      }\n    }\n\n    return this->table->get_glyph (unicode, glyph);\n  }",
        "output": "0",
        "idx": 2565
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static enum count_type __read_io_type(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\tif (mapping) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\t\tif (inode->i_ino == F2FS_META_INO(sbi))\n\t\t\treturn F2FS_RD_META;\n\n\t\tif (inode->i_ino == F2FS_NODE_INO(sbi))\n\t\t\treturn F2FS_RD_NODE;\n\t}\n\treturn F2FS_RD_DATA;\n}",
        "output": "1",
        "idx": 1878
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    virtual Status checkAuthForCommand(Client* client,\n                                       const std::string& dbname,\n                                       const BSONObj& cmdObj) {\n        return auth::checkAuthForAuthSchemaUpgradeCommand(client);\n    }",
        "output": "0",
        "idx": 3080
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CoreUserInputHandler::handleBan(const BufferInfo &bufferInfo, const QString &msg)\n{\n    banOrUnban(bufferInfo, msg, true);\n}",
        "output": "0",
        "idx": 1470
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n                        int index) {\n  if (context->tensors != nullptr) {\n    return &context->tensors[node->outputs->data[index]];\n  } else {\n    return context->GetTensor(context, node->outputs->data[index]);\n  }\n}",
        "output": "1",
        "idx": 811
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TryReuseIndex(Oid oldId, IndexStmt *stmt)\n{\n\tif (CheckIndexCompatible(oldId,\n\t\t\t\t\t\t\t stmt->relation,\n\t\t\t\t\t\t\t stmt->accessMethod,\n\t\t\t\t\t\t\t stmt->indexParams,\n\t\t\t\t\t\t\t stmt->excludeOpNames))\n\t{\n\t\tRelation\tirel = index_open(oldId, NoLock);\n\n\t\tstmt->oldNode = irel->rd_node.relNode;\n\t\tindex_close(irel, NoLock);\n\t}\n}",
        "output": "1",
        "idx": 2161
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void iov_iter_pipe(struct iov_iter *i, int direction,\n\t\t\tstruct pipe_inode_info *pipe,\n\t\t\tsize_t count)\n{\n\tBUG_ON(direction != ITER_PIPE);\n\ti->type = direction;\n\ti->pipe = pipe;\n\ti->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\ti->iov_offset = 0;\n\ti->count = count;\n}",
        "output": "1",
        "idx": 2122
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n{\n\tswitch (ctxt->op_bytes) {\n\tcase 2:\n\t\tctxt->_eip = (u16)dst;\n\t\tbreak;\n\tcase 4:\n\t\tctxt->_eip = (u32)dst;\n\t\tbreak;\n\tcase 8:\n\t\tctxt->_eip = dst;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"unsupported eip assignment size\\n\");\n\t}\n}",
        "output": "1",
        "idx": 873
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rend_get_service_list_mutable(smartlist_t* substitute_service_list)\n{\n  if (substitute_service_list) {\n    return substitute_service_list;\n  }\n\n  /* If no special service list is provided, then just use the global one. */\n\n  if (BUG(!rend_service_list)) {\n    /* No global HS list, which is a programmer error. */\n    return NULL;\n  }\n\n  return rend_service_list;\n}",
        "output": "0",
        "idx": 1407
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int filp_close(struct file *filp, fl_owner_t id)\n{\n\tint retval = 0;\n\n\tif (!file_count(filp)) {\n\t\tprintk(KERN_ERR \"VFS: Close: file count is 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (filp->f_op && filp->f_op->flush)\n\t\tretval = filp->f_op->flush(filp, id);\n\n\tdnotify_flush(filp, id);\n\tlocks_remove_posix(filp, id);\n\tfput(filp);\n\treturn retval;\n}",
        "output": "0",
        "idx": 2818
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct razer_report razer_chroma_misc_one_row_set_custom_frame(unsigned char start_col, unsigned char stop_col, unsigned char *rgb_data) // TODO recheck custom frame hex\n{\n    struct razer_report report = get_razer_report(0x03, 0x0C, 0x32);\n    size_t row_length = (size_t) (((stop_col + 1) - start_col) * 3);\n\n    report.arguments[0] = start_col;\n    report.arguments[1] = stop_col;\n\n    memcpy(&report.arguments[2], rgb_data, row_length);\n\n    return report;\n}",
        "output": "1",
        "idx": 3703
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int esp_select(ESPState *s)\n{\n    int target;\n\n    target = s->wregs[ESP_WBUSID] & BUSID_DID;\n\n    s->ti_size = 0;\n    fifo8_reset(&s->fifo);\n\n    if (s->current_req) {\n        /* Started a new command before the old one finished.  Cancel it.  */\n        scsi_req_cancel(s->current_req);\n        s->async_len = 0;\n    }\n\n    s->current_dev = scsi_device_find(&s->bus, 0, target, 0);\n    if (!s->current_dev) {\n        /* No such drive */\n        s->rregs[ESP_RSTAT] = 0;\n        s->rregs[ESP_RINTR] |= INTR_DC;\n        s->rregs[ESP_RSEQ] = SEQ_0;\n        esp_raise_irq(s);\n        return -1;\n    }\n\n    /*\n     * Note that we deliberately don't raise the IRQ here: this will be done\n     * either in do_busid_cmd() for DATA OUT transfers or by the deferred\n     * IRQ mechanism in esp_transfer_data() for DATA IN transfers\n     */\n    s->rregs[ESP_RINTR] |= INTR_FC;\n    s->rregs[ESP_RSEQ] = SEQ_CD;\n    return 0;\n}",
        "output": "1",
        "idx": 1666
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void svg_progress(void *cbk, u64 done, u64 total)\n{\n\tGF_SVG_Parser *parser = (GF_SVG_Parser *)cbk;\n\n\t/*notify MediaEvent*/\n\tif (parser->load && parser->load->is) {\n\t\tparser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_PROGRESS);\n\t\tif (done == total) {\n\t\t\tparser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_LOAD_DONE);\n\t\t}\n\t}\n\tgf_set_progress(\"SVG (Dynamic Attribute List) Parsing\", done, total);\n}",
        "output": "0",
        "idx": 3558
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool load_permissions_file(\n        AccessPermissionsHandle& ah,\n        std::string& permissions_file,\n        PermissionsData& permissions,\n        SecurityException& exception)\n{\n    bool returned_value = false;\n\n    BIO* file_mem = load_signed_file(ah->store_, permissions_file, exception);\n\n    if (file_mem != nullptr)\n    {\n        BUF_MEM* ptr = nullptr;\n        BIO_get_mem_ptr(file_mem, &ptr);\n\n        if (ptr != nullptr)\n        {\n            PermissionsParser parser;\n            if ((returned_value = parser.parse_stream(ptr->data, ptr->length)) == true)\n            {\n                parser.swap(permissions);\n            }\n            else\n            {\n                exception = _SecurityException_(std::string(\"Malformed permissions file \") + permissions_file);\n            }\n        }\n        else\n        {\n            exception = _SecurityException_(std::string(\"OpenSSL library cannot retrieve mem ptr from file \")\n                            + permissions_file);\n        }\n\n        BIO_free(file_mem);\n    }\n\n    return returned_value;\n}",
        "output": "0",
        "idx": 496
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ippAddSeparator(ipp_t *ipp)\t\t/* I - IPP message */\n{\n  DEBUG_printf((\"ippAddSeparator(ipp=%p)\", (void *)ipp));\n\n /*\n  * Range check input...\n  */\n\n  if (!ipp)\n    return (NULL);\n\n /*\n  * Create the attribute...\n  */\n\n  return (ipp_add_attr(ipp, NULL, IPP_TAG_ZERO, IPP_TAG_ZERO, 0));\n}",
        "output": "0",
        "idx": 3089
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void close_connection(h2o_http2_conn_t *conn)\n{\n    conn->state = H2O_HTTP2_CONN_STATE_IS_CLOSING;\n\n    if (conn->_write.buf_in_flight != NULL || h2o_timeout_is_linked(&conn->_write.timeout_entry)) {\n        /* there is a pending write, let on_write_complete actually close the connection */\n    } else {\n        close_connection_now(conn);\n    }\n}",
        "output": "1",
        "idx": 3126
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {\n  // If this is an inline header, we can't addViaMove, because we'll overwrite\n  // the existing value.\n  auto* entry = getExistingInline(key.getStringView());\n  if (entry != nullptr) {\n    appendToHeader(entry->value(), value.getStringView());\n    key.clear();\n    value.clear();\n  } else {\n    insertByKey(std::move(key), std::move(value));\n  }\n}",
        "output": "1",
        "idx": 1675
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool asn1_read_OID(struct asn1_data *data, TALLOC_CTX *mem_ctx, char **OID)\n{\n\tDATA_BLOB blob;\n\tint len;\n\n\tif (!asn1_start_tag(data, ASN1_OID)) return false;\n\n\tlen = asn1_tag_remaining(data);\n\tif (len < 0) {\n\t\tdata->has_error = true;\n\t\treturn false;\n\t}\n\n\tblob = data_blob(NULL, len);\n\tif (!blob.data) {\n\t\tdata->has_error = true;\n\t\treturn false;\n\t}\n\n\tasn1_read(data, blob.data, len);\n\tasn1_end_tag(data);\n\tif (data->has_error) {\n\t\tdata_blob_free(&blob);\n\t\treturn false;\n\t}\n\n\tif (!ber_read_OID_String(mem_ctx, blob, OID)) {\n\t\tdata->has_error = true;\n\t\tdata_blob_free(&blob);\n\t\treturn false;\n\t}\n\n\tdata_blob_free(&blob);\n\treturn true;\n}",
        "output": "1",
        "idx": 2569
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API st64 r_buf_read_at(RBuffer *b, ut64 addr, ut8 *buf, ut64 len) {\n\tr_return_val_if_fail (b && buf, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\n\tr = r_buf_read (b, buf, len);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}",
        "output": "1",
        "idx": 721
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    inline const WCHAR *GetDirW(int index)\n    {\n\tWCHAR *ptr = dirTableW[index];\n\tif (!ptr) {\n\t    /* simulate the existence of this drive */\n\t    ptr = szLocalBufferW;\n\t    ptr[0] = 'A' + index;\n\t    ptr[1] = ':';\n\t    ptr[2] = '\\\\';\n\t    ptr[3] = 0;\n\t}\n\treturn ptr;\n    };",
        "output": "0",
        "idx": 1357
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bucket_insert (index_bucket *bucket,\n               CK_OBJECT_HANDLE handle)\n{\n\tunsigned int alloc;\n\tint at = 0;\n\n\tif (bucket->elem) {\n\t\tat = binary_search (bucket->elem, 0, bucket->num, handle);\n\t\tif (at < bucket->num && bucket->elem[at] == handle)\n\t\t\treturn;\n\t}\n\n\talloc = alloc_size (bucket->num);\n\tif (bucket->num + 1 > alloc) {\n\t\tCK_OBJECT_HANDLE *elem;\n\n\t\talloc = alloc ? alloc * 2 : 1;\n\t\treturn_if_fail (alloc != 0);\n\t\telem = realloc (bucket->elem, alloc * sizeof (CK_OBJECT_HANDLE));\n\t\treturn_if_fail (elem != NULL);\n\t\tbucket->elem = elem;\n\t}\n\n\treturn_if_fail (bucket->elem != NULL);\n\tmemmove (bucket->elem + at + 1, bucket->elem + at,\n\t         (bucket->num - at) * sizeof (CK_OBJECT_HANDLE));\n\tbucket->elem[at] = handle;\n\tbucket->num++;\n}",
        "output": "1",
        "idx": 777
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct siginfo info;\n\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_TKILL;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = current_uid();\n\n\treturn do_send_specific(tgid, pid, sig, &info);\n}",
        "output": "0",
        "idx": 3710
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b)\n{\n\tu64 now;\n\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\treturn;\n\n\tnow = sched_clock_cpu(smp_processor_id());\n\tcfs_b->runtime = cfs_b->quota;\n\tcfs_b->runtime_expires = now + ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n}",
        "output": "1",
        "idx": 2150
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MagickBooleanType IsJP2(const unsigned char *magick,const size_t length)\n{\n  if (length < 4)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\x0d\\x0a\\x87\\x0a\",4) == 0)\n    return(MagickTrue);\n  if (length < 12)\n    return(MagickFalse);\n  if (memcmp(magick,\"\\x00\\x00\\x00\\x0c\\x6a\\x50\\x20\\x20\\x0d\\x0a\\x87\\x0a\",12) == 0)\n    return(MagickTrue);\n  return(MagickFalse);\n}",
        "output": "0",
        "idx": 274
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int rom_copy(uint8_t *dest, hwaddr addr, size_t size)\n{\n    hwaddr end = addr + size;\n    uint8_t *s, *d = dest;\n    size_t l = 0;\n    Rom *rom;\n\n    QTAILQ_FOREACH(rom, &roms, next) {\n        if (rom->fw_file) {\n            continue;\n        }\n        if (rom->mr) {\n            continue;\n        }\n        if (rom->addr + rom->romsize < addr) {\n            continue;\n        }\n        if (rom->addr > end) {\n            break;\n        }\n\n        d = dest + (rom->addr - addr);\n        s = rom->data;\n        l = rom->datasize;\n\n        if ((d + l) > (dest + size)) {\n            l = dest - d;\n        }\n\n        if (l > 0) {\n            memcpy(d, s, l);\n        }\n\n        if (rom->romsize > rom->datasize) {\n            /* If datasize is less than romsize, it means that we didn't\n             * allocate all the ROM because the trailing data are only zeros.\n             */\n\n            d += l;\n            l = rom->romsize - rom->datasize;\n\n            if ((d + l) > (dest + size)) {\n                /* Rom size doesn't fit in the destination area. Adjust to avoid\n                 * overflow.\n                 */\n                l = dest - d;\n            }\n\n            if (l > 0) {\n                memset(d, 0x0, l);\n            }\n        }\n    }\n\n    return (d + l) - dest;\n}",
        "output": "1",
        "idx": 376
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int nfc_fw_download(struct nfc_dev *dev, const char *firmware_name)\n{\n\tint rc = 0;\n\n\tpr_debug(\"%s do firmware %s\\n\", dev_name(&dev->dev), firmware_name);\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->shutting_down) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (dev->dev_up) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\n\tif (!dev->ops->fw_download) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\n\tdev->fw_download_in_progress = true;\n\trc = dev->ops->fw_download(dev, firmware_name);\n\tif (rc)\n\t\tdev->fw_download_in_progress = false;\n\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}",
        "output": "0",
        "idx": 2306
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CL_SetModel_f( void ) {\n\tchar\t*arg;\n\tchar\tname[256];\n\n\targ = Cmd_Argv( 1 );\n\tif (arg[0]) {\n\t\tCvar_Set( \"model\", arg );\n\t\tCvar_Set( \"headmodel\", arg );\n\t} else {\n\t\tCvar_VariableStringBuffer( \"model\", name, sizeof(name) );\n\t\tCom_Printf(\"model is set to %s\\n\", name);\n\t}\n}",
        "output": "0",
        "idx": 3398
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)\n{\n\tint *fdp = (int*)CMSG_DATA(cmsg);\n\tstruct scm_fp_list *fpl = *fplp;\n\tstruct file **fpp;\n\tint i, num;\n\n\tnum = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr)))/sizeof(int);\n\n\tif (num <= 0)\n\t\treturn 0;\n\n\tif (num > SCM_MAX_FD)\n\t\treturn -EINVAL;\n\n\tif (!fpl)\n\t{\n\t\tfpl = kmalloc(sizeof(struct scm_fp_list), GFP_KERNEL);\n\t\tif (!fpl)\n\t\t\treturn -ENOMEM;\n\t\t*fplp = fpl;\n\t\tfpl->count = 0;\n\t}\n\tfpp = &fpl->fp[fpl->count];\n\n\tif (fpl->count + num > SCM_MAX_FD)\n\t\treturn -EINVAL;\n\n\t/*\n\t *\tVerify the descriptors and increment the usage count.\n\t */\n\n\tfor (i=0; i< num; i++)\n\t{\n\t\tint fd = fdp[i];\n\t\tstruct file *file;\n\n\t\tif (fd < 0 || !(file = fget(fd)))\n\t\t\treturn -EBADF;\n\t\t*fpp++ = file;\n\t\tfpl->count++;\n\t}\n\treturn num;\n}",
        "output": "1",
        "idx": 3506
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ioeventfd_release(struct _ioeventfd *p)\n{\n\teventfd_ctx_put(p->eventfd);\n\tlist_del(&p->list);\n\tkfree(p);\n}",
        "output": "0",
        "idx": 1949
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_unwrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer,\n\t\tgss_buffer_t output_message_buffer,\n\t\tint *conf_state,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap(minor_status,\n\t\t\tcontext_handle,\n\t\t\tinput_message_buffer,\n\t\t\toutput_message_buffer,\n\t\t\tconf_state,\n\t\t\tqop_state);\n\n\treturn (ret);\n}",
        "output": "1",
        "idx": 3395
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_rdrand_seed()\n{\n    DEBUG_SEED(\"get_rdrand_seed\");\n    int r;\n    while (_rdrand32_step(&r) == 0);\n    return r;\n}",
        "output": "0",
        "idx": 924
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init sched_domain_debug_setup(char *str)\n{\n\tsched_domain_debug_enabled = 1;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1486
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_sparse_region (struct tar_sparse_file *file, off_t beg, off_t end)\n{\n  if (!lseek_or_error (file, beg))\n    return false;\n\n  while (beg < end)\n    {\n      size_t bytes_read;\n      size_t rdsize = BLOCKSIZE < end - beg ? BLOCKSIZE : end - beg;\n      char diff_buffer[BLOCKSIZE];\n\n      bytes_read = safe_read (file->fd, diff_buffer, rdsize);\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n          read_diag_details (file->stat_info->orig_file_name,\n\t                     beg,\n\t\t\t     rdsize);\n\t  return false;\n\t}\n      if (!zero_block_p (diff_buffer, bytes_read))\n\t{\n\t  char begbuf[INT_BUFSIZE_BOUND (off_t)];\n \t  report_difference (file->stat_info,\n\t\t\t     _(\"File fragment at %s is not a hole\"),\n\t\t\t     offtostr (beg, begbuf));\n\t  return false;\n\t}\n\n      beg += bytes_read;\n    }\n  return true;\n}",
        "output": "1",
        "idx": 1201
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void io_req_drop_files(struct io_kiocb *req)\n{\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->inflight_lock, flags);\n\tlist_del(&req->inflight_entry);\n\tif (waitqueue_active(&ctx->inflight_wait))\n\t\twake_up(&ctx->inflight_wait);\n\tspin_unlock_irqrestore(&ctx->inflight_lock, flags);\n\treq->flags &= ~REQ_F_INFLIGHT;\n\treq->work.files = NULL;\n}",
        "output": "1",
        "idx": 152
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool JOIN_TAB::hash_join_is_possible()\n{\n  if (type != JT_REF && type != JT_EQ_REF)\n    return FALSE;\n  if (!is_ref_for_hash_join())\n  {\n    KEY *keyinfo= table->key_info + ref.key;\n    return keyinfo->key_part[0].field->hash_join_is_possible();\n  }\n  return TRUE;\n}",
        "output": "0",
        "idx": 3545
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "reallocarray (void *ptr,\n\t      size_t nmemb,\n\t      size_t size)\n{\n\tassert (nmemb > 0 && size > 0);\n\tif (SIZE_MAX / nmemb < size) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\treturn realloc (ptr, nmemb * size);\n}",
        "output": "1",
        "idx": 3326
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pair<string, string> splitField(const string& inp, char sepa)\n{\n  pair<string, string> ret;\n  string::size_type cpos=inp.find(sepa);\n  if(cpos==string::npos)\n    ret.first=inp;\n  else {\n    ret.first=inp.substr(0, cpos);\n    ret.second=inp.substr(cpos+1);\n  }\n  return ret;\n}",
        "output": "0",
        "idx": 59
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dlci_ioctl_set(int (*hook) (unsigned int, void __user *))\n{\n\tmutex_lock(&dlci_ioctl_mutex);\n\tdlci_ioctl_hook = hook;\n\tmutex_unlock(&dlci_ioctl_mutex);\n}",
        "output": "0",
        "idx": 2958
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "lou_logFile (const char *fileName)\n{\n  if (fileName == NULL || fileName[0] == 0)\n    return;\n  if (initialLogFileName[0] == 0)\n    strcpy (initialLogFileName, fileName);\n  logFile = fopen (fileName, \"wb\");\n  if (logFile == NULL && initialLogFileName[0] != 0)\n    logFile = fopen (initialLogFileName, \"wb\");\n  if (logFile == NULL)\n    {\n      fprintf (stderr, \"Cannot open log file %s\\n\", fileName);\n      logFile = stderr;\n    }\n}",
        "output": "0",
        "idx": 2878
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void faad_resetbits(bitfile *ld, int bits)\n{\n    uint32_t tmp;\n    int words = bits >> 5;\n    int remainder = bits & 0x1F;\n\n    ld->bytes_left = ld->buffer_size - words*4;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufa = tmp;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words+1]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n\n    ld->bits_left = 32 - remainder;\n    ld->tail = &ld->start[words+2];\n\n    /* recheck for reading too many bytes */\n    ld->error = 0;\n//    if (ld->bytes_left == 0)\n//        ld->no_more_reading = 1;\n//    if (ld->bytes_left < 0)\n//        ld->error = 1;\n}",
        "output": "1",
        "idx": 2854
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ContentEncAESSettings::ContentEncAESSettings() : cipher_mode_(kCTR) {}",
        "output": "0",
        "idx": 972
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t   unsigned long size)\n{\n\tgfn_t end_gfn;\n\tpfn_t pfn;\n\n\tpfn     = gfn_to_pfn_memslot(slot, gfn);\n\tend_gfn = gfn + (size >> PAGE_SHIFT);\n\tgfn    += 1;\n\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn pfn;\n\n\twhile (gfn < end_gfn)\n\t\tgfn_to_pfn_memslot(slot, gfn++);\n\n\treturn pfn;\n}",
        "output": "1",
        "idx": 2907
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __io_openat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tconst char __user *fname;\n\tint ret;\n\n\tif (unlikely(sqe->ioprio || sqe->buf_index))\n\t\treturn -EINVAL;\n\tif (unlikely(req->flags & REQ_F_FIXED_FILE))\n\t\treturn -EBADF;\n\n\t/* open.how should be already initialised */\n\tif (!(req->open.how.flags & O_PATH) && force_o_largefile())\n\t\treq->open.how.flags |= O_LARGEFILE;\n\n\treq->open.dfd = READ_ONCE(sqe->fd);\n\tfname = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\treq->open.filename = getname(fname);\n\tif (IS_ERR(req->open.filename)) {\n\t\tret = PTR_ERR(req->open.filename);\n\t\treq->open.filename = NULL;\n\t\treturn ret;\n\t}\n\treq->open.nofile = rlimit(RLIMIT_NOFILE);\n\treq->flags |= REQ_F_NEED_CLEANUP;\n\treturn 0;\n}",
        "output": "0",
        "idx": 1111
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus EvalImpl(TfLiteContext* context, const TfLiteTensor* input,\n                      TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteUniqueParams*>(node->builtin_data);\n  if (params == nullptr) {\n    context->ReportError(context, \"Null params passed\");\n    return kTfLiteError;\n  }\n  switch (params->index_out_type) {\n    case kTfLiteInt32:\n      return EvalImpl<T, int32_t>(context, input, node);\n    case kTfLiteInt64:\n      return EvalImpl<T, int64_t>(context, input, node);\n    default:\n      context->ReportError(\n          context,\n          \"Unique index output array can only be Int32 or In64, requested: %s\",\n          TfLiteTypeGetName(params->index_out_type));\n  }\n  return kTfLiteError;\n}",
        "output": "1",
        "idx": 1627
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t runtime_active_time_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tu64 tmp = pm_runtime_active_time(dev);\n\tdo_div(tmp, NSEC_PER_MSEC);\n\tret = sprintf(buf, \"%llu\\n\", tmp);\n\treturn ret;\n}",
        "output": "1",
        "idx": 3465
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    void incNumConnections() override { ++num_listener_connections_; }",
        "output": "1",
        "idx": 2269
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ntop_check_profile_syntax(lua_State* vm) {\n  char *filter;\n  NetworkInterfaceView *ntop_interface = getCurrentInterface(vm);\n  NetworkInterface *iface = ntop_interface->getFirst();\n\n  ntop->getTrace()->traceEvent(TRACE_INFO, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  filter = (char*)lua_tostring(vm, 1);\n\n  lua_pushboolean(vm, iface ? iface->checkProfileSyntax(filter) : false);\n\n  return(CONST_LUA_OK);\n}",
        "output": "0",
        "idx": 653
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "tor_addr_is_public_for_reject(const tor_addr_t *addr)\n{\n  return (!tor_addr_is_null(addr) && !tor_addr_is_internal(addr, 0)\n          && !tor_addr_is_multicast(addr));\n}",
        "output": "0",
        "idx": 334
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ntop_has_geoip(lua_State* vm) {\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  lua_pushboolean(vm, ntop->getGeolocation() ? 1 : 0);\n  return(CONST_LUA_OK);\n}",
        "output": "0",
        "idx": 1447
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void avahi_s_host_name_resolver_start(AvahiSHostNameResolver *r) {\n    assert(r);\n\n    if(r->record_browser_a)\n        avahi_s_record_browser_start_query(r->record_browser_a);\n\n    if(r->record_browser_aaaa)\n        avahi_s_record_browser_start_query(r->record_browser_aaaa);\n}",
        "output": "0",
        "idx": 3459
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "e_ews_connection_create_folder_finish (EEwsConnection *cnc,\n                                       GAsyncResult *result,\n                                       EwsFolderId **fid,\n                                       GError **error)\n{\n\tGSimpleAsyncResult *simple;\n\tEwsAsyncData *async_data;\n\n\tg_return_val_if_fail (cnc != NULL, FALSE);\n\tg_return_val_if_fail (\n\t\tg_simple_async_result_is_valid (\n\t\tresult, G_OBJECT (cnc), e_ews_connection_create_folder),\n\t\tFALSE);\n\n\tsimple = G_SIMPLE_ASYNC_RESULT (result);\n\tasync_data = g_simple_async_result_get_op_res_gpointer (simple);\n\n\tif (g_simple_async_result_propagate_error (simple, error))\n\t\treturn FALSE;\n\n\t*fid = (EwsFolderId *) async_data->items_created->data;\n\tg_slist_free (async_data->items_created);\n\n\treturn TRUE;\n}",
        "output": "0",
        "idx": 1482
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned short get_ushort(const unsigned char *data)\n{\n    unsigned short val = *(const unsigned short *)data;\n#ifdef OPJ_BIG_ENDIAN\n    val = ((val & 0xffU) << 8) | (val >> 8);\n#endif\n    return val;\n}",
        "output": "1",
        "idx": 638
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "virDomainAddIOThread(virDomainPtr domain,\n                     unsigned int iothread_id,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"iothread_id=%u, flags=%x\",\n                     iothread_id, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainAddIOThread) {\n        int ret;\n        ret = conn->driver->domainAddIOThread(domain, iothread_id, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}",
        "output": "0",
        "idx": 3138
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "qb_log_blackbox_write_to_file(const char *filename)\n{\n\tssize_t written_size = 0;\n\tstruct qb_log_target *t;\n\tstruct _blackbox_file_header header;\n\tint fd = open(filename, O_CREAT | O_RDWR | O_EXCL, 0700);\n\n\tif (fd < 0) {\n\t\treturn -errno;\n\t}\n\n\t/* Write header, so we know this is a 'new' format blackbox */\n\theader.word_size = QB_BLACKBOX_HEADER_WORDSIZE;\n\theader.read_pt   = QB_BLACKBOX_HEADER_READPT;\n\theader.write_pt  = QB_BLACKBOX_HEADER_WRITEPT;\n\theader.version   = QB_BLACKBOX_HEADER_VERSION;\n\theader.hash      = QB_BLACKBOX_HEADER_HASH;\n\twritten_size = write(fd, &header, sizeof(header));\n\tif (written_size < sizeof(header)) {\n\t\tclose(fd);\n\t\treturn written_size;\n\t}\n\n\tt = qb_log_target_get(QB_LOG_BLACKBOX);\n\tif (t->instance) {\n\t\twritten_size += qb_rb_write_to_file(t->instance, fd);\n\t} else {\n\t\twritten_size = -ENOENT;\n\t}\n\tclose(fd);\n\n\treturn written_size;\n}",
        "output": "1",
        "idx": 3271
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void read_file_into_memory(\n    char const* filename,\n    PointerHolder<char>& file_buf, size_t& size)\n{\n    FILE* f = QUtil::safe_fopen(filename, \"rb\");\n    fseek(f, 0, SEEK_END);\n    size = QUtil::tell(f);\n    fseek(f, 0, SEEK_SET);\n    file_buf = PointerHolder<char>(true, new char[size]);\n    char* buf_p = file_buf.getPointer();\n    size_t bytes_read = 0;\n    size_t len = 0;\n    while ((len = fread(buf_p + bytes_read, 1, size - bytes_read, f)) > 0)\n    {\n        bytes_read += len;\n    }\n    if (bytes_read != size)\n    {\n        if (ferror(f))\n        {\n            throw std::runtime_error(\n                std::string(\"failure reading file \") + filename +\n                \" into memory: read \" +\n                QUtil::uint_to_string(bytes_read) + \"; wanted \" +\n                QUtil::uint_to_string(size));\n        }\n        else\n        {\n            throw std::logic_error(\n                std::string(\"premature eof reading file \") + filename +\n                \" into memory: read \" +\n                QUtil::uint_to_string(bytes_read) + \"; wanted \" +\n                QUtil::uint_to_string(size));\n        }\n    }\n    fclose(f);\n}",
        "output": "1",
        "idx": 2604
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "my_xbstream_write_callback(xb_wstream_file_t *f __attribute__((unused)),\n\t\t       void *userdata, const void *buf, size_t len)\n{\n\tds_stream_ctxt_t\t*stream_ctxt;\n\n\tstream_ctxt = (ds_stream_ctxt_t *) userdata;\n\n\txb_ad(stream_ctxt != NULL);\n\txb_ad(stream_ctxt->dest_file != NULL);\n\n\tif (!ds_write(stream_ctxt->dest_file, buf, len)) {\n\t\treturn len;\n\t}\n\treturn -1;\n}",
        "output": "0",
        "idx": 2255
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool vmxnet3_interrupt_asserted(VMXNET3State *s, int lidx)\n{\n    return s->interrupt_states[lidx].is_asserted;\n}",
        "output": "0",
        "idx": 1332
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void LinkResolver::resolve_invokehandle(CallInfo& result, constantPoolHandle pool, int index, TRAPS) {\n  assert(EnableInvokeDynamic, \"\");\n  // This guy is reached from InterpreterRuntime::resolve_invokehandle.\n  KlassHandle  resolved_klass;\n  Symbol* method_name = NULL;\n  Symbol* method_signature = NULL;\n  KlassHandle  current_klass;\n  resolve_pool(resolved_klass, method_name,  method_signature, current_klass, pool, index, CHECK);\n  if (TraceMethodHandles) {\n    ResourceMark rm(THREAD);\n    tty->print_cr(\"resolve_invokehandle %s %s\", method_name->as_C_string(), method_signature->as_C_string());\n  }\n  resolve_handle_call(result, resolved_klass, method_name, method_signature, current_klass, CHECK);\n}",
        "output": "1",
        "idx": 3101
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST(OverflowArithmetic, SignedAdditionTests) {\n    using T = int64_t;\n    static constexpr auto f = polyAdd;\n    ASSERT(test<T>(f, 0, kMax<T>, kMax<T>));\n    ASSERT(test<T>(f, -1, kMax<T>, kMax<T> - 1));\n    ASSERT(test<T>(f, 1, kMax<T> - 1, kMax<T>));\n    ASSERT(test<T>(f, 0, kMin<T>, kMin<T>));\n    ASSERT(test<T>(f, 1, kMin<T>, kMin<T> + 1));\n    ASSERT(test<T>(f, -1, kMin<T> + 1, kMin<T>));\n    ASSERT(test<T>(f, kMax<T>, kMin<T>, -1));\n    ASSERT(test<T>(f, 1, 1, 2));\n    ASSERT(test<T>(f, -1, -1, -2));\n    ASSERT(testOflow<T>(f, kMax<T>, 1));\n    ASSERT(testOflow<T>(f, kMax<T>, kMax<T>));\n    ASSERT(testOflow<T>(f, kMin<T>, -1));\n    ASSERT(testOflow<T>(f, kMin<T>, kMin<T>));\n}",
        "output": "0",
        "idx": 3706
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   Returns TRUE if the mode outputs blocks of bytes */\nPHP_FUNCTION(mcrypt_module_is_block_mode)\n{\n\tMCRYPT_GET_MODE_DIR_ARGS(modes_dir)\n\t\n\tif (mcrypt_module_is_block_mode(module, dir) == 1) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}",
        "output": "1",
        "idx": 3293
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int audit_compare_gid(kgid_t gid,\n\t\t\t     struct audit_names *name,\n\t\t\t     struct audit_field *f,\n\t\t\t     struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\tint rc;\n \n\tif (name) {\n\t\trc = audit_gid_comparator(gid, f->op, name->gid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n \n\tif (ctx) {\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\trc = audit_gid_comparator(gid, f->op, n->gid);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 1440
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void NumberFormatTest::verifyFieldPositionIterator(\n        NumberFormatTest_Attributes *expected, FieldPositionIterator &iter) {\n    int32_t idx = 0;\n    FieldPosition fp;\n    while (iter.next(fp)) {\n        if (expected[idx].spos == -1) {\n            errln(\"Iterator should have ended. got %d\", fp.getField());\n            return;\n        }\n        assertEquals(\"id\", expected[idx].id, fp.getField());\n        assertEquals(\"start\", expected[idx].spos, fp.getBeginIndex());\n        assertEquals(\"end\", expected[idx].epos, fp.getEndIndex());\n        ++idx;\n    }\n    if (expected[idx].spos != -1) {\n        errln(\"Premature end of iterator. expected %d\", expected[idx].id);\n    }\n}",
        "output": "0",
        "idx": 1
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\n\t/* Not even root can pretend to send signals from the kernel.\n\t * Nor can they impersonate a kill()/tgkill(), which adds source info.\n\t */\n\tif (info->si_code != SI_QUEUE) {\n\t\t/* We used to allow any < 0 si_code */\n\t\tWARN_ON_ONCE(info->si_code < 0);\n\t\treturn -EPERM;\n\t}\n\tinfo->si_signo = sig;\n\n\treturn do_send_specific(tgid, pid, sig, info);\n}",
        "output": "1",
        "idx": 1779
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "init_uncompress( compress_filter_context_t *zfx, z_stream *zs )\n{\n    int rc;\n\n    /****************\n     * PGP uses a windowsize of 13 bits. Using a negative value for\n     * it forces zlib not to expect a zlib header.  This is a\n     * undocumented feature Peter Gutmann told me about.\n     *    \n     * We must use 15 bits for the inflator because CryptoEx uses 15\n     * bits thus the output would get scrambled w/o error indication\n     * if we would use 13 bits.  For the uncompressing this does not\n     * matter at all.\n     */\n    if( (rc = zfx->algo == 1? inflateInit2( zs, -15)\n\t\t\t    : inflateInit( zs )) != Z_OK ) {\n\tlog_fatal(\"zlib problem: %s\\n\", zs->msg? zs->msg :\n\t\t\t       rc == Z_MEM_ERROR ? \"out of core\" :\n\t\t\t       rc == Z_VERSION_ERROR ? \"invalid lib version\" :\n\t\t\t\t\t\t       \"unknown error\" );\n    }\n\n    zfx->inbufsize = 2048;\n    zfx->inbuf = xmalloc( zfx->inbufsize );\n    zs->avail_in = 0;\n}",
        "output": "1",
        "idx": 1554
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    void topicName(\n            const string_255& topicName)\n    {\n        topic_name_ = topicName;\n    }",
        "output": "0",
        "idx": 2486
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    TEST(BSONValidate, Basic) {\n        BSONObj x;\n        ASSERT_TRUE( x.valid() );\n        \n        x = BSON( \"x\" << 1 );\n        ASSERT_TRUE( x.valid() );\n    }",
        "output": "1",
        "idx": 1923
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_new_clip_path (void)\n{\n    RsvgClipPath *clip_path;\n\n    clip_path = g_new (RsvgClipPath, 1);\n    _rsvg_node_init (&clip_path->super);\n    clip_path->units = userSpaceOnUse;\n    clip_path->super.set_atts = rsvg_clip_path_set_atts;\n    clip_path->super.free = _rsvg_node_free;\n    return &clip_path->super;\n}",
        "output": "1",
        "idx": 310
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus ComputeDepthMultiplier(TfLiteContext* context,\n                                    const TfLiteTensor* input,\n                                    const TfLiteTensor* filter,\n                                    int16* depth_multiplier) {\n  int num_filter_channels = SizeOfDimension(filter, 3);\n  int num_input_channels = SizeOfDimension(input, 3);\n  TF_LITE_ENSURE_EQ(context, num_filter_channels % num_input_channels, 0);\n\n  *depth_multiplier = num_filter_channels / num_input_channels;\n  return kTfLiteOk;\n}",
        "output": "1",
        "idx": 1849
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void notify_inserters_if_bounded() TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {\n    if (has_capacity() || has_memory_limit()) {\n      // Notify all inserters. The removal of an element\n      // may make memory available for many inserters\n      // to insert new elements\n      full_.notify_all();\n    }\n  }",
        "output": "1",
        "idx": 1795
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "coolkey_get_public_key_from_certificate(sc_pkcs15_card_t *p15card, sc_cardctl_coolkey_object_t *obj)\n{\n\tsc_pkcs15_cert_info_t cert_info;\n\tsc_pkcs15_cert_t *cert_out = NULL;\n\tsc_pkcs15_pubkey_t *key = NULL;\n\tint r;\n\n\tcert_info.value.value = NULL;\n\tr = coolkey_get_certificate(p15card->card, obj, &cert_info.value);\n\tif (r < 0) {\n\t\tgoto fail;\n\t}\n\tr = sc_pkcs15_read_certificate(p15card, &cert_info, &cert_out);\n\tif (r < 0) {\n\t\tgoto fail;\n\t}\n\tkey = cert_out->key;\n\tcert_out->key = NULL; /* adopt the key from the cert */\nfail:\n\tif (cert_out) {\n\t\tsc_pkcs15_free_certificate(cert_out);\n\t}\n\tif (cert_info.value.value) {\n\t\tfree(cert_info.value.value);\n\t}\n\treturn key;\n}",
        "output": "1",
        "idx": 2822
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tkvm_x86_ops->vcpu_put(vcpu);\n\tkvm_put_guest_fpu(vcpu);\n}",
        "output": "0",
        "idx": 2551
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TPM2B_ECC_POINT_Unmarshal(TPM2B_ECC_POINT *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    INT32 startSize;\n    if (rc == TPM_RC_SUCCESS) {\n\trc = UINT16_Unmarshal(&target->size, buffer, size);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tif (target->size == 0) {\n\t    rc = TPM_RC_SIZE;\n\t}\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tstartSize = *size;\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPMS_ECC_POINT_Unmarshal(&target->point, buffer, size);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tif (target->size != startSize - *size) {\n\t    rc = TPM_RC_SIZE;\n\t}\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 801
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sk_prot_free(struct proto *prot, struct sock *sk)\n{\n\tstruct kmem_cache *slab;\n\tstruct module *owner;\n\n\towner = prot->owner;\n\tslab = prot->slab;\n\n\tcgroup_sk_free(&sk->sk_cgrp_data);\n\tmem_cgroup_sk_free(sk);\n\tsecurity_sk_free(sk);\n\tif (slab != NULL)\n\t\tkmem_cache_free(slab, sk);\n\telse\n\t\tkfree(sk);\n\tmodule_put(owner);\n}",
        "output": "0",
        "idx": 2648
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline RBinWasmCustomNameLocalName *parse_local_name(RBuffer *b, ut64 bound) {\n\tRBinWasmCustomNameLocalName *local_name = R_NEW0 (RBinWasmCustomNameLocalName);\n\tif (local_name) {\n\t\tif (!consume_u32_r (b, bound, &local_name->index)) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tlocal_name->names = r_id_storage_new (0, UT32_MAX);\n\t\tif (!local_name->names) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\tif (!parse_namemap (b, bound, local_name->names, &local_name->names_count)) {\n\t\t\tgoto beach;\n\t\t}\n\n\t\treturn local_name;\n\t}\nbeach:\n\twasm_custom_name_local_free (local_name);\n\treturn NULL;\n}",
        "output": "0",
        "idx": 2136
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "HInstruction* HGraphBuilder::BuildLoadKeyedGeneric(HValue* object,\n                                                   HValue* key) {\n  HValue* context = environment()->LookupContext();\n  return new(zone()) HLoadKeyedGeneric(context, object, key);\n}",
        "output": "0",
        "idx": 1232
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct list_head *get_event_list(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\treturn event->attr.pinned ? &ctx->pinned_active : &ctx->flexible_active;\n}",
        "output": "0",
        "idx": 3269
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "null_asynch_write (struct rw *rw,\n                   struct command *command,\n                   nbd_completion_callback cb)\n{\n  int dummy = 0;\n\n  if (cb.callback (cb.user_data, &dummy) == -1) {\n    perror (rw->name);\n    exit (EXIT_FAILURE);\n  }\n}",
        "output": "1",
        "idx": 2675
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void setup_min_unmapped_ratio(void)\n{\n\tpg_data_t *pgdat;\n\tstruct zone *zone;\n\n\tfor_each_online_pgdat(pgdat)\n\t\tpgdat->min_unmapped_pages = 0;\n\n\tfor_each_zone(zone)\n\t\tzone->zone_pgdat->min_unmapped_pages += (zone->managed_pages *\n\t\t\t\tsysctl_min_unmapped_ratio) / 100;\n}",
        "output": "0",
        "idx": 3224
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void write_response(ESPState *s)\n{\n    uint8_t buf[2];\n\n    trace_esp_write_response(s->status);\n\n    buf[0] = s->status;\n    buf[1] = 0;\n\n    if (s->dma) {\n        if (s->dma_memory_write) {\n            s->dma_memory_write(s->dma_opaque, buf, 2);\n            s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;\n            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;\n            s->rregs[ESP_RSEQ] = SEQ_CD;\n        } else {\n            s->pdma_cb = write_response_pdma_cb;\n            esp_raise_drq(s);\n            return;\n        }\n    } else {\n        fifo8_reset(&s->fifo);\n        fifo8_push_all(&s->fifo, buf, 2);\n        s->rregs[ESP_RFLAGS] = 2;\n    }\n    esp_raise_irq(s);\n}",
        "output": "0",
        "idx": 1348
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *ask_new_field(struct chfn_control *ctl, const char *question,\n\t\t\t   char *def_val)\n{\n\tint len;\n\tchar *buf;\n#ifndef HAVE_LIBREADLINE\n\tsize_t dummy = 0;\n#endif\n\n\tif (!def_val)\n\t\tdef_val = \"\";\n\twhile (true) {\n\t\tprintf(\"%s [%s]:\", question, def_val);\n\t\t__fpurge(stdin);\n#ifdef HAVE_LIBREADLINE\n\t\trl_bind_key('\\t', rl_insert);\n\t\tif ((buf = readline(\" \")) == NULL)\n#else\n\t\tputchar(' ');\n\t\tif (getline(&buf, &dummy, stdin) < 0)\n#endif\n\t\t\terrx(EXIT_FAILURE, _(\"Aborted.\"));\n\t\t/* remove white spaces from string end */\n\t\tltrim_whitespace((unsigned char *) buf);\n\t\tlen = rtrim_whitespace((unsigned char *) buf);\n\t\tif (len == 0) {\n\t\t\tfree(buf);\n\t\t\treturn xstrdup(def_val);\n\t\t}\n\t\tif (!strcasecmp(buf, \"none\")) {\n\t\t\tfree(buf);\n\t\t\tctl->changed = 1;\n\t\t\treturn xstrdup(\"\");\n\t\t}\n\t\tif (check_gecos_string(question, buf) >= 0)\n\t\t\tbreak;\n\t}\n\tctl->changed = 1;\n\treturn buf;\n}",
        "output": "1",
        "idx": 2719
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __check_block_validity(struct inode *inode, const char *func,\n\t\t\t\tunsigned int line,\n\t\t\t\tstruct ext4_map_blocks *map)\n{\n\tif (ext4_has_feature_journal(inode->i_sb) &&\n\t    (inode->i_ino ==\n\t     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))\n\t\treturn 0;\n\tif (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,\n\t\t\t\t   map->m_len)) {\n\t\text4_error_inode(inode, func, line, map->m_pblk,\n\t\t\t\t \"lblock %lu mapped to illegal pblock %llu \"\n\t\t\t\t \"(length %d)\", (unsigned long) map->m_lblk,\n\t\t\t\t map->m_pblk, map->m_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 3504
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int switch_user(uid_t user, gid_t group) {\n    save_egid = getegid();\n    save_euid = geteuid();\n    if (save_euid == user && save_egid == group)\n        return 0;\n    message(MESS_DEBUG, \"switching euid from %u to %u and egid from %u to %u (pid %d)\\n\",\n            (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid());\n    if (setegid(group) || seteuid(user)) {\n        message(MESS_ERROR, \"error switching euid from %u to %u and egid from %u to %u (pid %d): %s\\n\",\n                (unsigned) save_euid, (unsigned) user, (unsigned) save_egid, (unsigned) group, getpid(),\n                strerror(errno));\n        return 1;\n    }\n    return 0;\n}",
        "output": "0",
        "idx": 1029
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ssh_scp_push_file(ssh_scp scp, const char *filename, size_t size, int mode){\n\treturn ssh_scp_push_file64(scp, filename, (uint64_t) size, mode);\n}",
        "output": "1",
        "idx": 716
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init fdt_find_uefi_params(unsigned long node, const char *uname,\n\t\t\t\t       int depth, void *data)\n{\n\tstruct param_info *info = data;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dt_params); i++) {\n\t\tconst char *subnode = dt_params[i].subnode;\n\n\t\tif (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {\n\t\t\tinfo->missing = dt_params[i].params[0].name;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (subnode) {\n\t\t\tint err = of_get_flat_dt_subnode_by_name(node, subnode);\n\n\t\t\tif (err < 0)\n\t\t\t\treturn 0;\n\n\t\t\tnode = err;\n\t\t}\n\n\t\treturn __find_uefi_params(node, info, dt_params[i].params);\n\t}\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2653
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cx24116_read_snr(struct dvb_frontend *fe, u16 *snr)\n{\n\tif (esno_snr == 1)\n\t\treturn cx24116_read_snr_esno(fe, snr);\n\telse\n\t\treturn cx24116_read_snr_pct(fe, snr);\n}",
        "output": "0",
        "idx": 3547
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vhost_net_buf_is_empty(struct vhost_net_buf *rxq)\n{\n\treturn rxq->tail == rxq->head;\n}",
        "output": "0",
        "idx": 2866
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xemaclite_disable_interrupts(struct net_local *drvdata)\n{\n\tu32 reg_data;\n\n\t/* Disable the Global Interrupt Enable */\n\txemaclite_writel(XEL_GIER_GIE_MASK, drvdata->base_addr + XEL_GIER_OFFSET);\n\n\t/* Disable the Tx interrupts for the first buffer */\n\treg_data = xemaclite_readl(drvdata->base_addr + XEL_TSR_OFFSET);\n\txemaclite_writel(reg_data & (~XEL_TSR_XMIT_IE_MASK),\n\t\t\t drvdata->base_addr + XEL_TSR_OFFSET);\n\n\t/* Disable the Rx interrupts for the first buffer */\n\treg_data = xemaclite_readl(drvdata->base_addr + XEL_RSR_OFFSET);\n\txemaclite_writel(reg_data & (~XEL_RSR_RECV_IE_MASK),\n\t\t\t drvdata->base_addr + XEL_RSR_OFFSET);\n}",
        "output": "0",
        "idx": 2384
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TPMI_CAMELLIA_KEY_BITS_Unmarshal(TPMI_CAMELLIA_KEY_BITS *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPM_KEY_BITS_Unmarshal(target, buffer, size);  \n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tswitch (*target) {\n\t  case 128:\n\t    break;\n\t  default:\n\t    rc = TPM_RC_VALUE;\n\t}\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 1097
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int device_notifier(struct notifier_block *nb,\n\t\t\t\t  unsigned long action, void *data)\n{\n\tstruct device *dev = data;\n\tstruct dmar_domain *domain;\n\n\tif (iommu_dummy(dev))\n\t\treturn 0;\n\n\tif (action != BUS_NOTIFY_REMOVED_DEVICE)\n\t\treturn 0;\n\n\tdomain = find_domain(dev);\n\tif (!domain)\n\t\treturn 0;\n\n\tdmar_remove_one_dev_info(domain, dev);\n\tif (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))\n\t\tdomain_exit(domain);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 365
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static noinline int btrfs_ioctl_ino_lookup(struct file *file,\n\t\t\t\t\t   void __user *argp)\n{\n\t struct btrfs_ioctl_ino_lookup_args *args;\n\t struct inode *inode;\n\tint ret = 0;\n\n\targs = memdup_user(argp, sizeof(*args));\n\tif (IS_ERR(args))\n\t\treturn PTR_ERR(args);\n\n\tinode = file_inode(file);\n\n\t/*\n\t * Unprivileged query to obtain the containing subvolume root id. The\n\t * path is reset so it's consistent with btrfs_search_path_in_tree.\n\t */\n\tif (args->treeid == 0)\n\t\targs->treeid = BTRFS_I(inode)->root->root_key.objectid;\n\n\tif (args->objectid == BTRFS_FIRST_FREE_OBJECTID) {\n\t\targs->name[0] = 0;\n\t\tgoto out;\n\t}\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\tret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\targs->treeid, args->objectid,\n\t\t\t\t\targs->name);\n\nout:\n\tif (ret == 0 && copy_to_user(argp, args, sizeof(*args)))\n\t\tret = -EFAULT;\n\n\tkfree(args);\n\treturn ret;\n}",
        "output": "0",
        "idx": 1576
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int Hints::getPageObjectNum(int page)\n{\n    if ((page < 1) || (page > nPages)) {\n        return 0;\n    }\n\n    if (page - 1 > pageFirst) {\n        return pageObjectNum[page - 1];\n    } else if (page - 1 < pageFirst) {\n        return pageObjectNum[page];\n    } else {\n        return pageObjectNum[0];\n    }\n}",
        "output": "0",
        "idx": 1122
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TPMI_ALG_SYM_OBJECT_Unmarshal(TPMI_ALG_SYM_OBJECT *target, BYTE **buffer, INT32 *size, BOOL allowNull)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPM_ALG_ID_Unmarshal(target, buffer, size);  \n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tswitch (*target) {\n#if ALG_AES\n\t  case TPM_ALG_AES:\n#endif\n#if ALG_SM4\n\t  case TPM_ALG_SM4:\t\t\n#endif\n#if ALG_CAMELLIA\n\t  case TPM_ALG_CAMELLIA:\t\n#endif\n#if ALG_TDES\t\t// libtpms added begin\n          case TPM_ALG_TDES:\n#endif\t\t\t// iibtpms added end\n\t    break;\n\t  case TPM_ALG_NULL:\n\t    if (allowNull) {\n\t\tbreak;\n\t    }\n\t  default:\n\t    rc = TPM_RC_SYMMETRIC;\n\t}\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 731
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "__vma_link(struct mm_struct *mm, struct vm_area_struct *vma,\n\tstruct vm_area_struct *prev, struct rb_node **rb_link,\n\tstruct rb_node *rb_parent)\n{\n\t__vma_link_list(mm, vma, prev, rb_parent);\n\t__vma_link_rb(mm, vma, rb_link, rb_parent);\n}",
        "output": "0",
        "idx": 227
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "crypt_reencrypt_info LUKS2_reencrypt_get_params(struct luks2_hdr *hdr,\n\tstruct crypt_params_reencrypt *params)\n{\n\tcrypt_reencrypt_info ri;\n\n\tri = LUKS2_reencrypt_status(hdr);\n\tif (ri == CRYPT_REENCRYPT_NONE || ri == CRYPT_REENCRYPT_INVALID || !params)\n\t\treturn ri;\n\n\tparams->mode = reencrypt_mode(hdr);\n\tparams->direction = reencrypt_direction(hdr);\n\tparams->resilience = reencrypt_resilience_type(hdr);\n\tparams->hash = reencrypt_resilience_hash(hdr);\n\tparams->data_shift = reencrypt_data_shift(hdr) >> SECTOR_SHIFT;\n\tparams->max_hotzone_size = 0;\n\tif (LUKS2_get_segment_id_by_flag(hdr, \"backup-moved-segment\") >= 0)\n\t\tparams->flags |= CRYPT_REENCRYPT_MOVE_FIRST_SEGMENT;\n\n\treturn ri;\n}",
        "output": "0",
        "idx": 1237
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jas_matrix_t *jas_matrix_copy(jas_matrix_t *x)\n{\n\tjas_matrix_t *y;\n\tint i;\n\tint j;\n\ty = jas_matrix_create(x->numrows_, x->numcols_);\n\tfor (i = 0; i < x->numrows_; ++i) {\n\t\tfor (j = 0; j < x->numcols_; ++j) {\n\t\t\t*jas_matrix_getref(y, i, j) = jas_matrix_get(x, i, j);\n\t\t}\n\t}\n\treturn y;\n}",
        "output": "1",
        "idx": 2085
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "has_system_location (GPtrArray  *locations,\n                     const char *id)\n{\n  int i;\n\n  for (i = 0; i < locations->len; i++)\n    {\n      GFile *path = g_ptr_array_index (locations, i);\n      DirExtraData *extra_data = g_object_get_data (G_OBJECT (path), \"extra-data\");\n      if (extra_data != NULL && g_strcmp0 (extra_data->id, id) == 0)\n        return TRUE;\n    }\n\n  return FALSE;\n}",
        "output": "0",
        "idx": 1759
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\terr = security_sb_remount(sb, data);\n\tif (err)\n\t\treturn err;\n\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n\t\terr = do_remount_sb(sb, flags, data, 0);\n\tif (!err) {\n\t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;\n\t\tmnt->mnt.mnt_flags = mnt_flags;\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}",
        "output": "1",
        "idx": 2959
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F(HttpConnectionManagerConfigTest, InvalidServerName) {\n  const std::string yaml_string = R\"EOF(\nserver_name: >\n  foo\nroute_config:\n  name: local_route\nstat_prefix: router\n  )EOF\";\n\n  EXPECT_THROW(createHttpConnectionManagerConfig(yaml_string), ProtoValidationException);\n}",
        "output": "0",
        "idx": 1607
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dummy_data_cb (void *opaque, const void *buffer, size_t length)\n{\n  (void)opaque;\n  (void)buffer;\n  (void)length;\n  return 0;\n}",
        "output": "0",
        "idx": 3601
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mp_encode_lua_table_as_map(lua_State *L, mp_buf *buf, int level) {\n    size_t len = 0;\n\n    /* First step: count keys into table. No other way to do it with the\n     * Lua API, we need to iterate a first time. Note that an alternative\n     * would be to do a single run, and then hack the buffer to insert the\n     * map opcodes for message pack. Too hackish for this lib. */\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        lua_pop(L,1); /* remove value, keep key for next iteration. */\n        len++;\n    }\n\n    /* Step two: actually encoding of the map. */\n    mp_encode_map(L,buf,len);\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        /* Stack: ... key value */\n        lua_pushvalue(L,-2); /* Stack: ... key value key */\n        mp_encode_lua_type(L,buf,level+1); /* encode key */\n        mp_encode_lua_type(L,buf,level+1); /* encode val */\n    }\n}",
        "output": "1",
        "idx": 2789
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint8_t smb2cli_session_security_mode(struct smbXcli_session *session)\n{\n\tstruct smbXcli_conn *conn = session->conn;\n\tuint8_t security_mode = 0;\n\n\tif (conn == NULL) {\n\t\treturn security_mode;\n\t}\n\n\tsecurity_mode = SMB2_NEGOTIATE_SIGNING_ENABLED;\n\tif (conn->mandatory_signing) {\n\t\tsecurity_mode |= SMB2_NEGOTIATE_SIGNING_REQUIRED;\n\t}\n\n\treturn security_mode;\n}",
        "output": "1",
        "idx": 3324
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int credssp_write_ts_password_creds(rdpCredssp* credssp, wStream* s)\n{\n\tint size = 0;\n\tint innerSize = credssp_sizeof_ts_password_creds(credssp);\n\n\tif (innerSize > Stream_GetRemainingLength(s))\n\t{\n\t\tprintf(\"\\033[91m[ ERROR ] Not enough space allocated for ts_password_creds\\033[0m\");\n\t}\n\n\t/* TSPasswordCreds (SEQUENCE) */\n\n\tsize += ber_write_sequence_tag(s, innerSize);\n\n\t/* [0] domainName (OCTET STRING) */\n\tsize += ber_write_sequence_octet_string(s, 0, (BYTE*) credssp->identity.Domain, credssp->identity.DomainLength * 2);\n\n\t/* [1] userName (OCTET STRING) */\n\tsize += ber_write_sequence_octet_string(s, 1, (BYTE*) credssp->identity.User, credssp->identity.UserLength * 2);\n\n\t/* [2] password (OCTET STRING) */\n\tsize += ber_write_sequence_octet_string(s, 2, (BYTE*) credssp->identity.Password, credssp->identity.PasswordLength * 2);\n\n\treturn size;\n}",
        "output": "1",
        "idx": 3306
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WRITE_JSON_ELEMENT(ObjStart) {\n    /* increase depth, save: before first key-value no comma needed. */\n    ctx->depth++;\n    ctx->commaNeeded[ctx->depth] = false;\n    return writeChar(ctx, '{');\n}",
        "output": "1",
        "idx": 2952
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void gfs2_clear_rgrpd(struct gfs2_sbd *sdp)\n{\n\tstruct rb_node *n;\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_glock *gl;\n\n\twhile ((n = rb_first(&sdp->sd_rindex_tree))) {\n\t\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tgl = rgd->rd_gl;\n\n\t\trb_erase(n, &sdp->sd_rindex_tree);\n\n\t\tif (gl) {\n\t\t\tspin_lock(&gl->gl_lockref.lock);\n\t\t\tgl->gl_object = NULL;\n\t\t\tspin_unlock(&gl->gl_lockref.lock);\n\t\t\tgfs2_glock_add_to_lru(gl);\n\t\t\tgfs2_glock_put(gl);\n\t\t}\n\n\t\tgfs2_free_clones(rgd);\n\t\tkfree(rgd->rd_bits);\n\t\treturn_all_reservations(rgd);\n\t\tkmem_cache_free(gfs2_rgrpd_cachep, rgd);\n\t}\n}",
        "output": "1",
        "idx": 1543
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, fgets)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (spl_filesystem_file_read(intern, 0 TSRMLS_CC) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);\n} /* }}} */",
        "output": "1",
        "idx": 1484
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int tty_prepare_flip_string_flags(struct tty_struct *tty,\n\t\t\tunsigned char **chars, char **flags, size_t size)\n{\n\tint space = tty_buffer_request_room(tty, size);\n\tif (likely(space)) {\n\t\tstruct tty_buffer *tb = tty->buf.tail;\n\t\t*chars = tb->char_buf_ptr + tb->used;\n\t\t*flags = tb->flag_buf_ptr + tb->used;\n\t\ttb->used += space;\n\t}\n\treturn space;\n}",
        "output": "1",
        "idx": 985
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cirrus_bitblt_videotovideo_patterncopy(CirrusVGAState * s)\n{\n    return cirrus_bitblt_common_patterncopy(s,\n\t\t\t\t\t    s->vram_ptr +\n                                            (s->cirrus_blt_srcaddr & ~7));\n}",
        "output": "1",
        "idx": 220
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void php_set_default_dir(int id TSRMLS_DC)\n{\n\tif (DIRG(default_dir)!=-1) {\n\t\tzend_list_delete(DIRG(default_dir));\n\t}\n\n\tif (id != -1) {\n\t\tzend_list_addref(id);\n\t}\n\t\n\tDIRG(default_dir) = id;\n}",
        "output": "1",
        "idx": 1258
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void copyIPv6IfDifferent(void * dest, const void * src)\n{\n\tif(dest != src) {\n\t\tmemcpy(dest, src, sizeof(struct in6_addr));\n\t}\n}",
        "output": "1",
        "idx": 119
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DefragIPv4NoDataTest(void)\n{\n    DefragContext *dc = NULL;\n    Packet *p = NULL;\n    int id = 12;\n    int ret = 0;\n\n    DefragInit();\n\n    dc = DefragContextNew();\n    if (dc == NULL)\n        goto end;\n\n    /* This packet has an offset > 0, more frags set to 0 and no data. */\n    p = BuildTestPacket(id, 1, 0, 'A', 0);\n    if (p == NULL)\n        goto end;\n\n    /* We do not expect a packet returned. */\n    if (Defrag(NULL, NULL, p, NULL) != NULL)\n        goto end;\n\n    /* The fragment should have been ignored so no fragments should\n     * have been allocated from the pool. */\n    if (dc->frag_pool->outstanding != 0)\n        return 0;\n\n    ret = 1;\nend:\n    if (dc != NULL)\n        DefragContextDestroy(dc);\n    if (p != NULL)\n        SCFree(p);\n\n    DefragDestroy();\n    return ret;\n}",
        "output": "1",
        "idx": 774
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  inline CImg<_cimg_Tfloat> pseudoinvert(const CImg<T>& instance, const bool use_LU=false) {\n    return instance.get_pseudoinvert(use_LU);\n  }",
        "output": "0",
        "idx": 3437
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qemu_input_queue_delay(struct QemuInputEventQueueHead *queue,\n                                   QEMUTimer *timer, uint32_t delay_ms)\n{\n    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);\n    bool start_timer = QTAILQ_EMPTY(queue);\n\n    item->type = QEMU_INPUT_QUEUE_DELAY;\n    item->delay_ms = delay_ms;\n    item->timer = timer;\n    QTAILQ_INSERT_TAIL(queue, item, node);\n\n    if (start_timer) {\n        timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)\n                  + item->delay_ms);\n    }\n}",
        "output": "1",
        "idx": 2433
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nr_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nr_sock *nr;\n\n\tif (sk == NULL) return 0;\n\n\tsock_hold(sk);\n\tsock_orphan(sk);\n\tlock_sock(sk);\n\tnr = nr_sk(sk);\n\n\tswitch (nr->state) {\n\tcase NR_STATE_0:\n\tcase NR_STATE_1:\n\tcase NR_STATE_2:\n\t\tnr_disconnect(sk, 0);\n\t\tnr_destroy_socket(sk);\n\t\tbreak;\n\n\tcase NR_STATE_3:\n\t\tnr_clear_queues(sk);\n\t\tnr->n2count = 0;\n\t\tnr_write_internal(sk, NR_DISCREQ);\n\t\tnr_start_t1timer(sk);\n\t\tnr_stop_t2timer(sk);\n\t\tnr_stop_t4timer(sk);\n\t\tnr_stop_idletimer(sk);\n\t\tnr->state    = NR_STATE_2;\n\t\tsk->sk_state    = TCP_CLOSE;\n\t\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tsk->sk_state_change(sk);\n\t\tsock_set_flag(sk, SOCK_DESTROY);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsock->sk   = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1688
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_timer_user_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tint err;\n\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->tread_sem);\n\ttu->ticks = 1;\n\ttu->queue_size = 128;\n\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;\n}",
        "output": "1",
        "idx": 2793
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,\n\t\t\t\t  struct snd_pcm_hw_params __user * _params)\n{\n\tstruct snd_pcm_hw_params *params;\n\tint err;\n\n\tparams = memdup_user(_params, sizeof(*params));\n\tif (IS_ERR(params))\n\t\treturn PTR_ERR(params);\n\n\terr = snd_pcm_hw_params(substream, params);\n\tif (err < 0)\n\t\tgoto end;\n\n\tif (copy_to_user(_params, params, sizeof(*params)))\n\t\terr = -EFAULT;\nend:\n\tkfree(params);\n\treturn err;\n}",
        "output": "0",
        "idx": 1489
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cmv_process_header(CmvContext *s, const uint8_t *buf, const uint8_t *buf_end)\n{\n    int pal_start, pal_count, i, ret, fps;\n\n    if(buf_end - buf < 16) {\n        av_log(s->avctx, AV_LOG_WARNING, \"truncated header\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    s->width  = AV_RL16(&buf[4]);\n    s->height = AV_RL16(&buf[6]);\n\n    ret = ff_set_dimensions(s->avctx, s->width, s->height);\n    if (ret < 0)\n        return ret;\n\n    fps = AV_RL16(&buf[10]);\n    if (fps > 0)\n        s->avctx->time_base = (AVRational){ 1, fps };\n\n    pal_start = AV_RL16(&buf[12]);\n    pal_count = AV_RL16(&buf[14]);\n\n    buf += 16;\n    for (i=pal_start; i<pal_start+pal_count && i<AVPALETTE_COUNT && buf_end - buf >= 3; i++) {\n        s->palette[i] = AV_RB24(buf);\n        buf += 3;\n    }\n\n    return 0;\n}",
        "output": "1",
        "idx": 1696
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void perf_event_exec(void)\n{\n\tstruct perf_event_context *ctx;\n\tint ctxn;\n\n\trcu_read_lock();\n\tfor_each_task_context_nr(ctxn) {\n\t\tctx = current->perf_event_ctxp[ctxn];\n\t\tif (!ctx)\n\t\t\tcontinue;\n\n\t\tperf_event_enable_on_exec(ctx);\n\t}\n\trcu_read_unlock();\n}",
        "output": "0",
        "idx": 895
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static JSValue js_bs_put_s16(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)\n{\n\treturn js_bs_put_val(ctx, this_val, argc, argv, 4);\n}",
        "output": "0",
        "idx": 1410
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *gf_seng_get_base64_iod(GF_SceneEngine *seng)\n{\n\tu32 size, size64;\n\tu8 *buffer, *buf64;\n\tu32 i=0;\n\tGF_StreamContext*sc = NULL;\n\n\tif (!seng->ctx->root_od) return NULL;\n\n\twhile ((sc = (GF_StreamContext*)gf_list_enum(seng->ctx->streams, &i))) {\n\t\tif ((sc->streamType == GF_STREAM_SCENE) && (sc->codec_id != GF_CODECID_DIMS))\n\t\t\tbreak;\n\t}\n\tif (!sc) return NULL;\n\n\tsize = 0;\n\tgf_odf_desc_write((GF_Descriptor *) seng->ctx->root_od, &buffer, &size);\n\tbuf64 = gf_malloc(size*2);\n\tsize64 = gf_base64_encode( buffer, size, buf64, size*2);\n\tbuf64[size64] = 0;\n\tgf_free(buffer);\n\treturn buf64;\n}",
        "output": "1",
        "idx": 3454
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bpf_map_mmap_close(struct vm_area_struct *vma)\n{\n\tstruct bpf_map *map = vma->vm_file->private_data;\n\n\tif (vma->vm_flags & VM_MAYWRITE) {\n\t\tmutex_lock(&map->freeze_mutex);\n\t\tmap->writecnt--;\n\t\tmutex_unlock(&map->freeze_mutex);\n\t}\n}",
        "output": "1",
        "idx": 3640
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mce_disable_bank(int bank)\n{\n\tif (bank >= mca_cfg.banks) {\n\t\tpr_warn(FW_BUG\n\t\t\t\"Ignoring request to disable invalid MCA bank %d.\\n\",\n\t\t\tbank);\n\t\treturn;\n\t}\n\tset_bit(bank, mce_banks_ce_disabled);\n\ton_each_cpu(__mce_disable_bank, &bank, 1);\n}",
        "output": "0",
        "idx": 3329
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tipc_nl_compat_bearer_set(struct sk_buff *skb,\n\t\t\t\t     struct tipc_nl_compat_msg *msg)\n{\n\tstruct nlattr *prop;\n\tstruct nlattr *bearer;\n\tstruct tipc_link_config *lc;\n\n\tlc = (struct tipc_link_config *)TLV_DATA(msg->req);\n\n\tbearer = nla_nest_start(skb, TIPC_NLA_BEARER);\n\tif (!bearer)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_string(skb, TIPC_NLA_BEARER_NAME, lc->name))\n\t\treturn -EMSGSIZE;\n\n\tprop = nla_nest_start(skb, TIPC_NLA_BEARER_PROP);\n\tif (!prop)\n\t\treturn -EMSGSIZE;\n\n\t__tipc_add_link_prop(skb, msg, lc);\n\tnla_nest_end(skb, prop);\n\tnla_nest_end(skb, bearer);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2984
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "link_info_done (NautilusDirectory *directory,\n\t\tNautilusFile *file,\n\t\tconst char *uri,\n\t\tconst char *name, \n\t\tconst char *icon,\n\t\tgboolean is_launcher,\n\t\tgboolean is_foreign)\n{\n\tfile->details->link_info_is_up_to_date = TRUE;\n\n\tnautilus_file_set_display_name (file, name, name, TRUE);\n\t\n\tfile->details->got_link_info = TRUE;\n\tg_free (file->details->custom_icon);\n\tif (uri) {\n\t\tif (file->details->activation_location) {\n\t\t\tg_object_unref (file->details->activation_location);\n\t\t\tfile->details->activation_location = NULL;\n\t\t}\n\t\tfile->details->got_custom_activation_location = TRUE;\n\t\tfile->details->activation_location = g_file_new_for_uri (uri);\n\t}\n\tfile->details->custom_icon = g_strdup (icon);\n\tfile->details->is_launcher = is_launcher;\n\tfile->details->is_foreign_link = is_foreign;\n\t\n\tnautilus_directory_async_state_changed (directory);\n}",
        "output": "1",
        "idx": 1986
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "find_jws(struct tang_keys_info* tki, const char* thp)\n{\n    if (!tki) {\n        return NULL;\n    }\n\n    if (thp == NULL) {\n        /* Default advertisement. */\n        json_auto_t* jws = jwk_sign(tki->m_payload, tki->m_sign);\n        if (!jws) {\n            return NULL;\n        }\n        return json_incref(jws);\n    }\n    return find_by_thp(tki, thp);\n}",
        "output": "1",
        "idx": 699
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)\n{\n#ifdef GPAC_FIXED_POINT\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\tif (neg < -FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\tif (val > FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(val/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#else\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#endif\n}",
        "output": "1",
        "idx": 2081
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    ushort getPort() const { return port; }",
        "output": "1",
        "idx": 2073
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n{\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn -1;\n\n\tStream_Read(s, header->Signature, 8);\n\tStream_Read_UINT32(s, header->MessageType);\n\n\tif (strncmp((char*) header->Signature, NTLM_SIGNATURE, 8) != 0)\n\t\treturn -1;\n\n\treturn 1;\n}",
        "output": "1",
        "idx": 1542
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool some_non_temp_table_to_be_updated(THD *thd, TABLE_LIST *tables)\n{\n  for (TABLE_LIST *table= tables; table; table= table->next_global)\n  {\n    DBUG_ASSERT(table->db && table->table_name);\n    if (table->updating && !thd->find_tmp_table_share(table))\n      return 1;\n  }\n  return 0;\n}",
        "output": "0",
        "idx": 2997
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool AES_GCM_DecryptContext::Decrypt(\n\tconst void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,\n\tconst void *pIV,\n\tvoid *pPlaintextData, uint32 *pcbPlaintextData,\n\tconst void *pAdditionalAuthenticationData, size_t cbAuthenticationData\n) {\n    unsigned long long pcbPlaintextData_longlong;\n\n    const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(\n\t\tstatic_cast<unsigned char*>( pPlaintextData ), &pcbPlaintextData_longlong,\n\t\tnullptr,\n\t\tstatic_cast<const unsigned char*>( pEncryptedDataAndTag ), cbEncryptedDataAndTag,\n\t\tstatic_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,\n\t\tstatic_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )\n\t);\n\n    *pcbPlaintextData = pcbPlaintextData_longlong;\n\n    return nDecryptResult == 0;\n}",
        "output": "1",
        "idx": 2042
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int has_handler(pid_t pid, int signal) {\n\tif (signal > 0 && signal <= SIGRTMAX) {\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/proc/%d/status\", pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tEUID_ROOT();\n\t\tFILE *fp = fopen(fname, \"re\");\n\t\tEUID_USER();\n\t\tfree(fname);\n\t\tif (fp) {\n\t\t\tchar buf[BUFLEN];\n\t\t\twhile (fgets(buf, BUFLEN, fp)) {\n\t\t\t\tif (strncmp(buf, \"SigCgt:\", 7) == 0) {\n\t\t\t\t\tunsigned long long val;\n\t\t\t\t\tif (sscanf(buf + 7, \"%llx\", &val) != 1) {\n\t\t\t\t\t\tfprintf(stderr, \"Error: cannot read /proc file\\n\");\n\t\t\t\t\t\texit(1);\n\t\t\t\t\t}\n\t\t\t\t\tval >>= (signal - 1);\n\t\t\t\t\tval &= 1ULL;\n\t\t\t\t\tfclose(fp);\n\t\t\t\t\treturn val;  // 1 if process has a handler for the signal, else 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tfclose(fp);\n\t\t}\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 445
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,\n\t\t\t\t      const struct dom_sid *alias,\n\t\t\t\t      TALLOC_CTX *mem_ctx,\n\t\t\t\t      struct dom_sid **pmembers,\n\t\t\t\t      size_t *pnum_members)\n{\n\tstruct pdb_samba_dsdb_state *state = talloc_get_type_abort(\n\t\tm->private_data, struct pdb_samba_dsdb_state);\n\tstruct ldb_dn *dn;\n\tunsigned int num_members;\n\tNTSTATUS status;\n\tstruct dom_sid_buf buf;\n\tTALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);\n\tNT_STATUS_HAVE_NO_MEMORY(tmp_ctx);\n\n\tdn = ldb_dn_new_fmt(\n\t\ttmp_ctx,\n\t\tstate->ldb,\n\t\t\"<SID=%s>\",\n\t\tdom_sid_str_buf(alias, &buf));\n\tif (!dn || !ldb_dn_validate(dn)) {\n\t\treturn NT_STATUS_NO_MEMORY;\n\t}\n\n\tstatus = dsdb_enum_group_mem(state->ldb, mem_ctx, dn, pmembers, &num_members);\n\tif (NT_STATUS_IS_OK(status)) {\n\t\t*pnum_members = num_members;\n\t}\n\ttalloc_free(tmp_ctx);\n\treturn status;\n}",
        "output": "0",
        "idx": 1411
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ntop_del_hash_redis(lua_State* vm) {\n  char *key, *member;\n  Redis *redis = ntop->getRedis();\n\n  ntop->getTrace()->traceEvent(TRACE_DEBUG, \"%s() called\", __FUNCTION__);\n\n  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);\n  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);\n  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);\n\n  redis->hashDel(key, member);\n\n  return(CONST_LUA_OK);\n}",
        "output": "0",
        "idx": 3522
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool __net_get_random_once(void *buf, int nbytes, bool *done,\n\t\t\t   struct static_key *done_key)\n{\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lock, flags);\n\tif (*done) {\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t\treturn false;\n\t}\n\n\tget_random_bytes(buf, nbytes);\n\t*done = true;\n\tspin_unlock_irqrestore(&lock, flags);\n\n\t__net_random_once_disable_jump(done_key);\n\n\treturn true;\n}",
        "output": "1",
        "idx": 3426
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void add_timer_on(struct timer_list *timer, int cpu)\n{\n\tstruct timer_base *new_base, *base;\n\tunsigned long flags;\n\n\ttimer_stats_timer_set_start_info(timer);\n\tBUG_ON(timer_pending(timer) || !timer->function);\n\n\tnew_base = get_timer_cpu_base(timer->flags, cpu);\n\n\t/*\n\t * If @timer was on a different CPU, it should be migrated with the\n\t * old base locked to prevent other operations proceeding with the\n\t * wrong base locked.  See lock_timer_base().\n\t */\n\tbase = lock_timer_base(timer, &flags);\n\tif (base != new_base) {\n\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\tspin_unlock(&base->lock);\n\t\tbase = new_base;\n\t\tspin_lock(&base->lock);\n\t\tWRITE_ONCE(timer->flags,\n\t\t\t   (timer->flags & ~TIMER_BASEMASK) | cpu);\n\t}\n\n\tdebug_activate(timer, timer->expires);\n\tinternal_add_timer(base, timer);\n\tspin_unlock_irqrestore(&base->lock, flags);\n}",
        "output": "1",
        "idx": 1751
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ghash_setkey(struct crypto_shash *tfm,\n\t\t\tconst u8 *key, unsigned int keylen)\n{\n\tstruct ghash_ctx *ctx = crypto_shash_ctx(tfm);\n\n\tif (keylen != GHASH_BLOCK_SIZE) {\n\t\tcrypto_shash_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctx->gf128)\n\t\tgf128mul_free_4k(ctx->gf128);\n\tctx->gf128 = gf128mul_init_4k_lle((be128 *)key);\n\tif (!ctx->gf128)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 3100
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int checkout_conflict_add(\n\tcheckout_data *data,\n\tconst git_index_entry *conflict)\n{\n\tint error = git_index_remove(data->index, conflict->path, 0);\n\n\tif (error == GIT_ENOTFOUND)\n\t\tgit_error_clear();\n\telse if (error < 0)\n\t\treturn error;\n\n\treturn git_index_add(data->index, conflict);\n}",
        "output": "0",
        "idx": 2859
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void  opj_j2k_read_int16_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                opj_read_bytes(l_src_data,&l_temp,2);\n\n                l_src_data+=sizeof(OPJ_INT16);\n\n                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;\n        }\n}",
        "output": "0",
        "idx": 1183
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "flac_read_loop (SF_PRIVATE *psf, unsigned len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\n\tpflac->pos = 0 ;\n\tpflac->len = len ;\n\tpflac->remain = len ;\n\n\t/* First copy data that has already been decoded and buffered. */\n\tif (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)\n\t\tflac_buffer_copy (psf) ;\n\n\t/* Decode some more. */\n\twhile (pflac->pos < pflac->len)\n\t{\tif (FLAC__stream_decoder_process_single (pflac->fsd) == 0)\n\t\t\tbreak ;\n\t\tif (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)\n\t\t\tbreak ;\n\t\t} ;\n\n\tpflac->ptr = NULL ;\n\n\treturn pflac->pos ;\n} /* flac_read_loop */",
        "output": "1",
        "idx": 1841
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int crypto_rng_generate(struct crypto_rng *tfm,\n\t\t\t\t      const u8 *src, unsigned int slen,\n\t\t\t\t      u8 *dst, unsigned int dlen)\n{\n\treturn tfm->generate(tfm, src, slen, dst, dlen);\n}",
        "output": "1",
        "idx": 1871
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Filter::onDownstreamEvent(Network::ConnectionEvent event) {\n  if (event == Network::ConnectionEvent::LocalClose ||\n      event == Network::ConnectionEvent::RemoteClose) {\n    downstream_closed_ = true;\n  }\n\n  ENVOY_CONN_LOG(trace, \"on downstream event {}, has upstream = {}\", read_callbacks_->connection(),\n                 static_cast<int>(event), upstream_ == nullptr);\n\n  if (upstream_) {\n    Tcp::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(event));\n    if (conn_data != nullptr &&\n        conn_data->connection().state() != Network::Connection::State::Closed) {\n      config_->drainManager().add(config_->sharedConfig(), std::move(conn_data),\n                                  std::move(upstream_callbacks_), std::move(idle_timer_),\n                                  read_callbacks_->upstreamHost());\n    }\n    if (event != Network::ConnectionEvent::Connected) {\n      upstream_.reset();\n      disableIdleTimer();\n    }\n  }\n  if (generic_conn_pool_) {\n    if (event == Network::ConnectionEvent::LocalClose ||\n        event == Network::ConnectionEvent::RemoteClose) {\n      // Cancel the conn pool request and close any excess pending requests.\n      generic_conn_pool_.reset();\n    }\n  }\n}",
        "output": "0",
        "idx": 2611
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DLLEXPORT unsigned long DLLCALL tjBufSize(int width, int height,\n\tint jpegSubsamp)\n{\n\tunsigned long retval=0;  int mcuw, mcuh, chromasf;\n\tif(width<1 || height<1 || jpegSubsamp<0 || jpegSubsamp>=NUMSUBOPT)\n\t\t_throw(\"tjBufSize(): Invalid argument\");\n\n\t/* This allows for rare corner cases in which a JPEG image can actually be\n\t   larger than the uncompressed input (we wouldn't mention it if it hadn't\n\t   happened before.) */\n\tmcuw=tjMCUWidth[jpegSubsamp];\n\tmcuh=tjMCUHeight[jpegSubsamp];\n\tchromasf=jpegSubsamp==TJSAMP_GRAY? 0: 4*64/(mcuw*mcuh);\n\tretval=PAD(width, mcuw) * PAD(height, mcuh) * (2 + chromasf) + 2048;\n\n\tbailout:\n\treturn retval;\n}",
        "output": "0",
        "idx": 2847
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hash_walk_next(struct crypto_hash_walk *walk)\n{\n\tunsigned int alignmask = walk->alignmask;\n\tunsigned int offset = walk->offset;\n\tunsigned int nbytes = min(walk->entrylen,\n\t\t\t\t  ((unsigned int)(PAGE_SIZE)) - offset);\n\n\tif (walk->flags & CRYPTO_ALG_ASYNC)\n\t\twalk->data = kmap(walk->pg);\n\telse\n\t\twalk->data = kmap_atomic(walk->pg);\n\twalk->data += offset;\n\n\tif (offset & alignmask) {\n\t\tunsigned int unaligned = alignmask + 1 - (offset & alignmask);\n\n\t\tif (nbytes > unaligned)\n\t\t\tnbytes = unaligned;\n\t}\n\n\twalk->entrylen -= nbytes;\n\treturn nbytes;\n}",
        "output": "0",
        "idx": 3446
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  const Plane_map& pm() const { return ptr()->pm_; }",
        "output": "0",
        "idx": 2124
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void add_sit_entry(unsigned int segno, struct list_head *head)\n{\n\tstruct sit_entry_set *ses;\n\tunsigned int start_segno = START_SEGNO(segno);\n\n\tlist_for_each_entry(ses, head, set_list) {\n\t\tif (ses->start_segno == start_segno) {\n\t\t\tses->entry_cnt++;\n\t\t\tadjust_sit_entry_set(ses, head);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tses = grab_sit_entry_set();\n\n\tses->start_segno = start_segno;\n\tses->entry_cnt++;\n\tlist_add(&ses->set_list, head);\n}",
        "output": "0",
        "idx": 2292
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_siocgstampns(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, struct compat_timespec __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timespec kts;\n\tint err;\n\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);\n\tset_fs(old_fs);\n\tif (!err) {\n\t\terr = put_user(kts.tv_sec, &up->tv_sec);\n\t\terr |= __put_user(kts.tv_nsec, &up->tv_nsec);\n\t}\n\treturn err;\n}",
        "output": "1",
        "idx": 617
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void adkm_box_del(GF_Box *s)\n{\n\tGF_AdobeDRMKeyManagementSystemBox *ptr = (GF_AdobeDRMKeyManagementSystemBox *)s;\n\tif (!ptr) return;\n\tgf_free(s);\n}",
        "output": "0",
        "idx": 3273
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "valid_word_prefix(\n    int\t\ttotprefcnt,\t// nr of prefix IDs\n    int\t\tarridx,\t\t// idx in sl_pidxs[]\n    int\t\tflags,\n    char_u\t*word,\n    slang_T\t*slang,\n    int\t\tcond_req)\t// only use prefixes with a condition\n{\n    int\t\tprefcnt;\n    int\t\tpidx;\n    regprog_T\t**rp;\n    int\t\tprefid;\n\n    prefid = (unsigned)flags >> 24;\n    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)\n    {\n\tpidx = slang->sl_pidxs[arridx + prefcnt];\n\n\t// Check the prefix ID.\n\tif (prefid != (pidx & 0xff))\n\t    continue;\n\n\t// Check if the prefix doesn't combine and the word already has a\n\t// suffix.\n\tif ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))\n\t    continue;\n\n\t// Check the condition, if there is one.  The condition index is\n\t// stored in the two bytes above the prefix ID byte.\n\trp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];\n\tif (*rp != NULL)\n\t{\n\t    if (!vim_regexec_prog(rp, FALSE, word, 0))\n\t\tcontinue;\n\t}\n\telse if (cond_req)\n\t    continue;\n\n\t// It's a match!  Return the WF_ flags.\n\treturn pidx;\n    }\n    return 0;\n}",
        "output": "0",
        "idx": 1906
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\n\thfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tprintk(KERN_ERR \"hfs: found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\n\thfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),\n\t\t\t\t &tmp.thread.nodeName);\n\treturn hfs_brec_find(fd);\n}",
        "output": "1",
        "idx": 281
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "loop_info(\n\tsockaddr_u *srcadr,\n\tendpt *inter,\n\tstruct req_pkt *inpkt\n\t)\n{\n\tstruct info_loop *li;\n\tl_fp ltmp;\n\n\tli = (struct info_loop *)prepare_pkt(srcadr, inter, inpkt,\n\t    sizeof(struct info_loop));\n\n\tDTOLFP(last_offset, &ltmp);\n\tHTONL_FP(&ltmp, &li->last_offset);\n\tDTOLFP(drift_comp * 1e6, &ltmp);\n\tHTONL_FP(&ltmp, &li->drift_comp);\n\tli->compliance = htonl((u_int32)(tc_counter));\n\tli->watchdog_timer = htonl((u_int32)(current_time - sys_epoch));\n\n\tmore_pkt();\n\tflush_pkt();\n}",
        "output": "1",
        "idx": 476
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "is_link_trusted (NautilusFile *file,\n\t\t gboolean is_launcher)\n{\n\tgboolean res;\n\t\n\tif (!is_launcher) {\n\t\treturn TRUE;\n\t}\n\t\n\tif (nautilus_file_can_execute (file)) {\n\t\treturn TRUE;\n\t}\n\n\tres = FALSE;\n\t\n\tif (nautilus_file_is_local (file)) {\n\t\tconst char * const * data_dirs; \n\t\tchar *uri, *path;\n\t\tint i;\n\t\t\t\n\t\tdata_dirs = g_get_system_data_dirs ();\n\t\t\n\t\tpath = NULL;\n\t\turi = nautilus_file_get_uri (file);\n\t\tif (uri) {\n\t\t\tpath = g_filename_from_uri (uri, NULL, NULL);\n\t\t\tg_free (uri);\n\t\t}\n\n\t\tfor (i = 0; path != NULL && data_dirs[i] != NULL; i++) {\n\t\t\tif (g_str_has_prefix (path, data_dirs[i])) {\n\t\t\t\tres = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tg_free (path);\n\t}\n\t\n\t\n\treturn res;\n}",
        "output": "1",
        "idx": 2574
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int h2_task_pre_conn(conn_rec* c, void *arg)\n{\n    h2_ctx *ctx;\n    \n    if (!c->master) {\n        return OK;\n    }\n    \n    ctx = h2_ctx_get(c, 0);\n    (void)arg;\n    if (ctx->task) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, c,\n                      \"h2_h2, pre_connection, found stream task\");\n        ap_add_input_filter(\"H2_SLAVE_IN\", NULL, NULL, c);\n        ap_add_output_filter(\"H2_PARSE_H1\", NULL, NULL, c);\n        ap_add_output_filter(\"H2_SLAVE_OUT\", NULL, NULL, c);\n    }\n    return OK;\n}",
        "output": "1",
        "idx": 1413
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rfbTightExtensionClientClose(rfbClientPtr cl, void* data) {\n\n\tif(data != NULL)\n\t\tfree(data);\n\n}",
        "output": "1",
        "idx": 1885
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    //! Replace the image by an identity matrix \\newinstance.\n    CImg<T> get_identity_matrix() const {\n      return identity_matrix(std::max(_width,_height));",
        "output": "0",
        "idx": 581
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\n    bool _draw_fill(const int x, const int y, const int z,\n                    const CImg<T>& ref, const float tolerance2) const {\n      const T *ptr1 = data(x,y,z), *ptr2 = ref._data;\n      const unsigned long off = _width*_height*_depth;\n      float diff = 0;\n      cimg_forC(*this,c) { diff += cimg::sqr(*ptr1 - *(ptr2++)); ptr1+=off; }\n      return diff<=tolerance2;",
        "output": "0",
        "idx": 2828
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cap_inode_setsecurity(struct inode *inode, const char *name,\n\t\t\t\t const void *value, size_t size, int flags)\n{\n\treturn -EOPNOTSUPP;\n}",
        "output": "0",
        "idx": 2615
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MONGO_EXPORT const char *bson_iterator_string( const bson_iterator *i ) {\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_STRING:\n    case BSON_SYMBOL:\n        return bson_iterator_value( i ) + 4;\n    default:\n        return \"\";\n    }\n}",
        "output": "0",
        "idx": 2217
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TPML_TAGGED_POLICY_Unmarshal(TPML_TAGGED_POLICY *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    UINT32 i;\n    if (rc == TPM_RC_SUCCESS) {\n\trc = UINT32_Unmarshal(&target->count, buffer, size);\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tif (target->count > MAX_TAGGED_POLICIES) {\n\t    rc = TPM_RC_SIZE;\n\t}\n    }\n    for (i = 0 ; (rc == TPM_RC_SUCCESS) && (i < target->count) ; i++) {\n\trc = TPMS_TAGGED_POLICY_Unmarshal(&target->policies[i], buffer, size);\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 782
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Filter::onUpstreamEvent(Network::ConnectionEvent event) {\n  // Update the connecting flag before processing the event because we may start a new connection\n  // attempt in initializeUpstreamConnection.\n  bool connecting = connecting_;\n  connecting_ = false;\n\n  if (event == Network::ConnectionEvent::RemoteClose ||\n      event == Network::ConnectionEvent::LocalClose) {\n    upstream_.reset();\n    disableIdleTimer();\n\n    if (connecting) {\n      if (event == Network::ConnectionEvent::RemoteClose) {\n        getStreamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure);\n        read_callbacks_->upstreamHost()->outlierDetector().putResult(\n            Upstream::Outlier::Result::LocalOriginConnectFailed);\n      }\n\n      initializeUpstreamConnection();\n    } else {\n      if (read_callbacks_->connection().state() == Network::Connection::State::Open) {\n        read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);\n      }\n    }\n  }\n}",
        "output": "1",
        "idx": 2626
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "finish_incsearch_highlighting(\n\tint gotesc,\n\tincsearch_state_T *is_state,\n\tint call_update_screen)\n{\n    if (is_state->did_incsearch)\n    {\n\tis_state->did_incsearch = FALSE;\n\tif (gotesc)\n\t    curwin->w_cursor = is_state->save_cursor;\n\telse\n\t{\n\t    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))\n\t    {\n\t\t// put the '\" mark at the original position\n\t\tcurwin->w_cursor = is_state->save_cursor;\n\t\tsetpcmark();\n\t    }\n\t    curwin->w_cursor = is_state->search_start;\n\t}\n\trestore_viewstate(&is_state->old_viewstate);\n\thighlight_match = FALSE;\n\n\t// by default search all lines\n\tsearch_first_line = 0;\n\tsearch_last_line = MAXLNUM;\n\n\tmagic_overruled = is_state->magic_overruled_save;\n\n\tvalidate_cursor();\t// needed for TAB\n\tredraw_all_later(SOME_VALID);\n\tif (call_update_screen)\n\t    update_screen(SOME_VALID);\n    }\n}",
        "output": "0",
        "idx": 805
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int proc_pid_permission(struct inode *inode, int mask)\n{\n\tstruct pid_namespace *pid = inode->i_sb->s_fs_info;\n\tstruct task_struct *task;\n\tbool has_perms;\n\n\ttask = get_proc_task(inode);\n\thas_perms = has_pid_permissions(pid, task, 1);\n\tput_task_struct(task);\n\n\tif (!has_perms) {\n\t\tif (pid->hide_pid == 2) {\n\t\t\t/*\n\t\t\t * Let's make getdents(), stat(), and open()\n\t\t\t * consistent with each other.  If a process\n\t\t\t * may not stat() a file, it shouldn't be seen\n\t\t\t * in procfs at all.\n\t\t\t */\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\treturn -EPERM;\n\t}\n\treturn generic_permission(inode, mask);\n}",
        "output": "1",
        "idx": 2453
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline unsigned ip_vs_rs_hashkey(int af,\n\t\t\t\t\t    const union nf_inet_addr *addr,\n\t\t\t\t\t    __be16 port)\n{\n\tregister unsigned porth = ntohs(port);\n\t__be32 addr_fold = addr->ip;\n\n#ifdef CONFIG_IP_VS_IPV6\n\tif (af == AF_INET6)\n\t\taddr_fold = addr->ip6[0]^addr->ip6[1]^\n\t\t\t    addr->ip6[2]^addr->ip6[3];\n#endif\n\n\treturn (ntohl(addr_fold)^(porth>>IP_VS_RTAB_BITS)^porth)\n\t\t& IP_VS_RTAB_MASK;\n}",
        "output": "0",
        "idx": 1285
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Cast(const SrcT* input_data, const Dims<4>& input_dims, DstT* output_data,\n          const Dims<4>& output_dims) {\n  Cast(DimsToShape(input_dims), input_data, DimsToShape(output_dims),\n       output_data);\n}",
        "output": "0",
        "idx": 1522
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SCK_RemoveSocket(int sock_fd)\n{\n  union sockaddr_all saddr;\n  socklen_t saddr_len;\n\n  saddr_len = sizeof (saddr);\n\n  if (getsockname(sock_fd, &saddr.sa, &saddr_len) < 0) {\n    DEBUG_LOG(\"getsockname() failed : %s\", strerror(errno));\n    return 0;\n  }\n\n  if (saddr_len > sizeof (saddr) || saddr_len <= sizeof (saddr.sa.sa_family) ||\n      saddr.sa.sa_family != AF_UNIX)\n    return 0;\n\n  if (unlink(saddr.un.sun_path) < 0) {\n    DEBUG_LOG(\"unlink(%s) failed : %s\", saddr.un.sun_path, strerror(errno));\n    return 0;\n  }\n\n  DEBUG_LOG(\"Removed %s\", saddr.un.sun_path);\n\n  return 1;\n}",
        "output": "1",
        "idx": 21
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)\n{\n    FD_t wfd = NULL;\n    int rc = 0;\n\n    /* Create the file with 0200 permissions (write by owner). */\n    {\n\tmode_t old_umask = umask(0577);\n\twfd = Fopen(dest, \"w.ufdio\");\n\tumask(old_umask);\n    }\n    if (Ferror(wfd)) {\n\trc = RPMERR_OPEN_FAILED;\n\tgoto exit;\n    }\n\n    if (!nocontent)\n\trc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm);\nexit:\n    if (wfd) {\n\tint myerrno = errno;\n\tFclose(wfd);\n\terrno = myerrno;\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 3536
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)\n{\n        static const char module[] = \"TIFFWriteDirectoryTagCheckedRational\";\n\tuint32 m[2];\n\tassert(sizeof(uint32)==4);\n        if( value < 0 )\n        {\n            TIFFErrorExt(tif->tif_clientdata,module,\"Negative value is illegal\");\n            return 0;\n        }\n\telse if (value==0.0)\n\t{\n\t\tm[0]=0;\n\t\tm[1]=1;\n\t}\n\telse if (value==(double)(uint32)value)\n\t{\n\t\tm[0]=(uint32)value;\n\t\tm[1]=1;\n\t}\n\telse if (value<1.0)\n\t{\n\t\tm[0]=(uint32)(value*0xFFFFFFFF);\n\t\tm[1]=0xFFFFFFFF;\n\t}\n\telse\n\t{\n\t\tm[0]=0xFFFFFFFF;\n\t\tm[1]=(uint32)(0xFFFFFFFF/value);\n\t}\n\tif (tif->tif_flags&TIFF_SWAB)\n\t{\n\t\tTIFFSwabLong(&m[0]);\n\t\tTIFFSwabLong(&m[1]);\n\t}\n\treturn(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_RATIONAL,1,8,&m[0]));\n}",
        "output": "1",
        "idx": 1216
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Pl_RunLength::decode(unsigned char* data, size_t len)\n{\n    for (size_t i = 0; i < len; ++i)\n    {\n        unsigned char ch = data[i];\n        switch (this->state)\n        {\n          case st_top:\n            if (ch < 128)\n            {\n                // length represents remaining number of bytes to copy\n                this->length = 1 + ch;\n                this->state = st_copying;\n            }\n            else if (ch > 128)\n            {\n                // length represents number of copies of next byte\n                this->length = 257 - ch;\n                this->state = st_run;\n            }\n            else // ch == 128\n            {\n                // EOD; stay in this state\n            }\n            break;\n\n          case st_copying:\n            this->getNext()->write(&ch, 1);\n            if (--this->length == 0)\n            {\n                this->state = st_top;\n            }\n            break;\n\n          case st_run:\n            for (unsigned int j = 0; j < this->length; ++j)\n            {\n                this->getNext()->write(&ch, 1);\n            }\n            this->state = st_top;\n            break;\n        }\n    }\n}",
        "output": "1",
        "idx": 1079
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "HeaderEntry* HeaderMapImpl::get(const LowerCaseString& key) {\n  for (HeaderEntryImpl& header : headers_) {\n    if (header.key() == key.get().c_str()) {\n      return &header;\n    }\n  }\n\n  return nullptr;\n}",
        "output": "1",
        "idx": 2408
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SSL_set_accept_state(SSL *s)\n\t{\n\ts->server=1;\n\ts->shutdown=0;\n\ts->state=SSL_ST_ACCEPT|SSL_ST_BEFORE;\n\ts->handshake_func=s->method->ssl_accept;\n\t/* clear the current cipher */\n\tssl_clear_cipher_ctx(s);\n\t}",
        "output": "0",
        "idx": 697
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "evbuffer_ptr_set(struct evbuffer *buf, struct evbuffer_ptr *pos,\n    size_t position, enum evbuffer_ptr_how how)\n{\n\tsize_t left = position;\n\tstruct evbuffer_chain *chain = NULL;\n\n\tEVBUFFER_LOCK(buf);\n\n\tswitch (how) {\n\tcase EVBUFFER_PTR_SET:\n\t\tchain = buf->first;\n\t\tpos->pos = position;\n\t\tposition = 0;\n\t\tbreak;\n\tcase EVBUFFER_PTR_ADD:\n\t\t/* this avoids iterating over all previous chains if\n\t\t   we just want to advance the position */\n\t\tchain = pos->_internal.chain;\n\t\tpos->pos += position;\n\t\tposition = pos->_internal.pos_in_chain;\n\t\tbreak;\n\t}\n\n\twhile (chain && position + left >= chain->off) {\n\t\tleft -= chain->off - position;\n\t\tchain = chain->next;\n\t\tposition = 0;\n\t}\n\tif (chain) {\n\t\tpos->_internal.chain = chain;\n\t\tpos->_internal.pos_in_chain = position + left;\n\t} else {\n\t\tpos->_internal.chain = NULL;\n\t\tpos->pos = -1;\n\t}\n\n\tEVBUFFER_UNLOCK(buf);\n\n\treturn chain != NULL ? 0 : -1;\n}",
        "output": "1",
        "idx": 1932
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args)\n{\n\tstruct cil_args_build *args = extra_args;\n\tstruct cil_tree_node *ast = args->ast;\n\n\tif (ast->flavor == CIL_ROOT) {\n\t\treturn SEPOL_OK;\n\t}\n\n\targs->ast = ast->parent;\n\n\tif (ast->flavor == CIL_TUNABLEIF) {\n\t\targs->tunif = NULL;\n\t}\n\n\tif (ast->flavor == CIL_IN) {\n\t\targs->in = NULL;\n\t}\n\n\tif (ast->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t}\n\n\tif (ast->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t}\n\n\t// At this point we no longer have any need for parse_current or any of its\n\t// siblings; they have all been converted to the appropriate AST node. The\n\t// full parse tree will get deleted elsewhere, but in an attempt to\n\t// minimize memory usage (of which the parse tree uses a lot), start\n\t// deleting the parts we don't need now.\n\tcil_tree_children_destroy(parse_current->parent);\n\n\treturn SEPOL_OK;\n}",
        "output": "1",
        "idx": 2503
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Header headerFree(Header h)\n{\n    (void) headerUnlink(h);\n\n    if (h == NULL || h->nrefs > 0)\n\treturn NULL;\n\n    if (h->index) {\n\tindexEntry entry = h->index;\n\tint i;\n\tfor (i = 0; i < h->indexUsed; i++, entry++) {\n\t    if ((h->flags & HEADERFLAG_ALLOCATED) && ENTRY_IS_REGION(entry)) {\n\t\tif (entry->length > 0) {\n\t\t    int32_t * ei = entry->data;\n\t\t    if ((ei - 2) == h->blob) h->blob = _free(h->blob);\n\t\t    entry->data = NULL;\n\t\t}\n\t    } else if (!ENTRY_IN_REGION(entry)) {\n\t\tentry->data = _free(entry->data);\n\t    }\n\t    entry->data = NULL;\n\t}\n\th->index = _free(h->index);\n    }\n\n    h = _free(h);\n    return NULL;\n}",
        "output": "0",
        "idx": 1200
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "lexer_current_is_literal (parser_context_t *context_p, /**< context */\n                          const lexer_lit_location_t *right_ident_p) /**< identifier */\n{\n  JERRY_ASSERT (context_p->token.type == LEXER_LITERAL\n                && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);\n\n  lexer_lit_location_t *left_ident_p = &context_p->token.lit_location;\n\n  JERRY_ASSERT (left_ident_p->length > 0 && right_ident_p->length > 0);\n\n  if (left_ident_p->length != right_ident_p->length)\n  {\n    return false;\n  }\n\n  if (!left_ident_p->has_escape && !right_ident_p->has_escape)\n  {\n    return memcmp (left_ident_p->char_p, right_ident_p->char_p, left_ident_p->length) == 0;\n  }\n\n  return lexer_compare_identifiers (context_p, left_ident_p, right_ident_p);\n} /* lexer_current_is_literal */",
        "output": "1",
        "idx": 3671
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool tipc_sk_overlimit1(struct sock *sk, struct sk_buff *skb)\n{\n\tatomic_t *dcnt = &tipc_sk(sk)->dupl_rcvcnt;\n\tunsigned int lim = rcvbuf_limit(sk, skb) + atomic_read(dcnt);\n\tunsigned int qsize = sk->sk_backlog.len + sk_rmem_alloc_get(sk);\n\n\treturn (qsize > lim * 90 / 100);\n}",
        "output": "0",
        "idx": 2271
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int _mkp_stage_30(struct plugin *p,\n        struct client_session *cs,\n        struct session_request *sr)\n{\n    mk_ptr_t referer;\n    (void) p;\n    (void) cs;\n\n    PLUGIN_TRACE(\"[FD %i] Mandril validating URL\", cs->socket);\n    if (mk_security_check_url(sr->uri) < 0) {\n        PLUGIN_TRACE(\"[FD %i] Close connection, blocked URL\", cs->socket);\n        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n\n    PLUGIN_TRACE(\"[FD %d] Mandril validating hotlinking\", cs->socket);\n    referer = mk_api->header_get(&sr->headers_toc, \"Referer\", strlen(\"Referer\"));\n    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {\n        PLUGIN_TRACE(\"[FD %i] Close connection, deny hotlinking.\", cs->socket);\n        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n\n    return MK_PLUGIN_RET_NOT_ME;\n}",
        "output": "1",
        "idx": 2921
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ConnectionImpl::~ConnectionImpl() { nghttp2_session_del(session_); }",
        "output": "1",
        "idx": 105
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static FILE* safe_fopen(char const* filename, char const* mode)\n{\n    // This function is basically a \"C\" port of QUtil::safe_fopen.\n    FILE* f = 0;\n#ifdef _MSC_VER\n    errno_t err = fopen_s(&f, filename, mode);\n    if (err != 0)\n    {\n        char buf[94];\n        strerror_s(buf, sizeof(buf), errno);\n\tfprintf(stderr, \"%s: unable to open %s: %s\\n\",\n\t\twhoami, filename, buf);\n\texit(2);\n    }\n#else\n    f = fopen(filename, mode);\n    if (f == NULL)\n    {\n\tfprintf(stderr, \"%s: unable to open %s: %s\\n\",\n\t\twhoami, filename, strerror(errno));\n\texit(2);\n    }\n#endif\n    return f;\n}",
        "output": "0",
        "idx": 3565
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static js_Ast *memberexp(js_State *J)\n{\n\tjs_Ast *a;\n\tINCREC();\n\ta = newexp(J);\nloop:\n\tif (jsP_accept(J, '.')) { a = EXP2(MEMBER, a, identifiername(J)); goto loop; }\n\tif (jsP_accept(J, '[')) { a = EXP2(INDEX, a, expression(J, 0)); jsP_expect(J, ']'); goto loop; }\n\tDECREC();\n\treturn a;\n}",
        "output": "1",
        "idx": 1560
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ass_flush_events(ASS_Track *track)\n{\n    if (track->events) {\n        int eid;\n        for (eid = 0; eid < track->n_events; eid++)\n            ass_free_event(track, eid);\n        track->n_events = 0;\n    }\n    free(track->parser_priv->read_order_bitmap);\n    track->parser_priv->read_order_bitmap = NULL;\n    track->parser_priv->read_order_elems = 0;\n}",
        "output": "0",
        "idx": 706
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void perf_event_exit_cpu(int cpu) { }",
        "output": "1",
        "idx": 1946
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int bson_check_string( bson *b, const char *string,\n                       const int length ) {\n\n    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 0, 0 );\n}",
        "output": "1",
        "idx": 2256
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int svm_smi_allowed(struct kvm_vcpu *vcpu, bool for_injection)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tif (svm->nested.nested_run_pending)\n\t\treturn -EBUSY;\n\n\t/* An SMI must not be injected into L2 if it's supposed to VM-Exit.  */\n\tif (for_injection && is_guest_mode(vcpu) && nested_exit_on_smi(svm))\n\t\treturn -EBUSY;\n\n\treturn !svm_smi_blocked(vcpu);\n}",
        "output": "0",
        "idx": 433
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "stringprep_utf8_to_ucs4 (const char *str, ssize_t len, size_t * items_written)\n{\n  return g_utf8_to_ucs4_fast (str, (glong) len, (glong *) items_written);\n}",
        "output": "1",
        "idx": 2186
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int io_epoll_ctl_prep(struct io_kiocb *req,\n\t\t\t     const struct io_uring_sqe *sqe)\n{\n#if defined(CONFIG_EPOLL)\n\tif (sqe->ioprio || sqe->buf_index)\n\t\treturn -EINVAL;\n\n\treq->epoll.epfd = READ_ONCE(sqe->fd);\n\treq->epoll.op = READ_ONCE(sqe->len);\n\treq->epoll.fd = READ_ONCE(sqe->off);\n\n\tif (ep_op_has_event(req->epoll.op)) {\n\t\tstruct epoll_event __user *ev;\n\n\t\tev = u64_to_user_ptr(READ_ONCE(sqe->addr));\n\t\tif (copy_from_user(&req->epoll.event, ev, sizeof(*ev)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}",
        "output": "0",
        "idx": 1954
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int zpff_init(struct hid_device *hid)\n{\n\treturn 0;\n}",
        "output": "1",
        "idx": 587
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "log2vis_encoded_string (PyObject * string, const char *encoding,\n\t\t\tFriBidiParType base_direction, int clean, int reordernsm)\n{\n\tPyObject *logical = NULL;\t/* logical unicode object */\n\tPyObject *result = NULL;\t/* output string object */\n\n\t/* Always needed for the string length */\n\tlogical = PyUnicode_Decode (PyString_AS_STRING (string),\n\t\t\t\t    PyString_GET_SIZE (string),\n\t\t\t\t    encoding, \"strict\");\n\tif (logical == NULL)\n\t\treturn NULL;\n\n\tif (strcmp (encoding, \"utf-8\") == 0)\n\t\t/* Shortcut for utf8 strings (little faster) */\n\t\tresult = log2vis_utf8 (string,\n\t\t\t\t       PyUnicode_GET_SIZE (logical),\n\t\t\t\t       base_direction, clean, reordernsm);\n\telse\n\t{\n\t\t/* Invoke log2vis_unicode and encode back to encoding */\n\n\t\tPyObject *visual = log2vis_unicode (logical, base_direction, clean, reordernsm);\n\n\t\tif (visual)\n\t\t{\n\t\t\tresult = PyUnicode_Encode (PyUnicode_AS_UNICODE\n\t\t\t\t\t\t   (visual),\n\t\t\t\t\t\t   PyUnicode_GET_SIZE (visual),\n\t\t\t\t\t\t   encoding, \"strict\");\n\t\t\tPy_DECREF (visual);\n\t\t}\n\t}\n\n\tPy_DECREF (logical);\n\n\treturn result;\n}",
        "output": "1",
        "idx": 1877
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "g_file_poll_mountable_finish (GFile         *file,\n                              GAsyncResult  *result,\n                              GError       **error)\n{\n  GFileIface *iface;\n\n  g_return_val_if_fail (G_IS_FILE (file), FALSE);\n  g_return_val_if_fail (G_IS_ASYNC_RESULT (result), FALSE);\n\n  if (g_async_result_legacy_propagate_error (result, error))\n    return FALSE;\n  else if (g_async_result_is_tagged (result, g_file_poll_mountable))\n    return g_task_propagate_boolean (G_TASK (result), error);\n\n  iface = G_FILE_GET_IFACE (file);\n  return (* iface->poll_mountable_finish) (file, result, error);\n}",
        "output": "0",
        "idx": 78
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QPDFObjectHandle::getInlineImageValue()\n{\n    if (isInlineImage())\n    {\n        return dynamic_cast<QPDF_InlineImage*>(m->obj.getPointer())->getVal();\n    }\n    else\n    {\n        typeWarning(\"inlineimage\", \"returning empty data\");\n        QTC::TC(\"qpdf\", \"QPDFObjectHandle inlineimage returning empty data\");\n        return \"\";\n    }\n}",
        "output": "0",
        "idx": 3626
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  List<Item> &params()\n  {\n    return m_params;\n  }",
        "output": "0",
        "idx": 2713
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rose_start_heartbeat(struct sock *sk)\n{\n\tdel_timer(&sk->sk_timer);\n\n\tsk->sk_timer.function = rose_heartbeat_expiry;\n\tsk->sk_timer.expires  = jiffies + 5 * HZ;\n\n\tadd_timer(&sk->sk_timer);\n}",
        "output": "1",
        "idx": 2106
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bond_uninit(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct bond_up_slave *usable, *all;\n\tstruct list_head *iter;\n\tstruct slave *slave;\n\n\tbond_netpoll_cleanup(bond_dev);\n\n\t/* Release the bonded slaves */\n\tbond_for_each_slave(bond, slave, iter)\n\t\t__bond_release_one(bond_dev, slave->dev, true, true);\n\tnetdev_info(bond_dev, \"Released all slaves\\n\");\n\n\tusable = rtnl_dereference(bond->usable_slaves);\n\tif (usable) {\n\t\tRCU_INIT_POINTER(bond->usable_slaves, NULL);\n\t\tkfree_rcu(usable, rcu);\n\t}\n\n\tall = rtnl_dereference(bond->all_slaves);\n\tif (all) {\n\t\tRCU_INIT_POINTER(bond->all_slaves, NULL);\n\t\tkfree_rcu(all, rcu);\n\t}\n\n\tlist_del(&bond->bond_list);\n\n\tbond_debug_unregister(bond);\n}",
        "output": "0",
        "idx": 931
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Crypto::get_random_values(JSContext *cx, unsigned argc, JS::Value *vp) {\n  JS::CallArgs args = CallArgsFromVp(argc, vp);\n  if (!args.requireAtLeast(cx, \"crypto.getRandomValues\", 1))\n    return false;\n\n  if (!args[0].isObject() || !is_int_typed_array(&args[0].toObject())) {\n    JS_ReportErrorUTF8(cx, \"crypto.getRandomValues: input must be an integer-typed TypedArray\");\n    return false;\n  }\n\n  JS::RootedObject typed_array(cx, &args[0].toObject());\n  size_t byte_length = JS_GetArrayBufferViewByteLength(typed_array);\n  if (byte_length > MAX_BYTE_LENGTH) {\n    JS_ReportErrorUTF8(cx,\n                       \"crypto.getRandomValues: input byteLength must be at most %u, \"\n                       \"but is %zu\",\n                       MAX_BYTE_LENGTH, byte_length);\n    return false;\n  }\n\n  JS::AutoCheckCannotGC noGC(cx);\n  bool is_shared;\n  void *buffer = JS_GetArrayBufferViewData(typed_array, &is_shared, noGC);\n  arc4random_buf(buffer, byte_length);\n\n  args.rval().setObject(*typed_array);\n  return true;\n}",
        "output": "1",
        "idx": 2682
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int pud_devmap(pud_t pud)\n{\n\treturn 0;\n}",
        "output": "0",
        "idx": 3373
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_marker_parse (const RsvgDefs * defs, const char *str)\n{\n    char *name;\n\n    name = rsvg_get_url_string (str);\n    if (name) {\n        RsvgNode *val;\n        val = rsvg_defs_lookup (defs, name);\n        g_free (name);\n\n        if (val && (!strcmp (val->type->str, \"marker\")))\n            return val;\n    }\n    return NULL;\n}",
        "output": "1",
        "idx": 2135
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0, reasonLen=0;\n    char *reason=NULL;\n\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n\n    authResult = rfbClientSwap32IfLE(authResult);\n\n    switch (authResult) {\n    case rfbVncAuthOK:\n      rfbClientLog(\"VNC authentication succeeded\\n\");\n      return TRUE;\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        /* we have an error following */\n        if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;\n        reasonLen = rfbClientSwap32IfLE(reasonLen);\n        reason = malloc(reasonLen+1);\n        if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }\n        reason[reasonLen]=0;\n        rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n        free(reason);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:\n      rfbClientLog(\"VNC authentication failed - too many tries\\n\");\n      return FALSE;\n    }\n\n    rfbClientLog(\"Unknown VNC authentication result: %d\\n\",\n                 (int)authResult);\n    return FALSE;\n}",
        "output": "1",
        "idx": 579
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteTensor* GetTempRhs(TfLiteContext* context, TfLiteNode* node,\n                         const TfLiteTensor* rhs) {\n  TfLiteTensor* transposed_rhs = GetTemporary(context, node, 1);\n  if (rhs->type == kTfLiteInt8) {\n    // Get the quantization params from the RHS tensor.\n    transposed_rhs->params.scale = rhs->params.scale;\n    transposed_rhs->params.zero_point = rhs->params.zero_point;\n  }\n  return transposed_rhs;\n}",
        "output": "1",
        "idx": 141
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mnt_fs_is_deleted(struct libmnt_fs *fs)\n{\n\treturn mnt_fs_get_flags(fs) & MNT_FS_DELETED;\n}",
        "output": "1",
        "idx": 2004
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  Status check_index_ordering(const Tensor& indices) {\n    auto findices = indices.flat<int>();\n\n    for (std::size_t i = 0; i < findices.dimension(0) - 1; ++i) {\n      if (findices(i) < findices(i + 1)) {\n        continue;\n      }\n\n      return Status(\n          errors::InvalidArgument(\"Indices are not strictly ordered\"));\n    }\n\n    return Status::OK();\n  }",
        "output": "1",
        "idx": 1719
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(hash_update_file)\n{\n\tzval *zhash, *zcontext = NULL;\n\tphp_hash_data *hash;\n\tphp_stream_context *context;\n\tphp_stream *stream;\n\tchar *filename, buf[1024];\n\tint filename_len, n;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs|r\", &zhash, &filename, &filename_len, &zcontext) == FAILURE) {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(hash, php_hash_data*, &zhash, -1, PHP_HASH_RESNAME, php_hash_le_hash);\n\tcontext = php_stream_context_from_zval(zcontext, 0);\n\n\tstream = php_stream_open_wrapper_ex(filename, \"rb\", REPORT_ERRORS, NULL, context);\n\tif (!stream) {\n\t\t/* Stream will report errors opening file */\n\t\tRETURN_FALSE;\n\t}\n\n\twhile ((n = php_stream_read(stream, buf, sizeof(buf))) > 0) {\n\t\thash->ops->hash_update(hash->context, (unsigned char *) buf, n);\n\t}\n\tphp_stream_close(stream);\n\n\tRETURN_TRUE;\n}",
        "output": "1",
        "idx": 2827
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void start_auth_request(PgSocket *client, const char *username)\n{\n\tint res;\n\tPktBuf *buf;\n\n\tclient->auth_user = client->db->auth_user;\n\t/* have to fetch user info from db */\n\tclient->pool = get_pool(client->db, client->db->auth_user);\n\tif (!find_server(client)) {\n\t\tclient->wait_for_user_conn = true;\n\t\treturn;\n\t}\n\tslog_noise(client, \"Doing auth_conn query\");\n\tclient->wait_for_user_conn = false;\n\tclient->wait_for_user = true;\n\tif (!sbuf_pause(&client->sbuf)) {\n\t\trelease_server(client->link);\n\t\tdisconnect_client(client, true, \"pause failed\");\n\t\treturn;\n\t}\n\tclient->link->ready = 0;\n\n\tres = 0;\n\tbuf = pktbuf_dynamic(512);\n\tif (buf) {\n\t\tpktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);\n\t\tres = pktbuf_send_immediate(buf, client->link);\n\t\tpktbuf_free(buf);\n\t\t/*\n\t\t * Should do instead:\n\t\t *   res = pktbuf_send_queued(buf, client->link);\n\t\t * but that needs better integration with SBuf.\n\t\t */\n\t}\n\tif (!res)\n\t\tdisconnect_server(client->link, false, \"unable to send login query\");\n}",
        "output": "1",
        "idx": 3544
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void line6_toneport_disconnect(struct usb_line6 *line6)\n{\n\tstruct usb_line6_toneport *toneport =\n\t\t(struct usb_line6_toneport *)line6;\n\n\tcancel_delayed_work_sync(&toneport->pcm_work);\n\n\tif (toneport_has_led(toneport))\n\t\ttoneport_remove_leds(toneport);\n}",
        "output": "1",
        "idx": 557
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int FuzzerTestOneInput(const uint8_t *buf, size_t len)\n{\n    const unsigned char *p = buf;\n    unsigned char *der = NULL;\n\n    X509 *x509 = d2i_X509(NULL, &p, len);\n    if (x509 != NULL) {\n        BIO *bio = BIO_new(BIO_s_null());\n        /* This will load and print the public key as well as extensions */\n        X509_print(bio, x509);\n        BIO_free(bio);\n\n        i2d_X509(x509, &der);\n        OPENSSL_free(der);\n\n        X509_free(x509);\n    }\n    ERR_clear_error();\n    return 0;\n}",
        "output": "1",
        "idx": 1298
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xfrm6_tunnel_spi_fini(void)\n{\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n}",
        "output": "1",
        "idx": 2178
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "file_rlookup(const char *filename)\t/* I - Filename */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  cache_t\t*wc;\t\t\t/* Current cache file */\n\n\n  for (i = web_files, wc = web_cache; i > 0; i --, wc ++)\n    if (!strcmp(wc->name, filename))\n      return (wc->url);\n\n  return (filename);\n}",
        "output": "1",
        "idx": 1819
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "http_cleanup (void)\n{\n  xfree (pconn.host);\n  if (wget_cookie_jar)\n    cookie_jar_delete (wget_cookie_jar);\n}",
        "output": "0",
        "idx": 1926
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t runtime_active_kids_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", dev->power.ignore_children ?\n\t\t0 : atomic_read(&dev->power.child_count));\n}",
        "output": "1",
        "idx": 357
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static double ipow( double n, int exp )\n{\n\tdouble r;\n\n\tif ( exp < 0 )\n\t\treturn 1.0 / ipow( n, -exp );\n\tr = 1;\n\twhile ( exp > 0 ) {\n\t\tif ( exp & 1 )\n\t\t\tr *= n;\n\t\texp >>= 1;\n\t\tn *= n;\n\t}\n\treturn r;\n}",
        "output": "1",
        "idx": 1853
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void gen_op_movq_env_0(int d_offset)\n{\n    tcg_gen_movi_i64(cpu_tmp1_i64, 0);\n    tcg_gen_st_i64(cpu_tmp1_i64, cpu_env, d_offset);\n}",
        "output": "0",
        "idx": 1936
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ZipCommon::isValidPath(const std::string& path)\n{\n\tif (path == \"..\")\n\t\treturn false;\n\tif (path.compare(0, 3, \"../\") == 0)\n\t\treturn false;\n\tif (path.compare(0, 3, \"..\\\\\") == 0)\n\t\treturn false;\n\tif (path.find(\"/..\") != std::string::npos)\n\t\treturn false;\n\tif (path.find(\"\\\\..\") != std::string::npos)\n\t\treturn false;\n\treturn true;\n}",
        "output": "1",
        "idx": 2949
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QUtil::hex_decode(std::string const& input)\n{\n    std::string result;\n    size_t pos = 0;\n    for (std::string::const_iterator p = input.begin(); p != input.end(); ++p)\n    {\n        char ch = *p;\n        bool skip = false;\n        if ((*p >= 'A') && (*p <= 'F'))\n        {\n            ch -= 'A';\n            ch += 10;\n        }\n        else if ((*p >= 'a') && (*p <= 'f'))\n        {\n            ch -= 'a';\n            ch += 10;\n        }\n        else if ((*p >= '0') && (*p <= '9'))\n        {\n            ch -= '0';\n        }\n        else\n        {\n            skip = true;\n        }\n        if (! skip)\n        {\n            if (pos == 0)\n            {\n                result.push_back(ch << 4);\n                pos = 1;\n            }\n            else\n            {\n                result[result.length()-1] += ch;\n                pos = 0;\n            }\n        }\n    }\n    return result;\n}",
        "output": "1",
        "idx": 2303
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\treturn -ENOSYS;\n}",
        "output": "1",
        "idx": 2870
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void checkpoint_signal(int signo)\n{\n\tcheckpoint_requested = 1;\n}",
        "output": "0",
        "idx": 3575
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BitWriter::writeBits(unsigned long long val, unsigned int bits)\n{\n    write_bits(this->ch, this->bit_offset, val, bits, this->pl);\n}",
        "output": "1",
        "idx": 2172
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sodium_misuse_handler(void)\n{\n\tfatal_exit(\n\t\t\"dnscrypt: libsodium could not be initialized, this typically\"\n\t\t\" happens when no good source of entropy is found. If you run\"\n\t\t\" unbound in a chroot, make sure /dev/urandom is available. See\"\n\t\t\" https://www.unbound.net/documentation/unbound.conf.html\");\n}",
        "output": "0",
        "idx": 2937
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static intset *intsetResize(intset *is, uint32_t len) {\n    uint32_t size = len*intrev32ifbe(is->encoding);\n    is = zrealloc(is,sizeof(intset)+size);\n    return is;\n}",
        "output": "1",
        "idx": 3657
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static size_t csum_and_copy_to_pipe_iter(const void *addr, size_t bytes,\n\t\t\t\t\t struct iov_iter *i, __wsum *sump)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tunsigned int p_mask = pipe->ring_size - 1;\n\t__wsum sum = *sump;\n\tsize_t off = 0;\n\tunsigned int i_head;\n\tsize_t r;\n\n\tif (!sanity(i))\n\t\treturn 0;\n\n\tbytes = push_pipe(i, bytes, &i_head, &r);\n\twhile (bytes) {\n\t\tsize_t chunk = min_t(size_t, bytes, PAGE_SIZE - r);\n\t\tchar *p = kmap_local_page(pipe->bufs[i_head & p_mask].page);\n\t\tsum = csum_and_memcpy(p + r, addr + off, chunk, sum, off);\n\t\tkunmap_local(p);\n\t\ti->head = i_head;\n\t\ti->iov_offset = r + chunk;\n\t\tbytes -= chunk;\n\t\toff += chunk;\n\t\tr = 0;\n\t\ti_head++;\n\t}\n\t*sump = sum;\n\ti->count -= off;\n\treturn off;\n}",
        "output": "0",
        "idx": 1052
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err gf_isom_set_track_interleaving_group(GF_ISOFile *movie, u32 trackNumber, u32 GroupID)\n{\n\tGF_TrackBox *trak;\n\n\tif (movie->openMode != GF_ISOM_OPEN_EDIT) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !GroupID) return GF_BAD_PARAM;\n\n\ttrak->Media->information->sampleTable->groupID = GroupID;\n\treturn GF_OK;\n}",
        "output": "0",
        "idx": 3608
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ScanLineInputFile::ScanLineInputFile(InputPartData* part)\n{\n    if (part->header.type() != SCANLINEIMAGE)\n        throw IEX_NAMESPACE::ArgExc(\"Can't build a ScanLineInputFile from a type-mismatched part.\");\n\n    _data = new Data(part->numThreads);\n    _streamData = part->mutex;\n    _data->memoryMapped = _streamData->is->isMemoryMapped();\n\n    _data->version = part->version;\n\n    initialize(part->header);\n\n    _data->lineOffsets = part->chunkOffsets;\n\n    _data->partNumber = part->partNumber;\n    //\n    // (TODO) change this code later.\n    // The completeness of the file should be detected in MultiPartInputFile.\n    //\n    _data->fileIsComplete = true;\n}",
        "output": "1",
        "idx": 1283
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "EXPORTED int http_allow_noauth_get(struct transaction_t *txn)\n{\n    /* Inverse logic: True means we *require* authentication */\n    switch (txn->meth) {\n    case METH_GET:\n    case METH_HEAD:\n        /* Let method processing function decide if auth is needed */\n        return 0;\n    default:\n        return 1;\n    }\n}",
        "output": "0",
        "idx": 3667
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(locale_accept_from_http)\n{\n\tUEnumeration *available;\n\tchar *http_accept = NULL;\n\tint http_accept_len;\n\tUErrorCode status = 0;\n\tint len;\n\tchar resultLocale[INTL_MAX_LOCALE_LEN+1];\n\tUAcceptResult outResult;\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &http_accept, &http_accept_len) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\"locale_accept_from_http: unable to parse input parameters\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\n\tavailable = ures_openAvailableLocales(NULL, &status);\n\tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to retrieve locale list\");\n\tlen = uloc_acceptLanguageFromHTTP(resultLocale, INTL_MAX_LOCALE_LEN,\n\t\t\t\t\t\t&outResult, http_accept, available, &status);\n\tuenum_close(available);\n\tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to find acceptable locale\");\n\tif (len < 0 || outResult == ULOC_ACCEPT_FAILED) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL(resultLocale, len, 1);\n}",
        "output": "1",
        "idx": 2116
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE3(timer_create, const clockid_t, which_clock,\n\t\tstruct sigevent __user *, timer_event_spec,\n\t\ttimer_t __user *, created_timer_id)\n{\n\tif (timer_event_spec) {\n\t\tsigevent_t event;\n\n\t\tif (copy_from_user(&event, timer_event_spec, sizeof (event)))\n\t\t\treturn -EFAULT;\n\t\treturn do_timer_create(which_clock, &event, created_timer_id);\n\t}\n\treturn do_timer_create(which_clock, NULL, created_timer_id);\n}",
        "output": "0",
        "idx": 916
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned long mmap_rnd(void)\n{\n\tunsigned long rnd = 0UL;\n\n\tif (current->flags & PF_RANDOMIZE) {\n\t\tunsigned long val = get_random_int();\n\t\tif (test_thread_flag(TIF_32BIT))\n\t\t\trnd = (val % (1UL << (23UL-PAGE_SHIFT)));\n\t\telse\n\t\t\trnd = (val % (1UL << (30UL-PAGE_SHIFT)));\n\t}\n\treturn rnd << PAGE_SHIFT;\n}",
        "output": "0",
        "idx": 3103
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dev_match_devt(struct device *dev, void *data)\n{\n\tdev_t *devt = data;\n\treturn dev->devt == *devt;\n}",
        "output": "0",
        "idx": 3201
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void xdp_del_sk_umem(struct xdp_umem *umem, struct xdp_sock *xs)\n{\n\tunsigned long flags;\n\n\tif (!xs->tx)\n\t\treturn;\n\n\tspin_lock_irqsave(&umem->xsk_list_lock, flags);\n\tlist_del_rcu(&xs->list);\n\tspin_unlock_irqrestore(&umem->xsk_list_lock, flags);\n}",
        "output": "0",
        "idx": 1514
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void esp_fifo_push(ESPState *s, uint8_t val)\n{\n    if (fifo8_num_used(&s->fifo) == ESP_FIFO_SZ) {\n        trace_esp_error_fifo_overrun();\n        return;\n    }\n\n    fifo8_push(&s->fifo, val);\n}",
        "output": "1",
        "idx": 2901
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F(HttpConnectionManagerConfigTest, ServerAppendIfAbsent) {\n  const std::string yaml_string = R\"EOF(\n  stat_prefix: ingress_http\n  server_header_transformation: APPEND_IF_ABSENT\n  route_config:\n    name: local_route\n  http_filters:\n  - name: envoy.filters.http.router\n  )EOF\";\n\n  EXPECT_CALL(context_.runtime_loader_.snapshot_, featureEnabled(_, An<uint64_t>()))\n      .WillRepeatedly(Invoke(&context_.runtime_loader_.snapshot_,\n                             &Runtime::MockSnapshot::featureEnabledDefault));\n  HttpConnectionManagerConfig config(parseHttpConnectionManagerFromYaml(yaml_string), context_,\n                                     date_provider_, route_config_provider_manager_,\n                                     scoped_routes_config_provider_manager_, http_tracer_manager_,\n                                     filter_config_provider_manager_);\n  EXPECT_EQ(HttpConnectionManagerConfig::HttpConnectionManagerProto::APPEND_IF_ABSENT,\n            config.serverHeaderTransformation());\n}",
        "output": "0",
        "idx": 294
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t control_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\",\n\t\t\t\tdev->power.runtime_auto ? ctrl_auto : ctrl_on);\n}",
        "output": "1",
        "idx": 2024
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cn_proc_mcast_ctl(struct cn_msg *msg,\n\t\t\t      struct netlink_skb_parms *nsp)\n{\n\tenum proc_cn_mcast_op *mc_op = NULL;\n\tint err = 0;\n\n\tif (msg->len != sizeof(*mc_op))\n\t\treturn;\n\n\t/* \n\t * Events are reported with respect to the initial pid\n\t * and user namespaces so ignore requestors from\n\t * other namespaces.\n\t */\n\tif ((current_user_ns() != &init_user_ns) ||\n\t    (task_active_pid_ns(current) != &init_pid_ns))\n\t\treturn;\n\n\t/* Can only change if privileged. */\n\tif (!capable(CAP_NET_ADMIN)) {\n\t\terr = EPERM;\n\t\tgoto out;\n\t}\n\n\tmc_op = (enum proc_cn_mcast_op *)msg->data;\n\tswitch (*mc_op) {\n\tcase PROC_CN_MCAST_LISTEN:\n\t\tatomic_inc(&proc_event_num_listeners);\n\t\tbreak;\n\tcase PROC_CN_MCAST_IGNORE:\n\t\tatomic_dec(&proc_event_num_listeners);\n\t\tbreak;\n\tdefault:\n\t\terr = EINVAL;\n\t\tbreak;\n\t}\n\nout:\n\tcn_proc_ack(err, msg->seq, msg->ack);\n}",
        "output": "1",
        "idx": 2045
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\n    size_t aoffset = (size_t) abs(offset);\n    unsigned char *source = buf->data + buf->offset;\n    if (offset >= 0) {\n        if (buf->offset + aoffset + len > buf->maxlen) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source += aoffset;\n    } else {\n        if (buf->offset < aoffset) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source -= aoffset;\n    }\n    memmove(buf->data + buf->offset, source, len);\n    buf->offset += len;\n}",
        "output": "1",
        "idx": 1891
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint64_t LUKS2_hdr_and_areas_size(struct luks2_hdr *hdr)\n{\n\treturn LUKS2_hdr_and_areas_size_jobj(hdr->jobj);\n}",
        "output": "0",
        "idx": 749
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nv_ctrlg(cmdarg_T *cap)\n{\n    if (VIsual_active)\t// toggle Selection/Visual mode\n    {\n\tVIsual_select = !VIsual_select;\n\ttrigger_modechanged();\n\tshowmode();\n    }\n    else if (!checkclearop(cap->oap))\n\t// print full name if count given or :cd used\n\tfileinfo((int)cap->count0, FALSE, TRUE);\n}",
        "output": "0",
        "idx": 2482
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int cfg80211_mgd_wext_giwessid(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       struct iw_point *data, char *ssid)\n{\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\n\t/* call only for station! */\n\tif (WARN_ON(wdev->iftype != NL80211_IFTYPE_STATION))\n\t\treturn -EINVAL;\n\n\tdata->flags = 0;\n\n\twdev_lock(wdev);\n\tif (wdev->current_bss) {\n\t\tconst u8 *ie;\n\n\t\trcu_read_lock();\n\t\tie = ieee80211_bss_get_ie(&wdev->current_bss->pub,\n\t\t\t\t\t  WLAN_EID_SSID);\n\t\tif (ie) {\n\t\t\tdata->flags = 1;\n\t\t\tdata->length = ie[1];\n\t\t\tmemcpy(ssid, ie + 2, data->length);\n\t\t}\n\t\trcu_read_unlock();\n\t} else if (wdev->wext.connect.ssid && wdev->wext.connect.ssid_len) {\n\t\tdata->flags = 1;\n\t\tdata->length = wdev->wext.connect.ssid_len;\n\t\tmemcpy(ssid, wdev->wext.connect.ssid, data->length);\n\t}\n\twdev_unlock(wdev);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 444
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)\n{\n    ap_mutex_init(pconf);\n\n    if (!saved_server_config_defines)\n        init_config_defines(pconf);\n    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,\n                              apr_pool_cleanup_null);\n\n    mpm_common_pre_config(pconf);\n\n    return OK;\n}",
        "output": "0",
        "idx": 3485
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "set_attribute_9(TERMTYPE2 *tp, int flag)\n{\n    const char *value;\n    char *result;\n\n    value = tparm(set_attributes, 0, 0, 0, 0, 0, 0, 0, 0, flag);\n    if (PRESENT(value))\n\tresult = strdup(value);\n    else\n\tresult = 0;\n    return result;\n}",
        "output": "1",
        "idx": 3417
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void schedule_bh(void (*handler)(void))\n{\n\tWARN_ON(work_pending(&floppy_work));\n\n\tfloppy_work_fn = handler;\n\tqueue_work(floppy_wq, &floppy_work);\n}",
        "output": "0",
        "idx": 396
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ldb_msg_append_value(struct ldb_message *msg,\n\t\t\t const char *attr_name,\n\t\t\t const struct ldb_val *val,\n\t\t\t int flags)\n{\n\treturn ldb_msg_append_value_impl(msg, attr_name, val, flags, NULL);\n}",
        "output": "0",
        "idx": 1287
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hugetlb_get_unmapped_area(struct file *file, unsigned long addr,\n\t\tunsigned long len, unsigned long pgoff, unsigned long flags)\n{\n\tstruct hstate *h = hstate_file(file);\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma;\n\tunsigned long task_size = TASK_SIZE;\n\n\tif (test_thread_flag(TIF_32BIT))\n\t\ttask_size = STACK_TOP32;\n\n\tif (len & ~huge_page_mask(h))\n\t\treturn -EINVAL;\n\tif (len > task_size)\n\t\treturn -ENOMEM;\n\n\tif (flags & MAP_FIXED) {\n\t\tif (prepare_hugepage_range(file, addr, len))\n\t\t\treturn -EINVAL;\n\t\treturn addr;\n\t}\n\n\tif (addr) {\n\t\taddr = ALIGN(addr, huge_page_size(h));\n\t\tvma = find_vma(mm, addr);\n\t\tif (task_size - len >= addr &&\n\t\t    (!vma || addr + len <= vma->vm_start))\n\t\t\treturn addr;\n\t}\n\tif (mm->get_unmapped_area == arch_get_unmapped_area)\n\t\treturn hugetlb_get_unmapped_area_bottomup(file, addr, len,\n\t\t\t\tpgoff, flags);\n\telse\n\t\treturn hugetlb_get_unmapped_area_topdown(file, addr, len,\n\t\t\t\tpgoff, flags);\n}",
        "output": "1",
        "idx": 1586
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F(HttpConnectionManagerImplTest, OverlyLongHeadersRejected) {\n  setup(false, \"\");\n\n  std::string response_code;\n  std::string response_body;\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> void {\n    StreamDecoder* decoder = &conn_manager_->newStream(response_encoder_);\n    HeaderMapPtr headers{\n        new TestHeaderMapImpl{{\":authority\", \"host\"}, {\":path\", \"/\"}, {\":method\", \"GET\"}}};\n    headers->addCopy(LowerCaseString(\"Foo\"), std::string(60 * 1024, 'a'));\n\n    EXPECT_CALL(response_encoder_, encodeHeaders(_, true))\n        .WillOnce(Invoke([&response_code](const HeaderMap& headers, bool) -> void {\n          response_code = std::string(headers.Status()->value().getStringView());\n        }));\n    decoder->decodeHeaders(std::move(headers), true);\n    conn_manager_->newStream(response_encoder_);\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false); // kick off request\n\n  EXPECT_EQ(\"431\", response_code);\n  EXPECT_EQ(\"\", response_body);\n}",
        "output": "1",
        "idx": 3402
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "set_background_color(NCURSES_SP_DCLx int bg, NCURSES_SP_OUTC outc)\n{\n#ifdef USE_TERM_DRIVER\n    CallDriver_3(SP_PARM, td_color, FALSE, bg, outc);\n#else\n    if (set_a_background) {\n\tTPUTS_TRACE(\"set_a_background\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTPARM_1(set_a_background, bg),\n\t\t\t\t1, outc);\n    } else {\n\tTPUTS_TRACE(\"set_background\");\n\tNCURSES_SP_NAME(tputs) (NCURSES_SP_ARGx\n\t\t\t\tTPARM_1(set_background, toggled_colors(bg)),\n\t\t\t\t1, outc);\n    }\n#endif\n}",
        "output": "1",
        "idx": 3581
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DefragIPv4TooLargeTest(void)\n{\n    DefragContext *dc = NULL;\n    Packet *p = NULL;\n    int ret = 0;\n\n    DefragInit();\n\n    dc = DefragContextNew();\n    if (dc == NULL)\n        goto end;\n\n    /* Create a fragment that would extend past the max allowable size\n     * for an IPv4 packet. */\n    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n    if (p == NULL)\n        goto end;\n\n    /* We do not expect a packet returned. */\n    if (Defrag(NULL, NULL, p, NULL) != NULL)\n        goto end;\n    if (!ENGINE_ISSET_EVENT(p, IPV4_FRAG_PKT_TOO_LARGE))\n        goto end;\n\n    /* The fragment should have been ignored so no fragments should have\n     * been allocated from the pool. */\n    if (dc->frag_pool->outstanding != 0)\n        return 0;\n\n    ret = 1;\nend:\n    if (dc != NULL)\n        DefragContextDestroy(dc);\n    if (p != NULL)\n        SCFree(p);\n\n    DefragDestroy();\n    return ret;\n}",
        "output": "1",
        "idx": 642
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST(RegexMatchExpression, MatchesElementMultilineOff) {\n    BSONObj match = BSON(\"x\"\n                         << \"az\");\n    BSONObj notMatch = BSON(\"x\"\n                            << \"\\naz\");\n    RegexMatchExpression regex;\n    ASSERT(regex.init(\"\", \"^a\", \"\").isOK());\n    ASSERT(regex.matchesSingleElement(match.firstElement()));\n    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));\n}",
        "output": "0",
        "idx": 1388
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void str_free(OPENSSL_STRING str)\n{\n    OPENSSL_free(str);\n}",
        "output": "0",
        "idx": 2347
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct sctp_chunk *sctp_chunkify(struct sk_buff *skb,\n\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t struct sock *sk, gfp_t gfp)\n{\n\tstruct sctp_chunk *retval;\n\n\tretval = kmem_cache_zalloc(sctp_chunk_cachep, gfp);\n\n\tif (!retval)\n\t\tgoto nodata;\n\tif (!sk)\n\t\tpr_debug(\"%s: chunkifying skb:%p w/o an sk\\n\", __func__, skb);\n\n\tINIT_LIST_HEAD(&retval->list);\n\tretval->skb\t\t= skb;\n\tretval->asoc\t\t= (struct sctp_association *)asoc;\n\tretval->singleton\t= 1;\n\n\tretval->fast_retransmit = SCTP_CAN_FRTX;\n\n\t/* Polish the bead hole.  */\n\tINIT_LIST_HEAD(&retval->transmitted_list);\n\tINIT_LIST_HEAD(&retval->frag_list);\n\tSCTP_DBG_OBJCNT_INC(chunk);\n\trefcount_set(&retval->refcnt, 1);\n\nnodata:\n\treturn retval;\n}",
        "output": "0",
        "idx": 1098
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST(HeaderMapImplTest, InlineInsert) {\n  HeaderMapImpl headers;\n  EXPECT_TRUE(headers.empty());\n  EXPECT_EQ(0, headers.size());\n  EXPECT_EQ(nullptr, headers.Host());\n  headers.insertHost().value(std::string(\"hello\"));\n  EXPECT_FALSE(headers.empty());\n  EXPECT_EQ(1, headers.size());\n  EXPECT_EQ(\":authority\", headers.Host()->key().getStringView());\n  EXPECT_EQ(\"hello\", headers.Host()->value().getStringView());\n  EXPECT_EQ(\"hello\", headers.get(Headers::get().Host)->value().getStringView());\n}",
        "output": "1",
        "idx": 2336
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "i_alloc_byte_array_immovable(gs_memory_t * mem, uint num_elements,\n                             uint elt_size, client_name_t cname)\n{\n    gs_ref_memory_t * const imem = (gs_ref_memory_t *)mem;\n    obj_header_t *obj;\n\n#ifdef MEMENTO\n    if (Memento_failThisEvent())\n        return NULL;\n#endif\n\n    obj = alloc_obj(imem, (ulong) num_elements * elt_size,\n                    &st_bytes, ALLOC_IMMOVABLE | ALLOC_DIRECT,\n                    cname);\n\n    if_debug6m('A', mem, \"[a%d|+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\\n\",\n               alloc_trace_space(imem), client_name_string(cname),\n               (ulong) num_elements * elt_size,\n               num_elements, elt_size, (ulong) obj);\n    return (byte *) obj;\n}",
        "output": "1",
        "idx": 523
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Uint16 DcmSCP::checkEVENTREPORTRequest(T_DIMSE_N_EventReportRQ & /*reqMessage*/,\n                                       DcmDataset * /*reqDataset*/)\n{\n  // we default to success\n  return STATUS_Success;\n}",
        "output": "0",
        "idx": 3086
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void aio_poll_complete(struct aio_kiocb *iocb, __poll_t mask)\n{\n\tstruct file *file = iocb->poll.file;\n\n\taio_complete(iocb, mangle_poll(mask), 0);\n\tfput(file);\n}",
        "output": "1",
        "idx": 3363
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void svm_free_nested(struct vcpu_svm *svm)\n{\n\tif (!svm->nested.initialized)\n\t\treturn;\n\n\tsvm_vcpu_free_msrpm(svm->nested.msrpm);\n\tsvm->nested.msrpm = NULL;\n\n\t__free_page(virt_to_page(svm->nested.vmcb02.ptr));\n\tsvm->nested.vmcb02.ptr = NULL;\n\n\t/*\n\t * When last_vmcb12_gpa matches the current vmcb12 gpa,\n\t * some vmcb12 fields are not loaded if they are marked clean\n\t * in the vmcb12, since in this case they are up to date already.\n\t *\n\t * When the vmcb02 is freed, this optimization becomes invalid.\n\t */\n\tsvm->nested.last_vmcb12_gpa = INVALID_GPA;\n\n\tsvm->nested.initialized = false;\n}",
        "output": "0",
        "idx": 3590
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cmd_anal_rtti(RCore *core, const char *input) {\n\tswitch (input[0]) {\n\tcase '\\0': // \"avr\"\n\tcase 'j': // \"avrj\"\n\t\tr_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);\n\t\tbreak;\n\tcase 'a': // \"avra\"\n\t\tr_anal_rtti_print_all (core->anal, input[1]);\n\t\tbreak;\n\tcase 'D': { // \"avrD\"\n\t\tchar *dup = strdup (input + 1);\n\t\tif (!dup) {\n\t\t\tbreak;\n\t\t}\n\t\tchar *name = r_str_trim (dup);\n\t\tchar *demangled = r_anal_rtti_demangle_class_name (core->anal, dup);\n\t\tfree (name);\n\t\tif (demangled) {\n\t\t\tr_cons_println (demangled);\n\t\t\tfree (demangled);\n\t\t}\n\t\tbreak;\n\t}\n\tdefault :\n\t\tr_core_cmd_help (core, help_msg_av);\n\t\tbreak;\n\t}\n}",
        "output": "0",
        "idx": 3603
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool bt_att_set_debug(struct bt_att *att, bt_att_debug_func_t callback,\n\t\t\t\tvoid *user_data, bt_att_destroy_func_t destroy)\n{\n\tif (!att)\n\t\treturn false;\n\n\tif (att->debug_destroy)\n\t\tatt->debug_destroy(att->debug_data);\n\n\tatt->debug_callback = callback;\n\tatt->debug_destroy = destroy;\n\tatt->debug_data = user_data;\n\n\treturn true;\n}",
        "output": "0",
        "idx": 2031
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool PM_io_parser<PMDEC>::read_face(Face_handle f)\n{ // syntax: index { halfedge, fclist, ivlist, mark }\n  int n, ei, vi; Mark m;\n  if ( !(in >> n) || !check_sep(\"{\") ) return false;\n  if ( !(in >> ei) || !check_sep(\",\") ) return false;\n  if (ei >= 0) f->set_halfedge(Halfedge_of[ei]);\n  while (in >> ei) {\n    CGAL_assertion_msg(ei >= 0 && (std::size_t) ei < en, \"wrong index in face cycle list.\");\n    f->store_fc(Halfedge_of[ei]);\n  } in.clear();\n  if (!check_sep(\",\")) { return false; }\n  while (in >> vi) {\n    CGAL_assertion_msg(vi >= 0 && (std::size_t) vi < vn, \"wrong index in iso vertex list.\");\n    f->store_iv(Vertex_of[vi]);\n  } in.clear();\n  if (!check_sep(\",\") || !(in >> m) || !check_sep(\"}\") )\n    return false;\n  mark(f) = m;\n  return true;\n}",
        "output": "1",
        "idx": 3686
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_rsvg_node_poly_free (RsvgNode * self)\n{\n    RsvgNodePoly *poly = (RsvgNodePoly *) self;\n    if (poly->path)\n        rsvg_cairo_path_destroy (poly->path);\n    _rsvg_node_finalize (&poly->super);\n    g_free (poly);\n}",
        "output": "0",
        "idx": 3294
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "z2grestoreall(i_ctx_t *i_ctx_p)\n{\n    for (;;) {\n        if (!restore_page_device(igs, gs_gstate_saved(igs))) {\n            bool done = !gs_gstate_saved(gs_gstate_saved(igs));\n\n            gs_grestore(igs);\n            if (done)\n                break;\n        } else\n            return push_callout(i_ctx_p, \"%grestoreallpagedevice\");\n    }\n    return 0;\n}",
        "output": "1",
        "idx": 1250
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "efind(name)\nchar *name;\n{\n\tstatic char efbuf[100];\n\tmy_regex_t re;\n\n\tsprintf(efbuf, \"REG_%s\", name);\n\tassert(strlen(efbuf) < sizeof(efbuf));\n\tre.re_endp = efbuf;\n\t(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));\n\treturn(atoi(efbuf));\n}",
        "output": "1",
        "idx": 2911
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {\n    Sfdouble_t d;\n    char *last;\n\n    if (*str == 0) {\n        if (ptr) *ptr = (char *)str;\n        return 0;\n    }\n    errno = 0;\n    d = number(str, &last, shp->inarith ? 0 : 10, NULL);\n    if (*last) {\n        if (*last != '.' || last[1] != '.') {\n            d = strval(shp, str, &last, arith, mode);\n            Varsubscript = true;\n        }\n        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);\n    } else if (!d && *str == '-') {\n        d = -0.0;\n    }\n    if (ptr) *ptr = last;\n    return d;\n}",
        "output": "1",
        "idx": 3161
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int smb_vfs_call_chdir(struct vfs_handle_struct *handle, const char *path)\n{\n\tVFS_FIND(chdir);\n\treturn handle->fns->chdir_fn(handle, path);\n}",
        "output": "0",
        "idx": 1008
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void io_req_free_batch_finish(struct io_ring_ctx *ctx,\n\t\t\t\t     struct req_batch *rb)\n{\n\tif (rb->to_free)\n\t\t__io_req_free_batch_flush(ctx, rb);\n\tif (rb->task) {\n\t\tput_task_struct_many(rb->task, rb->task_refs);\n\t\trb->task = NULL;\n\t}\n}",
        "output": "1",
        "idx": 2002
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "        static int on_method(http_parser* self_)\n        {\n            HTTPParser* self = static_cast<HTTPParser*>(self_);\n            self->req.method = static_cast<HTTPMethod>(self->method);\n\n            return 0;\n        }",
        "output": "0",
        "idx": 878
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vsock_release(struct socket *sock)\n{\n\t__vsock_release(sock->sk);\n\tsock->sk = NULL;\n\tsock->state = SS_FREE;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1074
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int check_line_charstring(void)\n{\n  char *p = line;\n  while (isspace(*p))\n    p++;\n  return (*p == '/' || (p[0] == 'd' && p[1] == 'u' && p[2] == 'p'));\n}",
        "output": "1",
        "idx": 3604
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TPMI_RH_HIERARCHY_POLICY_Unmarshal(TPMI_RH_HIERARCHY_POLICY *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n    \n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPM_HANDLE_Unmarshal(target, buffer, size);  \n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tswitch (*target) {\n\t  case TPM_RH_OWNER:\n\t  case TPM_RH_PLATFORM:\n\t  case TPM_RH_ENDORSEMENT:\n\t  case TPM_RH_LOCKOUT:\n\t    break;\n\t  default:\n\t      {\n\t\t  BOOL isNotHP =  (*target < TPM_RH_ACT_0) || (*target > TPM_RH_ACT_F);\n\t\t  if (isNotHP) {\n\t\t      rc = TPM_RC_VALUE;\n\t\t  }\n\t      }\n\t}\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 3012
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,\n\t\t\t\t      u64 chunk_offset)\n{\n\tstruct btrfs_block_group_cache *cache;\n\tu64 bytes_used;\n\tu64 chunk_type;\n\n\tcache = btrfs_lookup_block_group(fs_info, chunk_offset);\n\tASSERT(cache);\n\tchunk_type = cache->flags;\n\tbtrfs_put_block_group(cache);\n\n\tif (chunk_type & BTRFS_BLOCK_GROUP_DATA) {\n\t\tspin_lock(&fs_info->data_sinfo->lock);\n\t\tbytes_used = fs_info->data_sinfo->bytes_used;\n\t\tspin_unlock(&fs_info->data_sinfo->lock);\n\n\t\tif (!bytes_used) {\n\t\t\tstruct btrfs_trans_handle *trans;\n\t\t\tint ret;\n\n\t\t\ttrans =\tbtrfs_join_transaction(fs_info->tree_root);\n\t\t\tif (IS_ERR(trans))\n\t\t\t\treturn PTR_ERR(trans);\n\n\t\t\tret = btrfs_force_chunk_alloc(trans,\n\t\t\t\t\t\t      BTRFS_BLOCK_GROUP_DATA);\n\t\t\tbtrfs_end_transaction(trans);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tbtrfs_add_raid_kobjects(fs_info);\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 2885
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int putint(jas_stream_t *out, int sgnd, int prec, long val)\n{\n\tint n;\n\tint c;\n\tbool s;\n\tulong tmp;\n\tassert((!sgnd && prec >= 1) || (sgnd && prec >= 2));\n\tif (sgnd) {\n\t\tval = encode_twos_comp(val, prec);\n\t}\n\tassert(val >= 0);\n\tval &= (1 << prec) - 1;\n\tn = (prec + 7) / 8;\n\twhile (--n >= 0) {\n\t\tc = (val >> (n * 8)) & 0xff;\n\t\tif (jas_stream_putc(out, c) != c)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 1876
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE cState_space_before_set(VALUE self, VALUE space_before)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(space_before, T_STRING);\n    len = RSTRING_LEN(space_before);\n    if (len == 0) {\n        if (state->space_before) {\n            ruby_xfree(state->space_before);\n            state->space_before = NULL;\n            state->space_before_len = 0;\n        }\n    } else {\n        if (state->space_before) ruby_xfree(state->space_before);\n        state->space_before = strdup(RSTRING_PTR(space_before));\n        state->space_before_len = len;\n    }\n    return Qnil;\n}",
        "output": "1",
        "idx": 2897
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "flatpak_bwrap_steal_fds (FlatpakBwrap *bwrap,\n                         gsize        *len_out)\n{\n  gsize len = bwrap->fds->len;\n  int *res = (int *) g_array_free (bwrap->fds, FALSE);\n\n  bwrap->fds = g_array_new (FALSE, TRUE, sizeof (int));\n  *len_out = len;\n  return res;\n}",
        "output": "0",
        "idx": 2642
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    static CImg<T> row_vector(const T& a0, const T& a1, const T& a2, const T& a3,\n                              const T& a4, const T& a5, const T& a6, const T& a7,\n                              const T& a8, const T& a9, const T& a10, const T& a11,\n                              const T& a12) {\n      CImg<T> r(13,1);\n      r[0] = a0; r[1] = a1; r[2] = a2; r[3] = a3; r[4] = a4; r[5] = a5; r[6] = a6; r[7] = a7; r[8] = a8; r[9] = a9;\n      r[10] = a10; r[11] = a11; r[12] = a12;\n      return r;\n    }",
        "output": "0",
        "idx": 1977
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Status AuthorizationManager::getRolesDescription(OperationContext* txn,\n                                                 const std::vector<RoleName>& roleName,\n                                                 PrivilegeFormat privileges,\n                                                 BSONObj* result) {\n    return _externalState->getRolesDescription(txn, roleName, privileges, result);\n}",
        "output": "0",
        "idx": 614
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct eventpoll *ep = file->private_data;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\n\tmutex_lock_nested(&ep->mtx, call_nests + 1);\n\tfor (rbp = rb_first(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (unlikely(is_file_epoll(epi->ffd.file))) {\n\t\t\terror = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,\n\t\t\t\t\t       ep_loop_check_proc, epi->ffd.file,\n\t\t\t\t\t       epi->ffd.file->private_data, current);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ep->mtx);\n\n\treturn error;\n}",
        "output": "1",
        "idx": 2383
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "add_istr_to_list (gpointer key, gpointer value, gpointer callback_data)\n{\n\tGList **list;\n\n\tlist = callback_data;\n\t*list = g_list_prepend (*list, g_strdup (key));\n}",
        "output": "0",
        "idx": 3309
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ms_response_get_basename (MsResponse *response)\n{\n  return http_path_get_basename (response->path);\n}",
        "output": "0",
        "idx": 3549
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RGWGetBucketReplication_ObjStore_S3::send_response_data()\n{\n  if (op_ret)\n    set_req_state_err(s, op_ret);\n  dump_errno(s);\n  end_header(s, this, \"application/xml\");\n  dump_start(s);\n\n  ReplicationConfiguration conf;\n\n  if (s->bucket_info.sync_policy) {\n    auto policy = s->bucket_info.sync_policy;\n\n    auto iter = policy->groups.find(enabled_group_id);\n    if (iter != policy->groups.end()) {\n      conf.from_sync_policy_group(store, iter->second);\n    }\n    iter = policy->groups.find(disabled_group_id);\n    if (iter != policy->groups.end()) {\n      conf.from_sync_policy_group(store, iter->second);\n    }\n  }\n\n  if (!op_ret) {\n  s->formatter->open_object_section_in_ns(\"ReplicationConfiguration\", XMLNS_AWS_S3);\n  conf.dump_xml(s->formatter);\n  s->formatter->close_section();\n  rgw_flush_formatter_and_reset(s, s->formatter);\n  }\n}",
        "output": "0",
        "idx": 1622
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {}",
        "output": "0",
        "idx": 1445
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ikev1_vid_print(netdissect_options *ndo, u_char tpay _U_,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_VID)));\n\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_VID)));\n\treturn NULL;\n}",
        "output": "1",
        "idx": 2416
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CURLcode Curl_dupset(struct SessionHandle *dst, struct SessionHandle *src)\n{\n  CURLcode result = CURLE_OK;\n  enum dupstring i;\n\n  /* Copy src->set into dst->set first, then deal with the strings\n     afterwards */\n  dst->set = src->set;\n\n  /* clear all string pointers first */\n  memset(dst->set.str, 0, STRING_LAST * sizeof(char *));\n\n  /* duplicate all strings */\n  for(i=(enum dupstring)0; i< STRING_LAST; i++) {\n    result = setstropt(&dst->set.str[i], src->set.str[i]);\n    if(result)\n      break;\n  }\n\n  /* If a failure occurred, freeing has to be performed externally. */\n  return result;\n}",
        "output": "1",
        "idx": 1114
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vnc_async_encoding_start(VncState *orig, VncState *local)\n{\n    local->vnc_encoding = orig->vnc_encoding;\n    local->features = orig->features;\n    local->ds = orig->ds;\n    local->vd = orig->vd;\n    local->lossy_rect = orig->lossy_rect;\n    local->write_pixels = orig->write_pixels;\n    local->clientds = orig->clientds;\n    local->tight = orig->tight;\n    local->zlib = orig->zlib;\n    local->hextile = orig->hextile;\n    local->zrle = orig->zrle;\n    local->output =  queue->buffer;\n    local->csock = -1; /* Don't do any network work on this thread */\n\n    buffer_reset(&local->output);\n}",
        "output": "1",
        "idx": 3692
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)\n\t{\n\tint extdatalen=0;\n\tunsigned char *ret = p;\n\n\tret+=2;\n\tif (ret>=limit) return NULL; /* this really never occurs, but ... */\n\n\tif (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL)\n\t\t{ \n\t\tif (limit - p - 4 < 0) return NULL; \n\n\t\ts2n(TLSEXT_TYPE_server_name,ret);\n\t\ts2n(0,ret);\n\t\t}\n\t\n\tif ((extdatalen = ret-p-2)== 0) \n\t\treturn p;\n\n\ts2n(extdatalen,p);\n\treturn ret;\n}",
        "output": "1",
        "idx": 193
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void g_dhcp_server_stop(GDHCPServer *dhcp_server)\n{\n\t/* Save leases, before stop; load them before start */\n\tsave_lease(dhcp_server);\n\n\tif (dhcp_server->listener_watch > 0) {\n\t\tg_source_remove(dhcp_server->listener_watch);\n\t\tdhcp_server->listener_watch = 0;\n\t}\n\n\tdhcp_server->listener_channel = NULL;\n\n\tdhcp_server->started = FALSE;\n}",
        "output": "0",
        "idx": 1527
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,\n                                 hwaddr *plen, bool resolve_subpage)\n{\n    MemoryRegionSection *section;\n    MemoryRegion *mr;\n    Int128 diff;\n\n    section = address_space_lookup_region(d, addr, resolve_subpage);\n    /* Compute offset within MemoryRegionSection */\n    addr -= section->offset_within_address_space;\n\n    /* Compute offset within MemoryRegion */\n    *xlat = addr + section->offset_within_region;\n\n    mr = section->mr;\n    if (memory_region_is_ram(mr)) {\n        diff = int128_sub(mr->size, int128_make64(addr));\n        *plen = int128_get64(int128_min(diff, int128_make64(*plen)));\n    }\n    return section;\n}",
        "output": "1",
        "idx": 1416
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "     \\param user_path Specified path, or \\c 0 to get the path currently used.\n     \\param reinit_path Force path to be recalculated (may take some time).\n     \\return Path containing the \\c gzip binary.\n  **/\n  inline const char *gzip_path(const char *const user_path, const bool reinit_path) {\n    static CImg<char> s_path;\n    cimg::mutex(7);\n    if (reinit_path) s_path.assign();\n    if (user_path) {\n      if (!s_path) s_path.assign(1024);\n      std::strncpy(s_path,user_path,1023);\n    } else if (!s_path) {\n      s_path.assign(1024);\n      bool path_found = false;\n      std::FILE *file = 0;\n#if cimg_OS==2\n      if (!path_found) {\n        std::strcpy(s_path,\".\\\\gzip.exe\");\n        if ((file=std_fopen(s_path,\"r\"))!=0) { cimg::fclose(file); path_found = true; }\n      }\n      if (!path_found) std::strcpy(s_path,\"gzip.exe\");\n#else\n      if (!path_found) {\n        std::strcpy(s_path,\"./gzip\");\n        if ((file=std_fopen(s_path,\"r\"))!=0) { cimg::fclose(file); path_found = true; }\n      }\n      if (!path_found) std::strcpy(s_path,\"gzip\");\n#endif\n      winformat_string(s_path);",
        "output": "0",
        "idx": 3025
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Pipeline::SourceContainer::iterator DocumentSourceGraphLookUp::doOptimizeAt(\n    Pipeline::SourceContainer::iterator itr, Pipeline::SourceContainer* container) {\n    invariant(*itr == this);\n\n    if (std::next(itr) == container->end()) {\n        return container->end();\n    }\n\n    // If we are not already handling an $unwind stage internally, we can combine with the following\n    // $unwind stage.\n    auto nextUnwind = dynamic_cast<DocumentSourceUnwind*>((*std::next(itr)).get());\n    if (nextUnwind && !_unwind && nextUnwind->getUnwindPath() == _as.fullPath()) {\n        _unwind = std::move(nextUnwind);\n        container->erase(std::next(itr));\n        return itr;\n    }\n    return std::next(itr);\n}",
        "output": "0",
        "idx": 293
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "m4_mkstemp (struct obstack *obs, int argc, token_data **argv)\n{\n  if (bad_argc (argv[0], argc, 2, 2))\n    return;\n  mkstemp_helper (obs, ARG (1));\n}",
        "output": "1",
        "idx": 2724
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\nGF_Box *segr_New()\n{\n\tISOM_DECL_BOX_ALLOC(FDSessionGroupBox, GF_ISOM_BOX_TYPE_SEGR);\n\treturn (GF_Box *)tmp;",
        "output": "0",
        "idx": 3470
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QString AOClient::decodeMessage(QString incoming_message)\n{\n   QString decoded_message = incoming_message.replace(\"<num>\", \"#\")\n                                             .replace(\"<percent>\", \"%\")\n                                             .replace(\"<dollar>\", \"$\")\n                                             .replace(\"<and>\", \"&\");\n    return decoded_message;\n}",
        "output": "0",
        "idx": 1099
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QPDFObjectHandle::isMatrix()\n{\n    if (! isArray())\n    {\n        return false;\n    }\n    if (getArrayNItems() != 6)\n    {\n        return false;\n    }\n    for (int i = 0; i < 6; ++i)\n    {\n        if (! getArrayItem(i).isNumber())\n        {\n            return false;\n        }\n    }\n    return true;\n}",
        "output": "0",
        "idx": 1823
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  uint32_t readBool(bool& value) {\n    T_VIRTUAL_CALL();\n    return readBool_virt(value);\n  }",
        "output": "0",
        "idx": 3580
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loadaddr, Sdb *sdb){\n\tvoid *res = NULL;\n\tRBuffer *tbuf = NULL;\n\tif (!buf || !sz || sz == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\ttbuf = r_buf_new ();\n\tif (!tbuf) {\n\t\treturn NULL;\n\t}\t\t \n\tr_buf_set_bytes (tbuf, buf, sz);\n\tres = r_bin_dex_new_buf (tbuf);\n\tr_buf_free (tbuf);\n\treturn res;\n}",
        "output": "0",
        "idx": 3342
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool numa_is_active_node(int nid, struct numa_group *ng)\n{\n\treturn group_faults_cpu(ng, nid) * ACTIVE_NODE_FRACTION > ng->max_faults_cpu;\n}",
        "output": "0",
        "idx": 621
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteRegistration* Register_WHILE() {\n  static TfLiteRegistration r = {while_kernel::Init, while_kernel::Free,\n                                 while_kernel::Prepare, while_kernel::Eval};\n  return &r;\n}",
        "output": "0",
        "idx": 745
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus AverageEval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  switch (input->type) {  // Already know in/out types are same.\n    case kTfLiteFloat32:\n      AverageEvalFloat<kernel_type>(context, node, params, data, input, output);\n      break;\n    case kTfLiteUInt8:\n      AverageEvalQuantizedUint8<kernel_type>(context, node, params, data, input,\n                                             output);\n      break;\n    case kTfLiteInt8:\n      AverageEvalQuantizedInt8<kernel_type>(context, node, params, data, input,\n                                            output);\n      break;\n    case kTfLiteInt16:\n      AverageEvalQuantizedInt16<kernel_type>(context, node, params, data, input,\n                                             output);\n      break;\n    default:\n      TF_LITE_KERNEL_LOG(context, \"Type %s not currently supported.\",\n                         TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}",
        "output": "1",
        "idx": 3414
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ath6kl_wmi_disconnect_event_rx(struct wmi *wmi, u8 *datap, int len,\n\t\t\t\t\t  struct ath6kl_vif *vif)\n{\n\tstruct wmi_disconnect_event *ev;\n\twmi->traffic_class = 100;\n\n\tif (len < sizeof(struct wmi_disconnect_event))\n\t\treturn -EINVAL;\n\n\tev = (struct wmi_disconnect_event *) datap;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   \"wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\\n\",\n\t\t   le16_to_cpu(ev->proto_reason_status), ev->bssid,\n\t\t   ev->disconn_reason, ev->assoc_resp_len);\n\n\twmi->is_wmm_enabled = false;\n\n\tath6kl_disconnect_event(vif, ev->disconn_reason,\n\t\t\t\tev->bssid, ev->assoc_resp_len, ev->assoc_info,\n\t\t\t\tle16_to_cpu(ev->proto_reason_status));\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2358
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qemu_input_queue_process(void *opaque)\n{\n    struct QemuInputEventQueueHead *queue = opaque;\n    QemuInputEventQueue *item;\n\n    g_assert(!QTAILQ_EMPTY(queue));\n    item = QTAILQ_FIRST(queue);\n    g_assert(item->type == QEMU_INPUT_QUEUE_DELAY);\n    QTAILQ_REMOVE(queue, item, node);\n    g_free(item);\n\n    while (!QTAILQ_EMPTY(queue)) {\n        item = QTAILQ_FIRST(queue);\n        switch (item->type) {\n        case QEMU_INPUT_QUEUE_DELAY:\n            timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)\n                      + item->delay_ms);\n            return;\n        case QEMU_INPUT_QUEUE_EVENT:\n            qemu_input_event_send(item->src, item->evt);\n            qapi_free_InputEvent(item->evt);\n            break;\n        case QEMU_INPUT_QUEUE_SYNC:\n            qemu_input_event_sync();\n            break;\n        }\n        QTAILQ_REMOVE(queue, item, node);\n        g_free(item);\n    }\n}",
        "output": "1",
        "idx": 598
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE cState_object_nl_set(VALUE self, VALUE object_nl)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(object_nl, T_STRING);\n    len = RSTRING_LEN(object_nl);\n    if (len == 0) {\n        if (state->object_nl) {\n            ruby_xfree(state->object_nl);\n            state->object_nl = NULL;\n        }\n    } else {\n        if (state->object_nl) ruby_xfree(state->object_nl);\n        state->object_nl = strdup(RSTRING_PTR(object_nl));\n        state->object_nl_len = len;\n    }\n    return Qnil;\n}",
        "output": "1",
        "idx": 2397
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  usage( char*  execname )\n  {\n    fprintf( stderr,  \"\\n\" );\n    fprintf( stderr,  \"ftgrid: simple glyph grid viewer -- part of the FreeType project\\n\" );\n    fprintf( stderr,  \"-----------------------------------------------------------\\n\" );\n    fprintf( stderr,  \"\\n\" );\n    fprintf( stderr,  \"Usage: %s [status below] ppem fontname[.ttf|.ttc] ...\\n\",\n             execname );\n    fprintf( stderr,  \"\\n\" );\n    fprintf( stderr,  \"  -r R      use resolution R dpi (default: 72 dpi)\\n\" );\n    fprintf( stderr,  \"  -f index  specify first index to display\\n\" );\n    fprintf( stderr,  \"\\n\" );\n\n    exit( 1 );\n  }",
        "output": "0",
        "idx": 896
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rb_str_center(argc, argv, str)\n    int argc;\n    VALUE *argv;\n    VALUE str;\n{\n    return rb_str_justify(argc, argv, str, 'c');\n}",
        "output": "0",
        "idx": 619
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void audit_log_execve_info(struct audit_context *context,\n\t\t\t\t  struct audit_buffer **ab)\n{\n\tint i, len;\n\tsize_t len_sent = 0;\n\tconst char __user *p;\n\tchar *buf;\n\n\tp = (const char __user *)current->mm->arg_start;\n\n\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);\n\n\t/*\n\t * we need some kernel buffer to hold the userspace args.  Just\n\t * allocate one big one rather than allocating one of the right size\n\t * for every single argument inside audit_log_single_execve_arg()\n\t * should be <8k allocation so should be pretty safe.\n\t */\n\tbuf = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);\n\tif (!buf) {\n\t\taudit_panic(\"out of memory for argv string\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < context->execve.argc; i++) {\n\t\tlen = audit_log_single_execve_arg(context, ab, i,\n\t\t\t\t\t\t  &len_sent, p, buf);\n\t\tif (len <= 0)\n\t\t\tbreak;\n\t\tp += len;\n\t}\n\tkfree(buf);\n}",
        "output": "1",
        "idx": 3209
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dname_pkt_hash(sldns_buffer* pkt, uint8_t* dname, hashvalue_type h)\n{\n\tuint8_t labuf[LDNS_MAX_LABELLEN+1];\n\tuint8_t lablen;\n\tint i;\n\n\t/* preserve case of query, make hash label by label */\n\tlablen = *dname++;\n\twhile(lablen) {\n\t\tif(LABEL_IS_PTR(lablen)) {\n\t\t\t/* follow pointer */\n\t\t\tdname = sldns_buffer_at(pkt, PTR_OFFSET(lablen, *dname));\n\t\t\tlablen = *dname++;\n\t\t\tcontinue;\n\t\t}\n\t\tlog_assert(lablen <= LDNS_MAX_LABELLEN);\n\t\tlabuf[0] = lablen;\n\t\ti=0;\n\t\twhile(lablen--) {\n\t\t\tlabuf[++i] = (uint8_t)tolower((unsigned char)*dname);\n\t\t\tdname++;\n\t\t}\n\t\th = hashlittle(labuf, labuf[0] + 1, h);\n\t\tlablen = *dname++;\n\t}\n\n\treturn h;\n}",
        "output": "1",
        "idx": 3366
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct inode *inode_insert5(struct inode *inode, unsigned long hashval,\n\t\t\t    int (*test)(struct inode *, void *),\n\t\t\t    int (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(inode->i_sb, hashval);\n\tstruct inode *old;\n\nagain:\n\tspin_lock(&inode_hash_lock);\n\told = find_inode(inode->i_sb, head, test, data);\n\tif (unlikely(old)) {\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under us.\n\t\t * Use the old inode instead of the preallocated one.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\twait_on_inode(old);\n\t\tif (unlikely(inode_unhashed(old))) {\n\t\t\tiput(old);\n\t\t\tgoto again;\n\t\t}\n\t\treturn old;\n\t}\n\n\tif (set && unlikely(set(inode, data))) {\n\t\tinode = NULL;\n\t\tgoto unlock;\n\t}\n\n\t/*\n\t * Return the locked inode with I_NEW set, the\n\t * caller is responsible for filling in the contents\n\t */\n\tspin_lock(&inode->i_lock);\n\tinode->i_state |= I_NEW;\n\thlist_add_head(&inode->i_hash, head);\n\tspin_unlock(&inode->i_lock);\nunlock:\n\tspin_unlock(&inode_hash_lock);\n\n\treturn inode;\n}",
        "output": "0",
        "idx": 618
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mux_chr_close(struct CharDriverState *chr)\n{\n    MuxDriver *d = chr->opaque;\n\n    qemu_chr_fe_deinit(&d->chr);\n    g_free(d);\n}",
        "output": "1",
        "idx": 2278
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct file *__fget_files(struct files_struct *files, unsigned int fd,\n\t\t\t\t fmode_t mask, unsigned int refs)\n{\n\tstruct file *file;\n\n\trcu_read_lock();\nloop:\n\tfile = files_lookup_fd_rcu(files, fd);\n\tif (file) {\n\t\t/* File object ref couldn't be taken.\n\t\t * dup2() atomicity guarantee is the reason\n\t\t * we loop to catch the new file (or NULL pointer)\n\t\t */\n\t\tif (file->f_mode & mask)\n\t\t\tfile = NULL;\n\t\telse if (!get_file_rcu_many(file, refs))\n\t\t\tgoto loop;\n\t}\n\trcu_read_unlock();\n\n\treturn file;\n}",
        "output": "1",
        "idx": 3017
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ZipTest::verifyDataFile(const std::string& path, Poco::UInt64 size)\n{\n\tstd::ifstream in(path.c_str(), std::ios::binary);\n\tassert( ! in.fail() );\n\tPoco::Buffer<char> buffer1(MB);\n\tPoco::Buffer<char> buffer2(MB);\n\tfor (int i = 0; size != 0; i++)\n\t{\n\t\tstd::memset(buffer1.begin(), i, buffer1.size());\n\t\tstd::memset(buffer2.begin(), 0, buffer2.size());\n\t\tPoco::UInt64 bytesToRead = std::min(size, static_cast<Poco::UInt64>(buffer2.size()));\n\t\tin.read(buffer2.begin(), bytesToRead);\n\t\tassert(!in.fail() );\n\t\tassert(std::memcmp(buffer1.begin(), buffer2.begin(), static_cast<std::size_t>(bytesToRead)) == 0);\n\t\tsize -= bytesToRead;\n\t}\n\tchar c;\n\tin.read(&c, 1);\n\tassert ( in.eof() );\n}",
        "output": "1",
        "idx": 3583
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AverageEvalQuantizedInt16(TfLiteContext* context, TfLiteNode* node,\n                               TfLitePoolParams* params, OpData* data,\n                               const TfLiteTensor* input,\n                               TfLiteTensor* output) {\n  int32_t activation_min;\n  int32_t activation_max;\n  CalculateActivationRangeQuantized(context, params->activation, output,\n                                    &activation_min, &activation_max);\n#define TF_LITE_AVERAGE_POOL(type)                                         \\\n  tflite::PoolParams op_params;                                            \\\n  op_params.stride_height = params->stride_height;                         \\\n  op_params.stride_width = params->stride_width;                           \\\n  op_params.filter_height = params->filter_height;                         \\\n  op_params.filter_width = params->filter_width;                           \\\n  op_params.padding_values.height = data->padding.height;                  \\\n  op_params.padding_values.width = data->padding.width;                    \\\n  op_params.quantized_activation_min = activation_min;                     \\\n  op_params.quantized_activation_max = activation_max;                     \\\n  type::AveragePool(op_params, GetTensorShape(input),                      \\\n                    GetTensorData<int16_t>(input), GetTensorShape(output), \\\n                    GetTensorData<int16_t>(output))\n  TF_LITE_AVERAGE_POOL(reference_integer_ops);\n#undef TF_LITE_AVERAGE_POOL\n}",
        "output": "1",
        "idx": 1647
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_state_finalize (RsvgState * state)\n{\n    g_free (state->font_family);\n    g_free (state->lang);\n    rsvg_paint_server_unref (state->fill);\n    rsvg_paint_server_unref (state->stroke);\n\n    if (state->dash.n_dash != 0)\n        g_free (state->dash.dash);\n\n    if (state->styles) {\n        g_hash_table_unref (state->styles);\n        state->styles = NULL;\n    }\n}",
        "output": "1",
        "idx": 1400
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BROTLI_INLINE uint32_t ReadBlockLength(const HuffmanCode* table,\n                                              BrotliBitReader* br) {\n  uint32_t code;\n  uint32_t nbits;\n  code = ReadSymbol(table, br);\n  nbits = kBlockLengthPrefixCode[code].nbits;  /* nbits == 2..24 */\n  return kBlockLengthPrefixCode[code].offset + BrotliReadBits24(br, nbits);\n}",
        "output": "1",
        "idx": 130
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __fastcall Refresh(const UnicodeString & Session, const UnicodeString & Path)\r\n{\r\n  THandles OtherInstances;\r\n  FindOtherInstances(OtherInstances);\r\n\r\n  THandles::const_iterator I = OtherInstances.begin();\r\n  while (I != OtherInstances.end())\r\n  {\r\n    HWND Handle = *I;\r\n\r\n    TCopyDataMessage Message;\r\n    Message.Command = TCopyDataMessage::RefreshPanel;\r\n    wcsncpy(Message.Refresh.Session, Session.c_str(), LENOF(Message.Refresh.Session));\r\n    NULL_TERMINATE(Message.Refresh.Session);\r\n    wcsncpy(Message.Refresh.Path, Path.c_str(), LENOF(Message.Refresh.Path));\r\n    NULL_TERMINATE(Message.Refresh.Path);\r\n\r\n    SendCopyDataMessage(Handle, Message);\r\n\r\n    I++;\r\n  }\r\n}\r",
        "output": "0",
        "idx": 3068
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F(QueryPlannerTest, MultikeySharedPrefixNoIntersectOutsideElemMatch2) {\n    // true means multikey\n    addIndex(BSON(\"a.b\" << 1 << \"a.c\" << 1), true);\n    runQuery(fromjson(\"{a: {$elemMatch: {b: 1, c: 1}}, 'a.b': 1}\"));\n\n    assertNumSolutions(3U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: \"\n        \"{'a.b': [[1,1,true,true]], \"\n        \" 'a.c': [[1,1,true,true]]}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: \"\n        \"{'a.b': [[1,1,true,true]], \"\n        \" 'a.c': [['MinKey','MaxKey',true,true]]}}}}}\");\n}",
        "output": "0",
        "idx": 505
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool samba_private_attr_name(const char *unix_ea_name)\n{\n\tstatic const char * const prohibited_ea_names[] = {\n\t\tSAMBA_POSIX_INHERITANCE_EA_NAME,\n\t\tSAMBA_XATTR_DOS_ATTRIB,\n\t\tSAMBA_XATTR_MARKER,\n\t\tXATTR_NTACL_NAME,\n\t\tNULL\n\t};\n\n\tint i;\n\n\tfor (i = 0; prohibited_ea_names[i]; i++) {\n\t\tif (strequal( prohibited_ea_names[i], unix_ea_name))\n\t\t\treturn true;\n\t}\n\tif (strncasecmp_m(unix_ea_name, SAMBA_XATTR_DOSSTREAM_PREFIX,\n\t\t\tstrlen(SAMBA_XATTR_DOSSTREAM_PREFIX)) == 0) {\n\t\treturn true;\n\t}\n\treturn false;\n}",
        "output": "1",
        "idx": 36
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {\n  auto& self = instance();\n  WriteLock lock(self.create_mutex_);\n\n  if (self.db_ == nullptr) {\n    // Create primary SQLite DB instance.\n    openOptimized(self.db_);\n    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));\n    attachVirtualTables(self.connection_);\n  }\n\n  // Internal usage may request the primary connection explicitly.\n  if (primary) {\n    return self.connection_;\n  }\n\n  // Create a 'database connection' for the managed database instance.\n  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);\n  if (!instance->isPrimary()) {\n    attachVirtualTables(instance);\n  }\n  return instance;\n}",
        "output": "1",
        "idx": 826
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tsk_set_nagle(struct tipc_sock *tsk)\n{\n\tstruct sock *sk = &tsk->sk;\n\n\ttsk->maxnagle = 0;\n\tif (sk->sk_type != SOCK_STREAM)\n\t\treturn;\n\tif (tsk->nodelay)\n\t\treturn;\n\tif (!(tsk->peer_caps & TIPC_NAGLE))\n\t\treturn;\n\t/* Limit node local buffer size to avoid receive queue overflow */\n\tif (tsk->max_pkt == MAX_MSG_SIZE)\n\t\ttsk->maxnagle = 1500;\n\telse\n\t\ttsk->maxnagle = tsk->max_pkt;\n}",
        "output": "0",
        "idx": 2580
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "set_context_in_disassemble_cmd(expand_T *xp, char_u *arg)\n{\n    char_u\t*p;\n\n    // Default: expand user functions, \"debug\" and \"profile\"\n    xp->xp_context = EXPAND_DISASSEMBLE;\n    xp->xp_pattern = arg;\n\n    // first argument already typed: only user function names\n    if (*arg != NUL && *(p = skiptowhite(arg)) != NUL)\n    {\n\txp->xp_context = EXPAND_USER_FUNC;\n\txp->xp_pattern = skipwhite(p);\n    }\n}",
        "output": "0",
        "idx": 1979
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mk_request_premature_close(int http_status, struct client_session *cs)\n{\n    struct session_request *sr;\n    struct mk_list *sr_list = &cs->request_list;\n    struct mk_list *host_list = &config->hosts;\n\n    /*\n     * If the connection is too premature, we need to allocate a temporal session_request\n     * to do not break the plugins stages\n     */\n    if (mk_list_is_empty(sr_list) == 0) {\n        sr = &cs->sr_fixed;\n        memset(sr, 0, sizeof(struct session_request));\n        mk_request_init(sr);\n        mk_list_add(&sr->_head, &cs->request_list);\n    }\n    else {\n        sr = mk_list_entry_first(sr_list, struct session_request, _head);\n    }\n\n    /* Raise error */\n    if (http_status > 0) {\n        if (!sr->host_conf) {\n            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);\n        }\n        mk_request_error(http_status, cs, sr);\n\n        /* STAGE_40, request has ended */\n        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, cs->socket,\n                            NULL, cs, sr);\n    }\n\n    /* STAGE_50, connection closed  and remove client_session*/\n    mk_plugin_stage_run(MK_PLUGIN_STAGE_50, cs->socket, NULL, NULL, NULL);\n    mk_session_remove(cs->socket);\n}",
        "output": "0",
        "idx": 2543
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sco_conn_del(struct hci_conn *hcon, int err)\n{\n\tstruct sco_conn *conn = hcon->sco_data;\n\tstruct sock *sk;\n\n\tif (!conn)\n\t\treturn;\n\n\tBT_DBG(\"hcon %p conn %p, err %d\", hcon, conn, err);\n\n\t/* Kill socket */\n\tsco_conn_lock(conn);\n\tsk = conn->sk;\n\tsco_conn_unlock(conn);\n\n\tif (sk) {\n\t\tsock_hold(sk);\n\t\tbh_lock_sock(sk);\n\t\tsco_sock_clear_timer(sk);\n\t\tsco_chan_del(sk, err);\n\t\tbh_unlock_sock(sk);\n\t\tsco_sock_kill(sk);\n\t\tsock_put(sk);\n\t}\n\n\thcon->sco_data = NULL;\n\tkfree(conn);\n}",
        "output": "0",
        "idx": 1458
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cleanup_queue(struct avdtp *session, struct avdtp_stream *stream)\n{\n\tGSList *l;\n\tstruct pending_req *req;\n\n\twhile ((l = g_slist_find_custom(session->prio_queue, stream,\n\t\t\t\t\t\t\tpending_req_cmp))) {\n\t\treq = l->data;\n\t\tpending_req_free(req);\n\t\tsession->prio_queue = g_slist_remove(session->prio_queue, req);\n\t}\n\n\twhile ((l = g_slist_find_custom(session->req_queue, stream,\n\t\t\t\t\t\t\tpending_req_cmp))) {\n\t\treq = l->data;\n\t\tpending_req_free(req);\n\t\tsession->req_queue = g_slist_remove(session->req_queue, req);\n\t}\n}",
        "output": "0",
        "idx": 2496
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "      static double mp_dot(_cimg_math_parser& mp) {\n        const unsigned int siz = (unsigned int)mp.opcode[4];\n        return CImg<doubleT>(&_mp_arg(2) + 1,1,siz,1,1,true).\n          dot(CImg<doubleT>(&_mp_arg(3) + 1,1,siz,1,1,true));\n      }",
        "output": "0",
        "idx": 1771
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_wrap_umac128_set_key(void *ctx, size_t len, const uint8_t * key)\n{\n\tif (unlikely(len != 16))\n\t\tabort();\n\tumac128_set_key(ctx, key);\n}",
        "output": "0",
        "idx": 2639
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    void CiffEntry::doAddComponent(UniquePtr /*component*/)\n    {\n        throw Error(kerFunctionNotSupported, \"CiffEntry::add\");\n    }",
        "output": "0",
        "idx": 3261
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __init of_unittest_overlay_0(void)\n{\n\t/* device should enable */\n\tif (of_unittest_apply_overlay_check(0, 0, 0, 1, PDEV_OVERLAY))\n\t\treturn;\n\n\tunittest(1, \"overlay test %d passed\\n\", 0);\n}",
        "output": "0",
        "idx": 944
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CLASS kodak_thumb_load_raw()\n{\n  int row, col;\n  colors = thumb_misc >> 5;\n  for (row=0; row < height; row++)\n    for (col=0; col < width; col++)\n      read_shorts (image[row*width+col], colors);\n  maximum = (1 << (thumb_misc & 31)) - 1;\n}",
        "output": "1",
        "idx": 2192
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_msi_enabled(struct pci_vdev *dev)\n{\n\treturn dev->msi.enabled;\n}",
        "output": "0",
        "idx": 3720
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "localtime_r(const time_t *t, struct tm *tm)\n{\n    auto struct tm *tmp = localtime(t);\n    if (tmp)\n\t*tm = *tmp;\n    return tmp;\n}",
        "output": "0",
        "idx": 1430
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int __init early_init_dt_scan_rtas(unsigned long node,\n\t\tconst char *uname, int depth, void *data)\n{\n\tconst u32 *basep, *entryp, *sizep;\n\n\tif (depth != 1 || strcmp(uname, \"rtas\") != 0)\n\t\treturn 0;\n\n\tbasep  = of_get_flat_dt_prop(node, \"linux,rtas-base\", NULL);\n\tentryp = of_get_flat_dt_prop(node, \"linux,rtas-entry\", NULL);\n\tsizep  = of_get_flat_dt_prop(node, \"rtas-size\", NULL);\n\n\tif (basep && entryp && sizep) {\n\t\trtas.base = *basep;\n\t\trtas.entry = *entryp;\n\t\trtas.size = *sizep;\n\t}\n\n#ifdef CONFIG_UDBG_RTAS_CONSOLE\n\tbasep = of_get_flat_dt_prop(node, \"put-term-char\", NULL);\n\tif (basep)\n\t\trtas_putchar_token = *basep;\n\n\tbasep = of_get_flat_dt_prop(node, \"get-term-char\", NULL);\n\tif (basep)\n\t\trtas_getchar_token = *basep;\n\n\tif (rtas_putchar_token != RTAS_UNKNOWN_SERVICE &&\n\t    rtas_getchar_token != RTAS_UNKNOWN_SERVICE)\n\t\tudbg_init_rtas_console();\n\n#endif\n\n\t/* break now */\n\treturn 1;\n}",
        "output": "0",
        "idx": 180
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __perf_event_header__init_id(struct perf_event_header *header,\n\t\t\t\t\t struct perf_sample_data *data,\n\t\t\t\t\t struct perf_event *event)\n{\n\tu64 sample_type = event->attr.sample_type;\n\n\tdata->type = sample_type;\n\theader->size += event->id_header_size;\n\n\tif (sample_type & PERF_SAMPLE_TID) {\n\t\t/* namespace issues */\n\t\tdata->tid_entry.pid = perf_event_pid(event, current);\n\t\tdata->tid_entry.tid = perf_event_tid(event, current);\n\t}\n\n\tif (sample_type & PERF_SAMPLE_TIME)\n\t\tdata->time = perf_event_clock(event);\n\n\tif (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))\n\t\tdata->id = primary_event_id(event);\n\n\tif (sample_type & PERF_SAMPLE_STREAM_ID)\n\t\tdata->stream_id = event->id;\n\n\tif (sample_type & PERF_SAMPLE_CPU) {\n\t\tdata->cpu_entry.cpu\t = raw_smp_processor_id();\n\t\tdata->cpu_entry.reserved = 0;\n\t}\n}",
        "output": "0",
        "idx": 2971
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\n\tmemcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);\n\treturn 0;\n}",
        "output": "1",
        "idx": 1867
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k)\n{\n        opj_tcp_t * l_tcp = 00;\n        OPJ_UINT32 l_nb_tiles = 0;\n        OPJ_UINT32 l_max_poc = 0;\n        OPJ_UINT32 i;\n\n        l_tcp = p_j2k->m_cp.tcps;\n        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n\n        for (i=0;i<l_nb_tiles;++i) {\n                l_max_poc = opj_uint_max(l_max_poc,l_tcp->numpocs);\n                ++l_tcp;\n        }\n\n        ++l_max_poc;\n\n        return 4 + 9 * l_max_poc;\n}",
        "output": "0",
        "idx": 1565
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mif_validate(jas_stream_t *in)\n{\n\tuchar buf[MIF_MAGICLEN];\n\tuint_fast32_t magic;\n\tint i;\n\tint n;\n\n\tassert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);\n\n\t/* Read the validation data (i.e., the data used for detecting\n\t  the format). */\n\tif ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {\n\t\treturn -1;\n\t}\n\n\t/* Put the validation data back onto the stream, so that the\n\t  stream position will not be changed. */\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Was enough data read? */\n\tif (n < MIF_MAGICLEN) {\n\t\treturn -1;\n\t}\n\n\t/* Compute the signature value. */\n\tmagic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |\n\t  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |\n\t  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |\n\t  buf[3];\n\n\t/* Ensure that the signature is correct for this format. */\n\tif (magic != MIF_MAGIC) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1504
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(oci_lob_load)\n{\n\tzval **tmp, *z_descriptor = getThis();\n\tphp_oci_descriptor *descriptor;\n\tchar *buffer = NULL;\n\tub4 buffer_len;\n\n\tif (!getThis()) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"O\", &z_descriptor, oci_lob_class_entry_ptr) == FAILURE) {\n\t\t\treturn;\n\t\t}\t\n\t}\n\t\n\tif (zend_hash_find(Z_OBJPROP_P(z_descriptor), \"descriptor\", sizeof(\"descriptor\"), (void **)&tmp) == FAILURE) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to find descriptor property\");\n\t\tRETURN_FALSE;\n\t}\n\t\n\tPHP_OCI_ZVAL_TO_DESCRIPTOR(*tmp, descriptor);\n\n\tif (php_oci_lob_read(descriptor, -1, 0, &buffer, &buffer_len TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\tif (buffer_len > 0) {\n\t\tRETURN_STRINGL(buffer, buffer_len, 0);\n\t}\n\telse {\n\t\tRETURN_EMPTY_STRING();\n\t}\n}",
        "output": "1",
        "idx": 3455
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "strerrorSignalHandler(struct J9PortLibrary* portLibrary, U_32 gpType, void* gpInfo, void* userData)\n{\n\treturn J9PORT_SIG_EXCEPTION_RETURN;\n}",
        "output": "0",
        "idx": 1292
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void probe_driver(struct btd_adapter *adapter, gpointer user_data)\n{\n\tstruct btd_adapter_driver *driver = user_data;\n\tint err;\n\n\tif (driver->probe == NULL)\n\t\treturn;\n\n\terr = driver->probe(adapter);\n\tif (err < 0) {\n\t\tbtd_error(adapter->dev_id, \"%s: %s (%d)\", driver->name,\n\t\t\t\t\t\t\tstrerror(-err), -err);\n\t\treturn;\n\t}\n\n\tadapter->drivers = g_slist_prepend(adapter->drivers, driver);\n}",
        "output": "0",
        "idx": 537
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool AES_GCM_EncryptContext::Encrypt(\n\tconst void *pPlaintextData, size_t cbPlaintextData,\n\tconst void *pIV,\n\tvoid *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,\n\tconst void *pAdditionalAuthenticationData, size_t cbAuthenticationData\n) {\n    unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;\n\n    crypto_aead_aes256gcm_encrypt_afternm(\n\t\tstatic_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong,\n\t\tstatic_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,\n\t\tstatic_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,\n\t\tnullptr,\n\t\tstatic_cast<const unsigned char*>( pIV ),\n\t\tstatic_cast<const crypto_aead_aes256gcm_state*>( m_ctx )\n\t);\n\n    *pcbEncryptedDataAndTag = pcbEncryptedDataAndTag_longlong;\n\n    return true;\n}",
        "output": "1",
        "idx": 1865
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int nfcmrvl_parse_dt(struct device_node *node,\n\t\t     struct nfcmrvl_platform_data *pdata)\n{\n\tint reset_n_io;\n\n\treset_n_io = of_get_named_gpio(node, \"reset-n-io\", 0);\n\tif (reset_n_io < 0) {\n\t\tpr_info(\"no reset-n-io config\\n\");\n\t} else if (!gpio_is_valid(reset_n_io)) {\n\t\tpr_err(\"invalid reset-n-io GPIO\\n\");\n\t\treturn reset_n_io;\n\t}\n\tpdata->reset_n_io = reset_n_io;\n\n\tif (of_find_property(node, \"hci-muxed\", NULL))\n\t\tpdata->hci_muxed = 1;\n\telse\n\t\tpdata->hci_muxed = 0;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 3678
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int FIPS_des3_test(void)\n\t{\n\tint ret = 0;\n\tunsigned char pltmp[8];\n\tunsigned char citmp[8];\n    \tunsigned char key[] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,\n\t\t              19,20,21,22,23,24};\n    \tunsigned char plaintext[] = { 'e', 't', 'a', 'o', 'n', 'r', 'i', 's' };\n\tEVP_CIPHER_CTX ctx;\n\tFIPS_cipher_ctx_init(&ctx);\n\tif (FIPS_cipherinit(&ctx, EVP_des_ede3_ecb(), key, NULL, 1) <= 0)\n\t\tgoto err;\n\tFIPS_cipher(&ctx, citmp, plaintext, 8);\n\tif (FIPS_cipherinit(&ctx, EVP_des_ede3_ecb(), key, NULL, 0) <= 0)\n\t\tgoto err;\n\tFIPS_cipher(&ctx, pltmp, citmp, 8);\n\tif (memcmp(pltmp, plaintext, 8))\n\t\tgoto err;\n\tret = 1;\n\terr:\n\tFIPS_cipher_ctx_cleanup(&ctx);\n\treturn ret;\n\t}",
        "output": "0",
        "idx": 1972
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MagickExport QuantizeInfo *AcquireQuantizeInfo(const ImageInfo *image_info)\n{\n  QuantizeInfo\n    *quantize_info;\n\n  quantize_info=(QuantizeInfo *) AcquireMagickMemory(sizeof(*quantize_info));\n  if (quantize_info == (QuantizeInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  GetQuantizeInfo(quantize_info);\n  if (image_info != (ImageInfo *) NULL)\n    {\n      const char\n        *option;\n\n      quantize_info->dither=image_info->dither;\n      option=GetImageOption(image_info,\"dither\");\n      if (option != (const char *) NULL)\n        quantize_info->dither_method=(DitherMethod) ParseCommandOption(\n          MagickDitherOptions,MagickFalse,option);\n      quantize_info->measure_error=image_info->verbose;\n    }\n  return(quantize_info);\n}",
        "output": "0",
        "idx": 3659
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint64_t get_refcount(unsigned int order, void *rcblock, size_t index)\n{\n\tswitch (order) {\n\tcase 0:\n\t\treturn (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;\n\tcase 1:\n\t\treturn (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;\n\tcase 2:\n\t\treturn (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;\n\tcase 3:\n\t\treturn ((uint8_t *)rcblock)[index];\n\tcase 4:\n\t\treturn be16toh(((uint16_t *)rcblock)[index]);\n\tcase 5:\n\t\treturn be32toh(((uint32_t *)rcblock)[index]);\n\tcase 6:\n\t\treturn be64toh(((uint64_t *)rcblock)[index]);\n\tdefault:\n\t\tassert(0);\n\t}\n\n\treturn 0;\t/* NOT REACHED */\n}",
        "output": "0",
        "idx": 867
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "option_was_set(char_u *name)\n{\n    int idx;\n\n    idx = findoption(name);\n    if (idx < 0)\t/* unknown option */\n\treturn FALSE;\n    if (options[idx].flags & P_WAS_SET)\n\treturn TRUE;\n    return FALSE;\n}",
        "output": "0",
        "idx": 1223
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_winopt(winopt_T *wop UNUSED)\n{\n#ifdef FEAT_FOLDING\n    check_string_option(&wop->wo_fdi);\n    check_string_option(&wop->wo_fdm);\n    check_string_option(&wop->wo_fdm_save);\n# ifdef FEAT_EVAL\n    check_string_option(&wop->wo_fde);\n    check_string_option(&wop->wo_fdt);\n# endif\n    check_string_option(&wop->wo_fmr);\n#endif\n#ifdef FEAT_SIGNS\n    check_string_option(&wop->wo_scl);\n#endif\n#ifdef FEAT_RIGHTLEFT\n    check_string_option(&wop->wo_rlc);\n#endif\n#ifdef FEAT_STL_OPT\n    check_string_option(&wop->wo_stl);\n#endif\n#ifdef FEAT_SYN_HL\n    check_string_option(&wop->wo_cc);\n#endif\n#ifdef FEAT_CONCEAL\n    check_string_option(&wop->wo_cocu);\n#endif\n#ifdef FEAT_LINEBREAK\n    check_string_option(&wop->wo_briopt);\n#endif\n}",
        "output": "0",
        "idx": 3109
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Chapters::Display::Clear() {\n  delete[] m_string;\n  m_string = NULL;\n\n  delete[] m_language;\n  m_language = NULL;\n\n  delete[] m_country;\n  m_country = NULL;\n}",
        "output": "0",
        "idx": 2560
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "disp_idle_fn(ev, data)\nstruct event *ev;\nchar *data;\n{\n  struct display *olddisplay;\n  display = (struct display *)data;\n  debug(\"idle timeout\\n\");\n  if (idletimo <= 0 || idleaction.nr == RC_ILLEGAL)\n    return;\n  olddisplay = display;\n  flayer = D_forecv->c_layer;\n  fore = D_fore;\n  DoAction(&idleaction, -1);\n  if (idleaction.nr == RC_BLANKER)\n    return;\n  for (display = displays; display; display = display->d_next)\n    if (olddisplay == display)\n      break;\n  if (display)\n    ResetIdle();\n}",
        "output": "0",
        "idx": 3280
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ElectronBrowserHandlerImpl::SetTemporaryZoomLevel(double level) {\n  api::WebContents* api_web_contents = api::WebContents::From(web_contents());\n  if (api_web_contents) {\n    api_web_contents->SetTemporaryZoomLevel(level);\n  }\n}",
        "output": "1",
        "idx": 903
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MONGO_COMPILER_NOINLINE void DocumentSourceUnionWith::logStartingSubPipeline(\n    const std::vector<BSONObj>& serializedPipe) {\n    LOGV2_DEBUG(23869,\n                1,\n                \"$unionWith attaching cursor to pipeline {pipeline}\",\n                \"pipeline\"_attr = serializedPipe);\n}",
        "output": "0",
        "idx": 174
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline static bool jas_safe_size_add(size_t x, size_t y, size_t *result)\n{\n\tif (y > SIZE_MAX - x) {\n\t\t*result = 0;\n\t\treturn false;\n\t}\n\t*result = x + y;\n\treturn true;\n}",
        "output": "1",
        "idx": 728
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API bool r_core_anal_bb_seek(RCore *core, ut64 addr) {\n\tut64 bbaddr = r_anal_get_bbaddr (core->anal, addr);\n\tif (bbaddr != UT64_MAX) {\n\t\tr_core_seek (core, bbaddr, false);\n\t\treturn true;\n\t}\n\treturn false;\n}",
        "output": "0",
        "idx": 3254
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "virDomainResume(virDomainPtr domain)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainResume) {\n        int ret;\n        ret = conn->driver->domainResume(domain);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}",
        "output": "0",
        "idx": 1545
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlRelaxNGValidateDoc(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc)\n{\n    int ret;\n\n    if ((ctxt == NULL) || (doc == NULL))\n        return (-1);\n\n    ctxt->doc = doc;\n\n    ret = xmlRelaxNGValidateDocument(ctxt, doc);\n    /*\n     * Remove all left PSVI\n     */\n    xmlRelaxNGCleanPSVI((xmlNodePtr) doc);\n\n    /*\n     * TODO: build error codes\n     */\n    if (ret == -1)\n        return (1);\n    return (ret);\n}",
        "output": "0",
        "idx": 84
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "wStream* cliprdr_packet_file_contents_response_new(const CLIPRDR_FILE_CONTENTS_RESPONSE* response)\n{\n\twStream* s;\n\n\tif (!response)\n\t\treturn NULL;\n\n\ts = cliprdr_packet_new(CB_FILECONTENTS_RESPONSE, response->msgFlags, 4 + response->cbRequested);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tcliprdr_write_file_contents_response(s, response);\n\treturn s;\n}",
        "output": "0",
        "idx": 234
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)\n{\n    debugs(85,3, HERE << \"handleAdaptationFailure(\" << bypassable << \")\");\n\n    const bool usedStore = storeEntry() && !storeEntry()->isEmpty();\n    const bool usedPipe = request->body_pipe != NULL &&\n                          request->body_pipe->consumedSize() > 0;\n\n    if (bypassable && !usedStore && !usedPipe) {\n        debugs(85,3, HERE << \"ICAP REQMOD callout failed, bypassing: \" << calloutContext);\n        if (calloutContext)\n            doCallouts();\n        return;\n    }\n\n    debugs(85,3, HERE << \"ICAP REQMOD callout failed, responding with error\");\n\n    clientStreamNode *node = (clientStreamNode *)client_stream.tail->prev->data;\n    clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());\n    assert(repContext);\n\n    calloutsError(ERR_ICAP_FAILURE, errDetail);\n\n    if (calloutContext)\n        doCallouts();\n}",
        "output": "0",
        "idx": 2315
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "/* }}} */\n\nstatic void pspell_config_path(INTERNAL_FUNCTION_PARAMETERS, char *option)\n{\n\tint type;\n\tlong conf;\n\tchar *value;\n\tint value_len;\n\tPspellConfig *config;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ls\", &conf, &value, &value_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tPSPELL_FETCH_CONFIG;\n\n\tif (PG(safe_mode) && (!php_checkuid(value, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (php_check_open_basedir(value TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tpspell_config_replace(config, option, value);\n",
        "output": "1",
        "idx": 368
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *ad_get_entry(const struct adouble *ad, int eid)\n{\n\toff_t off = ad_getentryoff(ad, eid);\n\tsize_t len = ad_getentrylen(ad, eid);\n\n\tif (off == 0 || len == 0) {\n\t\treturn NULL;\n\t}\n\n\treturn ad->ad_data + off;\n}",
        "output": "1",
        "idx": 3208
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TPMI_AES_KEY_BITS_Unmarshal(TPMI_AES_KEY_BITS *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = TPM_KEY_BITS_Unmarshal(target, buffer, size);  \n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tswitch (*target) {\n\t  case 128:\n\t  case 256:\n\t    break;\n\t  default:\n\t    rc = TPM_RC_VALUE;\n\t}\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 2370
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void* X509_get_ext_d2i(X509* x, int nid, int* crit, int* idx)\n{\n    // no extensions supported yet\n    return 0;\n}",
        "output": "0",
        "idx": 630
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kvm_start_pvclock_update(struct kvm *kvm)\n{\n\tkvm_make_mclock_inprogress_request(kvm);\n\n\t/* no guest entries from this point */\n\t__kvm_start_pvclock_update(kvm);\n}",
        "output": "0",
        "idx": 2449
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n{\tsf_count_t total = 0 ;\n\tssize_t\tcount ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;\n\n\titems *= bytes ;\n\n\t/* Do this check after the multiplication above. */\n\tif (items <= 0)\n\t\treturn 0 ;\n\n\twhile (items > 0)\n\t{\t/* Break the writes down to a sensible size. */\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;\n\n\t\tcount = write (psf->file.filedes, ((const char*) ptr) + total, count) ;\n\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (count == 0)\n\t\t\tbreak ;\n\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\n\treturn total / bytes ;\n} /* psf_fwrite */",
        "output": "1",
        "idx": 1453
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int restore_altivec(struct task_struct *tsk) { return 0; }",
        "output": "1",
        "idx": 498
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)\n{\n\tfile_transfer_t *ft = data;\n\tstruct prpl_xfer_data *px = ft->data;\n\n\tpx->timeout = 0;\n\n\tif (ft->write == NULL) {\n\t\tft->write = prpl_xfer_write;\n\t\timcb_file_recv_start(px->ic, ft);\n\t}\n\n\tft->write_request(ft);\n\n\treturn FALSE;\n}",
        "output": "0",
        "idx": 1379
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __msr_io(struct kvm_vcpu *vcpu, struct kvm_msrs *msrs,\n\t\t    struct kvm_msr_entry *entries,\n\t\t    int (*do_msr)(struct kvm_vcpu *vcpu,\n\t\t\t\t  unsigned index, u64 *data))\n{\n\tint i, idx;\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tfor (i = 0; i < msrs->nmsrs; ++i)\n\t\tif (do_msr(vcpu, entries[i].index, &entries[i].data))\n\t\t\tbreak;\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\n\treturn i;\n}",
        "output": "0",
        "idx": 2674
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NO_INLINE JsVar *jspeFactorDelete() {\n  JSP_ASSERT_MATCH(LEX_R_DELETE);\n  JsVar *parent = 0;\n  JsVar *a = jspeFactorMember(jspeFactor(), &parent);\n  JsVar *result = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    bool ok = false;\n    if (jsvIsName(a) && !jsvIsNewChild(a)) {\n      // if no parent, check in root?\n      if (!parent && jsvIsChild(execInfo.root, a))\n        parent = jsvLockAgain(execInfo.root);\n\n#ifdef DEBUG\n      if (jsvHasChildren(parent)) assert(jsvIsChild(parent, a));\n#endif\n      if (jsvHasChildren(parent) && jsvIsChild(parent, a)) {\n        // else remove properly.\n        /* we use jsvIsChild here just in case. delete probably isn't called\n        that often so it pays to be safe */\n        if (jsvIsArray(parent)) {\n          // For arrays, we must make sure we don't change the length\n          JsVarInt l = jsvGetArrayLength(parent);\n          jsvRemoveChild(parent, a);\n          jsvSetArrayLength(parent, l, false);\n        } else {\n          jsvRemoveChild(parent, a);\n        }\n        ok = true;\n      }\n    }\n\n    result = jsvNewFromBool(ok);\n  }\n  jsvUnLock2(a, parent);\n  return result;\n}",
        "output": "0",
        "idx": 3598
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ib_destroy_cm_id(struct ib_cm_id *cm_id)\n{\n\tcm_destroy_id(cm_id, 0);\n}",
        "output": "0",
        "idx": 2235
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mutt_decode_xbit (STATE *s, LOFF_T len, int istext, iconv_t cd)\n{\n  int c, ch;\n  char bufi[BUFI_SIZE];\n  size_t l = 0;\n\n  if (istext)\n  {\n    state_set_prefix(s);\n\n    while ((c = fgetc(s->fpin)) != EOF && len--)\n    {\n      if (c == '\\r' && len)\n      {\n\tif ((ch = fgetc(s->fpin)) == '\\n')\n\t{\n\t  c = ch;\n\t  len--;\n\t}\n\telse\n\t  ungetc(ch, s->fpin);\n      }\n\n      bufi[l++] = c;\n      if (l == sizeof (bufi))\n\tmutt_convert_to_state (cd, bufi, &l, s);\n    }\n\n    mutt_convert_to_state (cd, bufi, &l, s);\n    mutt_convert_to_state (cd, 0, 0, s);\n\n    state_reset_prefix (s);\n  }\n  else\n    mutt_copy_bytes (s->fpin, s->fpout, len);\n}",
        "output": "0",
        "idx": 3228
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ElectronBrowserHandlerImpl::Create(\n    content::RenderFrameHost* frame_host,\n    mojo::PendingReceiver<mojom::ElectronBrowser> receiver) {\n  new ElectronBrowserHandlerImpl(frame_host, std::move(receiver));\n}",
        "output": "1",
        "idx": 1495
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void stdp_del(GF_Box *s)\n{\n\tGF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;\n\tif (ptr == NULL ) return;\n\tif (ptr->priorities) gf_free(ptr->priorities);\n\tgf_free(ptr);\n}",
        "output": "0",
        "idx": 1012
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int remarkupvals (global_State *g) {\n  lua_State *thread;\n  lua_State **p = &g->twups;\n  int work = 0;\n  while ((thread = *p) != NULL) {\n    work++;\n    lua_assert(!isblack(thread));  /* threads are never black */\n    if (isgray(thread) && thread->openupval != NULL)\n      p = &thread->twups;  /* keep marked thread with upvalues in the list */\n    else {  /* thread is not marked or without upvalues */\n      UpVal *uv;\n      *p = thread->twups;  /* remove thread from the list */\n      thread->twups = thread;  /* mark that it is out of list */\n      for (uv = thread->openupval; uv != NULL; uv = uv->u.open.next) {\n        work++;\n        if (!iswhite(uv))  /* upvalue already visited? */\n          markvalue(g, uv->v);  /* mark its value */\n      }\n    }\n  }\n  return work;\n}",
        "output": "1",
        "idx": 198
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    MemInStream(const void* data, int len, bool deleteWhenDone_=false)\n      : start((const U8*)data), deleteWhenDone(deleteWhenDone_)\n    {\n      ptr = start;\n      end = start + len;\n    }",
        "output": "1",
        "idx": 1790
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ElectronBrowserHandlerImpl::UpdateDraggableRegions(\n    std::vector<mojom::DraggableRegionPtr> regions) {\n  api::WebContents* api_web_contents = api::WebContents::From(web_contents());\n  if (api_web_contents) {\n    api_web_contents->UpdateDraggableRegions(std::move(regions));\n  }\n}",
        "output": "1",
        "idx": 3352
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ssl3_take_mac(SSL *s)\n\t{\n\tconst char *sender;\n\tint slen;\n\n\tif (s->state & SSL_ST_CONNECT)\n\t\t{\n\t\tsender=s->method->ssl3_enc->server_finished_label;\n\t\tslen=s->method->ssl3_enc->server_finished_label_len;\n\t\t}\n\telse\n\t\t{\n\t\tsender=s->method->ssl3_enc->client_finished_label;\n\t\tslen=s->method->ssl3_enc->client_finished_label_len;\n\t\t}\n\n\ts->s3->tmp.peer_finish_md_len = s->method->ssl3_enc->final_finish_mac(s,\n\t\tsender,slen,s->s3->tmp.peer_finish_md);\n\t}",
        "output": "1",
        "idx": 53
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline u64 kvm_guest_supported_xfd(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_guest_supported_xcr0(vcpu) & XFEATURE_MASK_USER_DYNAMIC;\n}",
        "output": "0",
        "idx": 3008
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvm_create_dirty_bitmap(struct kvm_memory_slot *memslot)\n{\n\tunsigned long dirty_bytes = 2 * kvm_dirty_bitmap_bytes(memslot);\n\n\tmemslot->dirty_bitmap = kvm_kvzalloc(dirty_bytes);\n\tif (!memslot->dirty_bitmap)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 3620
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "table_regex_match(const char *string, const char *pattern)\n{\n\tregex_t preg;\n\tint\tcflags = REG_EXTENDED|REG_NOSUB;\n\n\tif (strncmp(pattern, \"(?i)\", 4) == 0) {\n\t\tcflags |= REG_ICASE;\n\t\tpattern += 4;\n\t}\n\n\tif (regcomp(&preg, pattern, cflags) != 0)\n\t\treturn (0);\n\n\tif (regexec(&preg, string, 0, NULL, 0) != 0)\n\t\treturn (0);\n\n\treturn (1);\n}",
        "output": "1",
        "idx": 41
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void exif_iif_add_tag(image_info_type *image_info, int section_index, char *name, int tag, int format, size_t length, void* value)\n{\n\texif_iif_add_value(image_info, section_index, name, tag, format, (int)length, value, image_info->motorola_intel);\n}",
        "output": "1",
        "idx": 2450
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void llc_cmsg_rcv(struct msghdr *msg, struct sk_buff *skb)\n{\n\tstruct llc_sock *llc = llc_sk(skb->sk);\n\n\tif (llc->cmsg_flags & LLC_CMSG_PKTINFO) {\n\t\tstruct llc_pktinfo info;\n\n\t\tinfo.lpi_ifindex = llc_sk(skb->sk)->dev->ifindex;\n\t\tllc_pdu_decode_dsap(skb, &info.lpi_sap);\n\t\tllc_pdu_decode_da(skb, info.lpi_mac);\n\t\tput_cmsg(msg, SOL_LLC, LLC_OPT_PKTINFO, sizeof(info), &info);\n\t}\n}",
        "output": "1",
        "idx": 1268
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\tstruct msghdr *msg, size_t len, int noblock, int flags,\n\t\tint *addr_len)\n{\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\tstruct sockaddr_ieee802154 *saddr;\n\n\tsaddr = (struct sockaddr_ieee802154 *)msg->msg_name;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\t/* FIXME: skip headers if necessary ?! */\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (saddr) {\n\t\tsaddr->family = AF_IEEE802154;\n\t\tsaddr->addr = mac_cb(skb)->sa;\n\t}\n\tif (addr_len)\n\t\t*addr_len = sizeof(*saddr);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (err)\n\t\treturn err;\n\treturn copied;\n}",
        "output": "1",
        "idx": 922
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int l2tp_eth_dev_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct l2tp_eth *priv = netdev_priv(dev);\n\tstruct l2tp_session *session = priv->session;\n\tunsigned int len = skb->len;\n\tint ret = l2tp_xmit_skb(session, skb, session->hdr_len);\n\n\tif (likely(ret == NET_XMIT_SUCCESS)) {\n\t\tatomic_long_add(len, &priv->tx_bytes);\n\t\tatomic_long_inc(&priv->tx_packets);\n\t} else {\n\t\tatomic_long_inc(&priv->tx_dropped);\n\t}\n\treturn NETDEV_TX_OK;\n}",
        "output": "0",
        "idx": 1157
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API RBinJavaCPTypeObj *r_bin_java_get_item_from_cp(RBinJavaObj *bin, int i) {\n\tif (i < 1 || i > bin->cf.cp_count) {\n\t\treturn &R_BIN_JAVA_NULL_TYPE;\n\t}\n\tRBinJavaCPTypeObj *obj = (RBinJavaCPTypeObj *) r_list_get_n (bin->cp_list, i);\n\treturn obj ? obj : &R_BIN_JAVA_NULL_TYPE;\n}",
        "output": "0",
        "idx": 1062
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ProcessHandle switch_to_sandbox(ProcessHandle parent) {\n\t// firejail forks many children, identify the sandbox child\n\t// using a pidfile created by the sandbox parent\n\tpid_t pid = read_sandbox_pidfile(process_get_pid(parent));\n\n\t// pin the sandbox child\n\tfmessage(\"Switching to pid %d, the first child process inside the sandbox\\n\", pid);\n\tProcessHandle sandbox = pin_child_process(parent, pid);\n\n\treturn sandbox;\n}",
        "output": "0",
        "idx": 1417
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CAMLprim value caml_alloc_dummy(value size)\n{\n  mlsize_t wosize = Int_val(size);\n\n  if (wosize == 0) return Atom(0);\n  return caml_alloc (wosize, 0);\n}",
        "output": "1",
        "idx": 3241
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rb_push_glob(VALUE str, int flags) /* '\\0' is delimiter */\n{\n    long offset = 0;\n    VALUE ary;\n\n    GlobPathValue(str, TRUE);\n    ary = rb_ary_new();\n\n    while (offset < RSTRING_LEN(str)) {\n\tchar *p, *pend;\n\tint status;\n\tp = RSTRING_PTR(str) + offset;\n\tstatus = push_glob(ary, rb_enc_str_new(p, strlen(p), rb_enc_get(str)),\n\t\t\t   flags);\n\tif (status) GLOB_JUMP_TAG(status);\n\tif (offset >= RSTRING_LEN(str)) break;\n\tp += strlen(p) + 1;\n\tpend = RSTRING_PTR(str) + RSTRING_LEN(str);\n\twhile (p < pend && !*p)\n\t    p++;\n\toffset = p - RSTRING_PTR(str);\n    }\n\n    return ary;\n}",
        "output": "1",
        "idx": 2904
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __return_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\ts64 slack_runtime = cfs_rq->runtime_remaining - min_cfs_rq_runtime;\n\n\tif (slack_runtime <= 0)\n\t\treturn;\n\n\traw_spin_lock(&cfs_b->lock);\n\tif (cfs_b->quota != RUNTIME_INF &&\n\t    cfs_rq->runtime_expires == cfs_b->runtime_expires) {\n\t\tcfs_b->runtime += slack_runtime;\n\n\t\t/* we are under rq->lock, defer unthrottling using a timer */\n\t\tif (cfs_b->runtime > sched_cfs_bandwidth_slice() &&\n\t\t    !list_empty(&cfs_b->throttled_cfs_rq))\n\t\t\tstart_cfs_slack_bandwidth(cfs_b);\n\t}\n\traw_spin_unlock(&cfs_b->lock);\n\n\t/* even if it's not valid for return we don't want to try again */\n\tcfs_rq->runtime_remaining -= slack_runtime;\n}",
        "output": "1",
        "idx": 2755
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vnc_tight_start(VncState *vs)\n{\n    buffer_reset(&vs->tight.tight);\n\n    // make the output buffer be the zlib buffer, so we can compress it later\n    vs->tight.tmp = vs->output;\n    vs->output = vs->tight.tight;\n}",
        "output": "1",
        "idx": 2922
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_char_length_tree(Node* node, regex_t* reg, int* len)\n{\n  return get_char_length_tree1(node, reg, len, 0);\n}",
        "output": "0",
        "idx": 913
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint8_t adts_frame(adts_header *adts, bitfile *ld)\n{\n    /* faad_byte_align(ld); */\n    if (adts_fixed_header(adts, ld))\n        return 5;\n    adts_variable_header(adts, ld);\n    adts_error_check(adts, ld);\n\n    return 0;\n}",
        "output": "0",
        "idx": 3069
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int credential_config_callback(const char *var, const char *value,\n\t\t\t\t      void *data)\n{\n\tstruct credential *c = data;\n\tconst char *key, *dot;\n\n\tif (!skip_prefix(var, \"credential.\", &key))\n\t\treturn 0;\n\n\tif (!value)\n\t\treturn config_error_nonbool(var);\n\n\tdot = strrchr(key, '.');\n\tif (dot) {\n\t\tstruct credential want = CREDENTIAL_INIT;\n\t\tchar *url = xmemdupz(key, dot - key);\n\t\tint matched;\n\n\t\tcredential_from_url(&want, url);\n\t\tmatched = credential_match(&want, c);\n\n\t\tcredential_clear(&want);\n\t\tfree(url);\n\n\t\tif (!matched)\n\t\t\treturn 0;\n\t\tkey = dot + 1;\n\t}\n\n\tif (!strcmp(key, \"helper\")) {\n\t\tif (*value)\n\t\t\tstring_list_append(&c->helpers, value);\n\t\telse\n\t\t\tstring_list_clear(&c->helpers, 0);\n\t} else if (!strcmp(key, \"username\")) {\n\t\tif (!c->username)\n\t\t\tc->username = xstrdup(value);\n\t}\n\telse if (!strcmp(key, \"usehttppath\"))\n\t\tc->use_http_path = git_config_bool(var, value);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 462
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_busid_idx(const char *busid)\n{\n\tint i;\n\tint idx = -1;\n\n\tfor (i = 0; i < MAX_BUSID; i++)\n\t\tif (busid_table[i].name[0])\n\t\t\tif (!strncmp(busid_table[i].name, busid, BUSID_SIZE)) {\n\t\t\t\tidx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\treturn idx;\n}",
        "output": "1",
        "idx": 802
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char* secondary_order_string(UINT32 orderType)\n{\n\tconst char* orders[] = { \"[0x%02\" PRIx8 \"] Cache Bitmap\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Color Table\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap (Compressed)\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Glyph\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V2\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V2 (Compressed)\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Brush\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V3\" };\n\tconst char* fmt = \"[0x%02\" PRIx8 \"] UNKNOWN\";\n\tstatic char buffer[64] = { 0 };\n\n\tif (orderType < ARRAYSIZE(orders))\n\t\tfmt = orders[orderType];\n\n\tsprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);\n\treturn buffer;\n}",
        "output": "0",
        "idx": 3564
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual ~Item()\n  {\n#ifdef EXTRA_DEBUG\n    name=0;\n#endif\n  }\t\t/*lint -e1509 */",
        "output": "0",
        "idx": 813
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void atomic2gen (lua_State *L, global_State *g) {\n  /* sweep all elements making them old */\n  sweep2old(L, &g->allgc);\n  /* everything alive now is old */\n  g->reallyold = g->old = g->survival = g->allgc;\n\n  /* repeat for 'finobj' lists */\n  sweep2old(L, &g->finobj);\n  g->finobjrold = g->finobjold = g->finobjsur = g->finobj;\n\n  sweep2old(L, &g->tobefnz);\n\n  g->gckind = KGC_GEN;\n  g->lastatomic = 0;\n  g->GCestimate = gettotalbytes(g);  /* base for memory control */\n  finishgencycle(L, g);\n}",
        "output": "1",
        "idx": 2359
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "systemd_unit_name_escape (const gchar *in)\n{\n  /* Adapted from systemd source */\n  GString * const str = g_string_sized_new (strlen (in));\n\n  for (; *in; in++)\n    {\n      if (g_ascii_isalnum (*in) || *in == ':' || *in == '_' || *in == '.')\n        g_string_append_c (str, *in);\n      else\n        g_string_append_printf (str, \"\\\\x%02x\", *in);\n    }\n  return g_string_free (str, FALSE);\n}",
        "output": "0",
        "idx": 2912
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int Http2Stream::ReadStart() {\n  Http2Scope h2scope(this);\n  CHECK(!this->is_destroyed());\n  set_reading();\n\n  Debug(this, \"reading starting\");\n\n  // Tell nghttp2 about our consumption of the data that was handed\n  // off to JS land.\n  nghttp2_session_consume_stream(\n      session_->session(),\n      id_,\n      inbound_consumed_data_while_paused_);\n  inbound_consumed_data_while_paused_ = 0;\n\n  return 0;\n}",
        "output": "0",
        "idx": 1387
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dtls1_process_buffered_records(SSL *s)\n{\n    pitem *item;\n\n    item = pqueue_peek(s->d1->unprocessed_rcds.q);\n    if (item) {\n        /* Check if epoch is current. */\n        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)\n            return (1);         /* Nothing to do. */\n\n        /* Process all the records. */\n        while (pqueue_peek(s->d1->unprocessed_rcds.q)) {\n            dtls1_get_unprocessed_record(s);\n            if (!dtls1_process_record(s))\n                return (0);\n            if (dtls1_buffer_record(s, &(s->d1->processed_rcds),\n                                    s->s3->rrec.seq_num) < 0)\n                return -1;\n        }\n    }\n\n    /*\n     * sync epoch numbers once all the unprocessed records have been\n     * processed\n     */\n    s->d1->processed_rcds.epoch = s->d1->r_epoch;\n    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;\n\n    return (1);\n}",
        "output": "1",
        "idx": 3389
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_prepare_syntax()\n{\n  MYSQL_STMT *stmt;\n  int        rc;\n  char query[MAX_TEST_QUERY_LENGTH];\n\n  myheader(\"test_prepare_syntax\");\n\n  rc= mysql_query(mysql, \"DROP TABLE IF EXISTS test_prepare_syntax\");\n  myquery(rc);\n\n  rc= mysql_query(mysql, \"CREATE TABLE test_prepare_syntax(\"\n                         \"id int, name varchar(50), extra int)\");\n  myquery(rc);\n\n  strmov(query, \"INSERT INTO test_prepare_syntax VALUES(?\");\n  stmt= mysql_simple_prepare(mysql, query);\n  check_stmt_r(stmt);\n\n  strmov(query, \"SELECT id, name FROM test_prepare_syntax WHERE id=? AND WHERE\");\n  stmt= mysql_simple_prepare(mysql, query);\n  check_stmt_r(stmt);\n\n  /* now fetch the results ..*/\n  rc= mysql_commit(mysql);\n  myquery(rc);\n}",
        "output": "0",
        "idx": 2544
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dse_delete_plugin(Slapi_Entry *entry, char *returntext)\n{\n    int rc = LDAP_SUCCESS;\n\n    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, \"nsSlapdPlugin\") ||\n        slapi_entry_attr_hasvalue(entry, \"nsslapd-PluginEnabled\", \"off\") ||\n        !config_get_dynamic_plugins()) {\n        /*\n         * This is not a plugin, this plugin was not enabled to begin with, or we\n         * are not allowing dynamic updates .\n         */\n        return rc;\n    }\n    rc = plugin_delete(entry, returntext, 0 /* not locked */);\n\n    return rc;\n}",
        "output": "0",
        "idx": 2220
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "addChar(char c, Lineprop mode)\n{\n    addMChar(&c, mode, 1);\n}",
        "output": "1",
        "idx": 3235
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(MultipleIterator, valid)\n{\n\tspl_SplObjectStorage        *intern;\n\tspl_SplObjectStorageElement *element;\n\tzval                        *it, *retval = NULL;\n\tlong                         expect, valid;\n\n\tintern = (spl_SplObjectStorage*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!zend_hash_num_elements(&intern->storage)) {\n\t\tRETURN_FALSE;\n\t}\n\n\texpect = (intern->flags & MIT_NEED_ALL) ? 1 : 0;\n\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\twhile (zend_hash_get_current_data_ex(&intern->storage, (void**)&element, &intern->pos) == SUCCESS && !EG(exception)) {\n\t\tit = element->obj;\n\t\tzend_call_method_with_0_params(&it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_valid, \"valid\", &retval);\n\n\t\tif (retval) {\n\t\t\tvalid = Z_LVAL_P(retval);\n\t\t\tzval_ptr_dtor(&retval);\n\t\t} else {\n\t\t\tvalid = 0;\n\t\t}\n\n\t\tif (expect != valid) {\n\t\t\tRETURN_BOOL(!expect);\n\t\t}\n\n\t\tzend_hash_move_forward_ex(&intern->storage, &intern->pos);\n\t}\n\n\tRETURN_BOOL(expect);\n}",
        "output": "1",
        "idx": 3381
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w){\n    long i;\n#if !HAVE_FAST_UNALIGNED\n    if((long)src2 & (sizeof(long)-1)){\n        for(i=0; i+7<w; i+=8){\n            dst[i+0] = src1[i+0]-src2[i+0];\n            dst[i+1] = src1[i+1]-src2[i+1];\n            dst[i+2] = src1[i+2]-src2[i+2];\n            dst[i+3] = src1[i+3]-src2[i+3];\n            dst[i+4] = src1[i+4]-src2[i+4];\n            dst[i+5] = src1[i+5]-src2[i+5];\n            dst[i+6] = src1[i+6]-src2[i+6];\n            dst[i+7] = src1[i+7]-src2[i+7];\n        }\n    }else\n#endif\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n        long a = *(long*)(src1+i);\n        long b = *(long*)(src2+i);\n        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] = src1[i+0]-src2[i+0];\n}",
        "output": "1",
        "idx": 2199
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int rtrs_clt_reconnect_from_sysfs(struct rtrs_clt_path *clt_path)\n{\n\tenum rtrs_clt_state old_state;\n\tint err = -EBUSY;\n\tbool changed;\n\n\tchanged = rtrs_clt_change_state_get_old(clt_path,\n\t\t\t\t\t\t RTRS_CLT_RECONNECTING,\n\t\t\t\t\t\t &old_state);\n\tif (changed) {\n\t\tclt_path->reconnect_attempts = 0;\n\t\tqueue_delayed_work(rtrs_wq, &clt_path->reconnect_dwork, 0);\n\t}\n\tif (changed || old_state == RTRS_CLT_RECONNECTING) {\n\t\t/*\n\t\t * flush_delayed_work() queues pending work for immediate\n\t\t * execution, so do the flush if we have queued something\n\t\t * right now or work is pending.\n\t\t */\n\t\tflush_delayed_work(&clt_path->reconnect_dwork);\n\t\terr = (READ_ONCE(clt_path->state) ==\n\t\t       RTRS_CLT_CONNECTED ? 0 : -ENOTCONN);\n\t}\n\n\treturn err;\n}",
        "output": "0",
        "idx": 854
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {\n#if defined(OS_WIN)\n  const auto converted = base::WideToUTF8(arg);\n  const char* a = converted.c_str();\n#else\n  const char* a = arg;\n#endif\n\n  static const char* prefixes[] = {\"--\", \"-\", \"/\"};\n\n  int prefix_length = 0;\n  for (auto& prefix : prefixes) {\n    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {\n      prefix_length = strlen(prefix);\n      break;\n    }\n  }\n\n  if (prefix_length > 0) {\n    a += prefix_length;\n    std::string switch_name(a, strcspn(a, \"=\"));\n    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),\n                                  switch_name);\n    if (iter != std::end(kBlacklist) && switch_name == *iter) {\n      return true;\n    }\n  }\n\n  return false;\n}",
        "output": "1",
        "idx": 2947
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(RecursiveDirectoryIterator, getSubPathname)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar *sub_name;\n\tint len;\n\tchar slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (intern->u.dir.sub_path) {\n\t\tlen = spprintf(&sub_name, 0, \"%s%c%s\", intern->u.dir.sub_path, slash, intern->u.dir.entry.d_name);\n\t\tRETURN_STRINGL(sub_name, len, 0);\n\t} else {\n\t\tRETURN_STRING(intern->u.dir.entry.d_name, 1);\n\t}\n}",
        "output": "1",
        "idx": 3475
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BOOL license_decrypt_and_check_MAC(rdpLicense* license, const BYTE* input, size_t len,\n                                          LICENSE_BLOB* target, const BYTE* packetMac)\n{\n\tBYTE macData[16];\n\n\treturn license_rc4_with_licenseKey(license, input, len, target) &&\n\t       security_mac_data(license->MacSaltKey, target->data, len, macData) &&\n\t       (memcmp(packetMac, macData, sizeof(macData)) == 0);\n}",
        "output": "0",
        "idx": 860
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ts_format(netdissect_options *ndo\n#ifndef HAVE_PCAP_SET_TSTAMP_PRECISION\n_U_\n#endif\n, int sec, int usec, char *buf)\n{\n\tconst char *format;\n\n#ifdef HAVE_PCAP_SET_TSTAMP_PRECISION\n\tswitch (ndo->ndo_tstamp_precision) {\n\n\tcase PCAP_TSTAMP_PRECISION_MICRO:\n\t\tformat = \"%02d:%02d:%02d.%06u\";\n\t\tbreak;\n\n\tcase PCAP_TSTAMP_PRECISION_NANO:\n\t\tformat = \"%02d:%02d:%02d.%09u\";\n\t\tbreak;\n\n\tdefault:\n\t\tformat = \"%02d:%02d:%02d.{unknown}\";\n\t\tbreak;\n\t}\n#else\n\tformat = \"%02d:%02d:%02d.%06u\";\n#endif\n\n\tsnprintf(buf, TS_BUF_SIZE, format,\n                 sec / 3600, (sec % 3600) / 60, sec % 60, usec);\n\n        return buf;\n}",
        "output": "0",
        "idx": 3396
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API int r_socket_ready(RSocket *s, int secs, int usecs) {\n\treturn -1;\n}",
        "output": "1",
        "idx": 25
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  RGWOpType get_type() override { return RGW_OP_PUT_ACLS; }",
        "output": "0",
        "idx": 632
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "proc_file_lseek(struct file *file, loff_t offset, int orig)\n{\n    lock_kernel();\n\n    switch (orig) {\n    case 0:\n\tif (offset < 0)\n\t    goto out;\n\tfile->f_pos = offset;\n\tunlock_kernel();\n\treturn(file->f_pos);\n    case 1:\n\tif (offset + file->f_pos < 0)\n\t    goto out;\n\tfile->f_pos += offset;\n\tunlock_kernel();\n\treturn(file->f_pos);\n    case 2:\n\tgoto out;\n    default:\n\tgoto out;\n    }\n\nout:\n    unlock_kernel();\n    return -EINVAL;\n}",
        "output": "1",
        "idx": 864
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct sock *sk_alloc(struct net *net, int family, gfp_t priority,\n\t\t      struct proto *prot, int kern)\n{\n\tstruct sock *sk;\n\n\tsk = sk_prot_alloc(prot, priority | __GFP_ZERO, family);\n\tif (sk) {\n\t\tsk->sk_family = family;\n\t\t/*\n\t\t * See comment in struct sock definition to understand\n\t\t * why we need sk_prot_creator -acme\n\t\t */\n\t\tsk->sk_prot = sk->sk_prot_creator = prot;\n\t\tsk->sk_kern_sock = kern;\n\t\tsock_lock_init(sk);\n\t\tsk->sk_net_refcnt = kern ? 0 : 1;\n\t\tif (likely(sk->sk_net_refcnt))\n\t\t\tget_net(net);\n\t\tsock_net_set(sk, net);\n\t\trefcount_set(&sk->sk_wmem_alloc, 1);\n\n\t\tmem_cgroup_sk_alloc(sk);\n\t\tcgroup_sk_alloc(&sk->sk_cgrp_data);\n\t\tsock_update_classid(&sk->sk_cgrp_data);\n\t\tsock_update_netprioidx(&sk->sk_cgrp_data);\n\t}\n\n\treturn sk;\n}",
        "output": "0",
        "idx": 823
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Virtual_column_info::fix_session_expr_for_read(THD *thd, Field *field)\n{\n  DBUG_ENTER(\"fix_session_vcol_expr_for_read\");\n  TABLE_LIST *tl= field->table->pos_in_table_list;\n  if (!tl || tl->lock_type >= TL_WRITE_ALLOW_WRITE)\n    DBUG_RETURN(0);\n  Security_context *save_security_ctx= thd->security_ctx;\n  if (tl->security_ctx)\n    thd->security_ctx= tl->security_ctx;\n  bool res= fix_session_expr(thd);\n  thd->security_ctx= save_security_ctx;\n  DBUG_RETURN(res);\n}",
        "output": "1",
        "idx": 3610
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline ut64 dwarf_read_address(size_t size, bool big_endian, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tswitch (size) {\n\tcase 2:\n\t\tresult = READ16(*buf);\n\t\tbreak;\n\tcase 4:\n\t\tresult = READ32(*buf);\n\t\tbreak;\n\tcase 8:\n\t\tresult = READ64(*buf);\n\t\tbreak;\n\tdefault:\n\t\tresult = 0;\n\t\t*buf += size;\n\t\teprintf(\"Weird dwarf address size: %zu.\", size);\n\t}\n\treturn result;\n}",
        "output": "0",
        "idx": 1809
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "listener_ref_entry_remove_for_connection (GSListener  *listener,\n                                          int          entry_type,\n                                          const char  *connection)\n{\n        gboolean    removed;\n        guint       n_removed;\n        GHashTable *hash;\n\n        hash = get_hash_for_entry_type (listener, entry_type);\n\n        removed = FALSE;\n        n_removed = g_hash_table_foreach_remove (hash, listener_ref_entry_has_connection, (gpointer)connection);\n\n        removed = (n_removed > 0);\n\n        return removed;\n}",
        "output": "1",
        "idx": 269
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GError *add(char *label, char *server, char *username, char *secret) {\n\tGError *err = NULL;\n\n\tsecret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,\n\t\t\tserver, secret, NULL, &err,\n\t\t\t\"label\", label,\n\t\t\t\"server\", server,\n\t\t\t\"username\", username,\n\t\t\t\"docker_cli\", \"1\",\n\t\t\tNULL);\n\treturn err;\n}",
        "output": "0",
        "idx": 766
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool set_off_slab_cache(struct kmem_cache *cachep,\n\t\t\tsize_t size, unsigned long flags)\n{\n\tsize_t left;\n\n\tcachep->num = 0;\n\n\t/*\n\t * Always use on-slab management when SLAB_NOLEAKTRACE\n\t * to avoid recursive calls into kmemleak.\n\t */\n\tif (flags & SLAB_NOLEAKTRACE)\n\t\treturn false;\n\n\t/*\n\t * Size is large, assume best to place the slab management obj\n\t * off-slab (should allow better packing of objs).\n\t */\n\tleft = calculate_slab_order(cachep, size, flags | CFLGS_OFF_SLAB);\n\tif (!cachep->num)\n\t\treturn false;\n\n\t/*\n\t * If the slab has been placed off-slab, and we have enough space then\n\t * move it on-slab. This is at the expense of any extra colouring.\n\t */\n\tif (left >= cachep->num * sizeof(freelist_idx_t))\n\t\treturn false;\n\n\tcachep->colour = left / cachep->colour_off;\n\n\treturn true;\n}",
        "output": "0",
        "idx": 351
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "njs_vmcode_template_literal(njs_vm_t *vm, njs_value_t *invld1,\n    njs_value_t *retval)\n{\n    njs_array_t     *array;\n    njs_value_t     *value;\n    njs_jump_off_t  ret;\n\n    static const njs_function_t  concat = {\n          .native = 1,\n          .args_offset = 1,\n          .u.native = njs_string_prototype_concat\n    };\n\n    value = njs_scope_valid_value(vm, (njs_index_t) retval);\n\n    if (!njs_is_primitive(value)) {\n        array = njs_array(value);\n\n        ret = njs_function_frame(vm, (njs_function_t *) &concat,\n                                 &njs_string_empty, array->start,\n                                 array->length, 0);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n\n        ret = njs_function_frame_invoke(vm, value);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n\n    return sizeof(njs_vmcode_template_literal_t);\n}",
        "output": "0",
        "idx": 1776
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "control_notify_input(struct client *c, struct window_pane *wp,\n    struct evbuffer *input)\n{\n\tu_char\t\t*buf;\n\tsize_t\t\t len;\n\tstruct evbuffer *message;\n\tu_int\t\t i;\n\n\tif (c->session == NULL)\n\t    return;\n\n\tbuf = EVBUFFER_DATA(input);\n\tlen = EVBUFFER_LENGTH(input);\n\n\t/*\n\t * Only write input if the window pane is linked to a window belonging\n\t * to the client's session.\n\t */\n\tif (winlink_find_by_window(&c->session->windows, wp->window) != NULL) {\n\t\tmessage = evbuffer_new();\n\t\tevbuffer_add_printf(message, \"%%output %%%u \", wp->id);\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (buf[i] < ' ' || buf[i] == '\\\\')\n\t\t\t    evbuffer_add_printf(message, \"\\\\%03o\", buf[i]);\n\t\t\telse\n\t\t\t    evbuffer_add_printf(message, \"%c\", buf[i]);\n\t\t}\n\t\tcontrol_write_buffer(c, message);\n\t\tevbuffer_free(message);\n\t}\n}",
        "output": "1",
        "idx": 742
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void do_system(struct st_command *command)\n{\n  DYNAMIC_STRING ds_cmd;\n  DBUG_ENTER(\"do_system\");\n\n  if (strlen(command->first_argument) == 0)\n  {\n    report_or_die(\"Missing arguments to system, nothing to do!\");\n    return;\n  }\n\n  init_dynamic_string(&ds_cmd, 0, command->query_len + 64, 256);\n\n  /* Eval the system command, thus replacing all environment variables */\n  do_eval(&ds_cmd, command->first_argument, command->end, !is_windows);\n\n#ifdef __WIN__\n#ifndef USE_CYGWIN\n   /* Replace /dev/null with NUL */\n   while(replace(&ds_cmd, \"/dev/null\", 9, \"NUL\", 3) == 0)\n     ;\n#endif\n#endif\n\n\n  DBUG_PRINT(\"info\", (\"running system command '%s' as '%s'\",\n                      command->first_argument, ds_cmd.str));\n  if (my_system(&ds_cmd))\n  {\n    if (command->abort_on_error)\n      report_or_die(\"system command '%s' failed\", command->first_argument);\n    else\n    {\n      /* If ! abort_on_error, log message and continue */\n      dynstr_append(&ds_res, \"system command '\");\n      replace_dynstr_append(&ds_res, command->first_argument);\n      dynstr_append(&ds_res, \"' failed\\n\");\n    }\n  }\n\n  command->last_argument= command->end;\n  dynstr_free(&ds_cmd);\n  DBUG_VOID_RETURN;\n}",
        "output": "0",
        "idx": 2532
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "g_socket_client_tls_handshake_callback (GObject      *object,\n\t\t\t\t\tGAsyncResult *result,\n\t\t\t\t\tgpointer      user_data)\n{\n  GSocketClientAsyncConnectData *data = user_data;\n\n  if (g_tls_connection_handshake_finish (G_TLS_CONNECTION (object),\n\t\t\t\t\t result,\n\t\t\t\t\t &data->last_error))\n    {\n      g_object_unref (data->connection);\n      data->connection = G_IO_STREAM (object);\n\n      g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_TLS_HANDSHAKED, data->connectable, data->connection);\n      g_socket_client_async_connect_complete (data);\n    }\n  else\n    {\n      g_object_unref (object);\n      enumerator_next_async (data);\n    }\n}",
        "output": "1",
        "idx": 1697
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TPMA_SESSION_Unmarshal(TPMA_SESSION *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = UINT8_Unmarshal((UINT8 *)target, buffer, size);  /* libtpms changed */\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tif (*target & TPMA_SESSION_reserved) {\n\t    rc = TPM_RC_RESERVED_BITS;\n\t}\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 2696
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TopologyManager::onServerRTTUpdated(HostAndPort hostAndPort, IsMasterRTT rtt) {\n    {\n        stdx::lock_guard<mongo::Mutex> lock(_mutex);\n\n        auto oldServerDescription = _topologyDescription->findServerByAddress(hostAndPort);\n        if (oldServerDescription) {\n            auto newServerDescription = (*oldServerDescription)->cloneWithRTT(rtt);\n\n            auto oldTopologyDescription = _topologyDescription;\n            _topologyDescription = std::make_shared<TopologyDescription>(*_topologyDescription);\n            _topologyDescription->installServerDescription(newServerDescription);\n\n            _publishTopologyDescriptionChanged(oldTopologyDescription, _topologyDescription);\n\n            return;\n        }\n    }\n    // otherwise, the server was removed from the topology. Nothing to do.\n    LOGV2(4333201,\n          \"Not updating RTT. Server {server} does not exist in {replicaSet}\",\n          \"Not updating RTT. The server does not exist in the replica set\",\n          \"server\"_attr = hostAndPort,\n          \"replicaSet\"_attr = getTopologyDescription()->getSetName());\n}",
        "output": "1",
        "idx": 1950
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "longlong Item_func_uuid_short::val_int()\n{\n  ulonglong val;\n  mysql_mutex_lock(&LOCK_short_uuid_generator);\n  val= uuid_value++;\n  mysql_mutex_unlock(&LOCK_short_uuid_generator);\n  return (longlong) val;\n}",
        "output": "0",
        "idx": 2710
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplDoublyLinkedList, prev)\n{\n\tspl_dllist_object *intern = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_dllist_it_helper_move_forward(&intern->traverse_pointer, &intern->traverse_position, intern->llist, intern->flags ^ SPL_DLLIST_IT_LIFO TSRMLS_CC);\n}",
        "output": "1",
        "idx": 271
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpContext op_context(context, node);\n\n    switch (op_context.output->type) {\n      case kTfLiteFloat32:\n        TFLiteOperation<kernel_type, float, OpType>(context, node, op_context);\n        break;\n      case kTfLiteUInt8:\n        TFLiteOperation<kernel_type, uint8_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt8:\n        TFLiteOperation<kernel_type, int8_t, OpType>(context, node, op_context);\n        break;\n      case kTfLiteInt32:\n        TFLiteOperation<kernel_type, int32_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt64:\n        TFLiteOperation<kernel_type, int64_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt16:\n        TFLiteOperation<kernel_type, int16_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      default:\n        context->ReportError(context,\n                             \"Type %d is currently not supported by Maximum.\",\n                             op_context.output->type);\n        return kTfLiteError;\n    }\n  return kTfLiteOk;\n}",
        "output": "1",
        "idx": 2835
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void asyncCloseClientOnOutputBufferLimitReached(client *c) {\n    if (!c->conn) return; /* It is unsafe to free fake clients. */\n    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));\n    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;\n    if (checkClientOutputBufferLimits(c)) {\n        sds client = catClientInfoString(sdsempty(),c);\n\n        freeClientAsync(c);\n        serverLog(LL_WARNING,\"Client %s scheduled to be closed ASAP for overcoming of output buffer limits.\", client);\n        sdsfree(client);\n    }\n}",
        "output": "0",
        "idx": 1743
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\tswitch (yych) {\n\t\tcase 'a': goto yy18;\n\t\tdefault: goto yy17;\n\t}",
        "output": "1",
        "idx": 2295
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "runMainLoop(WorkingObjects &wo) {\n\tev::io feedbackFdWatcher(eventLoop);\n\tev::sig sigintWatcher(eventLoop);\n\tev::sig sigtermWatcher(eventLoop);\n\tev::sig sigquitWatcher(eventLoop);\n\t\n\tif (feedbackFdAvailable()) {\n\t\tfeedbackFdWatcher.set<&feedbackFdBecameReadable>();\n\t\tfeedbackFdWatcher.start(FEEDBACK_FD, ev::READ);\n\t\twriteArrayMessage(FEEDBACK_FD, \"initialized\", NULL);\n\t}\n\tsigintWatcher.set<&caughtExitSignal>();\n\tsigintWatcher.start(SIGINT);\n\tsigtermWatcher.set<&caughtExitSignal>();\n\tsigtermWatcher.start(SIGTERM);\n\tsigquitWatcher.set<&printInfo>();\n\tsigquitWatcher.start(SIGQUIT);\n\t\n\tP_WARN(\"PassengerLoggingAgent online, listening at \" << socketAddress);\n\tev_run(eventLoop, 0);\n}",
        "output": "1",
        "idx": 1343
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "virDomainNetNotifyActualDevice(virConnectPtr conn,\n                               virDomainDefPtr dom,\n                               virDomainNetDefPtr iface)\n{\n    virDomainNetType actualType = virDomainNetGetActualType(iface);\n\n    if (virDomainNetCreatePort(conn, dom, iface,\n                               VIR_NETWORK_PORT_CREATE_RECLAIM) < 0) {\n        return;\n    }\n\n    if (actualType == VIR_DOMAIN_NET_TYPE_NETWORK ||\n        actualType == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n        /*\n         * NB: we can't notify the guest of any MTU change anyway,\n         * so there is no point in trying to learn the actualMTU\n         * (final arg to virNetDevTapReattachBridge())\n         */\n        ignore_value(virNetDevTapReattachBridge(iface->ifname,\n                                                iface->data.network.actual->data.bridge.brname,\n                                                &iface->mac, dom->uuid,\n                                                virDomainNetGetActualVirtPortProfile(iface),\n                                                virDomainNetGetActualVlan(iface),\n                                                virDomainNetGetActualPortOptionsIsolated(iface),\n                                                iface->mtu, NULL));\n    }\n}",
        "output": "0",
        "idx": 758
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  Subgraph* subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputVariableId);\n  int resource_id = input_resource_id_tensor->data.i32[0];\n  auto& resources = subgraph->resources();\n  auto* variable = resource::GetResourceVariable(&resources, resource_id);\n  TF_LITE_ENSURE(context, variable != nullptr);\n\n  TfLiteTensor* variable_tensor = variable->GetTensor();\n  TfLiteTensor* output = GetOutput(context, node, kOutputValue);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, variable_tensor->type, output->type);\n  TF_LITE_ENSURE_OK(\n      context, context->ResizeTensor(\n                   context, output, TfLiteIntArrayCopy(variable_tensor->dims)));\n  memcpy(output->data.raw, variable_tensor->data.raw, output->bytes);\n\n  return kTfLiteOk;\n}",
        "output": "1",
        "idx": 1130
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,\n                                     uint32_t lun, void *hba_private)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n\n    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);\n    r = DO_UPCAST(SCSIDiskReq, req, req);\n    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);\n    return req;\n}",
        "output": "1",
        "idx": 2795
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "snprint_hinted_integer(char *buf, size_t buf_len,\n                       long val, const char *hint, const char *units)\n{\n    size_t          out_len = 0;\n    if (sprint_realloc_hinted_integer\n        ((u_char **) & buf, &buf_len, &out_len, 0, val, 'd', hint, units))\n        return (int) out_len;\n    else\n        return -1;\n}",
        "output": "0",
        "idx": 3715
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ipv6_mc_unmap(struct inet6_dev *idev)\n{\n\tstruct ifmcaddr6 *i;\n\n\t/* Install multicast list, except for all-nodes (already installed) */\n\n\tmutex_lock(&idev->mc_lock);\n\tfor_each_mc_mclock(idev, i)\n\t\tigmp6_group_dropped(i);\n\tmutex_unlock(&idev->mc_lock);\n}",
        "output": "0",
        "idx": 2562
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)\n{\n\tsapi_header_line ctr = {0};\n\tint r;\n\t\n\tctr.line = header_line;\n\tctr.line_len = header_line_len;\n\n\tr = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,\n\t\t\t&ctr TSRMLS_CC);\n\n\tif (!duplicate)\n\t\tefree(header_line);\n\n\treturn r;\n}",
        "output": "1",
        "idx": 2078
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void iov_iter_advance(struct iov_iter *i, size_t bytes)\n{\n\tBUG_ON(i->count < bytes);\n\n\tif (likely(i->nr_segs == 1)) {\n\t\ti->iov_offset += bytes;\n\t\ti->count -= bytes;\n\t} else {\n\t\tconst struct iovec *iov = i->iov;\n\t\tsize_t base = i->iov_offset;\n\n\t\t/*\n\t\t * The !iov->iov_len check ensures we skip over unlikely\n\t\t * zero-length segments (without overruning the iovec).\n\t\t */\n\t\twhile (bytes || unlikely(!iov->iov_len && i->count)) {\n\t\t\tint copy;\n\n\t\t\tcopy = min(bytes, iov->iov_len - base);\n\t\t\tBUG_ON(!i->count || i->count < copy);\n\t\t\ti->count -= copy;\n\t\t\tbytes -= copy;\n\t\t\tbase += copy;\n\t\t\tif (iov->iov_len == base) {\n\t\t\t\tiov++;\n\t\t\t\tbase = 0;\n\t\t\t}\n\t\t}\n\t\ti->iov = iov;\n\t\ti->iov_offset = base;\n\t}\n}",
        "output": "1",
        "idx": 2669
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "virDomainCoreDump(virDomainPtr domain, const char *to, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"to=%s, flags=%x\", to, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(to, error);\n\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_CRASH, VIR_DUMP_LIVE, error);\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_CRASH, VIR_DUMP_RESET, error);\n    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_LIVE, VIR_DUMP_RESET, error);\n\n    if (conn->driver->domainCoreDump) {\n        int ret;\n        char *absolute_to;\n\n        /* We must absolutize the file path as the save is done out of process */\n        if (virFileAbsPath(to, &absolute_to) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not build absolute core file path\"));\n            goto error;\n        }\n\n        ret = conn->driver->domainCoreDump(domain, absolute_to, flags);\n\n        VIR_FREE(absolute_to);\n\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}",
        "output": "0",
        "idx": 910
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cmp_addr_policies(smartlist_t *a, smartlist_t *b)\n{\n  int r, i;\n  int len_a = a ? smartlist_len(a) : 0;\n  int len_b = b ? smartlist_len(b) : 0;\n\n  for (i = 0; i < len_a && i < len_b; ++i) {\n    if ((r = cmp_single_addr_policy(smartlist_get(a, i), smartlist_get(b, i))))\n      return r;\n  }\n  if (i == len_a && i == len_b)\n    return 0;\n  if (i < len_a)\n    return -1;\n  else\n    return 1;\n}",
        "output": "1",
        "idx": 918
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parse_CT_CLEAR(char *arg OVS_UNUSED, struct ofpbuf *ofpacts,\n               enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    ofpact_put_CT_CLEAR(ofpacts);\n    return NULL;\n}",
        "output": "0",
        "idx": 1249
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned int selinux_ipv4_output(unsigned int hooknum,\n\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\tconst struct net_device *in,\n\t\t\t\t\tconst struct net_device *out,\n\t\t\t\t\tint (*okfn)(struct sk_buff *))\n{\n\treturn selinux_ip_output(skb, PF_INET);\n}",
        "output": "0",
        "idx": 2362
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "njs_promise_resolve(njs_vm_t *vm, njs_value_t *constructor, njs_value_t *x)\n{\n    njs_int_t                 ret;\n    njs_value_t               value;\n    njs_object_t              *object;\n    njs_promise_capability_t  *capability;\n\n    static const njs_value_t  string_constructor = njs_string(\"constructor\");\n\n    if (njs_is_object(x)) {\n        object = njs_object_proto_lookup(njs_object(x), NJS_PROMISE,\n                                         njs_object_t);\n\n        if (object != NULL) {\n            ret = njs_value_property(vm, x, njs_value_arg(&string_constructor),\n                                     &value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NULL;\n            }\n\n            if (njs_values_same(&value, constructor)) {\n                return njs_promise(x);\n            }\n        }\n    }\n\n    capability = njs_promise_new_capability(vm, constructor);\n    if (njs_slow_path(capability == NULL)) {\n        return NULL;\n    }\n\n    ret = njs_function_call(vm, njs_function(&capability->resolve),\n                            &njs_value_undefined, x, 1, &value);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return NULL;\n    }\n\n    return njs_promise(&capability->promise);\n}",
        "output": "1",
        "idx": 1982
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    static void auditCreateOrUpdateUser(const BSONObj& userObj, bool create) {\n        UserName userName = extractUserNameFromBSON(userObj);\n        std::vector<RoleName> roles;\n        uassertStatusOK(auth::parseRoleNamesFromBSONArray(\n            BSONArray(userObj[\"roles\"].Obj()), userName.getDB(), &roles));\n        BSONObj customData;\n        if (userObj.hasField(\"customData\")) {\n            customData = userObj[\"customData\"].Obj();\n        }\n\n        if (create) {\n            audit::logCreateUser(Client::getCurrent(),\n                                 userName,\n                                 userObj[\"credentials\"].Obj().hasField(\"MONGODB-CR\"),\n                                 userObj.hasField(\"customData\") ? &customData : NULL,\n                                 roles);\n        } else {\n            audit::logUpdateUser(Client::getCurrent(),\n                                 userName,\n                                 userObj[\"credentials\"].Obj().hasField(\"MONGODB-CR\"),\n                                 userObj.hasField(\"customData\") ? &customData : NULL,\n                                 &roles);\n        }\n    }",
        "output": "0",
        "idx": 3602
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int init_dumping(char *database, int init_func(char*))\n{\n  if (mysql_select_db(mysql, database))\n  {\n    DB_error(mysql, \"when selecting the database\");\n    return 1;                   /* If --force */\n  }\n  if (!path && !opt_xml)\n  {\n    if (opt_databases || opt_alldbs)\n    {\n      /*\n        length of table name * 2 (if name contains quotes), 2 quotes and 0\n      */\n      char quoted_database_buf[NAME_LEN*2+3];\n      char *qdatabase= quote_name(database,quoted_database_buf,opt_quoted);\n\n      print_comment(md_result_file, 0,\n                    \"\\n--\\n-- Current Database: %s\\n--\\n\", qdatabase);\n\n      /* Call the view or table specific function */\n      init_func(qdatabase);\n\n      fprintf(md_result_file,\"\\nUSE %s;\\n\", qdatabase);\n      check_io(md_result_file);\n    }\n  }\n  return 0;\n} /* init_dumping */",
        "output": "1",
        "idx": 20
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,\n\t\t\t\t\t\tint id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);\n\n\tif (IS_ERR(ipcp))\n\t\treturn ERR_CAST(ipcp);\n\n\treturn container_of(ipcp, struct sem_array, sem_perm);\n}",
        "output": "1",
        "idx": 6
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n\t\t\t   int fromlen, unsigned char *to)\n{\n\tstruct pathComponent *pc;\n\tint elen = 0;\n\tunsigned char *p = to;\n\n\twhile (elen < fromlen) {\n\t\tpc = (struct pathComponent *)(from + elen);\n\t\tswitch (pc->componentType) {\n\t\tcase 1:\n\t\t\t/*\n\t\t\t * Symlink points to some place which should be agreed\n \t\t\t * upon between originator and receiver of the media. Ignore.\n\t\t\t */\n\t\t\tif (pc->lengthComponentIdent > 0)\n\t\t\t\tbreak;\n\t\t\t/* Fall through */\n\t\tcase 2:\n\t\t\tp = to;\n\t\t\t*p++ = '/';\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmemcpy(p, \"../\", 3);\n\t\t\tp += 3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmemcpy(p, \"./\", 2);\n\t\t\tp += 2;\n\t\t\t/* that would be . - just ignore */\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tp += udf_get_filename(sb, pc->componentIdent, p,\n\t\t\t\t\t      pc->lengthComponentIdent);\n\t\t\t*p++ = '/';\n\t\t\tbreak;\n\t\t}\n\t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n\t}\n\tif (p > to + 1)\n\t\tp[-1] = '\\0';\n\telse\n\t\tp[0] = '\\0';\n}",
        "output": "1",
        "idx": 3665
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *cmd)\n{\n\tstruct megasas_instance *local_instance;\n\tint i, error = 0;\n\tint crash_support;\n\n\tcrash_support = cmd->frame->dcmd.mbox.w[0];\n\n\tfor (i = 0; i < megasas_mgmt_info.max_index; i++) {\n\t\tlocal_instance = megasas_mgmt_info.instance[i];\n\t\tif (local_instance && local_instance->crash_dump_drv_support) {\n\t\t\tif ((atomic_read(&local_instance->adprecovery) ==\n\t\t\t\tMEGASAS_HBA_OPERATIONAL) &&\n\t\t\t\t!megasas_set_crash_dump_params(local_instance,\n\t\t\t\t\tcrash_support)) {\n\t\t\t\tlocal_instance->crash_dump_app_support =\n\t\t\t\t\tcrash_support;\n\t\t\t\tdev_info(&local_instance->pdev->dev,\n\t\t\t\t\t\"Application firmware crash \"\n\t\t\t\t\t\"dump mode set success\\n\");\n\t\t\t\terror = 0;\n\t\t\t} else {\n\t\t\t\tdev_info(&local_instance->pdev->dev,\n\t\t\t\t\t\"Application firmware crash \"\n\t\t\t\t\t\"dump mode set failed\\n\");\n\t\t\t\terror = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn error;\n}",
        "output": "0",
        "idx": 3350
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned char *cipso_v4_optptr(const struct sk_buff *skb)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tunsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);\n\tint optlen;\n\tint taglen;\n\n\tfor (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {\n\t\tif (optptr[0] == IPOPT_CIPSO)\n\t\t\treturn optptr;\n\t\ttaglen = optptr[1];\n\t\toptlen -= taglen;\n\t\toptptr += taglen;\n\t}\n\n\treturn NULL;\n}",
        "output": "1",
        "idx": 1126
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "XSetStandardProperties (\n    \tDisplay *dpy,\n    \tWindow w,\t\t/* window to decorate */\n    \t_Xconst char *name,\t/* name of application */\n    \t_Xconst char *icon_string,/* name string for icon */\n\tPixmap icon_pixmap,\t/* pixmap to use as icon, or None */\n    \tchar **argv,\t\t/* command to be used to restart application */\n    \tint argc,\t\t/* count of arguments */\n    \tXSizeHints *hints)\t/* size hints for window in its normal state */\n{\n\tXWMHints phints;\n\tphints.flags = 0;\n\n\tif (name != NULL) XStoreName (dpy, w, name);\n\n\tif (icon_string != NULL) {\n\t    XChangeProperty (dpy, w, XA_WM_ICON_NAME, XA_STRING, 8,\n                             PropModeReplace,\n                             (_Xconst unsigned char *)icon_string,\n                             (int)safestrlen(icon_string));\n\t\t}\n\n\tif (icon_pixmap != None) {\n\t\tphints.icon_pixmap = icon_pixmap;\n\t\tphints.flags |= IconPixmapHint;\n\t\t}\n\tif (argv != NULL) XSetCommand(dpy, w, argv, argc);\n\n\tif (hints != NULL) XSetNormalHints(dpy, w, hints);\n\n\tif (phints.flags != 0) XSetWMHints(dpy, w, &phints);\n\n\treturn 1;\n}",
        "output": "1",
        "idx": 1791
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_seq_device_dev_free(struct snd_device *device)\n{\n\tstruct snd_seq_device *dev = device->device_data;\n\n\tput_device(&dev->dev);\n\treturn 0;\n}",
        "output": "1",
        "idx": 211
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "le64addr_string(netdissect_options *ndo, const u_char *ep)\n{\n\tconst unsigned int len = 8;\n\tregister u_int i;\n\tregister char *cp;\n\tregister struct enamemem *tp;\n\tchar buf[BUFSIZE];\n\n\ttp = lookup_bytestring(ndo, ep, len);\n\tif (tp->e_name)\n\t\treturn (tp->e_name);\n\n\tcp = buf;\n\tfor (i = len; i > 0 ; --i) {\n\t\t*cp++ = hex[*(ep + i - 1) >> 4];\n\t\t*cp++ = hex[*(ep + i - 1) & 0xf];\n\t\t*cp++ = ':';\n\t}\n\tcp --;\n\n\t*cp = '\\0';\n\n\ttp->e_name = strdup(buf);\n\tif (tp->e_name == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"le64addr_string: strdup(buf)\");\n\n\treturn (tp->e_name);\n}",
        "output": "1",
        "idx": 283
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  const string name() override { return \"options_cors\"; }",
        "output": "0",
        "idx": 3493
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mark_all_jobs_as_dead ()\n{\n  register int i;\n  sigset_t set, oset;\n\n  if (js.j_jobslots == 0)\n    return;\n\n  BLOCK_CHILD (set, oset);\n\n  /* XXX could use js.j_firstj here */\n  for (i = 0; i < js.j_jobslots; i++)\n    if (jobs[i])\n      {\n\tjobs[i]->state = JDEAD;\n\tjs.j_ndead++;\n      }\n\n  UNBLOCK_CHILD (oset);\n}",
        "output": "0",
        "idx": 1345
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void maybe_unmark_and_push(struct sock *x)\n{\n\tstruct unix_sock *u = unix_sk(x);\n\n\tif (u->gc_tree != GC_ORPHAN)\n\t\treturn;\n\tsock_hold(x);\n\tu->gc_tree = gc_current;\n\tgc_current = x;\n}",
        "output": "1",
        "idx": 870
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "validate_assignlist(asdl_seq *targets, expr_context_ty ctx)\n{\n    return validate_nonempty_seq(targets, \"targets\", ctx == Del ? \"Delete\" : \"Assign\") &&\n        validate_exprs(targets, ctx, 0);\n}",
        "output": "0",
        "idx": 2329
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "glue(cirrus_bitblt_rop_fwd_, ROP_NAME)(CirrusVGAState *s,\n                             uint8_t *dst,const uint8_t *src,\n                             int dstpitch,int srcpitch,\n                             int bltwidth,int bltheight)\n{\n    int x,y;\n    dstpitch -= bltwidth;\n    srcpitch -= bltwidth;\n    for (y = 0; y < bltheight; y++) {\n        for (x = 0; x < bltwidth; x++) {\n            ROP_OP(*dst, *src);\n            dst++;\n            src++;\n        }\n        dst += dstpitch;\n        src += srcpitch;\n    }\n}",
        "output": "1",
        "idx": 2530
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep)\n{\n\tstatic const u8 init_data[] = {\n\t\t/* initialization magic: \"get version\" */\n\t\t0xf0,\n\t\t0x00, 0x20, 0x31,\t/* Emagic */\n\t\t0x64,\t\t\t/* Unitor8 */\n\t\t0x0b,\t\t\t/* version number request */\n\t\t0x00,\t\t\t/* command version */\n\t\t0x00,\t\t\t/* EEPROM, box 0 */\n\t\t0xf7\n\t};\n\tsend_bulk_static_data(ep, init_data, sizeof(init_data));\n\t/* while we're at it, pour on more magic */\n\tsend_bulk_static_data(ep, init_data, sizeof(init_data));\n}",
        "output": "0",
        "idx": 2525
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    **/\n    T& atN(const int pos, const int x, const int y, const int z, const int c, const T& out_value) {\n      return (pos<0 || pos>=width())?(cimg::temporary(out_value)=out_value):(*this)(pos,x,y,z,c);",
        "output": "0",
        "idx": 2471
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void release_unused_pictures(H264Context *h, int remove_current)\n{\n    int i;\n\n    /* release non reference frames */\n    for (i = 0; i < MAX_PICTURE_COUNT; i++) {\n        if (h->DPB[i].f.data[0] && !h->DPB[i].reference &&\n            (remove_current || &h->DPB[i] != h->cur_pic_ptr)) {\n            unref_picture(h, &h->DPB[i]);\n        }\n    }\n}",
        "output": "0",
        "idx": 508
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rose_start_hbtimer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tdel_timer(&rose->timer);\n\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->hb;\n\n\tadd_timer(&rose->timer);\n}",
        "output": "1",
        "idx": 2323
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *enl_ipc_get(const char *msg_data)\n{\n\n\tstatic char *message = NULL;\n\tstatic unsigned short len = 0;\n\tchar buff[13], *ret_msg = NULL;\n\tregister unsigned char i;\n\tunsigned char blen;\n\n\tif (msg_data == IPC_TIMEOUT) {\n\t\treturn(IPC_TIMEOUT);\n\t}\n\tfor (i = 0; i < 12; i++) {\n\t\tbuff[i] = msg_data[i];\n\t}\n\tbuff[12] = 0;\n\tblen = strlen(buff);\n\tif (message != NULL) {\n\t\tlen += blen;\n\t\tmessage = (char *) erealloc(message, len + 1);\n\t\tstrcat(message, buff);\n\t} else {\n\t\tlen = blen;\n\t\tmessage = (char *) emalloc(len + 1);\n\t\tstrcpy(message, buff);\n\t}\n\tif (blen < 12) {\n\t\tret_msg = message;\n\t\tmessage = NULL;\n\t\tD((\"Received complete reply:  \\\"%s\\\"\\n\", ret_msg));\n\t}\n\treturn(ret_msg);\n}",
        "output": "1",
        "idx": 2034
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __page_check_anon_rmap(struct page *page,\n\tstruct vm_area_struct *vma, unsigned long address)\n{\n#ifdef CONFIG_DEBUG_VM\n\t/*\n\t * The page's anon-rmap details (mapping and index) are guaranteed to\n\t * be set up correctly at this point.\n\t *\n\t * We have exclusion against page_add_anon_rmap because the caller\n\t * always holds the page locked, except if called from page_dup_rmap,\n\t * in which case the page is already known to be setup.\n\t *\n\t * We have exclusion against page_add_new_anon_rmap because those pages\n\t * are initially only visible via the pagetables, and the pte is locked\n\t * over the call to page_add_new_anon_rmap.\n\t */\n\tBUG_ON(page_anon_vma(page)->root != vma->anon_vma->root);\n\tBUG_ON(page->index != linear_page_index(vma, address));\n#endif\n}",
        "output": "0",
        "idx": 2804
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void xenvif_grant_handle_reset(struct xenvif *vif,\n\t\t\t\t\t     u16 pending_idx)\n{\n\tif (unlikely(vif->grant_tx_handle[pending_idx] ==\n\t\t     NETBACK_INVALID_HANDLE)) {\n\t\tnetdev_err(vif->dev,\n\t\t\t   \"Trying to unmap invalid handle! pending_idx: %x\\n\",\n\t\t\t   pending_idx);\n\t\tBUG();\n\t}\n\tvif->grant_tx_handle[pending_idx] = NETBACK_INVALID_HANDLE;\n}",
        "output": "0",
        "idx": 479
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "av_cold void ff_vc2enc_free_transforms(VC2TransformContext *s)\n{\n    av_freep(&s->buffer);\n}",
        "output": "1",
        "idx": 3292
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)\n{\n  mrb_value blk;\n  mrb_value proc;\n  struct RProc *p;\n\n  /* Calling Proc.new without a block is not implemented yet */\n  mrb_get_args(mrb, \"&!\", &blk);\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));\n  mrb_proc_copy(p, mrb_proc_ptr(blk));\n  proc = mrb_obj_value(p);\n  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);\n  if (!MRB_PROC_STRICT_P(p) &&\n      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {\n    p->flags |= MRB_PROC_ORPHAN;\n  }\n  return proc;\n}",
        "output": "1",
        "idx": 1971
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool timerqueue_del(struct timerqueue_head *head, struct timerqueue_node *node)\n{\n\tWARN_ON_ONCE(RB_EMPTY_NODE(&node->node));\n\n\t/* update next pointer */\n\tif (head->next == node) {\n\t\tstruct rb_node *rbn = rb_next(&node->node);\n\n\t\thead->next = rb_entry_safe(rbn, struct timerqueue_node, node);\n\t}\n\trb_erase(&node->node, &head->head);\n\tRB_CLEAR_NODE(&node->node);\n\treturn head->next != NULL;\n}",
        "output": "1",
        "idx": 3713
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spell_load_cb(char_u *fname, void *cookie)\n{\n    spelload_T\t*slp = (spelload_T *)cookie;\n    slang_T\t*slang;\n\n    slang = spell_load_file(fname, slp->sl_lang, NULL, FALSE);\n    if (slang != NULL)\n    {\n\t// When a previously loaded file has NOBREAK also use it for the\n\t// \".add\" files.\n\tif (slp->sl_nobreak && slang->sl_add)\n\t    slang->sl_nobreak = TRUE;\n\telse if (slang->sl_nobreak)\n\t    slp->sl_nobreak = TRUE;\n\n\tslp->sl_slang = slang;\n    }\n}",
        "output": "0",
        "idx": 112
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_lou_findOpcodeNumber(const char *toFind) {\n\t/* Used by tools such as lou_debug */\n\tstatic TranslationTableOpcode lastOpcode = 0;\n\tTranslationTableOpcode opcode = lastOpcode;\n\tint length = (int)strlen(toFind);\n\tdo {\n\t\tif (length == opcodeLengths[opcode] &&\n\t\t\t\tstrcasecmp(toFind, opcodeNames[opcode]) == 0) {\n\t\t\tlastOpcode = opcode;\n\t\t\treturn opcode;\n\t\t}\n\t\topcode++;\n\t\tif (opcode >= CTO_None) opcode = 0;\n\t} while (opcode != lastOpcode);\n\treturn CTO_None;\n}",
        "output": "0",
        "idx": 2602
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fetch_result_int32(MYSQL_BIND *param,\n                               MYSQL_FIELD *field __attribute__((unused)),\n                               uchar **row)\n{\n  my_bool field_is_unsigned= test(field->flags & UNSIGNED_FLAG);\n  uint32 data= (uint32) sint4korr(*row);\n  longstore(param->buffer, data);\n  *param->error= param->is_unsigned != field_is_unsigned && data > INT_MAX32;\n  *row+= 4;\n}",
        "output": "0",
        "idx": 1692
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err text_box_size(GF_Box *s)\n{\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\n\t/*base + this + string length*/\n\ts->size += 51 + 1;\n\tif (ptr->textName)\n\t\ts->size += strlen(ptr->textName);\n\treturn GF_OK;\n}",
        "output": "1",
        "idx": 1506
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void hidp_process_report(struct hidp_session *session,\n\t\t\t\tint type, const u8 *data, int len, int intr)\n{\n\tif (len > HID_MAX_BUFFER_SIZE)\n\t\tlen = HID_MAX_BUFFER_SIZE;\n\n\tmemcpy(session->input_buf, data, len);\n\thid_input_report(session->hid, type, session->input_buf, len, intr);\n}",
        "output": "1",
        "idx": 527
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool tight_can_send_png_rect(VncState *vs, int w, int h)\n{\n    if (vs->tight.type != VNC_ENCODING_TIGHT_PNG) {\n        return false;\n    }\n\n    if (ds_get_bytes_per_pixel(vs->ds) == 1 ||\n        vs->client_pf.bytes_per_pixel == 1) {\n        return false;\n    }\n\n    return true;\n}",
        "output": "0",
        "idx": 17
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uid_t from_kuid(struct user_namespace *targ, kuid_t kuid)\n{\n\t/* Map the uid from a global kernel uid */\n\treturn map_id_up(&targ->uid_map, __kuid_val(kuid));\n}",
        "output": "0",
        "idx": 1019
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extract_job_on_completed (AutoarExtractor *extractor,\n                          gpointer         user_data)\n{\n    ExtractJob *extract_job = user_data;\n    GFile *output_file;\n\n    output_file = G_FILE (extract_job->output_files->data);\n\n    nautilus_file_changes_queue_file_added (output_file);\n}",
        "output": "0",
        "idx": 3312
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MYSQL_STMT *open_cursor(const char *query)\n{\n  int rc;\n  const ulong type= (ulong)CURSOR_TYPE_READ_ONLY;\n\n  MYSQL_STMT *stmt= mysql_stmt_init(mysql);\n  rc= mysql_stmt_prepare(stmt, query, strlen(query));\n  check_execute(stmt, rc);\n\n  mysql_stmt_attr_set(stmt, STMT_ATTR_CURSOR_TYPE, (void*) &type);\n  return stmt;\n}",
        "output": "0",
        "idx": 771
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int htc_send(struct htc_target *target, struct sk_buff *skb)\n{\n\tstruct ath9k_htc_tx_ctl *tx_ctl;\n\n\ttx_ctl = HTC_SKB_CB(skb);\n\treturn htc_issue_send(target, skb, skb->len, 0, tx_ctl->epid);\n}",
        "output": "0",
        "idx": 688
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int pci_piix3_xen_ide_unplug(DeviceState *dev)\n{\n    PCIIDEState *pci_ide;\n    DriveInfo *di;\n    int i;\n    IDEDevice *idedev;\n\n    pci_ide = PCI_IDE(dev);\n\n    for (i = 0; i < 4; i++) {\n        di = drive_get_by_index(IF_IDE, i);\n        if (di != NULL && !di->media_cd) {\n            BlockBackend *blk = blk_by_legacy_dinfo(di);\n            DeviceState *ds = blk_get_attached_dev(blk);\n            if (ds) {\n                blk_detach_dev(blk, ds);\n            }\n            pci_ide->bus[di->bus].ifs[di->unit].blk = NULL;\n            if (!(i % 2)) {\n                idedev = pci_ide->bus[di->bus].master;\n            } else {\n                idedev = pci_ide->bus[di->bus].slave;\n            }\n            idedev->conf.blk = NULL;\n            blk_unref(blk);\n        }\n    }\n    qdev_reset_all(DEVICE(dev));\n    return 0;\n}",
        "output": "0",
        "idx": 229
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ax25_disconnect(ax25_cb *ax25, int reason)\n{\n\tax25_clear_queues(ax25);\n\n\tif (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))\n\t\tax25_stop_heartbeat(ax25);\n\tax25_stop_t1timer(ax25);\n\tax25_stop_t2timer(ax25);\n\tax25_stop_t3timer(ax25);\n\tax25_stop_idletimer(ax25);\n\n\tax25->state = AX25_STATE_0;\n\n\tax25_link_failed(ax25, reason);\n\n\tif (ax25->sk != NULL) {\n\t\tlocal_bh_disable();\n\t\tbh_lock_sock(ax25->sk);\n\t\tax25->sk->sk_state     = TCP_CLOSE;\n\t\tax25->sk->sk_err       = reason;\n\t\tax25->sk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tif (!sock_flag(ax25->sk, SOCK_DEAD)) {\n\t\t\tax25->sk->sk_state_change(ax25->sk);\n\t\t\tsock_set_flag(ax25->sk, SOCK_DEAD);\n\t\t}\n\t\tbh_unlock_sock(ax25->sk);\n\t\tlocal_bh_enable();\n\t}\n}",
        "output": "1",
        "idx": 2395
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  bool const_item() const { return used_tables() == 0; }",
        "output": "1",
        "idx": 3568
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Item_equal::sort(Item_field_cmpfunc compare, void *arg)\n{\n  bubble_sort<Item>(&equal_items, compare, arg);\n}",
        "output": "0",
        "idx": 1645
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void prov_msg_recv(void)\n{\n\tk_work_reschedule(&link.prot_timer, PROTOCOL_TIMEOUT);\n\n\tif (!bt_mesh_fcs_check(link.rx.buf, link.rx.fcs)) {\n\t\tBT_ERR(\"Incorrect FCS\");\n\t\treturn;\n\t}\n\n\tgen_prov_ack_send(link.rx.id);\n\n\tif (atomic_test_bit(link.flags, ADV_LINK_INVALID)) {\n\t\tBT_WARN(\"Unexpected msg 0x%02x on invalidated link\",\n\t\t\tlink.rx.buf->data[0]);\n\t\tprov_failed(PROV_ERR_UNEXP_PDU);\n\t\treturn;\n\t}\n\n\tlink.cb->recv(&pb_adv, link.cb_data, link.rx.buf);\n}",
        "output": "0",
        "idx": 1757
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool device_path_matched(const char *path, struct btrfs_device *device)\n{\n\tint found;\n\n\trcu_read_lock();\n\tfound = strcmp(rcu_str_deref(device->name), path);\n\trcu_read_unlock();\n\n\treturn found == 0;\n}",
        "output": "0",
        "idx": 2346
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void hci_cc_write_voice_setting(struct hci_dev *hdev,\n\t\t\t\t       struct sk_buff *skb)\n{\n\t__u8 status = *((__u8 *) skb->data);\n\t__u16 setting;\n\tvoid *sent;\n\n\tBT_DBG(\"%s status 0x%2.2x\", hdev->name, status);\n\n\tif (status)\n\t\treturn;\n\n\tsent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);\n\tif (!sent)\n\t\treturn;\n\n\tsetting = get_unaligned_le16(sent);\n\n\tif (hdev->voice_setting == setting)\n\t\treturn;\n\n\thdev->voice_setting = setting;\n\n\tBT_DBG(\"%s voice setting 0x%4.4x\", hdev->name, setting);\n\n\tif (hdev->notify)\n\t\thdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);\n}",
        "output": "0",
        "idx": 968
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void switch_to_bitmap(unsigned long tifp) { }",
        "output": "1",
        "idx": 1828
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fpm_worker_pool_cleanup(int which, void *arg) /* {{{ */\n{\n\tstruct fpm_worker_pool_s *wp, *wp_next;\n\n\tfor (wp = fpm_worker_all_pools; wp; wp = wp_next) {\n\t\twp_next = wp->next;\n\t\tfpm_worker_pool_config_free(wp->config);\n\t\tfpm_children_free(wp->children);\n\t\tif ((which & FPM_CLEANUP_CHILD) == 0 && fpm_globals.parent_pid == getpid()) {\n\t\t\tfpm_scoreboard_free(wp->scoreboard);\n\t\t}\n\t\tfpm_worker_pool_free(wp);\n\t}\n\tfpm_worker_all_pools = NULL;\n}",
        "output": "1",
        "idx": 1494
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int dma_declare_contiguous(struct device *dev, phys_addr_t size,\n\t\t\t\t\t phys_addr_t base, phys_addr_t limit)\n{\n\tstruct cma *cma;\n\tint ret;\n\tret = dma_contiguous_reserve_area(size, base, limit, &cma, true);\n\tif (ret == 0)\n\t\tdev_set_cma_area(dev, cma);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 554
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mptcp_print(netdissect_options *ndo,\n            const u_char *cp, u_int len, u_char flags)\n{\n        const struct mptcp_option *opt;\n        u_int subtype;\n\n        if (len < 3)\n                return 0;\n\n        opt = (const struct mptcp_option *) cp;\n        subtype = min(MPTCP_OPT_SUBTYPE(opt->sub_etc), MPTCP_SUB_FCLOSE + 1);\n\n        ND_PRINT((ndo, \" %s\", mptcp_options[subtype].name));\n        return mptcp_options[subtype].print(ndo, cp, len, flags);\n}",
        "output": "0",
        "idx": 915
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  incXCcalls(L);\n  if (getCcalls(L) <= CSTACKERR)  /* possible stack overflow? */\n    luaE_freeCI(L);\n  luaD_call(L, func, nResults);\n  decXCcalls(L);\n}",
        "output": "1",
        "idx": 2374
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *funcs, void *allocdata)\n{\n  /* Need to bootstrap using the allocator function directly */\n  VTerm *vt = (*funcs->malloc)(sizeof(VTerm), allocdata);\n\n  vt->allocator = funcs;\n  vt->allocdata = allocdata;\n\n  vt->rows = rows;\n  vt->cols = cols;\n\n  vt->parser.state = NORMAL;\n\n  vt->parser.callbacks = NULL;\n  vt->parser.cbdata    = NULL;\n\n  vt->parser.strbuffer_len = 500; /* should be able to hold an OSC string */\n  vt->parser.strbuffer_cur = 0;\n  vt->parser.strbuffer = vterm_allocator_malloc(vt, vt->parser.strbuffer_len);\n\n  vt->outbuffer_len = 200;\n  vt->outbuffer_cur = 0;\n  vt->outbuffer = vterm_allocator_malloc(vt, vt->outbuffer_len);\n\n  return vt;\n}",
        "output": "1",
        "idx": 3188
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  virtual bool str_needs_quotes() { return TRUE; }",
        "output": "0",
        "idx": 3022
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "resolve_schema_leafref_valid_dep_flag(const struct lys_node *op_node, const struct lys_module *local_mod,\n                                      const struct lys_node *first_node, int abs_path)\n{\n    int dep1, dep2;\n    const struct lys_node *node;\n\n    if (!op_node) {\n        /* leafref pointing to a different module */\n        if (local_mod != lys_node_module(first_node)) {\n            return 1;\n        }\n    } else if (lys_parent(op_node)) {\n        /* inner operation (notif/action) */\n        if (abs_path) {\n            return 1;\n        } else {\n            /* compare depth of both nodes */\n            for (dep1 = 0, node = op_node; lys_parent(node); node = lys_parent(node));\n            for (dep2 = 0, node = first_node; lys_parent(node); node = lys_parent(node));\n            if ((dep2 > dep1) || ((dep2 == dep1) && (op_node != first_node))) {\n                return 1;\n            }\n        }\n    } else {\n        /* top-level operation (notif/rpc) */\n        if (op_node != first_node) {\n            return 1;\n        }\n    }\n\n    return 0;\n}",
        "output": "0",
        "idx": 230
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void smtp_server_connection_reply_lines(struct smtp_server_connection *conn,\n\t\t\t\t        unsigned int status,\n\t\t\t\t\tconst char *enh_code,\n\t\t\t\t\tconst char *const *text_lines)\n{\n\tstruct smtp_reply reply;\n\n\ti_zero(&reply);\n\treply.status = status;\n\treply.text_lines = text_lines;\n\n\tif (!smtp_reply_parse_enhanced_code(\n\t\tenh_code, &reply.enhanced_code, NULL))\n\t\treply.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);\n\n\tT_BEGIN {\n\t\tstring_t *str;\n\n\t\te_debug(conn->event, \"Sent: %s\", smtp_reply_log(&reply));\n\n\t\tstr = t_str_new(256);\n\t\tsmtp_reply_write(str, &reply);\n\t\to_stream_nsend(conn->conn.output, str_data(str), str_len(str));\n\t} T_END;\n}",
        "output": "0",
        "idx": 512
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mrb_include_module(mrb_state *mrb, struct RClass *c, struct RClass *m)\n{\n  mrb_check_frozen(mrb, c);\n  if (include_module_at(mrb, c, find_origin(c), m, 1) < 0) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"cyclic include detected\");\n  }\n  if (c->tt == MRB_TT_MODULE && (c->flags & MRB_FL_CLASS_IS_INHERITED)) {\n    struct RClass *data[2];\n    data[0] = c;\n    data[1] = m;\n    mrb_objspace_each_objects(mrb, fix_include_module, data);\n  }\n}",
        "output": "0",
        "idx": 3683
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "value_check_lock(int lock, char_u *name, int use_gettext)\n{\n    if (lock & VAR_LOCKED)\n    {\n\tif (name == NULL)\n\t    emsg(_(e_value_is_locked));\n\telse\n\t    semsg(_(e_value_is_locked_str),\n\t\t\t\t       use_gettext ? (char_u *)_(name) : name);\n\treturn TRUE;\n    }\n    if (lock & VAR_FIXED)\n    {\n\tif (name == NULL)\n\t    emsg(_(e_cannot_change_value));\n\telse\n\t    semsg(_(e_cannot_change_value_of_str),\n\t\t\t\t       use_gettext ? (char_u *)_(name) : name);\n\treturn TRUE;\n    }\n    return FALSE;\n}",
        "output": "0",
        "idx": 715
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static pj_status_t STATUS_FROM_SSL_ERR2(char *action, pj_ssl_sock_t *ssock,\n\t\t\t\t\tint ret, int err, int len)\n{\n    unsigned long ssl_err = err;\n\n    if (err == SSL_ERROR_SSL) {\n\tssl_err = ERR_peek_error();\n    }\n\n    /* Dig for more from OpenSSL error queue */\n    SSLLogErrors(action, ret, err, len, ssock);\n\n    ssock->last_err = ssl_err;\n    return GET_STATUS_FROM_SSL_ERR(ssl_err);\n}",
        "output": "1",
        "idx": 1659
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "compare_tor_addr_to_addr_policy(const tor_addr_t *addr, uint16_t port,\n                                const smartlist_t *policy)\n{\n  if (!policy) {\n    /* no policy? accept all. */\n    return ADDR_POLICY_ACCEPTED;\n  } else if (tor_addr_is_null(addr)) {\n    tor_assert(port != 0);\n    return compare_unknown_tor_addr_to_addr_policy(port, policy);\n  } else if (port == 0) {\n    return compare_known_tor_addr_to_addr_policy_noport(addr, policy);\n  } else {\n    return compare_known_tor_addr_to_addr_policy(addr, port, policy);\n  }\n}",
        "output": "1",
        "idx": 695
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    \"disallowed submodule name: %s\",\n\t\t\t\t    name);\n\tif (!strcmp(key, \"url\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_URL,\n\t\t\t\t    \"disallowed submodule url: %s\",\n\t\t\t\t    value);\n\tfree(name);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 545
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void MSG_WriteDeltaKey( msg_t *msg, int key, int oldV, int newV, int bits ) {\n\tif ( oldV == newV ) {\n\t\tMSG_WriteBits( msg, 0, 1 );\n\t\treturn;\n\t}\n\tMSG_WriteBits( msg, 1, 1 );\n\tMSG_WriteBits( msg, newV ^ key, bits );\n}",
        "output": "0",
        "idx": 374
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "virSecuritySELinuxMoveImageMetadata(virSecurityManager *mgr,\n                                    pid_t pid,\n                                    virStorageSource *src,\n                                    virStorageSource *dst)\n{\n    struct virSecuritySELinuxMoveImageMetadataData data = { .mgr = mgr, 0 };\n    int rc;\n\n    if (src && virStorageSourceIsLocalStorage(src))\n        data.src = src->path;\n\n    if (dst && virStorageSourceIsLocalStorage(dst))\n        data.dst = dst->path;\n\n    if (!data.src)\n        return 0;\n\n    if (pid == -1) {\n        rc = virProcessRunInFork(virSecuritySELinuxMoveImageMetadataHelper,\n                                 &data);\n    } else {\n        rc = virProcessRunInMountNamespace(pid,\n                                           virSecuritySELinuxMoveImageMetadataHelper,\n                                           &data);\n    }\n\n    return rc;\n}",
        "output": "0",
        "idx": 15
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cr_input_read_byte (CRInput * a_this, guchar * a_byte)\n{\n        g_return_val_if_fail (a_this && PRIVATE (a_this)\n                              && a_byte, CR_BAD_PARAM_ERROR);\n\n        g_return_val_if_fail (PRIVATE (a_this)->next_byte_index <=\n                              PRIVATE (a_this)->nb_bytes, CR_BAD_PARAM_ERROR);\n\n        if (PRIVATE (a_this)->end_of_input == TRUE)\n                return CR_END_OF_INPUT_ERROR;\n\n        *a_byte = PRIVATE (a_this)->in_buf[PRIVATE (a_this)->next_byte_index];\n\n        if (PRIVATE (a_this)->nb_bytes -\n            PRIVATE (a_this)->next_byte_index < 2) {\n                PRIVATE (a_this)->end_of_input = TRUE;\n        } else {\n                PRIVATE (a_this)->next_byte_index++;\n        }\n\n        return CR_OK;\n}",
        "output": "1",
        "idx": 2229
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "session_worker_child_watch (GPid              pid,\n                            int               status,\n                            GdmSessionWorker *worker)\n{\n        g_debug (\"GdmSessionWorker: child (pid:%d) done (%s:%d)\",\n                 (int) pid,\n                 WIFEXITED (status) ? \"status\"\n                 : WIFSIGNALED (status) ? \"signal\"\n                 : \"unknown\",\n                 WIFEXITED (status) ? WEXITSTATUS (status)\n                 : WIFSIGNALED (status) ? WTERMSIG (status)\n                 : -1);\n\n\n        gdm_session_worker_uninitialize_pam (worker, PAM_SUCCESS);\n\n        gdm_dbus_worker_emit_session_exited (GDM_DBUS_WORKER (worker),\n                                             worker->priv->service,\n                                             status);\n\n        killpg (pid, SIGHUP);\n\n        worker->priv->child_pid = -1;\n        worker->priv->child_watch_id = 0;\n        run_script (worker, GDMCONFDIR \"/PostSession\");\n}",
        "output": "1",
        "idx": 2536
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ServerSecurityFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {\n  options->addOption(\"--server.harden\",\n                     \"lock down REST APIs that reveal version information or server \"\n                     \"internals for non-admin users\",\n                     new BooleanParameter(&_hardenedRestApi))\n                     .setIntroducedIn(30500);\n\n  options->addOption(\"--foxx.api\", \"enables Foxx management REST APIs\",\n                     new BooleanParameter(&_enableFoxxApi),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30500);\n  options->addOption(\"--foxx.store\", \"enables Foxx store in web interface\",\n                     new BooleanParameter(&_enableFoxxStore),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30500);\n\n}",
        "output": "1",
        "idx": 914
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mount_rootfs_block(const char *rootfs, const char *target,\n\t\t\t                  const char *options)\n{\n\treturn mount_unknown_fs(rootfs, target, options);\n}",
        "output": "0",
        "idx": 1621
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool pt_can_write_msr(struct vcpu_vmx *vmx)\n{\n\treturn vmx_pt_mode_is_host_guest() &&\n\t       !(vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN);\n}",
        "output": "0",
        "idx": 442
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct dentry *proc_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\tint err;\n\tstruct super_block *sb;\n\tstruct pid_namespace *ns;\n\tchar *options;\n\n\tif (flags & MS_KERNMOUNT) {\n\t\tns = (struct pid_namespace *)data;\n\t\toptions = NULL;\n\t} else {\n\t\tns = task_active_pid_ns(current);\n\t\toptions = data;\n\n\t\t/* Does the mounter have privilege over the pid namespace? */\n\t\tif (!ns_capable(ns->user_ns, CAP_SYS_ADMIN))\n\t\t\treturn ERR_PTR(-EPERM);\n\t}\n\n\tsb = sget(fs_type, proc_test_super, proc_set_super, flags, ns);\n\tif (IS_ERR(sb))\n\t\treturn ERR_CAST(sb);\n\n\tif (!proc_parse_options(options, ns)) {\n\t\tdeactivate_locked_super(sb);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!sb->s_root) {\n\t\terr = proc_fill_super(sb);\n\t\tif (err) {\n\t\t\tdeactivate_locked_super(sb);\n\t\t\treturn ERR_PTR(err);\n\t\t}\n\n\t\tsb->s_flags |= MS_ACTIVE;\n\t\t/* User space would break if executables appear on proc */\n\t\tsb->s_iflags |= SB_I_NOEXEC;\n\t}\n\n\treturn dget(sb->s_root);\n}",
        "output": "1",
        "idx": 1319
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Logger::addMessage(const QString &message, const Log::MsgType &type)\n{\n    QWriteLocker locker(&lock);\n\n    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, message };\n    m_messages.push_back(temp);\n\n    if (m_messages.size() >= MAX_LOG_MESSAGES)\n        m_messages.pop_front();\n\n    emit newLogMessage(temp);\n}",
        "output": "1",
        "idx": 1403
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  static const char* ConvertScalar(PyObject* v, tstring* out) {\n    if (PyBytes_Check(v)) {\n      out->assign(PyBytes_AS_STRING(v), PyBytes_GET_SIZE(v));\n      return nullptr;\n    }\n    if (PyUnicode_Check(v)) {\n#if PY_MAJOR_VERSION >= 3\n      Py_ssize_t size;\n      const char* str = PyUnicode_AsUTF8AndSize(v, &size);\n      if (str == nullptr) return ErrorConvertingUnicodeString;\n      out->assign(str, size);\n      return nullptr;\n#else\n      PyObject* py_str = PyUnicode_AsUTF8String(v);\n      if (py_str == nullptr) return ErrorConvertingUnicodeString;\n      out->assign(PyBytes_AS_STRING(py_str), PyBytes_GET_SIZE(py_str));\n      Py_DECREF(py_str);\n      return nullptr;\n#endif\n    }\n    return ErrorMixedTypes;\n  }",
        "output": "1",
        "idx": 2375
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\t\n\t*data = &iterator->current;\n}",
        "output": "1",
        "idx": 1798
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, int mode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *pos, *ctx = NULL;\n\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(pos, &nfsi->open_files, list) {\n\t\tif (cred != NULL && pos->cred != cred)\n\t\t\tcontinue;\n\t\tif ((pos->mode & mode) == mode) {\n\t\t\tctx = get_nfs_open_context(pos);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn ctx;\n}",
        "output": "1",
        "idx": 3065
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jas_iccgetuint64(jas_stream_t *in, jas_iccuint64_t *val)\n{\n\tulonglong tmp;\n\tif (jas_iccgetuint(in, 8, &tmp))\n\t\treturn -1;\n\t*val = tmp;\n\treturn 0;\n}",
        "output": "1",
        "idx": 3578
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "val_exp_sec_ctx_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t *context_handle,\n    gss_buffer_t interprocess_token)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    if (interprocess_token != GSS_C_NO_BUFFER) {\n\tinterprocess_token->length = 0;\n\tinterprocess_token->value = NULL;\n    }\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == NULL || *context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (interprocess_token == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    return (GSS_S_COMPLETE);\n}",
        "output": "0",
        "idx": 534
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "irc_server_set_prefix_modes_chars (struct t_irc_server *server,\n                                   const char *prefix)\n{\n    char *pos;\n    int i, length_modes, length_chars;\n\n    if (!server || !prefix)\n        return;\n\n    /* free previous values */\n    if (server->prefix_modes)\n    {\n        free (server->prefix_modes);\n        server->prefix_modes = NULL;\n    }\n    if (server->prefix_chars)\n    {\n        free (server->prefix_chars);\n        server->prefix_chars = NULL;\n    }\n\n    /* assign new values */\n    pos = strchr (prefix, ')');\n    if (pos)\n    {\n        server->prefix_modes = weechat_strndup (prefix + 1,\n                                                pos - prefix - 1);\n        if (server->prefix_modes)\n        {\n            pos++;\n            length_modes = strlen (server->prefix_modes);\n            length_chars = strlen (pos);\n            server->prefix_chars = malloc (length_modes + 1);\n            if (server->prefix_chars)\n            {\n                for (i = 0; i < length_modes; i++)\n                {\n                    server->prefix_chars[i] = (i < length_chars) ? pos[i] : ' ';\n                }\n                server->prefix_chars[length_modes] = '\\0';\n            }\n            else\n            {\n                free (server->prefix_modes);\n                server->prefix_modes = NULL;\n            }\n        }\n    }\n}",
        "output": "1",
        "idx": 2349
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "free_mbdata (struct dfa *d)\n{\n  unsigned int i;\n\n  free(d->multibyte_prop);\n  d->multibyte_prop = NULL;\n\n  for (i = 0; i < d->nmbcsets; ++i)\n    {\n      unsigned int j;\n      struct mb_char_classes *p = &(d->mbcsets[i]);\n      free(p->chars);\n      free(p->ch_classes);\n      free(p->range_sts);\n      free(p->range_ends);\n\n      for (j = 0; j < p->nequivs; ++j)\n        free(p->equivs[j]);\n      free(p->equivs);\n\n      for (j = 0; j < p->ncoll_elems; ++j)\n        free(p->coll_elems[j]);\n      free(p->coll_elems);\n    }\n\n  free(d->mbcsets);\n  d->mbcsets = NULL;\n  d->nmbcsets = 0;\n}",
        "output": "1",
        "idx": 3316
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline static int jas_fast32_asr(int_fast32_t x, int n)\n{\n\tassert(n >= 0);\n\t// The behavior is undefined when x is negative. */\n\t// We tacitly assume the behavior is equivalent to a signed\n\t// arithmetic right shift.\n\treturn x >> n;\n}",
        "output": "0",
        "idx": 1128
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ms_adpcm_reset2 (_AFmoduleinst *i)\n{\n\tms_adpcm_data\t*d = (ms_adpcm_data *) i->modspec;\n\tint\t\tframesPerBlock;\n\n\tframesPerBlock = d->samplesPerBlock / d->track->f.channelCount;\n\n\td->track->fpos_next_frame = d->track->fpos_first_frame +\n\t\td->blockAlign * (d->track->nextfframe / framesPerBlock);\n\td->track->frames2ignore += d->framesToIgnore;\n\n\tassert(d->track->nextfframe % framesPerBlock == 0);\n}",
        "output": "1",
        "idx": 817
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n    mode_t mode, unsigned long set, unsigned long clear)\n{\n\t(void)a; /* UNUSED */\n\t(void)fd; /* UNUSED */\n\t(void)name; /* UNUSED */\n\t(void)mode; /* UNUSED */\n\t(void)set; /* UNUSED */\n\t(void)clear; /* UNUSED */\n\treturn (ARCHIVE_OK);\n}",
        "output": "1",
        "idx": 151
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gs_grab_get_keyboard (GSGrab    *grab,\n                      GdkWindow *window,\n                      GdkScreen *screen)\n{\n        GdkGrabStatus status;\n\n        g_return_val_if_fail (window != NULL, FALSE);\n        g_return_val_if_fail (screen != NULL, FALSE);\n\n        gs_debug (\"Grabbing keyboard widget=%X\", (guint32) GDK_WINDOW_XID (window));\n        status = gdk_keyboard_grab (window, FALSE, GDK_CURRENT_TIME);\n\n        if (status == GDK_GRAB_SUCCESS) {\n                grab->priv->keyboard_grab_window = window;\n                grab->priv->keyboard_grab_screen = screen;\n        } else {\n                gs_debug (\"Couldn't grab keyboard!  (%s)\", grab_string (status));\n        }\n\n        return status;\n}",
        "output": "1",
        "idx": 167
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Item_param::set_decimal(const my_decimal *dv, bool unsigned_arg)\n{\n  DBUG_ASSERT(value.type_handler()->cmp_type() == DECIMAL_RESULT);\n  state= SHORT_DATA_VALUE;\n\n  my_decimal2decimal(dv, &value.m_decimal);\n\n  decimals= (uint8) value.m_decimal.frac;\n  collation.set_numeric();\n  unsigned_flag= unsigned_arg;\n  max_length= my_decimal_precision_to_length(value.m_decimal.intg + decimals,\n                                             decimals, unsigned_flag);\n  maybe_null= 0;\n  null_value= 0;\n  fix_type(Item::DECIMAL_ITEM);\n}",
        "output": "0",
        "idx": 1048
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Map1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,\n        SDL_PixelFormat * dst)\n{\n    Uint8 *map;\n    int i;\n    int bpp;\n    SDL_Palette *pal = src->palette;\n\n    bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);\n    map = (Uint8 *) SDL_malloc(pal->ncolors * bpp);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n\n    /* We memory copy to the pixel map so the endianness is preserved */\n    for (i = 0; i < pal->ncolors; ++i) {\n        Uint8 R = (Uint8) ((pal->colors[i].r * Rmod) / 255);\n        Uint8 G = (Uint8) ((pal->colors[i].g * Gmod) / 255);\n        Uint8 B = (Uint8) ((pal->colors[i].b * Bmod) / 255);\n        Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255);\n        ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A);\n    }\n    return (map);\n}",
        "output": "1",
        "idx": 1710
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int check_unsafe_exec(struct linux_binprm *bprm)\n{\n\tstruct task_struct *p = current, *t;\n\tunsigned n_fs;\n\tint res = 0;\n\n\tif (p->ptrace) {\n\t\tif (p->ptrace & PT_PTRACE_CAP)\n\t\t\tbprm->unsafe |= LSM_UNSAFE_PTRACE_CAP;\n\t\telse\n\t\t\tbprm->unsafe |= LSM_UNSAFE_PTRACE;\n\t}\n\n\tn_fs = 1;\n\tspin_lock(&p->fs->lock);\n\trcu_read_lock();\n\tfor (t = next_thread(p); t != p; t = next_thread(t)) {\n\t\tif (t->fs == p->fs)\n\t\t\tn_fs++;\n\t}\n\trcu_read_unlock();\n\n\tif (p->fs->users > n_fs) {\n\t\tbprm->unsafe |= LSM_UNSAFE_SHARE;\n\t} else {\n\t\tres = -EAGAIN;\n\t\tif (!p->fs->in_exec) {\n\t\t\tp->fs->in_exec = 1;\n\t\t\tres = 1;\n\t\t}\n\t}\n\tspin_unlock(&p->fs->lock);\n\n\treturn res;\n}",
        "output": "1",
        "idx": 520
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcf_poll *nfcf_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcf_poll->bit_rate = *data++;\n\tnfcf_poll->sensf_res_len = *data++;\n\n\tpr_debug(\"bit_rate %d, sensf_res_len %d\\n\",\n\t\t nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);\n\n\tmemcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);\n\tdata += nfcf_poll->sensf_res_len;\n\n\treturn data;\n}",
        "output": "1",
        "idx": 3004
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\nstatic inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,\n\t\tunsigned int length, gfp_t gfp)\n{\n\tstruct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);\n\n\tif (NET_IP_ALIGN && skb)\n\t\tskb_reserve(skb, NET_IP_ALIGN);\n\treturn skb;",
        "output": "0",
        "idx": 3364
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "date_s_httpdate(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE str, sg;\n\n    rb_scan_args(argc, argv, \"02\", &str, &sg);\n\n    switch (argc) {\n      case 0:\n\tstr = rb_str_new2(\"Mon, 01 Jan -4712 00:00:00 GMT\");\n      case 1:\n\tsg = INT2FIX(DEFAULT_SG);\n    }\n\n    {\n\tVALUE hash = date_s__httpdate(klass, str);\n\treturn d_new_by_frags(klass, hash, sg);\n    }\n}",
        "output": "1",
        "idx": 1383
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ipc_rcu_free(struct rcu_head *head)\n{\n\tstruct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);\n\n\tkvfree(p);\n}",
        "output": "0",
        "idx": 2009
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\n    const CImg<T>& _save_tiff(TIFF *tif, const unsigned int directory, const unsigned int z,\n                              const unsigned int compression_type, const float *const voxel_size,\n                              const char *const description) const {\n      _cimg_save_tiff(\"bool\",unsigned char,compression_type);\n      _cimg_save_tiff(\"unsigned char\",unsigned char,compression_type);\n      _cimg_save_tiff(\"char\",char,compression_type);\n      _cimg_save_tiff(\"unsigned short\",unsigned short,compression_type);\n      _cimg_save_tiff(\"short\",short,compression_type);\n      _cimg_save_tiff(\"unsigned int\",unsigned int,compression_type);\n      _cimg_save_tiff(\"int\",int,compression_type);\n      _cimg_save_tiff(\"unsigned int64\",unsigned int,compression_type);\n      _cimg_save_tiff(\"int64\",int,compression_type);\n      _cimg_save_tiff(\"float\",float,compression_type);\n      _cimg_save_tiff(\"double\",float,compression_type);\n      const char *const filename = TIFFFileName(tif);\n      throw CImgInstanceException(_cimg_instance\n                                  \"save_tiff(): Unsupported pixel type '%s' for file '%s'.\",\n                                  cimg_instance,\n                                  pixel_type(),filename?filename:\"(FILE*)\");\n      return *this;",
        "output": "0",
        "idx": 1724
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "renderCoTable(struct table *tbl, int maxlimit)\n{\n    struct readbuffer obuf;\n    struct html_feed_environ h_env;\n    struct environment envs[MAX_ENV_LEVEL];\n    struct table *t;\n    int i, col, row;\n    int indent, maxwidth;\n\n    if (cotable_level >= MAX_COTABLE_LEVEL)\n\treturn;\t/* workaround to prevent infinite recursion */\n    cotable_level++;\n\n    for (i = 0; i < tbl->ntable; i++) {\n\tt = tbl->tables[i].ptr;\n\tcol = tbl->tables[i].col;\n\trow = tbl->tables[i].row;\n\tindent = tbl->tables[i].indent;\n\n\tinit_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[i].buf,\n\t\t  get_spec_cell_width(tbl, row, col), indent);\n\tcheck_row(tbl, row);\n\tif (h_env.limit > maxlimit)\n\t    h_env.limit = maxlimit;\n\tif (t->total_width == 0)\n\t    maxwidth = h_env.limit - indent;\n\telse if (t->total_width > 0)\n\t    maxwidth = t->total_width;\n\telse\n\t    maxwidth = t->total_width = -t->total_width * h_env.limit / 100;\n\trenderTable(t, maxwidth, &h_env);\n    }\n}",
        "output": "1",
        "idx": 1517
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "build_config(char *prefix, struct server *server)\n{\n    char *path    = NULL;\n    int path_size = strlen(prefix) + strlen(server->port) + 20;\n\n    path = ss_malloc(path_size);\n    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n    FILE *f = fopen(path, \"w+\");\n    if (f == NULL) {\n        if (verbose) {\n            LOGE(\"unable to open config file\");\n        }\n        ss_free(path);\n        return;\n    }\n    fprintf(f, \"{\\n\");\n    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n    fprintf(f, \"\\n}\\n\");\n    fclose(f);\n    ss_free(path);\n}",
        "output": "1",
        "idx": 1770
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vmx_slot_enable_log_dirty(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot)\n{\n\tkvm_mmu_slot_leaf_clear_dirty(kvm, slot);\n\tkvm_mmu_slot_largepage_remove_write_access(kvm, slot);\n}",
        "output": "0",
        "idx": 1512
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\tif (sk_hashed(sk)) {\n\t\twrite_lock_bh(&ping_table.lock);\n\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsock_put(sk);\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t\twrite_unlock_bh(&ping_table.lock);\n\t}\n}",
        "output": "1",
        "idx": 943
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_coc_t *coc = &ms->parms.coc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, coc->compno) > dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in COC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromcoc(dec->cp, coc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromcoc(tile->cp, coc);\n\t\tbreak;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 694
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline Http2Stream* GetStream(Http2Session* session,\n                              int32_t id,\n                              nghttp2_data_source* source) {\n  Http2Stream* stream = static_cast<Http2Stream*>(source->ptr);\n  if (stream == nullptr)\n    stream = session->FindStream(id);\n  CHECK_NE(stream, nullptr);\n  CHECK_EQ(id, stream->id());\n  return stream;\n}",
        "output": "0",
        "idx": 1259
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MagickExport MagickBooleanType GetOneVirtualPixel(const Image *image,\n  const ssize_t x,const ssize_t y,Quantum *pixel,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  const Quantum\n    *p;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  (void) memset(pixel,0,MaxPixelChannels*sizeof(*pixel));\n  if (cache_info->methods.get_one_virtual_pixel_from_handler !=\n       (GetOneVirtualPixelFromHandler) NULL)\n    return(cache_info->methods.get_one_virtual_pixel_from_handler(image,\n      GetPixelCacheVirtualMethod(image),x,y,pixel,exception));\n  assert(id < (int) cache_info->number_threads);\n  p=GetVirtualPixelsFromNexus(image,GetPixelCacheVirtualMethod(image),x,y,\n    1UL,1UL,cache_info->nexus_info[id],exception);\n  return(CopyPixel(image,p,pixel));\n}",
        "output": "0",
        "idx": 2936
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline int Http2Session::OnFrameReceive(nghttp2_session* handle,\n                                        const nghttp2_frame* frame,\n                                        void* user_data) {\n  Http2Session* session = static_cast<Http2Session*>(user_data);\n  session->statistics_.frame_count++;\n  DEBUG_HTTP2SESSION2(session, \"complete frame received: type: %d\",\n                      frame->hd.type);\n  switch (frame->hd.type) {\n    case NGHTTP2_DATA:\n      session->HandleDataFrame(frame);\n      break;\n    case NGHTTP2_PUSH_PROMISE:\n      // Intentional fall-through, handled just like headers frames\n    case NGHTTP2_HEADERS:\n      session->HandleHeadersFrame(frame);\n      break;\n    case NGHTTP2_SETTINGS:\n      session->HandleSettingsFrame(frame);\n      break;\n    case NGHTTP2_PRIORITY:\n      session->HandlePriorityFrame(frame);\n      break;\n    case NGHTTP2_GOAWAY:\n      session->HandleGoawayFrame(frame);\n      break;\n    case NGHTTP2_PING:\n      session->HandlePingFrame(frame);\n    default:\n      break;\n  }\n  return 0;\n}",
        "output": "1",
        "idx": 1796
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Vers_history_point::bad_expression_data_type_error(const char *type) const\n{\n  my_error(ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION, MYF(0),\n           type, \"FOR SYSTEM_TIME\");\n}",
        "output": "0",
        "idx": 1353
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SpoolssSetPrinterDataEx_r(tvbuff_t *tvb, int offset,\n\t\t\t\t     packet_info *pinfo, proto_tree *tree,\n\t\t\t\t     dcerpc_info *di, guint8 *drep _U_)\n{\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_doserror(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_rc, NULL);\n\n\treturn offset;\n}",
        "output": "0",
        "idx": 3311
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "is_match_charset(\n    FontData\tfont_data,\n    char\t*font_name)\n{\n    char *last;\n    int length, name_len;\n\n    name_len = strlen(font_name);\n    last = font_name + name_len;\n\n    length = strlen(font_data->name);\n    if (length > name_len)\n\treturn False;\n\n    if (_XlcCompareISOLatin1(last - length, font_data->name) == 0)\n\treturn True;\n\n    return False;\n}",
        "output": "0",
        "idx": 950
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gdk_pixbuf__gif_image_load_animation (FILE *file,\n                                      GError **error)\n{\n\tGifContext *context;\n\tGdkPixbufAnimation *animation;\n\n\tg_return_val_if_fail (file != NULL, NULL);\n\n\tcontext = new_context ();\n\n        context->error = error;\n\tcontext->file = file;\n\n\tif (gif_main_loop (context) == -1 || context->animation->frames == NULL) {\n                if (context->error && *(context->error) == NULL)\n                        g_set_error (context->error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,\n                                     _(\"GIF file was missing some data (perhaps it was truncated somehow?)\"));\n\n                g_object_unref (G_OBJECT (context->animation));\n                context->animation = NULL;\n        }\n\n        if (context->animation)\n                animation = GDK_PIXBUF_ANIMATION (context->animation);\n        else\n                animation = NULL;\n\n        if (context->error && *(context->error))\n                g_print (\"%s\\n\", (*(context->error))->message);\n        \n        g_free (context->buf);\n\tg_free (context);\n\treturn animation;\n}",
        "output": "1",
        "idx": 327
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,\n\t\t\tstruct vmcs12 *vmcs12,\n\t\t\tu32 reason, unsigned long qualification)\n{\n\tload_vmcs12_host_state(vcpu, vmcs12);\n\tvmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;\n\tvmcs12->exit_qualification = qualification;\n\tnested_vmx_succeed(vcpu);\n\tif (enable_shadow_vmcs)\n\t\tto_vmx(vcpu)->nested.sync_shadow_vmcs = true;\n}",
        "output": "0",
        "idx": 754
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "*/\nstatic void mysql_prune_stmt_list(MYSQL *mysql)\n{\n  LIST *element= mysql->stmts;\n  LIST *pruned_list= 0;\n\n  for (; element; element= element->next)\n  {\n    MYSQL_STMT *stmt= (MYSQL_STMT *) element->data;\n    if (stmt->state != MYSQL_STMT_INIT_DONE)\n    {\n      stmt->mysql= 0;\n      stmt->last_errno= CR_SERVER_LOST;\n      strmov(stmt->last_error, ER(CR_SERVER_LOST));\n      strmov(stmt->sqlstate, unknown_sqlstate);\n    }\n    else\n    {\n      pruned_list= list_add(pruned_list, element);\n    }\n  }\n\n  mysql->stmts= pruned_list;",
        "output": "1",
        "idx": 3635
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void lpFree(unsigned char *lp) {\n    lp_free(lp);\n}",
        "output": "0",
        "idx": 389
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gboolean\nmono_verifier_verify_class (MonoClass *class)\n{\n\t/*Neither <Module>, object or ifaces have parent.*/\n\tif (!class->parent &&\n\t\tclass != mono_defaults.object_class && \n\t\t!MONO_CLASS_IS_INTERFACE (class) &&\n\t\t(!class->image->dynamic && class->type_token != 0x2000001)) /*<Module> is the first type in the assembly*/\n\t\treturn FALSE;\n\tif (class->parent) {\n\t\tif (MONO_CLASS_IS_INTERFACE (class->parent))\n\t\t\treturn FALSE;\n\t\tif (!class->generic_class && class->parent->generic_container)\n\t\t\treturn FALSE;\n\t}\n\tif (class->generic_container && (class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)\n\t\treturn FALSE;\n\tif (class->generic_container && !verify_generic_parameters (class))\n\t\treturn FALSE;\n\tif (!verify_class_for_overlapping_reference_fields (class))\n\t\treturn FALSE;\n\tif (class->generic_class && !mono_class_is_valid_generic_instantiation (NULL, class))\n\t\treturn FALSE;\n\tif (class->generic_class == NULL && !verify_class_fields (class))\n\t\treturn FALSE;\n\tif (class->valuetype && !verify_valuetype_layout (class))\n\t\treturn FALSE;\n\tif (!verify_interfaces (class))\n\t\treturn FALSE;\n\treturn TRUE;",
        "output": "0",
        "idx": 2553
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "do_intthrow(cstack_T *cstack)\n{\n    /*\n     * If no interrupt occurred or no try conditional is active and no exception\n     * is being thrown, do nothing (for compatibility of non-EH scripts).\n     */\n    if (!got_int || (trylevel == 0 && !did_throw))\n\treturn FALSE;\n\n#ifdef THROW_TEST\t// avoid warning for condition always true\n    if (!THROW_ON_INTERRUPT)\n    {\n\t/*\n\t * The interrupt aborts everything except for executing finally clauses.\n\t * Discard any user or error or interrupt exception currently being\n\t * thrown.\n\t */\n\tif (did_throw)\n\t    discard_current_exception();\n    }\n    else\n#endif\n    {\n\t/*\n\t * Throw an interrupt exception, so that everything will be aborted\n\t * (except for executing finally clauses), until the interrupt exception\n\t * is caught; if still uncaught at the top level, the script processing\n\t * will be terminated then.  -  If an interrupt exception is already\n\t * being thrown, do nothing.\n\t *\n\t */\n\tif (did_throw)\n\t{\n\t    if (current_exception->type == ET_INTERRUPT)\n\t\treturn FALSE;\n\n\t    // An interrupt exception replaces any user or error exception.\n\t    discard_current_exception();\n\t}\n\tif (throw_exception(\"Vim:Interrupt\", ET_INTERRUPT, NULL) != FAIL)\n\t    do_throw(cstack);\n    }\n\n    return TRUE;\n}",
        "output": "0",
        "idx": 3334
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ldap_decode_attrib(TALLOC_CTX *mem_ctx, struct asn1_data *data,\n\t\t\t       struct ldb_message_element *attrib)\n{\n\tasn1_start_tag(data, ASN1_SEQUENCE(0));\n\tasn1_read_OctetString_talloc(mem_ctx, data, &attrib->name);\n\tasn1_start_tag(data, ASN1_SET);\n\twhile (asn1_peek_tag(data, ASN1_OCTET_STRING)) {\n\t\tDATA_BLOB blob;\n\t\tasn1_read_OctetString(data, mem_ctx, &blob);\n\t\tadd_value_to_attrib(mem_ctx, &blob, attrib);\n\t}\n\tasn1_end_tag(data);\n\tasn1_end_tag(data);\n\t\n}",
        "output": "1",
        "idx": 2308
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ews_backend_constructed (GObject *object)\n{\n\tEBackend *backend;\n\tESource *source;\n\tESourceAuthentication *auth_extension;\n\tconst gchar *extension_name;\n\tgchar *host = NULL;\n\tguint16 port = 0;\n\n\t/* Chain up to parent's constructed() method. */\n\tG_OBJECT_CLASS (e_ews_backend_parent_class)->constructed (object);\n\n\tbackend = E_BACKEND (object);\n\tsource = e_backend_get_source (backend);\n\n\t/* XXX Wondering if we ought to delay this until after folders\n\t *     are initially populated, just to remove the possibility\n\t *     of weird races with clients trying to create folders. */\n\te_server_side_source_set_remote_creatable (\n\t\tE_SERVER_SIDE_SOURCE (source), TRUE);\n\n\t/* Setup the Authentication extension so\n\t * Camel can determine host reachability. */\n\textension_name = E_SOURCE_EXTENSION_AUTHENTICATION;\n\tauth_extension = e_source_get_extension (source, extension_name);\n\n\tif (e_backend_get_destination_address (backend, &host, &port)) {\n\t\te_source_authentication_set_host (auth_extension, host);\n\t\te_source_authentication_set_port (auth_extension, port);\n\t}\n\n\tg_free (host);\n\n\t/* Reset the connectable, it steals data from Authentication extension,\n\t   where is written incorrect address */\n\te_backend_set_connectable (backend, NULL);\n}",
        "output": "1",
        "idx": 2274
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_client_protocol_timeout (GsmXSMPClient *client)\n{\n        g_debug (\"GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d\",\n                 client->priv->description,\n                 IceConnectionStatus (client->priv->ice_connection));\n\n        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);\n        gsm_client_disconnected (GSM_CLIENT (client));\n\n        return FALSE;\n}",
        "output": "1",
        "idx": 2102
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "link_to_name (char const *link_name, char const *link_target)\n{\n  int res = link (link_target, link_name);\n  if (res < 0 && create_dir_flag)\n    {\n      create_all_directories (link_name);\n      res = link (link_target, link_name);\n    }\n  if (res == 0)\n    {\n      if (verbose_flag)\n\terror (0, 0, _(\"%s linked to %s\"),\n\t       link_target, link_name);\n    }\n  else if (link_flag)\n    {\n      error (0, errno, _(\"cannot link %s to %s\"),\n\t     link_target, link_name);\n    }\n  return res;\n}",
        "output": "0",
        "idx": 3505
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static length_t compress_packet(uint8_t *dest, const uint8_t *source, length_t len, int level) {\n\tif(level == 0) {\n\t\tmemcpy(dest, source, len);\n\t\treturn len;\n\t} else if(level == 10) {\n#ifdef HAVE_LZO\n\t\tlzo_uint lzolen = MAXSIZE;\n\t\tlzo1x_1_compress(source, len, dest, &lzolen, lzo_wrkmem);\n\t\treturn lzolen;\n#else\n\t\treturn -1;\n#endif\n\t} else if(level < 10) {\n#ifdef HAVE_ZLIB\n\t\tunsigned long destlen = MAXSIZE;\n\t\tif(compress2(dest, &destlen, source, len, level) == Z_OK)\n\t\t\treturn destlen;\n\t\telse\n#endif\n\t\t\treturn -1;\n\t} else {\n#ifdef HAVE_LZO\n\t\tlzo_uint lzolen = MAXSIZE;\n\t\tlzo1x_999_compress(source, len, dest, &lzolen, lzo_wrkmem);\n\t\treturn lzolen;\n#else\n\t\treturn -1;\n#endif\n\t}\n\t\n\treturn -1;\n}",
        "output": "0",
        "idx": 2493
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn;\n\n\tbitmap_zero(vcpu->arch.ioapic_handled_vectors, 256);\n\n\tif (irqchip_split(vcpu->kvm))\n\t\tkvm_scan_ioapic_routes(vcpu, vcpu->arch.ioapic_handled_vectors);\n\telse {\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tkvm_x86_ops->sync_pir_to_irr(vcpu);\n\t\tkvm_ioapic_scan_entry(vcpu, vcpu->arch.ioapic_handled_vectors);\n\t}\n\n\tif (is_guest_mode(vcpu))\n\t\tvcpu->arch.load_eoi_exitmap_pending = true;\n\telse\n\t\tkvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);\n}",
        "output": "1",
        "idx": 1644
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iperf_get_control_socket(struct iperf_test *ipt)\n{\n    return ipt->ctrl_sck;\n}",
        "output": "0",
        "idx": 3478
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void kvm_queue_exception_p(struct kvm_vcpu *vcpu, unsigned nr,\n\t\t\t   unsigned long payload)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, true, payload, false);\n}",
        "output": "0",
        "idx": 344
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void drbg_set_testdata(struct drbg_state *drbg,\n\t\t\t\t     struct drbg_test_data *test_data)\n{\n\tif (!test_data || !test_data->testentropy)\n\t\treturn;\n\tmutex_lock(&drbg->drbg_mutex);;\n\tdrbg->test_data = test_data;\n\tmutex_unlock(&drbg->drbg_mutex);\n}",
        "output": "1",
        "idx": 3355
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "      ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa,\n                                const std::string& emsa) :\n         PK_Ops::Signature_with_EMSA(emsa),\n         m_group(ecdsa.domain()),\n         m_x(ecdsa.private_value())\n         {\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n         m_rfc6979_hash = hash_for_emsa(emsa);\n#endif\n         }",
        "output": "1",
        "idx": 1784
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "srs_set_separator(srs_t *srs, char value)\n{\n\tif (strchr(srs_separators, value) == NULL)\n\t\treturn SRS_ESEPARATORINVALID;\n\tsrs->separator = value;\n\treturn SRS_SUCCESS;\n}",
        "output": "0",
        "idx": 2979
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\nstatic void __skb_complete_tx_timestamp(struct sk_buff *skb,\n\t\t\t\t\tstruct sock *sk,\n\t\t\t\t\tint tstype,\n\t\t\t\t\tbool opt_stats)\n{\n\tstruct sock_exterr_skb *serr;\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(struct sock_exterr_skb) > sizeof(skb->cb));\n\n\tserr = SKB_EXT_ERR(skb);\n\tmemset(serr, 0, sizeof(*serr));\n\tserr->ee.ee_errno = ENOMSG;\n\tserr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;\n\tserr->ee.ee_info = tstype;\n\tserr->opt_stats = opt_stats;\n\tserr->header.h4.iif = skb->dev ? skb->dev->ifindex : 0;\n\tif (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {\n\t\tserr->ee.ee_data = skb_shinfo(skb)->tskey;\n\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\tserr->ee.ee_data -= sk->sk_tskey;\n\t}\n\n\terr = sock_queue_err_skb(sk, skb);\n\n\tif (err)\n\t\tkfree_skb(skb);",
        "output": "0",
        "idx": 732
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "v3_keyid (gcry_mpi_t a, u32 *ki)\n{\n  byte *buffer, *p;\n  size_t nbytes;\n\n  if (gcry_mpi_print (GCRYMPI_FMT_USG, NULL, 0, &nbytes, a ))\n    BUG ();\n  /* fixme: allocate it on the stack */\n  buffer = xmalloc (nbytes);\n  if (gcry_mpi_print( GCRYMPI_FMT_USG, buffer, nbytes, NULL, a ))\n    BUG ();\n  if (nbytes < 8) /* oops */\n    ki[0] = ki[1] = 0;\n  else\n    {\n      p = buffer + nbytes - 8;\n      ki[0] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];\n      p += 4;\n      ki[1] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];\n    }\n  xfree (buffer);\n  return ki[1];\n}",
        "output": "1",
        "idx": 969
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Avahi::addService(int, int, const QString &name, const QString &type, const QString &domain, uint)\n{\n    if (isLocalDomain(domain) && !services.contains(name)) {\n        AvahiService *srv=new AvahiService(name, type, domain);\n        services.insert(name, srv);\n        connect(srv, SIGNAL(serviceResolved(QString)), this, SIGNAL(serviceAdded(QString)));\n    }\n}",
        "output": "1",
        "idx": 2012
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int getClientTypeByName(char *name) {\n    if (!strcasecmp(name,\"normal\")) return CLIENT_TYPE_NORMAL;\n    else if (!strcasecmp(name,\"slave\")) return CLIENT_TYPE_SLAVE;\n    else if (!strcasecmp(name,\"pubsub\")) return CLIENT_TYPE_PUBSUB;\n    else if (!strcasecmp(name,\"master\")) return CLIENT_TYPE_MASTER;\n    else return -1;\n}",
        "output": "0",
        "idx": 313
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void naludmx_add_param_nalu(GF_List *param_list, GF_NALUFFParam *sl, u8 nal_type)\n{\n\tGF_NALUFFParamArray *pa = NULL;\n\tu32 i, count;\n\tcount = gf_list_count(param_list);\n\tfor (i=0; i<count; i++) {\n\t\tpa = gf_list_get(param_list, i);\n\t\tif (pa->type == nal_type) break;\n\t\tpa = NULL;\n\t}\n\tif (!pa) {\n\t\tGF_SAFEALLOC(pa, GF_NALUFFParamArray);\n\t\tif (!pa) return;\n\n\t\tpa->array_completeness = 1;\n\t\tpa->type = nal_type;\n\t\tpa->nalus = gf_list_new();\n\t\tgf_list_add(param_list, pa);\n\t}\n\tgf_list_add(pa->nalus, sl);\n}",
        "output": "0",
        "idx": 1524
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static apr_status_t unschedule_slow_tasks(h2_mplx *m) \n{\n    h2_stream *stream;\n    int n;\n    \n    /* Try to get rid of streams that occupy workers. Look for safe requests\n     * that are repeatable. If none found, fail the connection.\n     */\n    n = (m->tasks_active - m->limit_active - (int)h2_ihash_count(m->sredo));\n    while (n > 0 && (stream = get_latest_repeatable_unsubmitted_stream(m))) {\n        ap_log_cerror(APLOG_MARK, APLOG_TRACE2, 0, m->c, \n                      \"h2_mplx(%s): unschedule, resetting task for redo later\",\n                      stream->task->id);\n        h2_task_rst(stream->task, H2_ERR_CANCEL);\n        h2_ihash_add(m->sredo, stream);\n        --n;\n    }\n    \n    if ((m->tasks_active - h2_ihash_count(m->sredo)) > m->limit_active) {\n        stream = get_timed_out_busy_stream(m);\n        if (stream) {\n            /* Too many busy workers, unable to cancel enough streams\n             * and with a busy, timed out stream, we tell the client\n             * to go away... */\n            return APR_TIMEUP;\n        }\n    }\n    return APR_SUCCESS;\n}",
        "output": "1",
        "idx": 2753
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int f2fs_read_data_page(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret = -EAGAIN;\n\n\ttrace_f2fs_readpage(page, DATA);\n\n\t/* If the file has inline data, try to read it directly */\n\tif (f2fs_has_inline_data(inode))\n\t\tret = f2fs_read_inline_data(inode, page);\n\tif (ret == -EAGAIN)\n\t\tret = f2fs_mpage_readpages(page->mapping, NULL, page, 1, false);\n\treturn ret;\n}",
        "output": "1",
        "idx": 1630
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tcmpt_destroy(jpc_enc_tcmpt_t *tcmpt)\n{\n\tjpc_enc_rlvl_t *rlvl;\n\tuint_fast16_t rlvlno;\n\n\tif (tcmpt->rlvls) {\n\t\tfor (rlvlno = 0, rlvl = tcmpt->rlvls; rlvlno < tcmpt->numrlvls;\n\t\t  ++rlvlno, ++rlvl) {\n\t\t\trlvl_destroy(rlvl);\n\t\t}\n\t\tjas_free(tcmpt->rlvls);\n\t}\n\n\tif (tcmpt->data) {\n\t\tjas_seq2d_destroy(tcmpt->data);\n\t}\n\tif (tcmpt->tsfb) {\n\t\tjpc_tsfb_destroy(tcmpt->tsfb);\n\t}\n}",
        "output": "1",
        "idx": 1473
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kvm_cpu_vmxon(u64 addr)\n{\n\tcr4_set_bits(X86_CR4_VMXE);\n\tintel_pt_handle_vmx(1);\n\n\tasm volatile (ASM_VMX_VMXON_RAX\n\t\t\t: : \"a\"(&addr), \"m\"(addr)\n\t\t\t: \"memory\", \"cc\");\n}",
        "output": "0",
        "idx": 1013
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "zzip_mem_entry_free(ZZIP_MEM_ENTRY * _zzip_restrict item)\n{\n    if (item)\n    {\n\t/* *INDENT-OFF* */\n\tif (item->zz_ext[0]) free (item->zz_ext[0]);\n\tif (item->zz_ext[1]) free (item->zz_ext[1]);\n\tif (item->zz_ext[2]) free (item->zz_ext[2]);\n\tif (item->zz_comment) free (item->zz_comment);\n\tif (item->zz_name) free (item->zz_name);\n\tfree (item);\n\t/* *INDENT-ON* */\n    }\n}",
        "output": "0",
        "idx": 1485
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "concat_opt_exact_str(OptStr* to, UChar* s, UChar* end, OnigEncoding enc)\n{\n  int i, j, len;\n  UChar *p;\n\n  for (i = to->len, p = s; p < end && i < OPT_EXACT_MAXLEN; ) {\n    len = enclen(enc, p);\n    if (i + len > OPT_EXACT_MAXLEN) break;\n    for (j = 0; j < len && p < end; j++)\n      to->s[i++] = *p++;\n  }\n\n  to->len = i;\n\n  if (p >= end)\n    to->reach_end = 1;\n}",
        "output": "1",
        "idx": 2022
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_user_file (const char *filename,\n                 uid_t       user,\n                 gssize      max_file_size,\n                 gboolean    relax_group,\n                 gboolean    relax_other)\n{\n        struct stat fileinfo;\n\n        if (max_file_size < 0) {\n                max_file_size = G_MAXSIZE;\n        }\n\n        /* Exists/Readable? */\n        if (stat (filename, &fileinfo) < 0) {\n                return FALSE;\n        }\n\n        /* Is a regular file */\n        if (G_UNLIKELY (!S_ISREG (fileinfo.st_mode))) {\n                return FALSE;\n        }\n\n        /* Owned by user? */\n        if (G_UNLIKELY (fileinfo.st_uid != user)) {\n                return FALSE;\n        }\n\n        /* Group not writable or relax_group? */\n        if (G_UNLIKELY ((fileinfo.st_mode & S_IWGRP) == S_IWGRP && !relax_group)) {\n                return FALSE;\n        }\n\n        /* Other not writable or relax_other? */\n        if (G_UNLIKELY ((fileinfo.st_mode & S_IWOTH) == S_IWOTH && !relax_other)) {\n                return FALSE;\n        }\n\n        /* Size is kosher? */\n        if (G_UNLIKELY (fileinfo.st_size > max_file_size)) {\n                return FALSE;\n        }\n\n        return TRUE;\n}",
        "output": "1",
        "idx": 2507
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int hns_get_gid_index(struct hns_roce_dev *hr_dev, u8 port, int gid_index)\n{\n\treturn gid_index * hr_dev->caps.num_ports + port;\n}",
        "output": "0",
        "idx": 3256
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  CHARSET_INFO *sort_charset(void) const { return &my_charset_bin; }",
        "output": "0",
        "idx": 2179
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t regulator_opmode_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct regulator_dev *rdev = dev_get_drvdata(dev);\n\n\treturn regulator_print_opmode(buf, _regulator_get_mode(rdev));\n}",
        "output": "0",
        "idx": 1700
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void\nmono_reflection_destroy_dynamic_method (MonoReflectionDynamicMethod *mb)\n{\n\tg_assert (mb);\n\n\tif (mb->mhandle)\n\t\tmono_runtime_free_method (\n\t\t\tmono_object_get_domain ((MonoObject*)mb), mb->mhandle);",
        "output": "1",
        "idx": 689
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\nstatic void kvm_mmu_notifier_release(struct mmu_notifier *mn,\n\t\t\t\t     struct mm_struct *mm)\n{\n\tstruct kvm *kvm = mmu_notifier_to_kvm(mn);\n\tint idx;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tkvm_arch_flush_shadow_all(kvm);\n\tsrcu_read_unlock(&kvm->srcu, idx);",
        "output": "1",
        "idx": 1671
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *umm_realloc( void *ptr, size_t size ) {\n  void *ret;\n\n  ptr = GET_UNPOISONED(ptr);\n\n  /* check poison of each blocks, if poisoning is enabled */\n  if (!CHECK_POISON_ALL_BLOCKS()) {\n    return NULL;\n  }\n\n  /* check full integrity of the heap, if this check is enabled */\n  if (!INTEGRITY_CHECK()) {\n    return NULL;\n  }\n\n  size += POISON_SIZE(size);\n  ret = _umm_realloc( ptr, size );\n\n  ret = GET_POISONED(ret, size);\n\n  umm_account_free_blocks_cnt();\n\n  return ret;\n}",
        "output": "1",
        "idx": 1718
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "HttpIntegrationTest::makeRawHttpConnection(Network::ClientConnectionPtr&& conn) {\n  std::shared_ptr<Upstream::MockClusterInfo> cluster{new NiceMock<Upstream::MockClusterInfo>()};\n  cluster->max_response_headers_count_ = 200;\n  cluster->http2_options_.set_allow_connect(true);\n  cluster->http2_options_.set_allow_metadata(true);\n  cluster->http1_settings_.enable_trailers_ = true;\n  Upstream::HostDescriptionConstSharedPtr host_description{Upstream::makeTestHostDescription(\n      cluster, fmt::format(\"tcp://{}:80\", Network::Test::getLoopbackAddressUrlString(version_)))};\n  return std::make_unique<IntegrationCodecClient>(*dispatcher_, std::move(conn), host_description,\n                                                  downstream_protocol_);\n}",
        "output": "1",
        "idx": 3477
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cancel_refresh(dns_zone_t *zone) {\n\tconst char me[] = \"cancel_refresh\";\n\tisc_time_t now;\n\n\t/*\n\t * 'zone' locked by caller.\n\t */\n\n\tREQUIRE(DNS_ZONE_VALID(zone));\n\tREQUIRE(LOCKED_ZONE(zone));\n\n\tENTER;\n\n\tDNS_ZONE_CLRFLAG(zone, DNS_ZONEFLG_REFRESH);\n\tTIME_NOW(&now);\n\tzone_settimer(zone, &now);\n}",
        "output": "0",
        "idx": 2877
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_change_type(struct nameidata *nd, int flag)\n{\n\tstruct vfsmount *m, *mnt = nd->mnt;\n\tint recurse = flag & MS_REC;\n\tint type = flag & ~MS_REC;\n\n\tif (nd->dentry != nd->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\tdown_write(&namespace_sem);\n\tspin_lock(&vfsmount_lock);\n\tfor (m = mnt; m; m = (recurse ? next_mnt(m, mnt) : NULL))\n\t\tchange_mnt_propagation(m, type);\n\tspin_unlock(&vfsmount_lock);\n\tup_write(&namespace_sem);\n\treturn 0;\n}",
        "output": "1",
        "idx": 2628
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static zend_bool php_auto_globals_create_get(const char *name, uint name_len TSRMLS_DC)\n{\n\tzval *vars;\n\n\tif (PG(variables_order) && (strchr(PG(variables_order),'G') || strchr(PG(variables_order),'g'))) {\n\t\tsapi_module.treat_data(PARSE_GET, NULL, NULL TSRMLS_CC);\n\t\tvars = PG(http_globals)[TRACK_VARS_GET];\n\t} else {\n\t\tALLOC_ZVAL(vars);\n\t\tarray_init(vars);\n\t\tINIT_PZVAL(vars);\n\t\tif (PG(http_globals)[TRACK_VARS_GET]) {\n\t\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_GET]);\n\t\t}\n\t\tPG(http_globals)[TRACK_VARS_GET] = vars;\n\t}\n\n\tzend_hash_update(&EG(symbol_table), name, name_len + 1, &vars, sizeof(zval *), NULL);\n\tZ_ADDREF_P(vars);\n\t\n\treturn 0; /* don't rearm */\n}",
        "output": "1",
        "idx": 2157
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ecma_op_internal_buffer_append (ecma_collection_t *container_p, /**< internal container pointer */\n                                ecma_value_t key_arg, /**< key argument */\n                                ecma_value_t value_arg, /**< value argument */\n                                lit_magic_string_id_t lit_id) /**< class id */\n{\n  JERRY_ASSERT (container_p != NULL);\n\n  ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));\n\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (value_arg));\n  }\n\n  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1);\n} /* ecma_op_internal_buffer_append */",
        "output": "1",
        "idx": 412
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline ulong encode_twos_comp(long n, int prec)\n{\n\tulong result;\n\tassert(prec >= 2);\n\tjas_eprintf(\"warning: support for signed data is untested\\n\");\n\t// NOTE: Is this correct?\n\tif (n < 0) {\n\t\tresult = -n;\n\t\tresult = (result ^ 0xffffffffUL) + 1;\n\t\tresult &= (1 << prec) - 1;\n\t} else {\n\t\tresult = n;\n\t}\n\treturn result;\n}",
        "output": "1",
        "idx": 3067
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SIZED_STRING* yr_object_get_string(\n    YR_OBJECT* object,\n    const char* field,\n    ...)\n{\n  YR_OBJECT* string_obj;\n\n  va_list args;\n  va_start(args, field);\n\n  if (field != NULL)\n    string_obj = _yr_object_lookup(object, 0, field, args);\n  else\n    string_obj = object;\n\n  va_end(args);\n\n  if (string_obj == NULL)\n    return NULL;\n\n  assertf(string_obj->type == OBJECT_TYPE_STRING,\n          \"type of \\\"%s\\\" is not string\\n\", field);\n\n  return ((YR_OBJECT_STRING*) string_obj)->value;\n}",
        "output": "0",
        "idx": 2956
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Http2Session::HandlePingFrame(const nghttp2_frame* frame) {\n  Isolate* isolate = env()->isolate();\n  HandleScope scope(isolate);\n  Local<Context> context = env()->context();\n  Context::Scope context_scope(context);\n  Local<Value> arg;\n  bool ack = frame->hd.flags & NGHTTP2_FLAG_ACK;\n  if (ack) {\n    BaseObjectPtr<Http2Ping> ping = PopPing();\n\n    if (!ping) {\n      // PING Ack is unsolicited. Treat as a connection error. The HTTP/2\n      // spec does not require this, but there is no legitimate reason to\n      // receive an unsolicited PING ack on a connection. Either the peer\n      // is buggy or malicious, and we're not going to tolerate such\n      // nonsense.\n      arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);\n      MakeCallback(env()->http2session_on_error_function(), 1, &arg);\n      return;\n    }\n\n    ping->Done(true, frame->ping.opaque_data);\n    return;\n  }\n\n  if (!(js_fields_->bitfield & (1 << kSessionHasPingListeners))) return;\n  // Notify the session that a ping occurred\n  arg = Buffer::Copy(\n      env(),\n      reinterpret_cast<const char*>(frame->ping.opaque_data),\n      8).ToLocalChecked();\n  MakeCallback(env()->http2session_on_ping_function(), 1, &arg);\n}",
        "output": "0",
        "idx": 3539
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void add_metadata(RCore *r, RBinReloc *reloc, ut64 addr, int mode) {\n\tRBinFile * binfile = r->bin->cur;\n\tRBinObject *binobj = binfile ? binfile->o: NULL;\n\tRBinInfo *info = binobj ? binobj->info: NULL;\n\n\tint cdsz = info? (info->bits == 64? 8: info->bits == 32? 4: info->bits == 16 ? 4: 0): 0;\n\tif (cdsz == 0) {\n\t\treturn;\n\t}\n\n\tRIOMap *map = r_io_map_get (r->io, addr);\n\tif (!map || map ->perm & R_PERM_X) {\n\t\treturn;\n\t}\n\tif (IS_MODE_SET (mode)) {\n\t\tr_meta_add (r->anal, R_META_TYPE_DATA, reloc->vaddr, reloc->vaddr + cdsz, NULL);\n\t} else if (IS_MODE_RAD (mode)) {\n\t\tr_cons_printf (\"Cd %d @ 0x%08\" PFMT64x \"\\n\", cdsz, addr);\n\t}\n}",
        "output": "0",
        "idx": 2430
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SetXtermOSC(i, s)\nint i;\nchar *s;\n{\n  static char *oscs[][2] = {\n    { WT_FLAG \";\", \"screen\" }, /* set window title */\n    { \"20;\", \"\" },      /* background */\n    { \"39;\", \"black\" }, /* default foreground (black?) */\n    { \"49;\", \"white\" }  /* default background (white?) */\n  };\n\n  ASSERT(display);\n  if (!D_CXT)\n    return;\n  if (!s)\n    s = \"\";\n  if (!D_xtermosc[i] && !*s)\n    return;\n  if (i == 0 && !D_xtermosc[0])\n    AddStr(\"\\033[22;\" WT_FLAG \"t\");\t/* stack titles (xterm patch #251) */\n  if (!*s)\n    s = oscs[i][1];\n  D_xtermosc[i] = 1;\n  AddStr(\"\\033]\");\n  AddStr(oscs[i][0]);\n  AddStr(s);\n  AddChar(7);\n}",
        "output": "1",
        "idx": 2053
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "LJ_NOINLINE void lj_err_run(lua_State *L)\n{\n  ptrdiff_t ef = finderrfunc(L);\n  if (ef) {\n    TValue *errfunc = restorestack(L, ef);\n    TValue *top = L->top;\n    lj_trace_abort(G(L));\n    if (!tvisfunc(errfunc) || L->status == LUA_ERRERR) {\n      setstrV(L, top-1, lj_err_str(L, LJ_ERR_ERRERR));\n      lj_err_throw(L, LUA_ERRERR);\n    }\n    L->status = LUA_ERRERR;\n    copyTV(L, top, top-1);\n    copyTV(L, top-1, errfunc);\n    L->top = top+1;\n    lj_vm_call(L, top, 1+1);  /* Stack: |errfunc|msg| -> |msg| */\n  }\n  lj_err_throw(L, LUA_ERRRUN);\n}",
        "output": "1",
        "idx": 89
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\tSilenceMessage(const std::string& mask, const std::string& flags)\n\t\t: ClientProtocol::Message(\"SILENCE\")\n\t{\n\t\tPushParam(mask);\n\t\tPushParamRef(flags);\n\t}",
        "output": "1",
        "idx": 2741
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jas_iccgetuint32(jas_stream_t *in, jas_iccuint32_t *val)\n{\n\tulonglong tmp;\n\tif (jas_iccgetuint(in, 4, &tmp))\n\t\treturn -1;\n\t*val = tmp;\n\treturn 0;\n}",
        "output": "1",
        "idx": 2234
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long dsgetn(DviContext *dvi, size_t n)\n{\n\tlong\tval;\n\n\tif(NEEDBYTES(dvi, n) && get_bytes(dvi, n) == -1)\n\t\treturn -1;\n\tval = msgetn(dvi->buffer.data + dvi->buffer.pos, n);\n\tdvi->buffer.pos += n;\n\treturn val;\n}",
        "output": "0",
        "idx": 3718
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ext4_clear_inode(struct inode *inode)\n{\n\text4_discard_preallocations(inode);\n\tif (EXT4_JOURNAL(inode))\n\t\tjbd2_journal_release_jbd_inode(EXT4_SB(inode->i_sb)->s_journal,\n\t\t\t\t       &EXT4_I(inode)->jinode);\n}",
        "output": "0",
        "idx": 2214
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ASN1_STRING* X509_NAME::GetEntry(int i)\n{\n    if (i < 0 || i >= int(sz_))\n        return 0;\n\n    if (entry_.data)\n        ysArrayDelete(entry_.data);\n    entry_.data = NEW_YS byte[sz_];       // max size;\n\n    memcpy(entry_.data, &name_[i], sz_ - i);\n    if (entry_.data[sz_ -i - 1]) {\n        entry_.data[sz_ - i] = 0;\n        entry_.length = int(sz_) - i;\n    }\n    else\n        entry_.length = int(sz_) - i - 1;\n    entry_.type = 0;\n\n    return &entry_;\n}",
        "output": "1",
        "idx": 1782
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char* RtmpProtocol::handle_C2(const char *data, size_t len) {\n    if (len < C1_HANDSHARK_SIZE) {\n        //need more data!\n        return nullptr;\n    }\n    _next_step_func = [this](const char *data, size_t len) {\n        return handle_rtmp(data, len);\n    };\n\n    //\u63e1\u624b\u7ed3\u675f\uff0c\u8fdb\u5165\u547d\u4ee4\u6a21\u5f0f\n    return handle_rtmp(data + C1_HANDSHARK_SIZE, len - C1_HANDSHARK_SIZE);\n}",
        "output": "0",
        "idx": 207
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *vm_args) {\n\tUDATA requestedVersion = (UDATA)((JDK1_1InitArgs *)vm_args)->version;\n\t\n\tswitch (requestedVersion) {\n\tcase JNI_VERSION_1_2:\n\tcase JNI_VERSION_1_4:\n\tcase JNI_VERSION_1_6:\n\tcase JNI_VERSION_1_8:\n\tcase JNI_VERSION_9:\n\tcase JNI_VERSION_10:\n\t\treturn JNI_OK;\n\t}\n\t\n\treturn JNI_EVERSION;\t\n}",
        "output": "0",
        "idx": 3358
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ip_mc_check_igmp(struct sk_buff *skb)\n{\n\tint ret = ip_mc_check_iphdr(skb);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ip_hdr(skb)->protocol != IPPROTO_IGMP)\n\t\treturn -ENOMSG;\n\n\tret = ip_mc_check_igmp_csum(skb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ip_mc_check_igmp_msg(skb);\n}",
        "output": "0",
        "idx": 2038
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sas_destruct_devices(struct work_struct *work)\n{\n\tstruct domain_device *dev, *n;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\n\tclear_bit(DISCE_DESTRUCT, &port->disc.pending);\n\n\tlist_for_each_entry_safe(dev, n, &port->destroy_list, disco_list_node) {\n\t\tlist_del_init(&dev->disco_list_node);\n\n\t\tsas_remove_children(&dev->rphy->dev);\n\t\tsas_rphy_delete(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t}\n}",
        "output": "1",
        "idx": 1904
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void HeaderMapImplGetByteSize(benchmark::State& state) {\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  uint64_t size = 0;\n  for (auto _ : state) {\n    size += headers.byteSize();\n  }\n  benchmark::DoNotOptimize(size);\n}",
        "output": "1",
        "idx": 215
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int encode_getattr_two(struct xdr_stream *xdr, uint32_t bm0, uint32_t bm1)\n{\n        __be32 *p;\n\n        RESERVE_SPACE(16);\n        WRITE32(OP_GETATTR);\n        WRITE32(2);\n        WRITE32(bm0);\n        WRITE32(bm1);\n        return 0;\n}",
        "output": "0",
        "idx": 74
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cp2112_gpio_get_all(struct gpio_chip *chip)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,\n\t\t\t\t CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_GET_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO values: %d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto exit;\n\t}\n\n\tret = buf[1];\n\nexit:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn ret;\n}",
        "output": "1",
        "idx": 3526
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int RemoveUnknownSections(void)\r\n{\r\n    int a;\r\n    int Modified = FALSE;\r\n    for (a=0;a<SectionsRead-1;){\r\n        switch(Sections[a].Type){\r\n            case  M_SOF0:\r\n            case  M_SOF1:\r\n            case  M_SOF2:\r\n            case  M_SOF3:\r\n            case  M_SOF5:\r\n            case  M_SOF6:\r\n            case  M_SOF7:\r\n            case  M_SOF9:\r\n            case  M_SOF10:\r\n            case  M_SOF11:\r\n            case  M_SOF13:\r\n            case  M_SOF14:\r\n            case  M_SOF15:\r\n            case  M_SOI:\r\n            case  M_EOI:\r\n            case  M_SOS:\r\n            case  M_JFIF:\r\n            case  M_EXIF:\r\n            case  M_XMP:\r\n            case  M_COM:\r\n            case  M_DQT:\r\n            case  M_DHT:\r\n            case  M_DRI:\r\n            case  M_IPTC:\r\n                // keep.\r\n                a++;\r\n                break;\r\n            default:\r\n                // Unknown.  Delete.\r\n                free (Sections[a].Data);\r\n                // Move succeding sections back by one to close space in array.\r\n                memmove(Sections+a, Sections+a+1, sizeof(Section_t) * (SectionsRead-a));\r\n                SectionsRead -= 1;\r\n                Modified = TRUE;\r\n        }\r\n    }\r\n    return Modified;\r\n}\r",
        "output": "1",
        "idx": 1910
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cgit_print_http_headers(void)\n{\n\tif (ctx.env.no_http && !strcmp(ctx.env.no_http, \"1\"))\n\t\treturn;\n\n\tif (ctx.page.status)\n\t\thtmlf(\"Status: %d %s\\n\", ctx.page.status, ctx.page.statusmsg);\n\tif (ctx.page.mimetype && ctx.page.charset)\n\t\thtmlf(\"Content-Type: %s; charset=%s\\n\", ctx.page.mimetype,\n\t\t      ctx.page.charset);\n\telse if (ctx.page.mimetype)\n\t\thtmlf(\"Content-Type: %s\\n\", ctx.page.mimetype);\n\tif (ctx.page.size)\n\t\thtmlf(\"Content-Length: %zd\\n\", ctx.page.size);\n\tif (ctx.page.filename)\n\t\thtmlf(\"Content-Disposition: inline; filename=\\\"%s\\\"\\n\",\n\t\t      ctx.page.filename);\n\tif (!ctx.env.authenticated)\n\t\thtml(\"Cache-Control: no-cache, no-store\\n\");\n\thtmlf(\"Last-Modified: %s\\n\", http_date(ctx.page.modified));\n\thtmlf(\"Expires: %s\\n\", http_date(ctx.page.expires));\n\tif (ctx.page.etag)\n\t\thtmlf(\"ETag: \\\"%s\\\"\\n\", ctx.page.etag);\n\thtml(\"\\n\");\n\tif (ctx.env.request_method && !strcmp(ctx.env.request_method, \"HEAD\"))\n\t\texit(0);\n}",
        "output": "1",
        "idx": 2324
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int usb_device_init(USBDevice *dev)\n{\n    USBDeviceClass *klass = USB_DEVICE_GET_CLASS(dev);\n    if (klass->init) {\n        return klass->init(dev);\n    }\n    return 0;\n}",
        "output": "0",
        "idx": 3028
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int input_init(void)\n{\n\tGKeyFile *config;\n\tGError *err = NULL;\n\n\tconfig = load_config_file(CONFIGDIR \"/input.conf\");\n\tif (config) {\n\t\tint idle_timeout;\n\t\tgboolean uhid_enabled;\n\n\t\tidle_timeout = g_key_file_get_integer(config, \"General\",\n\t\t\t\t\t\t\t\"IdleTimeout\", &err);\n\t\tif (!err) {\n\t\t\tDBG(\"input.conf: IdleTimeout=%d\", idle_timeout);\n\t\t\tinput_set_idle_timeout(idle_timeout * 60);\n\t\t} else\n\t\t\tg_clear_error(&err);\n\n\t\tuhid_enabled = g_key_file_get_boolean(config, \"General\",\n\t\t\t\t\t\t\t\"UserspaceHID\", &err);\n\t\tif (!err) {\n\t\t\tDBG(\"input.conf: UserspaceHID=%s\", uhid_enabled ?\n\t\t\t\t\t\t\t\"true\" : \"false\");\n\t\t\tinput_enable_userspace_hid(uhid_enabled);\n\t\t} else\n\t\t\tg_clear_error(&err);\n\t}\n\n\tbtd_profile_register(&input_profile);\n\n\tif (config)\n\t\tg_key_file_free(config);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1661
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct anon_vma *page_get_anon_vma(struct page *page)\n{\n\tstruct anon_vma *anon_vma = NULL;\n\tunsigned long anon_mapping;\n\n\trcu_read_lock();\n\tanon_mapping = (unsigned long) ACCESS_ONCE(page->mapping);\n\tif ((anon_mapping & PAGE_MAPPING_FLAGS) != PAGE_MAPPING_ANON)\n\t\tgoto out;\n\tif (!page_mapped(page))\n\t\tgoto out;\n\n\tanon_vma = (struct anon_vma *) (anon_mapping - PAGE_MAPPING_ANON);\n\tif (!atomic_inc_not_zero(&anon_vma->refcount)) {\n\t\tanon_vma = NULL;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If this page is still mapped, then its anon_vma cannot have been\n\t * freed.  But if it has been unmapped, we have no security against the\n\t * anon_vma structure being freed and reused (for another anon_vma:\n\t * SLAB_DESTROY_BY_RCU guarantees that - so the atomic_inc_not_zero()\n\t * above cannot corrupt).\n\t */\n\tif (!page_mapped(page)) {\n\t\tput_anon_vma(anon_vma);\n\t\tanon_vma = NULL;\n\t}\nout:\n\trcu_read_unlock();\n\n\treturn anon_vma;\n}",
        "output": "0",
        "idx": 67
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dequeue_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tupdate_rq_clock(rq);\n\tsched_info_dequeued(p);\n\tp->sched_class->dequeue_task(rq, p, flags);\n\tp->se.on_rq = 0;\n}",
        "output": "0",
        "idx": 2379
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int __init early_fixup_exception(unsigned long *ip)\n{\n\tconst struct exception_table_entry *fixup;\n\tunsigned long new_ip;\n\n\tfixup = search_exception_tables(*ip);\n\tif (fixup) {\n\t\tnew_ip = ex_fixup_addr(fixup);\n\n\t\tif (fixup->fixup - fixup->insn >= 0x7ffffff0 - 4) {\n\t\t\t/* uaccess handling not supported during early boot */\n\t\t\treturn 0;\n\t\t}\n\n\t\t*ip = new_ip;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 434
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int wc_MakeCert_ex(Cert* cert, byte* derBuffer, word32 derSz, int keyType,\n                   void* key, WC_RNG* rng)\n{\n    RsaKey*      rsaKey = NULL;\n    DsaKey*      dsaKey = NULL;\n    ecc_key*     eccKey = NULL;\n    ed25519_key* ed25519Key = NULL;\n    ed448_key*   ed448Key = NULL;\n\n    if (keyType == RSA_TYPE)\n        rsaKey = (RsaKey*)key;\n    else if (keyType == DSA_TYPE)\n        dsaKey = (DsaKey*)key;\n    else if (keyType == ECC_TYPE)\n        eccKey = (ecc_key*)key;\n    else if (keyType == ED25519_TYPE)\n        ed25519Key = (ed25519_key*)key;\n    else if (keyType == ED448_TYPE)\n        ed448Key = (ed448_key*)key;\n\n    return MakeAnyCert(cert, derBuffer, derSz, rsaKey, eccKey, rng, dsaKey,\n                       NULL, 0, ed25519Key, ed448Key);\n}",
        "output": "0",
        "idx": 3501
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int alarm_timer_nsleep(const clockid_t which_clock, int flags,\n\t\t\t      const struct timespec64 *tsreq)\n{\n\tenum  alarmtimer_type type = clock2alarm(which_clock);\n\tstruct restart_block *restart = &current->restart_block;\n\tstruct alarm alarm;\n\tktime_t exp;\n\tint ret = 0;\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -ENOTSUPP;\n\n\tif (flags & ~TIMER_ABSTIME)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_WAKE_ALARM))\n\t\treturn -EPERM;\n\n\talarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);\n\n\texp = timespec64_to_ktime(*tsreq);\n\t/* Convert (if necessary) to absolute time */\n\tif (flags != TIMER_ABSTIME) {\n\t\tktime_t now = alarm_bases[type].gettime();\n\t\texp = ktime_add(now, exp);\n\t}\n\n\tret = alarmtimer_do_nsleep(&alarm, exp, type);\n\tif (ret != -ERESTART_RESTARTBLOCK)\n\t\treturn ret;\n\n\t/* abs timers don't set remaining time or restart */\n\tif (flags == TIMER_ABSTIME)\n\t\treturn -ERESTARTNOHAND;\n\n\trestart->fn = alarm_timer_nsleep_restart;\n\trestart->nanosleep.clockid = type;\n\trestart->nanosleep.expires = exp;\n\treturn ret;\n}",
        "output": "1",
        "idx": 317
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long dd_get_item_size(struct dump_dir *dd, const char *name)\n{\n    if (!str_is_correct_filename(name))\n        error_msg_and_die(\"Cannot get item size. '%s' is not a valid file name\", name);\n\n    long size = -1;\n    char *iname = concat_path_file(dd->dd_dirname, name);\n    struct stat statbuf;\n\n    if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))\n        size = statbuf.st_size;\n    else\n    {\n        if (errno == ENOENT)\n            size = 0;\n        else\n            perror_msg(\"Can't get size of file '%s'\", iname);\n    }\n\n    free(iname);\n\n    return size;\n}",
        "output": "1",
        "idx": 2714
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int reuc_isrch(const void *key, const void *array_member)\n{\n\tconst git_index_reuc_entry *reuc = array_member;\n\n\treturn strcasecmp(key, reuc->path);\n}",
        "output": "0",
        "idx": 3297
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_lnums(int do_curwin)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif ((do_curwin || wp != curwin) && wp->w_buffer == curbuf)\n\t{\n\t    // save the original cursor position and topline\n\t    wp->w_save_cursor.w_cursor_save = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_save = wp->w_topline;\n\n\t    if (wp->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\twp->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    if (wp->w_topline > curbuf->b_ml.ml_line_count)\n\t\twp->w_topline = curbuf->b_ml.ml_line_count;\n\n\t    // save the corrected cursor position and topline\n\t    wp->w_save_cursor.w_cursor_corr = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_corr = wp->w_topline;\n\t}\n}",
        "output": "1",
        "idx": 2942
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int send_solid_rect(VncState *vs)\n{\n    size_t bytes;\n\n    vnc_write_u8(vs, VNC_TIGHT_FILL << 4); /* no flushing, no filter */\n\n    if (vs->tight.pixel24) {\n        tight_pack24(vs, vs->tight.tight.buffer, 1, &vs->tight.tight.offset);\n        bytes = 3;\n    } else {\n        bytes = vs->clientds.pf.bytes_per_pixel;\n    }\n\n    vnc_write(vs, vs->tight.tight.buffer, bytes);\n    return 1;\n}",
        "output": "1",
        "idx": 343
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ttm_dma_tt_init(struct ttm_dma_tt *ttm_dma, struct ttm_buffer_object *bo,\n\t\t    uint32_t page_flags)\n{\n\tstruct ttm_tt *ttm = &ttm_dma->ttm;\n\n\tttm_tt_init_fields(ttm, bo, page_flags);\n\n\tINIT_LIST_HEAD(&ttm_dma->pages_list);\n\tif (ttm_dma_tt_alloc_page_directory(ttm_dma)) {\n\t\tttm_tt_destroy(ttm);\n\t\tpr_err(\"Failed allocating page table\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 1903
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rq_attach_root(struct rq *rq, struct root_domain *rd)\n{\n\tstruct root_domain *old_rd = NULL;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&rq->lock, flags);\n\n\tif (rq->rd) {\n\t\told_rd = rq->rd;\n\n\t\tif (cpumask_test_cpu(rq->cpu, old_rd->online))\n\t\t\tset_rq_offline(rq);\n\n\t\tcpumask_clear_cpu(rq->cpu, old_rd->span);\n\n\t\t/*\n\t\t * If we dont want to free the old_rd yet then\n\t\t * set old_rd to NULL to skip the freeing later\n\t\t * in this function:\n\t\t */\n\t\tif (!atomic_dec_and_test(&old_rd->refcount))\n\t\t\told_rd = NULL;\n\t}\n\n\tatomic_inc(&rd->refcount);\n\trq->rd = rd;\n\n\tcpumask_set_cpu(rq->cpu, rd->span);\n\tif (cpumask_test_cpu(rq->cpu, cpu_active_mask))\n\t\tset_rq_online(rq);\n\n\traw_spin_unlock_irqrestore(&rq->lock, flags);\n\n\tif (old_rd)\n\t\tcall_rcu_sched(&old_rd->rcu, free_rootdomain);\n}",
        "output": "0",
        "idx": 2297
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void umd_cleanup(struct subprocess_info *info)\n{\n\tstruct umd_info *umd_info = info->data;\n\n\t/* cleanup if umh_setup() was successful but exec failed */\n\tif (info->retval) {\n\t\tfput(umd_info->pipe_to_umh);\n\t\tfput(umd_info->pipe_from_umh);\n\t\tput_pid(umd_info->tgid);\n\t\tumd_info->tgid = NULL;\n\t}\n}",
        "output": "1",
        "idx": 611
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void visit(LiteralString & /*ope*/) override { result_ = true; }",
        "output": "0",
        "idx": 2705
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t n_tty_chars_in_buffer(struct tty_struct *tty)\n{\n\tssize_t n;\n\n\tWARN_ONCE(1, \"%s is deprecated and scheduled for removal.\", __func__);\n\n\tdown_write(&tty->termios_rwsem);\n\tn = chars_in_buffer(tty);\n\tup_write(&tty->termios_rwsem);\n\treturn n;\n}",
        "output": "0",
        "idx": 590
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "smtp_proceed_quit(struct smtp_session *s, const char *args)\n{\n\tsmtp_reply(s, \"221 %s Bye\",\n\t    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));\n\tsmtp_enter_state(s, STATE_QUIT);\n}",
        "output": "0",
        "idx": 3210
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_matching_with_multibyte_ops (struct dfa *d, int s, int idx)\n{\n  int i;\n  int* rarray;\n\n  MALLOC(rarray, d->states[s].mbps.nelem);\n  for (i = 0; i < d->states[s].mbps.nelem; ++i)\n    {\n      position pos = d->states[s].mbps.elems[i];\n      switch(d->tokens[pos.index])\n        {\n        case ANYCHAR:\n          rarray[i] = match_anychar(d, s, pos, idx);\n          break;\n        case MBCSET:\n          rarray[i] = match_mb_charset(d, s, pos, idx);\n          break;\n        default:\n          break; /* cannot happen.  */\n        }\n    }\n  return rarray;\n}",
        "output": "1",
        "idx": 1875
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void device_links_driver_cleanup(struct device *dev)\n{\n\tstruct device_link *link, *ln;\n\n\tdevice_links_write_lock();\n\n\tlist_for_each_entry_safe(link, ln, &dev->links.consumers, s_node) {\n\t\tif (!(link->flags & DL_FLAG_MANAGED))\n\t\t\tcontinue;\n\n\t\tWARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);\n\t\tWARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);\n\n\t\t/*\n\t\t * autoremove the links between this @dev and its consumer\n\t\t * devices that are not active, i.e. where the link state\n\t\t * has moved to DL_STATE_SUPPLIER_UNBIND.\n\t\t */\n\t\tif (link->status == DL_STATE_SUPPLIER_UNBIND &&\n\t\t    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)\n\t\t\tdevice_link_drop_managed(link);\n\n\t\tWRITE_ONCE(link->status, DL_STATE_DORMANT);\n\t}\n\n\tlist_del_init(&dev->links.defer_hook);\n\t__device_links_no_driver(dev);\n\n\tdevice_links_write_unlock();\n}",
        "output": "0",
        "idx": 69
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gst_rmdemux_parse_indx_data (GstRMDemux * rmdemux, const guint8 * data,\n    int length)\n{\n  int i;\n  int n;\n  GstRMDemuxIndex *index;\n\n  /* The number of index records */\n  n = length / 14;\n\n  if (rmdemux->index_stream == NULL)\n    return;\n\n  /* don't parse the index a second time when operating pull-based and\n   * reaching the end of the file */\n  if (rmdemux->index_stream->index_length > 0) {\n    GST_DEBUG_OBJECT (rmdemux, \"Already have an index for this stream\");\n    return;\n  }\n\n  index = g_malloc (sizeof (GstRMDemuxIndex) * n);\n  rmdemux->index_stream->index = index;\n  rmdemux->index_stream->index_length = n;\n\n  for (i = 0; i < n; i++) {\n    index[i].timestamp = RMDEMUX_GUINT32_GET (data + 2) * GST_MSECOND;\n    index[i].offset = RMDEMUX_GUINT32_GET (data + 6);\n\n    GST_DEBUG_OBJECT (rmdemux, \"Index found for timestamp=%f (at offset=%x)\",\n        gst_guint64_to_gdouble (index[i].timestamp) / GST_SECOND,\n        index[i].offset);\n    data += 14;\n  }\n}",
        "output": "0",
        "idx": 318
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ass_shaper_set_base_direction(ASS_Shaper *shaper, FriBidiParType dir)\n{\n    shaper->base_direction = dir;\n}",
        "output": "0",
        "idx": 2572
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct clock_source *dce80_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "output": "1",
        "idx": 2197
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ossl_cipher_key_length(VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n\n    GetCipher(self, ctx);\n\n    return INT2NUM(EVP_CIPHER_CTX_key_length(ctx));\n}",
        "output": "0",
        "idx": 3353
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init dcbnl_init(void)\n{\n\tINIT_LIST_HEAD(&dcb_app_list);\n\n\trtnl_register(PF_UNSPEC, RTM_GETDCB, dcb_doit, NULL, NULL);\n\trtnl_register(PF_UNSPEC, RTM_SETDCB, dcb_doit, NULL, NULL);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2293
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int process_numeric_entity(const char **buf, unsigned *code_point)\n{\n\tlong code_l;\n\tint hexadecimal = (**buf == 'x' || **buf == 'X'); /* TODO: XML apparently disallows \"X\" */\n\tchar *endptr;\n\n\tif (hexadecimal && (**buf != '\\0'))\n\t\t(*buf)++;\n\t\t\t\n\t/* strtol allows whitespace and other stuff in the beginning\n\t\t* we're not interested */\n\tif ((hexadecimal && !isxdigit(**buf)) ||\n\t\t\t(!hexadecimal && !isdigit(**buf))) {\n\t\treturn FAILURE;\n\t}\n\n\tcode_l = strtol(*buf, &endptr, hexadecimal ? 16 : 10);\n\t/* we're guaranteed there were valid digits, so *endptr > buf */\n\t*buf = endptr;\n\n\tif (**buf != ';')\n\t\treturn FAILURE;\n\n\t/* many more are invalid, but that depends on whether it's HTML\n\t * (and which version) or XML. */\n\tif (code_l > 0x10FFFFL)\n\t\treturn FAILURE;\n\n\tif (code_point != NULL)\n\t\t*code_point = (unsigned)code_l;\n\n\treturn SUCCESS;\n}",
        "output": "1",
        "idx": 3410
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool safecmp(char *a, char *b)\n{\n  if(a && b)\n    return !strcmp(a, b);\n  else if(!a && !b)\n    return TRUE; /* match */\n  return FALSE; /* no match */\n}",
        "output": "1",
        "idx": 2318
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(void) gdImageGifAnimAdd(gdImagePtr im, FILE *outFile, int LocalCM,\n                                    int LeftOfs, int TopOfs, int Delay,\n                                    int Disposal, gdImagePtr previm)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) return;\n\tgdImageGifAnimAddCtx(im, out, LocalCM, LeftOfs, TopOfs, Delay, Disposal, previm);\n\tout->gd_free(out);\n}",
        "output": "0",
        "idx": 206
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sys_var *find_sys_var(THD *thd, const char *str, size_t length)\n{\n  return find_sys_var_ex(thd, str, length, false, false);\n}",
        "output": "0",
        "idx": 1252
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Item *Item_decimal::neg(THD *thd)\n{\n  my_decimal_neg(&decimal_value);\n  unsigned_flag= 0;\n  name= 0;\n  max_length= my_decimal_precision_to_length_no_truncation(\n                      decimal_value.intg + decimals, decimals, unsigned_flag);\n  return this;\n}",
        "output": "0",
        "idx": 467
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int JOIN::optimize()\n{\n  int res= 0;\n  create_explain_query_if_not_exists(thd->lex, thd->mem_root);\n  join_optimization_state init_state= optimization_state;\n  if (optimization_state == JOIN::OPTIMIZATION_PHASE_1_DONE)\n    res= optimize_stage2();\n  else\n  {\n    // to prevent double initialization on EXPLAIN\n    if (optimization_state != JOIN::NOT_OPTIMIZED)\n      return FALSE;\n    optimization_state= JOIN::OPTIMIZATION_IN_PROGRESS;\n    res= optimize_inner();\n  }\n  if (!with_two_phase_optimization ||\n      init_state == JOIN::OPTIMIZATION_PHASE_1_DONE)\n  {\n    if (!res && have_query_plan != QEP_DELETED)\n      res= build_explain();\n    optimization_state= JOIN::OPTIMIZATION_DONE;\n  }\n  return res;\n}",
        "output": "0",
        "idx": 3488
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_ruser(pam_handle_t *pamh, char *ruserbuf, size_t ruserbuflen)\n{\n\tconst void *ruser;\n\tstruct passwd *pwd;\n\n\tif (ruserbuf == NULL || ruserbuflen < 1)\n\t\treturn -2;\n\t/* Get the name of the source user. */\n\tif (pam_get_item(pamh, PAM_RUSER, &ruser) != PAM_SUCCESS) {\n\t\truser = NULL;\n\t}\n\tif ((ruser == NULL) || (strlen(ruser) == 0)) {\n\t\t/* Barring that, use the current RUID. */\n\t\tpwd = pam_modutil_getpwuid(pamh, getuid());\n\t\tif (pwd != NULL) {\n\t\t\truser = pwd->pw_name;\n\t\t}\n\t}\n\tif (ruser == NULL || strlen(ruser) >= ruserbuflen) {\n\t\t*ruserbuf = '\\0';\n\t\treturn -1;\n\t}\n\tstrcpy(ruserbuf, ruser);\n\treturn 0;\n}",
        "output": "1",
        "idx": 398
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API const char *r_str_sep(const char *base, const char *sep) {\n\tint i;\n\twhile (*base) {\n\t\tfor (i = 0; sep[i]; i++) {\n\t\t\tif (*base == sep[i]) {\n\t\t\t\treturn base;\n\t\t\t}\n\t\t}\n\t\tbase++;\n\t}\n\treturn NULL;\n}",
        "output": "0",
        "idx": 26
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int IntensityCompare(const void *x,const void *y)\n{\n  double\n    intensity;\n\n  PixelInfo\n    *color_1,\n    *color_2;\n\n  color_1=(PixelInfo *) x;\n  color_2=(PixelInfo *) y;\n  intensity=GetPixelInfoIntensity((const Image *) NULL,color_1)-\n    GetPixelInfoIntensity((const Image *) NULL,color_2);\n  return((int) intensity);\n}",
        "output": "1",
        "idx": 700
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ext4_mb_mark_free_simple(struct super_block *sb,\n\t\t\t\tvoid *buddy, ext4_grpblk_t first, ext4_grpblk_t len,\n\t\t\t\t\tstruct ext4_group_info *grp)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\text4_grpblk_t min;\n\text4_grpblk_t max;\n\text4_grpblk_t chunk;\n\tunsigned int border;\n\n\tBUG_ON(len > EXT4_CLUSTERS_PER_GROUP(sb));\n\n\tborder = 2 << sb->s_blocksize_bits;\n\n\twhile (len > 0) {\n\t\t/* find how many blocks can be covered since this position */\n\t\tmax = ffs(first | border) - 1;\n\n\t\t/* find how many blocks of power 2 we need to mark */\n\t\tmin = fls(len) - 1;\n\n\t\tif (max < min)\n\t\t\tmin = max;\n\t\tchunk = 1 << min;\n\n\t\t/* mark multiblock chunks only */\n\t\tgrp->bb_counters[min]++;\n\t\tif (min > 0)\n\t\t\tmb_clear_bit(first >> min,\n\t\t\t\t     buddy + sbi->s_mb_offsets[min]);\n\n\t\tlen -= chunk;\n\t\tfirst += chunk;\n\t}\n}",
        "output": "0",
        "idx": 855
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST(SnappyMessageCompressor, Overflow) {\n    checkOverflow(stdx::make_unique<SnappyMessageCompressor>());\n}",
        "output": "0",
        "idx": 2908
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ikev1_sub_print(netdissect_options *ndo,\n\t\tu_char np, const struct isakmp_gen *ext, const u_char *ep,\n\t\tuint32_t phase, uint32_t doi, uint32_t proto, int depth)\n{\n\tconst u_char *cp;\n\tint i;\n\tstruct isakmp_gen e;\n\n\tcp = (const u_char *)ext;\n\n\twhile (np) {\n\t\tND_TCHECK(*ext);\n\n\t\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\n\t\tND_TCHECK2(*ext, ntohs(e.len));\n\n\t\tdepth++;\n\t\tND_PRINT((ndo,\"\\n\"));\n\t\tfor (i = 0; i < depth; i++)\n\t\t\tND_PRINT((ndo,\"    \"));\n\t\tND_PRINT((ndo,\"(\"));\n\t\tcp = ike_sub0_print(ndo, np, ext, ep, phase, doi, proto, depth);\n\t\tND_PRINT((ndo,\")\"));\n\t\tdepth--;\n\n\t\tif (cp == NULL) {\n\t\t\t/* Zero-length subitem */\n\t\t\treturn NULL;\n\t\t}\n\n\t\tnp = e.np;\n\t\text = (const struct isakmp_gen *)cp;\n\t}\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(np)));\n\treturn NULL;\n}",
        "output": "1",
        "idx": 770
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& val = ctx->input(0);\n    int64 id = ctx->session_state()->GetNewId();\n    TensorStore::TensorAndKey tk{val, id, requested_device()};\n    OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));\n\n    Tensor* handle = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));\n    if (ctx->expected_output_dtype(0) == DT_RESOURCE) {\n      ResourceHandle resource_handle = MakeResourceHandle<Tensor>(\n          ctx, SessionState::kTensorHandleResourceTypeName,\n          tk.GetHandle(name()));\n      resource_handle.set_maybe_type_name(\n          SessionState::kTensorHandleResourceTypeName);\n      handle->scalar<ResourceHandle>()() = resource_handle;\n    } else {\n      // Legacy behavior in V1.\n      handle->flat<tstring>().setConstant(tk.GetHandle(name()));\n    }\n  }",
        "output": "1",
        "idx": 1282
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "io_set_process_status(mrb_state *mrb, pid_t pid, int status)\n{\n  struct RClass *c_process, *c_status;\n  mrb_value v;\n\n  c_status = NULL;\n  if (mrb_class_defined(mrb, \"Process\")) {\n    c_process = mrb_module_get(mrb, \"Process\");\n    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, \"Status\"))) {\n      c_status = mrb_class_get_under(mrb, c_process, \"Status\");\n    }\n  }\n  if (c_status != NULL) {\n    v = mrb_funcall(mrb, mrb_obj_value(c_status), \"new\", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));\n  } else {\n    v = mrb_fixnum_value(WEXITSTATUS(status));\n  }\n  mrb_gv_set(mrb, mrb_intern_cstr(mrb, \"$?\"), v);\n}",
        "output": "0",
        "idx": 1090
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlBufAddLen(xmlBufPtr buf, size_t len) {\n    if ((buf == NULL) || (buf->error))\n        return(-1);\n    CHECK_COMPAT(buf)\n    if (len > (buf->size - buf->use))\n        return(-1);\n    buf->use += len;\n    UPDATE_COMPAT(buf)\n    if (buf->size > buf->use)\n        buf->content[buf->use] = 0;\n    else\n        return(-1);\n    return(0);\n}",
        "output": "0",
        "idx": 1304
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " */\nvoid php_info_print_style(TSRMLS_D)\n{\n\tphp_info_printf(\"<style type=\\\"text/css\\\">\\n\");\n\tphp_info_print_css(TSRMLS_C);\n\tphp_info_printf(\"</style>\\n\");",
        "output": "0",
        "idx": 3244
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Network::FilterStatus Context::onDownstreamData(int data_length, bool end_of_stream) {\n  if (!wasm_->onDownstreamData_) {\n    return Network::FilterStatus::Continue;\n  }\n  auto result = wasm_->onDownstreamData_(this, id_, static_cast<uint32_t>(data_length),\n                                         static_cast<uint32_t>(end_of_stream));\n  // TODO(PiotrSikora): pull Proxy-WASM's FilterStatus values.\n  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;\n}",
        "output": "1",
        "idx": 3550
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nouveau_sgdma_create_ttm(struct ttm_buffer_object *bo, uint32_t page_flags)\n{\n\tstruct nouveau_drm *drm = nouveau_bdev(bo->bdev);\n\tstruct nouveau_sgdma_be *nvbe;\n\n\tnvbe = kzalloc(sizeof(*nvbe), GFP_KERNEL);\n\tif (!nvbe)\n\t\treturn NULL;\n\n\tif (drm->client.device.info.family < NV_DEVICE_INFO_V0_TESLA)\n\t\tnvbe->ttm.ttm.func = &nv04_sgdma_backend;\n\telse\n\t\tnvbe->ttm.ttm.func = &nv50_sgdma_backend;\n\n\tif (ttm_dma_tt_init(&nvbe->ttm, bo, page_flags))\n\t\t/*\n\t\t * A failing ttm_dma_tt_init() will call ttm_tt_destroy()\n\t\t * and thus our nouveau_sgdma_destroy() hook, so we don't need\n\t\t * to free nvbe here.\n\t\t */\n\t\treturn NULL;\n\treturn &nvbe->ttm.ttm;\n}",
        "output": "1",
        "idx": 3357
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n\t\n\tobject->u.dir.index = 0;\n\tif (object->u.dir.dirp) {\n\t\tphp_stream_rewinddir(object->u.dir.dirp);\n\t}\n\tspl_filesystem_dir_read(object TSRMLS_CC);\n}",
        "output": "1",
        "idx": 2127
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void virtio_serial_register_types(void)\n{\n    type_register_static(&virtser_bus_info);\n    type_register_static(&virtio_serial_port_type_info);\n    type_register_static(&virtio_device_info);\n}",
        "output": "0",
        "idx": 889
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Window_frame::print(String *str, enum_query_type query_type)\n{\n  switch (units) {\n  case UNITS_ROWS:\n    str->append(STRING_WITH_LEN(\" rows \"));\n    break;\n  case UNITS_RANGE:\n    str->append(STRING_WITH_LEN(\" range \"));\n    break; \n  default:\n    DBUG_ASSERT(0);\n  }\n\n  str->append(STRING_WITH_LEN(\"between \"));\n  top_bound->print(str, query_type);\n  str->append(STRING_WITH_LEN(\" and \"));\n  bottom_bound->print(str, query_type);\n \n  if (exclusion != EXCL_NONE)\n  {\n     str->append(STRING_WITH_LEN(\" exclude \")); \n     switch (exclusion) {\n     case EXCL_CURRENT_ROW: \n       str->append(STRING_WITH_LEN(\" current row \"));\n       break;\n     case EXCL_GROUP: \n       str->append(STRING_WITH_LEN(\" group \"));\n       break;\n     case EXCL_TIES: \n       str->append(STRING_WITH_LEN(\" ties \"));\n       break;\n     default: \n       DBUG_ASSERT(0);\n       ;\n     }\n  } \n}",
        "output": "0",
        "idx": 1441
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlDumpElementDeclScan(xmlElementPtr elem, xmlBufferPtr buf) {\n    xmlDumpElementDecl(buf, elem);\n}",
        "output": "0",
        "idx": 244
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int yr_object_set_string(\n    const char* value,\n    size_t len,\n    YR_OBJECT* object,\n    const char* field,\n    ...)\n{\n  YR_OBJECT_STRING* string_obj;\n\n  va_list args;\n  va_start(args, field);\n\n  if (field != NULL)\n    string_obj = (YR_OBJECT_STRING*) _yr_object_lookup(\n        object, OBJECT_CREATE, field, args);\n  else\n    string_obj = (YR_OBJECT_STRING*) object;\n\n  va_end(args);\n\n  assert(string_obj != NULL);\n  assert(string_obj->type == OBJECT_TYPE_STRING);\n\n  if (string_obj->value != NULL)\n    yr_free(string_obj->value);\n\n  if (value != NULL)\n  {\n    string_obj->value = (SIZED_STRING*) yr_malloc(len + sizeof(SIZED_STRING));\n\n    if (string_obj->value == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    string_obj->value->length = (uint32_t) len;\n    string_obj->value->flags = 0;\n\n    memcpy(string_obj->value->c_string, value, len);\n    string_obj->value->c_string[len] = '\\0';\n  }\n  else\n  {\n    string_obj->value = NULL;\n  }\n\n  return ERROR_SUCCESS;\n}",
        "output": "0",
        "idx": 450
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool asn1_write_enumerated(struct asn1_data *data, uint8_t v)\n{\n\tif (!asn1_push_tag(data, ASN1_ENUMERATED)) return false;\n\tasn1_write_uint8(data, v);\n\tasn1_pop_tag(data);\n\treturn !data->has_error;\n}",
        "output": "1",
        "idx": 1629
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int _gnutls_fips_perform_self_checks1(void)\n{\n\tint ret;\n\n\t_gnutls_switch_lib_state(LIB_STATE_SELFTEST);\n\n\t/* Tests the FIPS algorithms used by nettle internally.\n\t * In our case we test AES-CBC since nettle's AES is used by\n\t * the DRBG-AES.\n\t */\n\n\t/* ciphers - one test per cipher */\n\tret = gnutls_cipher_self_test(0, GNUTLS_CIPHER_AES_128_CBC);\n\tif (ret < 0) {\n\t\tgnutls_assert();\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\t_gnutls_switch_lib_state(LIB_STATE_ERROR);\n\t_gnutls_audit_log(NULL, \"FIPS140-2 self testing part1 failed\\n\");\n\n\treturn GNUTLS_E_SELF_TEST_ERROR;\n}",
        "output": "0",
        "idx": 2774
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ZEND_FASTCALL  ZEND_ADD_STRING_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tzend_op *opline = EX(opline);\n\tzval *str = &EX_T(opline->result.u.var).tmp_var;\n\n\tif (IS_TMP_VAR == IS_UNUSED) {\n\t\t/* Initialize for erealloc in add_string_to_string */\n\t\tZ_STRVAL_P(str) = NULL;\n\t\tZ_STRLEN_P(str) = 0;\n\t\tZ_TYPE_P(str) = IS_STRING;\n\n\t\tINIT_PZVAL(str);\n\t}\n\n\tadd_string_to_string(str, str, &opline->op2.u.constant);\n\n\t/* FREE_OP is missing intentionally here - we're always working on the same temporary variable */\n\tZEND_VM_NEXT_OPCODE();\n}",
        "output": "0",
        "idx": 108
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "zzip_mem_disk_findfile(ZZIP_MEM_DISK* dir, \n                       char* filename, ZZIP_DISK_ENTRY* after,\n\t\t       zzip_strcmp_fn_t compare) {\n    return zzip_disk_findfile(dir->disk, filename, after, compare); }",
        "output": "1",
        "idx": 724
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    //! Return a reference to the minimum pixel value \\const.\n    const T& min() const {\n      if (is_empty())\n        throw CImgInstanceException(_cimg_instance\n                                    \"min(): Empty instance.\",\n                                    cimg_instance);\n      const T *ptr_min = _data;\n      T min_value = *ptr_min;\n      cimg_for(*this,ptrs,T) if (*ptrs<min_value) min_value = *(ptr_min=ptrs);\n      return *ptr_min;",
        "output": "0",
        "idx": 1745
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_pickle_UnpicklerMemoProxy_copy_impl(UnpicklerMemoProxyObject *self)\n/*[clinic end generated code: output=e12af7e9bc1e4c77 input=97769247ce032c1d]*/\n{\n    Py_ssize_t i;\n    PyObject *new_memo = PyDict_New();\n    if (new_memo == NULL)\n        return NULL;\n\n    for (i = 0; i < self->unpickler->memo_size; i++) {\n        int status;\n        PyObject *key, *value;\n\n        value = self->unpickler->memo[i];\n        if (value == NULL)\n            continue;\n\n        key = PyLong_FromSsize_t(i);\n        if (key == NULL)\n            goto error;\n        status = PyDict_SetItem(new_memo, key, value);\n        Py_DECREF(key);\n        if (status < 0)\n            goto error;\n    }\n    return new_memo;\n\nerror:\n    Py_DECREF(new_memo);\n    return NULL;\n}",
        "output": "1",
        "idx": 844
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int handle_vmx_instruction(struct kvm_vcpu *vcpu)\n{\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn 1;\n}",
        "output": "0",
        "idx": 709
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "completion_glob_pattern (string)\n     char *string;\n{\n  register int c;\n  char *send;\n  int open;\n\n  DECLARE_MBSTATE;\n\n  open = 0;\n  send = string + strlen (string);\n\n  while (c = *string++)\n    {\n      switch (c)\n\t{\n\tcase '?':\n\tcase '*':\n\t  return (1);\n\n\tcase '[':\n\t  open++;\n\t  continue;\n\n\tcase ']':\n\t  if (open)\n\t    return (1);\n\t  continue;\n\n\tcase '+':\n\tcase '@':\n\tcase '!':\n\t  if (*string == '(')\t/*)*/\n\t    return (1);\n\t  continue;\n\n\tcase '\\\\':\n\t  if (*string++ == 0)\n\t    return (0);\n\t}\n\n      /* Advance one fewer byte than an entire multibyte character to\n\t account for the auto-increment in the loop above. */\n#ifdef HANDLE_MULTIBYTE\n      string--;\n      ADVANCE_CHAR_P (string, send - string);\n      string++;\n#else\n      ADVANCE_CHAR_P (string, send - string);\n#endif\n    }\n  return (0);\n}",
        "output": "1",
        "idx": 501
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\tswitch (yych) {\n\t\tcase 'a': goto yy37;\n\t\tdefault: goto yy36;\n\t}",
        "output": "1",
        "idx": 2109
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __idr_remove_all(struct idr *idp)\n{\n\tint n, id, max;\n\tint bt_mask;\n\tstruct idr_layer *p;\n\tstruct idr_layer *pa[MAX_IDR_LEVEL];\n\tstruct idr_layer **paa = &pa[0];\n\n\tn = idp->layers * IDR_BITS;\n\tp = idp->top;\n\trcu_assign_pointer(idp->top, NULL);\n\tmax = 1 << n;\n\n\tid = 0;\n\twhile (id < max) {\n\t\twhile (n > IDR_BITS && p) {\n\t\t\tn -= IDR_BITS;\n\t\t\t*paa++ = p;\n\t\t\tp = p->ary[(id >> n) & IDR_MASK];\n\t\t}\n\n\t\tbt_mask = id;\n\t\tid += 1 << n;\n\t\t/* Get the highest bit that the above add changed from 0->1. */\n\t\twhile (n < fls(id ^ bt_mask)) {\n\t\t\tif (p)\n\t\t\t\tfree_layer(p);\n\t\t\tn += IDR_BITS;\n\t\t\tp = *--paa;\n\t\t}\n\t}\n\tidp->layers = 0;\n}",
        "output": "1",
        "idx": 169
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline void readit(int f, void *buf, size_t len) {\n\tssize_t res;\n\twhile (len > 0) {\n\t\tDEBUG(\"*\");\n\t\tif ((res = read(f, buf, len)) <= 0)\n\t\t\terr(\"Read failed: %m\");\n\t\tlen -= res;\n\t\tbuf += res;\n\t}\n}",
        "output": "0",
        "idx": 3135
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vnc_zrle_send_framebuffer_update(VncState *vs, int x, int y, int w, int h)\n{\n    vs->zrle.type = VNC_ENCODING_ZRLE;\n    return zrle_send_framebuffer_update(vs, x, y, w, h);\n}",
        "output": "1",
        "idx": 3361
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int set_bdev_super(struct super_block *s, void *data)\n{\n\ts->s_bdev = data;\n\ts->s_dev = s->s_bdev->bd_dev;\n\n\t/*\n\t * We set the bdi here to the queue backing, file systems can\n\t * overwrite this in ->fill_super()\n\t */\n\ts->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;\n\treturn 0;\n}",
        "output": "0",
        "idx": 1472
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "glue(glue(cirrus_bitblt_rop_bkwd_transp_, ROP_NAME),_16)(CirrusVGAState *s,\n\t\t\t\t\t\t\t uint8_t *dst,const uint8_t *src,\n\t\t\t\t\t\t\t int dstpitch,int srcpitch,\n\t\t\t\t\t\t\t int bltwidth,int bltheight)\n{\n    int x,y;\n    uint8_t p1, p2;\n    dstpitch += bltwidth;\n    srcpitch += bltwidth;\n    for (y = 0; y < bltheight; y++) {\n        for (x = 0; x < bltwidth; x+=2) {\n\t    p1 = *(dst-1);\n\t    p2 = *dst;\n            ROP_OP(&p1, *(src - 1));\n            ROP_OP(&p2, *src);\n\t    if ((p1 != s->vga.gr[0x34]) || (p2 != s->vga.gr[0x35])) {\n\t\t*(dst-1) = p1;\n\t\t*dst = p2;\n\t    }\n            dst-=2;\n            src-=2;\n        }\n        dst += dstpitch;\n        src += srcpitch;\n    }\n}",
        "output": "1",
        "idx": 372
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Curl_http_output_auth(struct Curl_easy *data,\n                      struct connectdata *conn,\n                      const char *request,\n                      Curl_HttpReq httpreq,\n                      const char *path,\n                      bool proxytunnel)\n{\n  (void)data;\n  (void)conn;\n  (void)request;\n  (void)httpreq;\n  (void)path;\n  (void)proxytunnel;\n  return CURLE_OK;\n}",
        "output": "1",
        "idx": 1308
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Token *make_tok_qstr(Token *next, const char *str)\n{\n    return make_tok_qstr_len(next, str, strlen(str));\n}",
        "output": "0",
        "idx": 974
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "evbuffer_chain_new(size_t size)\n{\n\tstruct evbuffer_chain *chain;\n\tsize_t to_alloc;\n\n\tsize += EVBUFFER_CHAIN_SIZE;\n\n\t/* get the next largest memory that can hold the buffer */\n\tto_alloc = MIN_BUFFER_SIZE;\n\twhile (to_alloc < size)\n\t\tto_alloc <<= 1;\n\n\t/* we get everything in one chunk */\n\tif ((chain = mm_malloc(to_alloc)) == NULL)\n\t\treturn (NULL);\n\n\tmemset(chain, 0, EVBUFFER_CHAIN_SIZE);\n\n\tchain->buffer_len = to_alloc - EVBUFFER_CHAIN_SIZE;\n\n\t/* this way we can manipulate the buffer to different addresses,\n\t * which is required for mmap for example.\n\t */\n\tchain->buffer = EVBUFFER_CHAIN_EXTRA(u_char, chain);\n\n\tchain->refcnt = 1;\n\n\treturn (chain);\n}",
        "output": "1",
        "idx": 399
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n\n    /* we have an error following */\n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    reason = malloc(reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n    free(reason);\n}",
        "output": "1",
        "idx": 491
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HttpIntegrationTest::waitForNextUpstreamRequest(uint64_t upstream_index) {\n  waitForNextUpstreamRequest(std::vector<uint64_t>({upstream_index}));\n}",
        "output": "1",
        "idx": 2366
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_fdc(int drive)\n{\n\tif (drive >= 0 && drive < N_DRIVE) {\n\t\tfdc = FDC(drive);\n\t\tcurrent_drive = drive;\n\t}\n\tif (fdc != 1 && fdc != 0) {\n\t\tpr_info(\"bad fdc value\\n\");\n\t\treturn;\n\t}\n\tset_dor(fdc, ~0, 8);\n#if N_FDC > 1\n\tset_dor(1 - fdc, ~8, 0);\n#endif\n\tif (FDCS->rawcmd == 2)\n\t\treset_fdc_info(1);\n\tif (fd_inb(FD_STATUS) != STATUS_READY)\n\t\tFDCS->reset = 1;\n}",
        "output": "1",
        "idx": 1427
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ucma_unlock_files(struct ucma_file *file1, struct ucma_file *file2)\n{\n\tif (file1 < file2) {\n\t\tmutex_unlock(&file2->mut);\n\t\tmutex_unlock(&file1->mut);\n\t} else {\n\t\tmutex_unlock(&file1->mut);\n\t\tmutex_unlock(&file2->mut);\n\t}\n}",
        "output": "1",
        "idx": 2744
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void usage(void)\n{\n  PRINT_VERSION;\n  puts(\"Copyright (c) 2011, Oracle and/or its affiliates. \"\n       \"All rights reserved.\\n\");\n  puts(\"Enable or disable plugins.\");\n  printf(\"\\nUsage: %s [options] <plugin> ENABLE|DISABLE\\n\\nOptions:\\n\",\n     my_progname);\n  my_print_help(my_long_options);\n  puts(\"\\n\");\n}",
        "output": "1",
        "idx": 2769
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned long sbusfb_mmapsize(long size, unsigned long fbsize)\n{\n\tif (size == SBUS_MMAP_EMPTY) return 0;\n\tif (size >= 0) return size;\n\treturn fbsize * (-size);\n}",
        "output": "0",
        "idx": 2051
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_mtime(buf_T *buf, stat_T *st)\n{\n    if (buf->b_mtime_read != 0\n\t    && time_differs((long)st->st_mtime, buf->b_mtime_read))\n    {\n\tmsg_scroll = TRUE;\t    /* don't overwrite messages here */\n\tmsg_silent = 0;\t\t    /* must give this prompt */\n\t/* don't use emsg() here, don't want to flush the buffers */\n\tMSG_ATTR(_(\"WARNING: The file has been changed since reading it!!!\"),\n\t\t\t\t\t\t       HL_ATTR(HLF_E));\n\tif (ask_yesno((char_u *)_(\"Do you really want to write to it\"),\n\t\t\t\t\t\t\t\t TRUE) == 'n')\n\t    return FAIL;\n\tmsg_scroll = FALSE;\t    /* always overwrite the file message now */\n    }\n    return OK;\n}",
        "output": "0",
        "idx": 2605
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void GENERAL_NAME_set0_value(GENERAL_NAME *a, int type, void *value)\n{\n    switch (type) {\n    case GEN_X400:\n    case GEN_EDIPARTY:\n        a->d.other = value;\n        break;\n\n    case GEN_OTHERNAME:\n        a->d.otherName = value;\n        break;\n\n    case GEN_EMAIL:\n    case GEN_DNS:\n    case GEN_URI:\n        a->d.ia5 = value;\n        break;\n\n    case GEN_DIRNAME:\n        a->d.dirn = value;\n        break;\n\n    case GEN_IPADD:\n        a->d.ip = value;\n        break;\n\n    case GEN_RID:\n        a->d.rid = value;\n        break;\n    }\n    a->type = type;\n}",
        "output": "1",
        "idx": 34
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "http_client_check_response_cb (SoupSession *session, SoupMessage *msg, gpointer user_data)\n{\n  GError *error;\n  CheckData *data = user_data;\n  GTlsCertificateFlags cert_flags;\n  gboolean op_res;\n  gboolean using_https;\n\n  error = NULL;\n  op_res = FALSE;\n\n  if (msg->status_code == SOUP_STATUS_CANCELLED)\n    goto out;\n  else if (msg->status_code != SOUP_STATUS_OK)\n    {\n      g_set_error (&error,\n                   GOA_ERROR,\n                   GOA_ERROR_FAILED, /* TODO: more specific */\n                   _(\"Code: %u - Unexpected response from server\"),\n                   msg->status_code);\n      goto out;\n    }\n\n  if (!data->accept_ssl_errors)\n    {\n      using_https = soup_message_get_https_status (msg, NULL, &cert_flags);\n      if (using_https && cert_flags != 0)\n        {\n          goa_utils_set_error_ssl (&error, cert_flags);\n          goto out;\n        }\n    }\n\n  op_res = TRUE;\n\n out:\n  g_simple_async_result_set_op_res_gboolean (data->res, op_res);\n  if (error != NULL)\n    g_simple_async_result_take_error (data->res, error);\n\n  g_simple_async_result_complete_in_idle (data->res);\n  g_idle_add (http_client_check_data_free, data);\n}",
        "output": "1",
        "idx": 2120
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gdk_pixbuf__png_image_stop_load (gpointer context, GError **error)\n{\n        LoadContext* lc = context;\n\n        g_return_val_if_fail(lc != NULL, TRUE);\n\n        /* FIXME this thing needs to report errors if\n         * we have unused image data\n         */\n        \n        gdk_pixbuf_unref(lc->pixbuf);\n        \n        png_destroy_read_struct(&lc->png_read_ptr, NULL, NULL);\n        g_free(lc);\n\n        return TRUE;\n}",
        "output": "1",
        "idx": 2715
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus PrepareMeanOrSum(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_OK(context, PrepareSimple(context, node));\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  // reduce_mean requires a buffer to store intermediate sum result.\n  OpContext op_context(context, node);\n  if (op_context.input->type == kTfLiteInt8 ||\n      op_context.input->type == kTfLiteUInt8 ||\n      op_context.input->type == kTfLiteInt16) {\n    const double real_multiplier =\n        static_cast<double>(op_context.input->params.scale) /\n        static_cast<double>(op_context.output->params.scale);\n    int exponent;\n    QuantizeMultiplier(real_multiplier, &data->multiplier, &exponent);\n    data->shift = exponent;\n  }\n  TfLiteTensor* temp_sum = GetTemporary(context, node, /*index=*/2);\n  if (!IsConstantTensor(op_context.axis)) {\n    SetTensorToDynamic(temp_sum);\n    return kTfLiteOk;\n  }\n  temp_sum->allocation_type = kTfLiteArenaRw;\n  return ResizeTempSum(context, &op_context, temp_sum);\n}",
        "output": "1",
        "idx": 1886
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::string dump_time_to_str(const real_time& t)\n{\n  char timestr[TIME_BUF_SIZE];\n  dump_time_header_impl(timestr, t);\n\n  return timestr;\n}",
        "output": "0",
        "idx": 808
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ins_compl_next_buf(buf_T *buf, int flag)\n{\n    static win_T *wp = NULL;\n\n    if (flag == 'w')\t\t// just windows\n    {\n\tif (buf == curbuf || wp == NULL)  // first call for this flag/expansion\n\t    wp = curwin;\n\twhile ((wp = (wp->w_next != NULL ? wp->w_next : firstwin)) != curwin\n\t\t&& wp->w_buffer->b_scanned)\n\t    ;\n\tbuf = wp->w_buffer;\n    }\n    else\n\t// 'b' (just loaded buffers), 'u' (just non-loaded buffers) or 'U'\n\t// (unlisted buffers)\n\t// When completing whole lines skip unloaded buffers.\n\twhile ((buf = (buf->b_next != NULL ? buf->b_next : firstbuf)) != curbuf\n\t\t&& ((flag == 'U'\n\t\t\t? buf->b_p_bl\n\t\t\t: (!buf->b_p_bl\n\t\t\t    || (buf->b_ml.ml_mfp == NULL) != (flag == 'u')))\n\t\t    || buf->b_scanned))\n\t    ;\n    return buf;\n}",
        "output": "1",
        "idx": 1584
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API st64 r_buf_fread_at(RBuffer *b, ut64 addr, ut8 *buf, const char *fmt, int n) {\n\tr_return_val_if_fail (b && buf && fmt, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tr = r_buf_fread (b, buf, fmt, n);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}",
        "output": "1",
        "idx": 3468
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int msr_open(struct inode *inode, struct file *file)\n{\n\tunsigned int cpu;\n\tstruct cpuinfo_x86 *c;\n\n\tcpu = iminor(file->f_path.dentry->d_inode);\n\tif (cpu >= nr_cpu_ids || !cpu_online(cpu))\n\t\treturn -ENXIO;\t/* No such CPU */\n\n\tc = &cpu_data(cpu);\n\tif (!cpu_has(c, X86_FEATURE_MSR))\n\t\treturn -EIO;\t/* MSR not supported */\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 3606
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *name, zend_uint len) /* {{{ */\n{\n\tzend_trait_alias *alias, **alias_ptr;\n\n\tif ((alias_ptr = ce->trait_aliases)) {\n\t\talias = *alias_ptr;\n\t\twhile (alias) {\n\t\t\tif (alias->alias_len == len &&\n\t\t\t\t!strncasecmp(name, alias->alias, alias->alias_len)) {\n\t\t\t\treturn alias->alias;\n\t\t\t}\n\t\t\talias_ptr++;\n\t\t\talias = *alias_ptr;\n\t\t}\n\t}\n\n\treturn name;\n}",
        "output": "0",
        "idx": 3585
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MD5::checkDataChecksum(char const* const checksum,\n\t\t       char const* buf, int len)\n{\n    std::string actual_checksum = getDataChecksum(buf, len);\n    return (checksum == actual_checksum);\n}",
        "output": "1",
        "idx": 2802
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int sas_smp_get_phy_events(struct sas_phy *phy)\n{\n\tint res;\n\tu8 *req;\n\tu8 *resp;\n\tstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\n\tstruct domain_device *dev = sas_find_dev_by_rphy(rphy);\n\n\treq = alloc_smp_req(RPEL_REQ_SIZE);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tresp = alloc_smp_resp(RPEL_RESP_SIZE);\n\tif (!resp) {\n\t\tkfree(req);\n\t\treturn -ENOMEM;\n\t}\n\n\treq[1] = SMP_REPORT_PHY_ERR_LOG;\n\treq[9] = phy->number;\n\n\tres = smp_execute_task(dev, req, RPEL_REQ_SIZE,\n\t\t\t            resp, RPEL_RESP_SIZE);\n\n\tif (!res)\n\t\tgoto out;\n\n\tphy->invalid_dword_count = scsi_to_u32(&resp[12]);\n\tphy->running_disparity_error_count = scsi_to_u32(&resp[16]);\n\tphy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);\n\tphy->phy_reset_problem_count = scsi_to_u32(&resp[24]);\n\n out:\n\tkfree(resp);\n\treturn res;\n\n}",
        "output": "1",
        "idx": 1503
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cil_destroy_nodecon(struct cil_nodecon *nodecon)\n{\n\tif (nodecon == NULL) {\n\t\treturn;\n\t}\n\n\tif (nodecon->addr_str == NULL && nodecon->addr != NULL) {\n\t\tcil_destroy_ipaddr(nodecon->addr);\n\t}\n\n\tif (nodecon->mask_str == NULL && nodecon->mask != NULL) {\n\t\tcil_destroy_ipaddr(nodecon->mask);\n\t}\n\n\tif (nodecon->context_str == NULL && nodecon->context != NULL) {\n\t\tcil_destroy_context(nodecon->context);\n\t}\n\n\tfree(nodecon);\n}",
        "output": "0",
        "idx": 42
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void draw_stroke_color_rgb( wmfAPI* API, const wmfRGB* rgb )\n{\n  PixelWand\n    *stroke_color;\n\n  stroke_color=NewPixelWand();\n  PixelSetRedQuantum(stroke_color,ScaleCharToQuantum(rgb->r));\n  PixelSetGreenQuantum(stroke_color,ScaleCharToQuantum(rgb->g));\n  PixelSetBlueQuantum(stroke_color,ScaleCharToQuantum(rgb->b));\n  PixelSetAlphaQuantum(stroke_color,OpaqueAlpha);\n  DrawSetStrokeColor(WmfDrawingWand,stroke_color);\n  stroke_color=DestroyPixelWand(stroke_color);\n}",
        "output": "0",
        "idx": 330
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int usb_device_detach(USBDevice *dev)\n{\n    USBBus *bus = usb_bus_from_device(dev);\n    USBPort *port = dev->port;\n\n    assert(port != NULL);\n    assert(dev->attached);\n    trace_usb_port_detach(bus->busnr, port->path);\n\n    usb_detach(port);\n    dev->attached--;\n    return 0;\n}",
        "output": "0",
        "idx": 2890
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ff_layout_need_layoutcommit(struct pnfs_layout_segment *lseg)\n{\n\treturn !(FF_LAYOUT_LSEG(lseg)->flags & FF_FLAGS_NO_LAYOUTCOMMIT);\n}",
        "output": "0",
        "idx": 3125
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "njs_vmcode_array(njs_vm_t *vm, u_char *pc)\n{\n    uint32_t            length;\n    njs_array_t         *array;\n    njs_value_t         *value;\n    njs_vmcode_array_t  *code;\n\n    code = (njs_vmcode_array_t *) pc;\n\n    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);\n\n    if (njs_fast_path(array != NULL)) {\n\n        if (code->ctor) {\n            /* Array of the form [,,,], [1,,]. */\n            value = array->start;\n            length = array->length;\n\n            do {\n                njs_set_invalid(value);\n                value++;\n                length--;\n            } while (length != 0);\n\n        } else {\n            /* Array of the form [], [,,1], [1,2,3]. */\n            array->length = 0;\n        }\n\n        njs_set_array(&vm->retval, array);\n\n        return sizeof(njs_vmcode_array_t);\n    }\n\n    return NJS_ERROR;\n}",
        "output": "1",
        "idx": 1399
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void zlib_stateful_finish(COMP_CTX *ctx)\n\t{\n\tCRYPTO_free_ex_data(CRYPTO_EX_INDEX_COMP,ctx,&ctx->ex_data);\n\t}",
        "output": "1",
        "idx": 785
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dense_rankStepFunc(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **apArg\n){\n  struct CallCount *p;\n  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));\n  if( p ) p->nStep = 1;\n  UNUSED_PARAMETER(nArg);\n  UNUSED_PARAMETER(apArg);\n}",
        "output": "0",
        "idx": 212
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main()\n{\n   initialize_environment();\n\n   test_format_wrong_size();\n   test_blit_info_format_check();\n   test_blit_info_format_check_null_format();\n   test_format_is_plain_nullptr_deref_trigger();\n   test_format_util_format_is_rgb_nullptr_deref_trigger_illegal_resource();\n   test_format_util_format_is_rgb_nullptr_deref_trigger();\n   test_double_free_in_vrend_renderer_blit_int_trigger_invalid_formats();\n   test_double_free_in_vrend_renderer_blit_int_trigger();\n   test_format_is_has_alpha_nullptr_deref_trigger_original();\n   test_format_is_has_alpha_nullptr_deref_trigger_legal_resource();\n\n   test_heap_overflow_vrend_renderer_transfer_write_iov();\n\n   virgl_renderer_context_destroy(ctx_id);\n   virgl_renderer_cleanup(&cookie);\n   virgl_egl_destroy(test_egl);\n\n   return 0;\n}",
        "output": "1",
        "idx": 3701
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "callbacks_save_layer_activate                       (GtkMenuItem     *menuitem,\n                                        gpointer         user_data)\n{\n  /* first figure out which layer in the layer side menu is selected */\n  gint index=callbacks_get_selected_row_index();\n  \n  /* Now save that layer */\n  if (index >= 0) {\n    if (!gerbv_save_layer_from_index (mainProject, index, mainProject->file[index]->fullPathname)) {\n      interface_show_alert_dialog(_(\"Gerbv cannot export this file type\"), \n\t\t\t\t  NULL,\n\t\t\t\t  FALSE,\n\t\t\t\t  NULL);\n      mainProject->file[index]->layer_dirty = FALSE;\n      callbacks_update_layer_tree();\n      return;\n    }\n  }\n  callbacks_update_layer_tree();\n  return;\n}",
        "output": "0",
        "idx": 1727
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HttpRequestEntry::resetHttpHeaderProcessor()\n{\n  proc_ = make_unique<HttpHeaderProcessor>(HttpHeaderProcessor::CLIENT_PARSER);\n}",
        "output": "0",
        "idx": 3444
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "chkpass_ne(PG_FUNCTION_ARGS)\n{\n\tchkpass    *a1 = (chkpass *) PG_GETARG_POINTER(0);\n\ttext\t   *a2 = PG_GETARG_TEXT_PP(1);\n\tchar\t\tstr[9];\n\n\ttext_to_cstring_buffer(a2, str, sizeof(str));\n\tPG_RETURN_BOOL(strcmp(a1->password, crypt(str, a1->password)) != 0);\n}",
        "output": "1",
        "idx": 2943
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int sqlite3Fts3SelectDoctotal(\n  Fts3Table *pTab,                /* Fts3 table handle */\n  sqlite3_stmt **ppStmt           /* OUT: Statement handle */\n){\n  sqlite3_stmt *pStmt = 0;\n  int rc;\n  rc = fts3SqlStmt(pTab, SQL_SELECT_STAT, &pStmt, 0);\n  if( rc==SQLITE_OK ){\n    sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);\n    if( sqlite3_step(pStmt)!=SQLITE_ROW\n     || sqlite3_column_type(pStmt, 0)!=SQLITE_BLOB\n    ){\n      rc = sqlite3_reset(pStmt);\n      if( rc==SQLITE_OK ) rc = FTS_CORRUPT_VTAB;\n      pStmt = 0;\n    }\n  }\n  *ppStmt = pStmt;\n  return rc;\n}",
        "output": "0",
        "idx": 1544
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "AnyP::Uri::path() const\n{\n    // RFC 3986 section 3.3 says path can be empty (path-abempty).\n    // RFC 7230 sections 2.7.3, 5.3.1, 5.7.2 - says path cannot be empty, default to \"/\"\n    // at least when sending and using. We must still accept path-abempty as input.\n    if (path_.isEmpty() && (scheme_ == AnyP::PROTO_HTTP || scheme_ == AnyP::PROTO_HTTPS))\n        return SlashPath();\n\n    return path_;\n}",
        "output": "0",
        "idx": 68
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    //! Equalize histogram of pixel values \\newinstance.\n    CImg<T> get_equalize(const unsigned int nblevels) const {\n      return (+*this).equalize(nblevels);",
        "output": "0",
        "idx": 1337
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(openssl_error_string)\n{\n\tchar buf[256];\n\tunsigned long val;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tphp_openssl_store_errors();\n\n\tif (OPENSSL_G(errors) == NULL || OPENSSL_G(errors)->top == OPENSSL_G(errors)->bottom) {\n\t\tRETURN_FALSE;\n\t}\n\n\tOPENSSL_G(errors)->bottom = (OPENSSL_G(errors)->bottom + 1) % ERR_NUM_ERRORS;\n\tval = OPENSSL_G(errors)->buffer[OPENSSL_G(errors)->bottom];\n\n\tif (val) {\n\t\tERR_error_string_n(val, buf, 256);\n\t\tRETURN_STRING(buf);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}",
        "output": "0",
        "idx": 315
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API const char *r_str_closer_chr(const char *b, const char *s) {\n\tconst char *a;\n\twhile (*b) {\n\t\tfor (a = s; *a; a++) {\n\t\t\tif (*b == *a) {\n\t\t\t\treturn b;\n\t\t\t}\n\t\t}\n\t\tb++;\n\t}\n\treturn NULL;\n}",
        "output": "0",
        "idx": 1271
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CIRCNetwork::SetEncoding(const CString& s) {\n    m_sEncoding = s;\n    if (GetIRCSock()) {\n        GetIRCSock()->SetEncoding(s);\n    }\n}",
        "output": "1",
        "idx": 1466
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int read_pack_info_file(const char *infofile)\n{\n\tFILE *fp;\n\tchar line[1000];\n\tint old_cnt = 0;\n\n\tfp = fopen(infofile, \"r\");\n\tif (!fp)\n\t\treturn 1; /* nonexistent is not an error. */\n\n\twhile (fgets(line, sizeof(line), fp)) {\n\t\tint len = strlen(line);\n\t\tif (len && line[len-1] == '\\n')\n\t\t\tline[--len] = 0;\n\n\t\tif (!len)\n\t\t\tcontinue;\n\n\t\tswitch (line[0]) {\n\t\tcase 'P': /* P name */\n\t\t\tif (parse_pack_def(line, old_cnt++))\n\t\t\t\tgoto out_stale;\n\t\t\tbreak;\n\t\tcase 'D': /* we used to emit D but that was misguided. */\n\t\t\tgoto out_stale;\n\t\t\tbreak;\n\t\tcase 'T': /* we used to emit T but nobody uses it. */\n\t\t\tgoto out_stale;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"unrecognized: %s\", line);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfclose(fp);\n\treturn 0;\n out_stale:\n\tfclose(fp);\n\treturn 1;\n}",
        "output": "1",
        "idx": 430
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TPM2B_MAX_BUFFER_Marshal(TPM2B_MAX_BUFFER *source, BYTE **buffer, INT32 *size)\n{\n    UINT16 written = 0;\n    written += TPM2B_Marshal(&source->b, buffer, size);\n    return written;\n}",
        "output": "1",
        "idx": 1153
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void save_key_to(const char *algo, const char *name, const char *keydata)\n{\n\tconst char *error;\n\tstruct dict_transaction_context *ctx =\n\t\tdict_transaction_begin(keys_dict);\n\n\tdict_set(ctx, t_strconcat(DICT_PATH_SHARED, \"default/\", algo, \"/\",\n\t\t\t\t  name, NULL),\n\t\t keydata);\n\tif (dict_transaction_commit(&ctx, &error) < 0)\n\t\ti_error(\"dict_set(%s) failed: %s\", name, error);\n}",
        "output": "1",
        "idx": 259
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlXPtrNewContext(xmlDocPtr doc, xmlNodePtr here, xmlNodePtr origin) {\n    xmlXPathContextPtr ret;\n\n    ret = xmlXPathNewContext(doc);\n    if (ret == NULL)\n\treturn(ret);\n    ret->xptr = 1;\n    ret->here = here;\n    ret->origin = origin;\n\n    xmlXPathRegisterFunc(ret, (xmlChar *)\"range-to\",\n\t                 xmlXPtrRangeToFunction);\n    xmlXPathRegisterFunc(ret, (xmlChar *)\"range\",\n\t                 xmlXPtrRangeFunction);\n    xmlXPathRegisterFunc(ret, (xmlChar *)\"range-inside\",\n\t                 xmlXPtrRangeInsideFunction);\n    xmlXPathRegisterFunc(ret, (xmlChar *)\"string-range\",\n\t                 xmlXPtrStringRangeFunction);\n    xmlXPathRegisterFunc(ret, (xmlChar *)\"start-point\",\n\t                 xmlXPtrStartPointFunction);\n    xmlXPathRegisterFunc(ret, (xmlChar *)\"end-point\",\n\t                 xmlXPtrEndPointFunction);\n    xmlXPathRegisterFunc(ret, (xmlChar *)\"here\",\n\t                 xmlXPtrHereFunction);\n    xmlXPathRegisterFunc(ret, (xmlChar *)\" origin\",\n\t                 xmlXPtrOriginFunction);\n\n    return(ret);\n}",
        "output": "1",
        "idx": 2167
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  QUInt16() {}",
        "output": "1",
        "idx": 575
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kvm_sched_in(struct preempt_notifier *pn, int cpu)\n{\n\tstruct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);\n\n\tWRITE_ONCE(vcpu->preempted, false);\n\tWRITE_ONCE(vcpu->ready, false);\n\n\t__this_cpu_write(kvm_running_vcpu, vcpu);\n\tkvm_arch_sched_in(vcpu, cpu);\n\tkvm_arch_vcpu_load(vcpu, cpu);\n}",
        "output": "0",
        "idx": 1817
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(Array, current)\n{\n\tzval *object = getThis();\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tzval **entry;\n\tHashTable *aht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (spl_array_object_verify_pos(intern, aht TSRMLS_CC) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (zend_hash_get_current_data_ex(aht, (void **) &entry, &intern->pos) == FAILURE) {\n\t\treturn;\n\t}\n\tRETVAL_ZVAL(*entry, 1, 0);\n}",
        "output": "1",
        "idx": 1801
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parse_hello_subtlv(const unsigned char *a, int alen,\n                   unsigned int *hello_send_us)\n{\n    int type, len, i = 0, ret = 0;\n\n    while(i < alen) {\n        type = a[0];\n        if(type == SUBTLV_PAD1) {\n            i++;\n            continue;\n        }\n\n        if(i + 1 > alen) {\n            flog_err(EC_BABEL_PACKET,\n\t\t      \"Received truncated sub-TLV on Hello message.\");\n            return -1;\n        }\n        len = a[i + 1];\n        if(i + len > alen) {\n            flog_err(EC_BABEL_PACKET,\n\t\t      \"Received truncated sub-TLV on Hello message.\");\n            return -1;\n        }\n\n        if(type == SUBTLV_PADN) {\n            /* Nothing to do. */\n        } else if(type == SUBTLV_TIMESTAMP) {\n            if(len >= 4) {\n                DO_NTOHL(*hello_send_us, a + i + 2);\n                ret = 1;\n            } else {\n                flog_err(EC_BABEL_PACKET,\n\t\t\t  \"Received incorrect RTT sub-TLV on Hello message.\");\n            }\n        } else {\n            debugf(BABEL_DEBUG_COMMON,\n                   \"Received unknown Hello sub-TLV type %d.\", type);\n        }\n\n        i += len + 2;\n    }\n    return ret;\n}",
        "output": "1",
        "idx": 1943
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mutt_b64_decode(char *out, const char *in)\n{\n  int len = 0;\n  unsigned char digit4;\n\n  do\n  {\n    const unsigned char digit1 = in[0];\n    if ((digit1 > 127) || (base64val(digit1) == BAD))\n      return -1;\n    const unsigned char digit2 = in[1];\n    if ((digit2 > 127) || (base64val(digit2) == BAD))\n      return -1;\n    const unsigned char digit3 = in[2];\n    if ((digit3 > 127) || ((digit3 != '=') && (base64val(digit3) == BAD)))\n      return -1;\n    digit4 = in[3];\n    if ((digit4 > 127) || ((digit4 != '=') && (base64val(digit4) == BAD)))\n      return -1;\n    in += 4;\n\n    /* digits are already sanity-checked */\n    *out++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4);\n    len++;\n    if (digit3 != '=')\n    {\n      *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);\n      len++;\n      if (digit4 != '=')\n      {\n        *out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4);\n        len++;\n      }\n    }\n  } while (*in && digit4 != '=');\n\n  return len;\n}",
        "output": "1",
        "idx": 2634
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RemoteDevicePropertiesWidget::RemoteDevicePropertiesWidget(QWidget *parent)\n    : QWidget(parent)\n    , modified(false)\n    , saveable(false)\n{\n    setupUi(this);\n    if (qobject_cast<QTabWidget *>(parent)) {\n        verticalLayout->setMargin(4);\n    }\n    type->addItem(tr(\"Samba Share\"), (int)Type_Samba);\n    type->addItem(tr(\"Samba Share (Auto-discover host and port)\"), (int)Type_SambaAvahi);\n    type->addItem(tr(\"Secure Shell (sshfs)\"), (int)Type_SshFs);\n    type->addItem(tr(\"Locally Mounted Folder\"), (int)Type_File);\n}",
        "output": "1",
        "idx": 1080
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\nstatic ssize_t kvm_vm_stats_read(struct file *file, char __user *user_buffer,\n\t\t\t      size_t size, loff_t *offset)\n{\n\tstruct kvm *kvm = file->private_data;\n\n\treturn kvm_stats_read(kvm->stats_id, &kvm_vm_stats_header,\n\t\t\t\t&kvm_vm_stats_desc[0], &kvm->stat,\n\t\t\t\tsizeof(kvm->stat), user_buffer, size, offset);",
        "output": "0",
        "idx": 1815
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)\n{\n    srpsrvparm *p = (srpsrvparm *) arg;\n    if (p->login == NULL && p->user == NULL) {\n        p->login = SSL_get_srp_username(s);\n        BIO_printf(bio_err, \"SRP username = \\\"%s\\\"\\n\", p->login);\n        return (-1);\n    }\n\n    if (p->user == NULL) {\n        BIO_printf(bio_err, \"User %s doesn't exist\\n\", p->login);\n        return SSL3_AL_FATAL;\n    }\n    if (SSL_set_srp_server_param\n        (s, p->user->N, p->user->g, p->user->s, p->user->v,\n         p->user->info) < 0) {\n        *ad = SSL_AD_INTERNAL_ERROR;\n        return SSL3_AL_FATAL;\n    }\n    BIO_printf(bio_err,\n               \"SRP parameters set: username = \\\"%s\\\" info=\\\"%s\\\" \\n\",\n               p->login, p->user->info);\n    /* need to check whether there are memory leaks */\n    p->user = NULL;\n    p->login = NULL;\n    return SSL_ERROR_NONE;\n}",
        "output": "1",
        "idx": 3447
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void setWriteFlags(folly::WriteFlags flags) {\n    writeFlags = flags;\n  }",
        "output": "0",
        "idx": 2998
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline double MagickRound(double x)\n{\n  /*\n    Round the fraction to nearest integer.\n  */\n  if ((x-floor(x)) < (ceil(x)-x))\n    return(floor(x));\n  return(ceil(x));\n}",
        "output": "1",
        "idx": 3698
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dissect_ac_if_output_terminal(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n        proto_tree *tree, usb_conv_info_t *usb_conv_info _U_)\n{\n    gint     offset_start;\n    offset_start = offset;\n\n    proto_tree_add_item(tree, hf_ac_if_output_terminalid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_output_terminaltype, tvb, offset, 2, ENC_LITTLE_ENDIAN);\n    offset += 2;\n\n    proto_tree_add_item(tree, hf_ac_if_output_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_output_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    proto_tree_add_item(tree, hf_ac_if_output_terminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    offset += 1;\n\n    return offset-offset_start;\n}",
        "output": "0",
        "idx": 3214
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Client::noteBodyProductionEnded(BodyPipe::Pointer bp)\n{\n#if USE_ADAPTATION\n    if (adaptedBodySource == bp) {\n        handleAdaptedBodyProductionEnded();\n        return;\n    }\n#endif\n    if (requestBodySource == bp)\n        handleRequestBodyProductionEnded();\n}",
        "output": "0",
        "idx": 2210
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "u32 gf_sg_get_next_available_node_id(GF_SceneGraph *sg)\n{\n\tu32 ID;\n\tNodeIDedItem *reg_node;\n\tif (!sg->id_node) return 1;\n\treg_node = sg->id_node;\n\tID = reg_node->NodeID;\n\t/*nodes are sorted*/\n\twhile (reg_node->next) {\n\t\tif (ID+1<reg_node->next->NodeID) return ID+1;\n\t\tID = reg_node->next->NodeID;\n\t\treg_node = reg_node->next;\n\t}\n\treturn ID+1;\n}",
        "output": "0",
        "idx": 1392
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)\n{\n\tint m;\n\n\t/* We can reliably put at most 31 bits since ISO/IEC 9899 only\n\t  guarantees that a long can represent values up to 2^31-1. */\n\tassert(n >= 0 && n < 32);\n\t/* Ensure that only the bits to be output are nonzero. */\n\tassert(!(v & (~JAS_ONES(n))));\n\n\t/* Put the desired number of bits to the specified bit stream. */\n\tm = n - 1;\n\twhile (--n >= 0) {\n\t\tif (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {\n\t\t\treturn EOF;\n\t\t}\n\t\tv <<= 1;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 2577
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n\n\tgpio_dev = platform_get_drvdata(pdev);\n\n\tgpiochip_remove(&gpio_dev->gc);\n\tpinctrl_unregister(gpio_dev->pctrl);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 921
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline void DNS::FillResourceRecord(ResourceRecord* rr, const unsigned char *input)\n{\n\trr->type = (QueryType)((input[0] << 8) + input[1]);\n\trr->rr_class = (input[2] << 8) + input[3];\n\trr->ttl = (input[4] << 24) + (input[5] << 16) + (input[6] << 8) + input[7];\n\trr->rdlength = (input[8] << 8) + input[9];\n}",
        "output": "0",
        "idx": 862
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteMulParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (output->type == kTfLiteFloat32 || output->type == kTfLiteInt32) {\n    EvalMul<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8 ||\n             output->type == kTfLiteInt16) {\n    TF_LITE_ENSURE_OK(\n        context, EvalQuantized<kernel_type>(context, node, params, data, input1,\n                                            input2, output));\n  } else {\n    context->ReportError(context,\n                         \"Mul only supports FLOAT32, INT32 and quantized UINT8,\"\n                         \" INT8 and INT16 now, got %d.\",\n                         output->type);\n    return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}",
        "output": "1",
        "idx": 18
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus LeakyReluPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  LeakyReluOpData* data = reinterpret_cast<LeakyReluOpData*>(node->user_data);\n\n  if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8 ||\n      output->type == kTfLiteInt16) {\n    const auto* params =\n        reinterpret_cast<TfLiteLeakyReluParams*>(node->builtin_data);\n\n    double alpha_multiplier =\n        input->params.scale * params->alpha / output->params.scale;\n    QuantizeMultiplier(alpha_multiplier, &data->output_multiplier_alpha,\n                       &data->output_shift_alpha);\n    double identity_multiplier = input->params.scale / output->params.scale;\n    QuantizeMultiplier(identity_multiplier, &data->output_multiplier_identity,\n                       &data->output_shift_identity);\n  }\n  return context->ResizeTensor(context, output,\n                               TfLiteIntArrayCopy(input->dims));\n}",
        "output": "1",
        "idx": 346
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int pmd_huge(pmd_t pmd)\n{\n\treturn !pmd_none(pmd) &&\n\t\t(pmd_val(pmd) & (_PAGE_VALID|_PAGE_PMD_HUGE)) != _PAGE_VALID;\n}",
        "output": "0",
        "idx": 99
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST(FormatTest, Print) {\n#if FMT_USE_FILE_DESCRIPTORS\n  EXPECT_WRITE(stdout, fmt::print(\"Don't {}!\", \"panic\"), \"Don't panic!\");\n  EXPECT_WRITE(stderr,\n      fmt::print(stderr, \"Don't {}!\", \"panic\"), \"Don't panic!\");\n#endif\n}",
        "output": "0",
        "idx": 2216
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::string GetTempFileName() {\n#if !defined _MSC_VER && !defined __MINGW32__\n  std::string temp_file_name_template_str =\n      std::string(std::getenv(\"TEST_TMPDIR\") ? std::getenv(\"TEST_TMPDIR\") :\n                                               \".\") +\n      \"/libwebm_temp.XXXXXX\";\n  char* temp_file_name_template =\n      new char[temp_file_name_template_str.length() + 1];\n  memset(temp_file_name_template, 0, temp_file_name_template_str.length() + 1);\n  temp_file_name_template_str.copy(temp_file_name_template,\n                                   temp_file_name_template_str.length(), 0);\n  int fd = mkstemp(temp_file_name_template);\n  std::string temp_file_name =\n      (fd != -1) ? std::string(temp_file_name_template) : std::string();\n  delete[] temp_file_name_template;\n  if (fd != -1) {\n    close(fd);\n  }\n  return temp_file_name;\n#else\n  char tmp_file_name[_MAX_PATH];\n#if defined _MSC_VER || defined MINGW_HAS_SECURE_API\n  errno_t err = tmpnam_s(tmp_file_name);\n#else\n  char* fname_pointer = tmpnam(tmp_file_name);\n  int err = (fname_pointer == &tmp_file_name[0]) ? 0 : -1;\n#endif\n  if (err == 0) {\n    return std::string(tmp_file_name);\n  }\n  return std::string();\n#endif\n}",
        "output": "1",
        "idx": 3047
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void follow_dotdot(struct nameidata *nd)\n{\n\tif (!nd->root.mnt)\n\t\tset_root(nd);\n\n\twhile(1) {\n\t\tstruct dentry *old = nd->path.dentry;\n\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\t/* rare case of legitimate dget_parent()... */\n\t\t\tnd->path.dentry = dget_parent(nd->path.dentry);\n\t\t\tdput(old);\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up(&nd->path))\n\t\t\tbreak;\n\t}\n\tfollow_mount(&nd->path);\n\tnd->inode = nd->path.dentry->d_inode;\n}",
        "output": "1",
        "idx": 1329
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ptrace_setwmmxregs(struct task_struct *tsk, void __user *ufp)\n{\n\tstruct thread_info *thread = task_thread_info(tsk);\n\n\tif (!test_ti_thread_flag(thread, TIF_USING_IWMMXT))\n\t\treturn -EACCES;\n\tiwmmxt_task_release(thread);  /* force a reload */\n\treturn copy_from_user(&thread->fpstate.iwmmxt, ufp, IWMMXT_SIZE)\n\t\t? -EFAULT : 0;\n}",
        "output": "0",
        "idx": 299
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void jas_icclut8_destroy(jas_iccattrval_t *attrval)\n{\n\tjas_icclut8_t *lut8 = &attrval->data.lut8;\n\tif (lut8->clut)\n\t\tjas_free(lut8->clut);\n\tif (lut8->intabs)\n\t\tjas_free(lut8->intabs);\n\tif (lut8->intabsbuf)\n\t\tjas_free(lut8->intabsbuf);\n\tif (lut8->outtabs)\n\t\tjas_free(lut8->outtabs);\n\tif (lut8->outtabsbuf)\n\t\tjas_free(lut8->outtabsbuf);\n}",
        "output": "1",
        "idx": 243
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tkvm_init_mmu(vcpu);\n}",
        "output": "0",
        "idx": 556
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int megasas_handle_dcmd(MegasasState *s, MegasasCmd *cmd)\n{\n    int opcode, len;\n    int retval = 0;\n    const struct dcmd_cmd_tbl_t *cmdptr = dcmd_cmd_tbl;\n\n    opcode = le32_to_cpu(cmd->frame->dcmd.opcode);\n    trace_megasas_handle_dcmd(cmd->index, opcode);\n    len = megasas_map_dcmd(s, cmd);\n    if (len < 0) {\n        return MFI_STAT_MEMORY_NOT_AVAILABLE;\n    }\n    while (cmdptr->opcode != -1 && cmdptr->opcode != opcode) {\n        cmdptr++;\n    }\n    if (cmdptr->opcode == -1) {\n        trace_megasas_dcmd_unhandled(cmd->index, opcode, len);\n        retval = megasas_dcmd_dummy(s, cmd);\n    } else {\n        trace_megasas_dcmd_enter(cmd->index, cmdptr->desc, len);\n        retval = cmdptr->func(s, cmd);\n    }\n    if (retval != MFI_STAT_INVALID_STATUS) {\n        megasas_finish_dcmd(cmd, len);\n    }\n    return retval;\n}",
        "output": "1",
        "idx": 893
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_gnutls_cipher_suite_get_cipher_algo (const cipher_suite_st * suite)\n{\n  int ret = 0;\n  GNUTLS_CIPHER_SUITE_ALG_LOOP (ret = p->block_algorithm);\n  return ret;\n}",
        "output": "0",
        "idx": 1547
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplDoublyLinkedList, current)\n{\n\tspl_dllist_object     *intern  = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tspl_ptr_llist_element *element = intern->traverse_pointer;\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (element == NULL || element->data == NULL) {\n\t\tRETURN_NULL();\n\t} else {\n\t\tzval *data    = (zval *)element->data;\n\t\tRETURN_ZVAL(data, 1, 0);\n\t}\n}",
        "output": "1",
        "idx": 2485
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init xfrm6_tunnel_spi_init(void)\n{\n\txfrm6_tunnel_spi_kmem = kmem_cache_create(\"xfrm6_tunnel_spi\",\n\t\t\t\t\t\t  sizeof(struct xfrm6_tunnel_spi),\n\t\t\t\t\t\t  0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t\t  NULL);\n\tif (!xfrm6_tunnel_spi_kmem)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
        "output": "1",
        "idx": 806
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\nstatic void hda_codec_device_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *k = DEVICE_CLASS(klass);\n    k->realize = hda_codec_dev_realize;\n    k->unrealize = hda_codec_dev_unrealize;\n    set_bit(DEVICE_CATEGORY_SOUND, k->categories);\n    k->bus_type = TYPE_HDA_BUS;\n    device_class_set_props(k, hda_props);",
        "output": "0",
        "idx": 1836
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_new_mask (void)\n{\n    RsvgMask *mask;\n\n    mask = g_new (RsvgMask, 1);\n    _rsvg_node_init (&mask->super, RSVG_NODE_TYPE_MASK);\n    mask->maskunits = objectBoundingBox;\n    mask->contentunits = userSpaceOnUse;\n    mask->x = _rsvg_css_parse_length (\"0\");\n    mask->y = _rsvg_css_parse_length (\"0\");\n    mask->width = _rsvg_css_parse_length (\"1\");\n    mask->height = _rsvg_css_parse_length (\"1\");\n    mask->super.set_atts = rsvg_mask_set_atts;\n    return &mask->super;\n}",
        "output": "0",
        "idx": 1429
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int link_set_ipv4_forward(Link *link) {\n        const char *p = NULL, *v;\n        int r;\n\n        if (link->flags & IFF_LOOPBACK)\n                return 0;\n\n        if (link->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)\n                return 0;\n\n        p = strjoina(\"/proc/sys/net/ipv4/conf/\", link->ifname, \"/forwarding\");\n        v = one_zero(link_ipv4_forward_enabled(link));\n\n        r = write_string_file(p, v, 0);\n        if (r < 0) {\n                /* If the right value is set anyway, don't complain */\n                if (verify_one_line_file(p, v) > 0)\n                        return 0;\n\n                log_link_warning_errno(link, r, \"Cannot configure IPv4 forwarding for interface %s: %m\", link->ifname);\n        }\n\n        return 0;\n}",
        "output": "0",
        "idx": 38
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void fastcall wait_on_page_bit(struct page *page, int bit_nr)\n{\n\tDEFINE_WAIT_BIT(wait, &page->flags, bit_nr);\n\n\tif (test_bit(bit_nr, &page->flags))\n\t\t__wait_on_bit(page_waitqueue(page), &wait, sync_page,\n\t\t\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n}",
        "output": "0",
        "idx": 2797
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uECC_VLI_API void uECC_vli_modSquare_fast(uECC_word_t *result,\n                                          const uECC_word_t *left,\n                                          uECC_Curve curve) {\n    uECC_word_t product[2 * uECC_MAX_WORDS];\n    uECC_vli_square(product, left, curve->num_words);\n#if (uECC_OPTIMIZATION_LEVEL > 0)\n    curve->mmod_fast(result, product);\n#else\n    uECC_vli_mmod(result, product, curve->p, curve->num_words);\n#endif\n}",
        "output": "0",
        "idx": 1088
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,\n\t\t\t\t\tstruct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct vhost_net *n = file->private_data;\n\tstruct vhost_dev *dev = &n->dev;\n\n\treturn vhost_chr_write_iter(dev, from);\n}",
        "output": "0",
        "idx": 3144
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int acpi_smbus_register_callback(struct acpi_smb_hc *hc,\n\t\t\t         smbus_alarm_callback callback, void *context)\n{\n\tmutex_lock(&hc->lock);\n\thc->callback = callback;\n\thc->context = context;\n\tmutex_unlock(&hc->lock);\n\treturn 0;\n}",
        "output": "0",
        "idx": 324
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void warnf(struct GlobalConfig *config, const char *fmt, ...)\n{\n  if(!config->mute) {\n    va_list ap;\n    int len;\n    char *ptr;\n    char print_buffer[256];\n\n    va_start(ap, fmt);\n    len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);\n    va_end(ap);\n\n    ptr = print_buffer;\n    while(len > 0) {\n      fputs(WARN_PREFIX, config->errors);\n\n      if(len > (int)WARN_TEXTWIDTH) {\n        int cut = WARN_TEXTWIDTH-1;\n\n        while(!ISSPACE(ptr[cut]) && cut) {\n          cut--;\n        }\n        if(0 == cut)\n          /* not a single cutting position was found, just cut it at the\n             max text width then! */\n          cut = WARN_TEXTWIDTH-1;\n\n        (void)fwrite(ptr, cut + 1, 1, config->errors);\n        fputs(\"\\n\", config->errors);\n        ptr += cut+1; /* skip the space too */\n        len -= cut;\n      }\n      else {\n        fputs(ptr, config->errors);\n        len = 0;\n      }\n    }\n  }\n}",
        "output": "1",
        "idx": 1198
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dtls1_read_failed(SSL *s, int code)\n\t{\n\tif ( code > 0)\n\t\t{\n\t\tfprintf( stderr, \"invalid state reached %s:%d\", __FILE__, __LINE__);\n\t\treturn 1;\n\t\t}\n\n\tif (!dtls1_is_timer_expired(s))\n\t\t{\n\t\t/* not a timeout, none of our business, \n\t\t   let higher layers handle this.  in fact it's probably an error */\n\t\treturn code;\n\t\t}\n\n\tif ( ! SSL_in_init(s))  /* done, no need to send a retransmit */\n\t\t{\n\t\tBIO_set_flags(SSL_get_rbio(s), BIO_FLAGS_READ);\n\t\treturn code;\n\t\t}\n\n#if 0 /* for now, each alert contains only one record number */\n\titem = pqueue_peek(state->rcvd_records);\n\tif ( item )\n\t\t{\n\t\t/* send an alert immediately for all the missing records */\n\t\t}\n\telse\n#endif\n\n#if 0  /* no more alert sending, just retransmit the last set of messages */\n\tif ( state->timeout.read_timeouts >= DTLS1_TMO_READ_COUNT)\n\t\tssl3_send_alert(s,SSL3_AL_WARNING,\n\t\t\tDTLS1_AD_MISSING_HANDSHAKE_MESSAGE);\n#endif\n\n\treturn dtls1_handle_timeout(s);\n\t}",
        "output": "1",
        "idx": 1616
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t clusterip_proc_write(struct file *file, const char __user *input,\n\t\t\t\tsize_t size, loff_t *ofs)\n{\n\tstruct clusterip_config *c = PDE(file->f_path.dentry->d_inode)->data;\n#define PROC_WRITELEN\t10\n\tchar buffer[PROC_WRITELEN+1];\n\tunsigned long nodenum;\n\n\tif (copy_from_user(buffer, input, PROC_WRITELEN))\n\t\treturn -EFAULT;\n\n\tif (*buffer == '+') {\n\t\tnodenum = simple_strtoul(buffer+1, NULL, 10);\n\t\tif (clusterip_add_node(c, nodenum))\n\t\t\treturn -ENOMEM;\n\t} else if (*buffer == '-') {\n\t\tnodenum = simple_strtoul(buffer+1, NULL,10);\n\t\tif (clusterip_del_node(c, nodenum))\n\t\t\treturn -ENOENT;\n\t} else\n\t\treturn -EIO;\n\n\treturn size;\n}",
        "output": "1",
        "idx": 1720
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Item_param::add_as_clone(THD *thd)\n{\n  LEX *lex= thd->lex;\n  uint master_pos= pos_in_query + lex->clone_spec_offset;\n  List_iterator_fast<Item_param> it(lex->param_list);\n  Item_param *master_param;\n  while ((master_param = it++))\n  {\n    if (master_pos == master_param->pos_in_query)\n      return master_param->register_clone(this);\n  }\n  DBUG_ASSERT(false);\n  return false;\n}",
        "output": "0",
        "idx": 936
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Box *dac3_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);\n\treturn (GF_Box *)tmp;\n}",
        "output": "0",
        "idx": 2
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vmci_transport_notify_send_pre_enqueue(\n\tstruct vsock_sock *vsk,\n\tstruct vsock_transport_send_notify_data *data)\n{\n\treturn vmci_trans(vsk)->notify_ops->send_pre_enqueue(\n\t\t\t&vsk->sk,\n\t\t\t(struct vmci_transport_send_notify_data *)data);\n}",
        "output": "0",
        "idx": 1778
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void clear_file(struct inode *inode, int type)\n{\n\tF2FS_I(inode)->i_advise &= ~type;\n\tf2fs_mark_inode_dirty_sync(inode, true);\n}",
        "output": "0",
        "idx": 1419
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err gf_isom_enable_compression(GF_ISOFile *file, GF_ISOCompressMode compress_mode, u32 compress_flags)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->compress_mode = compress_mode;\n\tfile->compress_flags = compress_flags;\n\treturn GF_OK;\n}",
        "output": "0",
        "idx": 2348
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t rebind_store(struct device_driver *dev, const char *buf,\n\t\t\t\t size_t count)\n{\n\tint ret;\n\tint len;\n\tstruct bus_id_priv *bid;\n\n\t/* buf length should be less that BUSID_SIZE */\n\tlen = strnlen(buf, BUSID_SIZE);\n\n\tif (!(len < BUSID_SIZE))\n\t\treturn -EINVAL;\n\n\tbid = get_busid_priv(buf);\n\tif (!bid)\n\t\treturn -ENODEV;\n\n\t/* mark the device for deletion so probe ignores it during rescan */\n\tbid->status = STUB_BUSID_OTHER;\n\n\tret = do_rebind((char *) buf, bid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* delete device from busid_table */\n\tdel_match_busid((char *) buf);\n\n\treturn count;\n}",
        "output": "1",
        "idx": 355
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "u_save_line(undoline_T *ul, linenr_T lnum)\n{\n    char_u *line = ml_get(lnum);\n\n    if (curbuf->b_ml.ml_line_len == 0)\n    {\n\tul->ul_len = 1;\n\tul->ul_line = vim_strsave((char_u *)\"\");\n    }\n    else\n    {\n\t// This uses the length in the memline, thus text properties are\n\t// included.\n\tul->ul_len = curbuf->b_ml.ml_line_len;\n\tul->ul_line = vim_memsave(line, ul->ul_len);\n    }\n    return ul->ul_line == NULL ? FAIL : OK;\n}",
        "output": "0",
        "idx": 665
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {\n    const Tensor first_partition_tensor =\n        context->input(kFirstPartitionInputIndex);\n    const RowPartitionType first_partition_type = row_partition_types_[0];\n    switch (first_partition_type) {\n      case RowPartitionType::FIRST_DIM_SIZE:\n        *result = first_partition_tensor.scalar<INDEX_TYPE>()();\n        return Status::OK();\n      case RowPartitionType::VALUE_ROWIDS:\n        return errors::InvalidArgument(\n            \"Cannot handle VALUE_ROWIDS in first dimension.\");\n      case RowPartitionType::ROW_SPLITS:\n        *result = first_partition_tensor.shape().dim_size(0) - 1;\n        return Status::OK();\n      default:\n        return errors::InvalidArgument(\n            \"Cannot handle type \",\n            RowPartitionTypeToString(first_partition_type));\n    }\n  }",
        "output": "1",
        "idx": 2811
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void insert_hash(struct audit_chunk *chunk)\n{\n\tstruct list_head *list = chunk_hash(chunk->watch.inode);\n\tlist_add_rcu(&chunk->hash, list);\n}",
        "output": "0",
        "idx": 1156
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dsdb_user_obj_set_account_type(struct ldb_context *ldb, struct ldb_message *usr_obj,\n\t\t\t\t   uint32_t user_account_control, uint32_t *account_type_p)\n{\n\tint ret;\n\tuint32_t account_type;\n\tstruct ldb_message_element *el;\n\n\taccount_type = ds_uf2atype(user_account_control);\n\tif (account_type == 0) {\n\t\tldb_set_errstring(ldb, \"dsdb: Unrecognized account type!\");\n\t\treturn LDB_ERR_UNWILLING_TO_PERFORM;\n\t}\n\tret = samdb_msg_add_uint(ldb, usr_obj, usr_obj,\n\t\t\t\t \"sAMAccountType\",\n\t\t\t\t account_type);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tel = ldb_msg_find_element(usr_obj, \"sAMAccountType\");\n\tel->flags = LDB_FLAG_MOD_REPLACE;\n\n\tif (account_type_p) {\n\t\t*account_type_p = account_type;\n\t}\n\n\treturn LDB_SUCCESS;\n}",
        "output": "1",
        "idx": 1614
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nsc_encode_sse2(NSC_CONTEXT* context, const BYTE* data,\n                            UINT32 scanline)\n{\n\tnsc_encode_argb_to_aycocg_sse2(context, data, scanline);\n\n\tif (context->ChromaSubsamplingLevel > 0)\n\t{\n\t\tnsc_encode_subsampling_sse2(context);\n\t}\n}",
        "output": "1",
        "idx": 2868
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void aesni_xts_enc(void *ctx, u128 *dst, const u128 *src, le128 *iv)\n{\n\tglue_xts_crypt_128bit_one(ctx, dst, src, iv, GLUE_FUNC_CAST(aesni_enc));\n}",
        "output": "0",
        "idx": 3030
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static TValue *trace_exit_cp(lua_State *L, lua_CFunction dummy, void *ud)\n{\n  ExitDataCP *exd = (ExitDataCP *)ud;\n  cframe_errfunc(L->cframe) = -1;  /* Inherit error function. */\n  /* Always catch error here. */\n  cframe_nres(L->cframe) = -2*LUAI_MAXSTACK*(int)sizeof(TValue);\n  exd->pc = lj_snap_restore(exd->J, exd->exptr);\n  UNUSED(dummy);\n  return NULL;\n}",
        "output": "1",
        "idx": 486
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int SSL_renegotiate(SSL *s)\n{\n    if (s->renegotiate == 0)\n        s->renegotiate = 1;\n\n    s->new_session = 1;\n\n    return (s->method->ssl_renegotiate(s));\n}",
        "output": "0",
        "idx": 2054
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint32_t TProtocol::skip_virt(TType type) {\n  return ::apache::thrift::protocol::skip(*this, type);\n}",
        "output": "0",
        "idx": 1044
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(\n    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,\n    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {\n  ASSERT(codec_client_ != nullptr);\n  // Send the request to Envoy.\n  IntegrationStreamDecoderPtr response;\n  if (request_body_size) {\n    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);\n  } else {\n    response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  }\n  waitForNextUpstreamRequest(upstream_index);\n  // Send response headers, and end_stream if there is no response body.\n  upstream_request_->encodeHeaders(response_headers, response_size == 0);\n  // Send any response data, with end_stream true.\n  if (response_size) {\n    upstream_request_->encodeData(response_size, true);\n  }\n  // Wait for the response to be read by the codec client.\n  response->waitForEndStream();\n  return response;\n}",
        "output": "1",
        "idx": 3037
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ex_open(exarg_T *eap)\n{\n    regmatch_T\tregmatch;\n    char_u\t*p;\n\n#ifdef FEAT_EVAL\n    if (not_in_vim9(eap) == FAIL)\n\treturn;\n#endif\n    curwin->w_cursor.lnum = eap->line2;\n    beginline(BL_SOL | BL_FIX);\n    if (*eap->arg == '/')\n    {\n\t// \":open /pattern/\": put cursor in column found with pattern\n\t++eap->arg;\n\tp = skip_regexp(eap->arg, '/', magic_isset());\n\t*p = NUL;\n\tregmatch.regprog = vim_regcomp(eap->arg, magic_isset() ? RE_MAGIC : 0);\n\tif (regmatch.regprog != NULL)\n\t{\n\t    regmatch.rm_ic = p_ic;\n\t    p = ml_get_curline();\n\t    if (vim_regexec(&regmatch, p, (colnr_T)0))\n\t\tcurwin->w_cursor.col = (colnr_T)(regmatch.startp[0] - p);\n\t    else\n\t\temsg(_(e_nomatch));\n\t    vim_regfree(regmatch.regprog);\n\t}\n\t// Move to the NUL, ignore any other arguments.\n\teap->arg += STRLEN(eap->arg);\n    }\n    check_cursor();\n\n    eap->cmdidx = CMD_visual;\n    do_exedit(eap, NULL);\n}",
        "output": "1",
        "idx": 660
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,\n\t\t\t\t\tstruct ath10k_urb_context *urb_context)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);\n\n\tpipe->urb_cnt++;\n\tlist_add(&urb_context->link, &pipe->urb_list_head);\n\n\tspin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);\n}",
        "output": "1",
        "idx": 465
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    WriterProxyData(\n            size_t max_unicast_locators,\n            size_t max_multicast_locators,\n            const VariableLengthDataLimits& data_limits)\n        : remote_locators_(max_unicast_locators, max_multicast_locators)\n        , topic_kind_(NO_KEY)\n        , is_alive_(true)\n        , type_id_()\n        , type_()\n        , type_info_()\n        , m_typeMaxSerialized(0)\n        , m_userDefinedId(0)\n    {\n        m_qos.m_userData.set_max_size((uint32_t)data_limits.max_user_data);\n        m_qos.m_partition.set_max_size((uint32_t)data_limits.max_partitions);\n    }",
        "output": "0",
        "idx": 2428
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,\n\t\tjson_t *proto_state, const char *error, const char *error_description) {\n\tconst char *prompt =\n\t\t\tjson_object_get(proto_state, \"prompt\") ?\n\t\t\t\t\tapr_pstrdup(r->pool,\n\t\t\t\t\t\t\tjson_string_value(\n\t\t\t\t\t\t\t\t\tjson_object_get(proto_state, \"prompt\"))) :\n\t\t\t\t\t\t\t\t\tNULL;\n\tjson_decref(proto_state);\n\tif ((prompt != NULL) && (apr_strnatcmp(prompt, \"none\") == 0)) {\n\t\treturn oidc_session_redirect_parent_window_to_logout(r, c);\n\t}\n\treturn oidc_util_html_send_error(r, c->error_template,\n\t\t\tapr_psprintf(r->pool, \"OpenID Connect Provider error: %s\", error),\n\t\t\terror_description, DONE);\n}",
        "output": "0",
        "idx": 2652
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ldb_kv_guid_to_key(struct ldb_module *module,\n\t\t       struct ldb_kv_private *ldb_kv,\n\t\t       const struct ldb_val *GUID_val,\n\t\t       struct ldb_val *key)\n{\n\tconst char *GUID_prefix = LDB_KV_GUID_KEY_PREFIX;\n\tconst int GUID_prefix_len = sizeof(LDB_KV_GUID_KEY_PREFIX) - 1;\n\n\tif (key->length != (GUID_val->length+GUID_prefix_len)) {\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n\n\tmemcpy(key->data, GUID_prefix, GUID_prefix_len);\n\tmemcpy(&key->data[GUID_prefix_len],\n\t       GUID_val->data, GUID_val->length);\n\treturn LDB_SUCCESS;\n}",
        "output": "0",
        "idx": 2636
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_event_reset(struct perf_event *event)\n{\n\t(void)perf_event_read(event);\n\tlocal64_set(&event->count, 0);\n\tperf_event_update_userpage(event);\n}",
        "output": "1",
        "idx": 1730
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Field_iterator_table_ref::set(TABLE_LIST *table)\n{\n  DBUG_ASSERT(table);\n  first_leaf= table->first_leaf_for_name_resolution();\n  last_leaf=  table->last_leaf_for_name_resolution();\n  DBUG_ASSERT(first_leaf && last_leaf);\n  table_ref= first_leaf;\n  set_field_iterator();\n}",
        "output": "0",
        "idx": 1460
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "drv_initpair(TERMINAL_CONTROL_BLOCK * TCB, int pair, int f, int b)\n{\n    SCREEN *sp;\n\n    AssertTCB();\n    SetSP();\n\n    if ((initialize_pair != NULL) && InPalette(f) && InPalette(b)) {\n\tconst color_t *tp = InfoOf(sp).defaultPalette;\n\n\tTR(TRACE_ATTRS,\n\t   (\"initializing pair: pair = %d, fg=(%d,%d,%d), bg=(%d,%d,%d)\",\n\t    pair,\n\t    tp[f].red, tp[f].green, tp[f].blue,\n\t    tp[b].red, tp[b].green, tp[b].blue));\n\n\tNCURSES_PUTP2(\"initialize_pair\",\n\t\t      TPARM_7(initialize_pair,\n\t\t\t      pair,\n\t\t\t      tp[f].red, tp[f].green, tp[f].blue,\n\t\t\t      tp[b].red, tp[b].green, tp[b].blue));\n    }\n}",
        "output": "1",
        "idx": 1397
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tg3_ptp_init(struct tg3 *tp)\n{\n\tif (!tg3_flag(tp, PTP_CAPABLE))\n\t\treturn;\n\n\t/* Initialize the hardware clock to the system time. */\n\ttg3_refclk_write(tp, ktime_to_ns(ktime_get_real()));\n\ttp->ptp_adjust = 0;\n\ttp->ptp_info = tg3_ptp_caps;\n}",
        "output": "0",
        "idx": 526
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gui_bg_default(void)\n{\n    if (gui_get_lightness(gui.back_pixel) < 127)\n\treturn (char_u *)\"dark\";\n    return (char_u *)\"light\";\n}",
        "output": "0",
        "idx": 2608
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline TfLiteTensor* GetTemporary(TfLiteContext* context,\n                                  const TfLiteNode* node, int index) {\n  return &context->tensors[node->temporaries->data[index]];\n}",
        "output": "1",
        "idx": 224
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int am_check_url(request_rec *r, const char *url)\n{\n    const char *i;\n\n    for (i = url; *i; i++) {\n        if (*i >= 0 && *i < ' ') {\n            /* Deny all control-characters. */\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                          \"Control character detected in URL.\");\n            return HTTP_BAD_REQUEST;\n        }\n    }\n\n    return OK;\n}",
        "output": "1",
        "idx": 2104
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void write_regvals(struct sd *sd,\n\t\t\t const struct ov_regvals *regvals,\n\t\t\t int n)\n{\n\twhile (--n >= 0) {\n\t\treg_w(sd, regvals->reg, regvals->val);\n\t\tregvals++;\n\t}\n}",
        "output": "0",
        "idx": 1766
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool asn1_read_OctetString(struct asn1_data *data, TALLOC_CTX *mem_ctx, DATA_BLOB *blob)\n{\n\tint len;\n\tZERO_STRUCTP(blob);\n\tif (!asn1_start_tag(data, ASN1_OCTET_STRING)) return false;\n\tlen = asn1_tag_remaining(data);\n\tif (len < 0) {\n\t\tdata->has_error = true;\n\t\treturn false;\n\t}\n\t*blob = data_blob_talloc(mem_ctx, NULL, len+1);\n\tif (!blob->data || blob->length < len) {\n\t\tdata->has_error = true;\n\t\treturn false;\n\t}\n\tasn1_read(data, blob->data, len);\n\tasn1_end_tag(data);\n\tblob->length--;\n\tblob->data[len] = 0;\n\t\n\tif (data->has_error) {\n\t\tdata_blob_free(blob);\n\t\t*blob = data_blob_null;\n\t\treturn false;\n\t}\n\treturn true;\n}",
        "output": "1",
        "idx": 3174
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                const TfLiteTensor* data,\n                                const TfLiteTensor* segment_ids,\n                                TfLiteTensor* output) {\n  int max_index = -1;\n  const int segment_id_size = segment_ids->dims->data[0];\n  if (segment_id_size > 0) {\n    max_index = segment_ids->data.i32[segment_id_size - 1];\n  }\n  const int data_rank = NumDimensions(data);\n  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(data));\n  output_shape->data[0] = max_index + 1;\n  for (int i = 1; i < data_rank; ++i) {\n    output_shape->data[i] = data->dims->data[i];\n  }\n  return context->ResizeTensor(context, output, output_shape);\n}",
        "output": "1",
        "idx": 3051
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "EC_GROUP *EC_GROUP_new(const EC_METHOD *meth)\n{\n    EC_GROUP *ret;\n\n    if (meth == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW, EC_R_SLOT_FULL);\n        return NULL;\n    }\n    if (meth->group_init == 0) {\n        ECerr(EC_F_EC_GROUP_NEW, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);\n        return NULL;\n    }\n\n    ret = OPENSSL_zalloc(sizeof(*ret));\n    if (ret == NULL) {\n        ECerr(EC_F_EC_GROUP_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    ret->meth = meth;\n    if ((ret->meth->flags & EC_FLAGS_CUSTOM_CURVE) == 0) {\n        ret->order = BN_new();\n        if (ret->order == NULL)\n            goto err;\n        ret->cofactor = BN_new();\n        if (ret->cofactor == NULL)\n            goto err;\n    }\n    ret->asn1_flag = OPENSSL_EC_NAMED_CURVE;\n    ret->asn1_form = POINT_CONVERSION_UNCOMPRESSED;\n    if (!meth->group_init(ret))\n        goto err;\n    return ret;\n\n err:\n    BN_free(ret->order);\n    BN_free(ret->cofactor);\n    OPENSSL_free(ret);\n    return NULL;\n}",
        "output": "0",
        "idx": 2583
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cmsStage* _cmsStageNormalizeFromLabFloat(cmsContext ContextID)\n{\n    static const cmsFloat64Number a1[] = {\n        1.0/100.0, 0, 0,\n        0, 1.0/255.0, 0,\n        0, 0, 1.0/255.0\n    };\n\n    static const cmsFloat64Number o1[] = {\n        0,\n        128.0/255.0,\n        128.0/255.0\n    };\n\n    cmsStage *mpe = cmsStageAllocMatrix(ContextID, 3, 3, a1, o1);\n\n    if (mpe == NULL) return mpe;\n    mpe ->Implements = cmsSigLab2FloatPCS;\n    return mpe;\n}",
        "output": "0",
        "idx": 1611
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " */\nstatic bool bfq_may_expire_for_budg_timeout(struct bfq_queue *bfqq)\n{\n\tbfq_log_bfqq(bfqq->bfqd, bfqq,\n\t\t\"may_budget_timeout: wait_request %d left %d timeout %d\",\n\t\tbfq_bfqq_wait_request(bfqq),\n\t\t\tbfq_bfqq_budget_left(bfqq) >=  bfqq->entity.budget / 3,\n\t\tbfq_bfqq_budget_timeout(bfqq));\n\n\treturn (!bfq_bfqq_wait_request(bfqq) ||\n\t\tbfq_bfqq_budget_left(bfqq) >=  bfqq->entity.budget / 3)\n\t\t&&\n\t\tbfq_bfqq_budget_timeout(bfqq);",
        "output": "0",
        "idx": 3031
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    void writeBytes(const void* data, int length) {\n      check(length);\n      memcpy(ptr, data, length);\n      ptr += length;\n    }",
        "output": "1",
        "idx": 1683
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "connection_changes_done (gpointer data)\n{\n\tConnectionChangedInfo *info = (ConnectionChangedInfo *) data;\n\tNMAGConfSettingsPrivate *priv = NMA_GCONF_SETTINGS_GET_PRIVATE (info->settings);\n\tNMAGConfConnection *connection;\n\n\tconnection = nma_gconf_settings_get_by_path (info->settings, info->path);\n\tif (!connection) {\n\t\t/* New connection */\n\t\tconnection = nma_gconf_connection_new (priv->client, info->path);\n\t\tadd_connection_real (info->settings, connection);\n\t} else {\n\t\tif (gconf_client_dir_exists (priv->client, info->path, NULL)) {\n\t\t\t/* Updated connection */\n\t\t\tif (!nma_gconf_connection_changed (connection))\n\t\t\t\tpriv->connections = g_slist_remove (priv->connections, connection);\n\t\t}\n\t}\n\n\tg_hash_table_remove (priv->pending_changes, info->path);\n\n\treturn FALSE;\n}",
        "output": "1",
        "idx": 2706
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void enable_kernel_spe(void)\n{\n\tWARN_ON(preemptible());\n\n\tmsr_check_and_set(MSR_SPE);\n\n\tif (current->thread.regs && (current->thread.regs->msr & MSR_SPE)) {\n\t\tcheck_if_tm_restore_required(current);\n\t\t__giveup_spe(current);\n\t}\n}",
        "output": "0",
        "idx": 1863
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int display_open(void *handle, void *device)\n{\n\n    IMAGE *img = (IMAGE *)malloc(sizeof(IMAGE));\n    if (img == NULL)\n        return -1;\n    memset(img, 0, sizeof(IMAGE));\n\n    if (first_image == NULL) {\n        gdk_rgb_init();\n        gtk_widget_set_default_colormap(gdk_rgb_get_cmap());\n        gtk_widget_set_default_visual(gdk_rgb_get_visual());\n    }\n\n    /* add to list */\n    if (first_image)\n        img->next = first_image;\n    first_image = img;\n\n    /* remember device and handle */\n    img->handle = handle;\n    img->device = device;\n\n    /* create window */\n    window_create(img);\n\n    gtk_main_iteration_do(FALSE);\n    return 0;\n}",
        "output": "1",
        "idx": 558
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_nc_find_user_entry(const char *string)\n{\n    const HashData *data = _nc_get_hash_user();\n    int hashvalue;\n    struct user_table_entry const *ptr = 0;\n    struct user_table_entry const *real_table;\n\n    hashvalue = data->hash_of(string);\n\n    if (data->table_data[hashvalue] >= 0) {\n\n\treal_table = _nc_get_userdefs_table();\n\tptr = real_table + data->table_data[hashvalue];\n\twhile (!data->compare_names(ptr->ute_name, string)) {\n\t    if (ptr->ute_link < 0) {\n\t\tptr = 0;\n\t\tbreak;\n\t    }\n\t    ptr = real_table + (ptr->ute_link\n\t\t\t\t+ data->table_data[data->table_size]);\n\t}\n    }\n\n    return (ptr);\n}",
        "output": "1",
        "idx": 3160
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void free_urlhandle(struct Curl_URL *u)\n{\n  free(u->scheme);\n  free(u->user);\n  free(u->password);\n  free(u->options);\n  free(u->host);\n  free(u->zoneid);\n  free(u->port);\n  free(u->path);\n  free(u->query);\n  free(u->fragment);\n  free(u->scratch);\n  free(u->temppath);\n}",
        "output": "0",
        "idx": 383
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pattern_get_fallback (gpointer data)\n{\n    RsvgPattern *pattern = data;\n\n    return pattern->fallback;\n}",
        "output": "1",
        "idx": 1931
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err ftyp_Write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_FileTypeBox *ptr = (GF_FileTypeBox *) s;\n\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->majorBrand);\n\tgf_bs_write_u32(bs, ptr->minorVersion);\n\tfor (i=0; i<ptr->altCount; i++) {\n\t\tgf_bs_write_u32(bs, ptr->altBrand[i]);\n\t}\n\treturn GF_OK;\n}",
        "output": "0",
        "idx": 1900
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ct_list_items(struct media_player *mp, const char *name,\n\t\t\t\tuint32_t start, uint32_t end, void *user_data)\n{\n\tstruct avrcp_player *player = user_data;\n\tstruct avrcp *session;\n\tstruct pending_list_items *p;\n\n\tif (player->p != NULL)\n\t\treturn -EBUSY;\n\n\tsession = player->sessions->data;\n\n\tset_ct_player(session, player);\n\n\tif (g_str_has_prefix(name, \"/NowPlaying\"))\n\t\tplayer->scope = 0x03;\n\telse if (g_str_has_suffix(name, \"/search\"))\n\t\tplayer->scope = 0x02;\n\telse\n\t\tplayer->scope = 0x01;\n\n\tavrcp_list_items(session, start, end);\n\n\tp = g_new0(struct pending_list_items, 1);\n\tp->start = start;\n\tp->end = end;\n\tp->total = (uint64_t) (p->end - p->start) + 1;\n\tplayer->p = p;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 458
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int RGWListBucketMultiparts_ObjStore::get_params()\n{\n  delimiter = s->info.args.get(\"delimiter\");\n  prefix = s->info.args.get(\"prefix\");\n  string str = s->info.args.get(\"max-uploads\");\n  op_ret = parse_value_and_bound(str, &max_uploads, 0, g_conf()->rgw_max_listing_results, default_max);\n  if (op_ret < 0) {\n    return op_ret;\n  }\n\n  string key_marker = s->info.args.get(\"key-marker\");\n  string upload_id_marker = s->info.args.get(\"upload-id-marker\");\n  if (!key_marker.empty())\n    marker.init(key_marker, upload_id_marker);\n\n  return 0;\n}",
        "output": "1",
        "idx": 3428
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct output_pixel_processor *dce80_opp_create(\n\tstruct dc_context *ctx,\n\tuint32_t inst)\n{\n\tstruct dce110_opp *opp =\n\t\tkzalloc(sizeof(struct dce110_opp), GFP_KERNEL);\n\n\tif (!opp)\n\t\treturn NULL;\n\n\tdce110_opp_construct(opp,\n\t\t\t     ctx, inst, &opp_regs[inst], &opp_shift, &opp_mask);\n\treturn &opp->base;\n}",
        "output": "0",
        "idx": 2549
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hostkey_method_ssh_rsa_init(LIBSSH2_SESSION * session,\n                            const unsigned char *hostkey_data,\n                            size_t hostkey_data_len,\n                            void **abstract)\n{\n    libssh2_rsa_ctx *rsactx;\n    const unsigned char *s, *e, *n;\n    unsigned long len, e_len, n_len;\n    int ret;\n\n    (void) hostkey_data_len;\n\n    if(*abstract) {\n        hostkey_method_ssh_rsa_dtor(session, abstract);\n        *abstract = NULL;\n    }\n\n    s = hostkey_data;\n    len = _libssh2_ntohu32(s);\n    s += 4;\n\n    if(len != 7 || strncmp((char *) s, \"ssh-rsa\", 7) != 0) {\n        return -1;\n    }\n    s += 7;\n\n    e_len = _libssh2_ntohu32(s);\n    s += 4;\n\n    e = s;\n    s += e_len;\n    n_len = _libssh2_ntohu32(s);\n    s += 4;\n    n = s;\n\n    ret = _libssh2_rsa_new(&rsactx, e, e_len, n, n_len, NULL, 0,\n                           NULL, 0, NULL, 0, NULL, 0, NULL, 0, NULL, 0);\n    if(ret) {\n        return -1;\n    }\n\n    *abstract = rsactx;\n\n    return 0;\n}",
        "output": "1",
        "idx": 3673
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_archive_write_data(struct archive *_a, const void *buff, size_t s)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_DATA, \"archive_write_data\");\n\tarchive_clear_error(&a->archive);\n\treturn ((a->format_write_data)(a, buff, s));\n}",
        "output": "1",
        "idx": 2676
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pcpu_extend_area_map(struct pcpu_chunk *chunk, int new_alloc)\n{\n\tint *old = NULL, *new = NULL;\n\tsize_t old_size = 0, new_size = new_alloc * sizeof(new[0]);\n\tunsigned long flags;\n\n\tnew = pcpu_mem_zalloc(new_size);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\t/* acquire pcpu_lock and switch to new area map */\n\tspin_lock_irqsave(&pcpu_lock, flags);\n\n\tif (new_alloc <= chunk->map_alloc)\n\t\tgoto out_unlock;\n\n\told_size = chunk->map_alloc * sizeof(chunk->map[0]);\n\told = chunk->map;\n\n\tmemcpy(new, old, old_size);\n\n\tchunk->map_alloc = new_alloc;\n\tchunk->map = new;\n\tnew = NULL;\n\nout_unlock:\n\tspin_unlock_irqrestore(&pcpu_lock, flags);\n\n\t/*\n\t * pcpu_mem_free() might end up calling vfree() which uses\n\t * IRQ-unsafe lock and thus can't be called under pcpu_lock.\n\t */\n\tpcpu_mem_free(old);\n\tpcpu_mem_free(new);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 2409
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct btrfs_device *find_device(struct btrfs_fs_devices *fs_devices,\n\t\tu64 devid, const u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\n\tlist_for_each_entry(dev, &fs_devices->devices, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}",
        "output": "1",
        "idx": 2513
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MagickExport void RemoveDuplicateLayers(Image **images,\n     ExceptionInfo *exception)\n{\n  register Image\n    *curr,\n    *next;\n\n  RectangleInfo\n    bounds;\n\n  assert((*images) != (const Image *) NULL);\n  assert((*images)->signature == MagickCoreSignature);\n  if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*images)->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n\n  curr=GetFirstImageInList(*images);\n  for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)\n  {\n    if ( curr->columns != next->columns || curr->rows != next->rows\n         || curr->page.x != next->page.x || curr->page.y != next->page.y )\n      continue;\n    bounds=CompareImagesBounds(curr,next,CompareAnyLayer,exception);\n    if ( bounds.x < 0 ) {\n      /*\n        the two images are the same, merge time delays and delete one.\n      */\n      size_t time;\n      time = curr->delay*1000/curr->ticks_per_second;\n      time += next->delay*1000/next->ticks_per_second;\n      next->ticks_per_second = 100L;\n      next->delay = time*curr->ticks_per_second/1000;\n      next->iterations = curr->iterations;\n      *images = curr;\n      (void) DeleteImageFromList(images);\n    }\n  }\n  *images = GetFirstImageInList(*images);\n}",
        "output": "1",
        "idx": 2029
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {\n    xmlXPathObjectPtr ret;\n\n    if (start == NULL)\n\treturn(NULL);\n    if (end == NULL)\n\treturn(NULL);\n\n    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));\n    if (ret == NULL) {\n        xmlXPtrErrMemory(\"allocating range\");\n\treturn(NULL);\n    }\n    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));\n    ret->type = XPATH_RANGE;\n    ret->user = start;\n    ret->index = -1;\n    ret->user2 = end;\n    ret->index2 = -1;\n    xmlXPtrRangeCheckOrder(ret);\n    return(ret);\n}",
        "output": "1",
        "idx": 1209
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u32 esp4_get_mtu(struct xfrm_state *x, int mtu)\n{\n\tstruct esp_data *esp = x->data;\n\tu32 blksize = ALIGN(crypto_aead_blocksize(esp->aead), 4);\n\tu32 align = max_t(u32, blksize, esp->padlen);\n\tu32 rem;\n\n\tmtu -= x->props.header_len + crypto_aead_authsize(esp->aead);\n\trem = mtu & (align - 1);\n\tmtu &= ~(align - 1);\n\n\tswitch (x->props.mode) {\n\tcase XFRM_MODE_TUNNEL:\n\t\tbreak;\n\tdefault:\n\tcase XFRM_MODE_TRANSPORT:\n\t\t/* The worst case */\n\t\tmtu -= blksize - 4;\n\t\tmtu += min_t(u32, blksize - 4, rem);\n\t\tbreak;\n\tcase XFRM_MODE_BEET:\n\t\t/* The worst case. */\n\t\tmtu += min_t(u32, IPV4_BEET_PHMAXLEN, rem);\n\t\tbreak;\n\t}\n\n\treturn mtu - 2;\n}",
        "output": "0",
        "idx": 3029
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void AbstractSqlStorage::addConnectionToPool()\n{\n    QMutexLocker locker(&_connectionPoolMutex);\n    // we have to recheck if the connection pool already contains a connection for\n    // this thread. Since now (after the lock) we can only tell for sure\n    if (_connectionPool.contains(QThread::currentThread()))\n        return;\n\n    QThread *currentThread = QThread::currentThread();\n\n    int connectionId = _nextConnectionId++;\n\n    Connection *connection = new Connection(QLatin1String(QString(\"quassel_%1_con_%2\").arg(driverName()).arg(connectionId).toLatin1()));\n    connection->moveToThread(currentThread);\n    connect(this, SIGNAL(destroyed()), connection, SLOT(deleteLater()));\n    connect(currentThread, SIGNAL(destroyed()), connection, SLOT(deleteLater()));\n    connect(connection, SIGNAL(destroyed()), this, SLOT(connectionDestroyed()));\n    _connectionPool[currentThread] = connection;\n\n    QSqlDatabase db = QSqlDatabase::addDatabase(driverName(), connection->name());\n    db.setDatabaseName(databaseName());\n\n    if (!hostName().isEmpty())\n        db.setHostName(hostName());\n\n    if (port() != -1)\n        db.setPort(port());\n\n    if (!userName().isEmpty()) {\n        db.setUserName(userName());\n        db.setPassword(password());\n    }\n\n    if (!db.open()) {\n        qWarning() << \"Unable to open database\" << displayName() << \"for thread\" << QThread::currentThread();\n        qWarning() << \"-\" << db.lastError().text();\n    }\n    else {\n        initDbSession(db);\n    }\n}",
        "output": "1",
        "idx": 3637
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "copy_mml(MinMaxLen* to, MinMaxLen* from)\n{\n  to->min = from->min;\n  to->max = from->max;\n}",
        "output": "0",
        "idx": 3249
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "datetime_s_iso8601(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE str, sg;\n\n    rb_scan_args(argc, argv, \"02\", &str, &sg);\n\n    switch (argc) {\n      case 0:\n\tstr = rb_str_new2(\"-4712-01-01T00:00:00+00:00\");\n      case 1:\n\tsg = INT2FIX(DEFAULT_SG);\n    }\n\n    {\n\tVALUE hash = date_s__iso8601(klass, str);\n\treturn dt_new_by_frags(klass, hash, sg);\n    }\n}",
        "output": "1",
        "idx": 2176
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "      DSA_Signature_Operation(const DSA_PrivateKey& dsa,\n                              const std::string& emsa,\n                              RandomNumberGenerator& rng) :\n         PK_Ops::Signature_with_EMSA(emsa),\n         m_group(dsa.get_group()),\n         m_x(dsa.get_x()),\n         m_mod_q(dsa.group_q())\n         {\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n         m_rfc6979_hash = hash_for_emsa(emsa);\n#endif\n\n         m_b = BigInt::random_integer(rng, 2, dsa.group_q());\n         m_b_inv = inverse_mod(m_b, dsa.group_q());\n         }",
        "output": "0",
        "idx": 2452
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void php_do_pcre_match(INTERNAL_FUNCTION_PARAMETERS, int global) /* {{{ */\n{\n\t/* parameters */\n\tchar\t\t\t *regex;\t\t\t/* Regular expression */\n\tchar\t\t\t *subject;\t\t\t/* String to match against */\n\tint\t\t\t\t  regex_len;\n\tint\t\t\t\t  subject_len;\n\tpcre_cache_entry *pce;\t\t\t\t/* Compiled regular expression */\n\tzval\t\t\t *subpats = NULL;\t/* Array for subpatterns */\n\tlong\t\t\t  flags = 0;\t\t/* Match control flags */\n\tlong\t\t\t  start_offset = 0;\t/* Where the new search starts */\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss|zll\", &regex, &regex_len,\n\t\t\t\t\t\t\t  &subject, &subject_len, &subpats, &flags, &start_offset) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\t\n\t/* Compile regex or get it from cache. */\n\tif ((pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tphp_pcre_match_impl(pce, subject, subject_len, return_value, subpats, \n\t\tglobal, ZEND_NUM_ARGS() >= 4, flags, start_offset TSRMLS_CC);\n}",
        "output": "1",
        "idx": 1582
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,\n                 LYS_NODE type, const struct lys_node **ret)\n{\n    const struct lys_node *node;\n\n    assert((mod || parent) && name);\n    assert(!(type & (LYS_AUGMENT | LYS_USES | LYS_GROUPING | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));\n\n    if (!mod) {\n        mod = lys_node_module(parent);\n    }\n\n    /* try to find the node */\n    node = NULL;\n    while ((node = lys_getnext(node, parent, mod, 0))) {\n        if (!type || (node->nodetype & type)) {\n            /* module check */\n            if (lys_node_module(node) != lys_main_module(mod)) {\n                continue;\n            }\n\n            /* direct name check */\n            if (!strncmp(node->name, name, nam_len) && !node->name[nam_len]) {\n                if (ret) {\n                    *ret = node;\n                }\n                return EXIT_SUCCESS;\n            }\n        }\n    }\n\n    return EXIT_FAILURE;\n}",
        "output": "1",
        "idx": 504
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int yr_re_ast_create(\n    RE_AST** re_ast)\n{\n  *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));\n\n  if (*re_ast == NULL)\n    return ERROR_INSUFFICIENT_MEMORY;\n\n  (*re_ast)->flags = 0;\n  (*re_ast)->root_node = NULL;\n\n  return ERROR_SUCCESS;\n}",
        "output": "1",
        "idx": 2260
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ecall_restore(const char *input, uint64_t input_len, char **output,\n                  uint64_t *output_len) {\n  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,\n                                                              input_len) ||\n      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(\n          output_len, sizeof(uint64_t))) {\n    asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"ecall_restore: input/output found to not be in untrusted memory.\");\n  }\n  int result = 0;\n  size_t tmp_output_len;\n  try {\n    result = asylo::Restore(input, static_cast<size_t>(input_len), output,\n                            &tmp_output_len);\n  } catch (...) {\n    LOG(FATAL) << \"Uncaught exception in enclave\";\n  }\n\n  if (output_len) {\n    *output_len = static_cast<uint64_t>(tmp_output_len);\n  }\n  return result;\n}",
        "output": "1",
        "idx": 1104
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xsltParseTemplateContent(xsltStylesheetPtr style, xmlNodePtr templ) {\n    if ((style == NULL) || (templ == NULL))\n\treturn;\n\n    /*\n    * Detection of handled content of extension instructions.\n    */\n    if (XSLT_CCTXT(style)->inode->category == XSLT_ELEMENT_CATEGORY_EXTENSION) {\n\tXSLT_CCTXT(style)->inode->extContentHandled = 1;\n    }\n\n    if (templ->children != NULL) {\t\n\txmlNodePtr child = templ->children;\n\t/*\n\t* Process xsl:param elements, which can only occur as the\n\t* immediate children of xsl:template (well, and of any\n\t* user-defined extension instruction if needed).\n\t*/\t\n\tdo {\n\t    if ((child->type == XML_ELEMENT_NODE) &&\n\t\tIS_XSLT_ELEM_FAST(child) &&\n\t\tIS_XSLT_NAME(child, \"param\"))\n\t    {\n\t\tXSLT_CCTXT(style)->inode->curChildType = XSLT_FUNC_PARAM;\n\t\txsltParseAnyXSLTElem(XSLT_CCTXT(style), child);\n\t    } else\n\t\tbreak;\n\t    child = child->next;\n\t} while (child != NULL);\n\t/*\n\t* Parse the content and register the pattern.\n\t*/\n\txsltParseSequenceConstructor(XSLT_CCTXT(style), child);\n    }\n}",
        "output": "1",
        "idx": 1996
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    //! Return a reference to an empty image \\const.\n    static const CImg<T>& const_empty() {\n      static const CImg<T> _empty;\n      return _empty;",
        "output": "0",
        "idx": 3075
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int atl2_set_features(struct net_device *netdev,\n\tnetdev_features_t features)\n{\n\tnetdev_features_t changed = netdev->features ^ features;\n\n\tif (changed & NETIF_F_HW_VLAN_CTAG_RX)\n\t\tatl2_vlan_mode(netdev, features);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2008
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "EventNotifier *virtio_queue_get_guest_notifier(VirtQueue *vq)\n{\n    return &vq->guest_notifier;\n}",
        "output": "0",
        "idx": 418
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static pyc_object *get_binary_float_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tdouble f;\n\n\tf = get_float64 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_FLOAT;\n\tret->data = r_str_newf (\"%.15g\", f);\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
        "output": "0",
        "idx": 1548
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int MGF1(unsigned char *mask, long len, const unsigned char *seed, long seedlen)\n\t{\n\treturn PKCS1_MGF1(mask, len, seed, seedlen, EVP_sha1());\n\t}",
        "output": "0",
        "idx": 80
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void hci_le_direct_adv_report_evt(struct hci_dev *hdev,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tu8 num_reports = skb->data[0];\n\tvoid *ptr = &skb->data[1];\n\n\thci_dev_lock(hdev);\n\n\twhile (num_reports--) {\n\t\tstruct hci_ev_le_direct_adv_info *ev = ptr;\n\n\t\tprocess_adv_report(hdev, ev->evt_type, &ev->bdaddr,\n\t\t\t\t   ev->bdaddr_type, &ev->direct_addr,\n\t\t\t\t   ev->direct_addr_type, ev->rssi, NULL, 0);\n\n\t\tptr += sizeof(*ev);\n\t}\n\n\thci_dev_unlock(hdev);\n}",
        "output": "1",
        "idx": 1493
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F(RouterTest, MissingRequiredHeaders) {\n  NiceMock<Http::MockRequestEncoder> encoder;\n  Http::ResponseDecoder* response_decoder = nullptr;\n  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _))\n      .WillOnce(Invoke(\n          [&](Http::ResponseDecoder& decoder,\n              Http::ConnectionPool::Callbacks& callbacks) -> Http::ConnectionPool::Cancellable* {\n            response_decoder = &decoder;\n            callbacks.onPoolReady(encoder, cm_.thread_local_cluster_.conn_pool_.host_,\n                                  upstream_stream_info_, Http::Protocol::Http10);\n            return nullptr;\n          }));\n  expectResponseTimerCreate();\n\n  Http::TestRequestHeaderMapImpl headers;\n  HttpTestUtility::addDefaultHeaders(headers);\n  headers.removeMethod();\n\n  EXPECT_CALL(encoder, encodeHeaders(_, _))\n      .WillOnce(Invoke([](const Http::RequestHeaderMap& headers, bool) -> Http::Status {\n        return Http::HeaderUtility::checkRequiredRequestHeaders(headers);\n      }));\n  EXPECT_CALL(\n      callbacks_,\n      sendLocalReply(Http::Code::ServiceUnavailable,\n                     testing::Eq(\"missing required header: :method\"), _, _,\n                     \"filter_removed_required_request_headers{missing required header: :method}\"))\n      .WillOnce(testing::InvokeWithoutArgs([] {}));\n  router_.decodeHeaders(headers, true);\n  router_.onDestroy();\n}",
        "output": "1",
        "idx": 173
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vhost_scsi_send_evt(struct vhost_scsi *vs,\n\t\t   struct vhost_scsi_tpg *tpg,\n\t\t   struct se_lun *lun,\n\t\t   u32 event,\n\t\t   u32 reason)\n{\n\tstruct vhost_scsi_evt *evt;\n\n\tevt = vhost_scsi_allocate_evt(vs, event, reason);\n\tif (!evt)\n\t\treturn;\n\n\tif (tpg && lun) {\n\t\t/* TODO: share lun setup code with virtio-scsi.ko */\n\t\t/*\n\t\t * Note: evt->event is zeroed when we allocate it and\n\t\t * lun[4-7] need to be zero according to virtio-scsi spec.\n\t\t */\n\t\tevt->event.lun[0] = 0x01;\n\t\tevt->event.lun[1] = tpg->tport_tpgt & 0xFF;\n\t\tif (lun->unpacked_lun >= 256)\n\t\t\tevt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;\n\t\tevt->event.lun[3] = lun->unpacked_lun & 0xFF;\n\t}\n\n\tllist_add(&evt->list, &vs->vs_event_list);\n\tvhost_work_queue(&vs->dev, &vs->vs_event_work);\n}",
        "output": "1",
        "idx": 3576
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  explicit IPCRenderer(v8::Isolate* isolate)\n      : content::RenderFrameObserver(GetCurrentRenderFrame()) {\n    RenderFrame* render_frame = GetCurrentRenderFrame();\n    DCHECK(render_frame);\n    weak_context_ =\n        v8::Global<v8::Context>(isolate, isolate->GetCurrentContext());\n    weak_context_.SetWeak();\n\n    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(\n        &electron_browser_remote_);\n  }",
        "output": "1",
        "idx": 1703
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dir_globs(long argc, const VALUE *argv, VALUE base, int flags)\n{\n    VALUE ary = rb_ary_new();\n    long i;\n\n    for (i = 0; i < argc; ++i) {\n\tint status;\n\tVALUE str = argv[i];\n\tGlobPathValue(str, TRUE);\n\tstatus = push_glob(ary, str, base, flags);\n\tif (status) GLOB_JUMP_TAG(status);\n    }\n\n    return ary;\n}",
        "output": "1",
        "idx": 2709
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_dpi_percentage (RsvgHandle * ctx)\n{\n    return sqrt (ctx->priv->dpi_x * ctx->priv->dpi_y);\n}",
        "output": "0",
        "idx": 564
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "lyd_insert_before(struct lyd_node *sibling, struct lyd_node *node)\n{\n    if (!node || !sibling) {\n        LOGARG;\n        return EXIT_FAILURE;\n    }\n\n    return lyd_insert_nextto(sibling, node, 1, 1);\n}",
        "output": "0",
        "idx": 547
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _CONSTRUCTOR lib_init(void)\n{\nint ret;\nconst char *e;\n\n\tif (_gnutls_global_init_skip() != 0)\n\t\treturn;\n\n\te = getenv(\"GNUTLS_NO_EXPLICIT_INIT\");\n\tif (e != NULL) {\n\t\tret = atoi(e);\n\t\tif (ret == 1)\n\t\t\treturn;\n\t}\n\n\tret = gnutls_global_init();\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"Error in GnuTLS initialization: %s\\n\", gnutls_strerror(ret));\n\t\t_gnutls_switch_lib_state(LIB_STATE_ERROR);\n\t}\n}",
        "output": "1",
        "idx": 1509
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cpu_bugs_smt_update(void)\n{\n\tmutex_lock(&spec_ctrl_mutex);\n\n\tswitch (spectre_v2_user) {\n\tcase SPECTRE_V2_USER_NONE:\n\t\tbreak;\n\tcase SPECTRE_V2_USER_STRICT:\n\tcase SPECTRE_V2_USER_STRICT_PREFERRED:\n\t\tupdate_stibp_strict();\n\t\tbreak;\n\tcase SPECTRE_V2_USER_PRCTL:\n\tcase SPECTRE_V2_USER_SECCOMP:\n\t\tupdate_indir_branch_cond();\n\t\tbreak;\n\t}\n\n\tswitch (mds_mitigation) {\n\tcase MDS_MITIGATION_FULL:\n\tcase MDS_MITIGATION_VMWERV:\n\t\tif (sched_smt_active() && !boot_cpu_has(X86_BUG_MSBDS_ONLY))\n\t\t\tpr_warn_once(MDS_MSG_SMT);\n\t\tupdate_mds_branch_idle();\n\t\tbreak;\n\tcase MDS_MITIGATION_OFF:\n\t\tbreak;\n\t}\n\n\tswitch (taa_mitigation) {\n\tcase TAA_MITIGATION_VERW:\n\tcase TAA_MITIGATION_UCODE_NEEDED:\n\t\tif (sched_smt_active())\n\t\t\tpr_warn_once(TAA_MSG_SMT);\n\t\tbreak;\n\tcase TAA_MITIGATION_TSX_DISABLED:\n\tcase TAA_MITIGATION_OFF:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&spec_ctrl_mutex);\n}",
        "output": "1",
        "idx": 2340
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,\n\t\t\t struct css_task_iter *it)\n{\n\tmemset(it, 0, sizeof(*it));\n\n\tspin_lock_irq(&css_set_lock);\n\n\tit->ss = css->ss;\n\tit->flags = flags;\n\n\tif (CGROUP_HAS_SUBSYS_CONFIG && it->ss)\n\t\tit->cset_pos = &css->cgroup->e_csets[css->ss->id];\n\telse\n\t\tit->cset_pos = &css->cgroup->cset_links;\n\n\tit->cset_head = it->cset_pos;\n\n\tcss_task_iter_advance(it);\n\n\tspin_unlock_irq(&css_set_lock);\n}",
        "output": "0",
        "idx": 1639
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void sqlite3ExprDelete(sqlite3 *db, Expr *p){\n  if( p ) sqlite3ExprDeleteNN(db, p);\n}",
        "output": "0",
        "idx": 1108
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t  const void *val, int bytes)\n{\n\tint ret;\n\n\tret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);\n\tif (ret < 0)\n\t\treturn 0;\n\tkvm_mmu_pte_write(vcpu, gpa, val, bytes, 1);\n\treturn 1;\n}",
        "output": "0",
        "idx": 115
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "lexer_compare_identifiers (parser_context_t *context_p, /**< context */\n                           const lexer_lit_location_t *left_p, /**< left literal */\n                           const lexer_lit_location_t *right_p) /**< right literal */\n{\n  prop_length_t length = left_p->length;\n\n  if (length != right_p->length)\n  {\n    return false;\n  }\n\n  if (!left_p->has_escape)\n  {\n    return lexer_compare_identifier_to_chars (right_p->char_p, left_p->char_p, length);\n  }\n\n  if (!right_p->has_escape)\n  {\n    return lexer_compare_identifier_to_chars (left_p->char_p, right_p->char_p, length);\n  }\n\n  if (length <= 64)\n  {\n    uint8_t buf_p[64];\n    lexer_convert_ident_to_cesu8 (buf_p, left_p->char_p, length);\n    return lexer_compare_identifier_to_chars (right_p->char_p, buf_p, length);\n  }\n\n  uint8_t *dynamic_buf_p = parser_malloc (context_p, length);\n\n  lexer_convert_ident_to_cesu8 (dynamic_buf_p, left_p->char_p, length);\n  bool result = lexer_compare_identifier_to_chars (right_p->char_p, dynamic_buf_p, length);\n  parser_free (dynamic_buf_p, length);\n\n  return result;\n} /* lexer_compare_identifiers */",
        "output": "1",
        "idx": 146
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Curl_free_idnconverted_hostname(struct hostname *host)\n{\n#if defined(USE_LIBIDN2)\n  if(host->encalloc) {\n    idn2_free(host->encalloc); /* must be freed with idn2_free() since this was\n                                 allocated by libidn */\n    host->encalloc = NULL;\n  }\n#elif defined(USE_WIN32_IDN)\n  free(host->encalloc); /* must be freed with free() since this was\n                           allocated by curl_win32_idn_to_ascii */\n  host->encalloc = NULL;\n#else\n  (void)host;\n#endif\n}",
        "output": "0",
        "idx": 2480
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int still_interesting(struct commit_list *src, unsigned long date, int slop)\n{\n\t/*\n\t * No source list at all? We're definitely done..\n\t */\n\tif (!src)\n\t\treturn 0;\n\n\t/*\n\t * Does the destination list contain entries with a date\n\t * before the source list? Definitely _not_ done.\n\t */\n\tif (date < src->item->date)\n\t\treturn SLOP;\n\n\t/*\n\t * Does the source list still have interesting commits in\n\t * it? Definitely not done..\n\t */\n\tif (!everybody_uninteresting(src))\n\t\treturn SLOP;\n\n\t/* Ok, we're closing in.. */\n\treturn slop-1;\n}",
        "output": "0",
        "idx": 1864
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int lua_ap_exists_config_define(lua_State *L)\n{\n    int returnValue;\n    const char     *name;\n    luaL_checktype(L, 1, LUA_TSTRING);\n    name = lua_tostring(L, 1);\n    returnValue = ap_exists_config_define(name);\n    lua_pushboolean(L, returnValue);\n    return 1;\n}",
        "output": "0",
        "idx": 3663
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void MainWindow::setPreviewScale(int scale)\n{\n    LOG_DEBUG() << scale;\n    switch (scale) {\n    case 360:\n        ui->actionPreview360->setChecked(true);\n        break;\n    case 540:\n        ui->actionPreview540->setChecked(true);\n        break;\n    case 720:\n        ui->actionPreview720->setChecked(true);\n        break;\n    default:\n        ui->actionPreviewNone->setChecked(true);\n        break;\n    }\n    MLT.setPreviewScale(scale);\n    MLT.refreshConsumer();\n}",
        "output": "0",
        "idx": 1922
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)\n{\n    int conn = -1;\n    int ret = 1;\n\n    if (s->method != meth) {\n        if (s->handshake_func != NULL)\n            conn = (s->handshake_func == s->method->ssl_connect);\n\n        if (s->method->version == meth->version)\n            s->method = meth;\n        else {\n            s->method->ssl_free(s);\n            s->method = meth;\n            ret = s->method->ssl_new(s);\n        }\n\n        if (conn == 1)\n            s->handshake_func = meth->ssl_connect;\n        else if (conn == 0)\n            s->handshake_func = meth->ssl_accept;\n    }\n    return (ret);\n}",
        "output": "0",
        "idx": 2760
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool CServer::IsAuthed(int ClientID) const\n{\n\treturn m_aClients[ClientID].m_Authed;\n}",
        "output": "0",
        "idx": 2796
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "set_str_a_characters_bp(struct archive_write *a, unsigned char *bp,\n    int from, int to, const char *s, enum vdc vdc)\n{\n\tint r;\n\n\tswitch (vdc) {\n\tcase VDC_STD:\n\t\tset_str(bp+from, s, to - from + 1, 0x20,\n\t\t    a_characters_map);\n\t\tr = ARCHIVE_OK;\n\t\tbreak;\n\tcase VDC_LOWERCASE:\n\t\tset_str(bp+from, s, to - from + 1, 0x20,\n\t\t    a1_characters_map);\n\t\tr = ARCHIVE_OK;\n\t\tbreak;\n\tcase VDC_UCS2:\n\tcase VDC_UCS2_DIRECT:\n\t\tr = set_str_utf16be(a, bp+from, s, to - from + 1,\n\t\t    0x0020, vdc);\n\t\tbreak;\n\tdefault:\n\t\tr = ARCHIVE_FATAL;\n\t}\n\treturn (r);\n}",
        "output": "0",
        "idx": 3187
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dp_packet_hwol_set_csum_sctp(struct dp_packet *b)\n{\n    *dp_packet_ol_flags_ptr(b) |= DP_PACKET_OL_TX_SCTP_CKSUM;\n}",
        "output": "0",
        "idx": 1721
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n\tGC_REFCOUNT(ht) = 1;\n\tGC_TYPE_INFO(ht) = IS_ARRAY;\n\tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\tht->nTableSize = zend_hash_check_size(nSize);\n\tht->nTableMask = HT_MIN_MASK;\n\tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n\tht->nNextFreeElement = 0;\n\tht->pDestructor = pDestructor;\n}",
        "output": "1",
        "idx": 1428
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int bns_cnt_ambi(const bntseq_t *bns, int64_t pos_f, int len, int *ref_id)\n{\n\tint left, mid, right, nn;\n\tif (ref_id) *ref_id = bns_pos2rid(bns, pos_f);\n\tleft = 0; right = bns->n_holes; nn = 0;\n\twhile (left < right) {\n\t\tmid = (left + right) >> 1;\n\t\tif (pos_f >= bns->ambs[mid].offset + bns->ambs[mid].len) left = mid + 1;\n\t\telse if (pos_f + len <= bns->ambs[mid].offset) right = mid;\n\t\telse { // overlap\n\t\t\tif (pos_f >= bns->ambs[mid].offset) {\n\t\t\t\tnn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?\n\t\t\t\t\tbns->ambs[mid].offset + bns->ambs[mid].len - pos_f : len;\n\t\t\t} else {\n\t\t\t\tnn += bns->ambs[mid].offset + bns->ambs[mid].len < pos_f + len?\n\t\t\t\t\tbns->ambs[mid].len : len - (bns->ambs[mid].offset - pos_f);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn nn;\n}",
        "output": "0",
        "idx": 3498
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int assign_proto_idx(struct proto *prot)\n{\n\tprot->inuse_idx = find_first_zero_bit(proto_inuse_idx, PROTO_INUSE_NR);\n\n\tif (unlikely(prot->inuse_idx == PROTO_INUSE_NR - 1)) {\n\t\tpr_err(\"PROTO_INUSE_NR exhausted\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tset_bit(prot->inuse_idx, proto_inuse_idx);\n\treturn 0;\n}",
        "output": "0",
        "idx": 3094
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\n\t(void)mode;\t/* UNUSED */\n\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\t/* Solaris writes POSIX.1e access and default ACLs together */\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_POSIX1E, \"posix1e\");\n\n\t\t/* Simultaneous POSIX.1e and NFSv4 is not supported */\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}",
        "output": "1",
        "idx": 796
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QPDFAnnotationObjectHelper::getFlags()\n{\n    QPDFObjectHandle flags_obj = this->oh.getKey(\"/F\");\n    return flags_obj.isInteger() ? flags_obj.getIntValue() : 0;\n}",
        "output": "1",
        "idx": 3169
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rpmsg_char_init(void)\n{\n\tint ret;\n\n\tret = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, \"rpmsg\");\n\tif (ret < 0) {\n\t\tpr_err(\"rpmsg: failed to allocate char dev region\\n\");\n\t\treturn ret;\n\t}\n\n\trpmsg_class = class_create(THIS_MODULE, \"rpmsg\");\n\tif (IS_ERR(rpmsg_class)) {\n\t\tpr_err(\"failed to create rpmsg class\\n\");\n\t\tunregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);\n\t\treturn PTR_ERR(rpmsg_class);\n\t}\n\n\tret = register_rpmsg_driver(&rpmsg_chrdev_driver);\n\tif (ret < 0) {\n\t\tpr_err(\"rpmsgchr: failed to register rpmsg driver\\n\");\n\t\tclass_destroy(rpmsg_class);\n\t\tunregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);\n\t}\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 1148
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(void) gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)\n{\n\tint x, y, pos;\n\tWbmp *wbmp;\n\n\t/* create the WBMP */\n\tif((wbmp = createwbmp(gdImageSX(image), gdImageSY(image), WBMP_WHITE)) == NULL) {\n\t\tgd_error(\"Could not create WBMP\\n\");\n\t\treturn;\n\t}\n\n\t/* fill up the WBMP structure */\n\tpos = 0;\n\tfor(y = 0; y < gdImageSY(image); y++) {\n\t\tfor(x = 0; x < gdImageSX(image); x++) {\n\t\t\tif(gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\twbmp->bitmap[pos] = WBMP_BLACK;\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t}\n\n\t/* write the WBMP to a gd file descriptor */\n\tif(writewbmp(wbmp, &gd_putout, out)) {\n\t\tgd_error(\"Could not save WBMP\\n\");\n\t}\n\n\t/* des submitted this bugfix: gdFree the memory. */\n\tfreewbmp(wbmp);\n}",
        "output": "1",
        "idx": 3420
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mv_GenerateOper(StringInfo buf, Oid opoid)\n{\n\tHeapTuple\topertup;\n\tForm_pg_operator operform;\n\n\topertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));\n\tif (!HeapTupleIsValid(opertup))\n\t\telog(ERROR, \"cache lookup failed for operator %u\", opoid);\n\toperform = (Form_pg_operator) GETSTRUCT(opertup);\n\tAssert(operform->oprkind == 'b');\n\n\tappendStringInfo(buf, \"OPERATOR(%s.%s)\",\n\t\t\t\tquote_identifier(get_namespace_name(operform->oprnamespace)),\n\t\t\t\t\t NameStr(operform->oprname));\n\n\tReleaseSysCache(opertup);\n}",
        "output": "0",
        "idx": 2499
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int php_snmp_read_info(php_snmp_object *snmp_object, zval **retval TSRMLS_DC)\n{\n\tzval *val;\n\n\tMAKE_STD_ZVAL(*retval);\n\tarray_init(*retval);\n\n\tif (snmp_object->session == NULL) {\n\t\treturn SUCCESS;\n\t}\n\t\t\n\tMAKE_STD_ZVAL(val);\n\tZVAL_STRINGL(val, snmp_object->session->peername, strlen(snmp_object->session->peername), 1);\n\tadd_assoc_zval(*retval, \"hostname\", val);\n\t\n\tMAKE_STD_ZVAL(val);\n\tZVAL_LONG(val, snmp_object->session->remote_port);\n\tadd_assoc_zval(*retval, \"port\", val);\n\t\n\tMAKE_STD_ZVAL(val);\n\tZVAL_LONG(val, snmp_object->session->timeout);\n\tadd_assoc_zval(*retval, \"timeout\", val);\n\t\n\tMAKE_STD_ZVAL(val);\n\tZVAL_LONG(val, snmp_object->session->retries);\n\tadd_assoc_zval(*retval, \"retries\", val);\n\t\n\treturn SUCCESS;\n}",
        "output": "1",
        "idx": 2205
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "is_link_trusted (NautilusFile *file,\n                 gboolean      is_launcher)\n{\n    GFile *location;\n    gboolean res;\n\n    if (!is_launcher)\n    {\n        return TRUE;\n    }\n\n    if (nautilus_file_can_execute (file))\n    {\n        return TRUE;\n    }\n\n    res = FALSE;\n\n    if (nautilus_file_is_local (file))\n    {\n        location = nautilus_file_get_location (file);\n        res = nautilus_is_in_system_dir (location);\n        g_object_unref (location);\n    }\n\n    return res;\n}",
        "output": "1",
        "idx": 2365
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned get_mmio_spte_access(u64 spte)\n{\n\treturn spte & shadow_mmio_access_mask;\n}",
        "output": "0",
        "idx": 1474
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool dl_param_changed(struct task_struct *p,\n\t\tconst struct sched_attr *attr)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tif (dl_se->dl_runtime != attr->sched_runtime ||\n\t\tdl_se->dl_deadline != attr->sched_deadline ||\n\t\tdl_se->dl_period != attr->sched_period ||\n\t\tdl_se->flags != attr->sched_flags)\n\t\treturn true;\n\n\treturn false;\n}",
        "output": "0",
        "idx": 1192
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "calc_crc32( u32  crc,  u8  *p,  u32  len )\n{\n\twhile( len-- )\n\t\tcrc = CRC32( *p++, crc );\n\n\treturn  crc;\n}",
        "output": "0",
        "idx": 2985
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "is_next_headerline(uint8_t *data, size_t size)\n{\n\tsize_t i = 0;\n\n\twhile (i < size && data[i] != '\\n')\n\t\ti++;\n\n\tif (++i >= size)\n\t\treturn 0;\n\n\treturn is_headerline(data + i, size - i);\n}",
        "output": "0",
        "idx": 2531
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main(void)\n{\n\tFILE *f;\n\tchar *tmpname;\n\tf = xfmkstemp(&tmpname, NULL);\n\tunlink(tmpname);\n\tfree(tmpname);\n\tfclose(f);\n\treturn EXIT_FAILURE;\n}",
        "output": "1",
        "idx": 3723
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QString BootDoctor::errorString()\n{\n    return m_lastErrorString;\n}",
        "output": "0",
        "idx": 932
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)\n{\n    /* create the t2 structure */\n    opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));\n    if (!l_t2) {\n        return NULL;\n    }\n\n    l_t2->image = p_image;\n    l_t2->cp = p_cp;\n\n    return l_t2;\n}",
        "output": "0",
        "idx": 1991
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "      static double mp_log10(_cimg_math_parser& mp) {\n        return std::log10(_mp_arg(2));\n      }",
        "output": "0",
        "idx": 2939
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len,\n\t\t\t    int flags)\n{\n\tint err;\n\tstruct sk_buff *skb;\n\tstruct sock *sk = sock->sk;\n\n\terr = -EIO;\n\tif (sk->sk_state & PPPOX_BOUND)\n\t\tgoto end;\n\n\tmsg->msg_namelen = 0;\n\n\terr = 0;\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto end;\n\n\tif (len > skb->len)\n\t\tlen = skb->len;\n\telse if (len < skb->len)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, len);\n\tif (likely(err == 0))\n\t\terr = len;\n\n\tkfree_skb(skb);\nend:\n\treturn err;\n}",
        "output": "1",
        "idx": 254
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlXPtrHereFunction(xmlXPathParserContextPtr ctxt, int nargs) {\n    CHECK_ARITY(0);\n\n    if (ctxt->context->here == NULL)\n\tXP_ERROR(XPTR_SYNTAX_ERROR);\n    \n    valuePush(ctxt, xmlXPtrNewLocationSetNodes(ctxt->context->here, NULL));\n}",
        "output": "0",
        "idx": 3175
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct bpf_prog *bpf_prog_get(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\n\tprog = __bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\n\tatomic_inc(&prog->aux->refcnt);\n\tfdput(f);\n\n\treturn prog;\n}",
        "output": "1",
        "idx": 1311
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ZRLE_ENCODE (int x, int y, int w, int h,\n\t\t  zrleOutStream* os, void* buf\n                  EXTRA_ARGS\n                  )\n{\n  int ty;\n  for (ty = y; ty < y+h; ty += rfbZRLETileHeight) {\n    int tx, th = rfbZRLETileHeight;\n    if (th > y+h-ty) th = y+h-ty;\n    for (tx = x; tx < x+w; tx += rfbZRLETileWidth) {\n      int tw = rfbZRLETileWidth;\n      if (tw > x+w-tx) tw = x+w-tx;\n\n      GET_IMAGE_INTO_BUF(tx,ty,tw,th,buf);\n\n      ZRLE_ENCODE_TILE((PIXEL_T*)buf, tw, th, os,\n\t\t      cl->zywrleLevel, cl->zywrleBuf);\n    }\n  }\n  zrleOutStreamFlush(os);\n}",
        "output": "1",
        "idx": 3035
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int crypt_metadata_locking(struct crypt_device *cd __attribute__((unused)), int enable)\n{\n\tif (enable && !_metadata_locking)\n\t\treturn -EPERM;\n\n\t_metadata_locking = enable ? 1 : 0;\n\treturn 0;\n}",
        "output": "0",
        "idx": 1598
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int process_open(ProcessHandle process, const char *fname) {\n\tint rv = process_open_nofail(process, fname);\n\tif (rv < 0) {\n\t\tfprintf(stderr, \"Error: cannot open /proc/%d/%s: %s\\n\", process->pid, fname, strerror(errno));\n\t\texit(1);\n\t}\n\n\treturn rv;\n}",
        "output": "1",
        "idx": 550
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  longlong val_int() { return cached_time.to_longlong(); }",
        "output": "0",
        "idx": 392
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "process(register int code, unsigned char** fill)\n{\n    int incode;\n    static unsigned char firstchar;\n\n    if (code == clear) {\n\tcodesize = datasize + 1;\n\tcodemask = (1 << codesize) - 1;\n\tavail = clear + 2;\n\toldcode = -1;\n\treturn 1;\n    }\n\n    if (oldcode == -1) {\n\t*(*fill)++ = suffix[code];\n\tfirstchar = oldcode = code;\n\treturn 1;\n    }\n    if (code > avail) {\n\tfprintf(stderr, \"code %d too large for %d\\n\", code, avail);\n\treturn 0; \n    }\n\n    incode = code;\n    if (code == avail) {      /* the first code is always < avail */\n\t*stackp++ = firstchar;\n\tcode = oldcode;\n    }\n    while (code > clear) {\n\t*stackp++ = suffix[code];\n\tcode = prefix[code];\n    }\n\n    *stackp++ = firstchar = suffix[code];\n    prefix[avail] = oldcode;\n    suffix[avail] = firstchar;\n    avail++;\n\n    if (((avail & codemask) == 0) && (avail < 4096)) {\n\tcodesize++;\n\tcodemask += avail;\n    }\n    oldcode = incode;\n    do {\n\t*(*fill)++ = *--stackp;\n    } while (stackp > stack);\n    return 1;\n}",
        "output": "1",
        "idx": 2364
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void print_version(void)\n{\n  printf(\"%s  Ver %s Distrib %s, for %s (%s)\\n\",my_progname,MTEST_VERSION,\n\t MYSQL_SERVER_VERSION,SYSTEM_TYPE,MACHINE_TYPE);\n}",
        "output": "0",
        "idx": 2884
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err hdlr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_HandlerBox *p = (GF_HandlerBox *)a;\n\tgf_isom_box_dump_start(a, \"HandlerBox\", trace);\n\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);\n\t} else {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8);\n\t}\n\tfprintf(trace, \"reserved1=\\\"%d\\\" reserved2=\\\"\", p->reserved1);\n\tdump_data(trace, (char *) p->reserved2, 12);\n\tfprintf(trace, \"\\\"\");\n\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"HandlerBox\", a, trace);\n\treturn GF_OK;\n}",
        "output": "1",
        "idx": 2805
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "toomany(struct magic_set *ms, const char *name, uint16_t num)\n{\n\tif (file_printf(ms, \", too many %s header sections (%u)\", name, num\n\t    ) == -1)\n\t\treturn -1;\n\treturn 0;\n}",
        "output": "1",
        "idx": 213
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "set_gray_color_procs(gx_device * pdev,\n        dev_t_proc_encode_color((*encode_color), gx_device),\n        dev_t_proc_decode_color((*decode_color), gx_device))\n{\n    set_color_procs(pdev, encode_color, decode_color,\n        gx_default_DevGray_get_color_mapping_procs,\n        gx_default_DevGray_get_color_comp_index);\n}",
        "output": "1",
        "idx": 1762
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int codeCompare(\n  Parse *pParse,    /* The parsing (and code generating) context */\n  Expr *pLeft,      /* The left operand */\n  Expr *pRight,     /* The right operand */\n  int opcode,       /* The comparison opcode */\n  int in1, int in2, /* Register holding operands */\n  int dest,         /* Jump here if true.  */\n  int jumpIfNull,   /* If true, jump if either operand is NULL */\n  int isCommuted    /* The comparison has been commuted */\n){\n  int p5;\n  int addr;\n  CollSeq *p4;\n\n  if( isCommuted ){\n    p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);\n  }else{\n    p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);\n  }\n  p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);\n  addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,\n                           (void*)p4, P4_COLLSEQ);\n  sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);\n  return addr;\n}",
        "output": "1",
        "idx": 131
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* size = GetInput(context, node, kSizeTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  // TODO(ahentz): Our current implementations rely on the input being 4D,\n  // and the size being 1D tensor with exactly 2 elements.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(size), 1);\n  TF_LITE_ENSURE_TYPES_EQ(context, size->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, size->dims->data[0], 2);\n\n  output->type = input->type;\n\n  if (!IsConstantTensor(size)) {\n    SetTensorToDynamic(output);\n    return kTfLiteOk;\n  }\n  return ResizeOutputTensor(context, input, size, output);\n}",
        "output": "1",
        "idx": 1558
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ephy_string_shorten (char  *str,\n                     gsize  target_length)\n{\n  char *new_str;\n  glong actual_length;\n  gulong bytes;\n\n  g_assert (target_length > 0);\n\n  if (!str)\n    return NULL;\n\n  /* FIXME: this function is a big mess. While it is utf-8 safe now,\n   * it can still split a sequence of combining characters.\n   */\n  actual_length = g_utf8_strlen (str, -1);\n\n  /* if the string is already short enough, or if it's too short for\n   * us to shorten it, return a new copy */\n  if ((gsize)actual_length <= target_length)\n    return str;\n\n  /* create string */\n  bytes = GPOINTER_TO_UINT (g_utf8_offset_to_pointer (str, target_length - 1) - str);\n\n  /* +1 for ellipsis, +1 for trailing NUL */\n  new_str = g_new (gchar, bytes + 1 + 1);\n\n  strncpy (new_str, str, bytes);\n  strcat (new_str, \"\u2026\");\n\n  g_free (str);\n\n  return new_str;\n}",
        "output": "1",
        "idx": 1406
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(xml_parser_create)\n{\n\tphp_xml_parser_create_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\t\n}",
        "output": "1",
        "idx": 601
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int stellaris_enet_load(QEMUFile *f, void *opaque, int version_id)\n{\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n    int i;\n\n    if (version_id != 1)\n        return -EINVAL;\n\n    s->ris = qemu_get_be32(f);\n    s->im = qemu_get_be32(f);\n    s->rctl = qemu_get_be32(f);\n    s->tctl = qemu_get_be32(f);\n    s->thr = qemu_get_be32(f);\n    s->mctl = qemu_get_be32(f);\n    s->mdv = qemu_get_be32(f);\n    s->mtxd = qemu_get_be32(f);\n    s->mrxd = qemu_get_be32(f);\n    s->np = qemu_get_be32(f);\n    s->tx_fifo_len = qemu_get_be32(f);\n    qemu_get_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n    for (i = 0; i < 31; i++) {\n        s->rx[i].len = qemu_get_be32(f);\n        qemu_get_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n\n    }\n    s->next_packet = qemu_get_be32(f);\n    s->rx_fifo_offset = qemu_get_be32(f);\n\n    return 0;\n}",
        "output": "1",
        "idx": 3466
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rfbClientIteratorNext(rfbClientIteratorPtr i)\n{\n  if(i->next == 0) {\n    LOCK(rfbClientListMutex);\n    i->next = i->screen->clientHead;\n    UNLOCK(rfbClientListMutex);\n  } else {\n    rfbClientPtr cl = i->next;\n    i->next = i->next->next;\n    rfbDecrClientRef(cl);\n  }\n\n#if defined(LIBVNCSERVER_HAVE_LIBPTHREAD) || defined(LIBVNCSERVER_HAVE_WIN32THREADS)\n    if(!i->closedToo)\n      while(i->next && i->next->sock<0)\n        i->next = i->next->next;\n    if(i->next)\n      rfbIncrClientRef(i->next);\n#endif\n\n    return i->next;\n}",
        "output": "1",
        "idx": 1461
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void auth_client_request_abort(struct auth_client_request **_request)\n{\n\tstruct auth_client_request *request = *_request;\n\n\t*_request = NULL;\n\n\tauth_client_send_cancel(request->conn->client, request->id);\n\tcall_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);\n}",
        "output": "1",
        "idx": 3507
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *arm_coherent_dma_alloc(struct device *dev, size_t size,\n\tdma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)\n{\n\tpgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);\n\tvoid *memory;\n\n\tif (dma_alloc_from_coherent(dev, size, handle, &memory))\n\t\treturn memory;\n\n\treturn __dma_alloc(dev, size, handle, gfp, prot, true,\n\t\t\t   __builtin_return_address(0));\n}",
        "output": "0",
        "idx": 762
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int win_chr_write(CharDriverState *chr, const uint8_t *buf, int len1)\n{\n    WinCharState *s = chr->opaque;\n    DWORD len, ret, size, err;\n\n    len = len1;\n    ZeroMemory(&s->osend, sizeof(s->osend));\n    s->osend.hEvent = s->hsend;\n    while (len > 0) {\n        if (s->hsend)\n            ret = WriteFile(s->hcom, buf, len, &size, &s->osend);\n        else\n            ret = WriteFile(s->hcom, buf, len, &size, NULL);\n        if (!ret) {\n            err = GetLastError();\n            if (err == ERROR_IO_PENDING) {\n                ret = GetOverlappedResult(s->hcom, &s->osend, &size, TRUE);\n                if (ret) {\n                    buf += size;\n                    len -= size;\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        } else {\n            buf += size;\n            len -= size;\n        }\n    }\n    return len1 - len;\n}",
        "output": "0",
        "idx": 1281
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data;\n\tvoid *vapic;\n\n\tif (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))\n\t\tapic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n\tdata = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));\n\tkunmap_atomic(vapic);\n\n\tapic_set_tpr(vcpu->arch.apic, data & 0xff);\n}",
        "output": "1",
        "idx": 2394
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "compute_U_value_R2(std::string const& user_password,\n\t\t   QPDF::EncryptionData const& data)\n{\n    // Algorithm 3.4 from the PDF 1.7 Reference Manual\n\n    std::string k1 = QPDF::compute_encryption_key(user_password, data);\n    char udata[key_bytes];\n    pad_or_truncate_password_V4(\"\", udata);\n    iterate_rc4(QUtil::unsigned_char_pointer(udata), key_bytes,\n\t\tQUtil::unsigned_char_pointer(k1),\n                data.getLengthBytes(), 1, false);\n    return std::string(udata, key_bytes);\n}",
        "output": "1",
        "idx": 3645
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct sk_buff *skb_morph(struct sk_buff *dst, struct sk_buff *src)\n{\n\tskb_release_all(dst);\n\treturn __skb_clone(dst, src);\n}",
        "output": "0",
        "idx": 908
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "addMultiArrayContentJSON(CtxJson *ctx, void* array, const UA_DataType *type, \n                         size_t *index, UA_UInt32 *arrayDimensions, size_t dimensionIndex, \n                         size_t dimensionSize) {\n    /* Check the recursion limit */\n    if(ctx->depth > UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    \n    /* Stop recursion: The inner Arrays are written */\n    status ret;\n    if(dimensionIndex == (dimensionSize - 1)) {\n        ret = encodeJsonArray(ctx, ((u8*)array) + (type->memSize * *index),\n                              arrayDimensions[dimensionIndex], type);\n        (*index) += arrayDimensions[dimensionIndex];\n        return ret;\n    }\n\n    /* Recurse to the next dimension */\n    ret = writeJsonArrStart(ctx);\n    for(size_t i = 0; i < arrayDimensions[dimensionIndex]; i++) {\n        ret |= writeJsonCommaIfNeeded(ctx);\n        ret |= addMultiArrayContentJSON(ctx, array, type, index, arrayDimensions,\n                                        dimensionIndex + 1, dimensionSize);\n        ctx->commaNeeded[ctx->depth] = true;\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n    ret |= writeJsonArrEnd(ctx);\n    return ret;\n}",
        "output": "1",
        "idx": 3122
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void RGWListBuckets_ObjStore_S3::send_response_begin(bool has_buckets)\n{\n  if (op_ret)\n    set_req_state_err(s, op_ret);\n  dump_errno(s);\n  dump_start(s);\n  // Explicitly use chunked transfer encoding so that we can stream the result\n  // to the user without having to wait for the full length of it.\n  end_header(s, NULL, \"application/xml\", CHUNKED_TRANSFER_ENCODING);\n\n  if (! op_ret) {\n    list_all_buckets_start(s);\n    dump_owner(s, s->user->user_id, s->user->display_name);\n    s->formatter->open_array_section(\"Buckets\");\n    sent_data = true;\n  }\n}",
        "output": "0",
        "idx": 3554
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F(ServerSelectorTestFixture, ShouldThrowOnWireError) {\n    auto topologyDescription = std::make_shared<TopologyDescription>(sdamConfiguration);\n    auto oldServer = ServerDescriptionBuilder()\n                         .withAddress(topologyDescription->getServers().back()->getAddress())\n                         .withType(ServerType::kRSPrimary)\n                         .withMaxWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)\n                         .withMinWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)\n                         .instance();\n    topologyDescription->installServerDescription(oldServer);\n\n    ASSERT(!topologyDescription->isWireVersionCompatible());\n    ASSERT_THROWS_CODE(selector.selectServers(topologyDescription, ReadPreferenceSetting()),\n                       DBException,\n                       ErrorCodes::IncompatibleServerVersion);\n}",
        "output": "1",
        "idx": 2185
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err tfdt_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;\n\n\tif (ptr->version==1) {\n\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\tptr->baseMediaDecodeTime = gf_bs_read_u64(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);\n\t}\n\treturn GF_OK;\n}",
        "output": "0",
        "idx": 2619
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_new_node_component_transfer_function (char channel)\n{\n    RsvgNodeComponentTransferFunc *filter;\n\n    filter = g_new0 (RsvgNodeComponentTransferFunc, 1);\n    _rsvg_node_init (&filter->super, RSVG_NODE_TYPE_COMPONENT_TRANFER_FUNCTION);\n    filter->super.free = rsvg_component_transfer_function_free;\n    filter->super.set_atts = rsvg_node_component_transfer_function_set_atts;\n    filter->function = identity_component_transfer_func;\n    filter->nbTableValues = 0;\n    filter->channel = channel;\n    return (RsvgNode *) filter;\n}",
        "output": "0",
        "idx": 1279
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool isIdIndex(const BSONObj& pattern) {\n    BSONObjIterator i(pattern);\n    BSONElement e = i.next();\n    //_id index must have form exactly {_id : 1} or {_id : -1}.\n    // Allows an index of form {_id : \"hashed\"} to exist but\n    // do not consider it to be the primary _id index\n    if (!(strcmp(e.fieldName(), \"_id\") == 0 && (e.numberInt() == 1 || e.numberInt() == -1)))\n        return false;\n    return i.next().eoo();\n}",
        "output": "0",
        "idx": 255
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static SECURITY_STATUS SEC_ENTRY negotiate_SetCredentialsAttributesW(PCredHandle phCredential,\n                                                                     ULONG ulAttribute,\n                                                                     void* pBuffer, ULONG cbBuffer)\n{\n\tMechCred* creds;\n\n\tcreds = sspi_SecureHandleGetLowerPointer(phCredential);\n\n\tif (!creds)\n\t\treturn SEC_E_INVALID_HANDLE;\n\n\tfor (size_t i = 0; i < MECH_COUNT; i++)\n\t{\n\t\tMechCred* cred = &creds[i];\n\n\t\tif (!cred->valid)\n\t\t\tcontinue;\n\n\t\tWINPR_ASSERT(cred->mech);\n\t\tWINPR_ASSERT(cred->mech->pkg);\n\t\tWINPR_ASSERT(cred->mech->pkg->table);\n\t\tWINPR_ASSERT(cred->mech->pkg->table_w->SetCredentialsAttributesW);\n\t\tcred->mech->pkg->table_w->SetCredentialsAttributesW(&cred->cred, ulAttribute, pBuffer,\n\t\t                                                    cbBuffer);\n\t}\n\n\treturn SEC_E_OK;\n}",
        "output": "1",
        "idx": 203
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int async_polkit_callback(sd_bus_message *reply, void *userdata, sd_bus_error *error) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error_buffer = SD_BUS_ERROR_NULL;\n        AsyncPolkitQuery *q = userdata;\n        int r;\n\n        assert(reply);\n        assert(q);\n\n        q->slot = sd_bus_slot_unref(q->slot);\n        q->reply = sd_bus_message_ref(reply);\n\n        r = sd_bus_message_rewind(q->request, true);\n        if (r < 0) {\n                r = sd_bus_reply_method_errno(q->request, r, NULL);\n                goto finish;\n        }\n\n        r = q->callback(q->request, q->userdata, &error_buffer);\n        r = bus_maybe_reply_error(q->request, r, &error_buffer);\n\nfinish:\n        async_polkit_query_free(q);\n\n        return r;\n}",
        "output": "1",
        "idx": 1448
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST(ProtocolTruncatedDataTest, TuncatedString_Binary) {\n  TestStruct s;\n  s.a_string_ref() = \"foobarbazstring\";\n\n  testPartialDataHandling<BinarySerializer>(\n      s, 7 /* field & length header */ + s.a_string_ref()->size());\n}",
        "output": "0",
        "idx": 1083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "absl::optional<std::string> canonicalizePath(absl::string_view original_path) {\n  std::string canonical_path;\n  url::Component in_component(0, original_path.size());\n  url::Component out_component;\n  url::StdStringCanonOutput output(&canonical_path);\n  if (!CanonicalizePath(original_path.data(), in_component, &output, &out_component)) {\n    return absl::nullopt;\n  } else {\n    output.Complete();\n    return absl::make_optional(std::move(canonical_path));\n  }\n}",
        "output": "1",
        "idx": 2754
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ssl_clear_bad_session(SSL *s)\n{\n    if ((s->session != NULL) &&\n        !(s->shutdown & SSL_SENT_SHUTDOWN) &&\n        !(SSL_in_init(s) || SSL_in_before(s))) {\n        SSL_CTX_remove_session(s->ctx, s->session);\n        return (1);\n    } else\n        return (0);\n}",
        "output": "0",
        "idx": 1571
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplObjectStorage, getHash)\n{\n\tzval *obj;\n\tchar *hash;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"o\", &obj) == FAILURE) {\n\t\treturn;\n\t}\n\n\thash = emalloc(33);\n\tphp_spl_object_hash(obj, hash TSRMLS_CC);\n\t\n\tRETVAL_STRING(hash, 0);\n\n} /* }}} */",
        "output": "1",
        "idx": 2860
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __fastcall TCustomDialog::AddWinControl(TWinControl * Control)\r\n{\r\n  Control->TabOrder = FCount;\r\n  FCount++;\r\n}\r",
        "output": "0",
        "idx": 1041
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void kvm_ioapic_destroy(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tcancel_delayed_work_sync(&ioapic->eoi_inject);\n\tkvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);\n\tkvm->arch.vioapic = NULL;\n\tkfree(ioapic);\n}",
        "output": "0",
        "idx": 1105
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ssize_t __weak cpu_show_l1tf(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"Not affected\\n\");\n}",
        "output": "1",
        "idx": 3158
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jas_iccprof_t *jas_iccprof_createfrombuf(uchar *buf, int len)\n{\n\tjas_stream_t *in;\n\tjas_iccprof_t *prof;\n\tif (!(in = jas_stream_memopen(JAS_CAST(char *, buf), len)))\n\t\tgoto error;\n\tif (!(prof = jas_iccprof_load(in)))\n\t\tgoto error;\n\tjas_stream_close(in);\n\treturn prof;\nerror:\n\tif (in)\n\t\tjas_stream_close(in);\n\treturn 0;\n}",
        "output": "1",
        "idx": 1887
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int credssp_skip_ts_request(int length)\n{\n\tlength += ber_skip_integer(2);\n\tlength += ber_skip_contextual_tag(3);\n\tlength += der_skip_sequence_tag(length);\n\treturn length;\n}",
        "output": "1",
        "idx": 2236
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void WillReleaseScriptContext(v8::Local<v8::Context> context,\n                                int32_t world_id) override {\n    if (weak_context_.IsEmpty() ||\n        weak_context_.Get(context->GetIsolate()) == context)\n      electron_browser_remote_.reset();\n  }",
        "output": "1",
        "idx": 1748
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *linetoken(FILE *stream)\n{\n    int ch, idx;\n\n    while ((ch = fgetc(stream)) == ' ' || ch == '\\t' ); \n    \n    idx = 0;\n    while (ch != EOF && ch != lineterm) \n    {\n        ident[idx++] = ch;\n        ch = fgetc(stream);\n    } /* while */\n    \n    ungetc(ch, stream);\n    ident[idx] = 0;\n\n    return(ident);\t/* returns pointer to the token */\n\n} /* linetoken */",
        "output": "1",
        "idx": 1030
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool keyring_gc_select_iterator(void *object, void *iterator_data)\n{\n\tstruct key *key = keyring_ptr_to_key(object);\n\ttime_t *limit = iterator_data;\n\n\tif (key_is_dead(key, *limit))\n\t\treturn false;\n\tkey_get(key);\n\treturn true;\n}",
        "output": "0",
        "idx": 2162
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jpc_dec_process_eoc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\n\t/* Eliminate compiler warnings about unused variables. */\n\tms = 0;\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\tif (tile->state == JPC_TILE_ACTIVE) {\n\t\t\tif (jpc_dec_tiledecode(dec, tile)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\t/* If the tile has not yet been finalized, finalize it. */\n\t\t// OLD CODE: jpc_dec_tilefini(dec, tile);\n\t\tif (tile->state != JPC_TILE_DONE) {\n\t\t\tjpc_dec_tilefini(dec, tile);\n\t\t}\n\t}\n\n\t/* We are done processing the code stream. */\n\tdec->state = JPC_MT;\n\n\treturn 1;\n}",
        "output": "0",
        "idx": 121
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int Field_decimal::store(longlong nr, bool unsigned_val)\n{\n  ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED;\n  char buff[22];\n  uint length, int_part;\n  char fyllchar;\n  uchar *to;\n\n  if (nr < 0 && unsigned_flag && !unsigned_val)\n  {\n    overflow(1);\n    return 1;\n  }\n  length= (uint) (longlong10_to_str(nr,buff,unsigned_val ? 10 : -10) - buff);\n  int_part= field_length- (dec  ? dec+1 : 0);\n\n  if (length > int_part)\n  {\n    overflow(!unsigned_val && nr < 0L);\t\t/* purecov: inspected */\n    return 1;\n  }\n\n  fyllchar = zerofill ? (char) '0' : (char) ' ';\n  to= ptr;\n  for (uint i=int_part-length ; i-- > 0 ;)\n    *to++ = fyllchar;\n  memcpy(to,buff,length);\n  if (dec)\n  {\n    to[length]='.';\n    bfill(to+length+1,dec,'0');\n  }\n  return 0;\n}",
        "output": "0",
        "idx": 1014
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_P(Http2CodecImplStreamLimitTest, MaxClientStreams) {\n  http2OptionsFromTuple(client_http2_options_, ::testing::get<0>(GetParam()));\n  http2OptionsFromTuple(server_http2_options_, ::testing::get<1>(GetParam()));\n  client_ = std::make_unique<TestClientConnectionImpl>(\n      client_connection_, client_callbacks_, stats_store_, client_http2_options_,\n      max_request_headers_kb_, max_response_headers_count_, ProdNghttp2SessionFactory::get());\n  server_ = std::make_unique<TestServerConnectionImpl>(\n      server_connection_, server_callbacks_, stats_store_, server_http2_options_,\n      max_request_headers_kb_, max_request_headers_count_, headers_with_underscores_action_);\n\n  for (int i = 0; i < 101; ++i) {\n    request_encoder_ = &client_->newStream(response_decoder_);\n    setupDefaultConnectionMocks();\n    EXPECT_CALL(server_callbacks_, newStream(_, _))\n        .WillOnce(Invoke([&](ResponseEncoder& encoder, bool) -> RequestDecoder& {\n          response_encoder_ = &encoder;\n          encoder.getStream().addCallbacks(server_stream_callbacks_);\n          return request_decoder_;\n        }));\n\n    TestRequestHeaderMapImpl request_headers;\n    HttpTestUtility::addDefaultHeaders(request_headers);\n    EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));\n    request_encoder_->encodeHeaders(request_headers, true);\n  }\n}",
        "output": "1",
        "idx": 2641
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE2(gethostname, char __user *, name, int, len)\n{\n\tint i, errno;\n\tstruct new_utsname *u;\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\tdown_read(&uts_sem);\n\tu = utsname();\n\ti = 1 + strlen(u->nodename);\n\tif (i > len)\n\t\ti = len;\n\terrno = 0;\n\tif (copy_to_user(name, u->nodename, i))\n\t\terrno = -EFAULT;\n\tup_read(&uts_sem);\n\treturn errno;\n}",
        "output": "0",
        "idx": 455
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "file_method(const char *s)\t/* I - Filename or URL */\n{\n  if (strncmp(s, \"http:\", 5) == 0)\n    return (\"http\");\n  else if (strncmp(s, \"https:\", 6) == 0)\n    return (\"https\");\n  else if (strncmp(s, \"ftp:\", 4) == 0)\n    return (\"ftp\");\n  else if (strncmp(s, \"mailto:\", 7) == 0)\n    return (\"mailto\");\n  else\n    return (NULL);\n}",
        "output": "1",
        "idx": 3179
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int econet_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddr_len, int peer)\n{\n\tstruct sock *sk;\n\tstruct econet_sock *eo;\n\tstruct sockaddr_ec *sec = (struct sockaddr_ec *)uaddr;\n\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&econet_mutex);\n\n\tsk = sock->sk;\n\teo = ec_sk(sk);\n\n\tsec->sec_family\t  = AF_ECONET;\n\tsec->port\t  = eo->port;\n\tsec->addr.station = eo->station;\n\tsec->addr.net\t  = eo->net;\n\n\tmutex_unlock(&econet_mutex);\n\n\t*uaddr_len = sizeof(*sec);\n\treturn 0;\n}",
        "output": "1",
        "idx": 2593
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fdctrl_handle_drive_specification_command(FDCtrl *fdctrl, int direction)\n{\n    FDrive *cur_drv = get_cur_drv(fdctrl);\n\n    if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x80) {\n        /* Command parameters done */\n        if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x40) {\n            fdctrl->fifo[0] = fdctrl->fifo[1];\n            fdctrl->fifo[2] = 0;\n            fdctrl->fifo[3] = 0;\n            fdctrl_set_fifo(fdctrl, 4);\n        } else {\n            fdctrl_reset_fifo(fdctrl);\n        }\n    } else if (fdctrl->data_len > 7) {\n        /* ERROR */\n        fdctrl->fifo[0] = 0x80 |\n            (cur_drv->head << 2) | GET_CUR_DRV(fdctrl);\n        fdctrl_set_fifo(fdctrl, 1);\n    }\n}",
        "output": "1",
        "idx": 3618
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *jas_malloc(size_t size)\n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_malloc called with %zu\\n\", size));\n\tresult = malloc(size);\n\tJAS_DBGLOG(100, (\"jas_malloc(%zu) -> %p\\n\", size, result));\n\treturn result;\n}",
        "output": "1",
        "idx": 2672
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  Supports_Condition_Obj Parser::parse_supports_operator()\n  {\n    Supports_Condition_Obj cond = parse_supports_condition_in_parens();\n    if (cond.isNull()) return {};\n\n    while (true) {\n      Supports_Operator::Operand op = Supports_Operator::OR;\n      if (lex < kwd_and >()) { op = Supports_Operator::AND; }\n      else if(!lex < kwd_or >()) { break; }\n\n      lex < css_whitespace >();\n      Supports_Condition_Obj right = parse_supports_condition_in_parens();\n\n      // Supports_Condition_Ptr cc = SASS_MEMORY_NEW(Supports_Condition, *static_cast<Supports_Condition_Ptr>(cond));\n      cond = SASS_MEMORY_NEW(Supports_Operator, pstate, cond, right, op);\n    }\n    return cond;\n  }",
        "output": "0",
        "idx": 2426
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "flatpak_dir_get_remote_state_for_summary (FlatpakDir   *self,\n                                          const char   *remote,\n                                          GBytes       *opt_summary,\n                                          GBytes       *opt_summary_sig,\n                                          GCancellable *cancellable,\n                                          GError      **error)\n{\n  return _flatpak_dir_get_remote_state (self, remote, FALSE, FALSE, FALSE, FALSE, opt_summary, opt_summary_sig, cancellable, error);\n}",
        "output": "0",
        "idx": 2360
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void do_cmd(ESPState *s)\n{\n    uint8_t busid = fifo8_pop(&s->cmdfifo);\n\n    s->cmdfifo_cdb_offset--;\n\n    /* Ignore extended messages for now */\n    if (s->cmdfifo_cdb_offset) {\n        esp_fifo_pop_buf(&s->cmdfifo, NULL, s->cmdfifo_cdb_offset);\n        s->cmdfifo_cdb_offset = 0;\n    }\n\n    do_busid_cmd(s, busid);\n}",
        "output": "1",
        "idx": 2455
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_rsvg_node_init (RsvgNode * self)\n{\n    self->parent = NULL;\n    self->children = g_ptr_array_new ();\n    self->state = g_new (RsvgState, 1);\n    rsvg_state_init (self->state);\n    self->free = _rsvg_node_free;\n    self->draw = _rsvg_node_draw_nothing;\n    self->set_atts = _rsvg_node_dont_set_atts;\n    self->type = NULL;\n}",
        "output": "1",
        "idx": 2483
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\n\tstrncpy(extra_response->key, key, strlen(key) + 1);\n\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}",
        "output": "1",
        "idx": 532
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gst_date_time_new_now_local_time (void)\n{\n  return gst_date_time_new_from_g_date_time (g_date_time_new_now_local ());\n}",
        "output": "0",
        "idx": 1340
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 32) ;\n\t\tpsf->header [psf->headindex++] = (x >> 40) ;\n\t\tpsf->header [psf->headindex++] = (x >> 48) ;\n\t\tpsf->header [psf->headindex++] = (x >> 56) ;\n\t\t} ;\n} /* header_put_le_8byte */",
        "output": "1",
        "idx": 1054
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MONGO_EXPORT int bson_append_code_w_scope_n( bson *b, const char *name,\n        const char *code, size_t len, const bson *scope ) {\n\n    size_t sl, size;\n    if ( !scope ) return BSON_ERROR;\n    sl = len + 1;\n    size = 4 + 4 + sl + bson_size( scope );\n    if ( bson_append_estart( b, BSON_CODEWSCOPE, name, size ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append32_as_int( b, ( int )size );\n    bson_append32( b, &sl );\n    bson_append( b, code, sl );\n    bson_append( b, scope->data, bson_size( scope ) );\n    return BSON_OK;\n}",
        "output": "0",
        "idx": 1437
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void StringBody::Dump(std::ostream& os, const std::string& prefix) const {\n  if (!data_.empty()) {\n    utility::DumpByLine(data_, os, prefix);\n  }\n}",
        "output": "0",
        "idx": 2368
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *opts)\n{\n    core_dir_config *this_dir = ap_get_core_module_config(sec);\n\n    if (!this_dir) {\n        return;\n    }\n\n    if (this_dir->opts & OPT_UNSET) {\n        opts->add = (opts->add & ~this_dir->opts_remove)\n                   | this_dir->opts_add;\n        opts->remove = (opts->remove & ~this_dir->opts_add)\n                      | this_dir->opts_remove;\n        opts->opts = (opts->opts & ~opts->remove) | opts->add;\n    }\n    else {\n        opts->opts = this_dir->opts;\n        opts->add = this_dir->opts_add;\n        opts->remove = this_dir->opts_remove;\n    }\n\n    if (!(this_dir->override & OR_UNSET)) {\n        opts->override = this_dir->override;\n        opts->override_opts = this_dir->override_opts;\n    }\n\n    if (this_dir->override_list != NULL) {\n        opts->override_list = this_dir->override_list;\n    }\n}",
        "output": "0",
        "idx": 2381
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int count(struct cstate *g, Renode *node)\n{\n\tint min, max, n;\n\tif (!node) return 0;\n\tswitch (node->type) {\n\tdefault: return 1;\n\tcase P_CAT: return count(g, node->x) + count(g, node->y);\n\tcase P_ALT: return count(g, node->x) + count(g, node->y) + 2;\n\tcase P_REP:\n\t\tmin = node->m;\n\t\tmax = node->n;\n\t\tif (min == max) n = count(g, node->x) * min;\n\t\telse if (max < REPINF) n = count(g, node->x) * max + (max - min);\n\t\telse n = count(g, node->x) * (min + 1) + 2;\n\t\tif (n < 0 || n > REG_MAXPROG) die(g, \"program too large\");\n\t\treturn n;\n\tcase P_PAR: return count(g, node->x) + 2;\n\tcase P_PLA: return count(g, node->x) + 2;\n\tcase P_NLA: return count(g, node->x) + 2;\n\t}\n}",
        "output": "1",
        "idx": 1336
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void LogOpenCLBuildFailure(MagickCLDevice device,const char *kernel,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    *log;\n\n  size_t\n    log_size;\n\n  (void) FormatLocaleString(filename,MagickPathExtent,\"%s%s%s\",\n    GetOpenCLCacheDirectory(),DirectorySeparator,\"magick_badcl.cl\");\n\n  (void) remove_utf8(filename);\n  (void) BlobToFile(filename,kernel,strlen(kernel),exception);\n\n  openCL_library->clGetProgramBuildInfo(device->program,device->deviceID,\n    CL_PROGRAM_BUILD_LOG,0,NULL,&log_size);\n  log=(char*)AcquireMagickMemory(log_size);\n  openCL_library->clGetProgramBuildInfo(device->program,device->deviceID,\n    CL_PROGRAM_BUILD_LOG,log_size,log,&log_size);\n\n  (void) FormatLocaleString(filename,MagickPathExtent,\"%s%s%s\",\n    GetOpenCLCacheDirectory(),DirectorySeparator,\"magick_badcl.log\");\n\n  (void) remove_utf8(filename);\n  (void) BlobToFile(filename,log,log_size,exception);\n  log=(char*)RelinquishMagickMemory(log);\n}",
        "output": "1",
        "idx": 2099
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    //! Autocrop image region, regarding the specified background value \\newinstance.\n    CImg<T> get_autocrop(const T& value, const char *const axes=\"czyx\") const {\n      return (+*this).autocrop(value,axes);",
        "output": "0",
        "idx": 3641
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void user_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %u\", key->datalen);\n}",
        "output": "1",
        "idx": 1404
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QPDFFormFieldObjectHelper::getChoices()\n{\n    std::vector<std::string> result;\n    if (! isChoice())\n    {\n        return result;\n    }\n    QPDFObjectHandle opt = getInheritableFieldValue(\"/Opt\");\n    if (opt.isArray())\n    {\n        size_t n = opt.getArrayNItems();\n        for (size_t i = 0; i < n; ++i)\n        {\n            QPDFObjectHandle item = opt.getArrayItem(i);\n            if (item.isString())\n            {\n                result.push_back(item.getUTF8Value());\n            }\n        }\n    }\n    return result;\n}",
        "output": "1",
        "idx": 1070
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileInfo, setInfoClass)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_class_entry *ce = spl_ce_SplFileInfo;\n\tzend_error_handling error_handling;\n\t\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling  TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n\t\tintern->info_class = ce;\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}",
        "output": "1",
        "idx": 2703
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vrrp_state_handler(vector_t *strvec)\n{\n\tchar *str = strvec_slot(strvec, 1);\n\tvrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);\n\n\tif (!strcmp(str, \"MASTER\"))\n\t\tvrrp->wantstate = VRRP_STATE_MAST;\n\telse if (!strcmp(str, \"BACKUP\"))\n\t{\n\t\tif (vrrp->wantstate == VRRP_STATE_MAST)\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"(%s) state previously set as MASTER - ignoring BACKUP\", vrrp->iname);\n\t\telse\n\t\t\tvrrp->wantstate = VRRP_STATE_BACK;\n\t}\n\telse {\n\t\treport_config_error(CONFIG_GENERAL_ERROR,\"(%s) unknown state '%s', defaulting to BACKUP\", vrrp->iname, str);\n\t\tvrrp->wantstate = VRRP_STATE_BACK;\n\t}\n}",
        "output": "0",
        "idx": 717
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::string Box_pitm::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n  sstr << indent << \"item_ID: \" << m_item_ID << \"\\n\";\n\n  return sstr.str();\n}",
        "output": "0",
        "idx": 781
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void setUpstreamBytesMeter(const BytesMeterSharedPtr& upstream_bytes_meter) override {\n    // Accumulate the byte measurement from previous upstream request during a retry.\n    upstream_bytes_meter->addWireBytesSent(upstream_bytes_meter_->wireBytesSent());\n    upstream_bytes_meter->addWireBytesReceived(upstream_bytes_meter_->wireBytesReceived());\n    upstream_bytes_meter->addHeaderBytesSent(upstream_bytes_meter_->headerBytesSent());\n    upstream_bytes_meter->addHeaderBytesReceived(upstream_bytes_meter_->headerBytesReceived());\n    upstream_bytes_meter_ = upstream_bytes_meter;\n  }",
        "output": "0",
        "idx": 2382
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(locale_get_display_language) \n{\n    get_icu_disp_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}",
        "output": "1",
        "idx": 425
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void fx_DataView_prototype_set(txMachine* the, txNumber delta, txTypeCoerce coercer, txTypeCallback setter)\n{\n\ttxSlot* instance = fxCheckDataViewInstance(the, mxThis);\n\ttxSlot* view = instance->next;\n\ttxSlot* buffer = view->next;\n\ttxInteger offset = fxArgToByteLength(the, 0, 0);\n\ttxInteger size;\n\tint endian = EndianBig;\n\ttxSlot* value;\n\tif (mxArgc > 1)\n\t\tmxPushSlot(mxArgv(1));\n\telse\n\t\tmxPushUndefined();\n\tvalue = the->stack;\t\n\t(*coercer)(the, value);\n\tif ((mxArgc > 2) && fxToBoolean(the, mxArgv(2)))\n\t\tendian = EndianLittle;\n\tsize = fxCheckDataViewSize(the, view, buffer, XS_MUTABLE);\n\tif ((size < delta) || ((size - delta) < offset))\n\t\tmxRangeError(\"out of range byteOffset\");\n\toffset += view->value.dataView.offset;\n\t(*setter)(the, buffer->value.reference->next, offset, value, endian);\n\tmxPop();\n}",
        "output": "0",
        "idx": 827
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vhost_add_used_and_signal(struct vhost_dev *dev,\n\t\t\t       struct vhost_virtqueue *vq,\n\t\t\t       unsigned int head, int len)\n{\n\tvhost_add_used(vq, head, len);\n\tvhost_signal(dev, vq);\n}",
        "output": "0",
        "idx": 2134
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline void Softmax(const uint8* input_data, const RuntimeShape& input_shape,\n                    int32 input_beta_multiplier, int32 input_beta_left_shift,\n                    int diff_min, uint8* output_data,\n                    const RuntimeShape& output_shape) {\n  SoftmaxParams params;\n  params.input_multiplier = input_beta_multiplier;\n  params.input_left_shift = input_beta_left_shift;\n  params.diff_min = diff_min;\n  Softmax(params, input_shape, input_data, output_shape, output_data);\n}",
        "output": "0",
        "idx": 2456
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {\n        int r;\n\n        assert(p);\n        assert(key);\n\n        /* Checks if the specified packet is a reply for the specified\n         * key and the specified key is the only one in the question\n         * section. */\n\n        if (DNS_PACKET_QR(p) != 1)\n                return 0;\n\n        /* Let's unpack the packet, if that hasn't happened yet. */\n        r = dns_packet_extract(p);\n        if (r < 0)\n                return r;\n\n        if (p->question->n_keys != 1)\n                return 0;\n\n        return dns_resource_key_equal(p->question->keys[0], key);\n}",
        "output": "1",
        "idx": 2916
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,\n\t\t\t\t      packet_info *pinfo, proto_tree *tree,\n\t\t\t\t      dcerpc_info *di, guint8 *drep)\n{\n\tchar *value_name;\n\tproto_item *hidden_item;\n\n\thidden_item = proto_tree_add_uint(\n\t\ttree, hf_printerdata, tvb, offset, 0, 1);\n\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\n\t/* Parse packet */\n\n\toffset = dissect_nt_policy_hnd(\n\t\ttvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,\n\t\tFALSE, FALSE);\n\n\toffset = dissect_ndr_cvstring(\n\t\ttvb, offset, pinfo, tree, di, drep, sizeof(guint16),\n\t\thf_printerdata_value, TRUE, &value_name);\n\n\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", value_name);\n\n\treturn offset;\n}",
        "output": "0",
        "idx": 2726
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PJ_DEF(unsigned) pjmedia_sdp_media_remove_all_attr(pjmedia_sdp_media *m,\n\t\t\t\t\t\t   const char *name)\n{\n    return pjmedia_sdp_attr_remove_all(&m->attr_count, m->attr, name);\n}",
        "output": "0",
        "idx": 1082
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int bson_string_is_db_ref( const unsigned char *string, const int length ) {\n    int result = 0;\n\n    if( length >= 4 ) {\n        if( string[1] == 'r' && string[2] == 'e' && string[3] == 'f' )\n            result = 1;\n    }\n    else if( length >= 3 ) {\n        if( string[1] == 'i' && string[2] == 'd' )\n            result = 1;\n        else if( string[1] == 'd' && string[2] == 'b' )\n            result = 1;\n    }\n\n    return result;\n}",
        "output": "1",
        "idx": 2287
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *asoc,\n\t\t\t\t     sctp_scope_t scope, gfp_t gfp)\n{\n\tint flags;\n\n\t/* Use scoping rules to determine the subset of addresses from\n\t * the endpoint.\n\t */\n\tflags = (PF_INET6 == asoc->base.sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;\n\tif (asoc->peer.ipv4_address)\n\t\tflags |= SCTP_ADDR4_PEERSUPP;\n\tif (asoc->peer.ipv6_address)\n\t\tflags |= SCTP_ADDR6_PEERSUPP;\n\n\treturn sctp_bind_addr_copy(sock_net(asoc->base.sk),\n\t\t\t\t   &asoc->base.bind_addr,\n\t\t\t\t   &asoc->ep->base.bind_addr,\n\t\t\t\t   scope, gfp, flags);\n}",
        "output": "0",
        "idx": 2813
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int raw6_seq_open(struct inode *inode, struct file *file)\n{\n\treturn raw_seq_open(inode, file, &raw_v6_hashinfo, &raw6_seq_ops);\n}",
        "output": "0",
        "idx": 2886
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLitePackParams* data =\n      reinterpret_cast<TfLitePackParams*>(node->builtin_data);\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  switch (output->type) {\n    case kTfLiteFloat32: {\n      return PackImpl<float>(context, node, output, data->values_count,\n                             data->axis);\n    }\n    case kTfLiteUInt8: {\n      return PackImpl<uint8_t>(context, node, output, data->values_count,\n                               data->axis);\n    }\n    case kTfLiteInt8: {\n      return PackImpl<int8_t>(context, node, output, data->values_count,\n                              data->axis);\n    }\n    case kTfLiteInt16: {\n      return PackImpl<int16_t>(context, node, output, data->values_count,\n                               data->axis);\n    }\n    case kTfLiteInt32: {\n      return PackImpl<int32_t>(context, node, output, data->values_count,\n                               data->axis);\n    }\n    case kTfLiteInt64: {\n      return PackImpl<int64_t>(context, node, output, data->values_count,\n                               data->axis);\n    }\n    default: {\n      context->ReportError(context, \"Type '%s' is not supported by pack.\",\n                           TfLiteTypeGetName(output->type));\n      return kTfLiteError;\n    }\n  }\n\n  return kTfLiteOk;\n}",
        "output": "1",
        "idx": 3676
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "htmlParseNameComplex(xmlParserCtxtPtr ctxt) {\n    int len = 0, l;\n    int c;\n    int count = 0;\n\n    /*\n     * Handler for more complex cases\n     */\n    GROW;\n    c = CUR_CHAR(l);\n    if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */\n\t(!IS_LETTER(c) && (c != '_') &&\n         (c != ':'))) {\n\treturn(NULL);\n    }\n\n    while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */\n\t   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n            (c == '.') || (c == '-') ||\n\t    (c == '_') || (c == ':') ||\n\t    (IS_COMBINING(c)) ||\n\t    (IS_EXTENDER(c)))) {\n\tif (count++ > 100) {\n\t    count = 0;\n\t    GROW;\n\t}\n\tlen += l;\n\tNEXTL(l);\n\tc = CUR_CHAR(l);\n    }\n    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));\n}",
        "output": "1",
        "idx": 2041
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err gf_isom_get_track_creation_time(GF_ISOFile *movie, u32 trackNumber, u64 *creationTime, u64 *modificationTime)\n{\n\tGF_TrackBox *trak;\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n\tif (creationTime) *creationTime = trak->Media->mediaHeader->creationTime;\n\tif (creationTime) *modificationTime = trak->Media->mediaHeader->modificationTime;\n\treturn GF_OK;\n}",
        "output": "0",
        "idx": 2564
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "includeFile(FileInfo *nested, CharsString *includedFile,\n\t\tCharacterClass **characterClasses,\n\t\tTranslationTableCharacterAttributes *characterClassAttribute,\n\t\tshort opcodeLengths[], TranslationTableOffset *newRuleOffset,\n\t\tTranslationTableRule **newRule, RuleName **ruleNames,\n\t\tTranslationTableHeader **table) {\n\tint k;\n\tchar includeThis[MAXSTRING];\n\tchar **tableFiles;\n\tint rv;\n\tfor (k = 0; k < includedFile->length; k++)\n\t\tincludeThis[k] = (char)includedFile->chars[k];\n\tincludeThis[k] = 0;\n\ttableFiles = _lou_resolveTable(includeThis, nested->fileName);\n\tif (tableFiles == NULL) {\n\t\terrorCount++;\n\t\treturn 0;\n\t}\n\tif (tableFiles[1] != NULL) {\n\t\terrorCount++;\n\t\tfree_tablefiles(tableFiles);\n\t\t_lou_logMessage(LOG_ERROR,\n\t\t\t\t\"Table list not supported in include statement: 'include %s'\",\n\t\t\t\tincludeThis);\n\t\treturn 0;\n\t}\n\trv = compileFile(*tableFiles, characterClasses, characterClassAttribute,\n\t\t\topcodeLengths, newRuleOffset, newRule, ruleNames, table);\n\tfree_tablefiles(tableFiles);\n\treturn rv;\n}",
        "output": "1",
        "idx": 1462
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void x25_kill_by_neigh(struct x25_neigh *nb)\n{\n\tstruct sock *s;\n\n\twrite_lock_bh(&x25_list_lock);\n\n\tsk_for_each(s, &x25_list)\n\t\tif (x25_sk(s)->neighbour == nb)\n\t\t\tx25_disconnect(s, ENETUNREACH, 0, 0);\n\n\twrite_unlock_bh(&x25_list_lock);\n\n\t/* Remove any related forwards */\n\tx25_clear_forward_by_dev(nb->dev);\n}",
        "output": "1",
        "idx": 1040
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gif_set_get_colormap2 (GifContext *context)\n{\n\tcontext->frame_colormap_size = 0;\n\tcontext->state = GIF_GET_COLORMAP2;\n}",
        "output": "0",
        "idx": 1588
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __init(RBuffer *buf, r_bin_ne_obj_t *bin) {\n\tbin->header_offset = r_buf_read_le16_at (buf, 0x3c);\n\tbin->ne_header = R_NEW0 (NE_image_header);\n\tif (!bin->ne_header) {\n\t\treturn;\n\t}\n\tbin->buf = buf;\n\tr_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header));\n\tbin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;\n\tif (!bin->alignment) {\n\t\tbin->alignment = 1 << 9;\n\t}\n\tbin->os = __get_target_os (bin);\n\n\tut16 offset = bin->ne_header->SegTableOffset + bin->header_offset;\n\tut16 size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);\n\tbin->segment_entries = calloc (1, size);\n\tif (!bin->segment_entries) {\n\t\treturn;\n\t}\n\tr_buf_read_at (buf, offset, (ut8 *)bin->segment_entries, size);\n\tbin->entry_table = calloc (1, bin->ne_header->EntryTableLength);\n\tr_buf_read_at (buf, (ut64)bin->header_offset + bin->ne_header->EntryTableOffset, bin->entry_table, bin->ne_header->EntryTableLength);\n\tbin->imports = r_bin_ne_get_imports (bin);\n\t__ne_get_resources (bin);\n}",
        "output": "1",
        "idx": 3272
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void NumberFormatTest::Test20037_ScientificIntegerOverflow() {\n    IcuTestErrorCode status(*this, \"Test20037_ScientificIntegerOverflow\");\n\n    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));\n    if (U_FAILURE(status)) {\n        dataerrln(\"Unable to create NumberFormat instance.\");\n        return;\n    }\n    Formattable result;\n\n    // Test overflow of exponent\n    nf->parse(u\"1E-2147483648\", result, status);\n    StringPiece sp = result.getDecimalNumber(status);\n    assertEquals(u\"Should snap to zero\",\n                 u\"0\",\n                 {sp.data(), sp.length(), US_INV});\n\n    // Test edge case overflow of exponent\n    result = Formattable();\n    nf->parse(u\"1E-2147483647E-1\", result, status);\n    sp = result.getDecimalNumber(status);\n    assertEquals(u\"Should not overflow and should parse only the first exponent\",\n                 u\"1E-2147483647\",\n                 {sp.data(), sp.length(), US_INV});\n}",
        "output": "1",
        "idx": 2773
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Downstream::inspect_http1_request() {\n  if (req_.method == HTTP_CONNECT) {\n    req_.upgrade_request = true;\n  } else if (req_.http_minor > 0) {\n    auto upgrade = req_.fs.header(http2::HD_UPGRADE);\n    if (upgrade) {\n      const auto &val = upgrade->value;\n      // TODO Perform more strict checking for upgrade headers\n      if (util::streq_l(NGHTTP2_CLEARTEXT_PROTO_VERSION_ID, val.c_str(),\n                        val.size())) {\n        req_.http2_upgrade_seen = true;\n      } else {\n        req_.upgrade_request = true;\n\n        // TODO Should we check Sec-WebSocket-Key, and\n        // Sec-WebSocket-Version as well?\n        if (util::strieq_l(\"websocket\", val)) {\n          req_.connect_proto = ConnectProto::WEBSOCKET;\n        }\n      }\n    }\n  }\n  auto transfer_encoding = req_.fs.header(http2::HD_TRANSFER_ENCODING);\n  if (transfer_encoding) {\n    req_.fs.content_length = -1;\n    if (util::iends_with_l(transfer_encoding->value, \"chunked\")) {\n      chunked_request_ = true;\n    }\n  }\n}",
        "output": "1",
        "idx": 142
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void aes_ctr_cleanup(struct ssh_cipher_struct *cipher){\n    if (cipher != NULL) {\n        if (cipher->aes_key != NULL) {\n            explicit_bzero(cipher->aes_key, sizeof(*cipher->aes_key));\n        }\n        SAFE_FREE(cipher->aes_key);\n    }\n}",
        "output": "0",
        "idx": 2966
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(wddx_serialize_vars)\n{\n\tint num_args, i;\n\twddx_packet *packet;\n\tzval ***args = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"+\", &args, &num_args) == FAILURE) {\n\t\treturn;\n\t}\n\t\t\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, NULL, 0);\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\t\n\tfor (i=0; i<num_args; i++) {\n\t\tif (Z_TYPE_PP(args[i]) != IS_ARRAY && Z_TYPE_PP(args[i]) != IS_OBJECT) {\n\t\t\tconvert_to_string_ex(args[i]);\n\t\t}\n\t\tphp_wddx_add_var(packet, *args[i]);\n\t}\t\n\t\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\tphp_wddx_packet_end(packet);\n\n\tefree(args);\n\n\tZVAL_STRINGL(return_value, packet->c, packet->len, 1);\n\tsmart_str_free(packet);\n\tefree(packet);\n}",
        "output": "1",
        "idx": 2963
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NOEXPORT void save_log() {\n    TCHAR file_name[MAX_PATH];\n    OPENFILENAME ofn;\n    LPTSTR txt;\n    LPSTR str;\n\n    ZeroMemory(&ofn, sizeof ofn);\n    file_name[0]='\\0';\n\n    ofn.lStructSize=sizeof ofn;\n    ofn.hwndOwner=hwnd;\n    ofn.lpstrFilter=TEXT(\"Log Files (*.log)\\0*.log\\0All Files (*.*)\\0*.*\\0\\0\");\n    ofn.lpstrFile=file_name;\n    ofn.nMaxFile=MAX_PATH;\n    ofn.lpstrDefExt=TEXT(\"LOG\");\n    ofn.lpstrInitialDir=TEXT(\".\");\n\n    ofn.lpstrTitle=TEXT(\"Save Log\");\n    ofn.Flags=OFN_EXPLORER|OFN_PATHMUSTEXIST|OFN_HIDEREADONLY|\n        OFN_OVERWRITEPROMPT;\n    if(!GetSaveFileName(&ofn))\n        return;\n\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_WIN_LOG]);\n    txt=log_txt(); /* need to convert the result to UTF-8 */\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_WIN_LOG]);\n    str=tstr2str(txt);\n    str_free(txt);\n    save_text_file(file_name, str);\n    str_free(str);\n}",
        "output": "0",
        "idx": 406
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cmd_starttls_next(struct smtp_server_cmd_ctx *cmd, void *context ATTR_UNUSED)\n{\n\tstruct smtp_server_connection *conn = cmd->conn;\n\tstruct smtp_server_command *command = cmd->cmd;\n\tconst struct smtp_server_callbacks *callbacks = conn->callbacks;\n\tint ret;\n\n\tsmtp_server_connection_set_state(conn, SMTP_SERVER_STATE_STARTTLS,\n\t\t\t\t\t NULL);\n\n\tsmtp_server_command_ref(command);\n\tif (callbacks != NULL && callbacks->conn_cmd_starttls != NULL)\n\t\tret = callbacks->conn_cmd_starttls(conn->context, cmd);\n\telse\n\t\tret = 1;\n\n\tsmtp_server_command_add_hook(command, SMTP_SERVER_COMMAND_HOOK_DESTROY,\n\t\t\t\t     cmd_starttls_destroy, NULL);\n\n\tif (ret <= 0) {\n\t\ti_assert(ret == 0 || smtp_server_command_is_replied(command));\n\t\t/* command is waiting for external event or it failed */\n\t\tsmtp_server_command_unref(&command);\n\t\treturn;\n\t}\n\tif (!smtp_server_command_is_replied(command)) {\n\t\tsmtp_server_reply(cmd,\n\t\t\t220, \"2.0.0\", \"Begin TLS negotiation now.\");\n\t}\n\tsmtp_server_command_unref(&command);\n}",
        "output": "1",
        "idx": 2935
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "proto_read_ulong_buffer (p11_rpc_message *msg,\n                         CK_ULONG_PTR *buffer,\n                         CK_ULONG *n_buffer)\n{\n\tuint32_t length;\n\n\tassert (msg != NULL);\n\tassert (buffer != NULL);\n\tassert (n_buffer != NULL);\n\tassert (msg->input != NULL);\n\n\t/* Check that we're supposed to be reading this at this point */\n\tassert (!msg->signature || p11_rpc_message_verify_part (msg, \"fu\"));\n\n\t/* The number of ulongs there's room for on the other end */\n\tif (!p11_rpc_buffer_get_uint32 (msg->input, &msg->parsed, &length))\n\t\treturn PARSE_ERROR;\n\n\t*n_buffer = length;\n\t*buffer = NULL;\n\n\t/* If set to zero, then they just want the length */\n\tif (length == 0)\n\t\treturn CKR_OK;\n\n\t*buffer = p11_rpc_message_alloc_extra (msg, length * sizeof (CK_ULONG));\n\tif (!*buffer)\n\t\treturn CKR_DEVICE_MEMORY;\n\n\treturn CKR_OK;\n}",
        "output": "1",
        "idx": 1278
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  bool IsSupported(const NodeDef* node) const override {\n    return IsAnySparseSegmentReduction(*node);\n  }",
        "output": "0",
        "idx": 693
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void add_preferred_base(unsigned char *sha1)\n{\n\tstruct pbase_tree *it;\n\tvoid *data;\n\tunsigned long size;\n\tunsigned char tree_sha1[20];\n\n\tif (window <= num_preferred_base++)\n\t\treturn;\n\n\tdata = read_object_with_reference(sha1, tree_type, &size, tree_sha1);\n\tif (!data)\n\t\treturn;\n\n\tfor (it = pbase_tree; it; it = it->next) {\n\t\tif (!hashcmp(it->pcache.sha1, tree_sha1)) {\n\t\t\tfree(data);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tit = xcalloc(1, sizeof(*it));\n\tit->next = pbase_tree;\n\tpbase_tree = it;\n\n\thashcpy(it->pcache.sha1, tree_sha1);\n\tit->pcache.tree_data = data;\n\tit->pcache.tree_size = size;\n}",
        "output": "0",
        "idx": 3384
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NTSTATUS check_access_fsp(struct files_struct *fsp,\n\t\t\t  uint32_t access_mask)\n{\n\tif (!fsp->fsp_flags.is_fsa) {\n\t\treturn smbd_check_access_rights_fsp(fsp->conn->cwd_fsp,\n\t\t\t\t\t\t    fsp,\n\t\t\t\t\t\t    false,\n\t\t\t\t\t\t    access_mask);\n\t}\n\tif (!(fsp->access_mask & access_mask)) {\n\t\treturn NT_STATUS_ACCESS_DENIED;\n\t}\n\treturn NT_STATUS_OK;\n}",
        "output": "0",
        "idx": 1435
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "lzh_emit_window(struct lzh_stream *strm, size_t s)\n{\n\tstrm->ref_ptr = strm->ds->w_buff;\n\tstrm->avail_out = (int)s;\n\tstrm->total_out += s;\n}",
        "output": "0",
        "idx": 2276
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplDoublyLinkedList, getIteratorMode)\n{\n\tspl_dllist_object *intern;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern = Z_SPLDLLIST_P(getThis());\n\n\tRETURN_LONG(intern->flags);\n}",
        "output": "0",
        "idx": 1006
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int spk_ttyio_ldisc_open(struct tty_struct *tty)\n{\n\tstruct spk_ldisc_data *ldisc_data;\n\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&speakup_tty_mutex);\n\tif (speakup_tty) {\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\treturn -EBUSY;\n\t}\n\tspeakup_tty = tty;\n\n\tldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);\n\tif (!ldisc_data) {\n\t\tspeakup_tty = NULL;\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tinit_completion(&ldisc_data->completion);\n\tldisc_data->buf_free = true;\n\tspeakup_tty->disc_data = ldisc_data;\n\tmutex_unlock(&speakup_tty_mutex);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 2424
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MagickBooleanType Huffman2DEncodeImage(const ImageInfo *image_info,\n  Image *image,Image *inject_image,ExceptionInfo *exception)\n{\n  Image\n    *group4_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  unsigned char\n    *group4;\n\n  status=MagickTrue;\n  write_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(write_info->filename,\"GROUP4:\",MagickPathExtent);\n  (void) CopyMagickString(write_info->magick,\"GROUP4\",MagickPathExtent);\n  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);\n  if (group4_image == (Image *) NULL)\n    return(MagickFalse);\n  group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,\n    exception);\n  group4_image=DestroyImage(group4_image);\n  if (group4 == (unsigned char *) NULL)\n    return(MagickFalse);\n  write_info=DestroyImageInfo(write_info);\n  if (WriteBlob(image,length,group4) != (ssize_t) length)\n    status=MagickFalse;\n  group4=(unsigned char *) RelinquishMagickMemory(group4);\n  return(status);\n}",
        "output": "1",
        "idx": 1732
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ssh_buffer_add_data(struct ssh_buffer_struct *buffer, const void *data, uint32_t len)\n{\n    buffer_verify(buffer);\n\n    if (data == NULL) {\n        return -1;\n    }\n\n    if (buffer->used + len < len) {\n        return -1;\n    }\n\n    if (buffer->allocated < (buffer->used + len)) {\n        if (buffer->pos > 0) {\n            buffer_shift(buffer);\n        }\n        if (realloc_buffer(buffer, buffer->used + len) < 0) {\n            return -1;\n        }\n    }\n\n    memcpy(buffer->data + buffer->used, data, len);\n    buffer->used += len;\n    buffer_verify(buffer);\n    return 0;\n}",
        "output": "1",
        "idx": 880
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cooked(\n\tstruct parse *pcmd,\n\tFILE *fp\n\t)\n{\n\trawmode = 0;\n\t(void) fprintf(fp, \"Output set to cooked\\n\");\n\treturn;\n}",
        "output": "0",
        "idx": 2954
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void write_png_palette(int idx, uint32_t pix, void *opaque)\n{\n    struct palette_cb_priv *priv = opaque;\n    VncState *vs = priv->vs;\n    png_colorp color = &priv->png_palette[idx];\n\n    if (vs->tight.pixel24)\n    {\n        color->red = (pix >> vs->client_pf.rshift) & vs->client_pf.rmax;\n        color->green = (pix >> vs->client_pf.gshift) & vs->client_pf.gmax;\n        color->blue = (pix >> vs->client_pf.bshift) & vs->client_pf.bmax;\n    }\n    else\n    {\n        int red, green, blue;\n\n        red = (pix >> vs->client_pf.rshift) & vs->client_pf.rmax;\n        green = (pix >> vs->client_pf.gshift) & vs->client_pf.gmax;\n        blue = (pix >> vs->client_pf.bshift) & vs->client_pf.bmax;\n        color->red = ((red * 255 + vs->client_pf.rmax / 2) /\n                      vs->client_pf.rmax);\n        color->green = ((green * 255 + vs->client_pf.gmax / 2) /\n                        vs->client_pf.gmax);\n        color->blue = ((blue * 255 + vs->client_pf.bmax / 2) /\n                       vs->client_pf.bmax);\n    }\n}",
        "output": "1",
        "idx": 3418
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Box *trgt_New()\n{\n\tISOM_DECL_BOX_ALLOC(GF_TrackGroupTypeBox, GF_ISOM_BOX_TYPE_TRGT);\n\treturn (GF_Box *)tmp;\n}",
        "output": "0",
        "idx": 787
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ecryptfs_free_kmem_caches(void)\n{\n\tint i;\n\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {\n\t\tstruct ecryptfs_cache_info *info;\n\n\t\tinfo = &ecryptfs_cache_infos[i];\n\t\tif (*(info->cache))\n\t\t\tkmem_cache_destroy(*(info->cache));\n\t}\n}",
        "output": "0",
        "idx": 3060
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ContentSettingsObserver::AllowScript(bool enabled_per_settings) {\n  if (!enabled_per_settings)\n    return false;\n  if (IsScriptDisabledForPreview(render_frame()))\n    return false;\n  if (is_interstitial_page_)\n    return true;\n\n  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();\n  const auto it = cached_script_permissions_.find(frame);\n  if (it != cached_script_permissions_.end())\n    return it->second;\n\n  // Evaluate the content setting rules before\n  // IsWhitelistedForContentSettings(); if there is only the default rule\n  // allowing all scripts, it's quicker this way.\n  bool allow = true;\n  if (content_setting_rules_) {\n    ContentSetting setting = GetContentSettingFromRules(\n        content_setting_rules_->script_rules, frame,\n        url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL());\n    allow = setting != CONTENT_SETTING_BLOCK;\n  }\n  allow = allow || IsWhitelistedForContentSettings();\n\n  cached_script_permissions_[frame] = allow;\n  return allow;\n}",
        "output": "1",
        "idx": 978
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool can_follow_write_pmd(pmd_t pmd, unsigned int flags)\n{\n\treturn pmd_write(pmd) ||\n\t       ((flags & FOLL_FORCE) && (flags & FOLL_COW) && pmd_dirty(pmd));\n}",
        "output": "1",
        "idx": 2050
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ap_lua_push_connection(lua_State *L, conn_rec *c)\n{\n    req_table_t* t;\n    lua_boxpointer(L, c);\n    luaL_getmetatable(L, \"Apache2.Connection\");\n    lua_setmetatable(L, -2);\n    luaL_getmetatable(L, \"Apache2.Connection\");\n\n    t = apr_pcalloc(c->pool, sizeof(req_table_t));\n    t->t = c->notes;\n    t->r = NULL;\n    t->n = \"notes\";\n    ap_lua_push_apr_table(L, t);\n    lua_setfield(L, -2, \"notes\");\n\n    lua_pushstring(L, c->client_ip);\n    lua_setfield(L, -2, \"client_ip\");\n\n    lua_pop(L, 1);\n}",
        "output": "0",
        "idx": 1942
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\nstatic void napi_skb_free_stolen_head(struct sk_buff *skb)\n{\n\tskb_dst_drop(skb);\n\tsecpath_reset(skb);\n\tkmem_cache_free(skbuff_head_cache, skb);",
        "output": "0",
        "idx": 1351
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void jas_icctxtdesc_destroy(jas_iccattrval_t *attrval)\n{\n\tjas_icctxtdesc_t *txtdesc = &attrval->data.txtdesc;\n\tif (txtdesc->ascdata)\n\t\tjas_free(txtdesc->ascdata);\n\tif (txtdesc->ucdata)\n\t\tjas_free(txtdesc->ucdata);\n}",
        "output": "1",
        "idx": 2039
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\tsigset_t m;\n\n\tsigandsets(&m, mask, &s->signal);\n\tif (sigisemptyset(&m))\n\t\treturn;\n\n\tsigandnsets(&s->signal, &s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (sigismember(mask, q->info.si_signo)) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n}",
        "output": "0",
        "idx": 902
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_user_string(optstr)\nchar *optstr;\n{\n    struct passwd *pw;\n    int pwlen;\n    char *eop, *w;\n    char *pwname = 0;\n\n    if (optstr[0] == '*')\n        return TRUE; /* allow any user */\n    if (sysopt.check_plname)\n        pwname = plname;\n    else if ((pw = get_unix_pw()) != 0)\n        pwname = pw->pw_name;\n    if (!pwname || !*pwname)\n        return FALSE;\n    pwlen = (int) strlen(pwname);\n    eop = eos(optstr);\n    w = optstr;\n    while (w + pwlen <= eop) {\n        if (!*w)\n            break;\n        if (isspace(*w)) {\n            w++;\n            continue;\n        }\n        if (!strncmp(w, pwname, pwlen)) {\n            if (!w[pwlen] || isspace(w[pwlen]))\n                return TRUE;\n        }\n        while (*w && !isspace(*w))\n            w++;\n    }\n    return FALSE;\n}",
        "output": "0",
        "idx": 2725
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t get_lease(struct dhcp_packet *packet)\n{\n\tuint8_t *option;\n\tuint32_t lease_seconds;\n\n\toption = dhcp_get_option(packet, DHCP_LEASE_TIME);\n\tif (!option)\n\t\treturn 3600;\n\n\tlease_seconds = get_be32(option);\n\n\tif (lease_seconds < 10)\n\t\tlease_seconds = 10;\n\n\treturn lease_seconds;\n}",
        "output": "1",
        "idx": 2894
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sisusb_check_rbc(struct sisusb_usb_data *sisusb, int *iret,\n\t\tu32 inc, int testn)\n{\n\tint ret = 0, i;\n\tu32 j, tmp;\n\n\t*iret = 0;\n\n\tfor (i = 0, j = 0; i < testn; i++) {\n\t\tret |= WRITEL(sisusb->vrambase + j, j);\n\t\tj += inc;\n\t}\n\n\tfor (i = 0, j = 0; i < testn; i++) {\n\t\tret |= READL(sisusb->vrambase + j, &tmp);\n\t\tif (tmp != j)\n\t\t\treturn ret;\n\n\t\tj += inc;\n\t}\n\n\t*iret = 1;\n\treturn ret;\n}",
        "output": "0",
        "idx": 2673
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int valid_entry_name(const char *filename)\n{\n\treturn *filename != '\\0' &&\n\t\tstrchr(filename, '/') == NULL &&\n\t\t(*filename != '.' ||\n\t\t (strcmp(filename, \".\") != 0 &&\n\t\t  strcmp(filename, \"..\") != 0 &&\n\t\t  strcmp(filename, DOT_GIT) != 0));\n}",
        "output": "1",
        "idx": 2759
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_P(Http2CodecImplTest, HeaderNameWithUnderscoreAreRejectedByDefault) {\n  headers_with_underscores_action_ = envoy::config::core::v3::HttpProtocolOptions::REJECT_REQUEST;\n  initialize();\n\n  TestRequestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  request_headers.addCopy(\"bad_header\", \"something\");\n  EXPECT_CALL(server_stream_callbacks_, onResetStream(_, _)).Times(1);\n  request_encoder_->encodeHeaders(request_headers, false);\n  EXPECT_EQ(1, stats_store_.counter(\"http2.requests_rejected_with_underscores_in_headers\").value());\n}",
        "output": "1",
        "idx": 2243
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int check_ptr_alignment(struct bpf_verifier_env *env,\n\t\t\t       const struct bpf_reg_state *reg,\n\t\t\t       int off, int size)\n{\n\tbool strict = env->strict_alignment;\n\tconst char *pointer_desc = \"\";\n\n\tswitch (reg->type) {\n\tcase PTR_TO_PACKET:\n\tcase PTR_TO_PACKET_META:\n\t\t/* Special case, because of NET_IP_ALIGN. Given metadata sits\n\t\t * right in front, treat it the very same way.\n\t\t */\n\t\treturn check_pkt_ptr_alignment(env, reg, off, size, strict);\n\tcase PTR_TO_MAP_VALUE:\n\t\tpointer_desc = \"value \";\n\t\tbreak;\n\tcase PTR_TO_CTX:\n\t\tpointer_desc = \"context \";\n\t\tbreak;\n\tcase PTR_TO_STACK:\n\t\tpointer_desc = \"stack \";\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn check_generic_ptr_alignment(env, reg, pointer_desc, off, size,\n\t\t\t\t\t   strict);\n}",
        "output": "1",
        "idx": 214
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void yurex_disconnect(struct usb_interface *interface)\n{\n\tstruct usb_yurex *dev;\n\tint minor = interface->minor;\n\n\tdev = usb_get_intfdata(interface);\n\tusb_set_intfdata(interface, NULL);\n\n\t/* give back our minor */\n\tusb_deregister_dev(interface, &yurex_class);\n\n\t/* prevent more I/O from starting */\n\tmutex_lock(&dev->io_mutex);\n\tdev->interface = NULL;\n\tmutex_unlock(&dev->io_mutex);\n\n\t/* wakeup waiters */\n\tkill_fasync(&dev->async_queue, SIGIO, POLL_IN);\n\twake_up_interruptible(&dev->waitq);\n\n\t/* decrement our usage count */\n\tkref_put(&dev->kref, yurex_delete);\n\n\tdev_info(&interface->dev, \"USB YUREX #%d now disconnected\\n\", minor);\n}",
        "output": "1",
        "idx": 1604
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mongo_pass_digest( const char *user, const char *pass, char hex_digest[33] ) {\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )\":mongo:\", 7 );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )pass, strlen( pass ) );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n}",
        "output": "1",
        "idx": 1569
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rtnl_group_changelink(struct net *net, int group,\n\t\tstruct ifinfomsg *ifm,\n\t\tstruct nlattr **tb)\n{\n\tstruct net_device *dev;\n\tint err;\n\n\tfor_each_netdev(net, dev) {\n\t\tif (dev->group == group) {\n\t\t\terr = do_setlink(dev, ifm, tb, NULL, 0);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 232
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ZipTest::testDecompress()\n{\n\tstd::string testFile = getTestFile(\"data\", \"test.zip\");\n\tstd::ifstream inp(testFile.c_str(), std::ios::binary);\n\tassert (inp.good());\n\tDecompress dec(inp, Poco::Path());\n\tdec.EError += Poco::Delegate<ZipTest, std::pair<const Poco::Zip::ZipLocalFileHeader, const std::string> >(this, &ZipTest::onDecompressError);\n\tdec.decompressAllFiles();\n\tdec.EError -= Poco::Delegate<ZipTest, std::pair<const Poco::Zip::ZipLocalFileHeader, const std::string> >(this, &ZipTest::onDecompressError);\n\tassert (_errCnt == 0);\n\tassert (!dec.mapping().empty());\n}",
        "output": "1",
        "idx": 2932
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rtp_packetize_ac3( sout_stream_id_sys_t *id, block_t *in )\n{\n    int     i_max   = rtp_mtu (id) - 2; /* payload max in one packet */\n    int     i_count = ( in->i_buffer + i_max - 1 ) / i_max;\n\n    uint8_t *p_data = in->p_buffer;\n    int     i_data  = in->i_buffer;\n    int     i;\n\n    for( i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 14 + i_payload );\n\n        /* rtp common header */\n        rtp_packetize_common( id, out, (i == i_count - 1)?1:0, in->i_pts );\n        /* unit count */\n        out->p_buffer[12] = 1;\n        /* unit header */\n        out->p_buffer[13] = 0x00;\n        /* data */\n        memcpy( &out->p_buffer[14], p_data, i_payload );\n\n        out->i_dts    = in->i_dts + i * in->i_length / i_count;\n        out->i_length = in->i_length / i_count;\n\n        rtp_packetize_send( id, out );\n\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n\n    block_Release(in);\n    return VLC_SUCCESS;\n}",
        "output": "0",
        "idx": 1331
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CommandHelpers::appendSimpleCommandStatus(BSONObjBuilder& result,\n                                               bool ok,\n                                               const std::string& errmsg) {\n    BSONObj tmp = result.asTempObj();\n    bool have_ok = tmp.hasField(\"ok\");\n    bool need_errmsg = !ok && !tmp.hasField(\"errmsg\");\n\n    if (!have_ok)\n        result.append(\"ok\", ok ? 1.0 : 0.0);\n\n    if (need_errmsg) {\n        result.append(\"errmsg\", errmsg);\n    }\n}",
        "output": "0",
        "idx": 3002
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    if (sz + idx > maxSz) {\n        return WS_BUFFER_E;\n    }",
        "output": "1",
        "idx": 2678
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static js_Ast *additive(js_State *J)\n{\n\tjs_Ast *a = multiplicative(J);\nloop:\n\tif (jsP_accept(J, '+')) { a = EXP2(ADD, a, multiplicative(J)); goto loop; }\n\tif (jsP_accept(J, '-')) { a = EXP2(SUB, a, multiplicative(J)); goto loop; }\n\treturn a;\n}",
        "output": "1",
        "idx": 2743
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_hb_buffer_next_glyph ( HB_Buffer buffer )\n{\n  HB_Error  error;\n\n  if ( buffer->separate_out )\n    {\n      error = hb_buffer_ensure( buffer, buffer->out_pos + 1 );\n      if ( error )\n\treturn error;\n\n      buffer->out_string[buffer->out_pos] = buffer->in_string[buffer->in_pos];\n    }\n\n  buffer->in_pos++;\n  buffer->out_pos++;\n  buffer->out_length = buffer->out_pos;\n\n  return HB_Err_Ok;\n}",
        "output": "1",
        "idx": 1962
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pg_role_aclcheck(Oid role_oid, Oid roleid, AclMode mode)\n{\n\tif (mode & ACL_GRANT_OPTION_FOR(ACL_CREATE))\n\t{\n\t\tif (is_admin_of_role(roleid, role_oid))\n\t\t\treturn ACLCHECK_OK;\n\t}\n\tif (mode & ACL_CREATE)\n\t{\n\t\tif (is_member_of_role(roleid, role_oid))\n\t\t\treturn ACLCHECK_OK;\n\t}\n\tif (mode & ACL_USAGE)\n\t{\n\t\tif (has_privs_of_role(roleid, role_oid))\n\t\t\treturn ACLCHECK_OK;\n\t}\n\treturn ACLCHECK_NO_PRIV;\n}",
        "output": "1",
        "idx": 1603
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BOOL ber_read_universal_tag(wStream* s, BYTE tag, BOOL pc)\n{\n\tBYTE byte;\n\n\tif(Stream_GetRemainingLength(s) < 1)\n\t\treturn FALSE;\n\tStream_Read_UINT8(s, byte);\n\n\tif (byte != (BER_CLASS_UNIV | BER_PC(pc) | (BER_TAG_MASK & tag)))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}",
        "output": "1",
        "idx": 1152
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "megasas_read_fw_status_reg_xscale(struct megasas_instance *instance)\n{\n\treturn readl(&instance->reg_set->outbound_msg_0);\n}",
        "output": "0",
        "idx": 1468
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ruby_scan_oct(const char *start, size_t len, size_t *retlen)\n{\n    register const char *s = start;\n    register unsigned long retval = 0;\n\n    while (len-- && *s >= '0' && *s <= '7') {\n\tretval <<= 3;\n\tretval |= *s++ - '0';\n    }\n    *retlen = (int)(s - start);\t/* less than len */\n    return retval;\n}",
        "output": "0",
        "idx": 3362
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HBasicBlock::Verify() {\n  // Check that every block is finished.\n  ASSERT(IsFinished());\n  ASSERT(block_id() >= 0);\n\n  // Check that the incoming edges are in edge split form.\n  if (predecessors_.length() > 1) {\n    for (int i = 0; i < predecessors_.length(); ++i) {\n      ASSERT(predecessors_[i]->end()->SecondSuccessor() == NULL);\n    }\n  }\n}",
        "output": "0",
        "idx": 681
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jpc_dec_process_qcc(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_qcc_t *qcc = &ms->parms.qcc;\n\tjpc_dec_tile_t *tile;\n\n\tif (JAS_CAST(int, qcc->compno) > dec->numcomps) {\n\t\tjas_eprintf(\"invalid component number in QCC marker segment\\n\");\n\t\treturn -1;\n\t}\n\tswitch (dec->state) {\n\tcase JPC_MH:\n\t\tjpc_dec_cp_setfromqcc(dec->cp, qcc);\n\t\tbreak;\n\tcase JPC_TPH:\n\t\tif (!(tile = dec->curtile)) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (tile->partno > 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tjpc_dec_cp_setfromqcc(tile->cp, qcc);\n\t\tbreak;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 1389
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mono_register_jit_icall (gconstpointer func, const char *name, MonoMethodSignature *sig, gboolean is_save)\n{\n\tMonoJitICallInfo *info;\n\t\n\tg_assert (func);\n\tg_assert (name);\n\n\tmono_loader_lock ();\n\n\tif (!jit_icall_hash_name) {\n\t\tjit_icall_hash_name = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);\n\t\tjit_icall_hash_addr = g_hash_table_new (NULL, NULL);\n\t}\n\n\tif (g_hash_table_lookup (jit_icall_hash_name, name)) {\n\t\tg_warning (\"jit icall already defined \\\"%s\\\"\\n\", name);\n\t\tg_assert_not_reached ();\n\t}\n\n\tinfo = g_new0 (MonoJitICallInfo, 1);\n\t\n\tinfo->name = name;\n\tinfo->func = func;\n\tinfo->sig = sig;\n\n\tif (is_save) {\n\t\tinfo->wrapper = func;\n\t} else {\n\t\tinfo->wrapper = NULL;\n\t}\n\n\tg_hash_table_insert (jit_icall_hash_name, (gpointer)info->name, info);\n\tg_hash_table_insert (jit_icall_hash_addr, (gpointer)func, info);\n\n\tmono_loader_unlock ();\n\treturn info;\n}",
        "output": "0",
        "idx": 2824
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void start_cfs_slack_bandwidth(struct cfs_bandwidth *cfs_b)\n{\n\tu64 min_left = cfs_bandwidth_slack_period + min_bandwidth_expiration;\n\n\t/* if there's a quota refresh soon don't bother with slack */\n\tif (runtime_refresh_within(cfs_b, min_left))\n\t\treturn;\n\n\t/* don't push forwards an existing deferred unthrottle */\n\tif (cfs_b->slack_started)\n\t\treturn;\n\tcfs_b->slack_started = true;\n\n\thrtimer_start(&cfs_b->slack_timer,\n\t\t\tns_to_ktime(cfs_bandwidth_slack_period),\n\t\t\tHRTIMER_MODE_REL);\n}",
        "output": "0",
        "idx": 332
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int is_inside_work_tree(void)\n{\n\tif (inside_work_tree < 0)\n\t\tinside_work_tree = is_inside_dir(get_git_work_tree());\n\treturn inside_work_tree;\n}",
        "output": "0",
        "idx": 1120
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pwc_cleanup(struct pwc_device *pdev)\n{\n\tpwc_remove_sysfs_files(pdev->vdev);\n\tvideo_unregister_device(pdev->vdev);\n}",
        "output": "0",
        "idx": 2545
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vhost_user_send_rarp(struct virtio_net **pdev, struct VhostUserMsg *msg,\n\t\t\tint main_fd __rte_unused)\n{\n\tstruct virtio_net *dev = *pdev;\n\tuint8_t *mac = (uint8_t *)&msg->payload.u64;\n\tstruct rte_vdpa_device *vdpa_dev;\n\tint did = -1;\n\n\tRTE_LOG(DEBUG, VHOST_CONFIG,\n\t\t\":: mac: %02x:%02x:%02x:%02x:%02x:%02x\\n\",\n\t\tmac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n\tmemcpy(dev->mac.addr_bytes, mac, 6);\n\n\t/*\n\t * Set the flag to inject a RARP broadcast packet at\n\t * rte_vhost_dequeue_burst().\n\t *\n\t * rte_smp_wmb() is for making sure the mac is copied\n\t * before the flag is set.\n\t */\n\trte_smp_wmb();\n\trte_atomic16_set(&dev->broadcast_rarp, 1);\n\tdid = dev->vdpa_dev_id;\n\tvdpa_dev = rte_vdpa_get_device(did);\n\tif (vdpa_dev && vdpa_dev->ops->migration_done)\n\t\tvdpa_dev->ops->migration_done(dev->vid);\n\n\treturn RTE_VHOST_MSG_RESULT_OK;\n}",
        "output": "1",
        "idx": 2177
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int putint(jas_stream_t *out, int sgnd, int prec, long val)\n{\n\tint n;\n\tint c;\n\tif (sgnd) {\n\t\t/* XXX - Do something here. */\n\t\tabort();\n\t}\n\tval &= (1 << prec) - 1;\n\tn = (prec + 7) / 8;\n\twhile (--n >= 0) {\n\t\tc = (val >> (n * 8)) & 0xff;\n\t\tif (jas_stream_putc(out, c) != c)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 1313
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)\n{\n    for (int j = 0; abs_symbol_names[j][0]; ++j) {\n        unsigned st_name = get_te32(&sym->st_name);\n        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {\n            sym->st_value += delta;\n            return 1;\n        }\n    }\n    return 0;\n}",
        "output": "1",
        "idx": 3286
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gst_asf_demux_get_stream_audio (asf_stream_audio * audio, guint8 ** p_data,\n    guint64 * p_size)\n{\n  if (*p_size < (2 + 2 + 4 + 4 + 2 + 2 + 2))\n    return FALSE;\n\n  /* WAVEFORMATEX Structure */\n  audio->codec_tag = gst_asf_demux_get_uint16 (p_data, p_size);\n  audio->channels = gst_asf_demux_get_uint16 (p_data, p_size);\n  audio->sample_rate = gst_asf_demux_get_uint32 (p_data, p_size);\n  audio->byte_rate = gst_asf_demux_get_uint32 (p_data, p_size);\n  audio->block_align = gst_asf_demux_get_uint16 (p_data, p_size);\n  audio->word_size = gst_asf_demux_get_uint16 (p_data, p_size);\n  /* Codec specific data size */\n  audio->size = gst_asf_demux_get_uint16 (p_data, p_size);\n  if (audio->size > *p_size) {\n    GST_WARNING (\"Corrupted audio codec_data (should be at least %u bytes, is %\"\n        G_GUINT64_FORMAT \" long)\", audio->size, *p_size);\n    return FALSE;\n  }\n  return TRUE;\n}",
        "output": "0",
        "idx": 3409
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BROTLI_INLINE uint32_t BrotliGetAvailableBits(\n    const BrotliBitReader* br) {\n  return (BROTLI_64_BITS ? 64 : 32) - br->bit_pos_;\n}",
        "output": "0",
        "idx": 1186
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dtls1_hm_fragment_free(hm_fragment *frag)\n{\n    if (!frag)\n        return;\n    if (frag->msg_header.is_ccs) {\n        EVP_CIPHER_CTX_free(frag->msg_header.\n                            saved_retransmit_state.enc_write_ctx);\n        EVP_MD_CTX_free(frag->msg_header.saved_retransmit_state.write_hash);\n    }\n    OPENSSL_free(frag->fragment);\n    OPENSSL_free(frag->reassembly);\n    OPENSSL_free(frag);\n}",
        "output": "0",
        "idx": 2148
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ssl3_record_sequence_update(unsigned char *seq)\n{\n    int i;\n\n    for (i = 7; i >= 0; i--) {\n        ++seq[i];\n        if (seq[i] != 0)\n            break;\n    }\n}",
        "output": "0",
        "idx": 3533
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void coroutine_fn mirror_wait_on_conflicts(MirrorOp *self,\n                                                  MirrorBlockJob *s,\n                                                  uint64_t offset,\n                                                  uint64_t bytes)\n{\n    uint64_t self_start_chunk = offset / s->granularity;\n    uint64_t self_end_chunk = DIV_ROUND_UP(offset + bytes, s->granularity);\n    uint64_t self_nb_chunks = self_end_chunk - self_start_chunk;\n\n    while (find_next_bit(s->in_flight_bitmap, self_end_chunk,\n                         self_start_chunk) < self_end_chunk &&\n           s->ret >= 0)\n    {\n        MirrorOp *op;\n\n        QTAILQ_FOREACH(op, &s->ops_in_flight, next) {\n            uint64_t op_start_chunk = op->offset / s->granularity;\n            uint64_t op_nb_chunks = DIV_ROUND_UP(op->offset + op->bytes,\n                                                 s->granularity) -\n                                    op_start_chunk;\n\n            if (op == self) {\n                continue;\n            }\n\n            if (ranges_overlap(self_start_chunk, self_nb_chunks,\n                               op_start_chunk, op_nb_chunks))\n            {\n                qemu_co_queue_wait(&op->waiting_requests, NULL);\n                break;\n            }\n        }\n    }\n}",
        "output": "1",
        "idx": 3071
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool PackLinuxElf32::calls_crt1(Elf32_Rel const *rel, int sz)\n{\n    if (!dynsym || !dynstr) {\n        return false;\n    }\n    for (; 0 < sz; (sz -= sizeof(Elf32_Rel)), ++rel) {\n        unsigned const symnum = get_te32(&rel->r_info) >> 8;\n        char const *const symnam = get_te32(&dynsym[symnum].st_name) + dynstr;\n        if (0==strcmp(symnam, \"__libc_start_main\")  // glibc\n        ||  0==strcmp(symnam, \"__libc_init\")  // Android\n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;\n    }\n    return false;\n}",
        "output": "0",
        "idx": 3387
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned int ldb_get_flags(struct ldb_context *ldb)\n{\n\treturn ldb->flags;\n}",
        "output": "0",
        "idx": 909
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sd_read_block_characteristics(struct scsi_disk *sdkp)\n{\n\tunsigned char *buffer;\n\tu16 rot;\n\tconst int vpd_len = 64;\n\n\tbuffer = kmalloc(vpd_len, GFP_KERNEL);\n\n\tif (!buffer ||\n\t    /* Block Device Characteristics VPD */\n\t    scsi_get_vpd_page(sdkp->device, 0xb1, buffer, vpd_len))\n\t\tgoto out;\n\n\trot = get_unaligned_be16(&buffer[4]);\n\n\tif (rot == 1)\n\t\tqueue_flag_set_unlocked(QUEUE_FLAG_NONROT, sdkp->disk->queue);\n\n out:\n\tkfree(buffer);\n}",
        "output": "0",
        "idx": 43
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "onig_set_callout_user_data_of_match_param(OnigMatchParam* param, void* user_data)\n{\n#ifdef USE_CALLOUT\n  param->callout_user_data = user_data;\n  return ONIG_NORMAL;\n#else\n  return ONIG_NO_SUPPORT_CONFIG;\n#endif\n}",
        "output": "0",
        "idx": 2840
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ogmaudio_type_find (GstTypeFind * tf, gpointer private)\n{\n  const guint8 *data = gst_type_find_peek (tf, 0, 9);\n\n  if (data) {\n    if (memcmp (data, \"\\001audio\\000\\000\\000\", 9) != 0)\n      return;\n    gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, OGMAUDIO_CAPS);\n  }\n}",
        "output": "0",
        "idx": 1477
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\nstatic int implement_date_interface_handler(zend_class_entry *interface, zend_class_entry *implementor TSRMLS_DC)\n{\n\tif (implementor->type == ZEND_USER_CLASS &&\n\t\t!instanceof_function(implementor, date_ce_date TSRMLS_CC) &&\n\t\t!instanceof_function(implementor, date_ce_immutable TSRMLS_CC)\n\t) {\n\t\tzend_error(E_ERROR, \"DateTimeInterface can't be implemented by user classes\");\n\t}\n\n\treturn SUCCESS;",
        "output": "0",
        "idx": 2467
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Item *Item_bool::neg_transformer(THD *thd)\n{\n  value= !value;\n  name= 0;\n  return this;\n}",
        "output": "0",
        "idx": 3397
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_swevent_init_hrtimer(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tif (!is_sampling_event(event))\n\t\treturn;\n\n\thrtimer_init(&hwc->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\thwc->hrtimer.function = perf_swevent_hrtimer;\n\n\t/*\n\t * Since hrtimers have a fixed rate, we can do a static freq->period\n\t * mapping and avoid the whole period adjust feedback stuff.\n\t */\n\tif (event->attr.freq) {\n\t\tlong freq = event->attr.sample_freq;\n\n\t\tevent->attr.sample_period = NSEC_PER_SEC / freq;\n\t\thwc->sample_period = event->attr.sample_period;\n\t\tlocal64_set(&hwc->period_left, hwc->sample_period);\n\t\thwc->last_period = hwc->sample_period;\n\t\tevent->attr.freq = 0;\n\t}\n}",
        "output": "0",
        "idx": 1673
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RsaCheckPrime(\n\t      bigNum           prime,\n\t      UINT32           exponent,\n\t      RAND_STATE      *rand\n\t      )\n{\n#if !RSA_KEY_SIEVE\n    TPM_RC          retVal = TPM_RC_SUCCESS;\n    UINT32          modE = BnModWord(prime, exponent);\n    NOT_REFERENCED(rand);\n    if(modE == 0)\n\t// evenly divisible so add two keeping the number odd\n\tBnAddWord(prime, prime, 2);\n    // want 0 != (p - 1) mod e\n    // which is 1 != p mod e\n    else if(modE == 1)\n\t// subtract 2 keeping number odd and insuring that\n\t// 0 != (p - 1) mod e\n\tBnSubWord(prime, prime, 2);\n    if(BnIsProbablyPrime(prime, rand) == 0)\n\tERROR_RETURN(g_inFailureMode ? TPM_RC_FAILURE : TPM_RC_VALUE);\n Exit:\n    return retVal;\n#else\n    return PrimeSelectWithSieve(prime, exponent, rand);\n#endif\n}",
        "output": "0",
        "idx": 888
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int usb_disable_remote_wakeup(struct usb_device *udev)\n{\n\tif (udev->speed < USB_SPEED_SUPER)\n\t\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,\n\t\t\t\tUSB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\telse\n\t\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,\n\t\t\t\tUSB_INTRF_FUNC_SUSPEND,\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n}",
        "output": "0",
        "idx": 2090
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tipc_nl_retrieve_key(struct nlattr **attrs,\n\t\t\t\tstruct tipc_aead_key **key)\n{\n\tstruct nlattr *attr = attrs[TIPC_NLA_NODE_KEY];\n\n\tif (!attr)\n\t\treturn -ENODATA;\n\n\t*key = (struct tipc_aead_key *)nla_data(attr);\n\tif (nla_len(attr) < tipc_aead_key_size(*key))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1315
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ZEND_FASTCALL  ZEND_PRINT_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)\n{\n\tzend_op *opline = EX(opline);\n\n\tZ_LVAL(EX_T(opline->result.u.var).tmp_var) = 1;\n\tZ_TYPE(EX_T(opline->result.u.var).tmp_var) = IS_LONG;\n\n\treturn ZEND_ECHO_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);\n}",
        "output": "0",
        "idx": 2567
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_start_metadata (RsvgHandle * ctx)\n{\n    RsvgSaxHandlerMetadata *handler = rsvg_start_extra (ctx, \"metadata\", &ctx->priv->metadata);\n\n    handler->super.start_element = rsvg_metadata_handler_start;\n    handler->super.end_element = rsvg_metadata_handler_end;\n}",
        "output": "0",
        "idx": 1261
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int usbredir_get_bufpq(QEMUFile *f, void *priv, size_t unused,\n                              const VMStateField *field)\n{\n    struct endp_data *endp = priv;\n    USBRedirDevice *dev = endp->dev;\n    struct buf_packet *bufp;\n    int i;\n\n    endp->bufpq_size = qemu_get_be32(f);\n    for (i = 0; i < endp->bufpq_size; i++) {\n        bufp = g_new(struct buf_packet, 1);\n        bufp->len = qemu_get_be32(f);\n        bufp->status = qemu_get_be32(f);\n        bufp->offset = 0;\n        bufp->data = qemu_oom_check(malloc(bufp->len)); /* regular malloc! */\n        bufp->free_on_destroy = bufp->data;\n        qemu_get_buffer(f, bufp->data, bufp->len);\n        QTAILQ_INSERT_TAIL(&endp->bufpq, bufp, next);\n        DPRINTF(\"get_bufpq %d/%d len %d status %d\\n\", i + 1, endp->bufpq_size,\n                bufp->len, bufp->status);\n    }\n    return 0;\n}",
        "output": "0",
        "idx": 570
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\\"\");\n\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n\tcmdline.append(\"\\\"\");\n\tstfl::reset();\n\tutils::run_interactively(cmdline, \"pb_controller::play_file\");\n}",
        "output": "1",
        "idx": 216
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cirrus_linear_bitblt_writew(void *opaque, target_phys_addr_t addr,\n\t\t\t\t uint32_t val)\n{\n#ifdef TARGET_WORDS_BIGENDIAN\n    cirrus_linear_bitblt_writeb(opaque, addr, (val >> 8) & 0xff);\n    cirrus_linear_bitblt_writeb(opaque, addr + 1, val & 0xff);\n#else\n    cirrus_linear_bitblt_writeb(opaque, addr, val & 0xff);\n    cirrus_linear_bitblt_writeb(opaque, addr + 1, (val >> 8) & 0xff);\n#endif\n}",
        "output": "0",
        "idx": 1415
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CLASS foveon_dp_load_raw()\n{\n  unsigned c, roff[4], row, col, diff;\n  ushort huff[258], vpred[2][2], hpred[2];\n\n  fseek (ifp, 8, SEEK_CUR);\n  foveon_huff (huff);\n  roff[0] = 48;\n  FORC3 roff[c+1] = -(-(roff[c] + get4()) & -16);\n  FORC3 {\n    fseek (ifp, data_offset+roff[c], SEEK_SET);\n    getbits(-1);\n    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;\n    for (row=0; row < height; row++) {\n      for (col=0; col < width; col++) {\n       diff = ljpeg_diff(huff);\n       if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n       else hpred[col & 1] += diff;\n       image[row*width+col][c] = hpred[col & 1];\n      }\n    }\n  }\n}",
        "output": "0",
        "idx": 1593
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint8_t LoRaMacMcChannelGetGroupId( uint32_t mcAddress )\r\n{\r\n    for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )\r\n    {\r\n        if( mcAddress == MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address )\r\n        {\r\n            return i;\r\n        }\r\n    }\r\n    return 0xFF;\r\n}\r",
        "output": "0",
        "idx": 891
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F(HttpConnectionManagerImplTest, MaxStreamDurationCallbackResetStream) {\n  max_stream_duration_ = std::chrono::milliseconds(10);\n  setup(false, \"\");\n  Event::MockTimer* duration_timer = setUpTimer();\n\n  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> Http::Status {\n    EXPECT_CALL(*duration_timer, enableTimer(max_stream_duration_.value(), _)).Times(1);\n    conn_manager_->newStream(response_encoder_);\n    return Http::okStatus();\n  }));\n\n  Buffer::OwnedImpl fake_input(\"1234\");\n  conn_manager_->onData(fake_input, false); // kick off request\n\n  EXPECT_CALL(*duration_timer, disableTimer());\n  duration_timer->invokeCallback();\n\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_max_duration_reached_.value());\n  EXPECT_EQ(1U, stats_.named_.downstream_rq_rx_reset_.value());\n}",
        "output": "0",
        "idx": 2917
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"ServerSecurity\"),\n      _enableFoxxApi(true),\n      _enableFoxxStore(true),\n      _hardenedRestApi(false) {\n  setOptional(false);\n  startsAfter<application_features::GreetingsFeaturePhase>();\n}",
        "output": "1",
        "idx": 76
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cancel_subscription(\n    cupsd_client_t *con,\t\t/* I - Client connection */\n    int            sub_id)\t\t/* I - Subscription ID */\n{\n  http_status_t\t\tstatus;\t\t/* Policy status */\n  cupsd_subscription_t\t*sub;\t\t/* Subscription */\n\n\n  cupsdLogMessage(CUPSD_LOG_DEBUG2,\n                  \"cancel_subscription(con=%p[%d], sub_id=%d)\",\n                  con, con->number, sub_id);\n\n /*\n  * Is the subscription ID valid?\n  */\n\n  if ((sub = cupsdFindSubscription(sub_id)) == NULL)\n  {\n   /*\n    * Bad subscription ID...\n    */\n\n    send_ipp_status(con, IPP_NOT_FOUND,\n                    _(\"Subscription #%d does not exist.\"), sub_id);\n    return;\n  }\n\n /*\n  * Check policy...\n  */\n\n  if ((status = cupsdCheckPolicy(sub->dest ? sub->dest->op_policy_ptr :\n                                             DefaultPolicyPtr,\n                                 con, sub->owner)) != HTTP_OK)\n  {\n    send_http_error(con, status, sub->dest);\n    return;\n  }\n\n /*\n  * Cancel the subscription...\n  */\n\n  cupsdDeleteSubscription(sub, 1);\n\n  con->response->request.status.status_code = IPP_OK;\n}",
        "output": "0",
        "idx": 2275
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  my_decimal *val_decimal(my_decimal *val) { return &decimal_value; }",
        "output": "0",
        "idx": 541
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void network_init_gcrypt (void) /* {{{ */\n{\n  /* http://lists.gnupg.org/pipermail/gcrypt-devel/2003-August/000458.html\n   * Because you can't know in a library whether another library has\n   * already initialized the library */\n  if (gcry_control (GCRYCTL_ANY_INITIALIZATION_P))\n    return;\n\n /* http://www.gnupg.org/documentation/manuals/gcrypt/Multi_002dThreading.html\n  * To ensure thread-safety, it's important to set GCRYCTL_SET_THREAD_CBS\n  * *before* initalizing Libgcrypt with gcry_check_version(), which itself must\n  * be called before any other gcry_* function. GCRYCTL_ANY_INITIALIZATION_P\n  * above doesn't count, as it doesn't implicitly initalize Libgcrypt.\n  *\n  * tl;dr: keep all these gry_* statements in this exact order please. */\n# if GCRYPT_VERSION_NUMBER < 0x010600\n  gcry_control (GCRYCTL_SET_THREAD_CBS, &gcry_threads_pthread);\n# endif\n  gcry_check_version (NULL);\n  gcry_control (GCRYCTL_INIT_SECMEM, 32768);\n  gcry_control (GCRYCTL_INITIALIZATION_FINISHED);\n} /* }}} void network_init_gcrypt */",
        "output": "1",
        "idx": 1180
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ngx_mail_core_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n{\n    ngx_mail_core_srv_conf_t *prev = parent;\n    ngx_mail_core_srv_conf_t *conf = child;\n\n    ngx_conf_merge_msec_value(conf->timeout, prev->timeout, 60000);\n    ngx_conf_merge_msec_value(conf->resolver_timeout, prev->resolver_timeout,\n                              30000);\n\n\n    ngx_conf_merge_str_value(conf->server_name, prev->server_name, \"\");\n\n    if (conf->server_name.len == 0) {\n        conf->server_name = cf->cycle->hostname;\n    }\n\n    if (conf->protocol == NULL) {\n        ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                      \"unknown mail protocol for server in %s:%ui\",\n                      conf->file_name, conf->line);\n        return NGX_CONF_ERROR;\n    }\n\n    if (conf->error_log == NULL) {\n        if (prev->error_log) {\n            conf->error_log = prev->error_log;\n        } else {\n            conf->error_log = &cf->cycle->new_log;\n        }\n    }\n\n    ngx_conf_merge_ptr_value(conf->resolver, prev->resolver, NULL);\n\n    return NGX_CONF_OK;\n}",
        "output": "1",
        "idx": 117
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_log_throttle(struct perf_event *event, int enable)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint ret;\n\n\tstruct {\n\t\tstruct perf_event_header\theader;\n\t\tu64\t\t\t\ttime;\n\t\tu64\t\t\t\tid;\n\t\tu64\t\t\t\tstream_id;\n\t} throttle_event = {\n\t\t.header = {\n\t\t\t.type = PERF_RECORD_THROTTLE,\n\t\t\t.misc = 0,\n\t\t\t.size = sizeof(throttle_event),\n\t\t},\n\t\t.time\t\t= perf_clock(),\n\t\t.id\t\t= primary_event_id(event),\n\t\t.stream_id\t= event->id,\n\t};\n\n\tif (enable)\n\t\tthrottle_event.header.type = PERF_RECORD_UNTHROTTLE;\n\n\tperf_event_header__init_id(&throttle_event.header, &sample, event);\n\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tthrottle_event.header.size);\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, throttle_event);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\tperf_output_end(&handle);\n}",
        "output": "0",
        "idx": 3499
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Status Conv2DBackpropComputeInputShape(const Tensor& input_sizes,\n                                       const TensorShape& filter_shape,\n                                       const TensorShape& out_backprop_shape,\n                                       const TensorFormat& data_format,\n                                       TensorShape* input_shape) {\n  if (!TensorShapeUtils::IsVector(input_sizes.shape())) {\n    return errors::InvalidArgument(\n        \"Conv2DBackpropInput: input_sizes input must be 1-dim, not \",\n        input_sizes.dims());\n  }\n\n  if (input_sizes.dim_size(0) == 4) {\n    return TensorShapeUtils::MakeShape(input_sizes.vec<int32>(), input_shape);\n  }\n\n  if (input_sizes.dim_size(0) == 2) {\n    const int batch_size = GetTensorDim(out_backprop_shape, data_format, 'N');\n    const int output_height = input_sizes.vec<int32>()(0);\n    const int output_width = input_sizes.vec<int32>()(1);\n    const int output_depth = filter_shape.dim_size(2);\n    *input_shape = ShapeFromFormat(data_format, batch_size, output_height,\n                                   output_width, output_depth);\n    return Status::OK();\n  }\n\n  return errors::InvalidArgument(\n      \"Conv2DBackpropInput requires input_sizes to \"\n      \"contain 4 values or 2 values, but got: \",\n      input_sizes.dim_size(0));\n}",
        "output": "0",
        "idx": 1715
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int coroutine_fn v9fs_mark_fids_unreclaim(V9fsPDU *pdu, V9fsPath *path)\n{\n    int err;\n    V9fsState *s = pdu->s;\n    V9fsFidState *fidp, head_fid;\n\n    head_fid.next = s->fid_list;\n    for (fidp = s->fid_list; fidp; fidp = fidp->next) {\n        if (fidp->path.size != path->size) {\n            continue;\n        }\n        if (!memcmp(fidp->path.data, path->data, path->size)) {\n            /* Mark the fid non reclaimable. */\n            fidp->flags |= FID_NON_RECLAIMABLE;\n\n            /* reopen the file/dir if already closed */\n            err = v9fs_reopen_fid(pdu, fidp);\n            if (err < 0) {\n                return err;\n            }\n            /*\n             * Go back to head of fid list because\n             * the list could have got updated when\n             * switched to the worker thread\n             */\n            if (err == 0) {\n                fidp = &head_fid;\n            }\n        }\n    }\n    return 0;\n}",
        "output": "1",
        "idx": 2068
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Panic(const char *fmtstr, ...)\n{\n   /* Ignored */\n   sLog(log_warning, \"Panic callback invoked. \\n\");\n   exit(1);\n}",
        "output": "1",
        "idx": 2578
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_new_image (void)\n{\n    RsvgNodeImage *image;\n    image = g_new (RsvgNodeImage, 1);\n    _rsvg_node_init (&image->super);\n    g_assert (image->super.state);\n    image->img = NULL;\n    image->preserve_aspect_ratio = RSVG_ASPECT_RATIO_XMID_YMID;\n    image->x = image->y = image->w = image->h = _rsvg_css_parse_length (\"0\");\n    image->super.free = rsvg_node_image_free;\n    image->super.draw = rsvg_node_image_draw;\n    image->super.set_atts = rsvg_node_image_set_atts;\n    return &image->super;\n}",
        "output": "1",
        "idx": 509
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static SQInteger _closure_acall(HSQUIRRELVM v,SQBool raiseerror)\n{\n    SQArray *aparams=_array(stack_get(v,2));\n    SQInteger nparams=aparams->Size();\n    v->Push(stack_get(v,1));\n    for(SQInteger i=0;i<nparams;i++)v->Push(aparams->_values[i]);\n    return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue,raiseerror))?1:SQ_ERROR;\n}",
        "output": "0",
        "idx": 1218
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int update_approximate_memblt_order(ORDER_INFO* orderInfo, const MEMBLT_ORDER* memblt)\n{\n\treturn 64;\n}",
        "output": "0",
        "idx": 737
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int32 MkvWriter::Position(int64 position) {\n  if (!file_)\n    return -1;\n\n#ifdef _MSC_VER\n  return _fseeki64(file_, position, SEEK_SET);\n#else\n  return fseeko(file_, static_cast<off_t>(position), SEEK_SET);\n#endif\n}",
        "output": "1",
        "idx": 661
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void elevator_exit(struct request_queue *q, struct elevator_queue *e)\n{\n\tmutex_lock(&e->sysfs_lock);\n\tif (e->type->ops.exit_sched)\n\t\tblk_mq_exit_sched(q, e);\n\tmutex_unlock(&e->sysfs_lock);\n\n\tkobject_put(&e->kobj);\n}",
        "output": "1",
        "idx": 3023
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  const char *type_name()\n  {\n    return type == COLUMN ? \"COLUMN\" :\n           type == CHECK_CONSTRAINT ? \"CONSTRAINT\" :\n           type == KEY ? \"INDEX\" : \"FOREIGN KEY\";\n  }",
        "output": "0",
        "idx": 608
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tshort sel;\n\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn -1L;\n\n\tif (v8086_mode(regs))\n\t\t/*\n\t\t * Base is simply the segment selector shifted 4\n\t\t * bits to the right.\n\t\t */\n\t\treturn (unsigned long)(sel << 4);\n\n\tif (user_64bit_mode(regs)) {\n\t\t/*\n\t\t * Only FS or GS will have a base address, the rest of\n\t\t * the segments' bases are forced to 0.\n\t\t */\n\t\tunsigned long base;\n\n\t\tif (seg_reg_idx == INAT_SEG_REG_FS)\n\t\t\trdmsrl(MSR_FS_BASE, base);\n\t\telse if (seg_reg_idx == INAT_SEG_REG_GS)\n\t\t\t/*\n\t\t\t * swapgs was called at the kernel entry point. Thus,\n\t\t\t * MSR_KERNEL_GS_BASE will have the user-space GS base.\n\t\t\t */\n\t\t\trdmsrl(MSR_KERNEL_GS_BASE, base);\n\t\telse\n\t\t\tbase = 0;\n\t\treturn base;\n\t}\n\n\t/* In protected mode the segment selector cannot be null. */\n\tif (!sel)\n\t\treturn -1L;\n\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn -1L;\n\n\treturn get_desc_base(desc);\n}",
        "output": "1",
        "idx": 2876
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ConvertTimeZoneAbbrevs(TimeZoneAbbrevTable *tbl,\n\t\t\t\t\t   struct tzEntry *abbrevs, int n)\n{\n\tdatetkn    *newtbl = tbl->abbrevs;\n\tint\t\t\ti;\n\n\ttbl->numabbrevs = n;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tstrncpy(newtbl[i].token, abbrevs[i].abbrev, TOKMAXLEN);\n\t\tnewtbl[i].type = abbrevs[i].is_dst ? DTZ : TZ;\n\t\tTOVAL(&newtbl[i], abbrevs[i].offset / MINS_PER_HOUR);\n\t}\n\n\t/* Check the ordering, if testing */\n\tAssert(CheckDateTokenTable(\"timezone offset\", newtbl, n));\n}",
        "output": "1",
        "idx": 3664
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_public_ int sd_bus_default(sd_bus **ret) {\n        int (*bus_open)(sd_bus **) = NULL;\n        sd_bus **busp;\n\n        busp = bus_choose_default(&bus_open);\n        return bus_default(bus_open, busp, ret);\n}",
        "output": "0",
        "idx": 153
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void veth_get_ethtool_stats(struct net_device *dev,\n\t\tstruct ethtool_stats *stats, u64 *data)\n{\n\tstruct veth_priv *priv;\n\n\tpriv = netdev_priv(dev);\n\tdata[0] = priv->peer->ifindex;\n}",
        "output": "0",
        "idx": 1646
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}",
        "output": "1",
        "idx": 3707
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void free_vpid(struct vcpu_vmx *vmx)\n{\n\tif (!enable_vpid)\n\t\treturn;\n\tspin_lock(&vmx_vpid_lock);\n\tif (vmx->vpid != 0)\n\t\t__clear_bit(vmx->vpid, vmx_vpid_bitmap);\n\tspin_unlock(&vmx_vpid_lock);\n}",
        "output": "0",
        "idx": 2083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QPDF::removePage(QPDFObjectHandle page)\n{\n    int pos = findPage(page); // also ensures flat /Pages\n    QTC::TC(\"qpdf\", \"QPDF remove page\",\n            (pos == 0) ? 0 :                            // remove at beginning\n            (pos == static_cast<int>(\n                this->m->all_pages.size() - 1)) ? 1 :   // end\n            2);                                         // remove in middle\n\n    QPDFObjectHandle pages = getRoot().getKey(\"/Pages\");\n    QPDFObjectHandle kids = pages.getKey(\"/Kids\");\n\n    kids.eraseItem(pos);\n    int npages = kids.getArrayNItems();\n    pages.replaceKey(\"/Count\", QPDFObjectHandle::newInteger(npages));\n    this->m->all_pages.erase(this->m->all_pages.begin() + pos);\n    assert(this->m->all_pages.size() == static_cast<size_t>(npages));\n    this->m->pageobj_to_pages_pos.erase(page.getObjGen());\n    assert(this->m->pageobj_to_pages_pos.size() == static_cast<size_t>(npages));\n    for (int i = pos; i < npages; ++i)\n    {\n        insertPageobjToPage(this->m->all_pages.at(i), i, false);\n    }\n}",
        "output": "1",
        "idx": 850
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    inline double atanh(const double x) {\n#if cimg_use_cpp11==1 && !defined(_MSC_VER)\n      return std::atanh(x);\n#else\n      return 0.5*std::log((1. + x)/(1. - x));\n#endif\n    }",
        "output": "0",
        "idx": 2514
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool pipe_writable(const struct pipe_inode_info *pipe)\n{\n\tunsigned int head = READ_ONCE(pipe->head);\n\tunsigned int tail = READ_ONCE(pipe->tail);\n\tunsigned int max_usage = READ_ONCE(pipe->max_usage);\n\n\treturn !pipe_full(head, tail, max_usage) ||\n\t\t!READ_ONCE(pipe->readers);\n}",
        "output": "0",
        "idx": 1701
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ssl3_send_alert(SSL *s, int level, int desc)\n{\n    /* Map tls/ssl alert value to correct one */\n    desc = s->method->ssl3_enc->alert_value(desc);\n    if (s->version == SSL3_VERSION && desc == SSL_AD_PROTOCOL_VERSION)\n        desc = SSL_AD_HANDSHAKE_FAILURE; /* SSL 3.0 does not have\n                                          * protocol_version alerts */\n    if (desc < 0)\n        return -1;\n    /* If a fatal one, remove from cache */\n    if ((level == 2) && (s->session != NULL))\n        SSL_CTX_remove_session(s->session_ctx, s->session);\n\n    s->s3->alert_dispatch = 1;\n    s->s3->send_alert[0] = level;\n    s->s3->send_alert[1] = desc;\n    if (s->s3->wbuf.left == 0)  /* data still being written out? */\n        return s->method->ssl_dispatch_alert(s);\n    /*\n     * else data is still being written out, we will get written some time in\n     * the future\n     */\n    return -1;\n}",
        "output": "1",
        "idx": 1320
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ttm_tt_create(struct ttm_buffer_object *bo, bool zero_alloc)\n{\n\tstruct ttm_bo_device *bdev = bo->bdev;\n\tuint32_t page_flags = 0;\n\n\tdma_resv_assert_held(bo->base.resv);\n\n\tif (bo->ttm)\n\t\treturn 0;\n\n\tif (bdev->need_dma32)\n\t\tpage_flags |= TTM_PAGE_FLAG_DMA32;\n\n\tif (bdev->no_retry)\n\t\tpage_flags |= TTM_PAGE_FLAG_NO_RETRY;\n\n\tswitch (bo->type) {\n\tcase ttm_bo_type_device:\n\t\tif (zero_alloc)\n\t\t\tpage_flags |= TTM_PAGE_FLAG_ZERO_ALLOC;\n\t\tbreak;\n\tcase ttm_bo_type_kernel:\n\t\tbreak;\n\tcase ttm_bo_type_sg:\n\t\tpage_flags |= TTM_PAGE_FLAG_SG;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Illegal buffer object type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbo->ttm = bdev->driver->ttm_tt_create(bo, page_flags);\n\tif (unlikely(bo->ttm == NULL))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 999
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowstride)\n{\n\tnsc_encode_argb_to_aycocg(context, bmpdata, rowstride);\n\n\tif (context->ChromaSubsamplingLevel)\n\t{\n\t\tnsc_encode_subsampling(context);\n\t}\n}",
        "output": "1",
        "idx": 90
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void debug_print_message_header(UdscsConnection             *conn,\n                                       struct udscs_message_header *header,\n                                       const gchar                 *direction)\n{\n    const gchar *type = \"invalid message\";\n\n    if (conn == NULL || conn->debug == FALSE)\n        return;\n\n    if (header->type < G_N_ELEMENTS(vdagentd_messages))\n        type = vdagentd_messages[header->type];\n\n    syslog(LOG_DEBUG, \"%p %s %s, arg1: %u, arg2: %u, size %u\",\n        conn, direction, type, header->arg1, header->arg2, header->size);\n}",
        "output": "0",
        "idx": 1998
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __rta_fill(struct sk_buff *skb, int attrtype, int attrlen, const void *data)\n{\n\tstruct rtattr *rta;\n\tint size = RTA_LENGTH(attrlen);\n\n\trta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));\n\trta->rta_type = attrtype;\n\trta->rta_len = size;\n\tmemcpy(RTA_DATA(rta), data, attrlen);\n}",
        "output": "1",
        "idx": 2510
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_config_dir_location (void)\n{\n  static gsize path = 0;\n\n  if (g_once_init_enter (&path))\n    {\n      gsize setup_value = 0;\n      const char *config_dir = g_getenv (\"FLATPAK_CONFIG_DIR\");\n      if (config_dir != NULL)\n        setup_value = (gsize) config_dir;\n      else\n        setup_value = (gsize) FLATPAK_CONFIGDIR;\n      g_once_init_leave (&path, setup_value);\n    }\n\n  return (const char *) path;\n}",
        "output": "0",
        "idx": 1212
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DEFUN (no_ipv6_nd_homeagent_lifetime,\n       no_ipv6_nd_homeagent_lifetime_cmd,\n       \"no ipv6 nd home-agent-lifetime\",\n       NO_STR\n       \"Interface IPv6 config commands\\n\"\n       \"Neighbor discovery\\n\"\n       \"Home Agent lifetime\\n\")\n{\n  struct interface *ifp;\n  struct zebra_if *zif;\n\n  ifp = (struct interface *) vty->index;\n  zif = ifp->info;\n\n  zif->rtadv.HomeAgentLifetime = -1;\n\n  return CMD_SUCCESS;\n}",
        "output": "0",
        "idx": 3616
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ahash_def_finup_finish1(struct ahash_request *req, int err)\n{\n\tif (err)\n\t\tgoto out;\n\n\treq->base.complete = ahash_def_finup_done2;\n\treq->base.flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;\n\terr = crypto_ahash_reqtfm(req)->final(req);\n\nout:\n\tahash_def_finup_finish2(req, err);\n\treturn err;\n}",
        "output": "1",
        "idx": 2406
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gnutls_pcert_deinit (gnutls_pcert_st *pcert)\n{\n  gnutls_pubkey_deinit(pcert->pubkey);\n  pcert->pubkey = NULL;\n  gnutls_free(pcert->cert.data);\n  pcert->cert.data = NULL;\n}",
        "output": "1",
        "idx": 3376
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplDoublyLinkedList, current)\n{\n\tspl_dllist_object     *intern  = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tspl_ptr_llist_element *element = intern->traverse_pointer;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (element == NULL || element->data == NULL) {\n\t\tRETURN_NULL();\n\t} else {\n\t\tzval *data    = (zval *)element->data;\n\t\tRETURN_ZVAL(data, 1, 0);\n\t}\n}",
        "output": "0",
        "idx": 1775
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)\n{\n    struct lo_inode *p;\n    struct lo_key key = {\n        .ino = st->st_ino,\n        .dev = st->st_dev,\n    };\n\n    pthread_mutex_lock(&lo->mutex);\n    p = g_hash_table_lookup(lo->inodes, &key);\n    if (p) {\n        assert(p->nlookup > 0);\n        p->nlookup++;\n        g_atomic_int_inc(&p->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    return p;\n}",
        "output": "0",
        "idx": 3011
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)\n{\n    int i, length;\n\n    segment->nb_index_entries = avio_rb32(pb);\n\n    length = avio_rb32(pb);\n\n    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||\n        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||\n        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries))))\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < segment->nb_index_entries; i++) {\n        segment->temporal_offset_entries[i] = avio_r8(pb);\n        avio_r8(pb);                                        /* KeyFrameOffset */\n        segment->flag_entries[i] = avio_r8(pb);\n        segment->stream_offset_entries[i] = avio_rb64(pb);\n        avio_skip(pb, length - 11);\n    }\n    return 0;\n}",
        "output": "1",
        "idx": 574
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int af_alg_release(struct socket *sock)\n{\n\tif (sock->sk)\n\t\tsock_put(sock->sk);\n\treturn 0;\n}",
        "output": "1",
        "idx": 11
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,\n\t\tstruct kvm_segment *save)\n{\n\tif (!emulate_invalid_guest_state) {\n\t\t/*\n\t\t * CS and SS RPL should be equal during guest entry according\n\t\t * to VMX spec, but in reality it is not always so. Since vcpu\n\t\t * is in the middle of the transition from real mode to\n\t\t * protected mode it is safe to assume that RPL 0 is a good\n\t\t * default value.\n\t\t */\n\t\tif (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)\n\t\t\tsave->selector &= ~SELECTOR_RPL_MASK;\n\t\tsave->dpl = save->selector & SELECTOR_RPL_MASK;\n\t\tsave->s = 1;\n\t}\n\tvmx_set_segment(vcpu, save, seg);\n}",
        "output": "0",
        "idx": 2305
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool ValidateSKIPJACK()\r\n{\r\n\tstd::cout << \"\\nSKIPJACK validation suite running...\\n\\n\";\r\n\tbool pass1 = true, pass2 = true;\r\n\r\n\tSKIPJACKEncryption enc;  // 80-bits only\r\n\tpass1 = enc.StaticGetValidKeyLength(8) == 10 && pass1;\r\n\tpass1 = enc.StaticGetValidKeyLength(9) == 10 && pass1;\r\n\tpass1 = enc.StaticGetValidKeyLength(10) == 10 && pass1;\r\n\tpass1 = enc.StaticGetValidKeyLength(16) == 10 && pass1;\r\n\r\n\tSKIPJACKDecryption dec;  // 80-bits only\r\n\tpass2 = dec.StaticGetValidKeyLength(8) == 10 && pass2;\r\n\tpass2 = dec.StaticGetValidKeyLength(9) == 10 && pass2;\r\n\tpass2 = dec.StaticGetValidKeyLength(10) == 10 && pass2;\r\n\tpass2 = dec.StaticGetValidKeyLength(16) == 10 && pass2;\r\n\tstd::cout << (pass1 && pass2 ? \"passed:\" : \"FAILED:\") << \"  Algorithm key lengths\\n\";\r\n\r\n\tFileSource valdata(CRYPTOPP_DATA_DIR \"TestData/skipjack.dat\", true, new HexDecoder);\r\n\treturn BlockTransformationTest(FixedRoundsCipherFactory<SKIPJACKEncryption, SKIPJACKDecryption>(), valdata) && pass1 && pass2;\r\n}\r",
        "output": "0",
        "idx": 3018
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, uint32_t value)\n{\n\tFLAC__ASSERT(0 != encoder);\n\tFLAC__ASSERT(0 != encoder->private_);\n\tFLAC__ASSERT(0 != encoder->protected_);\n\tif(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)\n\t\treturn false;\n\tencoder->protected_->bits_per_sample = value;\n\treturn true;\n}",
        "output": "0",
        "idx": 804
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const VTermLineInfo *vterm_state_get_lineinfo(const VTermState *state, int row)\n{\n  return state->lineinfo + row;\n}",
        "output": "0",
        "idx": 3523
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Status TF_TensorToMaybeAliasedPyArray(Safe_TF_TensorPtr tensor,\n                                      PyObject** out_ndarray) {\n  auto dtype = TF_TensorType(tensor.get());\n  if (dtype == TF_STRING || dtype == TF_RESOURCE) {\n    return TF_TensorToPyArray(std::move(tensor), out_ndarray);\n  }\n\n  TF_Tensor* moved = tensor.release();\n  int64 nelems = -1;\n  gtl::InlinedVector<npy_intp, 4> dims;\n  TF_RETURN_IF_ERROR(GetPyArrayDimensionsForTensor(moved, &dims, &nelems));\n  return ArrayFromMemory(\n      dims.size(), dims.data(), TF_TensorData(moved),\n      static_cast<DataType>(dtype), [moved] { TF_DeleteTensor(moved); },\n      out_ndarray);\n}",
        "output": "0",
        "idx": 1149
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void array_cleanup( char* arr[] , int arr_size)\n{\n\tint i=0;\n\tfor( i=0; i< arr_size; i++ ){ \n\t\tif( arr[i*2] ){\n\t\t\tefree( arr[i*2]);\n\t\t}\n\t}\n\tefree(arr);\n}",
        "output": "1",
        "idx": 2262
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static CURLcode setup_connection_internals(struct connectdata *conn)\n{\n  const struct Curl_handler * p;\n  CURLcode result;\n  conn->socktype = SOCK_STREAM; /* most of them are TCP streams */\n\n  /* Perform setup complement if some. */\n  p = conn->handler;\n\n  if(p->setup_connection) {\n    result = (*p->setup_connection)(conn);\n\n    if(result)\n      return result;\n\n    p = conn->handler;              /* May have changed. */\n  }\n\n  if(conn->port < 0)\n    /* we check for -1 here since if proxy was detected already, this\n       was very likely already set to the proxy port */\n    conn->port = p->defport;\n\n  return CURLE_OK;\n}",
        "output": "0",
        "idx": 453
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static irqreturn_t gfar_transmit(int irq, void *grp_id)\n{\n\tstruct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;\n\tunsigned long flags;\n\tu32 imask;\n\n\tif (likely(napi_schedule_prep(&grp->napi_tx))) {\n\t\tspin_lock_irqsave(&grp->grplock, flags);\n\t\timask = gfar_read(&grp->regs->imask);\n\t\timask &= IMASK_TX_DISABLED;\n\t\tgfar_write(&grp->regs->imask, imask);\n\t\tspin_unlock_irqrestore(&grp->grplock, flags);\n\t\t__napi_schedule(&grp->napi_tx);\n\t} else {\n\t\t/* Clear IEVENT, so interrupts aren't called again\n\t\t * because of the packets that have already arrived.\n\t\t */\n\t\tgfar_write(&grp->regs->ievent, IEVENT_TX_MASK);\n\t}\n\n\treturn IRQ_HANDLED;\n}",
        "output": "0",
        "idx": 1476
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t show_crash_notes(struct device *dev, struct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct cpu *cpu = container_of(dev, struct cpu, dev);\n\tssize_t rc;\n\tunsigned long long addr;\n\tint cpunum;\n\n\tcpunum = cpu->dev.id;\n\n\t/*\n\t * Might be reading other cpu's data based on which cpu read thread\n\t * has been scheduled. But cpu data (memory) is allocated once during\n\t * boot up and this data does not change there after. Hence this\n\t * operation should be safe. No locking required.\n\t */\n\taddr = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, cpunum));\n\trc = sprintf(buf, \"%Lx\\n\", addr);\n\treturn rc;\n}",
        "output": "1",
        "idx": 691
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vgacon_scrollback_startup(void)\n{\n\tvgacon_scrollback_cur = &vgacon_scrollbacks[0];\n\tvgacon_scrollback_init(0);\n}",
        "output": "1",
        "idx": 3102
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEE_Result syscall_cryp_obj_close(unsigned long obj)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\n\t/*\n\t * If it's busy it's used by an operation, a client should never have\n\t * this handle.\n\t */\n\tif (o->busy)\n\t\treturn TEE_ERROR_ITEM_NOT_FOUND;\n\n\ttee_obj_close(to_user_ta_ctx(sess->ctx), o);\n\treturn TEE_SUCCESS;\n}",
        "output": "0",
        "idx": 1235
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int fts3DoAutoincrmerge(\n  Fts3Table *p,                   /* FTS3 table handle */\n  const char *zParam              /* Nul-terminated string containing boolean */\n){\n  int rc = SQLITE_OK;\n  sqlite3_stmt *pStmt = 0;\n  p->nAutoincrmerge = fts3Getint(&zParam);\n  if( p->nAutoincrmerge==1 || p->nAutoincrmerge>FTS3_MERGE_COUNT ){\n    p->nAutoincrmerge = 8;\n  }\n  if( !p->bHasStat ){\n    assert( p->bFts4==0 );\n    sqlite3Fts3CreateStatTable(&rc, p);\n    if( rc ) return rc;\n  }\n  rc = fts3SqlStmt(p, SQL_REPLACE_STAT, &pStmt, 0);\n  if( rc ) return rc;\n  sqlite3_bind_int(pStmt, 1, FTS_STAT_AUTOINCRMERGE);\n  sqlite3_bind_int(pStmt, 2, p->nAutoincrmerge);\n  sqlite3_step(pStmt);\n  rc = sqlite3_reset(pStmt);\n  return rc;\n}",
        "output": "1",
        "idx": 596
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static handler_t wstunnel_stdin_append(gw_handler_ctx *gwhctx) {\n    /* prepare websocket frames to backend */\n    /* (caller should verify r->reqbody_queue) */\n    /*assert(!chunkqueue_is_empty(&r->reqbody_queue));*/\n    handler_ctx *hctx = (handler_ctx *)gwhctx;\n    if (0 == mod_wstunnel_frame_recv(hctx))\n        return HANDLER_GO_ON;\n    else {\n        /*(error)*/\n        /* future: might differentiate client close request from client error,\n         *         and then send 1000 or 1001 */\n        request_st * const r = hctx->gw.r;\n        DEBUG_LOG_INFO(\"disconnected from client (fd=%d)\", r->con->fd);\n        DEBUG_LOG_DEBUG(\"send close response to client (fd=%d)\", r->con->fd);\n        mod_wstunnel_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(\"1000\")); /* 1000 Normal Closure */\n        gw_handle_request_reset(r, hctx->gw.plugin_data);\n        return HANDLER_FINISHED;\n    }\n}",
        "output": "0",
        "idx": 2074
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ConnectionImpl::StreamImpl::encodeTrailersBase(const HeaderMap& trailers) {\n  ASSERT(!local_end_stream_);\n  local_end_stream_ = true;\n  if (pending_send_data_.length() > 0) {\n    // In this case we want trailers to come after we release all pending body data that is\n    // waiting on window updates. We need to save the trailers so that we can emit them later.\n    ASSERT(!pending_trailers_to_encode_);\n    pending_trailers_to_encode_ = cloneTrailers(trailers);\n  } else {\n    submitTrailers(trailers);\n    parent_.sendPendingFrames();\n  }\n}",
        "output": "1",
        "idx": 3192
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __net_exit ipv4_inetpeer_exit(struct net *net)\n{\n\tstruct inet_peer_base *bp = net->ipv4.peers;\n\n\tnet->ipv4.peers = NULL;\n\tinetpeer_invalidate_tree(bp);\n\tkfree(bp);\n}",
        "output": "0",
        "idx": 3458
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sraSpanCheck(const sraSpan *span, const char *text) {\n  /* Check the span is valid! */\n  if (span->start == span->end) {\n    printf(text); \n    printf(\":%d-%d\\n\", span->start, span->end);\n  }\n}",
        "output": "0",
        "idx": 126
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,\n\t\t\t struct hsr_port *port)\n{\n\tstruct hsr_node *node_dst;\n\n\tif (!skb_mac_header_was_set(skb)) {\n\t\tWARN_ONCE(1, \"%s: Mac header not set\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))\n\t\treturn;\n\n\tnode_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);\n\tif (!node_dst) {\n\t\tWARN_ONCE(1, \"%s: Unknown node\\n\", __func__);\n\t\treturn;\n\t}\n\tif (port->type != node_dst->AddrB_port)\n\t\treturn;\n\n\tether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);\n}",
        "output": "0",
        "idx": 890
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool svc_flash_pgm_blk(uint32_t beginAddr, uint32_t data, uint32_t align) {\n  _param_1 = beginAddr;\n  _param_2 = data;\n  _param_3 = align;\n  __asm__ __volatile__(\"svc %0\" ::\"i\"(SVC_FLASH_PGM_BLK) : \"memory\");\n  return !!_param_1;\n}",
        "output": "0",
        "idx": 1142
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void br_multicast_stop(struct net_bridge *br)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct hlist_node *n;\n\tu32 ver;\n\tint i;\n\n\tdel_timer_sync(&br->multicast_router_timer);\n\tdel_timer_sync(&br->multicast_querier_timer);\n\tdel_timer_sync(&br->multicast_query_timer);\n\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\tif (!mdb)\n\t\tgoto out;\n\n\tbr->mdb = NULL;\n\n\tver = mdb->ver;\n\tfor (i = 0; i < mdb->max; i++) {\n\t\thlist_for_each_entry_safe(mp, n, &mdb->mhash[i],\n\t\t\t\t\t  hlist[ver]) {\n\t\t\tdel_timer(&mp->timer);\n\t\t\tcall_rcu_bh(&mp->rcu, br_multicast_free_group);\n\t\t}\n\t}\n\n\tif (mdb->old) {\n\t\tspin_unlock_bh(&br->multicast_lock);\n\t\trcu_barrier_bh();\n\t\tspin_lock_bh(&br->multicast_lock);\n\t\tWARN_ON(mdb->old);\n\t}\n\n\tmdb->old = mdb;\n\tcall_rcu_bh(&mdb->rcu, br_mdb_free);\n\nout:\n\tspin_unlock_bh(&br->multicast_lock);\n}",
        "output": "1",
        "idx": 1735
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(getcwd)\n{\n\tchar path[MAXPATHLEN];\n\tchar *ret=NULL;\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n#if HAVE_GETCWD\n\tret = VCWD_GETCWD(path, MAXPATHLEN);\n#elif HAVE_GETWD\n\tret = VCWD_GETWD(path);\n#endif\n\n\tif (ret) {\n\t\tRETURN_STRING(path, 1);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}",
        "output": "1",
        "idx": 1243
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    static CImg<T> get_load_bmp(std::FILE *const file) {\n      return CImg<T>().load_bmp(file);\n    }",
        "output": "0",
        "idx": 1263
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static errno_t sssctl_manage_service(enum sssctl_svc_action action)\n{\n#ifdef HAVE_SYSTEMD\n    switch (action) {\n    case SSSCTL_SVC_START:\n        return sssctl_systemd_start();\n    case SSSCTL_SVC_STOP:\n        return sssctl_systemd_stop();\n    case SSSCTL_SVC_RESTART:\n        return sssctl_systemd_restart();\n    }\n#elif defined(HAVE_SERVICE)\n    switch (action) {\n    case SSSCTL_SVC_START:\n        return sssctl_run_command(SERVICE_PATH\" sssd start\");\n    case SSSCTL_SVC_STOP:\n        return sssctl_run_command(SERVICE_PATH\" sssd stop\");\n    case SSSCTL_SVC_RESTART:\n        return sssctl_run_command(SERVICE_PATH\" sssd restart\");\n    }\n#endif\n\n    return ENOSYS;\n}",
        "output": "1",
        "idx": 54
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)\n{\n\tstruct ip_options *opt;\n\n\topt = inet_sk(sk)->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn -ENOMSG;\n\n\treturn cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct iphdr),\n\t\t\t\tsecattr);\n}",
        "output": "1",
        "idx": 1685
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint32_t getLength(const Buffer::Instance* instance) { return instance ? instance->length() : 0; }",
        "output": "0",
        "idx": 2438
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void hexprint(FILE *out, const unsigned char *buf, int buflen)\n\t{\n\tint i;\n\tfprintf(out, \"\\t\");\n\tfor (i = 0; i < buflen; i++)\n\t\tfprintf(out, \"%02X\", buf[i]);\n\tfprintf(out, \"\\n\");\n\t}",
        "output": "1",
        "idx": 2630
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kvm_set_mmio_data(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmio_req *p = kvm_get_vcpu_ioreq(vcpu);\n\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(&p->data, vcpu->mmio_data, 8);\n\tp->state = STATE_IORESP_READY;\n}",
        "output": "1",
        "idx": 242
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_string_opt(const char *s, unsigned len, const char *opt,\n\t\t\t  char **val)\n{\n\tint i;\n\tunsigned opt_len = strlen(opt);\n\tchar *d;\n\n\tif (*val)\n\t\tfree(*val);\n\t*val = (char *) malloc(len - opt_len + 1);\n\tif (!*val) {\n\t\tfprintf(stderr, \"%s: failed to allocate memory\\n\", progname);\n\t\treturn 0;\n\t}\n\n\td = *val;\n\ts += opt_len;\n\tlen -= opt_len;\n\tfor (i = 0; i < len; i++) {\n\t\tif (s[i] == '\\\\' && i + 1 < len)\n\t\t\ti++;\n\t\t*d++ = s[i];\n\t}\n\t*d = '\\0';\n\treturn 1;\n}",
        "output": "0",
        "idx": 3167
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST(HeaderMapImplTest, LargeCharInHeader) {\n  TestRequestHeaderMapImpl headers;\n  LowerCaseString static_key(\"\\x90hello\");\n  std::string ref_value(\"value\");\n  headers.addReference(static_key, ref_value);\n  EXPECT_EQ(\"value\", headers.get(static_key)->value().getStringView());\n}",
        "output": "0",
        "idx": 2661
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\tstruct rt6_info *rt;\n\n\trt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);\n\tif (rt->dst.error == -EAGAIN) {\n\t\tip6_rt_put_flags(rt, flags);\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tif (!(flags | RT6_LOOKUP_F_DST_NOREF))\n\t\t\tdst_hold(&rt->dst);\n\t}\n\n\treturn &rt->dst;\n}",
        "output": "1",
        "idx": 3091
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "zzip_mem_disk_fread (void* ptr, _zzip_size_t size, _zzip_size_t nmemb,\n                     ZZIP_DISK_FILE* file) {\n    return zzip_disk_fread(ptr, size, nmemb, file); }",
        "output": "1",
        "idx": 2812
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool get_rsds(ut8* dbg_data, int dbg_data_len, SCV_RSDS_HEADER* res) {\n\tconst int rsds_sz = 4 + sizeof (SGUID) + 4;\n\tif (dbg_data_len < rsds_sz) {\n\t\treturn false;\n\t}\n\tmemcpy (res, dbg_data, rsds_sz);\n\tres->file_name = (ut8*) strdup ((const char*) dbg_data + rsds_sz);\n\treturn true;\n}",
        "output": "0",
        "idx": 2048
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int restore_fp(struct task_struct *tsk)\n{\n\tif (tsk->thread.load_fp || tm_active_with_fp(tsk)) {\n\t\tload_fp_state(&current->thread.fp_state);\n\t\tcurrent->thread.load_fp++;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 363
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void ms_fast_dispatch(Message *m) override {\n    Session *s = static_cast<Session*>(m->get_connection()->get_priv());\n    if (!s) {\n      s = new Session(m->get_connection());\n      m->get_connection()->set_priv(s->get());\n    }\n    s->put();\n    s->count++;\n    lderr(g_ceph_context) << __func__ << \" conn: \" << m->get_connection() << \" session \" << s << \" count: \" << s->count << dendl;\n    if (is_server) {\n      if (loopback)\n        assert(m->get_source().is_osd());\n      else\n        reply_message(m);\n    } else if (loopback) {\n      assert(m->get_source().is_client());\n    }\n    m->put();\n    Mutex::Locker l(lock);\n    got_new = true;\n    cond.Signal();\n  }",
        "output": "0",
        "idx": 1112
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(ldap_dn2ufn)\n{\n\tchar *dn, *ufn;\n\tint dn_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &dn, &dn_len) != SUCCESS) {\n\t\treturn;\n\t}\n\n\tufn = ldap_dn2ufn(dn);\n\n\tif (ufn != NULL) {\n\t\tRETVAL_STRING(ufn, 1);\n#if (LDAP_API_VERSION > 2000) || HAVE_NSLDAP || HAVE_ORALDAP || WINDOWS\n\t\tldap_memfree(ufn);\n#endif\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}",
        "output": "0",
        "idx": 2376
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void ComputeAsync(OpKernelContext* c, DoneCallback done) override {\n    auto col_params = new CollectiveParams();\n    auto done_with_cleanup = [col_params, done = std::move(done)]() {\n      done();\n      col_params->Unref();\n    };\n    OP_REQUIRES_OK_ASYNC(c,\n                         FillCollectiveParams(col_params, REDUCTION_COLLECTIVE,\n                                              /*group_size*/ c->input(1),\n                                              /*group_key*/ c->input(2),\n                                              /*instance_key*/ c->input(3)),\n                         done);\n    col_params->instance.shape = c->input(0).shape();\n    col_params->merge_op = merge_op_.get();\n    col_params->final_op = final_op_.get();\n    VLOG(1) << \"CollectiveReduceV2 group_size \" << col_params->group.group_size\n            << \" group_key \" << col_params->group.group_key << \" instance_key \"\n            << col_params->instance.instance_key;\n    // Allocate the output tensor, trying to reuse the input.\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK_ASYNC(c,\n                         c->forward_input_or_allocate_output(\n                             {0}, 0, col_params->instance.shape, &output),\n                         done_with_cleanup);\n    Run(c, col_params, std::move(done_with_cleanup));\n  }",
        "output": "1",
        "idx": 3234
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool dwgReader21::parseSysPage(duint64 sizeCompressed, duint64 sizeUncompressed, duint64 correctionFactor, duint64 offset, duint8 *decompData){\n    //round to 8\n    duint64 alsize = (sizeCompressed + 7) &(-8);\n    //minimum RS chunk:\n    duint32 chunks = (((alsize * correctionFactor)+238)/239);\n    duint64 fpsize = chunks * 255;\n\n    if (! fileBuf->setPosition(offset))\n        return false;\n    std::vector<duint8> tmpDataRaw(fpsize);\n    fileBuf->getBytes(&tmpDataRaw.front(), fpsize);\n    std::vector<duint8> tmpDataRS(fpsize);\n    dwgRSCodec::decode239I(&tmpDataRaw.front(), &tmpDataRS.front(), fpsize/255);\n    dwgCompressor::decompress21(&tmpDataRS.front(), decompData, sizeCompressed, sizeUncompressed);\n    return true;\n}",
        "output": "1",
        "idx": 1609
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int selinux_disable(struct selinux_state *state)\n{\n\tif (selinux_initialized(state)) {\n\t\t/* Not permitted after initial policy load. */\n\t\treturn -EINVAL;\n\t}\n\n\tif (selinux_disabled(state)) {\n\t\t/* Only do this once. */\n\t\treturn -EINVAL;\n\t}\n\n\tselinux_mark_disabled(state);\n\n\tpr_info(\"SELinux:  Disabled at runtime.\\n\");\n\n\t/*\n\t * Unregister netfilter hooks.\n\t * Must be done before security_delete_hooks() to avoid breaking\n\t * runtime disable.\n\t */\n\tselinux_nf_ip_exit();\n\n\tsecurity_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));\n\n\t/* Try to destroy the avc node cache */\n\tavc_disable();\n\n\t/* Unregister selinuxfs. */\n\texit_sel_fs();\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1768
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API int r_socket_block_time (RSocket *s, int block, int sec, int usec) {\n\treturn -1;\n}",
        "output": "1",
        "idx": 649
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init xfrm6_tunnel_init(void)\n{\n\tint rv;\n\n\trv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);\n\tif (rv < 0)\n\t\tgoto err;\n\trv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);\n\tif (rv < 0)\n\t\tgoto unreg;\n\trv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);\n\tif (rv < 0)\n\t\tgoto dereg6;\n\trv = xfrm6_tunnel_spi_init();\n\tif (rv < 0)\n\t\tgoto dereg46;\n\trv = register_pernet_subsys(&xfrm6_tunnel_net_ops);\n\tif (rv < 0)\n\t\tgoto deregspi;\n\treturn 0;\n\nderegspi:\n\txfrm6_tunnel_spi_fini();\ndereg46:\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\ndereg6:\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\nunreg:\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\nerr:\n\treturn rv;\n}",
        "output": "1",
        "idx": 3211
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int zap_other_threads(struct task_struct *p)\n{\n\tstruct task_struct *t = p;\n\tint count = 0;\n\n\tp->signal->group_stop_count = 0;\n\n\twhile_each_thread(p, t) {\n\t\ttask_clear_group_stop_pending(t);\n\t\tcount++;\n\n\t\t/* Don't bother with already dead threads */\n\t\tif (t->exit_state)\n\t\t\tcontinue;\n\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\tsignal_wake_up(t, 1);\n\t}\n\n\treturn count;\n}",
        "output": "0",
        "idx": 470
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs)\n{\n    FILE *fp = fopen(dest_filename, \"w\");\n    if (!fp)\n        return false;\n\n    unsigned fd = 0;\n    while (fd <= 99999) /* paranoia check */\n    {\n        sprintf(source_filename + source_base_ofs, \"fd/%u\", fd);\n        char *name = malloc_readlink(source_filename);\n        if (!name)\n            break;\n        fprintf(fp, \"%u:%s\\n\", fd, name);\n        free(name);\n\n        sprintf(source_filename + source_base_ofs, \"fdinfo/%u\", fd);\n        fd++;\n        FILE *in = fopen(source_filename, \"r\");\n        if (!in)\n            continue;\n        char buf[128];\n        while (fgets(buf, sizeof(buf)-1, in))\n        {\n            /* in case the line is not terminated, terminate it */\n            char *eol = strchrnul(buf, '\\n');\n            eol[0] = '\\n';\n            eol[1] = '\\0';\n            fputs(buf, fp);\n        }\n        fclose(in);\n    }\n    fclose(fp);\n    return true;\n}",
        "output": "1",
        "idx": 1391
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void PngImg::InitStorage_() {\n    rowPtrs_.resize(info_.height, nullptr);\n    data_ = new png_byte[info_.height * info_.rowbytes];\n\n    for(size_t i = 0; i < info_.height; ++i) {\n        rowPtrs_[i] = data_ + i * info_.rowbytes;\n    }\n}",
        "output": "1",
        "idx": 3453
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool is_ascii_printable(unsigned char ch)\n{\n    return ((ch >= 32) && (ch <= 126));\n}",
        "output": "1",
        "idx": 2390
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tfile_sb_list_del(file);\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
        "output": "1",
        "idx": 2400
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\nstatic void __io_queue_proc(struct io_poll_iocb *poll, struct io_poll_table *pt,\n\t\t\t    struct wait_queue_head *head,\n\t\t\t    struct io_poll_iocb **poll_ptr)\n{\n\tstruct io_kiocb *req = pt->req;\n\n\t/*\n\t * If poll->head is already set, it's because the file being polled\n\t * uses multiple waitqueues for poll handling (eg one for read, one\n\t * for write). Setup a separate io_poll_iocb if this happens.\n\t */\n\tif (unlikely(poll->head)) {\n\t\tstruct io_poll_iocb *poll_one = poll;\n\n\t\t/* already have a 2nd entry, fail a third attempt */\n\t\tif (*poll_ptr) {\n\t\t\tpt->error = -EINVAL;\n\t\t\treturn;\n\t\t}\n\t\tpoll = kmalloc(sizeof(*poll), GFP_ATOMIC);\n\t\tif (!poll) {\n\t\t\tpt->error = -ENOMEM;\n\t\t\treturn;\n\t\t}\n\t\tio_init_poll_iocb(poll, poll_one->events, io_poll_double_wake);\n\t\trefcount_inc(&req->refs);\n\t\tpoll->wait.private = req;\n\t\t*poll_ptr = poll;\n\t}\n\n\tpt->error = 0;\n\tpoll->head = head;\n\n\tif (poll->events & EPOLLEXCLUSIVE)\n\t\tadd_wait_queue_exclusive(head, &poll->wait);\n\telse\n\t\tadd_wait_queue(head, &poll->wait);",
        "output": "0",
        "idx": 2914
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static plist_t parse_array_node(struct bplist_data *bplist, const char** bnode, uint64_t size)\n{\n    uint64_t j;\n    uint32_t str_j = 0;\n    uint32_t index1;\n\n    plist_data_t data = plist_new_plist_data();\n\n    data->type = PLIST_ARRAY;\n    data->length = size;\n\n    plist_t node = node_create(NULL, data);\n\n    for (j = 0; j < data->length; j++) {\n        str_j = j * bplist->ref_size;\n        index1 = UINT_TO_HOST((*bnode) + str_j, bplist->ref_size);\n\n        if (index1 >= bplist->num_objects) {\n            plist_free(node);\n            return NULL;\n        }\n\n        /* process value node */\n        plist_t val = parse_bin_node_at_index(bplist, index1);\n        if (!val) {\n            plist_free(node);\n            return NULL;\n        }\n\n        node_attach(node, val);\n    }\n\n    return node;\n}",
        "output": "1",
        "idx": 124
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gplotMakeOutput(GPLOT  *gplot)\n{\nchar     buf[L_BUF_SIZE];\nchar    *cmdname;\nl_int32  ignore;\n\n    PROCNAME(\"gplotMakeOutput\");\n\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n\n    gplotGenCommandFile(gplot);\n    gplotGenDataFiles(gplot);\n    cmdname = genPathname(gplot->cmdname, NULL);\n\n#ifndef _WIN32\n    snprintf(buf, L_BUF_SIZE, \"gnuplot %s\", cmdname);\n#else\n    snprintf(buf, L_BUF_SIZE, \"wgnuplot %s\", cmdname);\n#endif  /* _WIN32 */\n\n#ifndef OS_IOS /* iOS 11 does not support system() */\n    ignore = system(buf);  /* gnuplot || wgnuplot */\n#endif /* !OS_IOS */\n\n    LEPT_FREE(cmdname);\n    return 0;\n}",
        "output": "1",
        "idx": 71
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int setTypeAdd(robj *subject, sds value) {\n    long long llval;\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        dict *ht = subject->ptr;\n        dictEntry *de = dictAddRaw(ht,value,NULL);\n        if (de) {\n            dictSetKey(ht,de,sdsdup(value));\n            dictSetVal(ht,de,NULL);\n            return 1;\n        }\n    } else if (subject->encoding == OBJ_ENCODING_INTSET) {\n        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {\n            uint8_t success = 0;\n            subject->ptr = intsetAdd(subject->ptr,llval,&success);\n            if (success) {\n                /* Convert to regular set when the intset contains\n                 * too many entries. */\n                if (intsetLen(subject->ptr) > server.set_max_intset_entries)\n                    setTypeConvert(subject,OBJ_ENCODING_HT);\n                return 1;\n            }\n        } else {\n            /* Failed to get integer from object, convert to regular set. */\n            setTypeConvert(subject,OBJ_ENCODING_HT);\n\n            /* The set *was* an intset and this value is not integer\n             * encodable, so dictAdd should always work. */\n            serverAssert(dictAdd(subject->ptr,sdsdup(value),NULL) == DICT_OK);\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}",
        "output": "1",
        "idx": 1000
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bgp_attr_med (struct bgp_attr_parser_args *args)\n{\n  struct peer *const peer = args->peer; \n  struct attr *const attr = args->attr;\n  const bgp_size_t length = args->length;\n  \n  /* Length check. */\n  if (length != 4)\n    {\n      zlog (peer->log, LOG_ERR, \n\t    \"MED attribute length isn't four [%d]\", length);\n\n      return bgp_attr_malformed (args,\n                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n                                 args->total);\n    }\n\n  attr->med = stream_getl (peer->ibuf);\n\n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);\n\n  return BGP_ATTR_PARSE_PROCEED;\n}",
        "output": "0",
        "idx": 603
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct geneve_sock *geneve_find_sock(struct geneve_net *gn,\n\t\t\t\t\t    sa_family_t family,\n\t\t\t\t\t    __be16 dst_port)\n{\n\tstruct geneve_sock *gs;\n\n\tlist_for_each_entry(gs, &gn->sock_list, list) {\n\t\tif (inet_sk(gs->sock->sk)->inet_sport == dst_port &&\n\t\t    geneve_get_sk_family(gs) == family) {\n\t\t\treturn gs;\n\t\t}\n\t}\n\treturn NULL;\n}",
        "output": "0",
        "idx": 3697
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tbs->size = se->length;\n\t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n\t\tbs->bits = R_SYS_BITS_16;\n\t\tbs->is_data = se->flags & IS_DATA;\n\t\tbs->perm = __translate_perms (se->flags);\n\t\tbs->paddr = (ut64)se->offset * bin->alignment;\n\t\tbs->name = r_str_newf (\"%s.%\" PFMT64d, se->flags & IS_MOVEABLE ? \"MOVEABLE\" : \"FIXED\", bs->paddr);\n\t\tbs->is_segment = true;\n\t\tr_list_append (segments, bs);\n\t}\n\tbin->segments = segments;\n\treturn segments;\n}",
        "output": "1",
        "idx": 370
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int enc_untrusted_inet_pton(int af, const char *src, void *dst) {\n  if (!src || !dst) {\n    return 0;\n  }\n\n  MessageWriter input;\n  input.Push<int>(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{\n      src, std::min(strlen(src) + 1, static_cast<size_t>(INET6_ADDRSTRLEN))});\n  MessageReader output;\n\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetPtonHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inet_pton\", 3);\n\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return -1;\n  }\n\n  auto klinux_addr_buffer = output.next();\n  size_t max_size = 0;\n  if (af == AF_INET) {\n    max_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    max_size = sizeof(struct in6_addr);\n  }\n  memcpy(dst, klinux_addr_buffer.data(),\n         std::min(klinux_addr_buffer.size(), max_size));\n  return result;\n}",
        "output": "1",
        "idx": 2763
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  String_Schema_Obj Parser::parse_css_variable_value(bool top_level)\n  {\n    String_Schema_Obj schema = SASS_MEMORY_NEW(String_Schema, pstate);\n    String_Schema_Obj tok;\n    if (!(tok = parse_css_variable_value_token(top_level))) {\n      return {};\n    }\n\n    schema->concat(tok);\n    while ((tok = parse_css_variable_value_token(top_level))) {\n      schema->concat(tok);\n    }\n\n    return schema.detach();\n  }",
        "output": "1",
        "idx": 93
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_new_tref (void)\n{\n    RsvgNodeTref *text;\n    text = g_new (RsvgNodeTref, 1);\n    _rsvg_node_init (&text->super);\n    text->super.set_atts = _rsvg_node_tref_set_atts;\n    text->link = NULL;\n    return &text->super;\n}",
        "output": "1",
        "idx": 1997
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool LOGGER::flush_general_log()\n{\n  /*\n    Now we lock logger, as nobody should be able to use logging routines while\n    log tables are closed\n  */\n  logger.lock_exclusive();\n\n  /* Reopen general log file */\n  if (opt_log)\n    file_log_handler->get_mysql_log()->reopen_file();\n\n  /* End of log flush */\n  logger.unlock();\n\n  return 0;\n}",
        "output": "0",
        "idx": 3457
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PackBSDElf32x86::~PackBSDElf32x86()\n{\n}",
        "output": "0",
        "idx": 2201
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool CModules::OnUserTextMessage(CTextMessage& Message) {\n    MODHALTCHK(OnUserTextMessage(Message));\n}",
        "output": "0",
        "idx": 2915
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gdk_pixbuf_copy (const GdkPixbuf *pixbuf)\n{\n\tguchar *buf;\n\tint size;\n\n\tg_return_val_if_fail (GDK_IS_PIXBUF (pixbuf), NULL);\n\n\t/* Calculate a semi-exact size.  Here we copy with full rowstrides;\n\t * maybe we should copy each row individually with the minimum\n\t * rowstride?\n\t */\n\n\tsize = gdk_pixbuf_get_byte_length (pixbuf);\n\n\tbuf = g_try_malloc (size * sizeof (guchar));\n\tif (!buf)\n\t\treturn NULL;\n\n\tmemcpy (buf, pixbuf->pixels, size);\n\n\treturn gdk_pixbuf_new_from_data (buf,\n\t\t\t\t\t pixbuf->colorspace, pixbuf->has_alpha,\n\t\t\t\t\t pixbuf->bits_per_sample,\n\t\t\t\t\t pixbuf->width, pixbuf->height,\n\t\t\t\t\t pixbuf->rowstride,\n\t\t\t\t\t free_buffer,\n\t\t\t\t\t NULL);\n}",
        "output": "1",
        "idx": 791
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct dst_entry *inet_csk_route_req(struct sock *sk,\n\t\t\t\t     const struct request_sock *req)\n{\n\tstruct rtable *rt;\n\tconst struct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ip_options *opt = inet_rsk(req)->opt;\n\tstruct net *net = sock_net(sk);\n\tstruct flowi4 fl4;\n\n\tflowi4_init_output(&fl4, sk->sk_bound_dev_if, sk->sk_mark,\n\t\t\t   RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE,\n\t\t\t   sk->sk_protocol, inet_sk_flowi_flags(sk),\n\t\t\t   (opt && opt->srr) ? opt->faddr : ireq->rmt_addr,\n\t\t\t   ireq->loc_addr, ireq->rmt_port, inet_sk(sk)->inet_sport);\n\tsecurity_req_classify_flow(req, flowi4_to_flowi(&fl4));\n\trt = ip_route_output_flow(net, &fl4, sk);\n\tif (IS_ERR(rt))\n\t\tgoto no_route;\n\tif (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway)\n\t\tgoto route_err;\n\treturn &rt->dst;\n\nroute_err:\n\tip_rt_put(rt);\nno_route:\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES);\n\treturn NULL;\n}",
        "output": "1",
        "idx": 31
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)\n{\n    PadContext *s = inlink->dst->priv;\n\n    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],\n                                         w + (s->w - s->in_w),\n                                         h + (s->h - s->in_h));\n    int plane;\n\n    if (!frame)\n        return NULL;\n\n    frame->width  = w;\n    frame->height = h;\n\n    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n        int hsub = s->draw.hsub[plane];\n        int vsub = s->draw.vsub[plane];\n        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +\n                              (s->y >> vsub) * frame->linesize[plane];\n    }\n\n    return frame;\n}",
        "output": "1",
        "idx": 1753
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *ldb_dn_escape_value(TALLOC_CTX *mem_ctx, struct ldb_val value)\n{\n\tchar *dst;\n\n\tif (!value.length)\n\t\treturn NULL;\n\n\t/* allocate destination string, it will be at most 3 times the source */\n\tdst = talloc_array(mem_ctx, char, value.length * 3 + 1);\n\tif ( ! dst) {\n\t\ttalloc_free(dst);\n\t\treturn NULL;\n\t}\n\n\tldb_dn_escape_internal(dst, (const char *)value.data, value.length);\n\n\tdst = talloc_realloc(mem_ctx, dst, char, strlen(dst) + 1);\n\n\treturn dst;\n}",
        "output": "1",
        "idx": 2814
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Item_ref::val_bool_result()\n{\n  if (result_field)\n  {\n    if ((null_value= result_field->is_null()))\n      return 0;\n    switch (result_field->result_type()) {\n    case INT_RESULT:\n      return result_field->val_int() != 0;\n    case DECIMAL_RESULT:\n    {\n      my_decimal decimal_value;\n      my_decimal *val= result_field->val_decimal(&decimal_value);\n      if (val)\n        return !my_decimal_is_zero(val);\n      return 0;\n    }\n    case REAL_RESULT:\n    case STRING_RESULT:\n      return result_field->val_real() != 0.0;\n    case ROW_RESULT:\n    case TIME_RESULT:\n    case IMPOSSIBLE_RESULT:\n      DBUG_ASSERT(0);\n    }\n  }\n  return val_bool();\n}",
        "output": "0",
        "idx": 1265
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "free_funccal_contents(funccall_T *fc)\n{\n    listitem_T\t*li;\n\n    // Free all l: variables.\n    vars_clear(&fc->l_vars.dv_hashtab);\n\n    // Free all a: variables.\n    vars_clear(&fc->l_avars.dv_hashtab);\n\n    // Free the a:000 variables.\n    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)\n\tclear_tv(&li->li_tv);\n\n    free_funccal(fc);\n}",
        "output": "0",
        "idx": 2838
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int put_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)\n{\n\tif (!access_ok(VERIFY_WRITE, up, sizeof(*up)))\n\t\treturn -EFAULT;\n\treturn __put_v4l2_format32(kp, up);\n}",
        "output": "1",
        "idx": 3245
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileInfo, getRealPath)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar buff[MAXPATHLEN];\n\tchar *filename;\n\tzend_error_handling error_handling;\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n\tif (intern->type == SPL_FS_DIR && !intern->file_name && intern->u.dir.entry.d_name[0]) {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t}\n\t\n\tif (intern->orig_path) {\n\t\tfilename = intern->orig_path;\n\t} else { \n\t\tfilename = intern->file_name;\n\t}\n\n\n\tif (filename && VCWD_REALPATH(filename, buff)) {\n#ifdef ZTS\n\t\tif (VCWD_ACCESS(buff, F_OK)) {\n\t\t\tRETVAL_FALSE;\n\t\t} else\n#endif\n\t\tRETVAL_STRING(buff, 1);\n\t} else {\n\t\tRETVAL_FALSE;\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}",
        "output": "1",
        "idx": 1728
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sas_init_port(struct asd_sas_port *port,\n\t\t\t  struct sas_ha_struct *sas_ha, int i)\n{\n\tmemset(port, 0, sizeof(*port));\n\tport->id = i;\n\tINIT_LIST_HEAD(&port->dev_list);\n\tINIT_LIST_HEAD(&port->disco_list);\n\tINIT_LIST_HEAD(&port->destroy_list);\n\tspin_lock_init(&port->phy_list_lock);\n\tINIT_LIST_HEAD(&port->phy_list);\n\tport->ha = sas_ha;\n\n\tspin_lock_init(&port->dev_list_lock);\n}",
        "output": "1",
        "idx": 703
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *ask_new_shell(char *question, char *oldshell)\n{\n\tint len;\n\tchar *ans = NULL;\n\tsize_t dummy = 0;\n\n\tif (!oldshell)\n\t\toldshell = \"\";\n\tprintf(\"%s [%s]:\", question, oldshell);\n\tputchar(' ');\n\n\tif (getline(&ans, &dummy, stdin) < 0)\n\t\treturn NULL;\n\n\t/* remove the newline at the end of ans. */\n\tltrim_whitespace((unsigned char *) ans);\n\tlen = rtrim_whitespace((unsigned char *) ans);\n\tif (len == 0)\n\t\treturn NULL;\n\treturn ans;\n}",
        "output": "0",
        "idx": 413
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "S3BootScriptLabelInternal (\r\n  IN        BOOLEAN                        BeforeOrAfter,\r\n  IN OUT    VOID                         **Position OPTIONAL,\r\n  IN        UINT32                         InformationLength,\r\n  IN CONST  CHAR8                          *Information\r\n  )\r\n{\r\n  UINT8                 Length;\r\n  UINT8                 *Script;\r\n  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;\r\n\r\n  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);\r\n\r\n  Script = S3BootScriptGetEntryAddAddress (Length);\r\n  if (Script == NULL) {\r\n    return RETURN_OUT_OF_RESOURCES;\r\n  }\r\n  //\r\n  // Build script data\r\n  //\r\n  ScriptInformation.OpCode     = S3_BOOT_SCRIPT_LIB_LABEL_OPCODE;\r\n  ScriptInformation.Length     = Length;\r\n\r\n\r\n  ScriptInformation.InformationLength = InformationLength;\r\n\r\n  CopyMem ((VOID*)Script, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));\r\n  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);\r\n\r\n  SyncBootScript (Script);\r\n\r\n  return S3BootScriptMoveLastOpcode (BeforeOrAfter, Position);\r\n\r\n}\r",
        "output": "1",
        "idx": 1253
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PS_SERIALIZER_ENCODE_FUNC(wddx)\n{\n\twddx_packet *packet;\n\tPS_ENCODE_VARS;\n\n\tpacket = php_wddx_constructor();\n\n\tphp_wddx_packet_start(packet, NULL, 0);\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_S);\n\t\n\tPS_ENCODE_LOOP(\n\t\tphp_wddx_serialize_var(packet, *struc, key, key_length TSRMLS_CC);\n\t);\n\t\n\tphp_wddx_add_chunk_static(packet, WDDX_STRUCT_E);\n\tphp_wddx_packet_end(packet);\n\t*newstr = php_wddx_gather(packet);\n\tphp_wddx_destructor(packet);\n\t\n\tif (newlen) {\n\t\t*newlen = strlen(*newstr);\n\t}\n\n\treturn SUCCESS;\n}",
        "output": "1",
        "idx": 2046
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "errno_t sssctl_logs_remove(struct sss_cmdline *cmdline,\n                           struct sss_tool_ctx *tool_ctx,\n                           void *pvt)\n{\n    struct sssctl_logs_opts opts = {0};\n    errno_t ret;\n\n    /* Parse command line. */\n    struct poptOption options[] = {\n        {\"delete\", 'd', POPT_ARG_NONE, &opts.delete, 0, _(\"Delete log files instead of truncating\"), NULL },\n        POPT_TABLEEND\n    };\n\n    ret = sss_tool_popt(cmdline, options, SSS_TOOL_OPT_OPTIONAL, NULL, NULL);\n    if (ret != EOK) {\n        DEBUG(SSSDBG_CRIT_FAILURE, \"Unable to parse command arguments\\n\");\n        return ret;\n    }\n\n    if (opts.delete) {\n        PRINT(\"Deleting log files...\\n\");\n        ret = sss_remove_subtree(LOG_PATH);\n        if (ret != EOK) {\n            ERROR(\"Unable to remove log files\\n\");\n            return ret;\n        }\n\n        sss_signal(SIGHUP);\n    } else {\n        PRINT(\"Truncating log files...\\n\");\n        ret = sssctl_run_command(\"truncate --no-create --size 0 \" LOG_FILES);\n        if (ret != EOK) {\n            ERROR(\"Unable to truncate log files\\n\");\n            return ret;\n        }\n    }\n\n    return EOK;\n}",
        "output": "1",
        "idx": 2538
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tftp_session_allocate(Slirp *slirp, struct sockaddr_storage *srcsas,\n                                 struct tftphdr *hdr)\n{\n    struct tftp_session *spt;\n    int k;\n\n    for (k = 0; k < TFTP_SESSIONS_MAX; k++) {\n        spt = &slirp->tftp_sessions[k];\n\n        if (!tftp_session_in_use(spt))\n            goto found;\n\n        /* sessions time out after 5 inactive seconds */\n        if ((int)(curtime - spt->timestamp) > 5000) {\n            tftp_session_terminate(spt);\n            goto found;\n        }\n    }\n\n    return -1;\n\nfound:\n    memset(spt, 0, sizeof(*spt));\n    memcpy(&spt->client_addr, srcsas, sockaddr_size(srcsas));\n    spt->fd = -1;\n    spt->block_size = 512;\n    spt->client_port = hdr->udp.uh_sport;\n    spt->slirp = slirp;\n\n    tftp_session_update(spt);\n\n    return k;\n}",
        "output": "0",
        "idx": 2322
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WandExport double *DrawGetStrokeDashArray(const DrawingWand *wand,\n  size_t *number_elements)\n{\n  double\n    *dasharray;\n\n  register const double\n    *p;\n\n  register double\n    *q;\n\n  register ssize_t\n    i;\n\n  size_t\n    n;\n\n  assert(wand != (const DrawingWand *) NULL);\n  assert(wand->signature == MagickWandSignature);\n  if (wand->debug != MagickFalse)\n    (void) LogMagickEvent(WandEvent,GetMagickModule(),\"%s\",wand->name);\n  assert(number_elements != (size_t *) NULL);\n  n=0;\n  p=CurrentContext->dash_pattern;\n  if (p != (const double *) NULL)\n    while (fabs(*p++) >= MagickEpsilon)\n      n++;\n  *number_elements=n;\n  dasharray=(double *) NULL;\n  if (n != 0)\n    {\n      dasharray=(double *) AcquireQuantumMemory((size_t) n+1UL,\n        sizeof(*dasharray));\n      p=CurrentContext->dash_pattern;\n      q=dasharray;\n      for (i=0; i < (ssize_t) n; i++)\n        *q++=(*p++);\n      *q=0.0;\n    }\n  return(dasharray);\n}",
        "output": "1",
        "idx": 2775
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "authDigestNonceLinks(digest_nonce_h * nonce)\n{\n    if (!nonce)\n        return -1;\n\n    return nonce->references;\n}",
        "output": "1",
        "idx": 2809
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char *SSL_get_cipher_list(const SSL *s, int n)\n{\n    SSL_CIPHER *c;\n    STACK_OF(SSL_CIPHER) *sk;\n\n    if (s == NULL)\n        return (NULL);\n    sk = SSL_get_ciphers(s);\n    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))\n        return (NULL);\n    c = sk_SSL_CIPHER_value(sk, n);\n    if (c == NULL)\n        return (NULL);\n    return (c->name);\n}",
        "output": "0",
        "idx": 481
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QPDF::resolve(int objid, int generation)\n{\n    // Check object cache before checking xref table.  This allows us\n    // to insert things into the object cache that don't actually\n    // exist in the file.\n    QPDFObjGen og(objid, generation);\n    if (! this->obj_cache.count(og))\n    {\n\tif (! this->xref_table.count(og))\n\t{\n\t    // PDF spec says unknown objects resolve to the null object.\n\t    return new QPDF_Null;\n\t}\n\n\tQPDFXRefEntry const& entry = this->xref_table[og];\n\tswitch (entry.getType())\n\t{\n\t  case 1:\n\t    {\n\t\tqpdf_offset_t offset = entry.getOffset();\n\t\t// Object stored in cache by readObjectAtOffset\n\t\tint aobjid;\n\t\tint ageneration;\n\t\tQPDFObjectHandle oh =\n\t\t    readObjectAtOffset(true, offset, \"\", objid, generation,\n\t\t\t\t       aobjid, ageneration);\n\t    }\n\t    break;\n\n\t  case 2:\n\t    resolveObjectsInStream(entry.getObjStreamNumber());\n\t    break;\n\n\t  default:\n\t    throw QPDFExc(qpdf_e_damaged_pdf, this->file->getName(), \"\", 0,\n\t\t\t  \"object \" +\n\t\t\t  QUtil::int_to_string(objid) + \"/\" +\n\t\t\t  QUtil::int_to_string(generation) +\n\t\t\t  \" has unexpected xref entry type\");\n\t}\n    }\n\n    return this->obj_cache[og].object;\n}",
        "output": "1",
        "idx": 1434
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Token *zap_white(Token *x)\n{\n    while (tok_white(x))\n        x = delete_Token(x);\n\n    return x;\n}",
        "output": "0",
        "idx": 3571
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_wrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tint conf_req_flag,\n\t\tgss_qop_t qop_req,\n\t\tgss_buffer_t input_message_buffer,\n\t\tint *conf_state,\n\t\tgss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap(minor_status,\n\t\t    context_handle,\n\t\t    conf_req_flag,\n\t\t    qop_req,\n\t\t    input_message_buffer,\n\t\t    conf_state,\n\t\t    output_message_buffer);\n\n\treturn (ret);\n}",
        "output": "1",
        "idx": 403
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "std::string encodeBase64(const std::string& input) {\n  using namespace boost::archive::iterators;\n  using b64it = base64_from_binary<transform_width<const char*, 6, 8>>;\n\n  auto data = input.data();\n  std::string encoded(b64it(data), b64it(data + (input.length())));\n  encoded.append((3 - (input.length() % 3)) % 3, '=');\n\n  return encoded;\n}",
        "output": "1",
        "idx": 3508
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "free_wininfo(wininfo_T *wip)\n{\n    if (wip->wi_optset)\n    {\n\tclear_winopt(&wip->wi_opt);\n#ifdef FEAT_FOLDING\n\tdeleteFoldRecurse(&wip->wi_folds);\n#endif\n    }\n    vim_free(wip);\n}",
        "output": "0",
        "idx": 16
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int test_x509_time_print(int idx)\n{\n    BIO *m;\n    int ret = 0, rv;\n    char *pp;\n    const char *readable;\n\n    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))\n        goto err;\n\n    rv = ASN1_TIME_print(m, &x509_print_tests[idx].asn1);\n    readable = x509_print_tests[idx].readable;\n\n    if (rv == 0 && !TEST_str_eq(readable, \"Bad time value\")) {\n        /* only if the test case intends to fail... */\n        goto err;\n    }\n    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &pp), 0)\n        || !TEST_int_eq(rv, (int)strlen(readable))\n        || !TEST_strn_eq(pp, readable, rv))\n        goto err;\n\n    ret = 1;\n err:\n    BIO_free(m);\n    return ret;\n}",
        "output": "0",
        "idx": 326
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int setup_tests(void)\n{\n    ADD_ALL_TESTS(call_run_cert, OSSL_NELEM(name_fns));\n    return 1;\n}",
        "output": "1",
        "idx": 1438
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq)\n{\n\tu64 ns = 0;\n\n\tif (task_current(rq, p)) {\n\t\tupdate_rq_clock(rq);\n\t\tns = rq_clock_task(rq) - p->se.exec_start;\n\t\tif ((s64)ns < 0)\n\t\t\tns = 0;\n\t}\n\n\treturn ns;\n}",
        "output": "0",
        "idx": 3556
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\tuint8_t value;\n\n\tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t0, reg, &value, 1, 1000);\n\treturn ret >= 0 ? value : ret;\n}",
        "output": "1",
        "idx": 101
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mb86a20s_get_segment_count(struct mb86a20s_state *state,\n\t\t\t\t      unsigned layer)\n{\n\tint rc, count;\n\tstatic unsigned char reg[] = {\n\t\t[0] = 0x89,\t/* Layer A */\n\t\t[1] = 0x8d,\t/* Layer B */\n\t\t[2] = 0x91,\t/* Layer C */\n\t};\n\n\tdev_dbg(&state->i2c->dev, \"%s called.\\n\", __func__);\n\n\tif (layer >= ARRAY_SIZE(reg))\n\t\treturn -EINVAL;\n\n\trc = mb86a20s_writereg(state, 0x6d, reg[layer]);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = mb86a20s_readreg(state, 0x6e);\n\tif (rc < 0)\n\t\treturn rc;\n\tcount = (rc >> 4) & 0x0f;\n\n\tdev_dbg(&state->i2c->dev, \"%s: segments: %d.\\n\", __func__, count);\n\n\treturn count;\n}",
        "output": "0",
        "idx": 1690
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main( int argc, char *argv[] )\n{\n    ((void) argc);\n    ((void) argv);\n\n    printf(\"POLARSSL_BIGNUM_C and/or POLARSSL_RSA_C and/or \"\n           \"POLARSSL_SHA1_C and/or POLARSSL_X509_PARSE_C and/or \"\n           \"POLARSSL_FS_IO not defined.\\n\");\n    return( 0 );\n}",
        "output": "1",
        "idx": 2245
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bit_write_MC (Bit_Chain *dat, BITCODE_MC val)\n{\n  int i, j;\n  int negative = 0;\n  unsigned char byte[5];\n  BITCODE_UMC mask = 0x0000007f;\n  BITCODE_UMC value = (BITCODE_UMC)val;\n\n  if (val < 0)\n    {\n      negative = 1;\n      value = (BITCODE_UMC)-val;\n    }\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = (unsigned char)((value & mask) >> j);\n      byte[i] |= 0x80;\n      mask = mask << 7;\n    }\n  for (i = 0; i < 4; i++)\n    if (byte[i] & 0x7f)\n      break;\n\n  if (byte[i] & 0x40)\n    i--;\n  byte[i] &= 0x7f;\n  if (negative)\n    byte[i] |= 0x40;\n  for (j = 4; j >= i; j--)\n    bit_write_RC (dat, byte[j]);\n}",
        "output": "1",
        "idx": 798
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CoreUserInputHandler::handleMsg(const BufferInfo &bufferInfo, const QString &msg)\n{\n    Q_UNUSED(bufferInfo);\n    if (!msg.contains(' '))\n        return;\n\n    QString target = msg.section(' ', 0, 0);\n    QByteArray encMsg = userEncode(target, msg.section(' ', 1));\n\n#ifdef HAVE_QCA2\n    putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));\n#else\n    putPrivmsg(serverEncode(target), encMsg);\n#endif\n}",
        "output": "1",
        "idx": 3617
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_framing_cap_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_ASYNC_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_SYNC_MASK) {\n\t\tND_PRINT((ndo, \"S\"));\n\t}\n}",
        "output": "1",
        "idx": 987
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool mpOk(const QString &mp)\n{\n    return !mp.isEmpty() && mp.startsWith(\"/home/\"); // ) && mp.contains(\"cantata\");\n}",
        "output": "1",
        "idx": 1167
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "asmlinkage long sys_oabi_semtimedop(int semid,\n\t\t\t\t    struct oabi_sembuf __user *tsops,\n\t\t\t\t    unsigned nsops,\n\t\t\t\t    const struct timespec __user *timeout)\n{\n\tstruct sembuf *sops;\n\tstruct timespec local_timeout;\n\tlong err;\n\tint i;\n\n\tif (nsops < 1 || nsops > SEMOPM)\n\t\treturn -EINVAL;\n\tsops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);\n\tif (!sops)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tfor (i = 0; i < nsops; i++) {\n\t\t__get_user_error(sops[i].sem_num, &tsops->sem_num, err);\n\t\t__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);\n\t\t__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);\n\t\ttsops++;\n\t}\n\tif (timeout) {\n\t\t/* copy this as well before changing domain protection */\n\t\terr |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));\n\t\ttimeout = &local_timeout;\n\t}\n\tif (err) {\n\t\terr = -EFAULT;\n\t} else {\n\t\tmm_segment_t fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = sys_semtimedop(semid, sops, nsops, timeout);\n\t\tset_fs(fs);\n\t}\n\tkfree(sops);\n\treturn err;\n}",
        "output": "1",
        "idx": 408
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_rre_bounds_server(GInputStream *is, GOutputStream *os)\n{\n    test_common_bounds_server(is, os);\n\n    /* Message type & pad */\n    test_send_u8(os, 0);\n    test_send_u8(os, 0);\n\n    /* num rect */\n    test_send_u16(os, 1);\n    /* x, y, w, h */\n    test_send_u16(os, 90);\n    test_send_u16(os, 90);\n    test_send_u16(os, 10);\n    test_send_u16(os, 10);\n\n    /* encoding=rre */\n    test_send_s32(os, 2);\n\n    /* num rect */\n    test_send_u32(os, 1);\n\n    /* bg pix, fg pix */\n    test_send_u32(os, 0x41414141);\n    test_send_u32(os, 0x42424242);\n\n    /* x, y, w, h */\n    test_send_u16(os, 10);\n    test_send_u16(os, 10000);\n    test_send_u16(os, 1);\n    test_send_u16(os, 1);\n}",
        "output": "0",
        "idx": 1799
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_get_cfgdata16(struct pci_vdev *dev, int offset)\n{\n\tassert(offset <= (PCI_REGMAX - 1) && (offset & 1) == 0);\n\treturn (*(uint16_t *)(dev->cfgdata + offset));\n}",
        "output": "1",
        "idx": 1450
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hasExternalSubsetDebug(void *ctx ATTRIBUTE_UNUSED)\n{\n    callbacks++;\n    if (noout)\n\treturn(0);\n    fprintf(stdout, \"SAX.hasExternalSubset()\\n\");\n    return(0);\n}",
        "output": "0",
        "idx": 3074
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\t\t\t     struct timespec64 *ts, enum hrtimer_mode mode)\n\t__must_hold(&ctx->timeout_lock)\n{\n\tstruct io_cancel_data cd = { .data = user_data, };\n\tstruct io_kiocb *req = io_timeout_extract(ctx, &cd);\n\tstruct io_timeout_data *data;\n\n\tif (IS_ERR(req))\n\t\treturn PTR_ERR(req);\n\n\treq->timeout.off = 0; /* noseq */\n\tdata = req->async_data;\n\tlist_add_tail(&req->timeout.list, &ctx->timeout_list);\n\thrtimer_init(&data->timer, io_timeout_get_clock(data), mode);\n\tdata->timer.function = io_timeout_fn;\n\thrtimer_start(&data->timer, timespec64_to_ktime(*ts), mode);\n\treturn 0;",
        "output": "1",
        "idx": 2319
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GuestFsfreezeStatus qmp_guest_fsfreeze_status(Error **errp)\n{\n    if (ga_is_frozen(ga_state)) {\n        return GUEST_FSFREEZE_STATUS_FROZEN;\n    }\n\n    return GUEST_FSFREEZE_STATUS_THAWED;\n}",
        "output": "0",
        "idx": 1316
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int pte_numa(pte_t pte)\n{\n\treturn (pte_flags(pte) &\n\t\t(_PAGE_NUMA|_PAGE_PRESENT)) == _PAGE_NUMA;\n}",
        "output": "0",
        "idx": 2590
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int http_buf_read(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int len;\n    /* read bytes from input buffer first */\n    len = s->buf_end - s->buf_ptr;\n    if (len > 0) {\n        if (len > size)\n            len = size;\n        memcpy(buf, s->buf_ptr, len);\n        s->buf_ptr += len;\n    } else {\n        int64_t target_end = s->end_off ? s->end_off : s->filesize;\n        if ((!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off >= target_end)\n            return AVERROR_EOF;\n        len = ffurl_read(s->hd, buf, size);\n        if (!len && (!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off < target_end) {\n            av_log(h, AV_LOG_ERROR,\n                   \"Stream ends prematurely at %\"PRId64\", should be %\"PRId64\"\\n\",\n                   s->off, target_end\n                  );\n            return AVERROR(EIO);\n        }\n    }\n    if (len > 0) {\n        s->off += len;\n        if (s->chunksize > 0)\n            s->chunksize -= len;\n    }\n    return len;\n}",
        "output": "1",
        "idx": 851
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BOOL security_decrypt(BYTE* data, size_t length, rdpRdp* rdp)\n{\n\tif (rdp->rc4_decrypt_key == NULL)\n\t\treturn FALSE;\n\n\tif (rdp->decrypt_use_count >= 4096)\n\t{\n\t\tif (!security_key_update(rdp->decrypt_key, rdp->decrypt_update_key, rdp->rc4_key_len, rdp))\n\t\t\treturn FALSE;\n\n\t\twinpr_RC4_Free(rdp->rc4_decrypt_key);\n\t\trdp->rc4_decrypt_key = winpr_RC4_New(rdp->decrypt_key, rdp->rc4_key_len);\n\n\t\tif (!rdp->rc4_decrypt_key)\n\t\t\treturn FALSE;\n\n\t\trdp->decrypt_use_count = 0;\n\t}\n\n\tif (!winpr_RC4_Update(rdp->rc4_decrypt_key, length, data, data))\n\t\treturn FALSE;\n\n\trdp->decrypt_use_count += 1;\n\trdp->decrypt_checksum_use_count++;\n\treturn TRUE;\n}",
        "output": "0",
        "idx": 1045
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n\t\t\t   gss_ctx_id_t context_handle,\n\t\t\t   int conf_req_flag,\n\t\t\t   gss_qop_t qop_req,\n\t\t\t   int *conf_state,\n\t\t\t   gss_iov_buffer_desc *iov,\n\t\t\t   int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov_length(minor_status,\n\t\t\t\t  context_handle,\n\t\t\t\t  conf_req_flag,\n\t\t\t\t  qop_req,\n\t\t\t\t  conf_state,\n\t\t\t\t  iov,\n\t\t\t\t  iov_count);\n\treturn (ret);\n}",
        "output": "1",
        "idx": 2731
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PS_CREATE_SID_FUNC(mm)\n{\n\tchar *sid;\n\tPS_MM_DATA;\n\n\tsid = php_session_create_id((void **)&data, newlen TSRMLS_CC);\n\n\treturn sid;\n}",
        "output": "1",
        "idx": 3423
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(imagesetstyle)\n{\n\tzval *IM, *styles;\n\tgdImagePtr im;\n\tint * stylearr;\n\tint index;\n\tHashPosition pos;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ra\", &IM, &styles) == FAILURE)  {\n\t\treturn;\n\t}\n\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\n\t/* copy the style values in the stylearr */\n\tstylearr = safe_emalloc(sizeof(int), zend_hash_num_elements(HASH_OF(styles)), 0);\n\n\tzend_hash_internal_pointer_reset_ex(HASH_OF(styles), &pos);\n\n\tfor (index = 0;; zend_hash_move_forward_ex(HASH_OF(styles), &pos))\t{\n\t\tzval ** item;\n\n\t\tif (zend_hash_get_current_data_ex(HASH_OF(styles), (void **) &item, &pos) == FAILURE) {\n\t\t\tbreak;\n\t\t}\n\n\t\tconvert_to_long_ex(item);\n\n\t\tstylearr[index++] = Z_LVAL_PP(item);\n\t}\n\n\tgdImageSetStyle(im, stylearr, index);\n\n\tefree(stylearr);\n\n\tRETURN_TRUE;\n}",
        "output": "1",
        "idx": 347
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tcp_chr_update_read_handler(CharDriverState *chr,\n                                        GMainContext *context,\n                                        int tag)\n{\n    TCPCharDriver *s = chr->opaque;\n\n    if (!s->connected) {\n        return;\n    }\n\n    remove_fd_in_watch(chr);\n    if (s->ioc) {\n        chr->fd_in_tag = io_add_watch_poll(s->ioc,\n                                           tcp_chr_read_poll,\n                                           tcp_chr_read, chr,\n                                           context);\n    }\n}",
        "output": "1",
        "idx": 1827
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "state_separate_contexts (position_set const *s)\n{\n  int separate_contexts = 0;\n  unsigned int j;\n\n  for (j = 0; j < s->nelem; ++j)\n    {\n      if (PREV_NEWLINE_DEPENDENT (s->elems[j].constraint))\n        separate_contexts |= CTX_NEWLINE;\n      if (PREV_LETTER_DEPENDENT (s->elems[j].constraint))\n        separate_contexts |= CTX_LETTER;\n    }\n\n  return separate_contexts;\n}",
        "output": "1",
        "idx": 3171
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int spl_filesystem_file_read_line(zval * this_ptr, spl_filesystem_object *intern, int silent TSRMLS_DC) /* {{{ */\n{\n\tint ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);\n\n\twhile (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY) && ret == SUCCESS && spl_filesystem_file_is_empty_line(intern TSRMLS_CC)) {\n\t\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\t\tret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);\n\t}\n\t\n\treturn ret;\n}",
        "output": "1",
        "idx": 1814
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "poolCopyString(STRING_POOL *pool, const XML_Char *s) {\n  do {\n    if (! poolAppendChar(pool, *s))\n      return NULL;\n  } while (*s++);\n  s = pool->start;\n  poolFinish(pool);\n  return s;\n}",
        "output": "0",
        "idx": 3052
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "doc_var_value(gqlDoc doc, const char *key) {\n    gqlVar\tvar;\n\n    // look in doc->vars and doc->op->vars\n    if (NULL != doc->op) {\n\tfor (var = doc->op->vars; NULL != var; var = var->next) {\n\t    if (0 == strcmp(key, var->name)) {\n\t\treturn var->value;\n\t    }\n\t}\n    }\n    for (var = doc->vars; NULL != var; var = var->next) {\n\tif (0 == strcmp(key, var->name)) {\n\t    return var->value;\n\t}\n    }\n    return NULL;\n}",
        "output": "0",
        "idx": 775
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool is_seccomp_available(void) {\n        static int cached_enabled = -1;\n\n        if (cached_enabled < 0)\n                cached_enabled =\n                        is_basic_seccomp_available() &&\n                        is_seccomp_filter_available();\n\n        return cached_enabled;\n}",
        "output": "0",
        "idx": 2629
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline char *tok_text_buf(struct Token *t)\n{\n    return (t->len <= INLINE_TEXT) ? t->text.a : t->text.p.ptr;\n}",
        "output": "0",
        "idx": 272
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    size_t overrun(size_t itemSize, size_t nItems, bool wait) { throw EndOfStream(); }",
        "output": "0",
        "idx": 3691
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "INST_HANDLER (sts) {\t// STS k, Rr\n\tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tint k = (buf[3] << 8) | buf[2];\n\top->ptr = k;\n\n\tESIL_A (\"r%d,\", r);\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 1);\n\n\top->cycles = 2;\n}",
        "output": "1",
        "idx": 1196
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "find_lively_task_by_vpid(pid_t vpid)\n{\n\tstruct task_struct *task;\n\tint err;\n\n\trcu_read_lock();\n\tif (!vpid)\n\t\ttask = current;\n\telse\n\t\ttask = find_task_by_vpid(vpid);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\n\tif (!task)\n\t\treturn ERR_PTR(-ESRCH);\n\n\t/* Reuse ptrace permission checks for now. */\n\terr = -EACCES;\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS))\n\t\tgoto errout;\n\n\treturn task;\nerrout:\n\tput_task_struct(task);\n\treturn ERR_PTR(err);\n\n}",
        "output": "1",
        "idx": 637
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rtadv_prefix_lookup (struct list *rplist, struct prefix_ipv6 *p)\n{\n  struct listnode *node;\n  struct rtadv_prefix *rprefix;\n\n  for (ALL_LIST_ELEMENTS_RO (rplist, node, rprefix))\n    if (prefix_same ((struct prefix *) &rprefix->prefix, (struct prefix *) p))\n      return rprefix;\n  return NULL;\n}",
        "output": "0",
        "idx": 3390
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "win_alloc_firstwin(win_T *oldwin)\n{\n    curwin = win_alloc(NULL, FALSE);\n    if (oldwin == NULL)\n    {\n\t/* Very first window, need to create an empty buffer for it and\n\t * initialize from scratch. */\n\tcurbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);\n\tif (curwin == NULL || curbuf == NULL)\n\t    return FAIL;\n\tcurwin->w_buffer = curbuf;\n#ifdef FEAT_SYN_HL\n\tcurwin->w_s = &(curbuf->b_s);\n#endif\n\tcurbuf->b_nwindows = 1;\t/* there is one window */\n\tcurwin->w_alist = &global_alist;\n\tcurwin_init();\t\t/* init current window */\n    }\n    else\n    {\n\t/* First window in new tab page, initialize it from \"oldwin\". */\n\twin_init(curwin, oldwin, 0);\n\n\t/* We don't want cursor- and scroll-binding in the first window. */\n\tRESET_BINDING(curwin);\n    }\n\n    new_frame(curwin);\n    if (curwin->w_frame == NULL)\n\treturn FAIL;\n    topframe = curwin->w_frame;\n    topframe->fr_width = Columns;\n    topframe->fr_height = Rows - p_ch;\n\n    return OK;\n}",
        "output": "0",
        "idx": 1590
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sig_chatnet_destroyed(IRC_CHATNET_REC *rec)\n{\n\tif (IS_IRC_CHATNET(rec))\n                g_free(rec->usermode);\n}",
        "output": "1",
        "idx": 1800
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xfs_alloc_compute_maxlevels(\n\txfs_mount_t\t*mp)\t/* file system mount structure */\n{\n\tmp->m_ag_maxlevels = xfs_btree_compute_maxlevels(mp->m_alloc_mnr,\n\t\t\t(mp->m_sb.sb_agblocks + 1) / 2);\n}",
        "output": "0",
        "idx": 2035
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int decode_attr_time_modify(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec64 *time)\n{\n\tint status = 0;\n\n\ttime->tv_sec = 0;\n\ttime->tv_nsec = 0;\n\tif (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_MODIFY - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[1] & FATTR4_WORD1_TIME_MODIFY)) {\n\t\tstatus = decode_attr_time(xdr, time);\n\t\tif (status == 0)\n\t\t\tstatus = NFS_ATTR_FATTR_MTIME;\n\t\tbitmap[1] &= ~FATTR4_WORD1_TIME_MODIFY;\n\t}\n\tdprintk(\"%s: mtime=%lld\\n\", __func__, time->tv_sec);\n\treturn status;\n}",
        "output": "0",
        "idx": 2644
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n{\n  size_t alloc = (inlength?(size_t)inlength:strlen(string))+1;\n  char *ns;\n  char *testing_ptr = NULL;\n  unsigned char in; /* we need to treat the characters unsigned */\n  size_t newlen = alloc;\n  int strindex=0;\n  size_t length;\n  CURLcode res;\n\n  ns = malloc(alloc);\n  if(!ns)\n    return NULL;\n\n  length = alloc-1;\n  while(length--) {\n    in = *string;\n\n    if(Curl_isunreserved(in))\n      /* just copy this */\n      ns[strindex++]=in;\n    else {\n      /* encode it */\n      newlen += 2; /* the size grows with two, since this'll become a %XX */\n      if(newlen > alloc) {\n        alloc *= 2;\n        testing_ptr = realloc(ns, alloc);\n        if(!testing_ptr) {\n          free( ns );\n          return NULL;\n        }\n        else {\n          ns = testing_ptr;\n        }\n      }\n\n      res = Curl_convert_to_network(handle, &in, 1);\n      if(res) {\n        /* Curl_convert_to_network calls failf if unsuccessful */\n        free(ns);\n        return NULL;\n      }\n\n      snprintf(&ns[strindex], 4, \"%%%02X\", in);\n\n      strindex+=3;\n    }\n    string++;\n  }\n  ns[strindex]=0; /* terminate it */\n  return ns;\n}",
        "output": "1",
        "idx": 3059
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *getusername(void)\n{\n\tchar *username = NULL;\n\tstruct passwd *password = getpwuid(getuid());\n\n\tif (password)\n\t\tusername = password->pw_name;\n\treturn username;\n}",
        "output": "1",
        "idx": 2501
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void unix_notinflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\tif(s) {\n\t\tatomic_dec(&unix_sk(s)->inflight);\n\t\tatomic_dec(&unix_tot_inflight);\n\t}\n}",
        "output": "1",
        "idx": 1324
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char *cmd_audit_engine(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = _dcfg;\n\n    if (strcasecmp(p1, \"On\") == 0) dcfg->auditlog_flag = AUDITLOG_ON;\n    else\n        if (strcasecmp(p1, \"Off\") == 0) dcfg->auditlog_flag = AUDITLOG_OFF;\n        else\n            if (strcasecmp(p1, \"RelevantOnly\") == 0) dcfg->auditlog_flag = AUDITLOG_RELEVANT;\n            else\n                return (const char *)apr_psprintf(cmd->pool,\n                        \"ModSecurity: Unrecognised parameter value for SecAuditEngine: %s\", p1);\n\n    return NULL;\n}",
        "output": "0",
        "idx": 73
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int get_evtchn_to_irq(evtchn_port_t evtchn)\n{\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -1;\n\tif (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)\n\t\treturn -1;\n\treturn evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)];\n}",
        "output": "1",
        "idx": 1521
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ieee80211_sta_block_awake(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_sta *pubsta, bool block)\n{\n\tstruct sta_info *sta = container_of(pubsta, struct sta_info, sta);\n\n\ttrace_api_sta_block_awake(sta->local, pubsta, block);\n\n\tif (block)\n\t\tset_sta_flag(sta, WLAN_STA_PS_DRIVER);\n\telse if (test_sta_flag(sta, WLAN_STA_PS_DRIVER))\n\t\tieee80211_queue_work(hw, &sta->drv_unblock_wk);\n}",
        "output": "0",
        "idx": 300
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main(int argc, char* argv[])\n{\n    whoami = QUtil::getWhoami(argv[0]);\n\n    // For libtool's sake....\n    if (strncmp(whoami, \"lt-\", 3) == 0)\n    {\n\twhoami += 3;\n    }\n\n    if (argc != 3)\n    {\n\tusage();\n    }\n    char const* filename = argv[1];\n    int pageno = QUtil::string_to_int(argv[2]);\n\n    try\n    {\n\tQPDF pdf;\n\tpdf.processFile(filename);\n        std::vector<QPDFPageObjectHelper> pages =\n            QPDFPageDocumentHelper(pdf).getAllPages();\n        if ((pageno < 1) || (static_cast<size_t>(pageno) > pages.size()))\n        {\n            usage();\n        }\n\n        QPDFPageObjectHelper& page = pages.at(pageno-1);\n        ParserCallbacks cb;\n        page.parsePageContents(&cb);\n    }\n    catch (std::exception& e)\n    {\n\tstd::cerr << whoami << \": \" << e.what() << std::endl;\n\texit(2);\n    }\n\n    return 0;\n}",
        "output": "1",
        "idx": 3147
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline bool SegmentReader::containsInterval(const void* from, const void* to) {\n  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&\n      readLimiter->canRead(\n          intervalLength(reinterpret_cast<const byte*>(from),\n                         reinterpret_cast<const byte*>(to),\n                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)\n              / BYTES_PER_WORD,\n          arena);\n}",
        "output": "1",
        "idx": 395
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "g_socket_client_connect_async (GSocketClient       *client,\n\t\t\t       GSocketConnectable  *connectable,\n\t\t\t       GCancellable        *cancellable,\n\t\t\t       GAsyncReadyCallback  callback,\n\t\t\t       gpointer             user_data)\n{\n  GSocketClientAsyncConnectData *data;\n\n  g_return_if_fail (G_IS_SOCKET_CLIENT (client));\n\n  data = g_slice_new0 (GSocketClientAsyncConnectData);\n  data->client = client;\n  data->connectable = g_object_ref (connectable);\n\n  if (can_use_proxy (client))\n    {\n      data->enumerator = g_socket_connectable_proxy_enumerate (connectable);\n      if (client->priv->proxy_resolver &&\n          G_IS_PROXY_ADDRESS_ENUMERATOR (data->enumerator))\n        {\n          g_object_set (G_OBJECT (data->enumerator),\n                        \"proxy-resolver\", client->priv->proxy_resolver,\n                        NULL);\n        }\n    }\n  else\n    data->enumerator = g_socket_connectable_enumerate (connectable);\n\n  data->task = g_task_new (client, cancellable, callback, user_data);\n  g_task_set_source_tag (data->task, g_socket_client_connect_async);\n  g_task_set_task_data (data->task, data, (GDestroyNotify)g_socket_client_async_connect_data_free);\n\n  enumerator_next_async (data);\n}",
        "output": "1",
        "idx": 858
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct resource_pool *dcn10_create_resource_pool(\n\t\tconst struct dc_init_data *init_data,\n\t\tstruct dc *dc)\n{\n\tstruct dcn10_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(init_data->num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "output": "1",
        "idx": 1752
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "crm_trigger_prepare(GSource * source, gint * timeout)\n{\n    crm_trigger_t *trig = (crm_trigger_t *) source;\n\n    /* cluster-glue's FD and IPC related sources make use of\n     * g_source_add_poll() but do not set a timeout in their prepare\n     * functions\n     *\n     * This means mainloop's poll() will block until an event for one\n     * of these sources occurs - any /other/ type of source, such as\n     * this one or g_idle_*, that doesn't use g_source_add_poll() is\n     * S-O-L and wont be processed until there is something fd-based\n     * happens.\n     *\n     * Luckily the timeout we can set here affects all sources and\n     * puts an upper limit on how long poll() can take.\n     *\n     * So unconditionally set a small-ish timeout, not too small that\n     * we're in constant motion, which will act as an upper bound on\n     * how long the signal handling might be delayed for.\n     */\n    *timeout = 500;             /* Timeout in ms */\n\n    return trig->trigger;\n}",
        "output": "0",
        "idx": 144
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ext4_data_block_valid_rcu(struct ext4_sb_info *sbi,\n\t\t\t\t     struct ext4_system_blocks *system_blks,\n\t\t\t\t     ext4_fsblk_t start_blk,\n\t\t\t\t     unsigned int count)\n{\n\tstruct ext4_system_zone *entry;\n\tstruct rb_node *n;\n\n\tif ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||\n\t    (start_blk + count < start_blk) ||\n\t    (start_blk + count > ext4_blocks_count(sbi->s_es)))\n\t\treturn 0;\n\n\tif (system_blks == NULL)\n\t\treturn 1;\n\n\tn = system_blks->root.rb_node;\n\twhile (n) {\n\t\tentry = rb_entry(n, struct ext4_system_zone, node);\n\t\tif (start_blk + count - 1 < entry->start_blk)\n\t\t\tn = n->rb_left;\n\t\telse if (start_blk >= (entry->start_blk + entry->count))\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
        "output": "1",
        "idx": 1500
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "do_tabs(int *tab_list)\n{\n    int last = 1;\n    int stop;\n\n    putchar('\\r');\n    while ((stop = *tab_list++) > 0) {\n\tif (last < stop) {\n\t    while (last++ < stop) {\n\t\tif (last > max_cols)\n\t\t    break;\n\t\tputchar(' ');\n\t    }\n\t}\n\tif (stop <= max_cols) {\n\t    tputs(tparm(set_tab, stop), 1, putch);\n\t    last = stop;\n\t} else {\n\t    break;\n\t}\n    }\n    putchar('\\r');\n}",
        "output": "1",
        "idx": 307
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {\n    long pid;\n    NTSTATUS status;\n    HANDLE hProcess;\n    PyObject* suspend;\n\n    if (! PyArg_ParseTuple(args, \"lO\", &pid, &suspend))\n        return NULL;\n\n    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);\n    if (hProcess == NULL)\n        return NULL;\n\n    if (PyObject_IsTrue(suspend))\n        status = psutil_NtSuspendProcess(hProcess);\n    else\n        status = psutil_NtResumeProcess(hProcess);\n\n    if (! NT_SUCCESS(status)) {\n        CloseHandle(hProcess);\n        return psutil_SetFromNTStatusErr(status, \"NtSuspend|ResumeProcess\");\n    }\n\n    CloseHandle(hProcess);\n    Py_RETURN_NONE;\n}",
        "output": "0",
        "idx": 3515
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "file_info_cancel (NautilusDirectory *directory)\n{\n\tif (directory->details->get_info_in_progress != NULL) {\n\t\tg_cancellable_cancel (directory->details->get_info_in_progress->cancellable);\n\t\tdirectory->details->get_info_in_progress->directory = NULL;\n\t\tdirectory->details->get_info_in_progress = NULL;\n\t\tdirectory->details->get_info_file = NULL;\n\n\t\tasync_job_end (directory, \"file info\");\n\t}\n}",
        "output": "0",
        "idx": 849
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "line_count_info(\n    char_u\t*line,\n    varnumber_T\t*wc,\n    varnumber_T\t*cc,\n    varnumber_T\tlimit,\n    int\t\teol_size)\n{\n    varnumber_T\ti;\n    varnumber_T\twords = 0;\n    varnumber_T\tchars = 0;\n    int\t\tis_word = 0;\n\n    for (i = 0; i < limit && line[i] != NUL; )\n    {\n\tif (is_word)\n\t{\n\t    if (vim_isspace(line[i]))\n\t    {\n\t\twords++;\n\t\tis_word = 0;\n\t    }\n\t}\n\telse if (!vim_isspace(line[i]))\n\t    is_word = 1;\n\t++chars;\n\ti += (*mb_ptr2len)(line + i);\n    }\n\n    if (is_word)\n\twords++;\n    *wc += words;\n\n    // Add eol_size if the end of line was reached before hitting limit.\n    if (i < limit && line[i] == NUL)\n    {\n\ti += eol_size;\n\tchars += eol_size;\n    }\n    *cc += chars;\n    return i;\n}",
        "output": "0",
        "idx": 1145
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "onig_callout_tag_is_exist_at_callout_num(regex_t* reg, int callout_num)\n{\n  RegexExt* ext = REG_EXTP(reg);\n\n  if (IS_NULL(ext) || IS_NULL(ext->callout_list)) return 0;\n  if (callout_num > ext->callout_num) return 0;\n\n  return (ext->callout_list[callout_num].flag &\n          CALLOUT_TAG_LIST_FLAG_TAG_EXIST) != 0  ? 1 : 0;\n}",
        "output": "0",
        "idx": 2200
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "u8 bnx2x_link_test(struct bnx2x *bp, u8 is_serdes)\n{\n\tu8 rc = 0;\n\n\tif (!BP_NOMCP(bp)) {\n\t\tbnx2x_acquire_phy_lock(bp);\n\t\trc = bnx2x_test_link(&bp->link_params, &bp->link_vars,\n\t\t\t\t     is_serdes);\n\t\tbnx2x_release_phy_lock(bp);\n\t} else\n\t\tBNX2X_ERR(\"Bootcode is missing - can not test link\\n\");\n\n\treturn rc;\n}",
        "output": "0",
        "idx": 1151
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Mounter::umount(const QString &mountPoint, int pid)\n{\n    if (calledFromDBus()) {\n        registerPid(pid);\n    }\n\n    if (mpOk(mountPoint)) {\n        QProcess *proc=new QProcess(this);\n        connect(proc, SIGNAL(finished(int)), SLOT(umountResult(int)));\n        proc->start(\"umount\", QStringList() << mountPoint);\n        proc->setProperty(\"mp\", mountPoint);\n        proc->setProperty(\"pid\", pid);\n        procCount++;\n    } else {\n        emit umountStatus(mountPoint, pid, -1);\n    }\n}",
        "output": "1",
        "idx": 786
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fr_window_set_batch__extract_here (FrWindow *window,\n\t\t\t\t   GFile    *archive)\n{\n\tg_return_if_fail (window != NULL);\n\tg_return_if_fail (archive != NULL);\n\n\tfr_window_append_batch_action (window,\n\t\t\t\t       FR_BATCH_ACTION_LOAD,\n\t\t\t\t       g_object_ref (archive),\n\t\t\t\t       (GFreeFunc) g_object_unref);\n\tfr_window_append_batch_action (window,\n\t\t\t\t       FR_BATCH_ACTION_EXTRACT_HERE,\n\t\t\t\t       extract_to_data_new (window, NULL),\n\t\t\t\t       (GFreeFunc) extract_data_free);\n\tfr_window_append_batch_action (window,\n\t\t\t\t       FR_BATCH_ACTION_CLOSE,\n\t\t\t\t       NULL,\n\t\t\t\t       NULL);\n}",
        "output": "0",
        "idx": 409
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int DCTStream::getChars(int nChars, unsigned char *buffer)\n{\n    for (int i = 0; i < nChars;) {\n        if (current == limit) {\n            if (!readLine())\n                return i;\n        }\n        int left = limit - current;\n        if (nChars < left)\n            left = nChars;\n        memcpy(buffer + i, current, left);\n        current += left;\n        i += left;\n    }\n    return nChars;\n}",
        "output": "1",
        "idx": 1804
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g) {\n    if(!p || !g) /* q is optional */\n        return 0;\n    BN_free(dh->p);\n    BN_free(dh->q);\n    BN_free(dh->g);\n    dh->p = p;\n    dh->q = q;\n    dh->g = g;\n    if(q)\n        dh->length = BN_num_bits(q);\n    return 1;\n}",
        "output": "1",
        "idx": 3027
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "INLINE void gdi_RectToCRgn(const HGDI_RECT rect, INT32* x, INT32* y, INT32* w, INT32* h)\n{\n\t*x = rect->left;\n\t*y = rect->top;\n\t*w = rect->right - rect->left + 1;\n\t*h = rect->bottom - rect->top + 1;\n}",
        "output": "1",
        "idx": 2783
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\tspl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);\n\t\n\tobject->u.dir.index++;\n\tdo {\n\t\tspl_filesystem_dir_read(object TSRMLS_CC);\n\t} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));\n\tif (object->file_name) {\n\t\tefree(object->file_name);\n\t\tobject->file_name = NULL;\n\t}\n\tif (iterator->current) {\n\t\tzval_ptr_dtor(&iterator->current);\n\t\titerator->current = NULL;\n\t}\n}",
        "output": "1",
        "idx": 1306
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int lgff_init(struct hid_device* hid)\n{\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tconst signed short *ff_bits = ff_joystick;\n\tint error;\n\tint i;\n\n\t/* Check that the report looks ok */\n\tif (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < ARRAY_SIZE(devices); i++) {\n\t\tif (dev->id.vendor == devices[i].idVendor &&\n\t\t    dev->id.product == devices[i].idProduct) {\n\t\t\tff_bits = devices[i].ff;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; ff_bits[i] >= 0; i++)\n\t\tset_bit(ff_bits[i], dev->ffbit);\n\n\terror = input_ff_create_memless(dev, NULL, hid_lgff_play);\n\tif (error)\n\t\treturn error;\n\n\tif ( test_bit(FF_AUTOCENTER, dev->ffbit) )\n\t\tdev->ff->set_autocenter = hid_lgff_set_autocenter;\n\n\tpr_info(\"Force feedback for Logitech force feedback devices by Johann Deneux <johann.deneux@it.uu.se>\\n\");\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 373
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "wkbReadInt(wkbObj *w)\n{\n  int i;\n  memcpy(&i, w->ptr, sizeof(int));\n  w->ptr += sizeof(int);\n  return i;\n}",
        "output": "0",
        "idx": 1920
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rxrpc_destroy(struct key *key)\n{\n\trxrpc_free_token_list(key->payload.data[0]);\n}",
        "output": "0",
        "idx": 1455
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void php_hash_string_xor(unsigned char *out, const unsigned char *in, const unsigned char *xor_with, const int length) {\n\tint i;\n\tfor (i=0; i < length; i++) {\n\t\tout[i] = in[i] ^ xor_with[i];\n\t}\n}",
        "output": "0",
        "idx": 1305
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ti_vread_sync(struct usb_device *dev, __u8 request,\n\t\t\t\t__u16 value, __u16 index, u8 *data, int size)\n{\n\tint status;\n\n\tstatus = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), request,\n\t\t\t(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN),\n\t\t\tvalue, index, data, size, 1000);\n\tif (status < 0)\n\t\treturn status;\n\tif (status != size) {\n\t\tdev_dbg(&dev->dev, \"%s - wanted to write %d, but only wrote %d\\n\",\n\t\t\t__func__, size, status);\n\t\treturn -ECOMM;\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 2193
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int decode_studiovisualobject(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    int visual_object_type;\n\n        skip_bits(gb, 4); /* visual_object_verid */\n        visual_object_type = get_bits(gb, 4);\n        if (visual_object_type != VOT_VIDEO_ID) {\n            avpriv_request_sample(s->avctx, \"VO type %u\", visual_object_type);\n            return AVERROR_PATCHWELCOME;\n        }\n\n        next_start_code_studio(gb);\n        extension_and_user_data(s, gb, 1);\n\n    return 0;\n}",
        "output": "0",
        "idx": 1676
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool chopOffDotted(string &domain)\n{\n  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))\n    return false;\n\n  string::size_type fdot=domain.find('.');\n  if(fdot == string::npos)\n    return false;\n\n  if(fdot==domain.size()-1) \n    domain=\".\";\n  else  {\n    string::size_type remain = domain.length() - (fdot + 1);\n    char tmp[remain];\n    memcpy(tmp, domain.c_str()+fdot+1, remain);\n    domain.assign(tmp, remain);\n  }\n  return true;\n}",
        "output": "1",
        "idx": 2845
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_handle_set_base_uri (RsvgHandle * handle, const char *base_uri)\n{\n    gchar *uri;\n\n    g_return_if_fail (handle != NULL);\n\n    if (base_uri == NULL)\n\treturn;\n\n    if (rsvg_path_is_uri (base_uri)) \n        uri = g_strdup (base_uri);\n    else\n        uri = rsvg_get_base_uri_from_filename (base_uri);\n\n    if (uri) {\n        if (handle->priv->base_uri)\n            g_free (handle->priv->base_uri);\n        handle->priv->base_uri = uri;\n        rsvg_defs_set_base_uri (handle->priv->defs, handle->priv->base_uri);\n    }\n}",
        "output": "0",
        "idx": 148
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tight_pack24(VncState *vs, uint8_t *buf, size_t count, size_t *ret)\n{\n    uint32_t *buf32;\n    uint32_t pix;\n    int rshift, gshift, bshift;\n\n    buf32 = (uint32_t *)buf;\n\n    if ((vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG) ==\n        (vs->ds->surface->flags & QEMU_BIG_ENDIAN_FLAG)) {\n        rshift = vs->clientds.pf.rshift;\n        gshift = vs->clientds.pf.gshift;\n        bshift = vs->clientds.pf.bshift;\n    } else {\n        rshift = 24 - vs->clientds.pf.rshift;\n        gshift = 24 - vs->clientds.pf.gshift;\n        bshift = 24 - vs->clientds.pf.bshift;\n    }\n\n    if (ret) {\n        *ret = count * 3;\n    }\n\n    while (count--) {\n        pix = *buf32++;\n        *buf++ = (char)(pix >> rshift);\n        *buf++ = (char)(pix >> gshift);\n        *buf++ = (char)(pix >> bshift);\n    }\n}",
        "output": "1",
        "idx": 2801
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)\n{\n  do\n  {\n    mutt_extract_token (buf, s, 0);\n    /*\n     * Check for deletion of entire list\n     */\n    if (mutt_strcmp (buf->data, \"*\") == 0)\n    {\n      mutt_free_list ((LIST **) data);\n      break;\n    }\n    remove_from_list ((LIST **) data, buf->data);\n  }\n  while (MoreArgs (s));\n\n  return 0;\n}",
        "output": "0",
        "idx": 2473
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ConnectionImpl::releaseOutboundFrame(const Buffer::OwnedBufferFragmentImpl* fragment) {\n  ASSERT(outbound_frames_ >= 1);\n  --outbound_frames_;\n  delete fragment;\n}",
        "output": "1",
        "idx": 3024
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "size_t _q_urldecode(char *str)\n{\n    if (str == NULL) {\n        return 0;\n    }\n\n    char *pEncPt, *pBinPt = str;\n    for (pEncPt = str; *pEncPt != '\\0'; pEncPt++) {\n        switch (*pEncPt) {\n            case '+': {\n                *pBinPt++ = ' ';\n                break;\n            }\n            case '%': {\n                *pBinPt++ = _q_x2c(*(pEncPt + 1), *(pEncPt + 2));\n                pEncPt += 2;\n                break;\n            }\n            default: {\n                *pBinPt++ = *pEncPt;\n                break;\n            }\n        }\n    }\n    *pBinPt = '\\0';\n\n    return (pBinPt - str);\n}",
        "output": "1",
        "idx": 3660
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "UsbHubCtrlGetSuperSpeedHubDesc (\r\n  IN  USB_DEVICE          *HubDev,\r\n  OUT VOID                *Buf\r\n  )\r\n{\r\n  EFI_STATUS              Status;\r\n  \r\n  Status = EFI_INVALID_PARAMETER;\r\n  \r\n  Status = UsbCtrlRequest (\r\n             HubDev,\r\n             EfiUsbDataIn,\r\n             USB_REQ_TYPE_CLASS,\r\n             USB_HUB_TARGET_HUB,\r\n             USB_HUB_REQ_GET_DESC,\r\n             (UINT16) (USB_DESC_TYPE_HUB_SUPER_SPEED << 8),\r\n             0,\r\n             Buf,\r\n             32\r\n             );\r\n\r\n  return Status;\r\n}\r",
        "output": "1",
        "idx": 2088
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "add_update_var_type(regex_t* reg, enum UpdateVarType type)\n{\n  UpdateVarType t = (UpdateVarType )type;\n\n  BB_ADD(reg, &t, SIZE_UPDATE_VAR_TYPE);\n  return 0;\n}",
        "output": "0",
        "idx": 871
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct nfsd4_copy *nfsd4_get_copy(struct nfs4_client *clp)\n{\n\tstruct nfsd4_copy *copy = NULL;\n\n\tspin_lock(&clp->async_lock);\n\tif (!list_empty(&clp->async_copies)) {\n\t\tcopy = list_first_entry(&clp->async_copies, struct nfsd4_copy,\n\t\t\t\t\tcopies);\n\t\trefcount_inc(&copy->refcount);\n\t}\n\tspin_unlock(&clp->async_lock);\n\treturn copy;\n}",
        "output": "0",
        "idx": 2154
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rtl8xxxu_submit_int_urb(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct urb *urb;\n\tu32 val32;\n\tint ret;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tusb_fill_int_urb(urb, priv->udev, priv->pipe_interrupt,\n\t\t\t priv->int_buf, USB_INTR_CONTENT_LENGTH,\n\t\t\t rtl8xxxu_int_complete, priv, 1);\n\tusb_anchor_urb(urb, &priv->int_anchor);\n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret) {\n\t\tusb_unanchor_urb(urb);\n\t\tgoto error;\n\t}\n\n\tval32 = rtl8xxxu_read32(priv, REG_USB_HIMR);\n\tval32 |= USB_HIMR_CPWM;\n\trtl8xxxu_write32(priv, REG_USB_HIMR, val32);\n\nerror:\n\treturn ret;\n}",
        "output": "1",
        "idx": 668
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    return AVERROR(ENOSYS);\n}",
        "output": "1",
        "idx": 1538
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void ConvertLuvToXYZ(const double L,const double u,const double v,\n  double *X,double *Y,double *Z)\n{\n  double\n    gamma;\n\n  assert(X != (double *) NULL);\n  assert(Y != (double *) NULL);\n  assert(Z != (double *) NULL);\n  if (L > (CIEK*CIEEpsilon))\n    *Y=(double) pow((L+16.0)/116.0,3.0);\n  else\n    *Y=L/CIEK;\n  gamma=PerceptibleReciprocal((((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+\n    3.0*D65Z))))-1.0)/3.0)-(-1.0/3.0));\n  *X=gamma*((*Y*((39.0*L/(v+13.0*L*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+\n    5.0*(*Y));\n  *Z=(*X*(((52.0f*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-\n    5.0*(*Y);\n}",
        "output": "1",
        "idx": 966
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int racls_del_cb(void *rock,\n                  const char *key, size_t keylen,\n                  const char *data __attribute__((unused)),\n                  size_t datalen __attribute__((unused)))\n{\n    struct txn **txn = (struct txn **)rock;\n    return cyrusdb_delete(mbdb, key, keylen, txn, /*force*/0);\n}",
        "output": "0",
        "idx": 1890
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "proto_tree_add_boolean_format(proto_tree *tree, int hfindex, tvbuff_t *tvb,\n\t\t\t      gint start, gint length, guint32 value,\n\t\t\t      const char *format, ...)\n{\n\tproto_item\t  *pi;\n\tva_list\t\t   ap;\n\n\tpi = proto_tree_add_boolean(tree, hfindex, tvb, start, length, value);\n\tif (pi != tree) {\n\t\tTRY_TO_FAKE_THIS_REPR(pi);\n\n\t\tva_start(ap, format);\n\t\tproto_tree_set_representation(pi, format, ap);\n\t\tva_end(ap);\n\t}\n\n\treturn pi;\n}",
        "output": "0",
        "idx": 2123
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) {\n    MOBIIndexEntry e = indx->entries[i];\n    char *inflected = e.label;\n    for (size_t j = 0; j < e.tags_count; j++) {\n        MOBIIndexTag t = e.tags[j];\n        if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) {\n            for (size_t k = 0; k < t.tagvalues_count - 1; k += 2) {\n                uint32_t len = t.tagvalues[k];\n                uint32_t offset = t.tagvalues[k + 1];\n                char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len);\n                if (base == NULL) {\n                    return MOBI_MALLOC_FAILED;\n                }\n                MOBI_RET ret = mobi_trie_insert_reversed(root, base, inflected);\n                free(base);\n                if (ret != MOBI_SUCCESS) {\n                    return ret;\n                }\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}",
        "output": "1",
        "idx": 2030
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void HGraphBuilder::GenerateIsConstructCall(CallRuntime* call) {\n  ASSERT(call->arguments()->length() == 0);\n  if (function_state()->outer() != NULL) {\n    // We are generating graph for inlined function.\n    HValue* value = function_state()->inlining_kind() == CONSTRUCT_CALL_RETURN\n        ? graph()->GetConstantTrue()\n        : graph()->GetConstantFalse();\n    return ast_context()->ReturnValue(value);\n  } else {\n    return ast_context()->ReturnControl(new(zone()) HIsConstructCallAndBranch,\n                                        call->id());\n  }\n}",
        "output": "0",
        "idx": 1373
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void SetHeaderFromIPL(Image *image, IPLInfo *ipl){\n  image->columns = ipl->width;\n  image->rows = ipl->height;\n  image->depth = ipl->depth;\n  image->x_resolution = 1;\n  image->y_resolution = 1;\n}",
        "output": "0",
        "idx": 1879
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TPM_CAP_Unmarshal(TPM_CAP *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = UINT32_Unmarshal(target, buffer, size);  \n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tswitch (*target) {\n\t  case TPM_CAP_ALGS:\n\t  case TPM_CAP_HANDLES:\n\t  case TPM_CAP_COMMANDS:\n\t  case TPM_CAP_PP_COMMANDS:\n\t  case TPM_CAP_AUDIT_COMMANDS:\n\t  case TPM_CAP_PCRS:\n\t  case TPM_CAP_TPM_PROPERTIES:\n\t  case TPM_CAP_PCR_PROPERTIES:\n\t  case TPM_CAP_ECC_CURVES:\n\t  case TPM_CAP_AUTH_POLICIES:\n\t  case TPM_CAP_ACT:\n\t  case TPM_CAP_VENDOR_PROPERTY:\n\t    break;\n\t  default:\n\t    rc = TPM_RC_VALUE;\n\t}\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 2105
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char ** split(const char *arg, const char *delim) {\n  char *copy = dupstr(arg);\n  char **result = NULL;\n  int i = 0;\n\n  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {\n    char **tmp = realloc (result, sizeof *result * (i + 1));\n    if (!tmp && result) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = dupstr(cptr);\n  }\n\n  free(copy);\n\n  if (i) {\n    char **tmp = realloc(result, sizeof *result * (i + 1));\n    if (!tmp) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = NULL;\n  }\n\n  return result;\n}",
        "output": "1",
        "idx": 2025
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "oerr_cert(krb5_context context, krb5_error_code code, X509_STORE_CTX *certctx,\n          const char *msg)\n{\n    int depth = X509_STORE_CTX_get_error_depth(certctx);\n    int err = X509_STORE_CTX_get_error(certctx);\n    const char *errstr = X509_verify_cert_error_string(err);\n\n    return oerr(context, code, _(\"%s (depth %d): %s\"), msg, depth, errstr);\n}",
        "output": "0",
        "idx": 954
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "draw (cairo_t *cr, int width, int height)\n{\n    cairo_set_source_rgb (cr, 0., 0., 0.);\n    cairo_paint (cr);\n\n    cairo_set_source_rgb (cr, 1., 1., 1.);\n    cairo_set_line_width (cr, 1.);\n\n    cairo_pattern_t *p = cairo_pattern_create_linear (0, 0, width, height);\n    cairo_pattern_add_color_stop_rgb (p, 0, 0.99, 1, 1);\n    cairo_pattern_add_color_stop_rgb (p, 1, 1, 1, 1);\n    cairo_set_source (cr, p);\n\n    cairo_move_to (cr, 0.5, -1);\n    for (int i = 0; i < width; i+=3) {\n\tcairo_rel_line_to (cr, 2, 2);\n\tcairo_rel_line_to (cr, 1, -2);\n    }\n\n    cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);\n    cairo_stroke (cr);\n\n    cairo_pattern_destroy(p);\n\n    return CAIRO_TEST_SUCCESS;\n}",
        "output": "0",
        "idx": 2883
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_P(HeaderIntegrationTest, TestVirtualHostAppendHeaderManipulation) {\n  initializeFilter(HeaderMode::Append, false);\n  performRequest(\n      Http::TestRequestHeaderMapImpl{\n          {\":method\", \"GET\"},\n          {\":path\", \"/vhost-only\"},\n          {\":scheme\", \"http\"},\n          {\":authority\", \"vhost-headers.com\"},\n          {\"x-vhost-request\", \"downstream\"},\n          {\"x-vhost-request-remove\", \"downstream\"},\n      },\n      Http::TestRequestHeaderMapImpl{\n          {\":authority\", \"vhost-headers.com\"},\n          {\"x-vhost-request\", \"downstream\"},\n          {\"x-vhost-request\", \"vhost\"},\n          {\":path\", \"/vhost-only\"},\n          {\":method\", \"GET\"},\n      },\n      Http::TestResponseHeaderMapImpl{\n          {\"server\", \"envoy\"},\n          {\"content-length\", \"0\"},\n          {\":status\", \"200\"},\n          {\"x-vhost-response\", \"upstream\"},\n          {\"x-vhost-response-remove\", \"upstream\"},\n      },\n      Http::TestResponseHeaderMapImpl{\n          {\"server\", \"envoy\"},\n          {\"x-vhost-response\", \"upstream\"},\n          {\"x-vhost-response\", \"vhost\"},\n          {\":status\", \"200\"},\n      });\n}",
        "output": "0",
        "idx": 1574
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "stdmac_file(const SMacro *s, Token **params, int nparams)\n{\n    (void)s;\n    (void)params;\n    (void)nparams;\n\n    return make_tok_qstr(NULL, src_get_fname());\n}",
        "output": "0",
        "idx": 845
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void consume_one_event(unsigned cpu,\n\t\t\t      struct evtchn_fifo_control_block *control_block,\n\t\t\t      unsigned priority, unsigned long *ready,\n\t\t\t      bool drop)\n{\n\tstruct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);\n\tuint32_t head;\n\tevtchn_port_t port;\n\tevent_word_t *word;\n\n\thead = q->head[priority];\n\n\t/*\n\t * Reached the tail last time?  Read the new HEAD from the\n\t * control block.\n\t */\n\tif (head == 0) {\n\t\tvirt_rmb(); /* Ensure word is up-to-date before reading head. */\n\t\thead = control_block->head[priority];\n\t}\n\n\tport = head;\n\tword = event_word_from_port(port);\n\thead = clear_linked(word);\n\n\t/*\n\t * If the link is non-zero, there are more events in the\n\t * queue, otherwise the queue is empty.\n\t *\n\t * If the queue is empty, clear this priority from our local\n\t * copy of the ready word.\n\t */\n\tif (head == 0)\n\t\tclear_bit(priority, ready);\n\n\tif (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port)) {\n\t\tif (unlikely(drop))\n\t\t\tpr_warn(\"Dropping pending event for port %u\\n\", port);\n\t\telse\n\t\t\thandle_irq_for_port(port);\n\t}\n\n\tq->head[priority] = head;\n}",
        "output": "1",
        "idx": 2232
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " */\nstatic int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n\n\tif (stack->elements) {\n\t\tfor (i = 0; i < stack->top; i++) {\n\t\t\tif (((st_entry *)stack->elements[i])->data)\t{\n\t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n\t\t\t}\n\t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;",
        "output": "1",
        "idx": 3639
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n\n    /* we have an error following */\n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    reason = malloc((uint64_t)reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n    free(reason);\n}",
        "output": "1",
        "idx": 577
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "g_vfs_backend_dav_finalize (GObject *object)\n{\n  GVfsBackendDav *dav_backend;\n\n  dav_backend = G_VFS_BACKEND_DAV (object);\n\n#ifdef HAVE_AVAHI\n  if (dav_backend->resolver != NULL)\n    {\n      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);\n      g_object_unref (dav_backend->resolver);\n    }\n#endif\n\n  mount_auth_info_free (&(dav_backend->auth_info));\n  \n  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)\n    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);\n}",
        "output": "0",
        "idx": 2588
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bgp_attr_as4_aggregator (struct peer *peer, bgp_size_t length,\n\t\t     struct attr *attr, u_char flag, \n\t\t     as_t *as4_aggregator_as,\n\t\t     struct in_addr *as4_aggregator_addr,\n\t\t     u_char *startp)\n{\n  bgp_size_t total;\n  \n  if (length != 8)\n    {\n      zlog (peer->log, LOG_ERR, \"New Aggregator length is not 8 [%d]\", length);\n      return bgp_attr_malformed (peer, BGP_ATTR_AS4_AGGREGATOR, flag,\n                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,\n                                 NULL, 0);\n    }\n  total = length + (CHECK_FLAG (flag, BGP_ATTR_FLAG_EXTLEN) ? 4 : 3);\n  /* Flags check. */\n  if (bgp_attr_flag_invalid (peer, BGP_ATTR_AS4_AGGREGATOR, flag))\n    return bgp_attr_malformed (peer, BGP_ATTR_AS4_AGGREGATOR, flag,\n                               BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,\n                               startp, total);\n  \n  *as4_aggregator_as = stream_getl (peer->ibuf);\n  as4_aggregator_addr->s_addr = stream_get_ipv4 (peer->ibuf);\n\n  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_AS4_AGGREGATOR);\n\n  return BGP_ATTR_PARSE_PROCEED;\n}",
        "output": "1",
        "idx": 2175
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int modbus_set_slave(modbus_t *ctx, int slave)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return ctx->backend->set_slave(ctx, slave);\n}",
        "output": "0",
        "idx": 331
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void qemu_chr_free_common(CharDriverState *chr)\n{\n    g_free(chr->filename);\n    g_free(chr->label);\n    if (chr->logfd != -1) {\n        close(chr->logfd);\n    }\n    qemu_mutex_destroy(&chr->chr_write_lock);\n    g_free(chr);\n}",
        "output": "1",
        "idx": 631
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_P(Http2CodecImplTest, InvalidHeadersFrame) {\n  initialize();\n\n  EXPECT_THROW(request_encoder_->encodeHeaders(TestRequestHeaderMapImpl{}, true), ServerCodecError);\n  EXPECT_EQ(1, stats_store_.counter(\"http2.rx_messaging_error\").value());\n}",
        "output": "1",
        "idx": 1291
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __init clear_bss(void)\n{\n\tmemset(__bss_start, 0,\n\t       (unsigned long) __bss_stop - (unsigned long) __bss_start);\n}",
        "output": "1",
        "idx": 1731
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void jpeg_init_destination(j_compress_ptr cinfo)\n{\n    VncState *vs = cinfo->client_data;\n    Buffer *buffer = &vs->tight.jpeg;\n\n    cinfo->dest->next_output_byte = (JOCTET *)buffer->buffer + buffer->offset;\n    cinfo->dest->free_in_buffer = (size_t)(buffer->capacity - buffer->offset);\n}",
        "output": "1",
        "idx": 1347
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err paen_Size(GF_Box *s)\n{\n\tGF_Err e;\n\tFDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;\n\n\tif (ptr->blocks_and_symbols) {\n\t\te = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);\n\t\tif (e) return e;\n\t\tptr->size += ptr->blocks_and_symbols->size;\n\t}\n\tif (ptr->FEC_symbol_locations) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);\n\t\tif (e) return e;\n\t\tptr->size += ptr->FEC_symbol_locations->size;\n\t}\n\tif (ptr->File_symbol_locations) {\n\t\te = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);\n\t\tif (e) return e;\n\t\tptr->size += ptr->File_symbol_locations->size;\n\t}\n\n\treturn GF_OK;\n}",
        "output": "0",
        "idx": 2091
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int term_addstr(TERM_WINDOW *window, const char *str)\n{\n\tint len, raw_len;\n\tunichar tmp;\n\tconst char *ptr;\n\n\tif (vcmove) term_move_real();\n\n\tlen = 0;\n\traw_len = strlen(str);\n\n\t/* The string length depends on the terminal encoding */\n\n\tptr = str;\n\n\tif (term_type == TERM_TYPE_UTF8) {\n\t\twhile (*ptr != '\\0') {\n\t\t\ttmp = g_utf8_get_char(ptr);\n\t\t\tlen += unichar_isprint(tmp) ? mk_wcwidth(tmp) : 1;\n\t\t\tptr = g_utf8_next_char(ptr);\n\t\t}\n\t} else\n\t\tlen = raw_len;\n\n        term_printed_text(len);\n\n\t/* Use strlen() here since we need the number of raw bytes */\n\tfwrite(str, 1, raw_len, window->term->out);\n\n\treturn len;\n}",
        "output": "1",
        "idx": 282
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vhost_vsock_common_send_transport_reset(VHostVSockCommon *vvc)\n{\n    VirtQueueElement *elem;\n    VirtQueue *vq = vvc->event_vq;\n    struct virtio_vsock_event event = {\n        .id = cpu_to_le32(VIRTIO_VSOCK_EVENT_TRANSPORT_RESET),\n    };\n\n    elem = virtqueue_pop(vq, sizeof(VirtQueueElement));\n    if (!elem) {\n        error_report(\"vhost-vsock missed transport reset event\");\n        return;\n    }\n\n    if (elem->out_num) {\n        error_report(\"invalid vhost-vsock event virtqueue element with \"\n                     \"out buffers\");\n        goto out;\n    }\n\n    if (iov_from_buf(elem->in_sg, elem->in_num, 0,\n                     &event, sizeof(event)) != sizeof(event)) {\n        error_report(\"vhost-vsock event virtqueue element is too short\");\n        goto out;\n    }\n\n    virtqueue_push(vq, elem, sizeof(event));\n    virtio_notify(VIRTIO_DEVICE(vvc), vq);\n\nout:\n    g_free(elem);\n}",
        "output": "1",
        "idx": 2961
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_error_response(h2_stream *stream, int http_status)\n{\n    if (!h2_stream_is_ready(stream)) {\n        stream->rtmp->http_status = http_status;\n    }\n}",
        "output": "1",
        "idx": 938
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ossl_cipher_block_size(VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n\n    GetCipher(self, ctx);\n\n    return INT2NUM(EVP_CIPHER_CTX_block_size(ctx));\n}",
        "output": "0",
        "idx": 1160
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int pmd_present(pmd_t pmd)\n{\n\treturn pmd_flags(pmd) & _PAGE_PRESENT;\n}",
        "output": "1",
        "idx": 640
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool isConstantExpr(ESTree::Node *node) {\n  // TODO: a little more agressive constant folding.\n  switch (node->getKind()) {\n    case ESTree::NodeKind::StringLiteral:\n    case ESTree::NodeKind::NumericLiteral:\n    case ESTree::NodeKind::NullLiteral:\n    case ESTree::NodeKind::BooleanLiteral:\n      return true;\n    default:\n      return false;\n  }\n}",
        "output": "0",
        "idx": 1905
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  base::WeakPtr<ElectronBrowserHandlerImpl> GetWeakPtr() {\n    return weak_factory_.GetWeakPtr();\n  }",
        "output": "1",
        "idx": 1970
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void p54u_disconnect(struct usb_interface *intf)\n{\n\tstruct ieee80211_hw *dev = usb_get_intfdata(intf);\n\tstruct p54u_priv *priv;\n\n\tif (!dev)\n\t\treturn;\n\n\tpriv = dev->priv;\n\twait_for_completion(&priv->fw_wait_load);\n\tp54_unregister_common(dev);\n\n\tusb_put_dev(interface_to_usbdev(intf));\n\trelease_firmware(priv->fw);\n\tp54_free_common(dev);\n}",
        "output": "1",
        "idx": 2159
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "find_cached_memberref_sig (MonoImage *image, guint32 sig_idx)\n{\n\tgpointer res;\n\n\tmono_loader_lock ();\n\tres = g_hash_table_lookup (image->memberref_signatures, GUINT_TO_POINTER (sig_idx));\n\tmono_loader_unlock ();\n\n\treturn res;\n}",
        "output": "0",
        "idx": 2223
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "yaml_parser_scan_directive_name(yaml_parser_t *parser,\n        yaml_mark_t start_mark, yaml_char_t **name)\n{\n    yaml_string_t string = NULL_STRING;\n\n    if (!STRING_INIT(parser, string, INITIAL_STRING_SIZE)) goto error;\n\n    /* Consume the directive name. */\n\n    if (!CACHE(parser, 1)) goto error;\n\n    while (IS_ALPHA(parser->buffer))\n    {\n        if (!READ(parser, string)) goto error;\n        if (!CACHE(parser, 1)) goto error;\n    }\n\n    /* Check if the name is empty. */\n\n    if (string.start == string.pointer) {\n        yaml_parser_set_scanner_error(parser, \"while scanning a directive\",\n                start_mark, \"could not find expected directive name\");\n        goto error;\n    }\n\n    /* Check for an blank character after the name. */\n\n    if (!IS_BLANKZ(parser->buffer)) {\n        yaml_parser_set_scanner_error(parser, \"while scanning a directive\",\n                start_mark, \"found unexpected non-alphabetical character\");\n        goto error;\n    }\n\n    *name = string.start;\n\n    return 1;\n\nerror:\n    STRING_DEL(parser, string);\n    return 0;\n}",
        "output": "0",
        "idx": 3107
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)\n{\n\tint ret;\n\tstruct inode *inode;\n\n\tlockdep_assert_held(&cgroup_mutex);\n\n\tinode = kernfs_get_inode(sb, cgrp->procs_file.kn);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tret = inode_permission(&init_user_ns, inode, MAY_WRITE);\n\tiput(inode);\n\treturn ret;\n}",
        "output": "0",
        "idx": 3700
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void register_if_needed(h2_mplx *m) \n{\n    if (!m->aborted && !m->is_registered && !h2_iq_empty(m->q)) {\n        apr_status_t status = h2_workers_register(m->workers, m); \n        if (status == APR_SUCCESS) {\n            m->is_registered = 1;\n        }\n        else {\n            ap_log_cerror(APLOG_MARK, APLOG_ERR, status, m->c, APLOGNO(10021)\n                          \"h2_mplx(%ld): register at workers\", m->id);\n        }\n    }\n}",
        "output": "0",
        "idx": 2839
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, setFlags)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &intern->flags) == FAILURE) {\n\t\treturn;\n\t}\n} /* }}} */",
        "output": "0",
        "idx": 2357
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *dev;\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tu32 ext_filter_mask = 0;\n\tu16 min_ifinfo_dump_size = 0;\n\tint hdrlen;\n\n\t/* Same kernel<->userspace interface hack as in rtnl_dump_ifinfo. */\n\thdrlen = nlmsg_len(nlh) < sizeof(struct ifinfomsg) ?\n\t\t sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);\n\n\tif (nlmsg_parse(nlh, hdrlen, tb, IFLA_MAX, ifla_policy) >= 0) {\n\t\tif (tb[IFLA_EXT_MASK])\n\t\t\text_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);\n\t}\n\n\tif (!ext_filter_mask)\n\t\treturn NLMSG_GOODSIZE;\n\t/*\n\t * traverse the list of net devices and compute the minimum\n\t * buffer size based upon the filter mask.\n\t */\n\tlist_for_each_entry(dev, &net->dev_base_head, dev_list) {\n\t\tmin_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,\n\t\t\t\t\t     if_nlmsg_size(dev,\n\t\t\t\t\t\t           ext_filter_mask));\n\t}\n\n\treturn min_ifinfo_dump_size;\n}",
        "output": "0",
        "idx": 2226
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct pending_op *acquire_write(struct external_chrc *chrc,\n\t\t\t\t\tstruct btd_device *device,\n\t\t\t\t\tstruct gatt_db_attribute *attrib,\n\t\t\t\t\tunsigned int id,\n\t\t\t\t\tconst uint8_t *value, size_t len,\n\t\t\t\t\tuint8_t link_type)\n{\n\tstruct pending_op *op;\n\tbool acquiring = !queue_isempty(chrc->pending_writes);\n\n\top = pending_write_new(device, chrc->pending_writes, attrib, id, value,\n\t\t\t\tlen, 0, link_type, false, false);\n\n\tif (acquiring)\n\t\treturn op;\n\n\tif (g_dbus_proxy_method_call(chrc->proxy, \"AcquireWrite\",\n\t\t\t\t\tacquire_write_setup,\n\t\t\t\t\tacquire_write_reply,\n\t\t\t\t\top, NULL))\n\t\treturn op;\n\n\tpending_op_free(op);\n\n\treturn NULL;\n}",
        "output": "1",
        "idx": 3003
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n\n    /* check key, it has to be valid filename and will end up in the\n     * bugzilla */\n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n\n    /* check value of 'basename', it has to be valid non-hidden directory\n     * name */\n    if (strcmp(key, \"basename\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!is_correct_filename(value))\n        {\n            error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                      key, value);\n            return FALSE;\n        }\n    }\n\n    return TRUE;\n}",
        "output": "1",
        "idx": 2711
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dp_packet_ip_checksum_bad(struct dp_packet *p OVS_UNUSED)\n{\n    return false;\n}",
        "output": "0",
        "idx": 3336
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err iods_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 descSize;\n\tchar *desc;\n\tGF_ObjectDescriptorBox *ptr = (GF_ObjectDescriptorBox *)s;\n\n\t//use the OD codec...\n\tdescSize = (u32) (ptr->size);\n\tdesc = (char*)gf_malloc(sizeof(char) * descSize);\n\tif (!desc) return GF_OUT_OF_MEM;\n\n\tgf_bs_read_data(bs, desc, descSize);\n\te = gf_odf_desc_read(desc, descSize, &ptr->descriptor);\n\t//OK, free our desc\n\tgf_free(desc);\n\treturn e;\n}",
        "output": "1",
        "idx": 1772
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int bson_iterator_int_raw( const bson_iterator *i ) {\n    int out;\n    bson_little_endian32( &out, bson_iterator_value( i ) );\n    return out;\n}",
        "output": "0",
        "idx": 2526
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)\n{\tva_list\targptr ;\n\tint\t\tmaxlen ;\n\tchar\t*start ;\n\n\tmaxlen = strlen ((char*) psf->header) ;\n\tstart\t= ((char*) psf->header) + maxlen ;\n\tmaxlen\t= sizeof (psf->header) - maxlen ;\n\n\tva_start (argptr, format) ;\n\tvsnprintf (start, maxlen, format, argptr) ;\n\tva_end (argptr) ;\n\n\t/* Make sure the string is properly terminated. */\n\tstart [maxlen - 1] = 0 ;\n\n\tpsf->headindex = strlen ((char*) psf->header) ;\n\n\treturn ;\n} /* psf_asciiheader_printf */",
        "output": "1",
        "idx": 513
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool get_discovery_client(struct btd_adapter *adapter, const char *owner,\n\t\t\t\tstruct discovery_client **client)\n{\n\tGSList *list = g_slist_find_custom(adapter->discovery_list, owner,\n\t\t\t\t\t\t\t\tcompare_sender);\n\tif (list) {\n\t\t*client = list->data;\n\t\treturn true;\n\t}\n\n\tlist = g_slist_find_custom(adapter->set_filter_list, owner,\n\t\t\t\t\t\t\t\tcompare_sender);\n\tif (list) {\n\t\t*client = list->data;\n\t\treturn false;\n\t}\n\n\t*client = NULL;\n\treturn false;\n}",
        "output": "0",
        "idx": 514
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool unconditional(const struct arpt_arp *arp)\n{\n\tstatic const struct arpt_arp uncond;\n\n\treturn memcmp(arp, &uncond, sizeof(uncond)) == 0;\n}",
        "output": "1",
        "idx": 3236
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "AvahiSServiceTypeBrowser *avahi_s_service_type_browser_new(\n    AvahiServer *server,\n    AvahiIfIndex interface,\n    AvahiProtocol protocol,\n    const char *domain,\n    AvahiLookupFlags flags,\n    AvahiSServiceTypeBrowserCallback callback,\n    void* userdata) {\n        AvahiSServiceTypeBrowser *b;\n\n        b = avahi_s_service_type_browser_prepare(server, interface, protocol, domain, flags, callback, userdata);\n        avahi_s_service_type_browser_start(b);\n\n        return b;\n}",
        "output": "1",
        "idx": 2411
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int fuse_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint err;\n\n\terr = -EIO;\n\tif (is_bad_inode(inode))\n\t\tgoto out;\n\n\terr = fuse_do_readpage(file, page);\n\tfuse_invalidate_atime(inode);\n out:\n\tunlock_page(page);\n\treturn err;\n}",
        "output": "1",
        "idx": 2846
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " */\nstatic inline bool skb_head_is_locked(const struct sk_buff *skb)\n{\n\treturn !skb->head_frag || skb_cloned(skb);",
        "output": "0",
        "idx": 542
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_P(ProtocolIntegrationTest, HeaderAndBodyWireBytesCountDownstream) {\n  // we only care about upstream protocol.\n  if (upstreamProtocol() != Http::CodecType::HTTP2) {\n    return;\n  }\n  useAccessLog(\"%DOWNSTREAM_WIRE_BYTES_SENT% %DOWNSTREAM_WIRE_BYTES_RECEIVED% \"\n               \"%DOWNSTREAM_HEADER_BYTES_SENT% %DOWNSTREAM_HEADER_BYTES_RECEIVED%\");\n  testRouterRequestAndResponseWithBody(100, 100, false);\n  expectDownstreamBytesSentAndReceived(BytesCountExpectation(244, 231, 114, 84),\n                                       BytesCountExpectation(177, 173, 68, 64),\n                                       BytesCountExpectation(111, 113, 8, 8));\n}",
        "output": "0",
        "idx": 983
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "matchCurrentInput(\n\t\tconst InString *input, int pos, const widechar *passInstructions, int passIC) {\n\tint k;\n\tint kk = pos;\n\tfor (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)\n\t\tif (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++])\n\t\t\treturn 0;\n\treturn 1;\n}",
        "output": "1",
        "idx": 3348
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int _hostsock_getpeername(\n    oe_fd_t* sock_,\n    struct oe_sockaddr* addr,\n    oe_socklen_t* addrlen)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    oe_socklen_t addrlen_in = 0;\n\n    oe_errno = 0;\n\n    if (!sock)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (addrlen)\n        addrlen_in = *addrlen;\n\n    if (oe_syscall_getpeername_ocall(\n            &ret,\n            sock->host_fd,\n            (struct oe_sockaddr*)addr,\n            addrlen_in,\n            addrlen) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    return ret;\n}",
        "output": "1",
        "idx": 3216
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool is_physical_fs(const struct statfs *sfs) {\n        return !is_temporary_fs(sfs) && !is_cgroup_fs(sfs);\n}",
        "output": "0",
        "idx": 507
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err trep_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->trackID = gf_bs_read_u32(bs);\n\n\treturn gf_isom_box_array_read(s, bs);\n}",
        "output": "0",
        "idx": 1365
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ClientHttpRequest::handleAdaptationBlock(const Adaptation::Answer &answer)\n{\n    static const auto d = MakeNamedErrorDetail(\"REQMOD_BLOCK\");\n    request->detailError(ERR_ACCESS_DENIED, d);\n    AclMatchedName = answer.ruleId.termedBuf();\n    assert(calloutContext);\n    calloutContext->clientAccessCheckDone(ACCESS_DENIED);\n    AclMatchedName = NULL;\n}",
        "output": "0",
        "idx": 3622
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cmsBool  _cmsReadMediaWhitePoint(cmsCIEXYZ* Dest, cmsHPROFILE hProfile)\n{\n    cmsCIEXYZ* Tag;\n\n    _cmsAssert(Dest != NULL);\n\n    Tag = (cmsCIEXYZ*) cmsReadTag(hProfile, cmsSigMediaWhitePointTag);\n\n    // If no wp, take D50\n    if (Tag == NULL) {\n        *Dest = *cmsD50_XYZ();\n        return TRUE;\n    }\n\n    // V2 display profiles should give D50\n    if (cmsGetEncodedICCversion(hProfile) < 0x4000000) {\n\n        if (cmsGetDeviceClass(hProfile) == cmsSigDisplayClass) {\n            *Dest = *cmsD50_XYZ();\n            return TRUE;\n        }\n    }\n\n    // All seems ok\n    *Dest = *Tag;\n    return TRUE;\n}",
        "output": "0",
        "idx": 2679
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));\n  if (keepinvariant(g)) {  /* must keep invariant? */\n    reallymarkobject(g, v);  /* restore invariant */\n    if (isold(o)) {\n      lua_assert(!isold(v));  /* white object could not be old */\n      setage(v, G_OLD0);  /* restore generational invariant */\n    }\n  }\n  else {  /* sweep phase */\n    lua_assert(issweepphase(g));\n    makewhite(g, o);  /* mark main obj. as white to avoid other barriers */\n  }\n}",
        "output": "1",
        "idx": 963
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *zrle_convert_fb(VncState *vs, int x, int y, int w, int h,\n                             int bpp)\n{\n    Buffer tmp;\n\n    buffer_reset(&vs->zrle.fb);\n    buffer_reserve(&vs->zrle.fb, w * h * bpp + bpp);\n\n    tmp = vs->output;\n    vs->output = vs->zrle.fb;\n\n    vnc_raw_send_framebuffer_update(vs, x, y, w, h);\n\n    vs->zrle.fb = vs->output;\n    vs->output = tmp;\n    return vs->zrle.fb.buffer;\n}",
        "output": "1",
        "idx": 2153
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TPMA_CC_Unmarshal(TPMA_CC *target, BYTE **buffer, INT32 *size)\n{\n    TPM_RC rc = TPM_RC_SUCCESS;\n\n    if (rc == TPM_RC_SUCCESS) {\n\trc = UINT32_Unmarshal((UINT32 *)target, buffer, size); /* libtpms changed */\n    }\n    if (rc == TPM_RC_SUCCESS) {\n\tif (*target & TPMA_CC_reserved) {\n\t    rc = TPM_RC_RESERVED_BITS;\n\t}\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 2919
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hostkey_method_ssh_ecdsa_sig_verify(LIBSSH2_SESSION * session,\n                                    const unsigned char *sig,\n                                    size_t sig_len,\n                                    const unsigned char *m,\n                                    size_t m_len, void **abstract)\n{\n    const unsigned char *r, *s, *p;\n    size_t r_len, s_len;\n    libssh2_ecdsa_ctx *ctx = (libssh2_ecdsa_ctx *) (*abstract);\n\n    (void) session;\n\n    if(sig_len < 35)\n        return -1;\n\n    /* Skip past keyname_len(4) + keyname(19){\"ecdsa-sha2-nistp256\"} + signature_len(4) */\n    p = sig;\n    p += 27;\n\n    r_len = _libssh2_ntohu32(p);\n    p += 4;\n    r = p;\n    p += r_len;\n\n    s_len = _libssh2_ntohu32(p);\n    p += 4;\n    s = p;\n\n    return _libssh2_ecdsa_verify(ctx, r, r_len, s, s_len, m, m_len);\n}",
        "output": "1",
        "idx": 349
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "double Magick::Image::xResolution(void) const\n{\n  return(constImage()->resolution.x);\n}",
        "output": "0",
        "idx": 1220
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void fix_from_value(Derivation dv, const Metadata metadata)\n  {\n    fix_charset_and_length(str_value.charset(), dv, metadata);\n  }",
        "output": "0",
        "idx": 1620
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "detect_mysql_capabilities_for_backup()\n{\n\tif (xtrabackup_incremental) {\n\t\t/* INNODB_CHANGED_PAGES are listed in\n\t\tINFORMATION_SCHEMA.PLUGINS in MariaDB, but\n\t\tFLUSH NO_WRITE_TO_BINLOG CHANGED_PAGE_BITMAPS\n\t\tis not supported for versions below 10.1.6\n\t\t(see MDEV-7472) */\n\t\tif (server_flavor == FLAVOR_MARIADB &&\n\t\t    mysql_server_version < 100106) {\n\t\t\thave_changed_page_bitmaps = false;\n\t\t}\n\t}\n\n\t/* do some sanity checks */\n\tif (opt_galera_info && !have_galera_enabled) {\n\t\tmsg(\"--galera-info is specified on the command \"\n\t\t \t\"line, but the server does not support Galera \"\n\t\t \t\"replication. Ignoring the option.\\n\");\n\t\topt_galera_info = false;\n\t}\n\n\tif (opt_slave_info && have_multi_threaded_slave &&\n\t    !have_gtid_slave && !opt_safe_slave_backup) {\n\t\tmsg(\"The --slave-info option requires GTID enabled or \"\n\t\t\t\"--safe-slave-backup option used for a multi-threaded \"\n\t\t\t\"slave.\\n\");\n\t\treturn(false);\n\t}\n\n\treturn(true);\n}",
        "output": "0",
        "idx": 904
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gs_window_destroy (GSWindow *window)\n{\n        g_return_if_fail (GS_IS_WINDOW (window));\n\n        if (window->priv->lock_pid > 0) {\n                gs_window_dialog_finish (window);\n        }\n\n        remove_popup_dialog_idle (window);\n        remove_command_watches (window);\n        remove_watchdog_timer (window);\n\n        if (window->priv->lock_box != NULL) {\n                gtk_container_remove (GTK_CONTAINER (window->priv->vbox), GTK_WIDGET (window->priv->lock_box));\n                window->priv->lock_box = NULL;\n\n                g_signal_emit (window, signals [DIALOG_DOWN], 0);\n        }\n\n        gtk_widget_destroy (GTK_WIDGET (window));\n}",
        "output": "1",
        "idx": 1820
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RoleNameIterator RoleGraph::getRolesForDatabase(const std::string& dbname) {\n    _createBuiltinRolesForDBIfNeeded(dbname);\n\n    std::set<RoleName>::const_iterator lower = _allRoles.lower_bound(RoleName(\"\", dbname));\n    std::string afterDB = dbname;\n    afterDB.push_back('\\0');\n    std::set<RoleName>::const_iterator upper = _allRoles.lower_bound(RoleName(\"\", afterDB));\n    return makeRoleNameIterator(lower, upper);\n}",
        "output": "0",
        "idx": 221
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void\nupdate_all_descriptor_downloads(time_t now)\n{\n  if (get_options()->DisableNetwork)\n    return;\n  update_router_descriptor_downloads(now);\n  update_microdesc_downloads(now);\n  launch_dummy_descriptor_download_as_needed(now, get_options());",
        "output": "0",
        "idx": 1793
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int open_user_journal_directory(Server *s, DIR **ret_dir, char **ret_path) {\n        _cleanup_closedir_ DIR *dir = NULL;\n        _cleanup_free_ char *path = NULL;\n        sd_id128_t machine;\n        int r;\n\n        assert(s);\n\n        r = sd_id128_get_machine(&machine);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to determine machine ID, ignoring: %m\");\n\n        if (asprintf(&path, \"/var/log/journal/\" SD_ID128_FORMAT_STR \"/\", SD_ID128_FORMAT_VAL(machine)) < 0)\n                return log_oom();\n\n        dir = opendir(path);\n        if (!dir)\n                return log_error_errno(errno, \"Failed to open user journal directory '%s': %m\", path);\n\n        if (ret_dir)\n                *ret_dir = TAKE_PTR(dir);\n        if (ret_path)\n                *ret_path = TAKE_PTR(path);\n\n        return 0;\n}",
        "output": "0",
        "idx": 48
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ga_grow_inner(garray_T *gap, int n)\n{\n    size_t\told_len;\n    size_t\tnew_len;\n    char_u\t*pp;\n\n    if (n < gap->ga_growsize)\n\tn = gap->ga_growsize;\n\n    // A linear growth is very inefficient when the array grows big.  This\n    // is a compromise between allocating memory that won't be used and too\n    // many copy operations. A factor of 1.5 seems reasonable.\n    if (n < gap->ga_len / 2)\n\tn = gap->ga_len / 2;\n\n    new_len = gap->ga_itemsize * (gap->ga_len + n);\n    pp = vim_realloc(gap->ga_data, new_len);\n    if (pp == NULL)\n\treturn FAIL;\n    old_len = gap->ga_itemsize * gap->ga_maxlen;\n    vim_memset(pp + old_len, 0, new_len - old_len);\n    gap->ga_maxlen = gap->ga_len + n;\n    gap->ga_data = pp;\n    return OK;\n}",
        "output": "0",
        "idx": 3461
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void timer_stats_timer_clear_start_info(struct timer_list *timer)\n{\n\ttimer->start_site = NULL;\n}",
        "output": "1",
        "idx": 2807
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned long get_devid(uint8_t busnum, uint8_t devnum)\n{\n\treturn (busnum << 16) | devnum;\n}",
        "output": "0",
        "idx": 620
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int unix_seqpacket_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t      struct msghdr *msg, size_t size,\n\t\t\t      int flags)\n{\n\tstruct sock *sk = sock->sk;\n\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\treturn -ENOTCONN;\n\n\treturn unix_dgram_recvmsg(iocb, sock, msg, size, flags);\n}",
        "output": "0",
        "idx": 967
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ext2_xattr_cache_insert(struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext2_xattr_cache, GFP_NOFS);\n\tif (!ce)\n\t\treturn -ENOMEM;\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache (%d cache entries)\",\n\t\t\t\tatomic_read(&ext2_xattr_cache->c_entry_count));\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x] (%d cache entries)\", (int)hash,\n\t\t\t  atomic_read(&ext2_xattr_cache->c_entry_count));\n\t\tmb_cache_entry_release(ce);\n\t}\n\treturn error;\n}",
        "output": "1",
        "idx": 2415
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    void CrwMap::decode0x1810(const CiffComponent& ciffComponent,\n                              const CrwMapping*    pCrwMapping,\n                                    Image&         image,\n                                    ByteOrder      byteOrder)\n    {\n        if (ciffComponent.typeId() != unsignedLong || ciffComponent.size() < 28) {\n            return decodeBasic(ciffComponent, pCrwMapping, image, byteOrder);\n        }\n\n        ExifKey key1(\"Exif.Photo.PixelXDimension\");\n        ULongValue value1;\n        value1.read(ciffComponent.pData(), 4, byteOrder);\n        image.exifData().add(key1, &value1);\n\n        ExifKey key2(\"Exif.Photo.PixelYDimension\");\n        ULongValue value2;\n        value2.read(ciffComponent.pData() + 4, 4, byteOrder);\n        image.exifData().add(key2, &value2);\n\n        int32_t r = getLong(ciffComponent.pData() + 12, byteOrder);\n        uint16_t o = RotationMap::orientation(r);\n        image.exifData()[\"Exif.Image.Orientation\"] = o;\n\n    } // CrwMap::decode0x1810",
        "output": "0",
        "idx": 3295
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int queue_get(struct priv_net *pn, void *buf, int len)\n{\n\tstruct queue *head = &pn->pn_queue;\n\tstruct queue *q = head->q_next;\n\n\tif (q == head)\n\t\treturn 0;\n\n\tassert(q->q_len <= len);\n\tmemcpy(buf, q->q_buf, q->q_len);\n\n\tqueue_del(q);\n\tqueue_add(&pn->pn_queue_free, q);\n\n\treturn q->q_len;\n}",
        "output": "0",
        "idx": 183
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_new_line (void)\n{\n    RsvgNodeLine *line;\n    line = g_new (RsvgNodeLine, 1);\n    _rsvg_node_init (&line->super);\n    line->super.draw = _rsvg_node_line_draw;\n    line->super.set_atts = _rsvg_node_line_set_atts;\n    line->x1 = line->x2 = line->y1 = line->y2 = _rsvg_css_parse_length (\"0\");\n    return &line->super;\n}",
        "output": "1",
        "idx": 2284
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "task_function_call(struct task_struct *p, remote_function_f func, void *info)\n{\n\tstruct remote_function_call data = {\n\t\t.p\t= p,\n\t\t.func\t= func,\n\t\t.info\t= info,\n\t\t.ret\t= -EAGAIN,\n\t};\n\tint ret;\n\n\tfor (;;) {\n\t\tret = smp_call_function_single(task_cpu(p), remote_function,\n\t\t\t\t\t       &data, 1);\n\t\tif (!ret)\n\t\t\tret = data.ret;\n\n\t\tif (ret != -EAGAIN)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 3331
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void put_filp(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tsecurity_file_free(file);\n\t\tfile_sb_list_del(file);\n\t\tfile_free(file);\n\t}\n}",
        "output": "1",
        "idx": 2386
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PHP_GINIT_FUNCTION(pcntl)\n{ \n\tmemset(pcntl_globals, 0, sizeof(*pcntl_globals));\n}",
        "output": "1",
        "idx": 1967
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void retrigger_next_event(void *arg)\n{\n\tstruct hrtimer_cpu_base *base;\n\tstruct timespec realtime_offset;\n\tunsigned long seq;\n\n\tif (!hrtimer_hres_active())\n\t\treturn;\n\n\tdo {\n\t\tseq = read_seqbegin(&xtime_lock);\n\t\tset_normalized_timespec(&realtime_offset,\n\t\t\t\t\t-wall_to_monotonic.tv_sec,\n\t\t\t\t\t-wall_to_monotonic.tv_nsec);\n\t} while (read_seqretry(&xtime_lock, seq));\n\n\tbase = &__get_cpu_var(hrtimer_bases);\n\n\t/* Adjust CLOCK_REALTIME offset */\n\tspin_lock(&base->lock);\n\tbase->clock_base[CLOCK_REALTIME].offset =\n\t\ttimespec_to_ktime(realtime_offset);\n\n\thrtimer_force_reprogram(base);\n\tspin_unlock(&base->lock);\n}",
        "output": "0",
        "idx": 1203
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "S3BootScriptSaveInformation (\r\n  IN  UINT32                                InformationLength,\r\n  IN  VOID                                 *Information\r\n  )\r\n{\r\n  UINT8                 Length;\r\n  UINT8                 *Script;\r\n  EFI_BOOT_SCRIPT_INFORMATION  ScriptInformation;\r\n\r\n  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_INFORMATION) + InformationLength);\r\n\r\n  Script = S3BootScriptGetEntryAddAddress (Length);\r\n  if (Script == NULL) {\r\n    return RETURN_OUT_OF_RESOURCES;\r\n  }\r\n  //\r\n  // Build script data\r\n  //\r\n  ScriptInformation.OpCode     = EFI_BOOT_SCRIPT_INFORMATION_OPCODE;\r\n  ScriptInformation.Length     = Length;\r\n\r\n\r\n  ScriptInformation.InformationLength = InformationLength;\r\n\r\n  CopyMem ((VOID*)Script, (VOID*)&ScriptInformation, sizeof (EFI_BOOT_SCRIPT_INFORMATION));\r\n  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_INFORMATION)), (VOID *) Information, (UINTN) InformationLength);\r\n\r\n  SyncBootScript (Script);\r\n\r\n  return RETURN_SUCCESS;\r\n\r\n}\r",
        "output": "1",
        "idx": 548
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,\n                                 hwaddr *plen, bool resolve_subpage)\n{\n    MemoryRegionSection *section;\n    Int128 diff;\n\n    section = address_space_lookup_region(d, addr, resolve_subpage);\n    /* Compute offset within MemoryRegionSection */\n    addr -= section->offset_within_address_space;\n\n    /* Compute offset within MemoryRegion */\n    *xlat = addr + section->offset_within_region;\n\n    diff = int128_sub(section->mr->size, int128_make64(addr));\n    *plen = int128_get64(int128_min(diff, int128_make64(*plen)));\n    return section;\n}",
        "output": "1",
        "idx": 2114
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,\n\t\t      const struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *data = *pbcc_area;\n\n\tcifs_dbg(FYI, \"bleft %d\\n\", bleft);\n\n\tkfree(ses->serverOS);\n\tses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverOS=%s\\n\", ses->serverOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\tses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverNOS=%s\\n\", ses->serverNOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverDomain);\n\tses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverDomain=%s\\n\", ses->serverDomain);\n\n\treturn;\n}",
        "output": "0",
        "idx": 2704
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t size_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct cacheinfo *this_leaf = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%uK\\n\", this_leaf->size >> 10);\n}",
        "output": "1",
        "idx": 673
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\tswitch (yych) {\n\t\tcase 'a': goto yy35;\n\t\tdefault: goto yy33;\n\t}",
        "output": "1",
        "idx": 735
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\tDlfcnModule(void* m)\n\t\t: module(m)\n\t{}",
        "output": "1",
        "idx": 63
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iobuf_temp_with_content (const char *buffer, size_t length)\n{\n  iobuf_t a;\n\n  a = iobuf_alloc (3, length);\n  memcpy (a->d.buf, buffer, length);\n  a->d.len = length;\n\n  return a;\n}",
        "output": "1",
        "idx": 1577
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  static void convertFunctionWordToUint32(typename ConvertWordTypeToUint32<Args>::type... args) {\n    F(std::forward<Args>(args)...);\n  }",
        "output": "0",
        "idx": 1550
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "show_ep_handle(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);\n\treturn sprintf(buf, \"%llu\\n\", (unsigned long long) ep->id);\n}",
        "output": "1",
        "idx": 2367
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,\n\t\t\t\t   struct pinctrl_dev *pctldev,\n\t\t\t\t   struct pinctrl_map *map, unsigned num_maps)\n{\n\tint i;\n\tstruct pinctrl_dt_map *dt_map;\n\n\t/* Initialize common mapping table entry fields */\n\tfor (i = 0; i < num_maps; i++) {\n\t\tmap[i].dev_name = dev_name(p->dev);\n\t\tmap[i].name = statename;\n\t\tif (pctldev)\n\t\t\tmap[i].ctrl_dev_name = dev_name(pctldev->dev);\n\t}\n\n\t/* Remember the converted mapping table entries */\n\tdt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);\n\tif (!dt_map) {\n\t\tdt_free_map(pctldev, map, num_maps);\n\t\treturn -ENOMEM;\n\t}\n\n\tdt_map->pctldev = pctldev;\n\tdt_map->map = map;\n\tdt_map->num_maps = num_maps;\n\tlist_add_tail(&dt_map->node, &p->dt_maps);\n\n\treturn pinctrl_register_map(map, num_maps, false);\n}",
        "output": "1",
        "idx": 3520
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlBufferCCat(xmlBufferPtr buf, const char *str) {\n    const char *cur;\n\n    if (buf == NULL)\n        return(-1);\n    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;\n    if (str == NULL) {\n#ifdef DEBUG_BUFFER\n        xmlGenericError(xmlGenericErrorContext,\n\t\t\"xmlBufferCCat: str == NULL\\n\");\n#endif\n\treturn -1;\n    }\n    for (cur = str;*cur != 0;cur++) {\n        if (buf->use  + 10 >= buf->size) {\n            if (!xmlBufferResize(buf, buf->use+10)){\n\t\txmlTreeErrMemory(\"growing buffer\");\n                return XML_ERR_NO_MEMORY;\n            }\n        }\n        buf->content[buf->use++] = *cur;\n    }\n    buf->content[buf->use] = 0;\n    return 0;\n}",
        "output": "1",
        "idx": 2249
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __net_exit xfrm6_tunnel_net_exit(struct net *net)\n{\n\tstruct xfrm6_tunnel_net *xfrm6_tn = xfrm6_tunnel_pernet(net);\n\tunsigned int i;\n\n\txfrm_flush_gc();\n\txfrm_state_flush(net, IPSEC_PROTO_ANY, false, true);\n\n\tfor (i = 0; i < XFRM6_TUNNEL_SPI_BYADDR_HSIZE; i++)\n\t\tWARN_ON_ONCE(!hlist_empty(&xfrm6_tn->spi_byaddr[i]));\n\n\tfor (i = 0; i < XFRM6_TUNNEL_SPI_BYSPI_HSIZE; i++)\n\t\tWARN_ON_ONCE(!hlist_empty(&xfrm6_tn->spi_byspi[i]));\n}",
        "output": "1",
        "idx": 416
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cmsNAMEDCOLORLIST* CMSEXPORT cmsAllocNamedColorList(cmsContext ContextID, cmsUInt32Number n, cmsUInt32Number ColorantCount, const char* Prefix, const char* Suffix)\n{\n    cmsNAMEDCOLORLIST* v = (cmsNAMEDCOLORLIST*) _cmsMallocZero(ContextID, sizeof(cmsNAMEDCOLORLIST));\n\n    if (v == NULL) return NULL;\n\n    v ->List      = NULL;\n    v ->nColors   = 0;\n    v ->ContextID  = ContextID;\n\n    while (v -> Allocated < n)\n        GrowNamedColorList(v);\n\n    strncpy(v ->Prefix, Prefix, sizeof(v ->Prefix));\n    strncpy(v ->Suffix, Suffix, sizeof(v ->Suffix));\n    v->Prefix[32] = v->Suffix[32] = 0;\n\n    v -> ColorantCount = ColorantCount;\n\n    return v;\n}",
        "output": "1",
        "idx": 1874
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ext3_handle_error(struct super_block *sb)\n{\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\n\tEXT3_SB(sb)->s_mount_state |= EXT3_ERROR_FS;\n\tes->s_state |= cpu_to_le16(EXT3_ERROR_FS);\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (!test_opt (sb, ERRORS_CONT)) {\n\t\tjournal_t *journal = EXT3_SB(sb)->s_journal;\n\n\t\tset_opt(EXT3_SB(sb)->s_mount_opt, ABORT);\n\t\tif (journal)\n\t\t\tjournal_abort(journal, -EIO);\n\t}\n\tif (test_opt (sb, ERRORS_RO)) {\n\t\text3_msg(sb, KERN_CRIT,\n\t\t\t\"error: remounting filesystem read-only\");\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\text3_commit_super(sb, es, 1);\n\tif (test_opt(sb, ERRORS_PANIC))\n\t\tpanic(\"EXT3-fs (%s): panic forced after error\\n\",\n\t\t\tsb->s_id);\n}",
        "output": "0",
        "idx": 427
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "HValueMap::HValueMap(Zone* zone, const HValueMap* other)\n    : array_size_(other->array_size_),\n      lists_size_(other->lists_size_),\n      count_(other->count_),\n      present_flags_(other->present_flags_),\n      array_(zone->NewArray<HValueMapListElement>(other->array_size_)),\n      lists_(zone->NewArray<HValueMapListElement>(other->lists_size_)),\n      free_list_head_(other->free_list_head_) {\n  memcpy(array_, other->array_, array_size_ * sizeof(HValueMapListElement));\n  memcpy(lists_, other->lists_, lists_size_ * sizeof(HValueMapListElement));\n}",
        "output": "0",
        "idx": 2923
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int compat_do_execve(struct filename *filename,\n\tconst compat_uptr_t __user *__argv,\n\tconst compat_uptr_t __user *__envp)\n{\n\tstruct user_arg_ptr argv = {\n\t\t.is_compat = true,\n\t\t.ptr.compat = __argv,\n\t};\n\tstruct user_arg_ptr envp = {\n\t\t.is_compat = true,\n\t\t.ptr.compat = __envp,\n\t};\n\treturn do_execveat_common(AT_FDCWD, filename, argv, envp, 0);\n}",
        "output": "0",
        "idx": 2649
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "find_session_from_nick (char *nick, server *serv)\n{\n\tsession *sess;\n\tGSList *list = sess_list;\n\n\tsess = find_dialog (serv, nick);\n\tif (sess)\n\t\treturn sess;\n\n\tif (serv->front_session)\n\t{\n\t\tif (userlist_find (serv->front_session, nick))\n\t\t\treturn serv->front_session;\n\t}\n\n\tif (current_sess && current_sess->server == serv)\n\t{\n\t\tif (userlist_find (current_sess, nick))\n\t\t\treturn current_sess;\n\t}\n\n\twhile (list)\n\t{\n\t\tsess = list->data;\n\t\tif (sess->server == serv)\n\t\t{\n\t\t\tif (userlist_find (sess, nick))\n\t\t\t\treturn sess;\n\t\t}\n\t\tlist = list->next;\n\t}\n\treturn NULL;\n}",
        "output": "0",
        "idx": 1687
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "f_settabvar(typval_T *argvars, typval_T *rettv)\n{\n    tabpage_T\t*save_curtab;\n    tabpage_T\t*tp;\n    char_u\t*varname, *tabvarname;\n    typval_T\t*varp;\n\n    rettv->vval.v_number = 0;\n\n    if (check_restricted() || check_secure())\n\treturn;\n\n    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));\n    varname = tv_get_string_chk(&argvars[1]);\n    varp = &argvars[2];\n\n    if (varname != NULL && varp != NULL && tp != NULL)\n    {\n\tsave_curtab = curtab;\n\tgoto_tabpage_tp(tp, FALSE, FALSE);\n\n\ttabvarname = alloc((unsigned)STRLEN(varname) + 3);\n\tif (tabvarname != NULL)\n\t{\n\t    STRCPY(tabvarname, \"t:\");\n\t    STRCPY(tabvarname + 2, varname);\n\t    set_var(tabvarname, varp, TRUE);\n\t    vim_free(tabvarname);\n\t}\n\n\t/* Restore current tabpage */\n\tif (valid_tabpage(save_curtab))\n\t    goto_tabpage_tp(save_curtab, FALSE, FALSE);\n    }\n}",
        "output": "1",
        "idx": 1895
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sc_awp_parse_df(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *df)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tunsigned char *buf = NULL;\n\tsize_t buf_len;\n\tint rv;\n\n\tLOG_FUNC_CALLED(ctx);\n\tif (df->type != SC_PKCS15_PRKDF && df->type != SC_PKCS15_DODF)\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n\n\tif (df->enumerated)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\n\trv = sc_oberthur_read_file(p15card, AWP_OBJECTS_LIST_PRV, &buf, &buf_len, 1);\n\tLOG_TEST_RET(ctx, rv, \"Parse DF: read private objects info failed\");\n\n\trv = sc_oberthur_parse_privateinfo(p15card, buf, buf_len, 0);\n\n\tif (buf)\n\t\tfree(buf);\n\n\tif (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)\n\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\n\tLOG_TEST_RET(ctx, rv, \"Parse DF: private info parse error\");\n\tdf->enumerated = 1;\n\n\tLOG_FUNC_RETURN(ctx, rv);\n}",
        "output": "0",
        "idx": 58
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\tstruct vmcb_save_area *save01 = &to_svm(vcpu)->vmcb01.ptr->save;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_CS: return &save->cs;\n\tcase VCPU_SREG_DS: return &save->ds;\n\tcase VCPU_SREG_ES: return &save->es;\n\tcase VCPU_SREG_FS: return &save01->fs;\n\tcase VCPU_SREG_GS: return &save01->gs;\n\tcase VCPU_SREG_SS: return &save->ss;\n\tcase VCPU_SREG_TR: return &save01->tr;\n\tcase VCPU_SREG_LDTR: return &save01->ldtr;\n\t}\n\tBUG();\n\treturn NULL;\n}",
        "output": "0",
        "idx": 2831
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "activate_callback (GList    *files,\n                   gpointer  callback_data)\n{\n    ActivateParameters *parameters = callback_data;\n    GList *l, *next;\n    NautilusFile *file;\n    LaunchLocation *location;\n\n    parameters->files_handle = NULL;\n\n    for (l = parameters->locations; l != NULL; l = next)\n    {\n        location = l->data;\n        file = location->file;\n        next = l->next;\n\n        if (file_was_cancelled (file))\n        {\n            launch_location_free (location);\n            parameters->locations = g_list_delete_link (parameters->locations, l);\n            continue;\n        }\n\n        if (file_was_not_mounted (file))\n        {\n            if (parameters->tried_mounting)\n            {\n                launch_location_free (location);\n                parameters->locations = g_list_delete_link (parameters->locations, l);\n            }\n            else\n            {\n                parameters->not_mounted = g_list_prepend (parameters->not_mounted,\n                                                          nautilus_file_ref (file));\n            }\n            continue;\n        }\n    }\n\n\n    if (parameters->not_mounted != NULL)\n    {\n        activation_mount_not_mounted (parameters);\n    }\n    else\n    {\n        activate_files (parameters);\n    }\n}",
        "output": "0",
        "idx": 2405
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset) {\n\tbloc = *offset;\n\tsend(huff->loc[ch], NULL, fout);\n\t*offset = bloc;\n}",
        "output": "1",
        "idx": 2464
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __net_random_once_deferred(struct work_struct *w)\n{\n\tstruct __net_random_once_work *work =\n\t\tcontainer_of(w, struct __net_random_once_work, work);\n\tif (!static_key_enabled(work->key))\n\t\tstatic_key_slow_inc(work->key);\n\tkfree(work);\n}",
        "output": "1",
        "idx": 2033
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void tcmi_box_del(GF_Box *s)\n{\n\tGF_TimeCodeMediaInformationBox *ptr = (GF_TimeCodeMediaInformationBox *)s;\n\tif (ptr->font) gf_free(ptr->font);\n\tgf_free(s);\n}",
        "output": "0",
        "idx": 3388
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n\n\tif (stack->elements) {\n\t\tfor (i = 0; i < stack->top; i++) {\n\t\t\tif (((st_entry *)stack->elements[i])->data)\t{\n\t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n\t\t\t}\n\t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\t\t\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;\n}",
        "output": "1",
        "idx": 1272
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Ogg::XiphComment::parse(const ByteVector &data)\n{\n  // The first thing in the comment data is the vendor ID length, followed by a\n  // UTF8 string with the vendor ID.\n\n  uint pos = 0;\n\n  int vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n\n  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n\n  // Next the number of fields in the comment vector.\n\n  uint commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n\n  if(commentFields > (data.size() - 8) / 4) {\n    return;\n  }\n\n  for(uint i = 0; i < commentFields; i++) {\n\n    // Each comment field is in the format \"KEY=value\" in a UTF8 string and has\n    // 4 bytes before the text starts that gives the length.\n\n    uint commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n    if(pos > data.size()) {\n      break;\n    }\n\n    int commentSeparatorPosition = comment.find(\"=\");\n    if(commentSeparatorPosition == -1) {\n      break;\n    }\n\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n\n    addField(key, value, false);\n  }\n}",
        "output": "1",
        "idx": 268
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void init_re(void)\n{\n  /*\n    Filter for queries that can be run using the\n    MySQL Prepared Statements C API\n  */\n  const char *ps_re_str =\n    \"^(\"\n    \"[[:space:]]*REPLACE[[:space:]]|\"\n    \"[[:space:]]*INSERT[[:space:]]|\"\n    \"[[:space:]]*UPDATE[[:space:]]|\"\n    \"[[:space:]]*DELETE[[:space:]]|\"\n    \"[[:space:]]*SELECT[[:space:]]|\"\n    \"[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|\"\n    \"[[:space:]]*DO[[:space:]]|\"\n    \"[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|\"\n    \"[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|\"\n    \"[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|\"\n    \"[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])\";\n\n  /*\n    Filter for queries that can be run using the\n    Stored procedures\n  */\n  const char *sp_re_str =ps_re_str;\n\n  /*\n    Filter for queries that can be run as views\n  */\n  const char *view_re_str =\n    \"^(\"\n    \"[[:space:]]*SELECT[[:space:]])\";\n\n  init_re_comp(&ps_re, ps_re_str);\n  init_re_comp(&sp_re, sp_re_str);\n  init_re_comp(&view_re, view_re_str);\n}",
        "output": "0",
        "idx": 667
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dm_request_for_irq_injection(struct kvm_vcpu *vcpu,\n\t\t\t\t\t  struct kvm_run *kvm_run)\n{\n\treturn (!vcpu->arch.irq_summary &&\n\t\tkvm_run->request_interrupt_window &&\n\t\tvcpu->arch.interrupt_window_open &&\n\t\t(kvm_x86_ops->get_rflags(vcpu) & X86_EFLAGS_IF));\n}",
        "output": "0",
        "idx": 3115
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QString Avahi::domainToDNS(const QString &domain)\n{\n    return isLocalDomain(domain) ? domain : QUrl::toAce(domain);\n}",
        "output": "1",
        "idx": 1085
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int bsearchenv(char **env, const char *name, size_t size)\n{\n\tunsigned low = 0, high = size;\n\twhile (low < high) {\n\t\tunsigned mid = low + ((high - low) >> 1);\n\t\tint cmp = compareenv(&env[mid], &name);\n\t\tif (cmp < 0)\n\t\t\tlow = mid + 1;\n\t\telse if (cmp > 0)\n\t\t\thigh = mid;\n\t\telse\n\t\t\treturn mid;\n\t}\n\treturn ~low; /* not found, return 1's complement of insert position */\n}",
        "output": "0",
        "idx": 2393
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __btrfs_releasepage(struct page *page, gfp_t gfp_flags)\n{\n\tstruct extent_io_tree *tree;\n\tstruct extent_map_tree *map;\n\tint ret;\n\n\ttree = &BTRFS_I(page->mapping->host)->io_tree;\n\tmap = &BTRFS_I(page->mapping->host)->extent_tree;\n\tret = try_release_extent_mapping(map, tree, page, gfp_flags);\n\tif (ret == 1) {\n\t\tClearPagePrivate(page);\n\t\tset_page_private(page, 0);\n\t\tpage_cache_release(page);\n\t}\n\treturn ret;\n}",
        "output": "0",
        "idx": 3668
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dataiterator_skip_attribute(Dataiterator *di)\n{\n  if (di->state == di_nextsolvableattr)\n    di->state = di_nextsolvablekey;\n  else\n    di->state = di_nextkey;\n}",
        "output": "0",
        "idx": 111
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __dvb_frontend_free(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\n\tif (fepriv)\n\t\tdvb_free_device(fepriv->dvbdev);\n\n\tdvb_frontend_invoke_release(fe, fe->ops.release);\n\n\tif (!fepriv)\n\t\treturn;\n\n\tkfree(fepriv);\n\tfe->frontend_priv = NULL;\n}",
        "output": "1",
        "idx": 3535
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_NAMED_FUNCTION(zif_locale_set_default)\n{\n\tchar* locale_name = NULL;\n\tint   len=0;\t\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  \"s\",\n\t\t&locale_name ,&len ) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \t\"locale_set_default: unable to parse input params\", 0 TSRMLS_CC );\n\n\t\tRETURN_FALSE;\n\t}\n\n\tif(len == 0) {\n\t\tlocale_name =  (char *)uloc_getDefault() ;\n\t\tlen = strlen(locale_name);\n\t}\n\n\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\t\n\n\tRETURN_TRUE;\n}",
        "output": "1",
        "idx": 658
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void TableLookUp::setTable(int ntable, const std::vector<ushort16>& table) {\n  assert(!table.empty());\n\n  const int nfilled = table.size();\n\n  if (ntable > ntables) {\n    ThrowRDE(\"Table lookup with number greater than number of tables.\");\n  }\n  ushort16* t = &tables[ntable * TABLE_SIZE];\n  if (!dither) {\n    for (int i = 0; i < 65536; i++) {\n      t[i] = (i < nfilled) ? table[i] : table[nfilled - 1];\n    }\n    return;\n  }\n  for (int i = 0; i < nfilled; i++) {\n    int center = table[i];\n    int lower = i > 0 ? table[i - 1] : center;\n    int upper = i < (nfilled - 1) ? table[i + 1] : center;\n    int delta = upper - lower;\n    t[i * 2] = center - ((upper - lower + 2) / 4);\n    t[i * 2 + 1] = delta;\n  }\n\n  for (int i = nfilled; i < 65536; i++) {\n    t[i * 2] = table[nfilled - 1];\n    t[i * 2 + 1] = 0;\n  }\n  t[0] = t[1];\n  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];\n}",
        "output": "1",
        "idx": 1091
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static apr_status_t session_identity_encode(request_rec * r, session_rec * z)\n{\n\n    char *buffer = NULL;\n    int length = 0;\n    if (z->expiry) {\n        char *expiry = apr_psprintf(z->pool, \"%\" APR_INT64_T_FMT, z->expiry);\n        apr_table_setn(z->entries, SESSION_EXPIRY, expiry);\n    }\n    apr_table_do(identity_count, &length, z->entries, NULL);\n    buffer = apr_pcalloc(r->pool, length + 1);\n    apr_table_do(identity_concat, buffer, z->entries, NULL);\n    z->encoded = buffer;\n    return OK;\n\n}",
        "output": "1",
        "idx": 962
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int uas_wait_for_pending_cmnds(struct uas_dev_info *devinfo)\n{\n\tunsigned long start_time;\n\tint r;\n\n\tstart_time = jiffies;\n\tdo {\n\t\tflush_work(&devinfo->work);\n\n\t\tr = usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 5000);\n\t\tif (r == 0)\n\t\t\treturn -ETIME;\n\n\t\tr = usb_wait_anchor_empty_timeout(&devinfo->data_urbs, 500);\n\t\tif (r == 0)\n\t\t\treturn -ETIME;\n\n\t\tif (time_after(jiffies, start_time + 5 * HZ))\n\t\t\treturn -ETIME;\n\t} while (!uas_cmnd_list_empty(devinfo));\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2730
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void maybeAllocTrailers() override {\n    ASSERT(processing_trailers_);\n    if (!absl::holds_alternative<RequestTrailerMapPtr>(headers_or_trailers_)) {\n      headers_or_trailers_.emplace<RequestTrailerMapPtr>(RequestTrailerMapImpl::create());\n    }\n  }",
        "output": "1",
        "idx": 2015
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void shmem_dir_free(struct page *page)\n{\n\t__free_pages(page, PAGE_CACHE_SHIFT-PAGE_SHIFT);\n}",
        "output": "0",
        "idx": 1208
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "valid_tabpage(tabpage_T *tpc)\n{\n    tabpage_T\t*tp;\n\n    FOR_ALL_TABPAGES(tp)\n\tif (tp == tpc)\n\t    return TRUE;\n    return FALSE;\n}",
        "output": "0",
        "idx": 1161
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void isis_notif_id_len_mismatch(const struct isis_circuit *circuit,\n\t\t\t\tuint8_t rcv_id_len, const char *raw_pdu,\n\t\t\t\tsize_t raw_pdu_len)\n{\n\tconst char *xpath = \"/frr-isisd:id-len-mismatch\";\n\tstruct list *arguments = yang_data_list_new();\n\tchar xpath_arg[XPATH_MAXLEN];\n\tstruct yang_data *data;\n\tstruct isis_area *area = circuit->area;\n\n\tnotif_prep_instance_hdr(xpath, area, \"default\", arguments);\n\tnotif_prepr_iface_hdr(xpath, circuit, arguments);\n\tsnprintf(xpath_arg, sizeof(xpath_arg), \"%s/pdu-field-len\", xpath);\n\tdata = yang_data_new_uint8(xpath_arg, rcv_id_len);\n\tlistnode_add(arguments, data);\n\tsnprintf(xpath_arg, sizeof(xpath_arg), \"%s/raw-pdu\", xpath);\n\tdata = yang_data_new(xpath_arg, raw_pdu);\n\tlistnode_add(arguments, data);\n\n\thook_call(isis_hook_id_len_mismatch, circuit, rcv_id_len, raw_pdu,\n\t\t  raw_pdu_len);\n\n\tnb_notification_send(xpath, arguments);\n}",
        "output": "1",
        "idx": 3432
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "STATIC ptr_t GC_alloc_large_and_clear(size_t lb, int k, unsigned flags)\n{\n    ptr_t result;\n    word n_blocks = OBJ_SZ_TO_BLOCKS(lb);\n\n    GC_ASSERT(I_HOLD_LOCK());\n    result = GC_alloc_large(lb, k, flags);\n    if (result != NULL\n          && (GC_debugging_started || GC_obj_kinds[k].ok_init)) {\n        /* Clear the whole block, in case of GC_realloc call. */\n        BZERO(result, n_blocks * HBLKSIZE);\n    }\n    return result;\n}",
        "output": "1",
        "idx": 2589
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dealloc(xmlSchemaPtr schema)\n{\n  NOKOGIRI_DEBUG_START(schema);\n  xmlSchemaFree(schema);\n  NOKOGIRI_DEBUG_END(schema);\n}",
        "output": "0",
        "idx": 2119
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sysbus_ahci_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    dc->realize = sysbus_ahci_realize;\n    dc->vmsd = &vmstate_sysbus_ahci;\n    dc->props = sysbus_ahci_properties;\n    dc->reset = sysbus_ahci_reset;\n    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);\n}",
        "output": "0",
        "idx": 1234
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool CTransaction::DisconnectInputs(CTxDB& txdb)\n{\n    // Relinquish previous transactions' spent pointers\n    if (!IsCoinBase())\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n        {\n            COutPoint prevout = txin.prevout;\n\n            // Get prev txindex from disk\n            CTxIndex txindex;\n            if (!txdb.ReadTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : ReadTxIndex failed\");\n\n            if (prevout.n >= txindex.vSpent.size())\n                return error(\"DisconnectInputs() : prevout.n out of range\");\n\n            // Mark outpoint as not spent\n            txindex.vSpent[prevout.n].SetNull();\n\n            // Write back\n            if (!txdb.UpdateTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : UpdateTxIndex failed\");\n        }\n    }\n\n    // Remove transaction from index\n    if (!txdb.EraseTxIndex(*this))\n        return error(\"DisconnectInputs() : EraseTxPos failed\");\n\n    return true;\n}",
        "output": "1",
        "idx": 3441
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "WalSndPrepareWrite(LogicalDecodingContext *ctx, XLogRecPtr lsn, TransactionId xid, bool last_write)\n{\n\t/* can't have sync rep confused by sending the same LSN several times */\n\tif (!last_write)\n\t\tlsn = InvalidXLogRecPtr;\n\n\tresetStringInfo(ctx->out);\n\n\tpq_sendbyte(ctx->out, 'w');\n\tpq_sendint64(ctx->out, lsn);\t/* dataStart */\n\tpq_sendint64(ctx->out, lsn);\t/* walEnd */\n\n\t/*\n\t * Fill out the sendtime later, just as it's done in XLogSendPhysical, but\n\t * reserve space here.\n\t */\n\tpq_sendint64(ctx->out, 0);\t/* sendtime */\n}",
        "output": "0",
        "idx": 2242
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int netif_receive_skb(struct sk_buff *skb)\n{\n\tif (netdev_tstamp_prequeue)\n\t\tnet_timestamp_check(skb);\n\n\tif (skb_defer_rx_timestamp(skb))\n\t\treturn NET_RX_SUCCESS;\n\n#ifdef CONFIG_RPS\n\t{\n\t\tstruct rps_dev_flow voidflow, *rflow = &voidflow;\n\t\tint cpu, ret;\n\n\t\trcu_read_lock();\n\n\t\tcpu = get_rps_cpu(skb->dev, skb, &rflow);\n\n\t\tif (cpu >= 0) {\n\t\t\tret = enqueue_to_backlog(skb, cpu, &rflow->last_qtail);\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\trcu_read_unlock();\n\t\t\tret = __netif_receive_skb(skb);\n\t\t}\n\n\t\treturn ret;\n\t}\n#else\n\treturn __netif_receive_skb(skb);\n#endif\n}",
        "output": "0",
        "idx": 381
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void WebContents::IncrementCapturerCount(gin::Arguments* args) {\n  gfx::Size size;\n  bool stay_hidden = false;\n  bool stay_awake = false;\n\n  // get size arguments if they exist\n  args->GetNext(&size);\n  // get stayHidden arguments if they exist\n  args->GetNext(&stay_hidden);\n  // get stayAwake arguments if they exist\n  args->GetNext(&stay_awake);\n\n  ignore_result(\n      web_contents()->IncrementCapturerCount(size, stay_hidden, stay_awake));\n}",
        "output": "0",
        "idx": 654
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char* GetOneCertName(CertName* name, int idx)\n{\n    switch (idx) {\n    case 0:\n       return name->country;\n\n    case 1:\n       return name->state;\n\n    case 2:\n       return name->locality;\n\n    case 3:\n       return name->sur;\n\n    case 4:\n       return name->org;\n\n    case 5:\n       return name->unit;\n\n    case 6:\n       return name->commonName;\n\n    case 7:\n       return name->serialDev;\n\n#ifdef WOLFSSL_CERT_EXT\n    case 8:\n       return name->busCat;\n\n    case 9:\n#else\n    case 8:\n#endif\n       return name->email;\n\n    default:\n       return 0;\n    }\n}",
        "output": "0",
        "idx": 14
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void php_snmp_object_free_storage(void *object TSRMLS_DC)\n{\n\tphp_snmp_object *intern = (php_snmp_object *)object;\n\t\n\tif (!intern) {\n\t\treturn;\n\t}\n\n\tnetsnmp_session_free(&(intern->session));\n\n\tzend_object_std_dtor(&intern->zo TSRMLS_CC);\n\t\n\tefree(intern);\n}",
        "output": "1",
        "idx": 1686
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ConnectionManagerImpl::RdsRouteConfigUpdateRequester::requestRouteConfigUpdate(\n    Http::RouteConfigUpdatedCallbackSharedPtr route_config_updated_cb) {\n  absl::optional<Router::ConfigConstSharedPtr> route_config = parent_.routeConfig();\n  Event::Dispatcher& thread_local_dispatcher =\n      parent_.connection_manager_.read_callbacks_->connection().dispatcher();\n  if (route_config.has_value() && route_config.value()->usesVhds()) {\n    ASSERT(!parent_.request_headers_->Host()->value().empty());\n    const auto& host_header = absl::AsciiStrToLower(parent_.request_headers_->getHostValue());\n    requestVhdsUpdate(host_header, thread_local_dispatcher, std::move(route_config_updated_cb));\n    return;\n  } else if (parent_.snapped_scoped_routes_config_ != nullptr) {\n    Router::ScopeKeyPtr scope_key =\n        parent_.snapped_scoped_routes_config_->computeScopeKey(*parent_.request_headers_);\n    // If scope_key is not null, the scope exists but RouteConfiguration is not initialized.\n    if (scope_key != nullptr) {\n      requestSrdsUpdate(std::move(scope_key), thread_local_dispatcher,\n                        std::move(route_config_updated_cb));\n      return;\n    }\n  }\n  // Continue the filter chain if no on demand update is requested.\n  (*route_config_updated_cb)(false);\n}",
        "output": "0",
        "idx": 1480
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int CMSEXPORT cmsIT8SetTableByLabel(cmsHANDLE hIT8, const char* cSet, const char* cField, const char* ExpectedType)\n{\n    const char* cLabelFld;\n    char Type[256], Label[256];\n    int nTable;\n\n    _cmsAssert(hIT8 != NULL);\n\n    if (cField != NULL && *cField == 0)\n            cField = \"LABEL\";\n\n    if (cField == NULL)\n            cField = \"LABEL\";\n\n    cLabelFld = cmsIT8GetData(hIT8, cSet, cField);\n    if (!cLabelFld) return -1;\n\n    if (sscanf(cLabelFld, \"%255s %d %255s\", Label, &nTable, Type) != 3)\n            return -1;\n\n    if (ExpectedType != NULL && *ExpectedType == 0)\n        ExpectedType = NULL;\n\n    if (ExpectedType) {\n\n        if (cmsstrcasecmp(Type, ExpectedType) != 0) return -1;\n    }\n\n    return cmsIT8SetTable(hIT8, nTable);\n}",
        "output": "0",
        "idx": 3400
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool Item_equal::count_sargable_conds(void *arg)\n{\n  SELECT_LEX *sel= (SELECT_LEX *) arg;\n  uint m= equal_items.elements;\n  sel->cond_count+= m*(m-1);\n  return 0;\n}",
        "output": "0",
        "idx": 420
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ProcessMakerNote(unsigned char * ValuePtr, int ByteCount, \n        unsigned char * OffsetBase, unsigned ExifLength)\n{\n    if (strstr(ImageInfo.CameraMake, \"Canon\")){\n        // So it turns out that some canons cameras use big endian, others use little\n        // endian in the main exif header.  But the maker note is always little endian.\n        static int MotorolaOrderSave;\n        MotorolaOrderSave = MotorolaOrder;\n        MotorolaOrder = 0; // Temporarily switch to little endian.\n        ProcessCanonMakerNoteDir(ValuePtr, OffsetBase, ExifLength);\n        MotorolaOrder = MotorolaOrderSave;\n    }else{\n        if (ShowTags){\n            ShowMakerNoteGeneric(ValuePtr, ByteCount);\n        }\n    }\n}",
        "output": "0",
        "idx": 3548
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nfsd_inet6addr_event(struct notifier_block *this,\n\tunsigned long event, void *ptr)\n{\n\tstruct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;\n\tstruct net_device *dev = ifa->idev->dev;\n\tstruct net *net = dev_net(dev);\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct sockaddr_in6 sin6;\n\n\tif (event != NETDEV_DOWN)\n\t\tgoto out;\n\n\tif (nn->nfsd_serv) {\n\t\tdprintk(\"nfsd_inet6addr_event: removed %pI6\\n\", &ifa->addr);\n\t\tsin6.sin6_family = AF_INET6;\n\t\tsin6.sin6_addr = ifa->addr;\n\t\tif (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)\n\t\t\tsin6.sin6_scope_id = ifa->idev->dev->ifindex;\n\t\tsvc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin6);\n\t}\n\nout:\n\treturn NOTIFY_DONE;\n}",
        "output": "0",
        "idx": 320
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Magick::Image::modulate(const double brightness_,const double saturation_,\n  const double hue_)\n{\n  char\n    modulate[MagickPathExtent + 1];\n\n  FormatLocaleString(modulate,MagickPathExtent,\"%3.6f,%3.6f,%3.6f\",brightness_,\n    saturation_,hue_);\n\n  modifyImage();\n  GetPPException;\n  ModulateImage(image(),modulate,exceptionInfo);\n  ThrowImageException;\n}",
        "output": "0",
        "idx": 1214
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CLASS minolta_rd175_load_raw()\n{\n  uchar pixel[768];\n  unsigned irow, box, row, col;\n\n  for (irow=0; irow < 1481; irow++) {\n    if (fread (pixel, 1, 768, ifp) < 768) derror();\n    box = irow / 82;\n    row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box-12)*2);\n    switch (irow) {\n      case 1477: case 1479: continue;\n      case 1476: row = 984; break;\n      case 1480: row = 985; break;\n      case 1478: row = 985; box = 1;\n    }\n    if ((box < 12) && (box & 1)) {\n      for (col=0; col < 1533; col++, row ^= 1)\n\tif (col != 1) RAW(row,col) = (col+1) & 2 ?\n\t\t   pixel[col/2-1] + pixel[col/2+1] : pixel[col/2] << 1;\n      RAW(row,1)    = pixel[1]   << 1;\n      RAW(row,1533) = pixel[765] << 1;\n    } else\n      for (col=row & 1; col < 1534; col+=2)\n\tRAW(row,col) = pixel[col/2] << 1;\n  }\n  maximum = 0xff << 1;\n}",
        "output": "0",
        "idx": 2431
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void testPartialDataHandling(const T& val, size_t bytesToPassTheCheck) {\n  auto buf = Serializer::template serialize<folly::IOBufQueue>(val).move();\n  buf->coalesce();\n\n  // Check that deserializing doesn't throw.\n  EXPECT_NO_THROW(Serializer::template deserialize<T>(buf.get()));\n\n  // Trim the buffer to the point that is *just enough* to pass the check for\n  // minimum required bytes.\n  buf->trimEnd(buf->length() - bytesToPassTheCheck);\n  // We'll hit underflow exception when pulling yet another element.\n  EXPECT_THROW(\n      Serializer::template deserialize<T>(buf.get()), std::out_of_range);\n\n  // Trim one more byte.\n  buf->trimEnd(1);\n  // We'll fail the deserialization straight when we read the length.\n  EXPECT_THROW(\n      Serializer::template deserialize<T>(buf.get()),\n      apache::thrift::protocol::TProtocolException);\n}",
        "output": "0",
        "idx": 3177
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int crypt_keyslot_add_by_keyfile_offset(struct crypt_device *cd,\n\tint keyslot,\n\tconst char *keyfile,\n\tsize_t keyfile_size,\n\tsize_t keyfile_offset,\n\tconst char *new_keyfile,\n\tsize_t new_keyfile_size,\n\tsize_t new_keyfile_offset)\n{\n\treturn crypt_keyslot_add_by_keyfile_device_offset(cd, keyslot,\n\t\t\t\tkeyfile, keyfile_size, keyfile_offset,\n\t\t\t\tnew_keyfile, new_keyfile_size, new_keyfile_offset);\n}",
        "output": "0",
        "idx": 1333
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cnt_recv_prep(struct req *req, const char *ci)\n{\n\tconst char *xff;\n\n\tif (req->restarts == 0) {\n\t\t/*\n\t\t * This really should be done earlier, but we want to capture\n\t\t * it in the VSL log.\n\t\t */\n\t\thttp_CollectHdr(req->http, H_X_Forwarded_For);\n\t\tif (http_GetHdr(req->http, H_X_Forwarded_For, &xff)) {\n\t\t\thttp_Unset(req->http, H_X_Forwarded_For);\n\t\t\thttp_PrintfHeader(req->http, \"X-Forwarded-For: %s, %s\",\n\t\t\t    xff, ci);\n\t\t} else {\n\t\t\thttp_PrintfHeader(req->http, \"X-Forwarded-For: %s\", ci);\n\t\t}\n\t\thttp_CollectHdr(req->http, H_Cache_Control);\n\n\t\t/* By default we use the first backend */\n\t\treq->director_hint = VCL_DefaultDirector(req->vcl);\n\n\t\treq->d_ttl = -1;\n\t\treq->d_grace = -1;\n\t\treq->disable_esi = 0;\n\t\treq->hash_always_miss = 0;\n\t\treq->hash_ignore_busy = 0;\n\t\treq->client_identity = NULL;\n\t\treq->storage = NULL;\n\t}\n\n\treq->vdc->retval = 0;\n\treq->is_hit = 0;\n\treq->is_hitmiss = 0;\n\treq->is_hitpass = 0;\n}",
        "output": "1",
        "idx": 2169
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rand_fork(void)\n{\n    rand_fork_count++;\n}",
        "output": "1",
        "idx": 1594
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)\n{\n\tunsigned long val;\n\tvoid *ptr = NULL;\n\n\tif (!atomic_pool) {\n\t\tWARN(1, \"coherent pool not initialised!\\n\");\n\t\treturn NULL;\n\t}\n\n\tval = gen_pool_alloc(atomic_pool, size);\n\tif (val) {\n\t\tphys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);\n\n\t\t*ret_page = phys_to_page(phys);\n\t\tptr = (void *)val;\n\t\tif (flags & __GFP_ZERO)\n\t\t\tmemset(ptr, 0, size);\n\t}\n\n\treturn ptr;\n}",
        "output": "1",
        "idx": 2117
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TiledInputFile::numYTiles (int ly) const\n{\n    if (ly < 0 || ly >= _data->numYLevels)\n    {\n        THROW (IEX_NAMESPACE::ArgExc, \"Error calling numYTiles() on image \"\n\t\t\t    \"file \\\"\" << _data->_streamData->is->fileName() << \"\\\" \"\n\t\t\t    \"(Argument is not in valid range).\");\n    }\n    \n    return _data->numYTiles[ly];\n}",
        "output": "0",
        "idx": 710
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n  output->type = input->type;\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input->dims);\n  return context->ResizeTensor(context, output, output_size);\n}",
        "output": "1",
        "idx": 1187
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "States& SSL::useStates()\n{\n    return states_;\n}",
        "output": "0",
        "idx": 912
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int show_slave_running(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_MY_BOOL;\n  var->value= buff;\n  *((my_bool *)buff)= (my_bool) (active_mi && \n                                 active_mi->slave_running == MYSQL_SLAVE_RUN_CONNECT &&\n                                 active_mi->rli.slave_running);\n  return 0;\n}",
        "output": "0",
        "idx": 2089
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "to_hash(mrb_state *mrb, mrb_value val)\n{\n  return check_type(mrb, val, MRB_TT_HASH, \"Hash\", \"to_hash\");\n}",
        "output": "0",
        "idx": 989
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "   OFB crypt/decrypt data using key key with cipher cipher starting with iv */\nPHP_FUNCTION(mcrypt_encrypt)\n{\n\tzval **mode;\n\tchar *cipher, *key, *data, *iv = NULL;\n\tint cipher_len, key_len, data_len, iv_len = 0;\n\t\n\tMCRYPT_GET_CRYPT_ARGS\n\t\n\tconvert_to_string_ex(mode);\n\n\tphp_mcrypt_do_crypt(cipher, key, key_len, data, data_len, Z_STRVAL_PP(mode), iv, iv_len, ZEND_NUM_ARGS(), MCRYPT_ENCRYPT, return_value TSRMLS_CC);",
        "output": "1",
        "idx": 3128
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int spl_object_storage_detach(spl_SplObjectStorage *intern, zval *this, zval *obj TSRMLS_DC) /* {{{ */\n{\n\tint hash_len, ret = FAILURE;\n\tchar *hash = spl_object_storage_get_hash(intern, this, obj, &hash_len TSRMLS_CC);\n\tif (!hash) {\n\t\treturn ret;\n\t}\n\tret = zend_hash_del(&intern->storage, hash, hash_len);\n\tspl_object_storage_free_hash(intern, hash);\n\t\n\treturn ret;\n} /* }}}*/",
        "output": "1",
        "idx": 1706
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "similar_sgr(char *a, char *b)\n{\n    bool result = FALSE;\n    if (a != 0 && b != 0) {\n\tint csi_a = is_csi(a);\n\tint csi_b = is_csi(b);\n\tsize_t len_a;\n\tsize_t len_b;\n\n\tTR(TRACE_DATABASE, (\"similar_sgr:\\n\\t%s\\n\\t%s\",\n\t\t\t    _nc_visbuf2(1, a),\n\t\t\t    _nc_visbuf2(2, b)));\n\tif (csi_a != 0 && csi_b != 0 && csi_a == csi_b) {\n\t    a += csi_a;\n\t    b += csi_b;\n\t    if (*a != *b) {\n\t\ta = skip_zero(a);\n\t\tb = skip_zero(b);\n\t    }\n\t}\n\tlen_a = strlen(a);\n\tlen_b = strlen(b);\n\tif (len_a && len_b) {\n\t    if (len_a > len_b)\n\t\tresult = (strncmp(a, b, len_b) == 0);\n\t    else\n\t\tresult = (strncmp(a, b, len_a) == 0);\n\t}\n\tTR(TRACE_DATABASE, (\"...similar_sgr: %d\\n\\t%s\\n\\t%s\", result,\n\t\t\t    _nc_visbuf2(1, a),\n\t\t\t    _nc_visbuf2(2, b)));\n    }\n    return result;\n}",
        "output": "0",
        "idx": 563
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST(WriterTest, WriteLongLong) {\n  CHECK_WRITE(56ll);\n  CHECK_WRITE(78ull);\n  CHECK_WRITE(std::numeric_limits<long long>::min());\n  CHECK_WRITE(std::numeric_limits<long long>::max());\n  CHECK_WRITE(std::numeric_limits<unsigned long long>::max());\n}",
        "output": "0",
        "idx": 2392
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int acp_early_init(void *handle)\n{\n\treturn 0;\n}",
        "output": "0",
        "idx": 3058
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_F(Http1ServerConnectionImplTest, ChunkedBody) {\n  initialize();\n\n  InSequence sequence;\n\n  MockRequestDecoder decoder;\n  EXPECT_CALL(callbacks_, newStream(_, _)).WillOnce(ReturnRef(decoder));\n\n  TestRequestHeaderMapImpl expected_headers{\n      {\":path\", \"/\"},\n      {\":method\", \"POST\"},\n      {\"transfer-encoding\", \"chunked\"},\n  };\n  EXPECT_CALL(decoder, decodeHeaders_(HeaderMapEqual(&expected_headers), false));\n  Buffer::OwnedImpl expected_data(\"Hello World\");\n  EXPECT_CALL(decoder, decodeData(BufferEqual(&expected_data), false));\n  // Call to decodeData(\"\", true) happens after.\n  Buffer::OwnedImpl empty(\"\");\n  EXPECT_CALL(decoder, decodeData(BufferEqual(&empty), true));\n\n  Buffer::OwnedImpl buffer(\"POST / HTTP/1.1\\r\\ntransfer-encoding: chunked\\r\\n\\r\\n\"\n                           \"6\\r\\nHello \\r\\n\"\n                           \"5\\r\\nWorld\\r\\n\"\n                           \"0\\r\\n\\r\\n\");\n  auto status = codec_->dispatch(buffer);\n  EXPECT_TRUE(status.ok());\n  EXPECT_EQ(0U, buffer.length());\n}",
        "output": "0",
        "idx": 82
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API RCmdDesc *r_cmd_desc_argv_new(RCmd *cmd, RCmdDesc *parent, const char *name, RCmdArgvCb cb, const RCmdDescHelp *help) {\n\tr_return_val_if_fail (cmd && parent && name, NULL);\n\treturn argv_new (cmd, parent, name, cb, help, true);\n}",
        "output": "0",
        "idx": 1189
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u64 blkg_prfill_rwstat_field(struct seq_file *sf,\n\t\t\t\t    struct blkg_policy_data *pd, int off)\n{\n\tstruct blkg_rwstat rwstat = blkg_rwstat_read((void *)pd->blkg + off);\n\n\treturn __blkg_prfill_rwstat(sf, pd, &rwstat);\n}",
        "output": "0",
        "idx": 3679
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_task_ioprio(struct task_struct *p)\n{\n\tint ret;\n\n\tret = security_task_getioprio(p);\n\tif (ret)\n\t\tgoto out;\n\tret = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, IOPRIO_NORM);\n\tif (p->io_context)\n\t\tret = p->io_context->ioprio;\nout:\n\treturn ret;\n}",
        "output": "1",
        "idx": 3407
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool netlink_net_capable(const struct sk_buff *skb, int cap)\n{\n\treturn netlink_ns_capable(skb, sock_net(skb->sk)->user_ns, cap);\n}",
        "output": "0",
        "idx": 1665
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_siocgstamp(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timeval ktv;\n\tint err;\n\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);\n\tset_fs(old_fs);\n\tif (!err)\n\t\terr = compat_put_timeval(up, &ktv);\n\n\treturn err;\n}",
        "output": "1",
        "idx": 783
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static size_t optsize (lua_State *L, char opt, const char **fmt) {\n  switch (opt) {\n    case 'B': case 'b': return sizeof(char);\n    case 'H': case 'h': return sizeof(short);\n    case 'L': case 'l': return sizeof(long);\n    case 'T': return sizeof(size_t);\n    case 'f':  return sizeof(float);\n    case 'd':  return sizeof(double);\n    case 'x': return 1;\n    case 'c': return getnum(L, fmt, 1);\n    case 'i': case 'I': {\n      int sz = getnum(L, fmt, sizeof(int));\n      if (sz > MAXINTSIZE)\n        luaL_error(L, \"integral size %d is larger than limit of %d\",\n                       sz, MAXINTSIZE);\n      return sz;\n    }\n    default: return 0;  /* other cases do not need alignment */\n  }\n}",
        "output": "1",
        "idx": 3284
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void visit(TokenBoundary &ope) override {\n    ope.ope_->accept(*this);\n    found_ope = tok(found_ope);\n  }",
        "output": "0",
        "idx": 2184
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline u8 cma_get_ip_ver(const struct cma_hdr *hdr)\n{\n\treturn hdr->ip_version >> 4;\n}",
        "output": "0",
        "idx": 1783
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)\n{\n\tstruct scm_fp_list *new_fpl;\n\tint i;\n\n\tif (!fpl)\n\t\treturn NULL;\n\n\tnew_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),\n\t\t\t  GFP_KERNEL);\n\tif (new_fpl) {\n\t\tfor (i = 0; i < fpl->count; i++)\n\t\t\tget_file(fpl->fp[i]);\n\t\tnew_fpl->max = new_fpl->count;\n\t}\n\treturn new_fpl;\n}",
        "output": "1",
        "idx": 1807
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "load_cache (GeglProperties *op_magick_load)\n{\n  if (!op_magick_load->user_data)\n    {\n      gchar    *filename;\n      gchar    *cmd;\n      GeglNode *graph, *sink, *loader;\n      GeglBuffer *newbuf = NULL;\n\n      /* ImageMagick backed fallback FIXME: make this robust.\n       * maybe use pipes in a manner similar to the raw loader,\n       * or at least use a properly unique filename  */\n\n      filename = g_build_filename (g_get_tmp_dir (), \"gegl-magick.png\", NULL);\n      cmd = g_strdup_printf (\"convert \\\"%s\\\"'[0]' \\\"%s\\\"\",\n                             op_magick_load->path, filename);\n      if (system (cmd) == -1)\n        g_warning (\"Error executing ImageMagick convert program\");\n\n\n      graph = gegl_node_new ();\n      sink = gegl_node_new_child (graph,\n                                 \"operation\", \"gegl:buffer-sink\",\n                                 \"buffer\", &newbuf, NULL);\n      loader = gegl_node_new_child (graph,\n                                    \"operation\", \"gegl:png-load\",\n                                    \"path\", filename, NULL);\n      gegl_node_link_many (loader, sink, NULL);\n      gegl_node_process (sink);\n      op_magick_load->user_data = (gpointer) newbuf;\n      g_object_unref (graph);\n      g_free (cmd);\n      g_free (filename);\n    }\n}",
        "output": "1",
        "idx": 515
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ossl_inline int cert_req_allowed(SSL *s)\n{\n    /* TLS does not like anon-DH with client cert */\n    if ((s->version > SSL3_VERSION\n         && (s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL))\n        || (s->s3->tmp.new_cipher->algorithm_auth & (SSL_aSRP | SSL_aPSK)))\n        return 0;\n\n    return 1;\n}",
        "output": "0",
        "idx": 2204
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vnc_tight_stop(VncState *vs)\n{\n    // switch back to normal output/zlib buffers\n    vs->tight.tight = vs->output;\n    vs->output = vs->tight.tmp;\n}",
        "output": "1",
        "idx": 1663
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_new_polygon (void)\n{\n    return rsvg_new_any_poly (FALSE);\n}",
        "output": "1",
        "idx": 1838
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n{\n        uint8* bufp = buf;\n        int32  bytes_read = 0;\n        uint16 strip, nstrips   = TIFFNumberOfStrips(in);\n        uint32 stripsize = TIFFStripSize(in);\n        uint32 rows = 0;\n        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n\n        for (strip = 0; strip < nstrips; strip++) {\n                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);\n                rows = bytes_read / scanline_size;\n                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))\n                        TIFFError(\"\", \"Strip %d: read %lu bytes, strip size %lu\",\n                                  (int)strip + 1, (unsigned long) bytes_read,\n                                  (unsigned long)stripsize);\n\n                if (bytes_read < 0 && !ignore) {\n                        TIFFError(\"\", \"Error reading strip %lu after %lu rows\",\n                                  (unsigned long) strip, (unsigned long)rows);\n                        return 0;\n                }\n                bufp += bytes_read;\n        }\n\n        return 1;\n} /* end readContigStripsIntoBuffer */",
        "output": "1",
        "idx": 1009
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    //! Wait for any event occuring either on the display \\c disp1, \\c disp2, \\c disp3, \\c disp4, ... \\c disp10.\n    static void wait(CImgDisplay& disp1, CImgDisplay& disp2, CImgDisplay& disp3, CImgDisplay& disp4, CImgDisplay& disp5,\n                     CImgDisplay& disp6, CImgDisplay& disp7, CImgDisplay& disp8, CImgDisplay& disp9,\n                     CImgDisplay& disp10) {\n      disp1._is_event = disp2._is_event = disp3._is_event = disp4._is_event = disp5._is_event =\n        disp6._is_event = disp7._is_event = disp8._is_event = disp9._is_event = disp10._is_event = false;\n      while ((!disp1._is_closed || !disp2._is_closed || !disp3._is_closed || !disp4._is_closed || !disp5._is_closed ||\n              !disp6._is_closed || !disp7._is_closed || !disp8._is_closed || !disp9._is_closed || !disp10._is_closed) &&\n             !disp1._is_event && !disp2._is_event && !disp3._is_event && !disp4._is_event && !disp5._is_event &&\n             !disp6._is_event && !disp7._is_event && !disp8._is_event && !disp9._is_event && !disp10._is_event)\n        wait_all();",
        "output": "0",
        "idx": 957
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,\n                                  RandomNumberGenerator& rng)\n   {\n   const BigInt& q = m_group.get_q();\n\n   BigInt i(msg, msg_len, q.bits());\n\n   while(i >= q)\n      i -= q;\n\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n   BOTAN_UNUSED(rng);\n   const BigInt k = generate_rfc6979_nonce(m_x, q, i, m_rfc6979_hash);\n#else\n   const BigInt k = BigInt::random_integer(rng, 1, q);\n#endif\n\n   BigInt s = inverse_mod(k, q);\n   const BigInt r = m_mod_q.reduce(m_group.power_g_p(k));\n\n   s = m_mod_q.multiply(s, mul_add(m_x, r, i));\n\n   // With overwhelming probability, a bug rather than actual zero r/s\n   if(r.is_zero() || s.is_zero())\n      throw Internal_Error(\"Computed zero r/s during DSA signature\");\n\n   return BigInt::encode_fixed_length_int_pair(r, s, q.bytes());\n   }",
        "output": "1",
        "idx": 2069
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "init_ext2_xattr(void)\n{\n\treturn 0;\n}",
        "output": "1",
        "idx": 2834
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": " */\nunsigned int skb_gso_transport_seglen(const struct sk_buff *skb)\n{\n\tconst struct skb_shared_info *shinfo = skb_shinfo(skb);\n\tunsigned int thlen = 0;\n\n\tif (skb->encapsulation) {\n\t\tthlen = skb_inner_transport_header(skb) -\n\t\t\tskb_transport_header(skb);\n\n\t\tif (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6)))\n\t\t\tthlen += inner_tcp_hdrlen(skb);\n\t} else if (likely(shinfo->gso_type & (SKB_GSO_TCPV4 | SKB_GSO_TCPV6))) {\n\t\tthlen = tcp_hdrlen(skb);\n\t} else if (unlikely(shinfo->gso_type & SKB_GSO_SCTP)) {\n\t\tthlen = sizeof(struct sctphdr);\n\t}\n\t/* UFO sets gso_size to the size of the fragmentation\n\t * payload, i.e. the size of the L4 (UDP) header is already\n\t * accounted for.\n\t */\n\treturn thlen + shinfo->gso_size;",
        "output": "0",
        "idx": 1955
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void slc_sync(void)\n{\n\tint i;\n\tstruct net_device *dev;\n\tstruct slcan\t  *sl;\n\n\tfor (i = 0; i < maxdev; i++) {\n\t\tdev = slcan_devs[i];\n\t\tif (dev == NULL)\n\t\t\tbreak;\n\n\t\tsl = netdev_priv(dev);\n\t\tif (sl->tty)\n\t\t\tcontinue;\n\t\tif (dev->flags & IFF_UP)\n\t\t\tdev_close(dev);\n\t}\n}",
        "output": "0",
        "idx": 3222
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "decode_sequence_of(const uint8_t *asn1, size_t len,\n                   const struct atype_info *elemtype, void **seq_out,\n                   size_t *count_out)\n{\n    krb5_error_code ret;\n    void *seq = NULL, *elem, *newseq;\n    const uint8_t *contents;\n    size_t clen, count = 0;\n    taginfo t;\n\n    *seq_out = NULL;\n    *count_out = 0;\n    while (len > 0) {\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        if (!check_atype_tag(elemtype, &t)) {\n            ret = ASN1_BAD_ID;\n            goto error;\n        }\n        newseq = realloc(seq, (count + 1) * elemtype->size);\n        if (newseq == NULL) {\n            ret = ENOMEM;\n            goto error;\n        }\n        seq = newseq;\n        elem = (char *)seq + count * elemtype->size;\n        memset(elem, 0, elemtype->size);\n        ret = decode_atype(&t, contents, clen, elemtype, elem);\n        if (ret)\n            goto error;\n        count++;\n    }\n    *seq_out = seq;\n    *count_out = count;\n    return 0;\n\nerror:\n    free_sequence_of(elemtype, seq, count);\n    free(seq);\n    return ret;\n}",
        "output": "1",
        "idx": 3145
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t auto_online_blocks_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\",\n\t\t       online_type_to_str[memhp_default_online_type]);\n}",
        "output": "1",
        "idx": 308
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Locked_tables_list::unlock_locked_table(THD *thd, MDL_ticket *mdl_ticket)\n{\n  /*\n    Ensure we are in locked table mode.\n    As this function is only called on error condition it's better\n    to check this condition here than in the caller.\n  */\n  if (thd->locked_tables_mode != LTM_LOCK_TABLES)\n    return;\n\n  if (mdl_ticket)\n  {\n    /*\n      Under LOCK TABLES we may have several instances of table open\n      and locked and therefore have to remove several metadata lock\n      requests associated with them.\n    */\n    thd->mdl_context.release_all_locks_for_name(mdl_ticket);\n  }\n\n  if (thd->lock->table_count == 0)\n    unlock_locked_tables(thd);\n}",
        "output": "0",
        "idx": 1822
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Node *gf_sg_find_node(GF_SceneGraph *sg, u32 nodeID)\n{\n\tNodeIDedItem *reg_node = sg->id_node;\n\twhile (reg_node) {\n\t\tif (reg_node->NodeID == nodeID) return reg_node->node;\n\t\treg_node = reg_node->next;\n\t}\n\treturn NULL;\n}",
        "output": "0",
        "idx": 2881
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "EIGEN_STRONG_INLINE QInt32 operator+(const QInt8 a, const QInt32 b) {\n  return QInt32(static_cast<int32_t>(a.value) + b.value);\n}",
        "output": "0",
        "idx": 1334
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(bcsqrt)\n{\n\tchar *left;\n\tint left_len;\n\tlong scale_param = 0;\n\tbc_num result;\n\tint scale = BCG(bc_precision), argc = ZEND_NUM_ARGS();\n\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"s|l\", &left, &left_len, &scale_param) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (argc == 2) {\n\t\tscale = (int) ((int)scale_param < 0) ? 0 : scale_param;\n\t}\n\n\tbc_init_num(&result TSRMLS_CC);\n\tphp_str2num(&result, left TSRMLS_CC);\n\n\tif (bc_sqrt (&result, scale TSRMLS_CC) != 0) {\n\t\tif (result->n_scale > scale) {\n\t\t\tresult = split_bc_num(result);\n\t\t\tresult->n_scale = scale;\n\t\t}\n\t\tZ_STRVAL_P(return_value) = bc_num2str(result);\n\t\tZ_STRLEN_P(return_value) = strlen(Z_STRVAL_P(return_value));\n\t\tZ_TYPE_P(return_value) = IS_STRING;\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Square root of negative number\");\n\t}\n\n\tbc_free_num(&result);\n\treturn;\n}",
        "output": "0",
        "idx": 1172
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "napi_status napi_get_value_string_utf16(napi_env env,\n                                        napi_value value,\n                                        char16_t* buf,\n                                        size_t bufsize,\n                                        size_t* result) {\n  CHECK_ENV(env);\n  CHECK_ARG(env, value);\n\n  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);\n  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);\n\n  if (!buf) {\n    CHECK_ARG(env, result);\n    // V8 assumes UTF-16 length is the same as the number of characters.\n    *result = val.As<v8::String>()->Length();\n  } else {\n    int copied = val.As<v8::String>()->Write(env->isolate,\n                                             reinterpret_cast<uint16_t*>(buf),\n                                             0,\n                                             bufsize - 1,\n                                             v8::String::NO_NULL_TERMINATION);\n\n    buf[copied] = '\\0';\n    if (result != nullptr) {\n      *result = copied;\n    }\n  }\n\n  return napi_clear_last_error(env);\n}",
        "output": "1",
        "idx": 722
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_report_kpp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_kpp rkpp;\n\n\tstrlcpy(rkpp.type, \"kpp\", sizeof(rkpp.type));\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_KPP,\n\t\t    sizeof(struct crypto_report_kpp), &rkpp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "1",
        "idx": 1264
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_end_element (void *data, const xmlChar * name)\n{\n    RsvgHandle *ctx = (RsvgHandle *) data;\n\n    if (ctx->priv->handler_nest > 0 && ctx->priv->handler != NULL) {\n        if (ctx->priv->handler->end_element != NULL)\n            ctx->priv->handler->end_element (ctx->priv->handler, (const char *) name);\n        ctx->priv->handler_nest--;\n    } else {\n        const char *tempname;\n        for (tempname = (const char *) name; *tempname != '\\0'; tempname++)\n            if (*tempname == ':')\n                name = (const xmlChar *) (tempname + 1);\n\n        if (ctx->priv->handler != NULL) {\n            ctx->priv->handler->free (ctx->priv->handler);\n            ctx->priv->handler = NULL;\n        }\n\n        if (ctx->priv->currentnode\n            && !strcmp ((const char *) name, ctx->priv->currentnode->type->str))\n            rsvg_pop_def_group (ctx);\n\n        if (ctx->priv->treebase && !strcmp ((const char *)name, \"svg\"))\n            _rsvg_node_svg_apply_atts ((RsvgNodeSvg *)ctx->priv->treebase, ctx);\n    }\n}",
        "output": "1",
        "idx": 3379
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BOOL ntlm_av_pair_add_copy(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList,\n                                  NTLM_AV_PAIR* pAvPair, size_t cbAvPair)\n{\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\treturn FALSE;\n\n\treturn ntlm_av_pair_add(pAvPairList, cbAvPairList, ntlm_av_pair_get_id(pAvPair),\n\t                        ntlm_av_pair_get_value_pointer(pAvPair), ntlm_av_pair_get_len(pAvPair));\n}",
        "output": "1",
        "idx": 2698
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct sock * unix_create1(struct socket *sock)\n{\n\tstruct sock *sk = NULL;\n\tstruct unix_sock *u;\n\n\tif (atomic_read(&unix_nr_socks) >= 2*get_max_files())\n\t\tgoto out;\n\n\tsk = sk_alloc(PF_UNIX, GFP_KERNEL, &unix_proto, 1);\n\tif (!sk)\n\t\tgoto out;\n\n\tatomic_inc(&unix_nr_socks);\n\n\tsock_init_data(sock,sk);\n\tlockdep_set_class(&sk->sk_receive_queue.lock,\n\t\t\t\t&af_unix_sk_receive_queue_lock_key);\n\n\tsk->sk_write_space\t= unix_write_space;\n\tsk->sk_max_ack_backlog\t= sysctl_unix_max_dgram_qlen;\n\tsk->sk_destruct\t\t= unix_sock_destructor;\n\tu\t  = unix_sk(sk);\n\tu->dentry = NULL;\n\tu->mnt\t  = NULL;\n\tspin_lock_init(&u->lock);\n\tatomic_set(&u->inflight, sock ? 0 : -1);\n\tmutex_init(&u->readlock); /* single task reading lock */\n\tinit_waitqueue_head(&u->peer_wait);\n\tunix_insert_socket(unix_sockets_unbound, sk);\nout:\n\treturn sk;\n}",
        "output": "1",
        "idx": 1076
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs4_xdr_enc_getacl(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tstruct nfs_getaclargs *args)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\tuint32_t replen;\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\treplen = hdr.replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1;\n\tencode_getattr_two(xdr, FATTR4_WORD0_ACL, 0, &hdr);\n\n\txdr_inline_pages(&req->rq_rcv_buf, replen << 2,\n\t\targs->acl_pages, args->acl_pgbase, args->acl_len);\n\tencode_nops(&hdr);\n}",
        "output": "1",
        "idx": 3131
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void csi_X(struct vc_data *vc, unsigned int vpar)\n{\t\t\t\t\t  /* not vt100? */\n\tunsigned int count;\n\n\tif (!vpar)\n\t\tvpar++;\n\n\tcount = min(vpar, vc->vc_cols - vc->state.x);\n\n\tvc_uniscr_clear_line(vc, vc->state.x, count);\n\tscr_memsetw((unsigned short *)vc->vc_pos, vc->vc_video_erase_char, 2 * count);\n\tif (con_should_update(vc))\n\t\tvc->vc_sw->con_clear(vc, vc->state.y, vc->state.x, 1, count);\n\tvc->vc_need_wrap = 0;\n}",
        "output": "0",
        "idx": 3098
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "  void MoveIndexIfNecessary(HValue* index_raw,\n                            HBoundsCheck* insert_before,\n                            HInstruction* end_of_scan_range) {\n    ASSERT(index_raw->IsAdd() || index_raw->IsSub());\n    HBinaryOperation* index =\n        HArithmeticBinaryOperation::cast(index_raw);\n    HValue* left_input = index->left();\n    HValue* right_input = index->right();\n    bool must_move_index = false;\n    bool must_move_left_input = false;\n    bool must_move_right_input = false;\n    for (HInstruction* cursor = end_of_scan_range; cursor != insert_before;) {\n      if (cursor == left_input) must_move_left_input = true;\n      if (cursor == right_input) must_move_right_input = true;\n      if (cursor == index) must_move_index = true;\n      if (cursor->previous() == NULL) {\n        cursor = cursor->block()->dominator()->end();\n      } else {\n        cursor = cursor->previous();\n      }\n    }\n\n    // The BCE algorithm only selects mergeable bounds checks that share\n    // the same \"index_base\", so we'll only ever have to move constants.\n    if (must_move_left_input) {\n      HConstant::cast(left_input)->Unlink();\n      HConstant::cast(left_input)->InsertBefore(index);\n    }\n    if (must_move_right_input) {\n      HConstant::cast(right_input)->Unlink();\n      HConstant::cast(right_input)->InsertBefore(index);\n    }\n  }",
        "output": "1",
        "idx": 1856
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "g_vfs_daemon_finalize (GObject *object)\n{\n  GVfsDaemon *daemon;\n\n  daemon = G_VFS_DAEMON (object);\n\n  /* There may be some jobs outstanding if we've been force unmounted. */\n  if (daemon->jobs)\n    g_warning (\"daemon->jobs != NULL when finalizing daemon!\");\n\n  if (daemon->name_watcher)\n    g_bus_unwatch_name (daemon->name_watcher);\n  \n  if (daemon->daemon_skeleton != NULL)\n    {\n      g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (daemon->daemon_skeleton));\n      g_object_unref (daemon->daemon_skeleton);\n    }\n  if (daemon->mountable_skeleton != NULL)\n    {\n      g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (daemon->mountable_skeleton));\n      g_object_unref (daemon->mountable_skeleton);\n    }\n  if (daemon->conn != NULL)\n    g_object_unref (daemon->conn);\n  \n  g_hash_table_destroy (daemon->registered_paths);\n  g_hash_table_destroy (daemon->client_connections);\n  g_mutex_clear (&daemon->lock);\n\n  if (G_OBJECT_CLASS (g_vfs_daemon_parent_class)->finalize)\n    (*G_OBJECT_CLASS (g_vfs_daemon_parent_class)->finalize) (object);\n}",
        "output": "1",
        "idx": 1248
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void _mutt_mktemp (char *s, size_t slen, const char *src, int line)\n{\n  snprintf (s, slen, \"%s/mutt-%s-%d-%d-%d\", NONULL (Tempdir), NONULL(Hostname), (int) getuid(), (int) getpid (), Counter++);\n  dprint (3, (debugfile, \"%s:%d: mutt_mktemp returns \\\"%s\\\".\\n\", src, line, s));\n  unlink (s);\n}",
        "output": "1",
        "idx": 339
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline const unsigned char *ReadResourceLong(const unsigned char *p,\n  unsigned int *quantum)\n{\n  *quantum=(size_t) (*p++ << 24);\n  *quantum|=(size_t) (*p++ << 16);\n  *quantum|=(size_t) (*p++ << 8);\n  *quantum|=(size_t) (*p++ << 0);\n  return(p);\n}",
        "output": "1",
        "idx": 3449
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ArgParser::argShowEncryptionKey()\n{\n    o.show_encryption_key = true;\n}",
        "output": "0",
        "idx": 1177
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static SQInteger base_collectgarbage(HSQUIRRELVM v)\n{\n    sq_pushinteger(v, sq_collectgarbage(v));\n    return 1;\n}",
        "output": "0",
        "idx": 3043
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void FVMenuGlyphsSplines(GWindow gw, struct gmenuitem *UNUSED(mi), GEvent *e) {\n    FontView *fv = (FontView *) GDrawGetUserData(gw);\n    int i, gid, doit;\n    EncMap *map = fv->b.map;\n    SplineFont *sf = fv->b.sf;\n    int merge = SelMergeType(e);\n    int layer = fv->b.active_layer;\n\n    for ( i=0; i< map->enccount; ++i ) {\n\tdoit = ( (gid=map->map[i])!=-1 && sf->glyphs[gid]!=NULL &&\n\t\tsf->glyphs[gid]->layers[layer].refs==NULL &&\n\t\tsf->glyphs[gid]->layers[layer].splines!=NULL );\n\tfv->b.selected[i] = mergefunc[ merge + (fv->b.selected[i]?2:0) + doit ];\n    }\n    GDrawRequestExpose(fv->v,NULL,false);\n}",
        "output": "0",
        "idx": 1668
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ipt_get_target_c(s);\n\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t/* Head of user chain: ERROR target with chainname */\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\n\t\tif (s->target_offset == sizeof(struct ipt_entry) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t   t->verdict < 0 &&\n\t\t   unconditional(&s->ip)) {\n\t\t\t/* Tail of chains: STANDARD target (return/policy) */\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1510
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void set_linear_hash_mask(partition_info *part_info, uint num_parts)\n{\n  uint mask;\n\n  for (mask= 1; mask < num_parts; mask<<=1)\n    ;\n  part_info->linear_hash_mask= mask - 1;\n}",
        "output": "0",
        "idx": 3110
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rx_cache_insert(netdissect_options *ndo,\n                const u_char *bp, const struct ip *ip, int dport)\n{\n\tstruct rx_cache_entry *rxent;\n\tconst struct rx_header *rxh = (const struct rx_header *) bp;\n\n\tif (ndo->ndo_snapend - bp + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t)))\n\t\treturn;\n\n\trxent = &rx_cache[rx_cache_next];\n\n\tif (++rx_cache_next >= RX_CACHE_SIZE)\n\t\trx_cache_next = 0;\n\n\trxent->callnum = EXTRACT_32BITS(&rxh->callNumber);\n\tUNALIGNED_MEMCPY(&rxent->client, &ip->ip_src, sizeof(uint32_t));\n\tUNALIGNED_MEMCPY(&rxent->server, &ip->ip_dst, sizeof(uint32_t));\n\trxent->dport = dport;\n\trxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);\n\trxent->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header));\n}",
        "output": "1",
        "idx": 1857
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "com_quit(String *buffer __attribute__((unused)),\n\t char *line __attribute__((unused)))\n{\n  status.exit_status=0;\n  return 1;\n}",
        "output": "0",
        "idx": 128
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void init_xml_relax_ng()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"RelaxNG\", cNokogiriXmlSchema);\n\n  cNokogiriXmlRelaxNG = klass;\n\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n}",
        "output": "1",
        "idx": 3253
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,\n        bigint *modulus, bigint *pub_exp)\n{\n    int i, size;\n    bigint *decrypted_bi, *dat_bi;\n    bigint *bir = NULL;\n    uint8_t *block = (uint8_t *)malloc(sig_len);\n\n    /* decrypt */\n    dat_bi = bi_import(ctx, sig, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    /* convert to a normal block */\n    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);\n\n    bi_export(ctx, decrypted_bi, block, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    i = 10; /* start at the first possible non-padded byte */\n    while (block[i++] && i < sig_len);\n    size = sig_len - i;\n\n    /* get only the bit we want */\n    if (size > 0)\n    {\n        int len;\n        const uint8_t *sig_ptr = get_signature(&block[i], &len);\n\n        if (sig_ptr)\n        {\n            bir = bi_import(ctx, sig_ptr, len);\n        }\n    }\n    free(block);\n    /* save a few bytes of memory */\n    bi_clear_cache(ctx);\n    return bir;\n}",
        "output": "1",
        "idx": 2164
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *path_name(struct name_path *path, const char *name)\n{\n\tstruct name_path *p;\n\tchar *n, *m;\n\tint nlen = strlen(name);\n\tint len = nlen + 1;\n\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len)\n\t\t\tlen += p->elem_len + 1;\n\t}\n\tn = xmalloc(len);\n\tm = n + len - (nlen + 1);\n\tstrcpy(m, name);\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len) {\n\t\t\tm -= p->elem_len + 1;\n\t\t\tmemcpy(m, p->elem, p->elem_len);\n\t\t\tm[p->elem_len] = '/';\n\t\t}\n\t}\n\treturn n;\n}",
        "output": "0",
        "idx": 1125
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int tcp_sendpage_locked(struct sock *sk, struct page *page, int offset,\n\t\t\tsize_t size, int flags)\n{\n\tif (!(sk->sk_route_caps & NETIF_F_SG))\n\t\treturn sock_no_sendpage_locked(sk, page, offset, size, flags);\n\n\ttcp_rate_check_app_limited(sk);  /* is sending application-limited? */\n\n\treturn do_tcp_sendpages(sk, page, offset, size, flags);\n}",
        "output": "0",
        "idx": 756
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int task_get_unused_fd_flags(struct binder_proc *proc, int flags)\n{\n\tunsigned long rlim_cur;\n\tunsigned long irqs;\n\tint ret;\n\n\tmutex_lock(&proc->files_lock);\n\tif (proc->files == NULL) {\n\t\tret = -ESRCH;\n\t\tgoto err;\n\t}\n\tif (!lock_task_sighand(proc->tsk, &irqs)) {\n\t\tret = -EMFILE;\n\t\tgoto err;\n\t}\n\trlim_cur = task_rlimit(proc->tsk, RLIMIT_NOFILE);\n\tunlock_task_sighand(proc->tsk, &irqs);\n\n\tret = __alloc_fd(proc->files, 0, rlim_cur, flags);\nerr:\n\tmutex_unlock(&proc->files_lock);\n\treturn ret;\n}",
        "output": "0",
        "idx": 828
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "m_sg(union DateData *x)\n{\n    if (simple_dat_p(x))\n\treturn x->s.sg;\n    else {\n\tget_c_jd(x);\n\treturn x->c.sg;\n    }\n}",
        "output": "0",
        "idx": 2982
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int credssp_ntlm_server_init(rdpCredssp* credssp)\n{\n\tfreerdp* instance;\n\trdpSettings* settings = credssp->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tsspi_SecBufferAlloc(&credssp->PublicKey, credssp->transport->TlsIn->PublicKeyLength);\n\tCopyMemory(credssp->PublicKey.pvBuffer, credssp->transport->TlsIn->PublicKey, credssp->transport->TlsIn->PublicKeyLength);\n\n\treturn 1;\n}",
        "output": "0",
        "idx": 2314
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)\n{\n\tunsigned char\t *b = skb->tail;\n\tstruct tc_cbq_ovl opt;\n\n\topt.strategy = cl->ovl_strategy;\n\topt.priority2 = cl->priority2+1;\n\topt.penalty = (cl->penalty*1000)/HZ;\n\tRTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);\n\treturn skb->len;\n\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}",
        "output": "1",
        "idx": 1240
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_temp;\n\n        for (i=0;i<p_nb_elem;++i) {\n                opj_read_bytes(l_src_data,&l_temp,4);\n\n                l_src_data+=sizeof(OPJ_INT32);\n\n                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;\n        }\n}",
        "output": "0",
        "idx": 1001
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static double filter_filter(double t)\n{\n\t/* f(t) = 2|t|^3 - 3|t|^2 + 1, -1 <= t <= 1 */\n\tif(t < 0.0) t = -t;\n\tif(t < 1.0) return((2.0 * t - 3.0) * t * t + 1.0);\n\treturn(0.0);\n}",
        "output": "0",
        "idx": 2429
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST_P(SslCertficateIntegrationTest, ServerRsaClientEcdsaOnly) {\n  server_rsa_cert_ = true;\n  server_ecdsa_cert_ = false;\n  client_ecdsa_cert_ = true;\n  initialize();\n  EXPECT_FALSE(\n      makeRawHttpConnection(makeSslClientConnection(ecdsaOnlyClientOptions()))->connected());\n  const std::string counter_name = listenerStatPrefix(\"ssl.connection_error\");\n  Stats::CounterSharedPtr counter = test_server_->counter(counter_name);\n  test_server_->waitForCounterGe(counter_name, 1);\n  EXPECT_EQ(1U, counter->value());\n  counter->reset();\n}",
        "output": "1",
        "idx": 1296
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void StreamEncoderImpl::encodeTrailersBase(const HeaderMap& trailers) {\n  if (!connection_.enableTrailers()) {\n    return endEncode();\n  }\n  // Trailers only matter if it is a chunk transfer encoding\n  // https://tools.ietf.org/html/rfc7230#section-4.4\n  if (chunk_encoding_) {\n    // Finalize the body\n    connection_.buffer().add(LAST_CHUNK);\n\n    trailers.iterate(\n        [](const HeaderEntry& header, void* context) -> HeaderMap::Iterate {\n          static_cast<StreamEncoderImpl*>(context)->encodeFormattedHeader(\n              header.key().getStringView(), header.value().getStringView());\n          return HeaderMap::Iterate::Continue;\n        },\n        this);\n\n    connection_.flushOutput();\n    connection_.buffer().add(CRLF);\n  }\n\n  connection_.flushOutput();\n  connection_.onEncodeComplete();\n}",
        "output": "0",
        "idx": 397
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static pyc_object *get_short_ascii_interned_object(RBuffer *buffer) {\n\tbool error = false;\n\tut8 n = get_ut8 (buffer, &error);\n\treturn error? NULL: get_ascii_object_generic (buffer, n, true);\n}",
        "output": "0",
        "idx": 1774
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rsvg_handle_write_impl (RsvgHandle * handle, const guchar * buf, gsize count, GError ** error)\n{\n    GError *real_error = NULL;\n    int result;\n\n    rsvg_return_val_if_fail (handle != NULL, FALSE, error);\n\n    handle->priv->error = &real_error;\n    if (handle->priv->ctxt == NULL) {\n        handle->priv->ctxt = xmlCreatePushParserCtxt (&rsvgSAXHandlerStruct, handle, NULL, 0,\n                                                      rsvg_handle_get_base_uri (handle));\n\n        /* if false, external entities work, but internal ones don't. if true, internal entities\n           work, but external ones don't. favor internal entities, in order to not cause a\n           regression */\n        handle->priv->ctxt->replaceEntities = TRUE;\n    }\n\n    result = xmlParseChunk (handle->priv->ctxt, (char *) buf, count, 0);\n    if (result != 0) {\n        rsvg_set_error (error, handle->priv->ctxt);\n        return FALSE;\n    }\n\n    handle->priv->error = NULL;\n\n    if (real_error != NULL) {\n        g_propagate_error (error, real_error);\n        return FALSE;\n    }\n\n    return TRUE;\n}",
        "output": "1",
        "idx": 45
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "print_arrays_for(char *set)\n{\n  FILE *f;\n\n  sprintf(buf, \"%s.conf\", set);\n\n  if ((f = fopen(buf, \"r\")) == NULL) {\n    fprintf(stderr, \"%s: can't read conf file for charset %s\\n\", prog, set);\n    exit(EXIT_FAILURE);\n  }\n\n  printf(\"\\\n/* The %s character set.  Generated automatically by configure and\\n\\\n * the %s program\\n\\\n */\\n\\n\",\n\t set, prog);\n\n  /* it would be nice if this used the code in mysys/charset.c, but... */\n  print_array(f, set, \"ctype\",      CTYPE_TABLE_SIZE);\n  print_array(f, set, \"to_lower\",   TO_LOWER_TABLE_SIZE);\n  print_array(f, set, \"to_upper\",   TO_UPPER_TABLE_SIZE);\n  print_array(f, set, \"sort_order\", SORT_ORDER_TABLE_SIZE);\n  printf(\"\\n\");\n\n  fclose(f);\n\n  return;\n}",
        "output": "1",
        "idx": 2892
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Magick::Image::read(MagickCore::Image *image,\n  MagickCore::ExceptionInfo *exceptionInfo)\n{\n  // Ensure that multiple image frames were not read.\n  if (image != (MagickCore::Image *) NULL &&\n      image->next != (MagickCore::Image *) NULL)\n    {\n      MagickCore::Image\n        *next;\n\n      // Destroy any extra image frames\n      next=image->next;\n      image->next=(MagickCore::Image *) NULL;\n      next->previous=(MagickCore::Image *) NULL;\n      DestroyImageList(next);\n    }\n  replaceImage(image);\n  if (exceptionInfo->severity == MagickCore::UndefinedException &&\n      image == (MagickCore::Image *) NULL)\n    {\n      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);\n      if (!quiet())\n        throwExceptionExplicit(MagickCore::ImageWarning,\n          \"No image was loaded.\");\n    }\n  ThrowImageException;\n}",
        "output": "1",
        "idx": 2285
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *get_header(FILE *fp)\n{\n    long start;\n\n    /* First 1024 bytes of doc must be header (1.7 spec pg 1102) */\n    char *header;\n\n    header = calloc(1, 1024);\n    \n    start = ftell(fp);\n    fseek(fp, 0, SEEK_SET);\n    SAFE_E(fread(header, 1, 1023, fp), 1023, \"Failed to load PDF header.\\n\");\n    fseek(fp, start, SEEK_SET);\n    \n    return header;\n}",
        "output": "1",
        "idx": 1973
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t type_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct cacheinfo *this_leaf = dev_get_drvdata(dev);\n\n\tswitch (this_leaf->type) {\n\tcase CACHE_TYPE_DATA:\n\t\treturn sprintf(buf, \"Data\\n\");\n\tcase CACHE_TYPE_INST:\n\t\treturn sprintf(buf, \"Instruction\\n\");\n\tcase CACHE_TYPE_UNIFIED:\n\t\treturn sprintf(buf, \"Unified\\n\");\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
        "output": "1",
        "idx": 883
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int selinux_msg_msg_alloc_security(struct msg_msg *msg)\n{\n\tstruct msg_security_struct *msec;\n\n\tmsec = selinux_msg_msg(msg);\n\tmsec->sid = SECINITSID_UNLABELED;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2512
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline unsigned int ScaleQuantumToLong(const Quantum quantum)\n{\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  return((unsigned int) (65537UL*quantum));\n#else\n  if (quantum <= 0.0)\n    return(0UL);\n  if ((65537.0*quantum) >= 4294967295.0)\n    return(4294967295U);\n  return((unsigned int) (65537.0*quantum+0.5));\n#endif\n}",
        "output": "1",
        "idx": 740
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TEST(ExpressionObjectParse, ShouldAcceptNestedObjects) {\n    intrusive_ptr<ExpressionContextForTest> expCtx(new ExpressionContextForTest());\n    VariablesParseState vps = expCtx->variablesParseState;\n    auto object =\n        ExpressionObject::parse(expCtx, fromjson(\"{a: {b: 1}, c: {d: {e: 1, f: 1}}}\"), vps);\n    auto expectedResult =\n        Value(Document{{\"a\", Document{{\"b\", literal(1)}}},\n                       {\"c\", Document{{\"d\", Document{{\"e\", literal(1)}, {\"f\", literal(1)}}}}}});\n    ASSERT_VALUE_EQ(expectedResult, object->serialize(false));\n}",
        "output": "0",
        "idx": 3724
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void php_array_element_export(zval *zv, zend_ulong index, zend_string *key, int level, smart_str *buf) /* {{{ */\n{\n\tif (key == NULL) { /* numeric key */\n\t\tbuffer_append_spaces(buf, level+1);\n\t\tsmart_str_append_long(buf, (zend_long) index);\n\t\tsmart_str_appendl(buf, \" => \", 4);\n\n\t} else { /* string key */\n\t\tzend_string *tmp_str;\n\t\tzend_string *ckey = php_addcslashes(key, 0, \"'\\\\\", 2);\n\t\ttmp_str = php_str_to_str(ZSTR_VAL(ckey), ZSTR_LEN(ckey), \"\\0\", 1, \"' . \\\"\\\\0\\\" . '\", 12);\n\n\t\tbuffer_append_spaces(buf, level + 1);\n\n\t\tsmart_str_appendc(buf, '\\'');\n\t\tsmart_str_append(buf, tmp_str);\n\t\tsmart_str_appendl(buf, \"' => \", 5);\n\n\t\tzend_string_free(ckey);\n\t\tzend_string_free(tmp_str);\n\t}\n\tphp_var_export_ex(zv, level + 2, buf);\n\n\tsmart_str_appendc(buf, ',');\n\tsmart_str_appendc(buf, '\\n');\n}",
        "output": "0",
        "idx": 3440
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char * gf_get_default_cache_directory() {\n\tchar szPath[GF_MAX_PATH];\n\tchar* root_tmp;\n\tsize_t len;\n#ifdef _WIN32_WCE\n\tstrcpy(szPath, \"\\\\windows\\\\temp\" );\n#elif defined(WIN32)\n\tGetTempPath(GF_MAX_PATH, szPath);\n#else\n\tstrcpy(szPath, \"/tmp\");\n#endif\n\n\troot_tmp = gf_strdup(szPath);\n\n\tlen = strlen(szPath);\n\tif (szPath[len-1] != GF_PATH_SEPARATOR) {\n\t\tszPath[len] = GF_PATH_SEPARATOR;\n\t\tszPath[len+1] = 0;\n\t}\n\n\tstrcat(szPath, \"gpac_cache\");\n\n\tif ( !gf_dir_exists(szPath) && gf_mkdir(szPath)!=GF_OK ) {\n\t\treturn root_tmp;\n\t}\n\n\tgf_free(root_tmp);\n\treturn gf_strdup(szPath);\n}",
        "output": "0",
        "idx": 360
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void plist_bin_init(void)\n{\n    /* init binary plist stuff */\n#ifdef DEBUG\n    char *env_debug = getenv(\"PLIST_BIN_DEBUG\");\n    if (env_debug && !strcmp(env_debug, \"1\")) {\n        plist_bin_debug = 1;\n    }\n#endif\n}",
        "output": "0",
        "idx": 3339
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void io_mem_init(void)\n{\n    memory_region_init_io(&io_mem_rom, NULL, &unassigned_mem_ops, NULL, NULL, UINT64_MAX);\n    memory_region_init_io(&io_mem_unassigned, NULL, &unassigned_mem_ops, NULL,\n                          NULL, UINT64_MAX);\n\n    /* io_mem_notdirty calls tb_invalidate_phys_page_fast,\n     * which can be called without the iothread mutex.\n     */\n    memory_region_init_io(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,\n                          NULL, UINT64_MAX);\n    memory_region_clear_global_locking(&io_mem_notdirty);\n\n    memory_region_init_io(&io_mem_watch, NULL, &watch_mem_ops, NULL,\n                          NULL, UINT64_MAX);\n}",
        "output": "0",
        "idx": 247
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ClientHandler::read_tls() {\n  ERR_clear_error();\n\n  rb_.ensure_chunk();\n\n  for (;;) {\n    // we should process buffered data first before we read EOF.\n    if (rb_.rleft() && on_read() != 0) {\n      return -1;\n    }\n    if (rb_.rleft() == 0) {\n      rb_.reset();\n    } else if (rb_.wleft() == 0) {\n      conn_.rlimit.stopw();\n      return 0;\n    }\n\n    if (!ev_is_active(&conn_.rev)) {\n      return 0;\n    }\n\n    auto nread = conn_.read_tls(rb_.last(), rb_.wleft());\n\n    if (nread == 0) {\n      if (rb_.rleft() == 0) {\n        rb_.release_chunk();\n      }\n      return 0;\n    }\n\n    if (nread < 0) {\n      return -1;\n    }\n\n    rb_.write(nread);\n  }\n}",
        "output": "1",
        "idx": 2139
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "asn1_get_octet_der (const unsigned char *der, int der_len,\n\t\t    int *ret_len, unsigned char *str, int str_size,\n\t\t    int *str_len)\n{\n  int len_len = 0;\n\n  if (der_len <= 0)\n    return ASN1_GENERIC_ERROR;\n\n  /* if(str==NULL) return ASN1_SUCCESS; */\n  *str_len = asn1_get_length_der (der, der_len, &len_len);\n\n  if (*str_len < 0)\n    return ASN1_DER_ERROR;\n\n  *ret_len = *str_len + len_len;\n  if (str_size >= *str_len)\n    {\n      if (*str_len > 0)\n        memcpy (str, der + len_len, *str_len);\n    }\n  else\n    {\n      return ASN1_MEM_ERROR;\n    }\n\n  return ASN1_SUCCESS;\n}",
        "output": "1",
        "idx": 3569
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void calipso_doi_putdef(struct calipso_doi *doi_def)\n{\n\tif (!doi_def)\n\t\treturn;\n\n\tif (!refcount_dec_and_test(&doi_def->refcount))\n\t\treturn;\n\tspin_lock(&calipso_doi_list_lock);\n\tlist_del_rcu(&doi_def->list);\n\tspin_unlock(&calipso_doi_list_lock);\n\n\tcall_rcu(&doi_def->rcu, calipso_doi_free_rcu);\n}",
        "output": "1",
        "idx": 605
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct dst_entry *rxe_find_route6(struct net_device *ndev,\n\t\t\t\t\t struct in6_addr *saddr,\n\t\t\t\t\t struct in6_addr *daddr)\n{\n\tstruct dst_entry *ndst;\n\tstruct flowi6 fl6 = { { 0 } };\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_oif = ndev->ifindex;\n\tmemcpy(&fl6.saddr, saddr, sizeof(*saddr));\n\tmemcpy(&fl6.daddr, daddr, sizeof(*daddr));\n\tfl6.flowi6_proto = IPPROTO_UDP;\n\n\tif (unlikely(ipv6_stub->ipv6_dst_lookup(sock_net(recv_sockets.sk6->sk),\n\t\t\t\t\t\trecv_sockets.sk6->sk, &ndst, &fl6))) {\n\t\tpr_err_ratelimited(\"no route to %pI6\\n\", daddr);\n\t\tgoto put;\n\t}\n\n\tif (unlikely(ndst->error)) {\n\t\tpr_err(\"no route to %pI6\\n\", daddr);\n\t\tgoto put;\n\t}\n\n\treturn ndst;\nput:\n\tdst_release(ndst);\n\treturn NULL;\n}",
        "output": "1",
        "idx": 885
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int trust_1oidany(X509_TRUST *trust, X509 *x, int flags)\n{\n    if (x->aux && (x->aux->trust || x->aux->reject))\n        return obj_trust(trust->arg1, x, flags);\n    /*\n     * we don't have any trust settings: for compatibility we return trusted\n     * if it is self signed\n     */\n    return trust_compat(trust, x, flags);\n}",
        "output": "1",
        "idx": 1185
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, quality);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}",
        "output": "1",
        "idx": 1725
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean cosine_read(wtap *wth, int *err, gchar **err_info,\n    gint64 *data_offset)\n{\n\tgint64\toffset;\n\tint\tpkt_len;\n\tchar\tline[COSINE_LINE_LENGTH];\n\n\t/* Find the next packet */\n\toffset = cosine_seek_next_packet(wth, err, err_info, line);\n\tif (offset < 0)\n\t\treturn FALSE;\n\t*data_offset = offset;\n\n\t/* Parse the header */\n\tpkt_len = parse_cosine_rec_hdr(&wth->phdr, line, err, err_info);\n\tif (pkt_len == -1)\n\t\treturn FALSE;\n\n\t/* Convert the ASCII hex dump to binary data */\n\treturn parse_cosine_hex_dump(wth->fh, &wth->phdr, pkt_len,\n\t    wth->frame_buffer, err, err_info);\n}",
        "output": "1",
        "idx": 2355
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,\n\t\t\t struct iov_iter *i)\n{\n\tsize_t res = 0;\n\tif (unlikely(!page_copy_sane(page, offset, bytes)))\n\t\treturn 0;\n\tpage += offset / PAGE_SIZE; // first subpage\n\toffset %= PAGE_SIZE;\n\twhile (1) {\n\t\tsize_t n = __copy_page_to_iter(page, offset,\n\t\t\t\tmin(bytes, (size_t)PAGE_SIZE - offset), i);\n\t\tres += n;\n\t\tbytes -= n;\n\t\tif (!bytes || !n)\n\t\t\tbreak;\n\t\toffset += n;\n\t\tif (offset == PAGE_SIZE) {\n\t\t\tpage++;\n\t\t\toffset = 0;\n\t\t}\n\t}\n\treturn res;\n}",
        "output": "0",
        "idx": 1702
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void frag_kfree_skb(struct netns_frags *nf, struct sk_buff *skb)\n{\n\tatomic_sub(skb->truesize, &nf->mem);\n\tkfree_skb(skb);\n}",
        "output": "1",
        "idx": 2729
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t allocation_policy_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct cacheinfo *this_leaf = dev_get_drvdata(dev);\n\tunsigned int ci_attr = this_leaf->attributes;\n\tint n = 0;\n\n\tif ((ci_attr & CACHE_READ_ALLOCATE) && (ci_attr & CACHE_WRITE_ALLOCATE))\n\t\tn = sprintf(buf, \"ReadWriteAllocate\\n\");\n\telse if (ci_attr & CACHE_READ_ALLOCATE)\n\t\tn = sprintf(buf, \"ReadAllocate\\n\");\n\telse if (ci_attr & CACHE_WRITE_ALLOCATE)\n\t\tn = sprintf(buf, \"WriteAllocate\\n\");\n\treturn n;\n}",
        "output": "1",
        "idx": 1563
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void jpc_dec_destroy(jpc_dec_t *dec)\n{\n\tif (dec->cstate) {\n\t\tjpc_cstate_destroy(dec->cstate);\n\t}\n\tif (dec->pkthdrstreams) {\n\t\tjpc_streamlist_destroy(dec->pkthdrstreams);\n\t}\n\tif (dec->image) {\n\t\tjas_image_destroy(dec->image);\n\t}\n\n\tif (dec->cp) {\n\t\tjpc_dec_cp_destroy(dec->cp);\n\t}\n\n\tif (dec->cmpts) {\n\t\tjas_free(dec->cmpts);\n\t}\n\n\tif (dec->tiles) {\n\t\tjas_free(dec->tiles);\n\t}\n\n\tjas_free(dec);\n}",
        "output": "1",
        "idx": 3589
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool ldb_kv_index_unique(struct ldb_context *ldb,\n\t\t\t\tstruct ldb_kv_private *ldb_kv,\n\t\t\t\tconst char *attr)\n{\n\tconst struct ldb_schema_attribute *a;\n\tif (ldb_kv->cache->GUID_index_attribute != NULL) {\n\t\tif (ldb_attr_cmp(attr, ldb_kv->cache->GUID_index_attribute) ==\n\t\t    0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (ldb_attr_dn(attr) == 0) {\n\t\treturn true;\n\t}\n\n\ta = ldb_schema_attribute_by_name(ldb, attr);\n\tif (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {\n\t\treturn true;\n\t}\n\treturn false;\n}",
        "output": "0",
        "idx": 422
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)\n{\n\tint i;\n\tint j;\n\n\tif (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=\n\t  mat1->numcols_) {\n\t\treturn 1;\n\t}\n\tfor (i = 0; i < mat0->numrows_; i++) {\n\t\tfor (j = 0; j < mat0->numcols_; j++) {\n\t\t\tif (jas_matrix_get(mat0, i, j) != jas_matrix_get(mat1, i, j)) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 602
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cit_model3_Packet1(struct gspca_dev *gspca_dev, u16 v1, u16 v2)\n{\n\tcit_write_reg(gspca_dev, 0x0078, 0x012d);\n\tcit_write_reg(gspca_dev, v1,     0x012f);\n\tcit_write_reg(gspca_dev, 0xd141, 0x0124);\n\tcit_write_reg(gspca_dev, v2,     0x0127);\n\tcit_write_reg(gspca_dev, 0xfea8, 0x0124);\n}",
        "output": "0",
        "idx": 1908
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "size_t estimate_size(const std::vector<RE*> &res)\n{\n    std::vector<StackItem> stack;\n\n    const size_t nre = res.size();\n    DASSERT(nre > 0);\n    size_t size = nre - 1;\n\n    for (size_t i = 0; i < nre; ++i) {\n        size += estimate_re_size(res[i], stack) + 1;\n    }\n\n    return size;\n}",
        "output": "1",
        "idx": 3341
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "    if (sz + idx > maxSz || sz > WOLFSSH_MAX_HANDLE) {\n        WLOG(WS_LOG_SFTP, \"Error with file handle size\");\n        res  = err;\n        type = WOLFSSH_FTP_FAILURE;\n        ret  = WS_BAD_FILE_E;\n    }",
        "output": "1",
        "idx": 818
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,\n                        const AVFrame *src, int field)\n{\n    int plane;\n    for (plane = 0; plane < 4 && src->data[plane]; plane++)\n        av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,\n                            src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,\n                            get_width(fm, src, plane), get_height(fm, src, plane) / 2);\n}",
        "output": "1",
        "idx": 2542
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "startElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar **atts)\n{\n    int i;\n\n    callbacks++;\n    if (noout)\n\treturn;\n    fprintf(stdout, \"SAX.startElement(%s\", (char *) name);\n    if (atts != NULL) {\n        for (i = 0;(atts[i] != NULL);i++) {\n\t    fprintf(stdout, \", %s='\", atts[i++]);\n\t    if (atts[i] != NULL)\n\t        fprintf(stdout, \"%s'\", atts[i]);\n\t}\n    }\n    fprintf(stdout, \")\\n\");\n}",
        "output": "0",
        "idx": 882
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t max_time_ms_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct wakeup_source *ws = dev_get_drvdata(dev);\n\tktime_t active_time;\n\tktime_t max_time = ws->max_time;\n\n\tif (ws->active) {\n\t\tactive_time = ktime_sub(ktime_get(), ws->last_time);\n\t\tif (active_time > max_time)\n\t\t\tmax_time = active_time;\n\t}\n\treturn sprintf(buf, \"%lld\\n\", ktime_to_ms(max_time));\n}",
        "output": "1",
        "idx": 594
    }
]