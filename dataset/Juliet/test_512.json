[
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_01()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "11999"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_relativePath_65a()\n{\n    char * data;\n    /* define a function pointer */\n    void (*funcPtr) (char *) = CWE114_Process_Control__w32_char_relativePath_65aSink;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    /* FLAW: Specify just the file name for the library, not the full path */\n    strcpy(data, \"winsrv.dll\");\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "938"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    data = NULL;\n    {\n        char * data = *dataPtr1;\n        /* FIX: Allocate space for a null terminator */\n        data = new char[10+1];\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char source[10+1] = SRC_STRING;\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            strcpy(data, source);\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "20761"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_21()\n{\n    int * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_21Source(data);\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "24611"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_67b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_67_structType myStruct)\n{\n    char * data = myStruct.structFirst;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "13346"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_42()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    data = CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_42Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "17813"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_09()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "10824"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_file_53c_CWE114_Process_Control__w32_char_file_53cSink(char * data)\n{\n    CWE114_Process_Control__w32_char_file_53d_CWE114_Process_Control__w32_char_file_53cSink(data);\n}\n",
        "output": "0",
        "idx": "587"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_54bSink(data);\n}\n",
        "output": "0",
        "idx": "7965"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_67_structType myStruct)\n{\n    int * data = myStruct.structFirst;\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3621"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_17()\n{\n    int h;\n    wchar_t * data;\n    data = NULL;\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new wchar_t[10+1];\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "21870"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_18()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    goto source;\nsource:\n    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n    data = dataGoodBuffer;\n    goto sink;\nsink:\n    {\n        /* The Visual C++ compiler generates a warning if you initialize the class with ().\n         * This will cause the compile to default-initialize the object.\n         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n         */\n        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n        TwoIntsClass * classTwo = new(data) TwoIntsClass;\n        /* Initialize and make use of the class */\n        classTwo->intOne = 5;\n        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n        printIntLine(classTwo->intOne);\n        /* skip printing classTwo->intTwo since that could be a buffer overread */\n    }\n}\n",
        "output": "0",
        "idx": "17404"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_21()\n{\n    int64_t * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_21Source(data);\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n            delete [] data;\n        }\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "23806"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_31()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n            strcat(dest, data);\n            printLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "17799"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_67bSink(structType myStruct)\n{\n    int * data = myStruct.structFirst;\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "24382"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "5829"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_21()\n{\n    int64_t * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_21Source(data);\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "24128"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int64_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_22bSource(int64_t * data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_22bGlobal)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int64_t[100];\n    }\n    return data;\n}\n",
        "output": "0",
        "idx": "24138"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_07()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(staticFive==5)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "14185"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_53cSink_c(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "19626"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_67a()\n{\n    int data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_67_structType myStruct;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_67b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "2739"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_54bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "20806"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_18()\n{\n    void * data;\n    data = NULL;\n    goto source;\nsource:\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    goto sink;\nsink:\n    {\n        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n        size_t dataLen = strlen((char *)data);\n        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n        (void)wcscpy(dest, data);\n        printLine((char *)dest);\n    }\n}\n",
        "output": "1",
        "idx": "3982"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_21()\n{\n    char * data;\n    data = new char[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_21Static = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_21Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "26545"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_17()\n{\n    int h;\n    int * data;\n    data = NULL;\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memmove(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "3818"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_54cSink_c(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "17468"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_34()\n{\n    int data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_34_unionType myUnion;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    myUnion.unionFirst = data;\n    {\n        int data = myUnion.unionSecond;\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}\n",
        "output": "1",
        "idx": "2627"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_53cSink(data);\n}\n",
        "output": "0",
        "idx": "8092"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_15()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    switch(6)\n    {\n    case 6:\n        /* POTENTIAL FLAW: Read data from the console using fscanf() */\n        fscanf(stdin, \"%d\", &data);\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        int i;\n        int * buffer = new int[10];\n        /* initialize buffer */\n        for (i = 0; i < 10; i++)\n        {\n            buffer[i] = 0;\n        }\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n        delete[] buffer;\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n",
        "output": "1",
        "idx": "19779"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_17()\n{\n    int h;\n    int * data;\n    data = NULL;\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int[100];\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "24446"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_44()\n{\n    int64_t * data;\n    void (*funcPtr) (int64_t *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_44Sink;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int64_t[100];\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "23840"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_03()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(5==5)\n    {\n        /* POTENTIAL FLAW: Read data from the console using fscanf() */\n        fscanf(stdin, \"%d\", &data);\n    }\n    if(5==5)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}\n",
        "output": "1",
        "idx": "2530"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_68a()\n{\n    char * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new char[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_68aSink();\n}\n",
        "output": "1",
        "idx": "21325"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_53cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "24986"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_18()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    goto source;\nsource:\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcsncpy(data, source, 100-1);\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "12178"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_52b_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_52c_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_52bSink(data);\n}\n",
        "output": "0",
        "idx": "16603"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_63a()\n{\n    int64_t * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int64_t[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_63aSink(&data);\n}\n",
        "output": "0",
        "idx": "23882"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_07()\n{\n    int64_t * data;\n    data = NULL;\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int64_t[100];\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "24096"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_54dSink_d(TwoIntsClass * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "23386"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memmove_16()\n{\n    while(1)\n    {\n        {\n            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));\n            if (structCharVoid == NULL) {exit(-1);}\n            structCharVoid->voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid->voidSecond */\n            printLine((char *)structCharVoid->voidSecond);\n            /* FLAW: Use the sizeof(*structCharVoid) which will overwrite the pointer y */\n            memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));\n            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid->charFirst);\n            printLine((char *)structCharVoid->voidSecond);\n        }\n        break;\n    }\n}\n",
        "output": "1",
        "idx": "19215"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_43Source(int &data)\n{\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n}\n",
        "output": "0",
        "idx": "3384"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_72bSink(vector<wchar_t *> dataVector)\n{\n    wchar_t * data = dataVector[2];\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "11058"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_52bSink_b(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "19860"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_72a()\n{\n    int data;\n    vector<int> dataVector;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "2750"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_67_structType myStruct)\n{\n    int * data = myStruct.structFirst;\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "3755"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_45()\n{\n    char * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new char[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_45Sink();\n}\n",
        "output": "1",
        "idx": "20783"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_41()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_41Sink(data);\n}\n",
        "output": "0",
        "idx": "19332"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_73bSink(list<int64_t *> dataList)\n{\n    /* copy data out of dataList */\n    int64_t * data = dataList.back();\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "9066"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_73a()\n{\n    int * data;\n    list<int *> dataList;\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "3898"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_74a()\n{\n    char * data;\n    map<int, char *> dataMap;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new char[50];\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "22786"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_45()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_45Sink();\n}\n",
        "output": "1",
        "idx": "19846"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_52bSink(data);\n}\n",
        "output": "0",
        "idx": "8350"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45Sink()\n{\n    int64_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45Data;\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "8740"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_68a()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_68aSink();\n}\n",
        "output": "1",
        "idx": "9455"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_11()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));\n            if (structCharVoid == NULL) {exit(-1);}\n            structCharVoid->voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid->voidSecond */\n            printLine((char *)structCharVoid->voidSecond);\n            /* FLAW: Use the sizeof(*structCharVoid) which will overwrite the pointer y */\n            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));\n            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid->charFirst);\n            printLine((char *)structCharVoid->voidSecond);\n            free(structCharVoid);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "19152"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "14602"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_17()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));\n            if (structCharVoid == NULL) {exit(-1);}\n            structCharVoid->voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid->voidSecond */\n            printLine((char *)structCharVoid->voidSecond);\n            /* FLAW: Use the sizeof(*structCharVoid) which will overwrite the pointer y */\n            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));\n            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid->charFirst);\n            printLine((char *)structCharVoid->voidSecond);\n            free(structCharVoid);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "19168"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_66a()\n{\n    char * data;\n    char * dataArray[5];\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_66b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "12696"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_33()\n{\n    wchar_t * data;\n    wchar_t * &dataRef = data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new wchar_t[10];\n    {\n        wchar_t * data = dataRef;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            size_t i, sourceLen;\n            sourceLen = wcslen(source);\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            for (i = 0; i < sourceLen + 1; i++)\n            {\n                data[i] = source[i];\n            }\n            printWLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "21728"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_15()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    switch(6)\n    {\n    case 6:\n        /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n        data = dataBadBuffer;\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* The Visual C++ compiler generates a warning if you initialize the class with ().\n         * This will cause the compile to default-initialize the object.\n         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n         */\n        /* FIX: data will at least be the sizeof(OneIntClass) */\n        OneIntClass * classOne = new(data) OneIntClass;\n        /* Initialize and make use of the class */\n        classOne->intOne = 5;\n        printIntLine(classOne->intOne);\n    }\n    break;\n    }\n}\n",
        "output": "0",
        "idx": "17392"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "wchar_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_61bSource(wchar_t * data)\n{\n    /* FLAW: Did not leave space for a null terminator */\n    data = new wchar_t[10];\n    return data;\n}\n",
        "output": "1",
        "idx": "21621"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "5424"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_53cSink_c(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "20364"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_53b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_53bSink(int data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_53c_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_53bSink(data);\n}\n",
        "output": "0",
        "idx": "2433"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "6502"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_53cSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_53cSink(data);\n}\n",
        "output": "0",
        "idx": "10087"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_34()\n{\n    int data;\n    unionType myUnion;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    myUnion.unionFirst = data;\n    {\n        int data = myUnion.unionSecond;\n        {\n            int i;\n            int * buffer = new int[10];\n            /* initialize buffer */\n            for (i = 0; i < 10; i++)\n            {\n                buffer[i] = 0;\n            }\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n            delete[] buffer;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "20064"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_41()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_41Sink(data);\n}\n",
        "output": "0",
        "idx": "20562"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_45()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_45Sink();\n}\n",
        "output": "1",
        "idx": "9404"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_54d_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_54e_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_54dSink(data);\n}\n",
        "output": "0",
        "idx": "18173"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_21()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_21Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "27509"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_74bSink(map<int, void *> dataMap)\n{\n    void * data = dataMap[2];\n    {\n        /* FIX: treating pointer like a wchar_t*  */\n        size_t dataLen = wcslen((wchar_t *)data);\n        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n        (void)wcscpy((wchar_t *)dest, (wchar_t *)data);\n        printWLine((wchar_t *)dest);\n    }\n}\n",
        "output": "0",
        "idx": "4150"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_22a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_22aGlobal = 1; /* true */\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_22aSink(data);\n}\n",
        "output": "1",
        "idx": "3348"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_63a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_63b_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_63aSink(&data);\n}\n",
        "output": "0",
        "idx": "2223"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_54c_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_54d_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_54cSink(data);\n}\n",
        "output": "0",
        "idx": "16619"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_21Source(char * data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_21Static)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new char[10+1];\n    }\n    return data;\n}\n",
        "output": "0",
        "idx": "21070"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_17()\n{\n    int h;\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "6192"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_63a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_63aSink(&data);\n}\n",
        "output": "0",
        "idx": "20645"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_65bSink(wchar_t * data)\n{\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "15269"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_72bSink(vector<char *> dataVector)\n{\n    char * data = dataVector[2];\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "13354"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "6230"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_53cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "21283"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_67a()\n{\n    twoIntsStruct * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_67_structType myStruct;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "10116"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_53bSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_53bSink(data);\n}\n",
        "output": "0",
        "idx": "10351"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_54dSink(data);\n}\n",
        "output": "0",
        "idx": "11294"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_52bSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_52bSink(data);\n}\n",
        "output": "1",
        "idx": "3581"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_12()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "9370"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_41()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_41Sink(data);\n}\n",
        "output": "1",
        "idx": "3830"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_06()\n{\n    char * data;\n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new char[10+1];\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "20713"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_67a()\n{\n    int data;\n    structType myStruct;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "20667"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_11()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "27328"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_67_structType myStruct)\n{\n    int64_t * data = myStruct.structFirst;\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "8656"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_64b_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    int * * dataPtr = (int * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    int * data = (*dataPtr);\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "3610"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_66b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_66bSink(char * dataArray[])\n{\n    char * data = dataArray[2];\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4795"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_73bSink(list<char *> dataList)\n{\n    char * data = dataList.back();\n    {\n        /* The Visual C++ compiler generates a warning if you initialize the class with ().\n         * This will cause the compile to default-initialize the object.\n         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n         */\n        /* FIX: data will at least be the sizeof(OneIntClass) */\n        OneIntClass * classOne = new(data) OneIntClass;\n        /* Initialize and make use of the class */\n        classOne->intOne = 5;\n        printIntLine(classOne->intOne);\n    }\n}\n",
        "output": "0",
        "idx": "17730"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_01()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new wchar_t[100];\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "25528"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_21()\n{\n    char * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_21Source(data);\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        strcpy(data, source);\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "27831"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_01()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4152"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_53bSink(data);\n}\n",
        "output": "0",
        "idx": "5962"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54cSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54cSink(data);\n}\n",
        "output": "0",
        "idx": "9164"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_73a()\n{\n    int64_t * data;\n    list<int64_t *> dataList;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "8798"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_73bSink(list<char *> dataList)\n{\n    /* copy data out of dataList */\n    char * data = dataList.back();\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "7337"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_66a()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "14627"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_74a()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "25040"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_16()\n{\n    int * data;\n    data = NULL;\n    while(1)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new int[50];\n        break;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "24282"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static TwoIntsClass * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_21Source(TwoIntsClass * data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_21Static)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new TwoIntsClass[100];\n    }\n    return data;\n}\n",
        "output": "0",
        "idx": "23487"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_file_66a()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        /* Read input from a file */\n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    /* Restore NUL terminator if fgetws fails */\n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    /* put data in array */\n    dataArray[2] = data;\n    CWE114_Process_Control__w32_wchar_t_file_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "1586"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_65a()\n{\n    void * data;\n    void (*funcPtr) (void *) = CWE121_Stack_Based_Buffer_Overflow__CWE135_65b_CWE121_Stack_Based_Buffer_Overflow__CWE135_65aSink;\n    data = NULL;\n    /* FIX: Set data to point to a char string */\n    data = (void *)CHAR_STRING;\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "4110"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_54bSink(data);\n}\n",
        "output": "0",
        "idx": "8364"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_32()\n{\n    void * data;\n    void * *dataPtr1 = &data;\n    void * *dataPtr2 = &data;\n    data = NULL;\n    {\n        void * data = *dataPtr1;\n        /* POTENTIAL FLAW: Set data to point to a wide string */\n        data = (void *)WIDE_STRING;\n        *dataPtr1 = data;\n    }\n    {\n        void * data = *dataPtr2;\n        {\n            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n            size_t dataLen = strlen((char *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy(dest, data);\n            printLine((char *)dest);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "4004"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_12()\n{\n    int64_t * data;\n    data = NULL;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int64_t[100];\n    }\n    else\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int64_t[100];\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "24111"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_16()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    while(1)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        break;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "9381"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_34()\n{\n    int * data;\n    unionType myUnion;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int[100];\n    myUnion.unionFirst = data;\n    {\n        int * data = myUnion.unionSecond;\n        {\n            int source[100] = {0}; /* fill with 0's */\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memcpy(data, source, 100*sizeof(int));\n            printIntLine(data[0]);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "24468"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_45()\n{\n    int * data;\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_45Sink();\n}\n",
        "output": "0",
        "idx": "3707"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "5432"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_54cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "20808"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_72bSink(vector<int64_t *> dataVector)\n{\n    /* copy data out of dataVector */\n    int64_t * data = dataVector[2];\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "8929"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "wchar_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_22bSource(wchar_t * data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_22bGlobal)\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new wchar_t[10+1];\n    }\n    return data;\n}\n",
        "output": "0",
        "idx": "22206"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_66a()\n{\n    void * data;\n    void * dataArray[5];\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "4115"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_52bSink(data);\n}\n",
        "output": "0",
        "idx": "7153"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_22a()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_22aGlobal = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_22aSource(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "18114"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    int64_t * * dataPtr = (int64_t * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    int64_t * data = (*dataPtr);\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "8776"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_42()\n{\n    int * data;\n    data = NULL;\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_42Source(data);\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "24635"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_34()\n{\n    void * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_34_unionType myUnion;\n    data = NULL;\n    /* FIX: Set data to point to a char string */\n    data = (void *)CHAR_STRING;\n    myUnion.unionFirst = data;\n    {\n        void * data = myUnion.unionSecond;\n        {\n            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n            size_t dataLen = strlen((char *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * 1);\n            (void)strcpy(dest, data);\n            printLine((char *)dest);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "4011"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_12()\n{\n    wchar_t * data;\n    data = NULL;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new wchar_t[50];\n        data[0] = L'\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new wchar_t[100];\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        wcsncpy(data, source, 100-1);\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "25398"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_44()\n{\n    int * data;\n    /* define a function pointer */\n    void (*funcPtr) (int *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_44Sink;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "9932"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54eSink(wchar_t * data)\n{\n    {\n        size_t i;\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "10896"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_73a()\n{\n    int data;\n    list<int> dataList;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "2265"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_12()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "5779"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_31()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    {\n        int64_t * dataCopy = data;\n        int64_t * data = dataCopy;\n        {\n            int64_t source[100] = {0}; /* fill with 0's */\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memmove(data, source, 100*sizeof(int64_t));\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "8723"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_console_54d_CWE114_Process_Control__w32_wchar_t_console_54dSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_console_54e_CWE114_Process_Control__w32_wchar_t_console_54dSink(data);\n}\n",
        "output": "0",
        "idx": "1241"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_console_67a()\n{\n    wchar_t * data;\n    CWE114_Process_Control__w32_wchar_t_console_67_structType myStruct;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        /* Read input from the console */\n        size_t dataLen = wcslen(data);\n        /* if there is room in data, read into it from the console */\n        if (100-dataLen > 1)\n        {\n            /* POTENTIAL FLAW: Read data from the console */\n            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                /* The next few lines remove the carriage return from the string that is\n                 * inserted by fgetws() */\n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                /* Restore NUL terminator if fgetws fails */\n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    myStruct.structFirst = data;\n    CWE114_Process_Control__w32_wchar_t_console_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "1268"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_52bSink_b(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "19614"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_12()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "13718"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_45()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_45_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_45Sink();\n}\n",
        "output": "0",
        "idx": "2165"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_67a()\n{\n    int64_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_67_structType myStruct;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "8653"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_45()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_45Sink();\n}\n",
        "output": "1",
        "idx": "25452"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_73a()\n{\n    int * data;\n    list<int *> dataList;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "3631"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_73a()\n{\n    wchar_t * data;\n    list<wchar_t *> dataList;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "6272"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_54bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "22416"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_17()\n{\n    int h;\n    char * data;\n    data = new char[100];\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "26539"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_74a()\n{\n    TwoIntsClass * data;\n    map<int, TwoIntsClass *> dataMap;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new TwoIntsClass[100];\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_74aSink(dataMap);\n}\n",
        "output": "0",
        "idx": "23592"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_63a()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_63b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_63aSink(&data);\n}\n",
        "output": "0",
        "idx": "5047"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_15()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "8048"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "7824"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_68a()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_68aSink();\n}\n",
        "output": "1",
        "idx": "10386"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_53cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "26113"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_54cSink(data);\n}\n",
        "output": "0",
        "idx": "15407"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_21()\n{\n    char * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_21Source(data);\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */\n        strcat(data, source);\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "27674"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_64b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    char * * dataPtr = (char * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    char * data = (*dataPtr);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "12690"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_72a()\n{\n    twoIntsStruct * data;\n    vector<twoIntsStruct *> dataVector;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_72aSink(dataVector);\n}\n",
        "output": "0",
        "idx": "10125"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_18()\n{\n    goto sink;\nsink:\n    {\n        charVoid structCharVoid;\n        structCharVoid.voidSecond = (void *)SRC_STR;\n        /* Print the initial block pointed to by structCharVoid.voidSecond */\n        printLine((char *)structCharVoid.voidSecond);\n        /* FLAW: Use the sizeof(structCharVoid) which will overwrite the pointer voidSecond */\n        memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));\n        structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n        printLine((char *)structCharVoid.charFirst);\n        printLine((char *)structCharVoid.voidSecond);\n    }\n}\n",
        "output": "1",
        "idx": "1979"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_21()\n{\n    void * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_21Static = 1; /* true */\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_21Sink(data);\n}\n",
        "output": "1",
        "idx": "3986"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_66bSink(void * dataArray[])\n{\n    /* copy data out of dataArray */\n    void * data = dataArray[2];\n    {\n        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n        size_t dataLen = strlen((char *)data);\n        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n        (void)wcscpy(dest, data);\n        printLine((char *)dest);\n    }\n}\n",
        "output": "1",
        "idx": "4118"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_15()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        size_t i;\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "11639"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "18976"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_53dSink(char * data)\n{\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "12502"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_44()\n{\n    int * data;\n    /* define a function pointer */\n    void (*funcPtr) (int *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_44Sink;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int[50];\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "24643"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_12()\n{\n    int * data;\n    data = NULL;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new int[50];\n    }\n    else\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int[100];\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "24593"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_53bSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "3721"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_04()\n{\n    wchar_t * data;\n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new wchar_t[50];\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */\n        wcsncat(data, source, 100);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "25213"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_08()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "5768"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_54cSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_54cSink(data);\n}\n",
        "output": "0",
        "idx": "10095"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "12662"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54bSink(data);\n}\n",
        "output": "0",
        "idx": "10891"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_18()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    goto source;\nsource:\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "10450"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_68a()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_68aSink();\n}\n",
        "output": "1",
        "idx": "6795"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "14594"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_41()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_41Sink(data);\n}\n",
        "output": "1",
        "idx": "11657"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_21()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_21Static = 1; /* true */\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_21Sink(data);\n}\n",
        "output": "1",
        "idx": "2603"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_54bSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_54bSink(data);\n}\n",
        "output": "0",
        "idx": "10492"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_64a()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_64aSink(&data);\n}\n",
        "output": "1",
        "idx": "10503"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_17()\n{\n    int i;\n    wchar_t * data;\n    data = NULL;\n    for(i = 0; i < 1; i++)\n    {\n        /* FLAW: Did not leave space for a null terminator */\n        data = new wchar_t[10];\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "21869"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_52bSink(int data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_52bSink(data);\n}\n",
        "output": "1",
        "idx": "2177"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_67a()\n{\n    int * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_67_structType myStruct;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "3752"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_12()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "6179"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_41Sink(wchar_t * data)\n{\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "5671"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_52b_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_52bSink(int data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_52c_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_52bSink(data);\n}\n",
        "output": "0",
        "idx": "3162"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_54dSink_d(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "25318"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_74bSink(map<int, char *> dataMap)\n{\n    /* copy data out of dataMap */\n    char * data = dataMap[2];\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "25847"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_08()\n{\n    char * data;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    if(staticReturnsTrue())\n    {\n        /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n        data = dataBadBuffer;\n    }\n    if(staticReturnsTrue())\n    {\n        {\n            /* The Visual C++ compiler generates a warning if you initialize the class with ().\n             * This will cause the compile to default-initialize the object.\n             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n             */\n            /* FIX: data will at least be the sizeof(OneIntClass) */\n            OneIntClass * classOne = new(data) OneIntClass;\n            /* Initialize and make use of the class */\n            classOne->intOne = 5;\n            printIntLine(classOne->intOne);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "17566"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int64_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_22bSource(int64_t * data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_22bGlobal)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int64_t[100];\n    }\n    return data;\n}\n",
        "output": "0",
        "idx": "23977"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54cSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "9829"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "5837"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_45()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_45Sink();\n}\n",
        "output": "0",
        "idx": "13612"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "4908"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "7020"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_52bSink(data);\n}\n",
        "output": "0",
        "idx": "11675"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_34()\n{\n    wchar_t * data;\n    unionType myUnion;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n            memcpy(data, source, 100*sizeof(wchar_t));\n            data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "24950"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "6506"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_54bSink(data);\n}\n",
        "output": "0",
        "idx": "14922"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_52bSink_b(int64_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "24173"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_51a()\n{\n    int * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_51aSink(data);\n}\n",
        "output": "0",
        "idx": "24651"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    data = NULL;\n    {\n        char * data = *dataPtr1;\n        /* FLAW: Did not leave space for a null terminator */\n        data = new char[10];\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char source[10+1] = SRC_STRING;\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            strcpy(data, source);\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "20760"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_18()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    goto source;\nsource:\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    goto sink;\nsink:\n    {\n        int i;\n        int * buffer = new int[10];\n        /* initialize buffer */\n        for (i = 0; i < 10; i++)\n        {\n            buffer[i] = 0;\n        }\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n        delete[] buffer;\n    }\n}\n",
        "output": "1",
        "idx": "19790"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_16()\n{\n    int * data;\n    data = NULL;\n    while(1)\n    {\n        /* FLAW: Allocate memory without using sizeof(int) */\n        data = (int *)ALLOCA(10);\n        break;\n    }\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3549"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_21()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_21Static = 1; /* true */\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_21Sink(data);\n}\n",
        "output": "1",
        "idx": "3341"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_74a()\n{\n    int data;\n    map<int, int> dataMap;\n    /* Initialize data */\n    data = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_74aSink(dataMap);\n}\n",
        "output": "0",
        "idx": "2518"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_53cSink(data);\n}\n",
        "output": "0",
        "idx": "7560"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_environment_01()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            strncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "322"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_42()\n{\n    char * data;\n    data = new char[100];\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_42Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "26569"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_44()\n{\n    void * data;\n    void (*funcPtr) (void *) = CWE121_Stack_Based_Buffer_Overflow__CWE135_44Sink;\n    data = NULL;\n    /* FIX: Set data to point to a char string */\n    data = (void *)CHAR_STRING;\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "4034"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_74a()\n{\n    int * data;\n    map<int, int *> dataMap;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int[100];\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_74aSink(dataMap);\n}\n",
        "output": "0",
        "idx": "24397"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_67a()\n{\n    wchar_t * data;\n    structType myStruct;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new wchar_t[10];\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "22287"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_53cSink_c(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "20118"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_17()\n{\n    int h;\n    int64_t * data;\n    data = NULL;\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int64_t[100];\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "24124"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_66b_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_66bSink(char * dataArray[])\n{\n    char * data = dataArray[2];\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strcat(data, source);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "16373"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_54dSink(data);\n}\n",
        "output": "0",
        "idx": "7570"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_environment_53c_CWE114_Process_Control__w32_wchar_t_environment_53cSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_environment_53d_CWE114_Process_Control__w32_wchar_t_environment_53cSink(data);\n}\n",
        "output": "0",
        "idx": "1392"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    int64_t * * dataPtr = (int64_t * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    int64_t * data = (*dataPtr);\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "8909"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_65a()\n{\n    char * data;\n    /* define a function pointer */\n    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_65aSink;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "7049"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_72bSink(vector<char *> dataVector)\n{\n    char * data = dataVector[2];\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4541"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_67_structType myStruct)\n{\n    char * data = myStruct.structFirst;\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4799"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_53b_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_53c_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_53bSink(data);\n}\n",
        "output": "0",
        "idx": "16343"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_15()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        break;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "10576"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_32()\n{\n    TwoIntsClass * data;\n    TwoIntsClass * *dataPtr1 = &data;\n    TwoIntsClass * *dataPtr2 = &data;\n    data = NULL;\n    {\n        TwoIntsClass * data = *dataPtr1;\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new TwoIntsClass[50];\n        *dataPtr1 = data;\n    }\n    {\n        TwoIntsClass * data = *dataPtr2;\n        {\n            TwoIntsClass source[100];\n            {\n                size_t i;\n                /* Initialize array */\n                for (i = 0; i < 100; i++)\n                {\n                    source[i].intOne = 0;\n                    source[i].intTwo = 0;\n                }\n            }\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memcpy(data, source, 100*sizeof(TwoIntsClass));\n            printIntLine(data[0].intOne);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "23497"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_file_54d_CWE114_Process_Control__w32_char_file_54dSink(char * data)\n{\n    CWE114_Process_Control__w32_char_file_54e_CWE114_Process_Control__w32_char_file_54dSink(data);\n}\n",
        "output": "0",
        "idx": "597"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54a()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54aSink(data);\n}\n",
        "output": "1",
        "idx": "12504"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_17()\n{\n    int i;\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    for(i = 0; i < 1; i++)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "9915"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "11808"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_63b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_63bSink(wchar_t * * dataPtr)\n{\n    wchar_t * data = *dataPtr;\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "15262"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_15()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "8447"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_73bSink(list<int> dataList)\n{\n    /* copy data out of dataList */\n    int data = dataList.back();\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "2267"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53c_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53cSink(int data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53d_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53cSink(data);\n}\n",
        "output": "0",
        "idx": "2928"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_41()\n{\n    char * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new char[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_41Sink(data);\n}\n",
        "output": "1",
        "idx": "20928"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_52bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "21275"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_53bSink(data);\n}\n",
        "output": "0",
        "idx": "12821"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54bSink(data);\n}\n",
        "output": "0",
        "idx": "12829"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_17()\n{\n    int h,j;\n    int data;\n    /* Initialize data */\n    data = -1;\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    for(j = 0; j < 1; j++)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}\n",
        "output": "0",
        "idx": "2106"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_22a()\n{\n    wchar_t * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_22aGlobal = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_22aSource(data);\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */\n        wcscat(data, source);\n        printWLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "27998"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_45()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_45Sink();\n}\n",
        "output": "0",
        "idx": "12332"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_72a()\n{\n    char * data;\n    vector<char *> dataVector;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "17513"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_53c_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_53d_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_53cSink(data);\n}\n",
        "output": "0",
        "idx": "16345"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67a()\n{\n    int64_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67_structType myStruct;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "8787"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_01()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4284"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_51b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_51bSink(char * data)\n{\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "7016"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_54bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "27407"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    data = NULL;\n    {\n        wchar_t * data = *dataPtr1;\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new wchar_t[50];\n        data[0] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n            SNPRINTF(data, 100, L\"%s\", source);\n            printWLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "25590"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_21()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_21Static = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_21Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "15993"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_73a()\n{\n    int64_t * data;\n    list<int64_t *> dataList;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int64_t[100];\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "24232"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_12()\n{\n    wchar_t * data;\n    data = NULL;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new wchar_t[100];\n        data[0] = L'\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new wchar_t[100];\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        wcsncpy(data, source, 100-1);\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "25399"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_32()\n{\n    void * data;\n    void * *dataPtr1 = &data;\n    void * *dataPtr2 = &data;\n    data = NULL;\n    {\n        void * data = *dataPtr1;\n        /* FIX: Set data to point to a char string */\n        data = (void *)CHAR_STRING;\n        *dataPtr1 = data;\n    }\n    {\n        void * data = *dataPtr2;\n        {\n            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n            size_t dataLen = strlen((char *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * 1);\n            (void)strcpy(dest, data);\n            printLine((char *)dest);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "4005"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22aGlobal = 1; /* true */\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22aSink(data);\n}\n",
        "output": "1",
        "idx": "2610"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_34()\n{\n    int64_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_34_unionType myUnion;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myUnion.unionFirst = data;\n    {\n        int64_t * data = myUnion.unionSecond;\n        {\n            int64_t source[100] = {0}; /* fill with 0's */\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memcpy(data, source, 100*sizeof(int64_t));\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "8995"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_45()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_45Sink();\n}\n",
        "output": "1",
        "idx": "6877"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_45()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new wchar_t[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_45Sink();\n}\n",
        "output": "1",
        "idx": "22071"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_10()\n{\n    char * data;\n    data = NULL;\n    if(globalTrue)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new char[50];\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "22655"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_54bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "25636"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_listen_socket_52b_CWE114_Process_Control__w32_char_listen_socket_52bSink(char * data)\n{\n    CWE114_Process_Control__w32_char_listen_socket_52c_CWE114_Process_Control__w32_char_listen_socket_52bSink(data);\n}\n",
        "output": "0",
        "idx": "740"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_52bSink_b(int64_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "24012"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_51a()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_51aSink(data);\n}\n",
        "output": "1",
        "idx": "9673"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_53bSink(data);\n}\n",
        "output": "0",
        "idx": "11282"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_18()\n{\n    wchar_t * data;\n    data = NULL;\n    goto source;\nsource:\n    /* FIX: Allocate space for a null terminator */\n    data = new wchar_t[10+1];\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "21872"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_12()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n    else\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "1965"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_53bSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_53bSink(data);\n}\n",
        "output": "1",
        "idx": "8488"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_44Sink(char * data)\n{\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "13285"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_66a()\n{\n    int * data;\n    int * dataArray[5];\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "9846"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_connect_socket_53c_CWE114_Process_Control__w32_char_connect_socket_53cSink(char * data)\n{\n    CWE114_Process_Control__w32_char_connect_socket_53d_CWE114_Process_Control__w32_char_connect_socket_53cSink(data);\n}\n",
        "output": "0",
        "idx": "104"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_03()\n{\n    char * data;\n    data = NULL;\n    if(5==5)\n    {\n        /* FLAW: Did not leave space for a null terminator */\n        data = new char[10];\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "20863"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_21()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_21Static = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_21Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "16150"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_32()\n{\n    int data;\n    int *dataPtr1 = &data;\n    int *dataPtr2 = &data;\n    /* Initialize data */\n    data = -1;\n    {\n        int data = *dataPtr1;\n        {\n            char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n            /* POTENTIAL FLAW: Read data from the console using fgets() */\n            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n            {\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            else\n            {\n                printLine(\"fgets() failed.\");\n            }\n        }\n        *dataPtr1 = data;\n    }\n    {\n        int data = *dataPtr2;\n        {\n            int i;\n            int * buffer = new int[10];\n            /* initialize buffer */\n            for (i = 0; i < 10; i++)\n            {\n                buffer[i] = 0;\n            }\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n            delete[] buffer;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "19566"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_53cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "22088"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_52b_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_52bSink(int data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_52c_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_52bSink(data);\n}\n",
        "output": "0",
        "idx": "3408"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_51a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_51aSink(data);\n}\n",
        "output": "1",
        "idx": "20589"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_68a()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_68aSink();\n}\n",
        "output": "1",
        "idx": "16378"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_67a()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_67_structType myStruct;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "6924"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_73bSink(list<char *> dataList)\n{\n    /* copy data out of dataList */\n    char * data = dataList.back();\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4278"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    int * * dataPtr = (int * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    int * data = (*dataPtr);\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3742"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_54a()\n{\n    void * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_54b_CWE121_Stack_Based_Buffer_Overflow__CWE135_54aSink(data);\n}\n",
        "output": "0",
        "idx": "4072"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_66b_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_66bSink(int * dataArray[])\n{\n    int * data = dataArray[2];\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "3751"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static wchar_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_21Source(wchar_t * data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_21Static)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new wchar_t[50];\n        data[0] = L'\\0'; /* null terminate */\n    }\n    return data;\n}\n",
        "output": "1",
        "idx": "24771"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_45()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new wchar_t[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_45Sink();\n}\n",
        "output": "1",
        "idx": "21910"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_relativePath_62bSource(wchar_t * &data)\n{\n    /* FLAW: Specify just the file name for the library, not the full path */\n    wcscpy(data, L\"winsrv.dll\");\n}\n",
        "output": "1",
        "idx": "1894"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_environment_74a()\n{\n    char * data;\n    map<int, char *> dataMap;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            strncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE114_Process_Control__w32_char_environment_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "479"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_52a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_52b_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_52aSink(data);\n}\n",
        "output": "0",
        "idx": "2175"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_21()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_21Static = 0; /* false */\n    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_21Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "18594"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54bSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54bSink(data);\n}\n",
        "output": "0",
        "idx": "9162"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_53d_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "18324"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_68a()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_68aSink();\n}\n",
        "output": "1",
        "idx": "25189"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_72a()\n{\n    int64_t * data;\n    vector<int64_t *> dataVector;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_72aSink(dataVector);\n}\n",
        "output": "0",
        "idx": "8928"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_06()\n{\n    wchar_t * data;\n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Did not leave space for a null terminator */\n        data = new wchar_t[10];\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "22160"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_16()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    while(1)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        break;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "10578"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_34()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_34_unionType myUnion;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            strncpy(data, source, strlen(source) + 1);\n            printLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "5404"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_52bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "26427"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_53d_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "18968"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_54bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "22255"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    wchar_t * data = (*dataPtr);\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "5850"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_54bSink(data);\n}\n",
        "output": "0",
        "idx": "7566"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_53bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "27077"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_03()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(5==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "13692"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_04()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new TwoIntsClass[100];\n    }\n    {\n        TwoIntsClass source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0].intOne);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "23282"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_53cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "28045"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_53bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "27882"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_21Source(int * data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_21Static)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new int[50];\n    }\n    return data;\n}\n",
        "output": "1",
        "idx": "24288"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_17()\n{\n    int i;\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    for(i = 0; i < 1; i++)\n    {\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4861"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_15()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "9644"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_53a()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_53aSink(data);\n}\n",
        "output": "1",
        "idx": "3718"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_12()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "27009"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_73bSink(list<wchar_t *> dataList)\n{\n    wchar_t * data = dataList.back();\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "15290"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_listen_socket_53c_CWE114_Process_Control__w32_char_listen_socket_53cSink(char * data)\n{\n    CWE114_Process_Control__w32_char_listen_socket_53d_CWE114_Process_Control__w32_char_listen_socket_53cSink(data);\n}\n",
        "output": "0",
        "idx": "748"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE114_Process_Control__w32_char_connect_socket_21()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    CWE114_Process_Control__w32_char_connect_socket_21Static = 0; /* false */\n    data = CWE114_Process_Control__w32_char_connect_socket_21Source(data);\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "0",
        "idx": "52"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_12()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        wmemset(data, L'A', 100-1); /* fill with L'A's */\n        data[100-1] = L'\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "15488"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_10()\n{\n    int * data;\n    data = NULL;\n    if(globalTrue)\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memmove(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "3800"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22aGlobal = 1; /* true */\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22aSink(data);\n}\n",
        "output": "0",
        "idx": "2613"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_relativePath_54b_CWE114_Process_Control__w32_char_relativePath_54bSink(char * data)\n{\n    CWE114_Process_Control__w32_char_relativePath_54c_CWE114_Process_Control__w32_char_relativePath_54bSink(data);\n}\n",
        "output": "0",
        "idx": "915"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    {\n        char * data = *dataPtr1;\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            memcpy(dest, data, strlen(data)*sizeof(char));\n            dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "12621"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_01()\n{\n    char * data;\n    data = new char[100];\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "25849"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_65a()\n{\n    twoIntsStruct * data;\n    /* define a function pointer */\n    void (*funcPtr) (twoIntsStruct *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_65aSink;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "10507"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_64b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    char * * dataPtr = (char * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    char * data = (*dataPtr);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "13334"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_73a()\n{\n    TwoIntsClass * data;\n    list<TwoIntsClass *> dataList;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new TwoIntsClass[50];\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "23587"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_54cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "27731"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54a()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54aSink(data);\n}\n",
        "output": "1",
        "idx": "3726"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_relativePath_01()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    /* FLAW: Specify just the file name for the library, not the full path */\n    wcscpy(data, L\"winsrv.dll\");\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "1771"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_61a()\n{\n    int * data;\n    data = NULL;\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_61aSource(data);\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "24518"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "6107"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_52a()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_52aSink(data);\n}\n",
        "output": "1",
        "idx": "3579"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "6089"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_34()\n{\n    int64_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_34_unionType myUnion;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myUnion.unionFirst = data;\n    {\n        int64_t * data = myUnion.unionSecond;\n        {\n            int64_t source[100] = {0}; /* fill with 0's */\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memmove(data, source, 100*sizeof(int64_t));\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "9128"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_file_54c_CWE114_Process_Control__w32_wchar_t_file_54cSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_file_54d_CWE114_Process_Control__w32_wchar_t_file_54cSink(data);\n}\n",
        "output": "0",
        "idx": "1561"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_54cSink(data);\n}\n",
        "output": "0",
        "idx": "13475"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "18332"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_51a()\n{\n    int * data;\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_51b_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_51aSink(data);\n}\n",
        "output": "0",
        "idx": "3576"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_33()\n{\n    wchar_t * data;\n    wchar_t * &dataRef = data;\n    data = new wchar_t[100];\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t * data = dataRef;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            SNPRINTF(dest, wcslen(data), L\"%s\", data);\n            printWLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "27524"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_53cSink_c(TwoIntsClass * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "23698"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54bSink(data);\n}\n",
        "output": "0",
        "idx": "12507"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_67a()\n{\n    int * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_67_structType myStruct;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "9851"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54dSink(data);\n}\n",
        "output": "0",
        "idx": "10895"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_03()\n{\n    int * data;\n    data = NULL;\n    if(5==5)\n    {\n        /* FLAW: Allocate memory without using sizeof(int) */\n        data = (int *)ALLOCA(10);\n    }\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3511"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_21()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_21Static = 0; /* false */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_21Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "12610"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_44()\n{\n    void * data;\n    /* define a function pointer */\n    void (*funcPtr) (void *) = CWE121_Stack_Based_Buffer_Overflow__CWE135_44Sink;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "4032"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_08()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4570"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_environment_74a()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            wcsncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE114_Process_Control__w32_wchar_t_environment_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "1445"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_54dSink_d(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "17677"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_16()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    while(1)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        break;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "10445"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_53bSink_b(int * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "24501"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_44Sink(char * data)\n{\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "17818"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_43Source(int &data)\n{\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n}\n",
        "output": "1",
        "idx": "2888"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_54dSink(data);\n}\n",
        "output": "0",
        "idx": "14926"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_52bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "21758"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_34()\n{\n    int * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_34_unionType myUnion;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    myUnion.unionFirst = data;\n    {\n        int * data = myUnion.unionSecond;\n        {\n            int source[10] = {0};\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n            for (i = 0; i < 10; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "3561"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_67a()\n{\n    twoIntsStruct * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_67_structType myStruct;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "10250"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    {\n        char * data = *dataPtr1;\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char source[10+1] = SRC_STRING;\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            strcpy(data, source);\n            printLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "4203"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_17()\n{\n    int i;\n    int64_t * data;\n    data = NULL;\n    for(i = 0; i < 1; i++)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new int64_t[50];\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "24123"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_15()\n{\n    int64_t * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int64_t[100];\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "23959"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_44Sink(int data)\n{\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* FIX: Properly validate the array index and prevent a buffer overflow */\n        if (data >= 0 && data < (10))\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is out-of-bounds\");\n        }\n    }\n}\n",
        "output": "0",
        "idx": "2160"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_45()\n{\n    char * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new char[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_45Sink();\n}\n",
        "output": "1",
        "idx": "21266"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_06()\n{\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "1947"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_33()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    {\n        char * data = dataRef;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            SNPRINTF(dest, strlen(data), \"%s\", data);\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "14233"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_connect_socket_52bSink(char * data)\n{\n    CWE114_Process_Control__w32_char_connect_socket_52bSink(data);\n}\n",
        "output": "1",
        "idx": "95"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_45()\n{\n    char * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new char[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_45Sink();\n}\n",
        "output": "1",
        "idx": "21427"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_68a()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_68aSink();\n}\n",
        "output": "1",
        "idx": "24706"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_68a()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_68aSink();\n}\n",
        "output": "1",
        "idx": "6396"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_54bSink(data);\n}\n",
        "output": "0",
        "idx": "11556"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_53bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "23052"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54e_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "17020"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_53cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "24825"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_54cSink(data);\n}\n",
        "output": "0",
        "idx": "5307"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_53cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "25308"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_74a()\n{\n    char * data;\n    map<int, char *> dataMap;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_74aSink(dataMap);\n}\n",
        "output": "0",
        "idx": "13682"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_52bSink_b(TwoIntsClass * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "23368"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_74a()\n{\n    void * data;\n    map<int, void *> dataMap;\n    data = NULL;\n    /* FIX: Set data to point to a char string */\n    data = (void *)CHAR_STRING;\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_74aSink(dataMap);\n}\n",
        "output": "0",
        "idx": "4146"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "13143"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_54bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "27890"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_34()\n{\n    wchar_t * data;\n    unionType myUnion;\n    data = new wchar_t[100];\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n            dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "26883"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_73a()\n{\n    int * data;\n    list<int *> dataList;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "9330"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_54bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "22094"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "14600"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_file_01()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        /* Read input from a file */\n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "483"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_43Source(wchar_t * &data)\n{\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n}\n",
        "output": "1",
        "idx": "14406"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_52bSink(data);\n}\n",
        "output": "0",
        "idx": "7685"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_51a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_51aSink(data);\n}\n",
        "output": "0",
        "idx": "19606"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54cSink(data);\n}\n",
        "output": "0",
        "idx": "12509"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_03()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(5==5)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "12885"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_18()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    goto source;\nsource:\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "12767"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_33()\n{\n    char * data;\n    char * &dataRef = data;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n    data = dataGoodBuffer;\n    {\n        char * data = dataRef;\n        {\n            /* The Visual C++ compiler generates a warning if you initialize the class with ().\n             * This will cause the compile to default-initialize the object.\n             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n             */\n            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n            TwoIntsClass * classTwo = new(data) TwoIntsClass;\n            /* Initialize and make use of the class */\n            classTwo->intOne = 5;\n            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n            printIntLine(classTwo->intOne);\n            /* skip printing classTwo->intTwo since that could be a buffer overread */\n        }\n    }\n}\n",
        "output": "0",
        "idx": "17412"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_52b_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_52c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "17268"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_12()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "5912"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_66a()\n{\n    char * data;\n    char * dataArray[5];\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n    data = dataGoodBuffer;\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "17496"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_14()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    if(globalFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "8712"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_67a()\n{\n    wchar_t * data;\n    structType myStruct;\n    data = new wchar_t[100];\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "26956"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_52bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "22241"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_34()\n{\n    int * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_34_unionType myUnion;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    myUnion.unionFirst = data;\n    {\n        int * data = myUnion.unionSecond;\n        {\n            int source[10] = {0};\n            /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n            memcpy(data, source, 10*sizeof(int));\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "3694"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_relativePath_44()\n{\n    wchar_t * data;\n    /* define a function pointer */\n    void (*funcPtr) (wchar_t *) = CWE114_Process_Control__w32_wchar_t_relativePath_44Sink;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    /* FLAW: Specify just the file name for the library, not the full path */\n    wcscpy(data, L\"winsrv.dll\");\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "1853"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void * CWE121_Stack_Based_Buffer_Overflow__CWE135_42Source(void * data)\n{\n    /* FIX: Set data to point to a char string */\n    data = (void *)CHAR_STRING;\n    return data;\n}\n",
        "output": "0",
        "idx": "4021"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_31()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            memmove(dest, data, wcslen(data)*sizeof(wchar_t));\n            dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "15678"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_45()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_45Sink();\n}\n",
        "output": "0",
        "idx": "7943"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_12()\n{\n    int64_t * data;\n    data = NULL;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new int64_t[50];\n    }\n    else\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int64_t[100];\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "23949"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_02()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "1984"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_environment_41()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            strncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    CWE114_Process_Control__w32_char_environment_41Sink(data);\n}\n",
        "output": "1",
        "idx": "392"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_68a()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_68aSink();\n}\n",
        "output": "1",
        "idx": "17507"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_34()\n{\n    char * data;\n    unionType myUnion;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new char[50];\n    data[0] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            size_t i;\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "22374"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_02()\n{\n    wchar_t * data;\n    data = NULL;\n    if(1)\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new wchar_t[10+1];\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "21667"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_34()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_34_unionType myUnion;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            SNPRINTF(data, 100, L\"%s\", source);\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "12319"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_33()\n{\n    wchar_t * data;\n    wchar_t * &dataRef = data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t * data = dataRef;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            SNPRINTF(dest, wcslen(data), L\"%s\", data);\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "16165"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_51a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_51aSink(data);\n}\n",
        "output": "1",
        "idx": "20097"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_06()\n{\n    char * data;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n        data = dataBadBuffer;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* The Visual C++ compiler generates a warning if you initialize the class with ().\n             * This will cause the compile to default-initialize the object.\n             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n             */\n            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n            TwoIntsClass * classTwo = new(data) TwoIntsClass;\n            /* Initialize and make use of the class */\n            classTwo->intOne = 5;\n            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n            printIntLine(classTwo->intOne);\n            /* skip printing classTwo->intTwo since that could be a buffer overread */\n        }\n    }\n}\n",
        "output": "1",
        "idx": "17554"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_34()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_34_unionType myUnion;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            memcpy(data, source, 100*sizeof(char));\n            data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "7000"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_41_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_41Sink(int * data)\n{\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "3698"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_17()\n{\n    int i;\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    for(i = 0; i < 1; i++)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "8585"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_54bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "26602"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_53cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "21927"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_34()\n{\n    int64_t * data;\n    unionType myUnion;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int64_t[50];\n    myUnion.unionFirst = data;\n    {\n        int64_t * data = myUnion.unionSecond;\n        {\n            int64_t source[100] = {0}; /* fill with 0's */\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memcpy(data, source, 100*sizeof(int64_t));\n            printLongLongLine(data[0]);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "23984"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_21()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_21Static = 1; /* true */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_21Sink(data);\n}\n",
        "output": "1",
        "idx": "20532"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_41Sink(int data)\n{\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "2138"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_63a()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_63b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_63aSink(&data);\n}\n",
        "output": "0",
        "idx": "8904"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_68a()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_68_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_68b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_68aSink();\n}\n",
        "output": "0",
        "idx": "5333"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_66a()\n{\n    char * data;\n    char * dataArray[5];\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "6920"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45Sink();\n}\n",
        "output": "0",
        "idx": "10337"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_54bSink(data);\n}\n",
        "output": "0",
        "idx": "6635"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_12()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "13073"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_72a()\n{\n    char * data;\n    vector<char *> dataVector;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new char[10];\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "21490"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54d_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54cSink(data);\n}\n",
        "output": "0",
        "idx": "18493"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "7826"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_45()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_45Sink();\n}\n",
        "output": "0",
        "idx": "5150"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_53bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "22730"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_22a()\n{\n    int64_t * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_22aGlobal = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_22aSource(data);\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "23972"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_41()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_41_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_41Sink(data);\n}\n",
        "output": "0",
        "idx": "10728"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_53bSink(data);\n}\n",
        "output": "0",
        "idx": "11681"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_66a()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new wchar_t[100];\n    data[0] = L'\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "25182"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_72a()\n{\n    char * data;\n    vector<char *> dataVector;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n    data = dataGoodBuffer;\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_72aSink(dataVector);\n}\n",
        "output": "0",
        "idx": "17720"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_22a()\n{\n    wchar_t * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_22aGlobal = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_22aSource(data);\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "21880"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_relativePath_73a()\n{\n    wchar_t * data;\n    list<wchar_t *> dataList;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    /* FLAW: Specify just the file name for the library, not the full path */\n    wcscpy(data, L\"winsrv.dll\");\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE114_Process_Control__w32_wchar_t_relativePath_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "1924"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_45Sink()\n{\n    int * data = CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_45Data;\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memmove(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3837"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_53bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "22891"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_53b_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "18644"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_68a()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new TwoIntsClass[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_68aSink();\n}\n",
        "output": "1",
        "idx": "23418"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_01()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "5482"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_63bSink(char * * dataPtr)\n{\n    char * data = *dataPtr;\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "20824"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_17()\n{\n    int i;\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    for(i = 0; i < 1; i++)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "12043"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_53a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_53b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_53aSink(data);\n}\n",
        "output": "0",
        "idx": "2676"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_73bSink(list<char *> dataList)\n{\n    /* copy data out of dataList */\n    char * data = dataList.back();\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "21174"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_66a()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "6255"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54dSink(data);\n}\n",
        "output": "0",
        "idx": "7304"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_21()\n{\n    int * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_21Static = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_21Source(data);\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n            delete [] data;\n        }\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "24291"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_41_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_41Sink(char * data)\n{\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "12629"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_15()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new TwoIntsClass[50];\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        TwoIntsClass source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(TwoIntsClass));\n        printIntLine(data[0].intOne);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "23474"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_62a()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_62aSource(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "17858"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_72bSink(vector<int *> dataVector)\n{\n    int * data = dataVector[2];\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "3763"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_72a()\n{\n    int * data;\n    vector<int *> dataVector;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "3627"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_14()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(globalFive==5)\n    {\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "6183"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_54cSink_c(int * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "24511"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_53cSink(data);\n}\n",
        "output": "0",
        "idx": "14433"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "17018"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE114_Process_Control__w32_wchar_t_connect_socket_41()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    /* FIX: Specify the full pathname for the library */\n    wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    CWE114_Process_Control__w32_wchar_t_connect_socket_41_CWE114_Process_Control__w32_wchar_t_connect_socket_41Sink(data);\n}\n",
        "output": "0",
        "idx": "1038"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_53bSink(data);\n}\n",
        "output": "0",
        "idx": "5297"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_73a()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "5074"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_relativePath_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        /* FLAW: Specify just the file name for the library, not the full path */\n        wcscpy(data, L\"winsrv.dll\");\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            HMODULE hModule;\n            /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n             * replace his own file with the intended library */\n            hModule = LoadLibraryW(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n",
        "output": "1",
        "idx": "1834"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "6238"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_34()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_34_unionType myUnion;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char source[10+1] = SRC_STRING;\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            strcpy(data, source);\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "4206"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_54e_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "16488"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_45()\n{\n    char * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new char[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_45Sink();\n}\n",
        "output": "1",
        "idx": "21105"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_16()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    while(1)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "12762"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_61b_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_61bSource(int data)\n{\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    return data;\n}\n",
        "output": "0",
        "idx": "2214"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_45()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_45Sink();\n}\n",
        "output": "1",
        "idx": "10202"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_03()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    if(5==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "26661"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_45()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_45Sink();\n}\n",
        "output": "1",
        "idx": "13932"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_62bSource(TwoIntsClass * &data)\n{\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new TwoIntsClass[50];\n}\n",
        "output": "1",
        "idx": "23718"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_43Source(int &data)\n{\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n}\n",
        "output": "0",
        "idx": "2400"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_54cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "21774"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_63a()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_63aSink(&data);\n}\n",
        "output": "1",
        "idx": "6376"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_45()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_45Sink();\n}\n",
        "output": "1",
        "idx": "3393"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_62bSource(TwoIntsClass * &data)\n{\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new TwoIntsClass[100];\n}\n",
        "output": "0",
        "idx": "23397"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_02()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(1)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4953"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_16()\n{\n    wchar_t * data;\n    data = NULL;\n    while(1)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new wchar_t[50];\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "24926"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_67_structType myStruct)\n{\n    char * data = myStruct.structFirst;\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4665"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_console_22a()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    CWE114_Process_Control__w32_wchar_t_console_22aGlobal = 1; /* true */\n    data = CWE114_Process_Control__w32_wchar_t_console_22aSource(data);\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "1182"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "13620"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_54bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "21128"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54b_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "17016"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_21Sink(int data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_21Static)\n    {\n        {\n            int i;\n            int * buffer = new int[10];\n            /* initialize buffer */\n            for (i = 0; i < 10; i++)\n            {\n                buffer[i] = 0;\n            }\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n            delete[] buffer;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "19301"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_73bSink(list<char *> dataList)\n{\n    /* copy data out of dataList */\n    char * data = dataList.back();\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "12713"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_73a()\n{\n    int * data;\n    list<int *> dataList;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "9995"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_74a()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    data = new wchar_t[100];\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "27616"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_21()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_21Static = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_21Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "18753"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_45()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new wchar_t[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_45Sink();\n}\n",
        "output": "1",
        "idx": "21588"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_16()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    while(1)\n    {\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4460"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_68a()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_68aSink();\n}\n",
        "output": "1",
        "idx": "7194"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_environment_41()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            wcsncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    CWE114_Process_Control__w32_wchar_t_environment_41Sink(data);\n}\n",
        "output": "1",
        "idx": "1358"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_67_structType myStruct)\n{\n    char * data = myStruct.structFirst;\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "7193"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "5166"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_67a()\n{\n    int data;\n    structType myStruct;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "19931"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_53cSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_53cSink(data);\n}\n",
        "output": "0",
        "idx": "9156"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54cSink(data);\n}\n",
        "output": "0",
        "idx": "7302"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_34()\n{\n    int * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_34_unionType myUnion;\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    myUnion.unionFirst = data;\n    {\n        int * data = myUnion.unionSecond;\n        {\n            int source[10] = {0};\n            /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n            memcpy(data, source, 10*sizeof(int));\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "3695"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_03()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    if(5==5)\n    {\n        /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n        data = dataBadBuffer;\n    }\n    if(5==5)\n    {\n        {\n            /* The Visual C++ compiler generates a warning if you initialize the class with ().\n             * This will cause the compile to default-initialize the object.\n             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n             */\n            /* FIX: data will at least be the sizeof(OneIntClass) */\n            OneIntClass * classOne = new(data) OneIntClass;\n            /* Initialize and make use of the class */\n            classOne->intOne = 5;\n            printIntLine(classOne->intOne);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "17335"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_72a()\n{\n    char * data;\n    vector<char *> dataVector;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "17719"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_74a()\n{\n    int * data;\n    map<int, int *> dataMap;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "3768"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_11()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "8968"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_74bSink(map<int, int64_t *> dataMap)\n{\n    /* copy data out of dataMap */\n    int64_t * data = dataMap[2];\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "9070"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_66a()\n{\n    int64_t * data;\n    int64_t * dataArray[5];\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "9048"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_01()\n{\n    int64_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int64_t[50];\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "23756"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_18()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    goto source;\nsource:\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "9918"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_66a()\n{\n    int * data;\n    int * dataArray[5];\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "9447"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_41()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_41Sink(data);\n}\n",
        "output": "0",
        "idx": "20070"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_54bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "28373"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54eSink(wchar_t * data)\n{\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "18496"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_68a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_68aSink();\n}\n",
        "output": "1",
        "idx": "20181"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54c_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54cSink(int data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54d_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54cSink(data);\n}\n",
        "output": "0",
        "idx": "2448"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_67a()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_67_structType myStruct;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_67b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "13505"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_01()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "8807"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_67a()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_67_structType myStruct;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "12699"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_73a()\n{\n    int data;\n    list<int> dataList;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "3496"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_34()\n{\n    char * data;\n    unionType myUnion;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            /* The Visual C++ compiler generates a warning if you initialize the class with ().\n             * This will cause the compile to default-initialize the object.\n             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n             */\n            /* FIX: data will at least be the sizeof(OneIntClass) */\n            OneIntClass * classOne = new(data) OneIntClass;\n            /* Initialize and make use of the class */\n            classOne->intOne = 5;\n            printIntLine(classOne->intOne);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "17416"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_03()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    if(5==5)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "8545"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_06()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "12012"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_31()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new TwoIntsClass[50];\n    {\n        TwoIntsClass * dataCopy = data;\n        TwoIntsClass * data = dataCopy;\n        {\n            TwoIntsClass source[100];\n            {\n                size_t i;\n                /* Initialize array */\n                for (i = 0; i < 100; i++)\n                {\n                    source[i].intOne = 0;\n                    source[i].intTwo = 0;\n                }\n            }\n            {\n                size_t i;\n                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n                for (i = 0; i < 100; i++)\n                {\n                    data[i] = source[i];\n                }\n                printIntLine(data[0].intOne);\n                delete [] data;\n            }\n        }\n    }\n}\n",
        "output": "1",
        "idx": "23334"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_03()\n{\n    char * data;\n    data = NULL;\n    if(5==5)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new char[100];\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "23119"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_52bSink_b(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "19368"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_22a()\n{\n    char * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_22aGlobal = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_22aSource(data);\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "22685"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_17()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n            printWLine((wchar_t *)structCharVoid.charFirst);\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "19071"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_06()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "14182"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_72a()\n{\n    char * data;\n    vector<char *> dataVector;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "7464"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_21()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_21Static = 1; /* true */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_21Sink(data);\n}\n",
        "output": "1",
        "idx": "20040"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_44()\n{\n    char * data;\n    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_44Sink;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "6875"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_21()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_21Static = 0; /* false */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_21Sink(data);\n}\n",
        "output": "0",
        "idx": "20534"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_21()\n{\n    char * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_21Source(data);\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "22679"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_53bSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_53bSink(data);\n}\n",
        "output": "0",
        "idx": "8888"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_02()\n{\n    wchar_t * data;\n    data = NULL;\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new wchar_t[10+1];\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "22149"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_54bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "25314"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54cSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "9031"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_relativePath_62bSource(char * &data)\n{\n    /* FLAW: Specify just the file name for the library, not the full path */\n    strcpy(data, \"winsrv.dll\");\n}\n",
        "output": "1",
        "idx": "928"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_67bSink(CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_67_structType myStruct)\n{\n    char * data = myStruct.structFirst;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "17880"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_73bSink(list<int *> dataList)\n{\n    /* copy data out of dataList */\n    int * data = dataList.back();\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3633"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_45()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_45Sink();\n}\n",
        "output": "1",
        "idx": "17430"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_53cSink(data);\n}\n",
        "output": "0",
        "idx": "7294"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_66a()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "13500"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_53bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "25467"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_34()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_34_unionType myUnion;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            strncpy(dest, data, strlen(data));\n            dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "14075"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_06()\n{\n    char * data;\n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Did not leave space for a null terminator */\n        data = new char[10];\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "20872"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_52bSink_b(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "20598"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_72a()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "15283"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_73a()\n{\n    char * data;\n    list<char *> dataList;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new char[10];\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "20850"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_41()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_41Sink(data);\n}\n",
        "output": "0",
        "idx": "2633"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_34()\n{\n    int data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_34_unionType myUnion;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    myUnion.unionFirst = data;\n    {\n        int data = myUnion.unionSecond;\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}\n",
        "output": "0",
        "idx": "2629"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_41Sink(wchar_t * data)\n{\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "14398"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "16041"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_07()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(staticFive==5)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "7626"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_67a()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_67_structType myStruct;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "10915"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_53a()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_53aSink(data);\n}\n",
        "output": "1",
        "idx": "7688"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_16()\n{\n    char * data;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    while(1)\n    {\n        /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n        data = dataBadBuffer;\n        break;\n    }\n    while(1)\n    {\n        {\n            /* The Visual C++ compiler generates a warning if you initialize the class with ().\n             * This will cause the compile to default-initialize the object.\n             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n             */\n            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n            TwoIntsClass * classTwo = new(data) TwoIntsClass;\n            /* Initialize and make use of the class */\n            classTwo->intOne = 5;\n            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n            printIntLine(classTwo->intOne);\n            /* skip printing classTwo->intTwo since that could be a buffer overread */\n        }\n        break;\n    }\n}\n",
        "output": "1",
        "idx": "17602"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_74bSink(map<int, char *> dataMap)\n{\n    char * data = dataMap[2];\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "22467"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_52a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_52aSink_b(data);\n}\n",
        "output": "0",
        "idx": "19612"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_45()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_45Sink();\n}\n",
        "output": "1",
        "idx": "10069"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_54bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "21289"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_52bSink(data);\n}\n",
        "output": "0",
        "idx": "12976"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t dest[50] = L\"\";\n            size_t i, dataLen;\n            dataLen = wcslen(data);\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            for (i = 0; i < dataLen; i++)\n            {\n                dest[i] = data[i];\n            }\n            dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "15359"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_68a()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new TwoIntsClass[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_68_CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_68aSink();\n}\n",
        "output": "0",
        "idx": "23741"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_45()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_45Sink();\n}\n",
        "output": "1",
        "idx": "10601"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_54bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "22899"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_72bSink(vector<char *> dataVector)\n{\n    char * data = dataVector[2];\n    {\n        /* The Visual C++ compiler generates a warning if you initialize the class with ().\n         * This will cause the compile to default-initialize the object.\n         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n         */\n        /* FIX: data will at least be the sizeof(OneIntClass) */\n        OneIntClass * classOne = new(data) OneIntClass;\n        /* Initialize and make use of the class */\n        classOne->intOne = 5;\n        printIntLine(classOne->intOne);\n    }\n}\n",
        "output": "0",
        "idx": "17518"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_53b_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_53c_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_53bSink(data);\n}\n",
        "output": "0",
        "idx": "17839"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_listen_socket_54c_CWE114_Process_Control__w32_wchar_t_listen_socket_54cSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_listen_socket_54d_CWE114_Process_Control__w32_wchar_t_listen_socket_54cSink(data);\n}\n",
        "output": "0",
        "idx": "1722"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_54bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "24831"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_68a()\n{\n    int64_t * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int64_t[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_68_CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_68aSink();\n}\n",
        "output": "0",
        "idx": "24063"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_15()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        break;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "8980"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "11018"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_54dSink_d(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "28055"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_68a()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_68aSink();\n}\n",
        "output": "0",
        "idx": "8791"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_54bSink(data);\n}\n",
        "output": "0",
        "idx": "15405"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_17()\n{\n    int h;\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "9783"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_54cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "25477"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_44()\n{\n    int64_t * data;\n    /* define a function pointer */\n    void (*funcPtr) (int64_t *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_44Sink;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int64_t[50];\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "23838"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_72bSink(vector<int64_t *> dataVector)\n{\n    int64_t * data = dataVector[2];\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "8531"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_31()\n{\n    int * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int[100];\n    {\n        int * dataCopy = data;\n        int * data = dataCopy;\n        {\n            int source[100] = {0}; /* fill with 0's */\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memmove(data, source, 100*sizeof(int));\n            printIntLine(data[0]);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "24623"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_33()\n{\n    wchar_t * data;\n    wchar_t * &dataRef = data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t * data = dataRef;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            memmove(dest, data, wcslen(data)*sizeof(wchar_t));\n            dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "15682"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_63a()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new TwoIntsClass[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_63aSink(&data);\n}\n",
        "output": "1",
        "idx": "23720"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_54bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "21933"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_53bSink(data);\n}\n",
        "output": "0",
        "idx": "6627"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_31()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    {\n        int64_t * dataCopy = data;\n        int64_t * data = dataCopy;\n        {\n            int64_t source[100] = {0}; /* fill with 0's */\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memmove(data, source, 100*sizeof(int64_t));\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "8722"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_68a()\n{\n    char * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new char[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_68aSink();\n}\n",
        "output": "1",
        "idx": "21486"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_54dSink(data);\n}\n",
        "output": "0",
        "idx": "11693"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_63a()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_63b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_63aSink(&data);\n}\n",
        "output": "0",
        "idx": "11963"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_15()\n{\n    char * data;\n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Allocate space for a null terminator */\n        data = new char[10+1];\n        break;\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "20738"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_53cSink_c(int64_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "24181"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_41_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_41Sink(char * data)\n{\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4210"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_21()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_21Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "27026"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_13()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "5116"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54bSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54bSink(data);\n}\n",
        "output": "0",
        "idx": "9295"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_53d_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "17010"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_console_54d_CWE114_Process_Control__w32_char_console_54dSink(char * data)\n{\n    CWE114_Process_Control__w32_char_console_54e_CWE114_Process_Control__w32_char_console_54dSink(data);\n}\n",
        "output": "0",
        "idx": "275"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_18()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    goto source;\nsource:\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    goto sink;\nsink:\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "3337"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_14()\n{\n    char * data;\n    data = NULL;\n    if(globalFive==5)\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new char[10+1];\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "20736"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_45()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new TwoIntsClass[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_45Sink();\n}\n",
        "output": "1",
        "idx": "23520"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_67a()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_67_structType myStruct;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_67b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "13827"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_22bSink(void * data)\n{\n    if(CWE121_Stack_Based_Buffer_Overflow__CWE135_22bGlobal)\n    {\n        {\n            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n            size_t dataLen = strlen((char *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy(dest, data);\n            printLine((char *)dest);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "3997"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_66a()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataArray[5];\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "10113"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_45()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_45Sink();\n}\n",
        "output": "1",
        "idx": "16327"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_66a()\n{\n    int * data;\n    int * dataArray[5];\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_66b_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "3616"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_54bSink(data);\n}\n",
        "output": "0",
        "idx": "16210"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_51a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_51b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_51aSink(data);\n}\n",
        "output": "0",
        "idx": "2908"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_65a()\n{\n    char * data;\n    /* define a function pointer */\n    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_65aSink;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "17489"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_73bSink(list<int> dataList)\n{\n    int data = dataList.back();\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}\n",
        "output": "0",
        "idx": "2268"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_72bSink(vector<wchar_t *> dataVector)\n{\n    wchar_t * data = dataVector[2];\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "14642"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_45()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_45Sink();\n}\n",
        "output": "1",
        "idx": "3705"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_54cSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_54cSink(data);\n}\n",
        "output": "0",
        "idx": "3598"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_53bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "20959"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_42()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_42Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "14886"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_54dSink_d(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "28377"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "14592"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_44()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_44Sink;\n    data = NULL;\n    /* FIX: Allocate space for a null terminator */\n    data = new wchar_t[10+1];\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "21908"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "4765"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_68a()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_68aSink();\n}\n",
        "output": "0",
        "idx": "17508"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_52bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "26266"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_54cSink(data);\n}\n",
        "output": "0",
        "idx": "14924"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_17()\n{\n    int i;\n    int * data;\n    data = NULL;\n    for(i = 0; i < 1; i++)\n    {\n        /* FLAW: Allocate memory without using sizeof(int) */\n        data = (int *)ALLOCA(10);\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3684"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53aSink(data);\n}\n",
        "output": "0",
        "idx": "2922"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "11409"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_13()\n{\n    int64_t * data;\n    data = NULL;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int64_t[100];\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "24114"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "4245"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_54bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "28212"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_45()\n{\n    int64_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int64_t[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_45Sink();\n}\n",
        "output": "1",
        "idx": "24164"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_53bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "25789"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_52bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "20953"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_file_54b_CWE114_Process_Control__w32_wchar_t_file_54bSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_file_54c_CWE114_Process_Control__w32_wchar_t_file_54bSink(data);\n}\n",
        "output": "0",
        "idx": "1559"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_54c_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_54cSink(int data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_54d_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_54cSink(data);\n}\n",
        "output": "0",
        "idx": "2202"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_45Sink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_45Data;\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcsncpy(data, source, 100-1);\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "11400"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_07()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(staticFive==5)\n    {\n        /* POTENTIAL FLAW: Use an invalid index */\n        data = 10;\n    }\n    if(staticFive==5)\n    {\n        {\n            int i;\n            int * buffer = new int[10];\n            /* initialize buffer */\n            for (i = 0; i < 10; i++)\n            {\n                buffer[i] = 0;\n            }\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n            delete[] buffer;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "19987"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_52b_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_52c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "18960"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_52cSink(int * data)\n{\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "9416"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_73a()\n{\n    wchar_t * data;\n    list<wchar_t *> dataList;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "25036"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_12()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "11765"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_34()\n{\n    char * data;\n    unionType myUnion;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new char[100];\n    data[0] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n            SNPRINTF(data, 100, \"%s\", source);\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "23180"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_52b_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_52c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "18638"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_73a()\n{\n    char * data;\n    list<char *> dataList;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new char[50];\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "22943"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_01()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "11466"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_65a()\n{\n    char * data;\n    /* define a function pointer */\n    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_65aSink;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "4921"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_52bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "24978"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_45Sink()\n{\n    void * data = CWE121_Stack_Based_Buffer_Overflow__CWE135_45_CWE121_Stack_Based_Buffer_Overflow__CWE135_45Data;\n    {\n        /* FIX: treating pointer like a wchar_t*  */\n        size_t dataLen = wcslen((wchar_t *)data);\n        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n        (void)wcscpy(dest, data);\n        printWLine((wchar_t *)dest);\n    }\n}\n",
        "output": "0",
        "idx": "4041"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_67a()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_67_structType myStruct;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "6925"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_03()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(5==5)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "13207"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_73bSink(list<char *> dataList)\n{\n    char * data = dataList.back();\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "7072"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_73bSink(list<wchar_t *> dataList)\n{\n    /* copy data out of dataList */\n    wchar_t * data = dataList.back();\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "25038"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_file_54c_CWE114_Process_Control__w32_char_file_54cSink(char * data)\n{\n    CWE114_Process_Control__w32_char_file_54d_CWE114_Process_Control__w32_char_file_54cSink(data);\n}\n",
        "output": "0",
        "idx": "595"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_64a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_64aSink(&data);\n}\n",
        "output": "1",
        "idx": "20649"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_31()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    {\n        int dataCopy = data;\n        int data = dataCopy;\n        {\n            int i;\n            int * buffer = new int[10];\n            /* initialize buffer */\n            for (i = 0; i < 10; i++)\n            {\n                buffer[i] = 0;\n            }\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n            delete[] buffer;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "19809"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_66a()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_66b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "14467"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_17()\n{\n    int i;\n    char * data;\n    data = NULL;\n    for(i = 0; i < 1; i++)\n    {\n        /* FLAW: Did not leave space for a null terminator */\n        data = new char[10];\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "21064"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_54dSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_54dSink(data);\n}\n",
        "output": "0",
        "idx": "8767"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_connect_socket_41_CWE114_Process_Control__w32_wchar_t_connect_socket_41Sink(wchar_t * data)\n{\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "0",
        "idx": "1037"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_68a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_68_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_68b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_68aSink();\n}\n",
        "output": "0",
        "idx": "2499"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_54bSink_b(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "20619"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_54a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_54aSink_b(data);\n}\n",
        "output": "1",
        "idx": "20616"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_53a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_53aSink_b(data);\n}\n",
        "output": "1",
        "idx": "20604"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "11816"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_54a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_54aSink(data);\n}\n",
        "output": "1",
        "idx": "2933"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    data = new wchar_t[100];\n    {\n        wchar_t * data = *dataPtr1;\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            memmove(dest, data, wcslen(data)*sizeof(wchar_t));\n            dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "27040"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_console_67a()\n{\n    char * data;\n    CWE114_Process_Control__w32_char_console_67_structType myStruct;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        /* Read input from the console */\n        size_t dataLen = strlen(data);\n        /* if there is room in data, read into it from the console */\n        if (100-dataLen > 1)\n        {\n            /* POTENTIAL FLAW: Read data from the console */\n            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                /* The next few lines remove the carriage return from the string that is\n                 * inserted by fgets() */\n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    myStruct.structFirst = data;\n    CWE114_Process_Control__w32_char_console_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "302"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_44Sink(wchar_t * data)\n{\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "5544"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE114_Process_Control__w32_char_relativePath_43Source(char * &data)\n{\n    /* FLAW: Specify just the file name for the library, not the full path */\n    strcpy(data, \"winsrv.dll\");\n}\n",
        "output": "1",
        "idx": "882"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_34()\n{\n    int64_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_34_unionType myUnion;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myUnion.unionFirst = data;\n    {\n        int64_t * data = myUnion.unionSecond;\n        {\n            int64_t source[100] = {0}; /* fill with 0's */\n            {\n                size_t i;\n                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n                for (i = 0; i < 100; i++)\n                {\n                    data[i] = source[i];\n                }\n                printLongLongLine(data[0]);\n            }\n        }\n    }\n}\n",
        "output": "0",
        "idx": "8463"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_21()\n{\n    wchar_t * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_21Static = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_21Source(data);\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "21554"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_64b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    int64_t * * dataPtr = (int64_t * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    int64_t * data = (*dataPtr);\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "8644"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_67a()\n{\n    int * data;\n    structType myStruct;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int[100];\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "24542"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_31()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n            strcat(dest, data);\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "18120"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_68a()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_68aSink();\n}\n",
        "output": "1",
        "idx": "9987"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_74bSink(map<int, wchar_t *> dataMap)\n{\n    /* copy data out of dataMap */\n    wchar_t * data = dataMap[2];\n    {\n        size_t i;\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "24881"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_21()\n{\n    int64_t * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_21Static = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_21Source(data);\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "23969"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_45()\n{\n    int64_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int64_t[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_45Sink();\n}\n",
        "output": "1",
        "idx": "23842"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_54cSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_54cSink(data);\n}\n",
        "output": "0",
        "idx": "9962"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_66bSink(char * dataArray[])\n{\n    char * data = dataArray[2];\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "26633"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_54dSink_d(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "20133"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_environment_53c_CWE114_Process_Control__w32_char_environment_53cSink(char * data)\n{\n    CWE114_Process_Control__w32_char_environment_53d_CWE114_Process_Control__w32_char_environment_53cSink(data);\n}\n",
        "output": "0",
        "idx": "426"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_04()\n{\n    wchar_t * data;\n    data = NULL;\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new wchar_t[100];\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */\n        wcsncat(data, source, 100);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "25214"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_53cSink_c(TwoIntsClass * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "23537"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67a()\n{\n    int * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67_structType myStruct;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "3885"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_68a()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_68aSink();\n}\n",
        "output": "1",
        "idx": "10519"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_63a()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_63aSink(&data);\n}\n",
        "output": "1",
        "idx": "5578"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_65a()\n{\n    int data;\n    void (*funcPtr) (int) = CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_65b_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_65aSink;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "3466"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_relativePath_67a()\n{\n    char * data;\n    CWE114_Process_Control__w32_char_relativePath_67_structType myStruct;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    /* FLAW: Specify just the file name for the library, not the full path */\n    strcpy(data, \"winsrv.dll\");\n    myStruct.structFirst = data;\n    CWE114_Process_Control__w32_char_relativePath_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "946"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53b_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53aSink(data);\n}\n",
        "output": "0",
        "idx": "3414"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_74a()\n{\n    char * data;\n    map<int, char *> dataMap;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "4280"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_52a()\n{\n    int64_t * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int64_t[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_52aSink_b(data);\n}\n",
        "output": "0",
        "idx": "23850"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_53a()\n{\n    char * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new char[100];\n    data[0] = '\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_53aSink_b(data);\n}\n",
        "output": "0",
        "idx": "22407"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_45()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_45Sink();\n}\n",
        "output": "1",
        "idx": "7143"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_33()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    {\n        char * data = dataRef;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n            strncat(dest, data, strlen(data));\n            dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "13911"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_53cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "22732"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_54dSink_d(int * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "24513"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_68a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_68aSink();\n}\n",
        "output": "0",
        "idx": "20182"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_15()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "12437"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_53cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "26918"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_01()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "14490"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_34()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_34_unionType myUnion;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char source[10+1] = SRC_STRING;\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            strcpy(data, source);\n            printLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "4872"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_53a()\n{\n    void * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_53b_CWE121_Stack_Based_Buffer_Overflow__CWE135_53aSink(data);\n}\n",
        "output": "0",
        "idx": "4060"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_72bSink(vector<int *> dataVector)\n{\n    /* copy data out of dataVector */\n    int * data = dataVector[2];\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memmove(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3895"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "12654"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_62a()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_62aSource(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "13968"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_68a()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_68aSink();\n}\n",
        "output": "1",
        "idx": "10120"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    data = NULL;\n    {\n        wchar_t * data = *dataPtr1;\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new wchar_t[100];\n        data[0] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */\n            wcsncat(data, source, 100);\n            printWLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "25269"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_52bSink(data);\n}\n",
        "output": "0",
        "idx": "12493"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_15()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        charVoid structCharVoid;\n        structCharVoid.voidSecond = (void *)SRC_STR;\n        /* Print the initial block pointed to by structCharVoid.voidSecond */\n        printLine((char *)structCharVoid.voidSecond);\n        /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n        memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n        structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n        printLine((char *)structCharVoid.charFirst);\n        printLine((char *)structCharVoid.voidSecond);\n    }\n    break;\n    }\n}\n",
        "output": "0",
        "idx": "1973"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_67_structType myStruct)\n{\n    wchar_t * data = myStruct.structFirst;\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "15277"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "7836"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_34()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_34_unionType myUnion;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n            printLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "4473"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_66a()\n{\n    int data;\n    int dataArray[5];\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_66b_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "2241"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_22a()\n{\n    int * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_22aGlobal = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_22aSource(data);\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n            delete [] data;\n        }\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "24295"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_41_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_41Sink(wchar_t * data)\n{\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "10993"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_21()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_21Static = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_21Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "13735"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_66a()\n{\n    TwoIntsClass * data;\n    TwoIntsClass * dataArray[5];\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new TwoIntsClass[50];\n    /* put data in array */\n    dataArray[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "23732"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_63a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_63b_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_63aSink(&data);\n}\n",
        "output": "0",
        "idx": "3454"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_16()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    while(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        break;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "8451"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_environment_54b_CWE114_Process_Control__w32_char_environment_54bSink(char * data)\n{\n    CWE114_Process_Control__w32_char_environment_54c_CWE114_Process_Control__w32_char_environment_54bSink(data);\n}\n",
        "output": "0",
        "idx": "432"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_54bSink(data);\n}\n",
        "output": "0",
        "idx": "5039"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_45Sink()\n{\n    char * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_45Data;\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "22714"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_54cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "22418"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_73a()\n{\n    int * data;\n    list<int *> dataList;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int[50];\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "24392"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_67a()\n{\n    int * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_67_structType myStruct;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "3619"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_15()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    switch(6)\n    {\n    case 6:\n        /* POTENTIAL FLAW: Read data from the console using fscanf() */\n        fscanf(stdin, \"%d\", &data);\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n",
        "output": "1",
        "idx": "2588"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_22a()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_22aGlobal = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_22aSource(data);\n    {\n        TwoIntsClass source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0].intOne);\n            delete [] data;\n        }\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "23328"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_54dSink(data);\n}\n",
        "output": "0",
        "idx": "6639"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_04()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "6952"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_62bSource(char * &data)\n{\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new char[50];\n    data[0] = '\\0'; /* null terminate */\n}\n",
        "output": "1",
        "idx": "22913"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "14103"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_54cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "26604"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_74bSink(map<int, char *> dataMap)\n{\n    char * data = dataMap[2];\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "25848"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_04()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "9480"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_72bSink(vector<char *> dataVector)\n{\n    /* copy data out of dataVector */\n    char * data = dataVector[2];\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "23263"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static wchar_t * CWE114_Process_Control__w32_wchar_t_connect_socket_21Source(wchar_t * data)\n{\n    if(CWE114_Process_Control__w32_wchar_t_connect_socket_21Static)\n    {\n        /* FIX: Specify the full pathname for the library */\n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    return data;\n}\n",
        "output": "0",
        "idx": "1019"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_51a()\n{\n    char * data;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_51aSink(data);\n}\n",
        "output": "0",
        "idx": "17642"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_41()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_41Sink(data);\n}\n",
        "output": "0",
        "idx": "3371"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_53cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "26435"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_63a()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_63b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_63aSink(&data);\n}\n",
        "output": "0",
        "idx": "9702"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    TwoIntsClass * * dataPtr = (TwoIntsClass * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    TwoIntsClass * data = (*dataPtr);\n    {\n        TwoIntsClass source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(TwoIntsClass));\n        printIntLine(data[0].intOne);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "23565"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_connect_socket_42()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    data = CWE114_Process_Control__w32_char_connect_socket_42Source(data);\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "74"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_45Sink()\n{\n    char * data = CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_45Data;\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        strcpy(data, source);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "27866"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_54bSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "10226"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_22bSource(char * data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_22bGlobal)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new char[100];\n        data[0] = '\\0'; /* null terminate */\n    }\n    return data;\n}\n",
        "output": "0",
        "idx": "22528"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_74bSink(map<int, wchar_t *> dataMap)\n{\n    /* copy data out of dataMap */\n    wchar_t * data = dataMap[2];\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcsncpy(data, source, 100-1);\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "11464"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_15()\n{\n    char * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new char[50];\n        data[0] = '\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "22669"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_52bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "28359"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_console_54c_CWE114_Process_Control__w32_wchar_t_console_54cSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_console_54d_CWE114_Process_Control__w32_wchar_t_console_54cSink(data);\n}\n",
        "output": "0",
        "idx": "1239"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_52bSink(data);\n}\n",
        "output": "0",
        "idx": "6621"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_43Source(wchar_t * &data)\n{\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n}\n",
        "output": "1",
        "idx": "25282"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_54e_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "16754"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_54cSink(data);\n}\n",
        "output": "0",
        "idx": "4376"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_41Sink(wchar_t * data)\n{\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "14881"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_02()\n{\n    char * data;\n    data = NULL;\n    if(1)\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new char[10+1];\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "21345"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_72a()\n{\n    int * data;\n    vector<int *> dataVector;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int[50];\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "24388"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_53cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "27079"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_listen_socket_54c_CWE114_Process_Control__w32_char_listen_socket_54cSink(char * data)\n{\n    CWE114_Process_Control__w32_char_listen_socket_54d_CWE114_Process_Control__w32_char_listen_socket_54cSink(data);\n}\n",
        "output": "0",
        "idx": "756"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_45()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new wchar_t[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_45Sink();\n}\n",
        "output": "1",
        "idx": "22232"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_42Source(char * data)\n{\n    /* FLAW: Did not leave space for a null terminator */\n    data = new char[10];\n    return data;\n}\n",
        "output": "1",
        "idx": "20931"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_52bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "26588"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_53cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "27401"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_72bSink(vector<char *> dataVector)\n{\n    char * data = dataVector[2];\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "12710"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_12()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "6445"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_53cSink(data);\n}\n",
        "output": "0",
        "idx": "6363"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_12()\n{\n    char * data;\n    data = new char[100];\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "26526"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_54bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "22738"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45Sink();\n}\n",
        "output": "0",
        "idx": "2657"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_41_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_41Sink(int64_t * data)\n{\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "8466"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_66a()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "5590"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_45()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_45Sink();\n}\n",
        "output": "1",
        "idx": "6611"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_41()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_41Sink(data);\n}\n",
        "output": "0",
        "idx": "20316"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "6222"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_53bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "22408"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_53bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "27238"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_51a()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_51aSink(data);\n}\n",
        "output": "1",
        "idx": "3575"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_04()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "26663"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "12672"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_73bSink(list<int64_t *> dataList)\n{\n    /* copy data out of dataList */\n    int64_t * data = dataList.back();\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "8933"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45Sink();\n}\n",
        "output": "0",
        "idx": "8741"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_68a()\n{\n    char * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new char[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_68aSink();\n}\n",
        "output": "1",
        "idx": "21164"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_67_structType myStruct)\n{\n    int64_t * data = myStruct.structFirst;\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "8655"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_61a()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_61b_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_61aSource(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "18499"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_72a()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "6666"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_54a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_54aSink_b(data);\n}\n",
        "output": "0",
        "idx": "19633"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_54bSink_b(int64_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "24026"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_68a()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_68_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_68b_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_68aSink();\n}\n",
        "output": "0",
        "idx": "17310"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_45()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_45Sink();\n}\n",
        "output": "0",
        "idx": "10071"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_73a()\n{\n    char * data;\n    list<char *> dataList;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "4542"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_54bSink_b(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "17465"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_06()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "9753"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_53cSink(data);\n}\n",
        "output": "0",
        "idx": "11151"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    wchar_t * data = (*dataPtr);\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "5584"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    data = NULL;\n    {\n        char * data = *dataPtr1;\n        /* FIX: Allocate space for a null terminator */\n        data = new char[10+1];\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            memmove(data, source, (strlen(source) + 1) * sizeof(char));\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "21244"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_54dSink_d(int64_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "23869"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_53bSink_b(int * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "24340"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_53bSink(data);\n}\n",
        "output": "0",
        "idx": "15719"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_67a()\n{\n    twoIntsStruct * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_67_structType myStruct;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "10648"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_34()\n{\n    TwoIntsClass * data;\n    unionType myUnion;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new TwoIntsClass[50];\n    myUnion.unionFirst = data;\n    {\n        TwoIntsClass * data = myUnion.unionSecond;\n        {\n            TwoIntsClass source[100];\n            {\n                size_t i;\n                /* Initialize array */\n                for (i = 0; i < 100; i++)\n                {\n                    source[i].intOne = 0;\n                    source[i].intTwo = 0;\n                }\n            }\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memcpy(data, source, 100*sizeof(TwoIntsClass));\n            printIntLine(data[0].intOne);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "23501"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_73a()\n{\n    wchar_t * data;\n    list<wchar_t *> dataList;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "6537"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_21()\n{\n    char * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_21Source(data);\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */\n        strncat(data, source, 100);\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "22840"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_66a()\n{\n    char * data;\n    char * dataArray[5];\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new char[50];\n    data[0] = '\\0'; /* null terminate */\n    /* put data in array */\n    dataArray[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "22927"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_65a()\n{\n    int * data;\n    /* define a function pointer */\n    void (*funcPtr) (int *) = CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_65aSink;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "3611"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_52bSink(data);\n}\n",
        "output": "0",
        "idx": "15874"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_64a()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_64b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_64aSink(&data);\n}\n",
        "output": "0",
        "idx": "8509"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_02()\n{\n    char * data;\n    data = NULL;\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new char[10+1];\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "20861"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_61bSource(int * data)\n{\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int[50];\n    return data;\n}\n",
        "output": "1",
        "idx": "24519"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_file_66a()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        /* Read input from a file */\n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    /* put data in array */\n    dataArray[2] = data;\n    CWE114_Process_Control__w32_char_file_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "620"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_54cSink(data);\n}\n",
        "output": "0",
        "idx": "12356"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_53d_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "17276"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    char * * dataPtr = (char * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    char * data = (*dataPtr);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "12850"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_01()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FIX: Allocate space for a null terminator */\n    data = new wchar_t[10+1];\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "22147"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_17()\n{\n    int h;\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "5394"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_43Source(void * &data)\n{\n    /* FIX: Set data to point to a char string */\n    data = (void *)CHAR_STRING;\n}\n",
        "output": "0",
        "idx": "4027"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_74bSink(map<int, char *> dataMap)\n{\n    /* copy data out of dataMap */\n    char * data = dataMap[2];\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "21017"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_52b_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_52c_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_52bSink(data);\n}\n",
        "output": "0",
        "idx": "16337"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_66a()\n{\n    char * data;\n    char * dataArray[5];\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_66b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "4261"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_67a()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_67_structType myStruct;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "11048"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_64a()\n{\n    void * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_64aSink(&data);\n}\n",
        "output": "1",
        "idx": "4103"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_07()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    if(staticFive==5)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "8424"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_67a()\n{\n    wchar_t * data;\n    structType myStruct;\n    data = new wchar_t[100];\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "26796"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_06()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "9487"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "8217"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_68a()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_68aSink();\n}\n",
        "output": "1",
        "idx": "28248"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_66bSink(wchar_t * dataArray[])\n{\n    wchar_t * data = dataArray[2];\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "12110"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_53b_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "18322"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_34()\n{\n    int64_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_34_unionType myUnion;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myUnion.unionFirst = data;\n    {\n        int64_t * data = myUnion.unionSecond;\n        {\n            int64_t source[100] = {0}; /* fill with 0's */\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memmove(data, source, 100*sizeof(int64_t));\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "9127"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_54a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_54aSink_b(data);\n}\n",
        "output": "0",
        "idx": "20371"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_45()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_45Sink();\n}\n",
        "output": "1",
        "idx": "25291"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_67a()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_67_structType myStruct;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "4930"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_45()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_45_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_45Sink();\n}\n",
        "output": "0",
        "idx": "3397"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_18()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    goto source;\nsource:\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "6593"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_67a()\n{\n    int * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_67_structType myStruct;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "9717"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_43Source(char * &data)\n{\n    /* FLAW: Did not leave space for a null terminator */\n    data = new char[10];\n}\n",
        "output": "1",
        "idx": "21096"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_66b_CWE121_Stack_Based_Buffer_Overflow__CWE135_66bSink(void * dataArray[])\n{\n    void * data = dataArray[2];\n    {\n        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n        size_t dataLen = strlen((char *)data);\n        void * dest = (void *)ALLOCA((dataLen+1) * 1);\n        (void)strcpy(dest, data);\n        printLine((char *)dest);\n    }\n}\n",
        "output": "0",
        "idx": "4119"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54dSink(data);\n}\n",
        "output": "0",
        "idx": "14765"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_21()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_21Static = 0; /* false */\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_21Sink(data);\n}\n",
        "output": "0",
        "idx": "2359"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45Sink()\n{\n    twoIntsStruct * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45Data;\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "10336"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_15()\n{\n    char * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Did not leave space for a null terminator */\n        data = new char[10];\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "21059"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_relativePath_54c_CWE114_Process_Control__w32_wchar_t_relativePath_54cSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_relativePath_54d_CWE114_Process_Control__w32_wchar_t_relativePath_54cSink(data);\n}\n",
        "output": "0",
        "idx": "1883"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_44()\n{\n    int * data;\n    void (*funcPtr) (int *) = CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_44Sink;\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "3570"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_17()\n{\n    int h;\n    char * data;\n    data = NULL;\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new char[10+1];\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "21387"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_53bSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "8622"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_45()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_45Sink();\n}\n",
        "output": "0",
        "idx": "7677"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_45()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_45Sink();\n}\n",
        "output": "1",
        "idx": "9936"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_52bSink(data);\n}\n",
        "output": "0",
        "idx": "11276"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_52bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "23046"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_73bSink(list<wchar_t *> dataList)\n{\n    /* copy data out of dataList */\n    wchar_t * data = dataList.back();\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "14806"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_67a()\n{\n    int data;\n    structType myStruct;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "19929"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_53b_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "18966"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_44()\n{\n    int data;\n    /* define a function pointer */\n    void (*funcPtr) (int) = CWE121_Stack_Based_Buffer_Overflow__CWE129_large_44Sink;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "2895"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_53cSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_53cSink(data);\n}\n",
        "output": "0",
        "idx": "10353"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_01()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "10004"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_45()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_45Sink();\n}\n",
        "output": "1",
        "idx": "28189"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_53cSink(data);\n}\n",
        "output": "0",
        "idx": "4368"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_15()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        wmemset(data, L'A', 100-1); /* fill with L'A's */\n        data[100-1] = L'\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "14852"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_66bSink(char * dataArray[])\n{\n    /* copy data out of dataArray */\n    char * data = dataArray[2];\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "13019"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_45()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_45Sink();\n}\n",
        "output": "0",
        "idx": "11667"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_52bSink(data);\n}\n",
        "output": "0",
        "idx": "7951"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_74a()\n{\n    char * data;\n    map<int, char *> dataMap;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "17731"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_54cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "21935"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_73a()\n{\n    int64_t * data;\n    list<int64_t *> dataList;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int64_t[50];\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "23909"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_54dSink(data);\n}\n",
        "output": "0",
        "idx": "5043"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_17()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "1978"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_73a()\n{\n    wchar_t * data;\n    list<wchar_t *> dataList;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "5740"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_72a()\n{\n    int64_t * data;\n    vector<int64_t *> dataVector;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_72aSink(dataVector);\n}\n",
        "output": "0",
        "idx": "8529"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_53bSink(data);\n}\n",
        "output": "0",
        "idx": "8356"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_67bSink(structType myStruct)\n{\n    char * data = myStruct.structFirst;\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */\n        strncat(data, source, 100);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "22933"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_68a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_68aSink();\n}\n",
        "output": "1",
        "idx": "20673"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_53bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "24984"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_52bSink(data);\n}\n",
        "output": "0",
        "idx": "13459"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_67_structType myStruct)\n{\n    wchar_t * data = myStruct.structFirst;\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "5995"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_16()\n{\n    char * data;\n    data = new char[100];\n    while(1)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "25892"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_01()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "6146"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_31()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n            wcscat(dest, data);\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "18442"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_53b_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_53c_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_53bSink(data);\n}\n",
        "output": "0",
        "idx": "16609"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_45()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_45Sink();\n}\n",
        "output": "1",
        "idx": "24325"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_34()\n{\n    int64_t * data;\n    unionType myUnion;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int64_t[100];\n    myUnion.unionFirst = data;\n    {\n        int64_t * data = myUnion.unionSecond;\n        {\n            int64_t source[100] = {0}; /* fill with 0's */\n            {\n                size_t i;\n                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n                for (i = 0; i < 100; i++)\n                {\n                    data[i] = source[i];\n                }\n                printLongLongLine(data[0]);\n                delete [] data;\n            }\n        }\n    }\n}\n",
        "output": "0",
        "idx": "23824"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_73a()\n{\n    wchar_t * data;\n    list<wchar_t *> dataList;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "11725"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_15()\n{\n    wchar_t * data;\n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Allocate space for a null terminator */\n        data = new wchar_t[10+1];\n        break;\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "21543"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_63a()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new TwoIntsClass[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_63aSink(&data);\n}\n",
        "output": "0",
        "idx": "23721"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_54cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "26926"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_68a()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_68aSink();\n}\n",
        "output": "0",
        "idx": "9722"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_67a()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_67_structType myStruct;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_67b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "13022"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_67a()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_67_structType myStruct;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "8122"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_53cSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_53cSink(data);\n}\n",
        "output": "0",
        "idx": "9688"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_31()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    {\n        int * dataCopy = data;\n        int * data = dataCopy;\n        {\n            int source[100] = {0}; /* fill with 0's */\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memmove(data, source, 100*sizeof(int));\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "9521"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_68a()\n{\n    int * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_68_CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_68aSink();\n}\n",
        "output": "0",
        "idx": "24707"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_54d_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_54e_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_54dSink(data);\n}\n",
        "output": "0",
        "idx": "17851"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54dSink(data);\n}\n",
        "output": "0",
        "idx": "6373"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_68a()\n{\n    int64_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int64_t[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_68aSink();\n}\n",
        "output": "1",
        "idx": "23901"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_34()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_34_unionType myUnion;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            size_t i, sourceLen;\n            sourceLen = wcslen(source);\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            for (i = 0; i < sourceLen + 1; i++)\n            {\n                data[i] = source[i];\n            }\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "5670"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_54dSink_d(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "19641"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_67_structType myStruct)\n{\n    int64_t * data = myStruct.structFirst;\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "8523"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_32()\n{\n    int * data;\n    int * *dataPtr1 = &data;\n    int * *dataPtr2 = &data;\n    data = NULL;\n    {\n        int * data = *dataPtr1;\n        /* FLAW: Allocate memory without using sizeof(int) */\n        data = (int *)ALLOCA(10);\n        *dataPtr1 = data;\n    }\n    {\n        int * data = *dataPtr2;\n        {\n            int source[10] = {0};\n            /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n            memcpy(data, source, 10*sizeof(int));\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "3690"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_15()\n{\n    char * data;\n    data = new char[100];\n    switch(6)\n    {\n    case 6:\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "26213"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_67_structType myStruct)\n{\n    char * data = myStruct.structFirst;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "12701"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "5438"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_72bSink(vector<void *> dataVector)\n{\n    /* copy data out of dataVector */\n    void * data = dataVector[2];\n    {\n        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n        size_t dataLen = strlen((char *)data);\n        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n        (void)wcscpy((wchar_t *)dest, (wchar_t *)data);\n        printLine((char *)dest);\n    }\n}\n",
        "output": "1",
        "idx": "4136"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_52a()\n{\n    int * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_52aSink_b(data);\n}\n",
        "output": "0",
        "idx": "24655"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_64b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    char * * dataPtr = (char * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    char * data = (*dataPtr);\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "7314"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_67a()\n{\n    int64_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_67_structType myStruct;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "8520"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_44()\n{\n    char * data;\n    /* define a function pointer */\n    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_44Sink;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "7671"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_21()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_21Static = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_21Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "27028"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_21()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_21Static = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_21Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "13896"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_32()\n{\n    int64_t * data;\n    int64_t * *dataPtr1 = &data;\n    int64_t * *dataPtr2 = &data;\n    data = NULL;\n    {\n        int64_t * data = *dataPtr1;\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new int64_t[50];\n        *dataPtr1 = data;\n    }\n    {\n        int64_t * data = *dataPtr2;\n        {\n            int64_t source[100] = {0}; /* fill with 0's */\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memmove(data, source, 100*sizeof(int64_t));\n            printLongLongLine(data[0]);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "24141"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_54dSink_d(int64_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "24191"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_66a()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "11043"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_12()\n{\n    int * data;\n    data = NULL;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int[100];\n    }\n    else\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int[100];\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "24272"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_64a()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_64aSink(&data);\n}\n",
        "output": "1",
        "idx": "7178"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_41Sink(char * data)\n{\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "13271"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "5563"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_66a()\n{\n    char * data;\n    char * dataArray[5];\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "17495"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_54cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "24994"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53b_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53bSink(int data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53c_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53bSink(data);\n}\n",
        "output": "0",
        "idx": "3171"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_52a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_52b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_52aSink(data);\n}\n",
        "output": "0",
        "idx": "2421"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_54dSink_d(TwoIntsClass * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "23708"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_21()\n{\n    char * data;\n    data = new char[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_21Static = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_21Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "28316"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_68a()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new wchar_t[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_68aSink();\n}\n",
        "output": "1",
        "idx": "21647"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_21()\n{\n    int * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_21Source(data);\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "24450"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_file_53b_CWE114_Process_Control__w32_wchar_t_file_53bSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_file_53c_CWE114_Process_Control__w32_wchar_t_file_53bSink(data);\n}\n",
        "output": "0",
        "idx": "1551"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_03()\n{\n    char * data;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    if(5==5)\n    {\n        /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n        data = dataBadBuffer;\n    }\n    if(5==5)\n    {\n        {\n            /* The Visual C++ compiler generates a warning if you initialize the class with ().\n             * This will cause the compile to default-initialize the object.\n             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n             */\n            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n            TwoIntsClass * classTwo = new(data) TwoIntsClass;\n            /* Initialize and make use of the class */\n            classTwo->intOne = 5;\n            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n            printIntLine(classTwo->intOne);\n            /* skip printing classTwo->intTwo since that could be a buffer overread */\n        }\n    }\n}\n",
        "output": "1",
        "idx": "17539"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_45()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_45Sink();\n}\n",
        "output": "0",
        "idx": "8608"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_65b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_65bSink(char * data)\n{\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4392"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_54bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "23221"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_42()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    data = CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_42Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "18133"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_42()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_42Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "12632"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_51a()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_51b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_51aSink(data);\n}\n",
        "output": "0",
        "idx": "9674"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_12()\n{\n    wchar_t * data;\n    data = NULL;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Did not leave space for a null terminator */\n        data = new wchar_t[10];\n    }\n    else\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new wchar_t[10+1];\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "21856"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_04()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "12568"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_54a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_54aSink_b(data);\n}\n",
        "output": "0",
        "idx": "20125"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_33()\n{\n    char * data;\n    char * &dataRef = data;\n    data = new char[100];\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    {\n        char * data = dataRef;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n            strcat(dest, data);\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "28329"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_54bSink(data);\n}\n",
        "output": "0",
        "idx": "12354"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_54dSink_d(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "26928"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_41()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_41Sink(data);\n}\n",
        "output": "0",
        "idx": "2141"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_53bSink(data);\n}\n",
        "output": "0",
        "idx": "12346"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_72bSink(vector<int64_t *> dataVector)\n{\n    /* copy data out of dataVector */\n    int64_t * data = dataVector[2];\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "8663"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_65a()\n{\n    TwoIntsClass * data;\n    void (*funcPtr) (TwoIntsClass *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_65aSink;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new TwoIntsClass[100];\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "23729"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_74a()\n{\n    char * data;\n    map<int, char *> dataMap;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new char[100];\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_74aSink(dataMap);\n}\n",
        "output": "0",
        "idx": "22787"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "6236"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_72bSink(vector<char *> dataVector)\n{\n    char * data = dataVector[2];\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "23264"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_68a()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_68aSink();\n}\n",
        "output": "0",
        "idx": "10387"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_68a()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new wchar_t[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_68aSink();\n}\n",
        "output": "1",
        "idx": "22130"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53aSink(data);\n}\n",
        "output": "0",
        "idx": "2923"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_34()\n{\n    int data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_34_unionType myUnion;\n    /* Initialize data */\n    data = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    myUnion.unionFirst = data;\n    {\n        int data = myUnion.unionSecond;\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}\n",
        "output": "1",
        "idx": "2381"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "13145"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_68a()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_68aSink();\n}\n",
        "output": "1",
        "idx": "8790"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE114_Process_Control__w32_wchar_t_connect_socket_67a()\n{\n    wchar_t * data;\n    CWE114_Process_Control__w32_wchar_t_connect_socket_67_structType myStruct;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    /* FIX: Specify the full pathname for the library */\n    wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    myStruct.structFirst = data;\n    CWE114_Process_Control__w32_wchar_t_connect_socket_67b_CWE114_Process_Control__w32_wchar_t_connect_socket_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "1108"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_54cSink(data);\n}\n",
        "output": "0",
        "idx": "13958"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_33()\n{\n    int * data;\n    int * &dataRef = data;\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    {\n        int * data = dataRef;\n        {\n            int source[10] = {0};\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n            for (i = 0; i < 10; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "3560"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_68a()\n{\n    char * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new char[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_68aSink();\n}\n",
        "output": "1",
        "idx": "21003"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_42Source(wchar_t * data)\n{\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    return data;\n}\n",
        "output": "0",
        "idx": "14404"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_72a()\n{\n    int data;\n    vector<int> dataVector;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_72aSink(dataVector);\n}\n",
        "output": "0",
        "idx": "3490"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_54dSink_d(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "27572"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_53bSink_b(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "19869"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_15()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "7649"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_file_52b_CWE114_Process_Control__w32_wchar_t_file_52bSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_file_52c_CWE114_Process_Control__w32_wchar_t_file_52bSink(data);\n}\n",
        "output": "0",
        "idx": "1545"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_53cSink(data);\n}\n",
        "output": "0",
        "idx": "7161"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_67_structType myStruct)\n{\n    wchar_t * data = myStruct.structFirst;\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "5596"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_14()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "5519"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52aSink(data);\n}\n",
        "output": "0",
        "idx": "2667"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_17()\n{\n    int i,k;\n    int data;\n    /* Initialize data */\n    data = -1;\n    for(i = 0; i < 1; i++)\n    {\n        /* POTENTIAL FLAW: Set data to a random value */\n        data = RAND32();\n    }\n    for(k = 0; k < 1; k++)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}\n",
        "output": "0",
        "idx": "3335"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68a()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68aSink();\n}\n",
        "output": "0",
        "idx": "9855"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_18()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    goto source;\nsource:\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "13088"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_67a()\n{\n    char * data;\n    structType myStruct;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new char[10];\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "21482"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "7034"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    {\n        wchar_t * data = *dataPtr1;\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            wcscpy(data, source);\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "6198"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_51a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_51b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_51aSink(data);\n}\n",
        "output": "0",
        "idx": "2661"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    char * * dataPtr = (char * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    char * data = (*dataPtr);\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strncpy(data, source, 100-1);\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "7446"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_03()\n{\n    wchar_t * data;\n    data = NULL;\n    if(5==5)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new wchar_t[50];\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "25049"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_10()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(globalTrue)\n    {\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "5640"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_53bSink_b(int * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "24662"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_54bSink_b(int64_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "23865"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_54b_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_54bSink(int data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_54c_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_54bSink(data);\n}\n",
        "output": "0",
        "idx": "3183"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_67a()\n{\n    TwoIntsClass * data;\n    structType myStruct;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new TwoIntsClass[100];\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "23576"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_53bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "21281"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_45()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_45Sink();\n}\n",
        "output": "0",
        "idx": "4884"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_10()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    if(globalTrue)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "9100"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_53bSink(data);\n}\n",
        "output": "0",
        "idx": "12499"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_52cSink(wchar_t * data)\n{\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "11144"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_relativePath_53c_CWE114_Process_Control__w32_wchar_t_relativePath_53cSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_relativePath_53d_CWE114_Process_Control__w32_wchar_t_relativePath_53cSink(data);\n}\n",
        "output": "0",
        "idx": "1875"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_42()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_42Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "26889"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_74a()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_74aSink(dataMap);\n}\n",
        "output": "0",
        "idx": "14487"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_72a()\n{\n    TwoIntsClass * data;\n    vector<TwoIntsClass *> dataVector;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new TwoIntsClass[50];\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "23583"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_01()\n{\n    char * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new char[50];\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "23112"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_15()\n{\n    int * data;\n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int[100];\n        break;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "24280"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_45()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_45Sink();\n}\n",
        "output": "0",
        "idx": "9672"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_17()\n{\n    int h;\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "8453"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_environment_62bSource(char * &data)\n{\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            strncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "445"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_44()\n{\n    int64_t * data;\n    /* define a function pointer */\n    void (*funcPtr) (int64_t *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_44Sink;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int64_t[50];\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "23999"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_02()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    if(1)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "9872"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_53c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_53d_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_53cSink(data);\n}\n",
        "output": "0",
        "idx": "18807"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_18()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    goto source;\nsource:\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "9119"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_file_04()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        /* Restore NUL terminator if fgetws fails */\n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "1457"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_45Sink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_45Data;\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "11265"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char * CWE114_Process_Control__w32_char_relativePath_22bSource(char * data)\n{\n    if(CWE114_Process_Control__w32_char_relativePath_22bGlobal)\n    {\n        /* FLAW: Specify just the file name for the library, not the full path */\n        strcpy(data, \"winsrv.dll\");\n    }\n    return data;\n}\n",
        "output": "1",
        "idx": "863"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_53a()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_53aSink_b(data);\n}\n",
        "output": "0",
        "idx": "27076"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * CWE114_Process_Control__w32_char_relativePath_21Source(char * data)\n{\n    if(CWE114_Process_Control__w32_char_relativePath_21Static)\n    {\n        /* FLAW: Specify just the file name for the library, not the full path */\n        strcpy(data, \"winsrv.dll\");\n    }\n    return data;\n}\n",
        "output": "1",
        "idx": "854"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_52bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "21597"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_16()\n{\n    int * data;\n    data = NULL;\n    while(1)\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n        break;\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memmove(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "3816"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_21()\n{\n    wchar_t * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_21Source(data);\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */\n        wcscat(data, source);\n        printWLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "27992"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_73bSink(list<char *> dataList)\n{\n    char * data = dataList.back();\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "21014"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_04()\n{\n    char * data;\n    data = new char[100];\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "26342"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45Sink();\n}\n",
        "output": "0",
        "idx": "3149"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_01()\n{\n    {\n        charVoid structCharVoid;\n        structCharVoid.voidSecond = (void *)SRC_STR;\n        /* Print the initial block pointed to by structCharVoid.voidSecond */\n        printWLine((wchar_t *)structCharVoid.voidSecond);\n        /* FLAW: Use the sizeof(structCharVoid) which will overwrite the pointer voidSecond */\n        memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));\n        structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n        printWLine((wchar_t *)structCharVoid.charFirst);\n        printWLine((wchar_t *)structCharVoid.voidSecond);\n    }\n}\n",
        "output": "1",
        "idx": "19025"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_relativePath_74a()\n{\n    char * data;\n    map<int, char *> dataMap;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    /* FLAW: Specify just the file name for the library, not the full path */\n    strcpy(data, \"winsrv.dll\");\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE114_Process_Control__w32_char_relativePath_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "962"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_34()\n{\n    int64_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_34_unionType myUnion;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myUnion.unionFirst = data;\n    {\n        int64_t * data = myUnion.unionSecond;\n        {\n            int64_t source[100] = {0}; /* fill with 0's */\n            {\n                size_t i;\n                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n                for (i = 0; i < 100; i++)\n                {\n                    data[i] = source[i];\n                }\n                printLongLongLine(data[0]);\n            }\n        }\n    }\n}\n",
        "output": "1",
        "idx": "8462"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "16752"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_14()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "18902"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_53cSink(data);\n}\n",
        "output": "0",
        "idx": "6895"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_21()\n{\n    int64_t * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_21Source(data);\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "23967"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_31()\n{\n    char * data;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n    data = dataGoodBuffer;\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            /* The Visual C++ compiler generates a warning if you initialize the class with ().\n             * This will cause the compile to default-initialize the object.\n             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n             */\n            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n            TwoIntsClass * classTwo = new(data) TwoIntsClass;\n            /* Initialize and make use of the class */\n            classTwo->intOne = 5;\n            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n            printIntLine(classTwo->intOne);\n            /* skip printing classTwo->intTwo since that could be a buffer overread */\n        }\n    }\n}\n",
        "output": "0",
        "idx": "17612"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54a()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54aSink(data);\n}\n",
        "output": "1",
        "idx": "10888"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_44()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_44Sink;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "5545"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_67bSink(structType myStruct)\n{\n    wchar_t * data = myStruct.structFirst;\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "27280"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_66bSink(char * dataArray[])\n{\n    char * data = dataArray[2];\n    {\n        /* The Visual C++ compiler generates a warning if you initialize the class with ().\n         * This will cause the compile to default-initialize the object.\n         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n         */\n        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n        TwoIntsClass * classTwo = new(data) TwoIntsClass;\n        /* Initialize and make use of the class */\n        classTwo->intOne = 5;\n        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n        printIntLine(classTwo->intOne);\n        /* skip printing classTwo->intTwo since that could be a buffer overread */\n    }\n}\n",
        "output": "0",
        "idx": "17499"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_45()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_45Sink();\n}\n",
        "output": "1",
        "idx": "7276"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_17()\n{\n    int h;\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "5527"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_41Sink(twoIntsStruct * data)\n{\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "10060"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_54bSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_54bSink(data);\n}\n",
        "output": "0",
        "idx": "9694"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_64a()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_64b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_64aSink(&data);\n}\n",
        "output": "0",
        "idx": "9307"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_45Sink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_45Data;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "13126"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_67a()\n{\n    twoIntsStruct * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_67_structType myStruct;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "10649"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_15()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    switch(6)\n    {\n    case 6:\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        size_t i;\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "11641"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_01()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "2768"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_54bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "25475"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_21()\n{\n    wchar_t * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_21Source(data);\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "21874"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_22a()\n{\n    char * data;\n    data = new char[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_22aGlobal = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_22aSource(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "26550"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_relativePath_34()\n{\n    wchar_t * data;\n    CWE114_Process_Control__w32_wchar_t_relativePath_34_unionType myUnion;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    /* FLAW: Specify just the file name for the library, not the full path */\n    wcscpy(data, L\"winsrv.dll\");\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            HMODULE hModule;\n            /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n             * replace his own file with the intended library */\n            hModule = LoadLibraryW(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n",
        "output": "1",
        "idx": "1838"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54a()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54aSink(data);\n}\n",
        "output": "1",
        "idx": "8494"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_16()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    while(1)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        wmemset(data, L'A', 100-1); /* fill with L'A's */\n        data[100-1] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "15016"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_72bSink(vector<int64_t *> dataVector)\n{\n    int64_t * data = dataVector[2];\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "8664"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "12225"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_53cSink(data);\n}\n",
        "output": "0",
        "idx": "16204"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_74bSink(map<int, int *> dataMap)\n{\n    /* copy data out of dataMap */\n    int * data = dataMap[2];\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "24720"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53cSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53cSink(data);\n}\n",
        "output": "0",
        "idx": "3856"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_16()\n{\n    int * data;\n    data = NULL;\n    while(1)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int[100];\n        break;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "24283"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_32()\n{\n    int64_t * data;\n    int64_t * *dataPtr1 = &data;\n    int64_t * *dataPtr2 = &data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    {\n        int64_t * data = *dataPtr1;\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        *dataPtr1 = data;\n    }\n    {\n        int64_t * data = *dataPtr2;\n        {\n            int64_t source[100] = {0}; /* fill with 0's */\n            {\n                size_t i;\n                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n                for (i = 0; i < 100; i++)\n                {\n                    data[i] = source[i];\n                }\n                printLongLongLine(data[0]);\n            }\n        }\n    }\n}\n",
        "output": "1",
        "idx": "8458"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_environment_67a()\n{\n    char * data;\n    CWE114_Process_Control__w32_char_environment_67_structType myStruct;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            strncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    myStruct.structFirst = data;\n    CWE114_Process_Control__w32_char_environment_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "463"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_01()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "10934"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_52bSink_b(TwoIntsClass * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "23529"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_51a()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_51aSink(data);\n}\n",
        "output": "1",
        "idx": "8875"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_68a()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_68aSink();\n}\n",
        "output": "1",
        "idx": "8657"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_relativePath_67a()\n{\n    wchar_t * data;\n    CWE114_Process_Control__w32_wchar_t_relativePath_67_structType myStruct;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    /* FLAW: Specify just the file name for the library, not the full path */\n    wcscpy(data, L\"winsrv.dll\");\n    myStruct.structFirst = data;\n    CWE114_Process_Control__w32_wchar_t_relativePath_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "1912"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_file_73a()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        /* Read input from a file */\n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE114_Process_Control__w32_char_file_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "636"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_74bSink(map<int, twoIntsStruct *> dataMap)\n{\n    /* copy data out of dataMap */\n    twoIntsStruct * data = dataMap[2];\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "10134"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_72a()\n{\n    int data;\n    vector<int> dataVector;\n    /* Initialize data */\n    data = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_72aSink(dataVector);\n}\n",
        "output": "0",
        "idx": "2506"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_16()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    while(1)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "12763"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_34()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_34_unionType myUnion;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            memcpy(dest, data, strlen(data)*sizeof(char));\n            dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "12625"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_54bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "21772"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_54bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "27085"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_54cSink_c(TwoIntsClass * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "23545"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_54bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "21611"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_68a()\n{\n    int * data;\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_68_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_68b_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_68aSink();\n}\n",
        "output": "0",
        "idx": "3624"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_41()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_41Sink(data);\n}\n",
        "output": "1",
        "idx": "10061"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_54cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "27087"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_53cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "22249"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_22a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_22aGlobal = 0; /* false */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_22aSink(data);\n}\n",
        "output": "0",
        "idx": "20540"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_68a()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new TwoIntsClass[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_68aSink();\n}\n",
        "output": "1",
        "idx": "23740"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_67a()\n{\n    int * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_67_structType myStruct;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "9850"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_54cSink_c(int64_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "24028"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_06()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strncpy(data, source, 100-1);\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "8155"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_67bSink(structType myStruct)\n{\n    char * data = myStruct.structFirst;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "26475"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_relativePath_54d_CWE114_Process_Control__w32_wchar_t_relativePath_54dSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_relativePath_54e_CWE114_Process_Control__w32_wchar_t_relativePath_54dSink(data);\n}\n",
        "output": "0",
        "idx": "1885"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_21()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_21Static = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_21Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "18431"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_06()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "6561"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_21()\n{\n    char * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_21Static = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_21Source(data);\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "21232"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_15()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        charVoid structCharVoid;\n        structCharVoid.voidSecond = (void *)SRC_STR;\n        /* Print the initial block pointed to by structCharVoid.voidSecond */\n        printLine((char *)structCharVoid.voidSecond);\n        /* FLAW: Use the sizeof(structCharVoid) which will overwrite the pointer voidSecond */\n        memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));\n        structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n        printLine((char *)structCharVoid.charFirst);\n        printLine((char *)structCharVoid.voidSecond);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n",
        "output": "1",
        "idx": "2021"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "7028"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_53cSink(data);\n}\n",
        "output": "0",
        "idx": "15721"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_66a()\n{\n    int64_t * data;\n    int64_t * dataArray[5];\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int64_t[100];\n    dataArray[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "23894"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_relativePath_41()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    /* FLAW: Specify just the file name for the library, not the full path */\n    strcpy(data, \"winsrv.dll\");\n    CWE114_Process_Control__w32_char_relativePath_41Sink(data);\n}\n",
        "output": "1",
        "idx": "875"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_21()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_21Static = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_21Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "18592"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_41_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_41Sink(char * data)\n{\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "12468"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_53bSink(data);\n}\n",
        "output": "0",
        "idx": "13787"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_67_structType myStruct)\n{\n    char * data = myStruct.structFirst;\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "7192"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54cSink(data);\n}\n",
        "output": "0",
        "idx": "6903"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_41()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_41Sink(data);\n}\n",
        "output": "1",
        "idx": "2877"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_63a()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_63b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_63aSink(&data);\n}\n",
        "output": "0",
        "idx": "8505"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_15()\n{\n    char * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Did not leave space for a null terminator */\n        data = new char[10];\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "20898"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_32()\n{\n    int data;\n    int *dataPtr1 = &data;\n    int *dataPtr2 = &data;\n    /* Initialize data */\n    data = -1;\n    {\n        int data = *dataPtr1;\n        /* POTENTIAL FLAW: Read data from the console using fscanf() */\n        fscanf(stdin, \"%d\", &data);\n        *dataPtr1 = data;\n    }\n    {\n        int data = *dataPtr2;\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}\n",
        "output": "1",
        "idx": "2621"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_21()\n{\n    char * data;\n    data = new char[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_21Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "26060"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_54dSink_d(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "22259"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "16035"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_51a()\n{\n    void * data;\n    data = NULL;\n    /* FIX: Set data to point to a char string */\n    data = (void *)CHAR_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_51b_CWE121_Stack_Based_Buffer_Overflow__CWE135_51aSink(data);\n}\n",
        "output": "0",
        "idx": "4044"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_53bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "26111"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_73a()\n{\n    wchar_t * data;\n    list<wchar_t *> dataList;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "14482"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_54dSink_d(int * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "24352"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_22a()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_22_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_22aGlobal = 0; /* false */\n    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_22_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_22aSource(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "18920"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_14()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(globalFive==5)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "7114"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_67a()\n{\n    char * data;\n    structType myStruct;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "17707"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_21()\n{\n    wchar_t * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_21Static = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_21Source(data);\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "21876"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_52bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "21114"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "11016"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "6496"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_63a()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_63b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_63aSink(&data);\n}\n",
        "output": "0",
        "idx": "13489"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_52b_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_52c_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "17994"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_66a()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    /* put data in array */\n    dataArray[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "25181"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_52bSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "10212"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_66a()\n{\n    int data;\n    int dataArray[5];\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    dataArray[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "20663"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_45()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_45Sink();\n}\n",
        "output": "1",
        "idx": "8473"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_54a()\n{\n    void * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_54aSink(data);\n}\n",
        "output": "1",
        "idx": "4070"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_66a()\n{\n    int data;\n    int dataArray[5];\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "2978"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_54bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "25958"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_54dSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_54dSink(data);\n}\n",
        "output": "0",
        "idx": "3866"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_environment_53b_CWE114_Process_Control__w32_wchar_t_environment_53bSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_environment_53c_CWE114_Process_Control__w32_wchar_t_environment_53bSink(data);\n}\n",
        "output": "0",
        "idx": "1390"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "4767"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_54cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "28214"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_41()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_41Sink(data);\n}\n",
        "output": "1",
        "idx": "6204"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_15()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    switch(6)\n    {\n    case 6:\n        /* POTENTIAL FLAW: Read data from the console using fscanf() */\n        fscanf(stdin, \"%d\", &data);\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* FIX: Properly validate the array index and prevent a buffer overflow */\n        if (data >= 0 && data < (10))\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is out-of-bounds\");\n        }\n    }\n    break;\n    }\n}\n",
        "output": "0",
        "idx": "2589"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_67a()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_67_structType myStruct;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "6392"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_01()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int[50];\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "24400"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_53cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "22410"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_54cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "20969"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_22bSource(char * data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_22bGlobal)\n    {\n        /* FLAW: Did not leave space for a null terminator */\n        data = new char[10];\n    }\n    return data;\n}\n",
        "output": "1",
        "idx": "20755"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_34()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_34_unionType myUnion;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t dest[50] = L\"\";\n            size_t i, dataLen;\n            dataLen = wcslen(data);\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            for (i = 0; i < dataLen; i++)\n            {\n                dest[i] = data[i];\n            }\n            dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "15362"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_54dSink_d(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "20971"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_53bSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_53bSink(data);\n}\n",
        "output": "0",
        "idx": "9154"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_74bSink(map<int, char *> dataMap)\n{\n    char * data = dataMap[2];\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "7076"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_54cSink_c(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "20376"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_53bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "25950"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_73a()\n{\n    int data;\n    list<int> dataList;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "3002"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_connect_socket_41Sink(char * data)\n{\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "69"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    char * * dataPtr = (char * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    char * data = (*dataPtr);\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4254"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_54a()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FIX: Allocate space for a null terminator */\n    data = new wchar_t[10+1];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_54aSink_b(data);\n}\n",
        "output": "0",
        "idx": "21610"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "7437"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_52bSink_b(int * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "24334"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_21()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_21Static = 0; /* false */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_21Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "14059"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_68a()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_68_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_68b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_68aSink();\n}\n",
        "output": "0",
        "idx": "5067"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_67a()\n{\n    void * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_67_structType myStruct;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "4121"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_67_structType myStruct)\n{\n    char * data = myStruct.structFirst;\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strncpy(data, source, 100-1);\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "7458"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int64_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_21Source(int64_t * data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_21Static)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new int64_t[50];\n    }\n    return data;\n}\n",
        "output": "1",
        "idx": "24127"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_54bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "26441"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_72a()\n{\n    char * data;\n    vector<char *> dataVector;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_72aSink(dataVector);\n}\n",
        "output": "0",
        "idx": "5071"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_51a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_51aSink(data);\n}\n",
        "output": "0",
        "idx": "20344"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_54bSink(data);\n}\n",
        "output": "0",
        "idx": "15244"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_52b_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_52c_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "16736"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_72bSink(vector<int> dataVector)\n{\n    /* copy data out of dataVector */\n    int data = dataVector[2];\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "2261"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_08()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "18240"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE135_67_structType myStruct)\n{\n    void * data = myStruct.structFirst;\n    {\n        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n        size_t dataLen = strlen((char *)data);\n        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n        (void)wcscpy(dest, data);\n        printLine((char *)dest);\n    }\n}\n",
        "output": "1",
        "idx": "4124"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_74bSink(map<int, int *> dataMap)\n{\n    /* copy data out of dataMap */\n    int * data = dataMap[2];\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3637"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_73a()\n{\n    char * data;\n    list<char *> dataList;\n    data = NULL;\n    /* FIX: Allocate space for a null terminator */\n    data = new char[10+1];\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "20851"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_41()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_41Sink(data);\n}\n",
        "output": "1",
        "idx": "3697"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_33()\n{\n    void * data;\n    void * &dataRef = data;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    {\n        void * data = dataRef;\n        {\n            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n            size_t dataLen = strlen((char *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy((wchar_t *)dest, (wchar_t *)data);\n            printLine((char *)dest);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "4007"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_68a()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_68aSink();\n}\n",
        "output": "1",
        "idx": "25672"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_66a()\n{\n    void * data;\n    void * dataArray[5];\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_66b_CWE121_Stack_Based_Buffer_Overflow__CWE135_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "4117"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54cSink(data);\n}\n",
        "output": "0",
        "idx": "14763"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_45()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_45Sink();\n}\n",
        "output": "1",
        "idx": "6744"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_51a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_51aSink(data);\n}\n",
        "output": "0",
        "idx": "19852"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_34()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_34_unionType myUnion;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "5802"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_65a()\n{\n    twoIntsStruct * data;\n    void (*funcPtr) (twoIntsStruct *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_65b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_65aSink;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "10508"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_54cSink(data);\n}\n",
        "output": "0",
        "idx": "7169"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_04()\n{\n    char * data;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n        data = dataGoodBuffer;\n    }\n    if(STATIC_CONST_TRUE)\n    {\n        {\n            /* The Visual C++ compiler generates a warning if you initialize the class with ().\n             * This will cause the compile to default-initialize the object.\n             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n             */\n            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n            TwoIntsClass * classTwo = new(data) TwoIntsClass;\n            /* Initialize and make use of the class */\n            classTwo->intOne = 5;\n            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n            printIntLine(classTwo->intOne);\n            /* skip printing classTwo->intTwo since that could be a buffer overread */\n        }\n    }\n}\n",
        "output": "0",
        "idx": "17547"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_68a()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_68aSink();\n}\n",
        "output": "0",
        "idx": "10254"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_68a()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new wchar_t[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_68aSink();\n}\n",
        "output": "1",
        "idx": "21969"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_44()\n{\n    wchar_t * data;\n    /* define a function pointer */\n    void (*funcPtr) (wchar_t *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_44Sink;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "25287"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "15568"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_45()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_45Sink();\n}\n",
        "output": "0",
        "idx": "9539"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    data = NULL;\n    {\n        char * data = *dataPtr1;\n        /* FLAW: Did not leave space for a null terminator */\n        data = new char[10];\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char source[10+1] = SRC_STRING;\n            size_t i, sourceLen;\n            sourceLen = strlen(source);\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            for (i = 0; i < sourceLen + 1; i++)\n            {\n                data[i] = source[i];\n            }\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "20921"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_01()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "2276"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_68a()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_68aSink();\n}\n",
        "output": "1",
        "idx": "13830"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_16()\n{\n    int64_t * data;\n    data = NULL;\n    while(1)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new int64_t[50];\n        break;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "24121"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_68a()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_68aSink();\n}\n",
        "output": "0",
        "idx": "11983"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_21()\n{\n    char * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_21Static = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_21Source(data);\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "20749"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    {\n        wchar_t * data = *dataPtr1;\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            size_t i;\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "11650"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_66a()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n    data = dataGoodBuffer;\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "17702"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_45()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_45Sink();\n}\n",
        "output": "0",
        "idx": "17432"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_34()\n{\n    int * data;\n    unionType myUnion;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int[50];\n    myUnion.unionFirst = data;\n    {\n        int * data = myUnion.unionSecond;\n        {\n            int source[100] = {0}; /* fill with 0's */\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memmove(data, source, 100*sizeof(int));\n            printIntLine(data[0]);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "24628"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_73a()\n{\n    twoIntsStruct * data;\n    list<twoIntsStruct *> dataList;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "10128"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_42Source(int data)\n{\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    return data;\n}\n",
        "output": "1",
        "idx": "3374"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "15566"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_09()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4840"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_33()\n{\n    char * data;\n    char * &dataRef = data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char * data = dataRef;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n            strncat(data, source, 100);\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "7263"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_16()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    while(1)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "6057"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_52b_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_52c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_52bSink(data);\n}\n",
        "output": "0",
        "idx": "17135"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_73a()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "4942"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "4243"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_06()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        wmemset(data, L'A', 100-1); /* fill with L'A's */\n        data[100-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "27151"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * CWE114_Process_Control__w32_char_environment_21Source(char * data)\n{\n    if(CWE114_Process_Control__w32_char_environment_21Static)\n    {\n        {\n            /* Append input from an environment variable to data */\n            size_t dataLen = strlen(data);\n            char * environment = GETENV(ENV_VARIABLE);\n            /* If there is data in the environment variable */\n            if (environment != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from an environment variable */\n                strncat(data+dataLen, environment, 100-dataLen-1);\n            }\n        }\n    }\n    return data;\n}\n",
        "output": "1",
        "idx": "371"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_52a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_52b_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_52aSink(data);\n}\n",
        "output": "0",
        "idx": "3159"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_22a()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_22_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_22aGlobal = 0; /* false */\n    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_22_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_22aSource(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "18759"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_68a()\n{\n    int64_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int64_t[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_68aSink();\n}\n",
        "output": "1",
        "idx": "24062"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_08()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(staticReturnsTrue())\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "5902"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_21()\n{\n    char * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_21Source(data);\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        strncpy(data, source, 100-1);\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "23005"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_17()\n{\n    int k;\n    for(k = 0; k < 1; k++)\n    {\n        {\n            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));\n            if (structCharVoid == NULL) {exit(-1);}\n            structCharVoid->voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid->voidSecond */\n            printLine((char *)structCharVoid->voidSecond);\n            /* FIX: Use the sizeof(structCharVoid->charFirst) to avoid overwriting the pointer y */\n            memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));\n            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid->charFirst);\n            printLine((char *)structCharVoid->voidSecond);\n            free(structCharVoid);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "19169"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_73a()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "13678"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_67a()\n{\n    wchar_t * data;\n    structType myStruct;\n    data = NULL;\n    /* FIX: Allocate space for a null terminator */\n    data = new wchar_t[10+1];\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "21644"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_16()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    while(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        size_t i;\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "11643"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_06()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "8554"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_02()\n{\n    int64_t * data;\n    data = NULL;\n    if(1)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int64_t[100];\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "23921"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_72bSink(vector<wchar_t *> dataVector)\n{\n    /* copy data out of dataVector */\n    wchar_t * data = dataVector[2];\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "21653"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_53bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "21120"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_53bSink_b(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "19377"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_53cSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "10619"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_relativePath_53c_CWE114_Process_Control__w32_char_relativePath_53cSink(char * data)\n{\n    CWE114_Process_Control__w32_char_relativePath_53d_CWE114_Process_Control__w32_char_relativePath_53cSink(data);\n}\n",
        "output": "0",
        "idx": "909"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_21()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_21Static = 0; /* false */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_21Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "14703"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_67a()\n{\n    int64_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_67_structType myStruct;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "8521"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_03()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(5==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "5887"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_54dSink(data);\n}\n",
        "output": "0",
        "idx": "4378"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_54cSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_54cSink(data);\n}\n",
        "output": "0",
        "idx": "9563"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_07()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    if(staticFive==5)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "9621"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_relativePath_03()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(5==5)\n    {\n        /* FLAW: Specify just the file name for the library, not the full path */\n        wcscpy(data, L\"winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "1776"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_53cSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_53cSink(data);\n}\n",
        "output": "0",
        "idx": "8491"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_13()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "5649"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_console_53c_CWE114_Process_Control__w32_char_console_53cSink(char * data)\n{\n    CWE114_Process_Control__w32_char_console_53d_CWE114_Process_Control__w32_char_console_53cSink(data);\n}\n",
        "output": "0",
        "idx": "265"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_64a()\n{\n    int64_t * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int64_t[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_64aSink(&data);\n}\n",
        "output": "0",
        "idx": "23886"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_01()\n{\n    {\n        charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));\n        if (structCharVoid == NULL) {exit(-1);}\n        structCharVoid->voidSecond = (void *)SRC_STR;\n        /* Print the initial block pointed to by structCharVoid->voidSecond */\n        printLine((char *)structCharVoid->voidSecond);\n        /* FIX: Use the sizeof(structCharVoid->charFirst) to avoid overwriting the pointer y */\n        memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));\n        structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n        printLine((char *)structCharVoid->charFirst);\n        printLine((char *)structCharVoid->voidSecond);\n        free(structCharVoid);\n    }\n}\n",
        "output": "0",
        "idx": "19124"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_53dSink(char * data)\n{\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4236"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_63a()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_63aSink(&data);\n}\n",
        "output": "1",
        "idx": "17477"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_53cSink_c(TwoIntsClass * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "23376"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_54dSink(data);\n}\n",
        "output": "0",
        "idx": "14282"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_52bSink(data);\n}\n",
        "output": "0",
        "idx": "10877"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_08()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    if(staticReturnsTrue())\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "8562"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_41()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_41Sink(data);\n}\n",
        "output": "1",
        "idx": "20068"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_08()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "7496"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_54c_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_54d_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_54cSink(data);\n}\n",
        "output": "0",
        "idx": "18171"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_73bSink(list<void *> dataList)\n{\n    void * data = dataList.back();\n    {\n        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n        size_t dataLen = strlen((char *)data);\n        void * dest = (void *)ALLOCA((dataLen+1) * 1);\n        (void)strcpy((char *)dest, (char *)data);\n        printLine((char *)dest);\n    }\n}\n",
        "output": "0",
        "idx": "4143"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_54dSink(data);\n}\n",
        "output": "0",
        "idx": "15731"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_54dSink_d(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "23225"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_21()\n{\n    wchar_t * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_21Source(data);\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "24933"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_17()\n{\n    int h,j;\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n        data = dataGoodBuffer;\n    }\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* The Visual C++ compiler generates a warning if you initialize the class with ().\n             * This will cause the compile to default-initialize the object.\n             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n             */\n            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n            TwoIntsClass * classTwo = new(data) TwoIntsClass;\n            /* Initialize and make use of the class */\n            classTwo->intOne = 5;\n            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n            printIntLine(classTwo->intOne);\n            /* skip printing classTwo->intTwo since that could be a buffer overread */\n        }\n    }\n}\n",
        "output": "0",
        "idx": "17401"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_01()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3506"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_52bSink_b(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "20352"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67_structType myStruct)\n{\n    int data = myStruct.structFirst;\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "2249"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_68a()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_68aSink();\n}\n",
        "output": "1",
        "idx": "7460"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_54eSink_e(char * data)\n{\n    {\n        /* The Visual C++ compiler generates a warning if you initialize the class with ().\n         * This will cause the compile to default-initialize the object.\n         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n         */\n        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n        TwoIntsClass * classTwo = new(data) TwoIntsClass;\n        /* Initialize and make use of the class */\n        classTwo->intOne = 5;\n        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n        printIntLine(classTwo->intOne);\n        /* skip printing classTwo->intTwo since that could be a buffer overread */\n    }\n}\n",
        "output": "1",
        "idx": "17474"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_53bSink(data);\n}\n",
        "output": "0",
        "idx": "15236"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_73bSink(list<char *> dataList)\n{\n    /* copy data out of dataList */\n    char * data = dataList.back();\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "25843"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    {\n        char * data = *dataPtr1;\n        /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n        data = dataBadBuffer;\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            /* The Visual C++ compiler generates a warning if you initialize the class with ().\n             * This will cause the compile to default-initialize the object.\n             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n             */\n            /* FIX: data will at least be the sizeof(OneIntClass) */\n            OneIntClass * classOne = new(data) OneIntClass;\n            /* Initialize and make use of the class */\n            classOne->intOne = 5;\n            printIntLine(classOne->intOne);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "17410"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_68bSink()\n{\n    int * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_68bData;\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "24386"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_41Sink(char * data)\n{\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4341"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_relativePath_53b_CWE114_Process_Control__w32_wchar_t_relativePath_53bSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_relativePath_53c_CWE114_Process_Control__w32_wchar_t_relativePath_53bSink(data);\n}\n",
        "output": "0",
        "idx": "1873"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53b_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53aSink(data);\n}\n",
        "output": "0",
        "idx": "2184"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_68a()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new wchar_t[100];\n    data[0] = L'\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_68_CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_68aSink();\n}\n",
        "output": "0",
        "idx": "25029"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_65a()\n{\n    char * data;\n    /* define a function pointer */\n    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_65aSink;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "13818"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_63a()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_63aSink(&data);\n}\n",
        "output": "1",
        "idx": "10632"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    {\n        wchar_t * data = *dataPtr1;\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "5931"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22aGlobal = 0; /* false */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22aSink(data);\n}\n",
        "output": "0",
        "idx": "19802"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_53cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "27884"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_72bSink(vector<wchar_t *> dataVector)\n{\n    /* copy data out of dataVector */\n    wchar_t * data = dataVector[2];\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "25678"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_72bSink(vector<char *> dataVector)\n{\n    /* copy data out of dataVector */\n    char * data = dataVector[2];\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4540"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    data = new wchar_t[100];\n    {\n        wchar_t * data = *dataPtr1;\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        wmemset(data, L'A', 100-1); /* fill with L'A's */\n        data[100-1] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t dest[50] = L\"\";\n            size_t i, dataLen;\n            dataLen = wcslen(data);\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            for (i = 0; i < dataLen; i++)\n            {\n                dest[i] = data[i];\n            }\n            dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "26717"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    char * * dataPtr = (char * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    char * data = (*dataPtr);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "13333"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "11417"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_54cSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_54cSink(data);\n}\n",
        "output": "0",
        "idx": "8765"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_34()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_34_unionType myUnion;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            SNPRINTF(dest, strlen(data), \"%s\", data);\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "14235"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_68a()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_68aSink();\n}\n",
        "output": "1",
        "idx": "14313"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_66bSink(int * dataArray[])\n{\n    /* copy data out of dataArray */\n    int * data = dataArray[2];\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "9316"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "14111"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_54cSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_54cSink(data);\n}\n",
        "output": "0",
        "idx": "9696"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_connect_socket_41Sink(wchar_t * data)\n{\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "1035"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_53cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "25469"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_63a()\n{\n    char * data;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_63aSink(&data);\n}\n",
        "output": "1",
        "idx": "17683"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_53bSink(data);\n}\n",
        "output": "0",
        "idx": "5696"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_54dSink(data);\n}\n",
        "output": "0",
        "idx": "16214"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_66a()\n{\n    int64_t * data;\n    int64_t * dataArray[5];\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "8916"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_67a()\n{\n    wchar_t * data;\n    structType myStruct;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "25024"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_relativePath_73a()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    /* FLAW: Specify just the file name for the library, not the full path */\n    strcpy(data, \"winsrv.dll\");\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE114_Process_Control__w32_char_relativePath_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "958"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_51a()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_51b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_51aSink(data);\n}\n",
        "output": "0",
        "idx": "8876"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_54cSink(data);\n}\n",
        "output": "0",
        "idx": "11558"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_73a()\n{\n    char * data;\n    list<char *> dataList;\n    data = NULL;\n    /* FIX: Allocate space for a null terminator */\n    data = new char[10+1];\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "21495"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_73bSink(list<wchar_t *> dataList)\n{\n    wchar_t * data = dataList.back();\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "5609"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_72a()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_72aSink(dataVector);\n}\n",
        "output": "0",
        "idx": "11721"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_34()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_34_unionType myUnion;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            wcscpy(data, source);\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "5537"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_21()\n{\n    char * data;\n    data = new char[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_21Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "25899"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_01()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "5083"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "4499"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_41_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_41Sink(wchar_t * data)\n{\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "5806"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_02()\n{\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n            printWLine((wchar_t *)structCharVoid.charFirst);\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "19028"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_54dSink_d(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "22420"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static wchar_t * CWE114_Process_Control__w32_wchar_t_relativePath_21Source(wchar_t * data)\n{\n    if(CWE114_Process_Control__w32_wchar_t_relativePath_21Static)\n    {\n        /* FLAW: Specify just the file name for the library, not the full path */\n        wcscpy(data, L\"winsrv.dll\");\n    }\n    return data;\n}\n",
        "output": "1",
        "idx": "1820"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_54cSink_c(int * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "24350"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_68a()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_68aSink();\n}\n",
        "output": "0",
        "idx": "9456"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_53bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "27721"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_17()\n{\n    int h;\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "7522"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static wchar_t * CWE114_Process_Control__w32_wchar_t_console_21Source(wchar_t * data)\n{\n    if(CWE114_Process_Control__w32_wchar_t_console_21Static)\n    {\n        {\n            /* Read input from the console */\n            size_t dataLen = wcslen(data);\n            /* if there is room in data, read into it from the console */\n            if (100-dataLen > 1)\n            {\n                /* POTENTIAL FLAW: Read data from the console */\n                if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n                {\n                    /* The next few lines remove the carriage return from the string that is\n                     * inserted by fgetws() */\n                    dataLen = wcslen(data);\n                    if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                    {\n                        data[dataLen-1] = L'\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgetws() failed\");\n                    /* Restore NUL terminator if fgetws fails */\n                    data[dataLen] = L'\\0';\n                }\n            }\n        }\n    }\n    return data;\n}\n",
        "output": "1",
        "idx": "1176"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_68a()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_68aSink();\n}\n",
        "output": "0",
        "idx": "9589"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_66a()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    data = NULL;\n    /* FIX: Allocate space for a null terminator */\n    data = new wchar_t[10+1];\n    dataArray[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "21640"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_53cSink(data);\n}\n",
        "output": "0",
        "idx": "14755"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    char * * dataPtr = (char * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    char * data = (*dataPtr);\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4520"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_53bSink_b(TwoIntsClass * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "23696"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_66a()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_66b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "5591"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_53bSink_b(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "20607"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_44()\n{\n    char * data;\n    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_44Sink;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n    data = dataGoodBuffer;\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "17426"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_54cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "26282"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char * CWE114_Process_Control__w32_char_connect_socket_22_CWE114_Process_Control__w32_char_connect_socket_22bSource(char * data)\n{\n    if(CWE114_Process_Control__w32_char_connect_socket_22_CWE114_Process_Control__w32_char_connect_socket_22bGlobal)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Specify the full pathname for the library */\n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    return data;\n}\n",
        "output": "0",
        "idx": "59"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE114_Process_Control__w32_char_connect_socket_02()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Specify the full pathname for the library */\n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "0",
        "idx": "3"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_02()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(1)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        wmemset(data, L'A', 100-1); /* fill with L'A's */\n        data[100-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "14492"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_67_structType myStruct)\n{\n    int * data = myStruct.structFirst;\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "9453"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_53cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "22893"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_54bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "25797"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_41Sink(wchar_t * data)\n{\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "11523"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_53cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "27723"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45Sink()\n{\n    int64_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45Data;\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "8738"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_31()\n{\n    char * data;\n    data = new char[100];\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            SNPRINTF(dest, strlen(data), \"%s\", data);\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "26555"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_31()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n            strncat(dest, data, strlen(data));\n            dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "13907"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "12670"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_54cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "21452"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_54bSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_54bSink(data);\n}\n",
        "output": "0",
        "idx": "10093"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_51a()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_51aSink(data);\n}\n",
        "output": "1",
        "idx": "3841"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_07()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(staticFive==5)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "10951"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_52bSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_52bSink(data);\n}\n",
        "output": "0",
        "idx": "9680"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53c_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53cSink(int data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53d_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53cSink(data);\n}\n",
        "output": "0",
        "idx": "2190"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_54cSink_c(int64_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "23867"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_73bSink(list<wchar_t *> dataList)\n{\n    wchar_t * data = dataList.back();\n    {\n        size_t i;\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "24878"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_53cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "21444"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_02()\n{\n    int * data;\n    data = NULL;\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int[100];\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "24403"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_52bSink_b(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "20106"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_54bSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_54bSink(data);\n}\n",
        "output": "0",
        "idx": "10359"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_33()\n{\n    wchar_t * data;\n    wchar_t * &dataRef = data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new wchar_t[100];\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t * data = dataRef;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n            wcsncpy(data, source, 100-1);\n            data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "25432"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_45()\n{\n    char * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new char[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_45Sink();\n}\n",
        "output": "1",
        "idx": "20944"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_53cSink(data);\n}\n",
        "output": "0",
        "idx": "12348"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_18()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    goto source;\nsource:\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "11247"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_45()\n{\n    int * data;\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_45_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_45Sink();\n}\n",
        "output": "0",
        "idx": "3574"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_18()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    goto source;\nsource:\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "5130"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_33()\n{\n    int * data;\n    int * &dataRef = data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    {\n        int * data = dataRef;\n        {\n            int source[100] = {0}; /* fill with 0's */\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memcpy(data, source, 100*sizeof(int));\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "9391"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_34()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_34_unionType myUnion;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            memcpy(data, source, 100*sizeof(char));\n            data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "6999"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_53a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_53aSink_b(data);\n}\n",
        "output": "0",
        "idx": "20113"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_53bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "26755"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_64a()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new wchar_t[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_64aSink(&data);\n}\n",
        "output": "1",
        "idx": "22275"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_15()\n{\n    wchar_t * data;\n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new wchar_t[100];\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "24924"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_12()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "7774"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_73a()\n{\n    int64_t * data;\n    list<int64_t *> dataList;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int64_t[100];\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "23910"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_54bSink_b(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "20127"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53bSink(int data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53c_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53bSink(data);\n}\n",
        "output": "0",
        "idx": "2925"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_17()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FLAW: Use the sizeof(structCharVoid) which will overwrite the pointer voidSecond */\n            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "1977"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_54cSink(data);\n}\n",
        "output": "0",
        "idx": "5972"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_72a()\n{\n    char * data;\n    vector<char *> dataVector;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "4272"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_52bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "27715"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_54cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "27892"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_52bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "26749"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_02()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(1)\n    {\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4818"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_file_53b_CWE114_Process_Control__w32_char_file_53bSink(char * data)\n{\n    CWE114_Process_Control__w32_char_file_53c_CWE114_Process_Control__w32_char_file_53bSink(data);\n}\n",
        "output": "0",
        "idx": "585"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_12()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "11897"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_04()\n{\n    int * data;\n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Allocate memory without using sizeof(int) */\n        data = (int *)ALLOCA(10);\n    }\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3514"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_03()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(5==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4424"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_17()\n{\n    int h;\n    int * data;\n    data = NULL;\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int[100];\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "24285"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_73a()\n{\n    wchar_t * data;\n    list<wchar_t *> dataList;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "11724"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_68a()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_68aSink();\n}\n",
        "output": "1",
        "idx": "18365"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_16()\n{\n    char * data;\n    data = new char[100];\n    while(1)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "25731"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_53cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "25147"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_12()\n{\n    int * data;\n    data = NULL;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Allocate memory without using sizeof(int) */\n        data = (int *)ALLOCA(10);\n    }\n    else\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3671"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_52bSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "9813"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_45()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_45Sink();\n}\n",
        "output": "1",
        "idx": "16460"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_67_structType myStruct)\n{\n    char * data = myStruct.structFirst;\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "7326"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_21Source(char * data)\n{\n    if(CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_21Static)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n    }\n    return data;\n}\n",
        "output": "1",
        "idx": "12446"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_67a()\n{\n    char * data;\n    structType myStruct;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n    data = dataGoodBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "17708"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_65a()\n{\n    void * data;\n    /* define a function pointer */\n    void (*funcPtr) (void *) = CWE121_Stack_Based_Buffer_Overflow__CWE135_65aSink;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "4109"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_54dSink_d(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "22742"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_53cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "27562"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_64b_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    char * * dataPtr = (char * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    char * data = (*dataPtr);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "17869"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_15()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    switch(6)\n    {\n    case 6:\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "6853"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67_structType myStruct)\n{\n    int * data = myStruct.structFirst;\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memmove(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3887"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_45Sink()\n{\n    int * data = CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_45Data;\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3704"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_66a()\n{\n    char * data;\n    char * dataArray[5];\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "4393"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_34()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_34_unionType myUnion;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char source[10+1] = SRC_STRING;\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            strcpy(data, source);\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "4871"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_15()\n{\n    int64_t * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new int64_t[50];\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "23796"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_54cSink(data);\n}\n",
        "output": "0",
        "idx": "6637"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_52a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_52aSink_b(data);\n}\n",
        "output": "0",
        "idx": "20596"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_67a()\n{\n    int * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_67_structType myStruct;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "9451"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_54bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "26280"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_64b_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    wchar_t * data = (*dataPtr);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "18513"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67_structType myStruct)\n{\n    char * data = myStruct.structFirst;\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4266"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_61bSource(int * data)\n{\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int[100];\n    return data;\n}\n",
        "output": "0",
        "idx": "24520"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_51a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_51aSink(data);\n}\n",
        "output": "1",
        "idx": "3398"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_73a()\n{\n    TwoIntsClass * data;\n    list<TwoIntsClass *> dataList;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new TwoIntsClass[100];\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "23749"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_54cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "25799"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_73bSink(list<wchar_t *> dataList)\n{\n    /* copy data out of dataList */\n    wchar_t * data = dataList.back();\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "15289"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_68a()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new wchar_t[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_68aSink();\n}\n",
        "output": "1",
        "idx": "21808"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_45()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_45Sink();\n}\n",
        "output": "1",
        "idx": "6478"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_18()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    goto source;\nsource:\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4730"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_51a()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_51aSink(data);\n}\n",
        "output": "1",
        "idx": "24650"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_41()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_41Sink(data);\n}\n",
        "output": "1",
        "idx": "20560"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_41()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_41Sink(data);\n}\n",
        "output": "1",
        "idx": "3564"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_relativePath_74a()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    /* FLAW: Specify just the file name for the library, not the full path */\n    wcscpy(data, L\"winsrv.dll\");\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE114_Process_Control__w32_wchar_t_relativePath_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "1928"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_22a()\n{\n    char * data;\n    data = new char[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_22aGlobal = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_22aSource(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "28320"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_52bSink(data);\n}\n",
        "output": "0",
        "idx": "12815"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_18()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    goto source;\nsource:\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "9519"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_53bSink(data);\n}\n",
        "output": "0",
        "idx": "11149"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_relativePath_66a()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    /* FLAW: Specify just the file name for the library, not the full path */\n    wcscpy(data, L\"winsrv.dll\");\n    /* put data in array */\n    dataArray[2] = data;\n    CWE114_Process_Control__w32_wchar_t_relativePath_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "1908"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "7832"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_54cSink_c(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "19884"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_54bSink(data);\n}\n",
        "output": "0",
        "idx": "13473"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "16049"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_53bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "26594"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_66a()\n{\n    int data;\n    int dataArray[5];\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "2732"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_54cSink_c(TwoIntsClass * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "23706"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54cSink(data);\n}\n",
        "output": "0",
        "idx": "6371"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_45()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_45Sink();\n}\n",
        "output": "0",
        "idx": "8475"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_06()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "9618"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_68a()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_68aSink();\n}\n",
        "output": "0",
        "idx": "12116"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22aGlobal = 1; /* true */\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22aSink(data);\n}\n",
        "output": "0",
        "idx": "2367"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_52bSink_b(int * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "24495"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_54cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "27248"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_54dSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_54dSink(data);\n}\n",
        "output": "0",
        "idx": "9565"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    wchar_t * data = (*dataPtr);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "15265"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_54c_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_54cSink(int data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_54d_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_54cSink(data);\n}\n",
        "output": "0",
        "idx": "3432"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_73bSink(list<char *> dataList)\n{\n    char * data = dataList.back();\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "13358"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_52a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_52b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_52aSink(data);\n}\n",
        "output": "0",
        "idx": "2914"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_68a()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new TwoIntsClass[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_68_CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_68aSink();\n}\n",
        "output": "0",
        "idx": "23419"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_54e_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "18656"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_33()\n{\n    char * data;\n    char * &dataRef = data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new char[50];\n    data[0] = '\\0'; /* null terminate */\n    {\n        char * data = dataRef;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n            SNPRINTF(data, 100, \"%s\", source);\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "23177"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    {\n        char * data = *dataPtr1;\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            SNPRINTF(data, 100, \"%s\", source);\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "8325"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_68a()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_68aSink();\n}\n",
        "output": "0",
        "idx": "7860"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_environment_73a()\n{\n    wchar_t * data;\n    list<wchar_t *> dataList;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            wcsncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE114_Process_Control__w32_wchar_t_environment_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "1441"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_45()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_45Sink();\n}\n",
        "output": "1",
        "idx": "10468"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_66a()\n{\n    char * data;\n    char * dataArray[5];\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new char[100];\n    data[0] = '\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "22928"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_53cSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_53cSink(data);\n}\n",
        "output": "0",
        "idx": "9289"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_45()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_45Sink();\n}\n",
        "output": "1",
        "idx": "7542"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_74a()\n{\n    char * data;\n    map<int, char *> dataMap;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new char[10];\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "20854"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_53cSink(data);\n}\n",
        "output": "0",
        "idx": "12501"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_68a()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_68aSink();\n}\n",
        "output": "1",
        "idx": "25028"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_66a()\n{\n    char * data;\n    char * dataArray[5];\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "12534"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_74a()\n{\n    int64_t * data;\n    map<int, int64_t *> dataMap;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_74aSink(dataMap);\n}\n",
        "output": "0",
        "idx": "8936"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_67a()\n{\n    int data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_67_structType myStruct;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_67b_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "3478"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_32()\n{\n    int * data;\n    int * *dataPtr1 = &data;\n    int * *dataPtr2 = &data;\n    data = NULL;\n    {\n        int * data = *dataPtr1;\n        /* FLAW: Allocate memory without using sizeof(int) */\n        data = (int *)ALLOCA(10);\n        *dataPtr1 = data;\n    }\n    {\n        int * data = *dataPtr2;\n        {\n            int source[10] = {0};\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n            for (i = 0; i < 10; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "3557"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_22a()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_22_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_22aGlobal = 0; /* false */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_22_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_22aSource(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "15190"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_13()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "9240"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_16()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    while(1)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "8317"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_relativePath_17()\n{\n    int i;\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        /* FLAW: Specify just the file name for the library, not the full path */\n        wcscpy(data, L\"winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "1816"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "11026"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_53bSink(data);\n}\n",
        "output": "0",
        "idx": "7957"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_18()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    goto source;\nsource:\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "11780"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_72a()\n{\n    int64_t * data;\n    vector<int64_t *> dataVector;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "9060"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_54dSink_d(int64_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "24030"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_52bSink(data);\n}\n",
        "output": "0",
        "idx": "13781"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    {\n        char * data = *dataPtr1;\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            strncpy(data, source, strlen(source) + 1);\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "5399"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_file_67a()\n{\n    char * data;\n    CWE114_Process_Control__w32_char_file_67_structType myStruct;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        /* Read input from a file */\n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    myStruct.structFirst = data;\n    CWE114_Process_Control__w32_char_file_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "624"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE114_Process_Control__w32_char_connect_socket_41()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    /* FIX: Specify the full pathname for the library */\n    strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    CWE114_Process_Control__w32_char_connect_socket_41_CWE114_Process_Control__w32_char_connect_socket_41Sink(data);\n}\n",
        "output": "0",
        "idx": "72"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_53a()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new wchar_t[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_53aSink_b(data);\n}\n",
        "output": "1",
        "idx": "21601"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_62bSource(wchar_t * &data)\n{\n    /* FIX: Allocate space for a null terminator */\n    data = new wchar_t[10+1];\n}\n",
        "output": "0",
        "idx": "21626"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_64a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_64aSink(&data);\n}\n",
        "output": "1",
        "idx": "20157"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_01()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new wchar_t[10];\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "21502"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_34()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_34_unionType myUnion;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char dest[50] = \"\";\n            size_t i, dataLen;\n            dataLen = strlen(data);\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            for (i = 0; i < dataLen; i++)\n            {\n                dest[i] = data[i];\n            }\n            dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "13431"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_53bSink_b(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "17659"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "4493"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_03()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(5==5)\n    {\n        {\n            int i;\n            int * buffer = new int[10];\n            /* initialize buffer */\n            for (i = 0; i < 10; i++)\n            {\n                buffer[i] = 0;\n            }\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n            delete[] buffer;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "19478"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_54dSink_d(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "26123"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_02()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(1)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "14009"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_51a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_51b_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_51aSink(data);\n}\n",
        "output": "0",
        "idx": "2169"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_16()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    while(1)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new TwoIntsClass[50];\n        break;\n    }\n    {\n        TwoIntsClass source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(TwoIntsClass));\n        printIntLine(data[0].intOne);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "23477"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_54d_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_54e_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_54dSink(data);\n}\n",
        "output": "0",
        "idx": "16621"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_45()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_45Sink();\n}\n",
        "output": "0",
        "idx": "8874"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_54bSink(data);\n}\n",
        "output": "0",
        "idx": "13312"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_01()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "6945"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_54cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "26765"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_67a()\n{\n    twoIntsStruct * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_67_structType myStruct;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "10516"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_environment_73a()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            strncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE114_Process_Control__w32_char_environment_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "475"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_45()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_45Sink();\n}\n",
        "output": "0",
        "idx": "9273"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_65a()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_65b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_65aSink;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "15751"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_66a()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    data = NULL;\n    /* FIX: Allocate space for a null terminator */\n    data = new wchar_t[10+1];\n    dataArray[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "22284"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_41()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_41_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_41Sink(data);\n}\n",
        "output": "0",
        "idx": "5541"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_52b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_52bSink(int data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_52c_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_52bSink(data);\n}\n",
        "output": "0",
        "idx": "2916"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_53cSink(data);\n}\n",
        "output": "0",
        "idx": "7959"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_52bSink(data);\n}\n",
        "output": "0",
        "idx": "11941"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_66b_CWE121_Stack_Based_Buffer_Overflow__CWE135_66bSink(void * dataArray[])\n{\n    void * data = dataArray[2];\n    {\n        /* FIX: treating pointer like a wchar_t*  */\n        size_t dataLen = wcslen((wchar_t *)data);\n        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n        (void)wcscpy(dest, data);\n        printWLine((wchar_t *)dest);\n    }\n}\n",
        "output": "0",
        "idx": "4120"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_51a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_51b_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_51aSink(data);\n}\n",
        "output": "0",
        "idx": "3153"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "4906"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_74a()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_74aSink(dataMap);\n}\n",
        "output": "0",
        "idx": "11596"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54bSink(data);\n}\n",
        "output": "0",
        "idx": "4640"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_67bSink(structType myStruct)\n{\n    wchar_t * data = myStruct.structFirst;\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "21967"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_08()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "6698"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_21Source(int * data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_21Static)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int[100];\n    }\n    return data;\n}\n",
        "output": "0",
        "idx": "24290"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_06()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "9353"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_42()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_42Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "14081"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_54b_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_54c_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_54bSink(data);\n}\n",
        "output": "0",
        "idx": "16351"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_54a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_54aSink(data);\n}\n",
        "output": "1",
        "idx": "3425"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_68a()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_68aSink();\n}\n",
        "output": "1",
        "idx": "28087"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_65a()\n{\n    void * data;\n    void (*funcPtr) (void *) = CWE121_Stack_Based_Buffer_Overflow__CWE135_65b_CWE121_Stack_Based_Buffer_Overflow__CWE135_65aSink;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "4111"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_54bSink(data);\n}\n",
        "output": "0",
        "idx": "15727"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_11()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    if(globalReturnsTrue())\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "10697"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_51a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_51aSink(data);\n}\n",
        "output": "0",
        "idx": "19360"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_64b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    wchar_t * data = (*dataPtr);\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "5585"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_45()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_45Sink();\n}\n",
        "output": "1",
        "idx": "25130"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_74a()\n{\n    int64_t * data;\n    map<int, int64_t *> dataMap;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "9068"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_connect_socket_22a()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    CWE114_Process_Control__w32_char_connect_socket_22aGlobal = 1; /* true */\n    data = CWE114_Process_Control__w32_char_connect_socket_22aSource(data);\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "55"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_45()\n{\n    int * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_45Sink();\n}\n",
        "output": "0",
        "idx": "24488"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_42()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    data = CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_42Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "18294"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_54bSink(data);\n}\n",
        "output": "0",
        "idx": "11689"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_73a()\n{\n    int64_t * data;\n    list<int64_t *> dataList;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "9064"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    {\n        wchar_t * data = *dataPtr1;\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            SNPRINTF(data, 100, L\"%s\", source);\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "12316"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "13155"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_06()\n{\n    wchar_t * data;\n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new wchar_t[50];\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "24736"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_68a()\n{\n    char * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new char[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_68aSink();\n}\n",
        "output": "1",
        "idx": "20842"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_18()\n{\n    wchar_t * data;\n    data = NULL;\n    goto source;\nsource:\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */\n        wcsncat(data, source, 100);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "25252"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_54bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "23060"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "6103"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_68a()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_68_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_68b_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_68aSink();\n}\n",
        "output": "0",
        "idx": "16778"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_08()\n{\n    int * data;\n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new int[50];\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "24259"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_07()\n{\n    wchar_t * data;\n    data = NULL;\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new wchar_t[100];\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "24740"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_54d_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_54dSink(int data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_54e_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_54dSink(data);\n}\n",
        "output": "0",
        "idx": "2697"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_42Source(int data)\n{\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    return data;\n}\n",
        "output": "1",
        "idx": "2636"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_74bSink(map<int, wchar_t *> dataMap)\n{\n    wchar_t * data = dataMap[2];\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "5613"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_74bSink(map<int, wchar_t *> dataMap)\n{\n    /* copy data out of dataMap */\n    wchar_t * data = dataMap[2];\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "15293"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_45()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_45Sink();\n}\n",
        "output": "1",
        "idx": "24969"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_66a()\n{\n    void * data;\n    void * dataArray[5];\n    data = NULL;\n    /* FIX: Set data to point to a char string */\n    data = (void *)CHAR_STRING;\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_66b_CWE121_Stack_Based_Buffer_Overflow__CWE135_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "4116"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_68a()\n{\n    void * data;\n    data = NULL;\n    /* FIX: Set data to point to a char string */\n    data = (void *)CHAR_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_68_CWE121_Stack_Based_Buffer_Overflow__CWE135_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_68b_CWE121_Stack_Based_Buffer_Overflow__CWE135_68aSink();\n}\n",
        "output": "0",
        "idx": "4128"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_54cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "25155"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_18()\n{\n    char * data;\n    data = new char[100];\n    goto source;\nsource:\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "26057"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_13()\n{\n    int64_t * data;\n    data = NULL;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new int64_t[50];\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "23951"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_54cSink_c(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "19392"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_45()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_45Sink();\n}\n",
        "output": "0",
        "idx": "10204"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_environment_53b_CWE114_Process_Control__w32_char_environment_53bSink(char * data)\n{\n    CWE114_Process_Control__w32_char_environment_53c_CWE114_Process_Control__w32_char_environment_53bSink(data);\n}\n",
        "output": "0",
        "idx": "424"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_53dSink(int64_t * data)\n{\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "8492"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_53bSink(data);\n}\n",
        "output": "0",
        "idx": "7292"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_66a()\n{\n    char * data;\n    char * dataArray[5];\n    data = NULL;\n    /* FIX: Allocate space for a null terminator */\n    data = new char[10+1];\n    dataArray[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "21479"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_07()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(staticFive==5)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "9355"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_12()\n{\n    void * data;\n    data = NULL;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* POTENTIAL FLAW: Set data to point to a wide string */\n        data = (void *)WIDE_STRING;\n    }\n    else\n    {\n        /* POTENTIAL FLAW: Set data to point to a wide string */\n        data = (void *)WIDE_STRING;\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* FIX: treating pointer like a wchar_t*  */\n            size_t dataLen = wcslen((wchar_t *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy(dest, data);\n            printWLine((wchar_t *)dest);\n        }\n    }\n    else\n    {\n        {\n            /* FIX: treating pointer like a wchar_t*  */\n            size_t dataLen = wcslen((wchar_t *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy(dest, data);\n            printWLine((wchar_t *)dest);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "3959"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_67a()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_67_structType myStruct;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "13826"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_06()\n{\n    char * data;\n    data = new char[100];\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "26347"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_01()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "18864"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_09()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        wmemset(data, L'A', 100-1); /* fill with L'A's */\n        data[100-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "14352"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_52bSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_52bSink(data);\n}\n",
        "output": "0",
        "idx": "9946"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE114_Process_Control__w32_wchar_t_connect_socket_73a()\n{\n    wchar_t * data;\n    list<wchar_t *> dataList;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    /* FIX: Specify the full pathname for the library */\n    wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE114_Process_Control__w32_wchar_t_connect_socket_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "1120"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_06()\n{\n    int * data;\n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new int[50];\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "24575"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_66bSink(wchar_t * dataArray[])\n{\n    /* copy data out of dataArray */\n    wchar_t * data = dataArray[2];\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "27115"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_34()\n{\n    char * data;\n    unionType myUnion;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            /* The Visual C++ compiler generates a warning if you initialize the class with ().\n             * This will cause the compile to default-initialize the object.\n             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n             */\n            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n            TwoIntsClass * classTwo = new(data) TwoIntsClass;\n            /* Initialize and make use of the class */\n            classTwo->intOne = 5;\n            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n            printIntLine(classTwo->intOne);\n            /* skip printing classTwo->intTwo since that could be a buffer overread */\n        }\n    }\n}\n",
        "output": "1",
        "idx": "17620"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_43Source(char * &data)\n{\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n}\n",
        "output": "1",
        "idx": "12957"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_41()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_41Sink(data);\n}\n",
        "output": "0",
        "idx": "19578"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_console_73a()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        /* Read input from the console */\n        size_t dataLen = strlen(data);\n        /* if there is room in data, read into it from the console */\n        if (100-dataLen > 1)\n        {\n            /* POTENTIAL FLAW: Read data from the console */\n            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                /* The next few lines remove the carriage return from the string that is\n                 * inserted by fgets() */\n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE114_Process_Control__w32_char_console_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "314"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_52a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_52aSink(data);\n}\n",
        "output": "1",
        "idx": "3404"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_73bSink(list<int *> dataList)\n{\n    int * data = dataList.back();\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "3634"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_02()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(1)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "8010"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_54e_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "17286"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_45()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_45Sink();\n}\n",
        "output": "1",
        "idx": "20584"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_03()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(5==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "16107"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_17()\n{\n    int h;\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "8985"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_02()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "8278"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_73a()\n{\n    wchar_t * data;\n    list<wchar_t *> dataList;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "10926"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_15()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "12599"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_45()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_45Sink();\n}\n",
        "output": "0",
        "idx": "11933"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_17()\n{\n    int i;\n    char * data;\n    data = NULL;\n    for(i = 0; i < 1; i++)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new char[50];\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "22674"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "4775"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_53cSink_c(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "20610"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_03()\n{\n    int * data;\n    data = NULL;\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "3512"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_68a()\n{\n    int * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_68_CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_68aSink();\n}\n",
        "output": "0",
        "idx": "24385"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_02()\n{\n    int64_t * data;\n    data = NULL;\n    if(1)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new int64_t[50];\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "23758"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_54cSink_c(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "19638"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_45Sink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_45_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_45Data;\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "18629"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_53c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_53d_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_53cSink(data);\n}\n",
        "output": "0",
        "idx": "17143"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_06()\n{\n    char * data;\n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new char[50];\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "22321"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53c_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53cSink(int data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53d_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53cSink(data);\n}\n",
        "output": "0",
        "idx": "3420"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_22a()\n{\n    char * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_22aGlobal = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_22aSource(data);\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "23168"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_63a()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_63b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_63aSink(&data);\n}\n",
        "output": "0",
        "idx": "10234"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_54cSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_54cSink(data);\n}\n",
        "output": "0",
        "idx": "10494"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_04()\n{\n    char * data;\n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new char[50];\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "22315"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_52bSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_52bSink(data);\n}\n",
        "output": "0",
        "idx": "3582"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_53c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_53d_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_53cSink(data);\n}\n",
        "output": "0",
        "idx": "16877"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_21()\n{\n    char * data;\n    data = new char[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_21Static = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_21Source(data);\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "25740"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_connect_socket_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    char * * dataPtr = (char * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    char * data = (*dataPtr);\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "131"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_01()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "9604"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_02()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    if(1)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        wmemset(data, L'A', 100-1); /* fill with L'A's */\n        data[100-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "26817"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_72a()\n{\n    char * data;\n    vector<char *> dataVector;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new char[50];\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "22456"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_34()\n{\n    wchar_t * data;\n    unionType myUnion;\n    data = new wchar_t[100];\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n            wcsncat(dest, data, wcslen(data));\n            dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "27204"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_44()\n{\n    int * data;\n    void (*funcPtr) (int *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_44Sink;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "9801"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_03()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(5==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "12271"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67a()\n{\n    int * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67_structType myStruct;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "9584"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_16()\n{\n    wchar_t * data;\n    data = NULL;\n    while(1)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new wchar_t[100];\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "25088"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_54dSink_d(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "21615"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54dSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54dSink(data);\n}\n",
        "output": "0",
        "idx": "8501"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    {\n        char * data = *dataPtr1;\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            memmove(data, source, 100*sizeof(char));\n            data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "7128"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_33()\n{\n    void * data;\n    void * &dataRef = data;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    {\n        void * data = dataRef;\n        {\n            /* FIX: treating pointer like a wchar_t*  */\n            size_t dataLen = wcslen((wchar_t *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy((wchar_t *)dest, (wchar_t *)data);\n            printWLine((wchar_t *)dest);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "4009"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_42()\n{\n    char * data;\n    data = new char[100];\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_42Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "28338"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_54dSink_d(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "25962"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_54bSink(data);\n}\n",
        "output": "0",
        "idx": "13956"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_52bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "27393"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54bSink(data);\n}\n",
        "output": "0",
        "idx": "6901"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_45()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_45Sink();\n}\n",
        "output": "1",
        "idx": "13771"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_72a()\n{\n    char * data;\n    vector<char *> dataVector;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_72aSink(dataVector);\n}\n",
        "output": "0",
        "idx": "6933"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_12()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "10434"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_44()\n{\n    int data;\n    void (*funcPtr) (int) = CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_44Sink;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "3391"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_18()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    goto source;\nsource:\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "27023"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_22a()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_22aGlobal = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_22aSource(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "27032"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_53cSink(data);\n}\n",
        "output": "0",
        "idx": "7693"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "6772"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "8231"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_45Sink()\n{\n    wchar_t * data = CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_45Data;\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        wcscpy(data, source);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "28188"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_21()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_21Static = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_21Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "18270"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_44()\n{\n    wchar_t * data;\n    /* define a function pointer */\n    void (*funcPtr) (wchar_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_44Sink;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "11661"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_54bSink(data);\n}\n",
        "output": "0",
        "idx": "5970"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54dSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "3733"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_63a()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_63aSink(&data);\n}\n",
        "output": "1",
        "idx": "9302"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_45()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_45Sink();\n}\n",
        "output": "1",
        "idx": "25613"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_53bSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_53bSink(data);\n}\n",
        "output": "0",
        "idx": "8755"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_54bSink_b(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "20373"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_07()\n{\n    int * data;\n    data = NULL;\n    if(staticFive==5)\n    {\n        /* FLAW: Allocate memory without using sizeof(int) */\n        data = (int *)ALLOCA(10);\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3656"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_54dSink_d(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "22098"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_21()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_21Static = 0; /* false */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_21Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "15186"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_72bSink(vector<twoIntsStruct *> dataVector)\n{\n    /* copy data out of dataVector */\n    twoIntsStruct * data = dataVector[2];\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "10392"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_54b_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "17282"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_66a()\n{\n    char * data;\n    char * dataArray[5];\n    data = NULL;\n    /* FIX: Allocate space for a null terminator */\n    data = new char[10+1];\n    dataArray[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "20835"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_41()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_41_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_41Sink(data);\n}\n",
        "output": "0",
        "idx": "10861"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_45()\n{\n    char * data;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_45Sink();\n}\n",
        "output": "1",
        "idx": "17636"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_54dSink_d(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "21454"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_41()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new TwoIntsClass[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_41Sink(data);\n}\n",
        "output": "0",
        "idx": "23345"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "16051"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_72bSink(vector<wchar_t *> dataVector)\n{\n    /* copy data out of dataVector */\n    wchar_t * data = dataVector[2];\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "11190"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_41_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_41Sink(char * data)\n{\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "17808"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "6504"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_74bSink(map<int, char *> dataMap)\n{\n    /* copy data out of dataMap */\n    char * data = dataMap[2];\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "7208"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_67_structType myStruct)\n{\n    char * data = myStruct.structFirst;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "13023"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_44()\n{\n    char * data;\n    /* define a function pointer */\n    void (*funcPtr) (char *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_44Sink;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new char[10];\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "21101"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_68a()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_68aSink();\n}\n",
        "output": "0",
        "idx": "10520"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_53cSink_c(int64_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "23859"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_01()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "8540"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_34()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_34_unionType myUnion;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char source[10+1] = SRC_STRING;\n            size_t i, sourceLen;\n            sourceLen = strlen(source);\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            for (i = 0; i < sourceLen + 1; i++)\n            {\n                data[i] = source[i];\n            }\n            printLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "4340"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_21()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_21Static = 0; /* false */\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_21Sink(data);\n}\n",
        "output": "0",
        "idx": "3343"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_54dSink(data);\n}\n",
        "output": "0",
        "idx": "12511"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_67a()\n{\n    int * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_67_structType myStruct;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "9983"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_15()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        break;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "8581"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_54dSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_54dSink(data);\n}\n",
        "output": "0",
        "idx": "10363"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_52a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_52aSink_b(data);\n}\n",
        "output": "1",
        "idx": "20595"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_66a()\n{\n    int data;\n    int dataArray[5];\n    /* Initialize data */\n    data = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "2486"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_52bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "22402"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_73a()\n{\n    int * data;\n    list<int *> dataList;\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "3632"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char * CWE114_Process_Control__w32_char_console_22_CWE114_Process_Control__w32_char_console_22bSource(char * data)\n{\n    if(CWE114_Process_Control__w32_char_console_22_CWE114_Process_Control__w32_char_console_22bGlobal)\n    {\n        /* FIX: Specify the full pathname for the library */\n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    return data;\n}\n",
        "output": "0",
        "idx": "221"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_52bSink_b(int64_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "23851"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_connect_socket_53b_CWE114_Process_Control__w32_char_connect_socket_53bSink(char * data)\n{\n    CWE114_Process_Control__w32_char_connect_socket_53c_CWE114_Process_Control__w32_char_connect_socket_53bSink(data);\n}\n",
        "output": "0",
        "idx": "102"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_67a()\n{\n    char * data;\n    structType myStruct;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new char[50];\n    data[0] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "22931"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_15()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4856"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_74bSink(map<int, int> dataMap)\n{\n    int data = dataMap[2];\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* FIX: Properly validate the array index and prevent a buffer overflow */\n        if (data >= 0 && data < (10))\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is out-of-bounds\");\n        }\n    }\n}\n",
        "output": "0",
        "idx": "2275"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54b_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54bSink(data);\n}\n",
        "output": "0",
        "idx": "18491"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    data = NULL;\n    {\n        wchar_t * data = *dataPtr1;\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new wchar_t[50];\n        data[0] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */\n            wcsncat(data, source, 100);\n            printWLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "25268"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_42Source(char * data)\n{\n    /* FIX: Allocate space for a null terminator */\n    data = new char[10+1];\n    return data;\n}\n",
        "output": "0",
        "idx": "20772"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_53bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "28043"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_67bSink(CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_67_structType myStruct)\n{\n    wchar_t * data = myStruct.structFirst;\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "18524"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_01()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        size_t i;\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "10802"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_console_53c_CWE114_Process_Control__w32_wchar_t_console_53cSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_console_53d_CWE114_Process_Control__w32_wchar_t_console_53cSink(data);\n}\n",
        "output": "0",
        "idx": "1231"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_73a()\n{\n    twoIntsStruct * data;\n    list<twoIntsStruct *> dataList;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "10129"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_68a()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_68aSink();\n}\n",
        "output": "1",
        "idx": "24545"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_73a()\n{\n    int data;\n    list<int> dataList;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "3494"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_file_72a()\n{\n    char * data;\n    vector<char *> dataVector;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        /* Read input from a file */\n        size_t dataLen = strlen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE114_Process_Control__w32_char_file_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "632"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_53cSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_53cSink(data);\n}\n",
        "output": "0",
        "idx": "10752"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_21()\n{\n    char * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_21Source(data);\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "21069"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    {\n        wchar_t * data = *dataPtr1;\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            memcpy(data, source, 100*sizeof(wchar_t));\n            data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "10986"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_74bSink(map<int, wchar_t *> dataMap)\n{\n    /* copy data out of dataMap */\n    wchar_t * data = dataMap[2];\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "14810"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_01()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "14330"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_67a()\n{\n    int data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_67_structType myStruct;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_67b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "2740"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_68a()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_68aSink();\n}\n",
        "output": "1",
        "idx": "9588"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_72a()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "11720"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_52bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "25944"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_68a()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_68aSink();\n}\n",
        "output": "1",
        "idx": "7593"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_45()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_45Sink();\n}\n",
        "output": "0",
        "idx": "8209"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_73a()\n{\n    TwoIntsClass * data;\n    list<TwoIntsClass *> dataList;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new TwoIntsClass[100];\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "23588"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_72bSink(vector<int *> dataVector)\n{\n    int * data = dataVector[2];\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "24552"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_console_73a()\n{\n    wchar_t * data;\n    list<wchar_t *> dataList;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        /* Read input from the console */\n        size_t dataLen = wcslen(data);\n        /* if there is room in data, read into it from the console */\n        if (100-dataLen > 1)\n        {\n            /* POTENTIAL FLAW: Read data from the console */\n            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                /* The next few lines remove the carriage return from the string that is\n                 * inserted by fgetws() */\n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                /* Restore NUL terminator if fgetws fails */\n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE114_Process_Control__w32_wchar_t_console_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "1280"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_34()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_34_unionType myUnion;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "6600"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_53b_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_53c_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_53bSink(data);\n}\n",
        "output": "0",
        "idx": "18161"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_52bSink_b(int * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "24656"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_41_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_41Sink(wchar_t * data)\n{\n    {\n        size_t i;\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "10860"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_54cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "25316"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_17()\n{\n    int i;\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    for(i = 0; i < 1; i++)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strncpy(data, source, 100-1);\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "8186"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    {\n        char * data = *dataPtr1;\n        /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n        data = dataBadBuffer;\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            /* The Visual C++ compiler generates a warning if you initialize the class with ().\n             * This will cause the compile to default-initialize the object.\n             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n             */\n            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n            TwoIntsClass * classTwo = new(data) TwoIntsClass;\n            /* Initialize and make use of the class */\n            classTwo->intOne = 5;\n            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n            printIntLine(classTwo->intOne);\n            /* skip printing classTwo->intTwo since that could be a buffer overread */\n        }\n    }\n}\n",
        "output": "1",
        "idx": "17614"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_54bSink_b(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "17671"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_18()\n{\n    wchar_t * data;\n    data = NULL;\n    goto source;\nsource:\n    /* FLAW: Did not leave space for a null terminator */\n    data = new wchar_t[10];\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "21871"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_environment_72a()\n{\n    char * data;\n    vector<char *> dataVector;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = strlen(data);\n        char * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            strncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE114_Process_Control__w32_char_environment_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "471"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_08()\n{\n    int64_t * data;\n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new int64_t[50];\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "24098"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_12()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "6178"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_06()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "14023"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_54cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "28375"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_54dSink(data);\n}\n",
        "output": "0",
        "idx": "7969"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_21()\n{\n    int * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_21Source(data);\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n            delete [] data;\n        }\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "24289"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_16()\n{\n    int * data;\n    data = NULL;\n    while(1)\n    {\n        /* FLAW: Allocate memory without using sizeof(int) */\n        data = (int *)ALLOCA(10);\n        break;\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3682"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_74bSink(map<int, char *> dataMap)\n{\n    char * data = dataMap[2];\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "13362"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_67a()\n{\n    int * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_67_structType myStruct;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "9318"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "4900"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_41()\n{\n    char * data;\n    data = NULL;\n    /* FIX: Allocate space for a null terminator */\n    data = new char[10+1];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_41Sink(data);\n}\n",
        "output": "0",
        "idx": "21091"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_22a()\n{\n    char * data;\n    data = new char[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_22aGlobal = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_22aSource(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "25905"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53b_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53bSink(int data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53c_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53bSink(data);\n}\n",
        "output": "0",
        "idx": "3417"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_18()\n{\n    char * data;\n    data = NULL;\n    goto source;\nsource:\n    /* FIX: Allocate space for a null terminator */\n    data = new char[10+1];\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "21228"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_34()\n{\n    int data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_34_unionType myUnion;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    myUnion.unionFirst = data;\n    {\n        int data = myUnion.unionSecond;\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}\n",
        "output": "0",
        "idx": "2136"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_72bSink(vector<wchar_t *> dataVector)\n{\n    /* copy data out of dataVector */\n    wchar_t * data = dataVector[2];\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "14963"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_53cSink(data);\n}\n",
        "output": "0",
        "idx": "14916"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_16()\n{\n    int64_t * data;\n    data = NULL;\n    while(1)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int64_t[100];\n        break;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "23961"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memmove_16()\n{\n    while(1)\n    {\n        {\n            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));\n            if (structCharVoid == NULL) {exit(-1);}\n            structCharVoid->voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid->voidSecond */\n            printLine((char *)structCharVoid->voidSecond);\n            /* FIX: Use the sizeof(structCharVoid->charFirst) to avoid overwriting the pointer y */\n            memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));\n            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid->charFirst);\n            printLine((char *)structCharVoid->voidSecond);\n        }\n        break;\n    }\n}\n",
        "output": "0",
        "idx": "19216"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_54bSink_b(TwoIntsClass * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "23704"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_45Sink()\n{\n    char * data = CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_45Data;\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */\n        strcat(data, source);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "27705"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "12215"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_52bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "22885"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_61a()\n{\n    char * data;\n    data = new char[100];\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_61aSource(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "26128"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_66a()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "17701"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_22bSource(char * data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_22bGlobal)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new char[50];\n        data[0] = '\\0'; /* null terminate */\n    }\n    return data;\n}\n",
        "output": "1",
        "idx": "22526"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_68a()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_68aSink();\n}\n",
        "output": "1",
        "idx": "6263"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_52bSink_b(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "17444"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_67a()\n{\n    char * data;\n    structType myStruct;\n    data = NULL;\n    /* FIX: Allocate space for a null terminator */\n    data = new char[10+1];\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "20839"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_16()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    while(1)\n    {\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "6455"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_22_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_22bSink(int data)\n{\n    if(CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_22_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_22bGlobal)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}\n",
        "output": "0",
        "idx": "2125"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "11415"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_67a()\n{\n    TwoIntsClass * data;\n    structType myStruct;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new TwoIntsClass[50];\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "23736"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_53cSink_c(int * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "24503"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_41()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_41_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_41Sink(data);\n}\n",
        "output": "0",
        "idx": "10063"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_54cSink_c(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "17674"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_44()\n{\n    int data;\n    /* define a function pointer */\n    void (*funcPtr) (int) = CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_44Sink;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "3387"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67a()\n{\n    int data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67_structType myStruct;\n    /* Initialize data */\n    data = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "2492"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_34()\n{\n    int data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_34_unionType myUnion;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    myUnion.unionFirst = data;\n    {\n        int data = myUnion.unionSecond;\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}\n",
        "output": "1",
        "idx": "2873"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_54bSink_b(int * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "24670"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_connect_socket_52b_CWE114_Process_Control__w32_wchar_t_connect_socket_52bSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_connect_socket_52c_CWE114_Process_Control__w32_wchar_t_connect_socket_52bSink(data);\n}\n",
        "output": "0",
        "idx": "1062"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_44()\n{\n    int data;\n    /* define a function pointer */\n    void (*funcPtr) (int) = CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_44Sink;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "2649"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54bSink(int data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54c_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54bSink(data);\n}\n",
        "output": "0",
        "idx": "2445"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_74bSink(map<int, char *> dataMap)\n{\n    /* copy data out of dataMap */\n    char * data = dataMap[2];\n    {\n        /* The Visual C++ compiler generates a warning if you initialize the class with ().\n         * This will cause the compile to default-initialize the object.\n         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n         */\n        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n        TwoIntsClass * classTwo = new(data) TwoIntsClass;\n        /* Initialize and make use of the class */\n        classTwo->intOne = 5;\n        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n        printIntLine(classTwo->intOne);\n        /* skip printing classTwo->intTwo since that could be a buffer overread */\n    }\n}\n",
        "output": "1",
        "idx": "17734"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_54bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "27729"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_41()\n{\n    char * data;\n    data = NULL;\n    /* FIX: Allocate space for a null terminator */\n    data = new char[10+1];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_41Sink(data);\n}\n",
        "output": "0",
        "idx": "20930"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_21()\n{\n    void * data;\n    data = NULL;\n    /* FIX: Set data to point to a char string */\n    data = (void *)CHAR_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_21Static = 1; /* true */\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_21Sink(data);\n}\n",
        "output": "0",
        "idx": "3992"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_06()\n{\n    char * data;\n    data = NULL;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new char[100];\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */\n        strncat(data, source, 100);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "22805"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_environment_72a()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            wcsncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE114_Process_Control__w32_wchar_t_environment_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "1437"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_15()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "5787"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_72bSink(vector<char *> dataVector)\n{\n    /* copy data out of dataVector */\n    char * data = dataVector[2];\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "20848"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_61a()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_61aSource(data);\n    {\n        TwoIntsClass source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(TwoIntsClass));\n        printIntLine(data[0].intOne);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "23712"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_21()\n{\n    int64_t * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_21Static = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_21Source(data);\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "24130"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_68a()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_68aSink();\n}\n",
        "output": "0",
        "idx": "12249"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "6762"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE114_Process_Control__w32_char_connect_socket_43Source(char * &data)\n{\n    /* FIX: Specify the full pathname for the library */\n    strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n}\n",
        "output": "0",
        "idx": "79"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67a()\n{\n    int * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67_structType myStruct;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "9585"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_12()\n{\n    int * data;\n    data = NULL;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    else\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "3672"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    data = new char[100];\n    {\n        char * data = *dataPtr1;\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            memmove(dest, data, strlen(data)*sizeof(char));\n            dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "26074"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_21()\n{\n    char * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_21Source(data);\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        strcpy(data, source);\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "27835"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_66a()\n{\n    char * data;\n    char * dataArray[5];\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "6921"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54bSink(data);\n}\n",
        "output": "0",
        "idx": "11157"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_54dSink_d(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "26284"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_15()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "10043"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "14119"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_relativePath_15()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Specify just the file name for the library, not the full path */\n        strcpy(data, \"winsrv.dll\");\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "845"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_18()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    goto source;\nsource:\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "14216"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_52bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "27071"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_34()\n{\n    int * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_34_unionType myUnion;\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    myUnion.unionFirst = data;\n    {\n        int * data = myUnion.unionSecond;\n        {\n            int source[10] = {0};\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n            for (i = 0; i < 10; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "3562"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_54a()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new wchar_t[100];\n    data[0] = L'\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_54aSink_b(data);\n}\n",
        "output": "0",
        "idx": "25152"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_54cSink_c(int * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "24672"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_12()\n{\n    void * data;\n    data = NULL;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* POTENTIAL FLAW: Set data to point to a wide string */\n        data = (void *)WIDE_STRING;\n    }\n    else\n    {\n        /* FIX: Set data to point to a char string */\n        data = (void *)CHAR_STRING;\n    }\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n            size_t dataLen = strlen((char *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy(dest, data);\n            printLine((char *)dest);\n        }\n    }\n    else\n    {\n        {\n            /* FIX: treating pointer like a wchar_t*  */\n            size_t dataLen = wcslen((wchar_t *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy(dest, data);\n            printWLine((wchar_t *)dest);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "3958"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_45()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_45Sink();\n}\n",
        "output": "1",
        "idx": "14254"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_34()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_34_unionType myUnion;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            wcscpy(data, source);\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "6202"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_52bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "25461"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * CWE114_Process_Control__w32_char_connect_socket_42Source(char * data)\n{\n    /* FIX: Specify the full pathname for the library */\n    strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    return data;\n}\n",
        "output": "0",
        "idx": "75"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_53cSink(data);\n}\n",
        "output": "0",
        "idx": "11550"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "4501"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_67b_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_67_structType myStruct)\n{\n    char * data = myStruct.structFirst;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "18042"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_02()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    if(1)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "26819"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_06()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "7492"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_12()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        wmemset(data, L'A', 100-1); /* fill with L'A's */\n        data[100-1] = L'\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "15810"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_22a()\n{\n    int64_t * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_22aGlobal = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_22aSource(data);\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "24134"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_connect_socket_54b_CWE114_Process_Control__w32_wchar_t_connect_socket_54bSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_connect_socket_54c_CWE114_Process_Control__w32_wchar_t_connect_socket_54bSink(data);\n}\n",
        "output": "0",
        "idx": "1076"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_73bSink(list<twoIntsStruct *> dataList)\n{\n    twoIntsStruct * data = dataList.back();\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "10264"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_54bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "25153"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_68a()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_68aSink();\n}\n",
        "output": "1",
        "idx": "7327"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_12()\n{\n    char * data;\n    data = NULL;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Did not leave space for a null terminator */\n        data = new char[10];\n    }\n    else\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new char[10+1];\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "20729"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_54cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "27409"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_66a()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "4925"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_67a()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_67_structType myStruct;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "5195"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_15()\n{\n    int * data;\n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n        break;\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "3680"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_32()\n{\n    int * data;\n    int * *dataPtr1 = &data;\n    int * *dataPtr2 = &data;\n    data = NULL;\n    {\n        int * data = *dataPtr1;\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new int[50];\n        *dataPtr1 = data;\n    }\n    {\n        int * data = *dataPtr2;\n        {\n            int source[100] = {0}; /* fill with 0's */\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memcpy(data, source, 100*sizeof(int));\n            printIntLine(data[0]);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "24463"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_34()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_34_unionType myUnion;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n            dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "14558"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_15()\n{\n    int * data;\n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int[100];\n        break;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "24441"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_54cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "22579"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_14()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "6184"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_45()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_45Sink();\n}\n",
        "output": "1",
        "idx": "2901"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_21()\n{\n    wchar_t * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_21Source(data);\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "22035"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "7419"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_53a()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_53aSink(data);\n}\n",
        "output": "1",
        "idx": "3585"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_45()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_45Sink();\n}\n",
        "output": "1",
        "idx": "20092"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_41()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new TwoIntsClass[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_41Sink(data);\n}\n",
        "output": "1",
        "idx": "23504"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "7036"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_67bSink(structType myStruct)\n{\n    char * data = myStruct.structFirst;\n    {\n        /* The Visual C++ compiler generates a warning if you initialize the class with ().\n         * This will cause the compile to default-initialize the object.\n         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n         */\n        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n        TwoIntsClass * classTwo = new(data) TwoIntsClass;\n        /* Initialize and make use of the class */\n        classTwo->intOne = 5;\n        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n        printIntLine(classTwo->intOne);\n        /* skip printing classTwo->intTwo since that could be a buffer overread */\n    }\n}\n",
        "output": "1",
        "idx": "17504"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_73a()\n{\n    int data;\n    list<int> dataList;\n    /* Initialize data */\n    data = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "2510"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_72a()\n{\n    char * data;\n    vector<char *> dataVector;\n    data = NULL;\n    /* FIX: Allocate space for a null terminator */\n    data = new char[10+1];\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_72aSink(dataVector);\n}\n",
        "output": "0",
        "idx": "20847"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_53bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "28365"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_53bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "28204"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_63a()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_63aSink(&data);\n}\n",
        "output": "1",
        "idx": "8504"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_67b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_67_structType myStruct)\n{\n    char * data = myStruct.structFirst;\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4666"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    data = NULL;\n    {\n        char * data = *dataPtr1;\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new char[50];\n        data[0] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n            memmove(data, source, 100*sizeof(char));\n            data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "22692"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_17()\n{\n    int j;\n    for(j = 0; j < 1; j++)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n            /* FLAW: Use the sizeof(structCharVoid) which will overwrite the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n            printWLine((wchar_t *)structCharVoid.charFirst);\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "19119"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_54dSink_d(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "27894"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_74a()\n{\n    int data;\n    map<int, int> dataMap;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "3500"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_51a()\n{\n    void * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_51aSink(data);\n}\n",
        "output": "1",
        "idx": "4043"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    char * * dataPtr = (char * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    char * data = (*dataPtr);\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "23243"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_17()\n{\n    int h;\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "12604"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_53bSink_b(int64_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "24018"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_34()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_34_unionType myUnion;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char dest[50] = \"\";\n            size_t i, dataLen;\n            dataLen = strlen(data);\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            for (i = 0; i < dataLen; i++)\n            {\n                dest[i] = data[i];\n            }\n            dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "13430"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_67a()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_67_structType myStruct;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "12245"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_41()\n{\n    void * data;\n    data = NULL;\n    /* FIX: Set data to point to a char string */\n    data = (void *)CHAR_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_41Sink(data);\n}\n",
        "output": "0",
        "idx": "4016"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_45Sink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_45Data;\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4615"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52bSink(int data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52c_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_52bSink(data);\n}\n",
        "output": "0",
        "idx": "2670"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_73a()\n{\n    char * data;\n    list<char *> dataList;\n    data = new char[100];\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "26002"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_67bSink(structType myStruct)\n{\n    TwoIntsClass * data = myStruct.structFirst;\n    {\n        TwoIntsClass source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0].intOne);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "23416"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_54bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "27568"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_34()\n{\n    int * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_34_unionType myUnion;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myUnion.unionFirst = data;\n    {\n        int * data = myUnion.unionSecond;\n        {\n            int source[100] = {0}; /* fill with 0's */\n            {\n                size_t i;\n                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n                for (i = 0; i < 100; i++)\n                {\n                    data[i] = source[i];\n                }\n                printIntLine(data[0]);\n            }\n        }\n    }\n}\n",
        "output": "1",
        "idx": "9260"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_66a()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "7719"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_68a()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_68aSink();\n}\n",
        "output": "0",
        "idx": "8126"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_52a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_52aSink_b(data);\n}\n",
        "output": "0",
        "idx": "19366"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67a()\n{\n    int data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67_structType myStruct;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "2985"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_63bSink(wchar_t * * dataPtr)\n{\n    wchar_t * data = *dataPtr;\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "22273"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_52bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "25139"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_01()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */\n        wcsncat(data, source, 100);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "25205"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_68a()\n{\n    int64_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int64_t[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_68aSink();\n}\n",
        "output": "1",
        "idx": "24223"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_relativePath_18()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    goto source;\nsource:\n    /* FLAW: Specify just the file name for the library, not the full path */\n    strcpy(data, \"winsrv.dll\");\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "852"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_52bSink(data);\n}\n",
        "output": "0",
        "idx": "14425"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_45()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_45Sink();\n}\n",
        "output": "0",
        "idx": "20340"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_53aSink(data);\n}\n",
        "output": "1",
        "idx": "3413"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_03()\n{\n    void * data;\n    data = NULL;\n    if(5==5)\n    {\n        /* POTENTIAL FLAW: Set data to point to a wide string */\n        data = (void *)WIDE_STRING;\n    }\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* FIX: treating pointer like a wchar_t*  */\n            size_t dataLen = wcslen((wchar_t *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy(dest, data);\n            printWLine((wchar_t *)dest);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "3914"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_09()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(GLOBAL_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4574"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_04()\n{\n    char * data;\n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new char[50];\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        strncpy(data, source, 100-1);\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "22959"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_54bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "22577"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_15()\n{\n    char * data;\n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Allocate space for a null terminator */\n        data = new char[10+1];\n        break;\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "20899"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_53bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "26916"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_connect_socket_54b_CWE114_Process_Control__w32_char_connect_socket_54bSink(char * data)\n{\n    CWE114_Process_Control__w32_char_connect_socket_54c_CWE114_Process_Control__w32_char_connect_socket_54bSink(data);\n}\n",
        "output": "0",
        "idx": "110"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_74bSink(map<int, char *> dataMap)\n{\n    char * data = dataMap[2];\n    {\n        /* The Visual C++ compiler generates a warning if you initialize the class with ().\n         * This will cause the compile to default-initialize the object.\n         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n         */\n        /* FIX: data will at least be the sizeof(OneIntClass) */\n        OneIntClass * classOne = new(data) OneIntClass;\n        /* Initialize and make use of the class */\n        classOne->intOne = 5;\n        printIntLine(classOne->intOne);\n    }\n}\n",
        "output": "0",
        "idx": "17736"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_72a()\n{\n    int * data;\n    vector<int *> dataVector;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_72aSink(dataVector);\n}\n",
        "output": "0",
        "idx": "9992"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_65a()\n{\n    int64_t * data;\n    /* define a function pointer */\n    void (*funcPtr) (int64_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_65aSink;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "8778"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_41_CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_41Sink(int * data)\n{\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memmove(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "3831"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "5442"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_34()\n{\n    char * data;\n    unionType myUnion;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n    data = dataGoodBuffer;\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            /* The Visual C++ compiler generates a warning if you initialize the class with ().\n             * This will cause the compile to default-initialize the object.\n             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n             */\n            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n            TwoIntsClass * classTwo = new(data) TwoIntsClass;\n            /* Initialize and make use of the class */\n            classTwo->intOne = 5;\n            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n            printIntLine(classTwo->intOne);\n            /* skip printing classTwo->intTwo since that could be a buffer overread */\n        }\n    }\n}\n",
        "output": "0",
        "idx": "17415"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_54dSink_d(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "22903"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_68a()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_68aSink();\n}\n",
        "output": "1",
        "idx": "13991"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_34()\n{\n    wchar_t * data;\n    unionType myUnion;\n    data = new wchar_t[100];\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t dest[50] = L\"\";\n            size_t i, dataLen;\n            dataLen = wcslen(data);\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            for (i = 0; i < dataLen; i++)\n            {\n                dest[i] = data[i];\n            }\n            dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "26721"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_64a()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_64aSink(&data);\n}\n",
        "output": "1",
        "idx": "3607"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_42Source(char * data)\n{\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    return data;\n}\n",
        "output": "0",
        "idx": "12633"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_68a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_68_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_68b_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_68aSink();\n}\n",
        "output": "0",
        "idx": "2253"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_54dSink_d(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "27733"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_67a()\n{\n    int data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_67_structType myStruct;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "2738"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_21()\n{\n    char * data;\n    data = new char[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_21Static = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_21Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "26223"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_66a()\n{\n    int64_t * data;\n    int64_t * dataArray[5];\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "8649"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_63a()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_63aSink(&data);\n}\n",
        "output": "1",
        "idx": "24525"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_54e_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "18012"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_54dSink(data);\n}\n",
        "output": "0",
        "idx": "6905"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_67a()\n{\n    int64_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_67_structType myStruct;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "8920"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_45()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_45Sink();\n}\n",
        "output": "1",
        "idx": "9271"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_16()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    while(1)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "6722"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_66bSink(char * dataArray[])\n{\n    /* copy data out of dataArray */\n    char * data = dataArray[2];\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4262"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_74a()\n{\n    char * data;\n    map<int, char *> dataMap;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "8004"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_01()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "6811"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_13()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        wmemset(data, L'A', 100-1); /* fill with L'A's */\n        data[100-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "26688"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_03()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    if(5==5)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "10407"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_04()\n{\n    char * data;\n    data = new char[100];\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "26018"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_61a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_61aSource(data);\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "2210"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_52b_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_52c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_52bSink(data);\n}\n",
        "output": "0",
        "idx": "18477"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_16()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    while(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        break;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "8584"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54cSink(data);\n}\n",
        "output": "0",
        "idx": "11159"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_01()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "9738"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_66bSink(char * dataArray[])\n{\n    /* copy data out of dataArray */\n    char * data = dataArray[2];\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "18037"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_45()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_45Sink();\n}\n",
        "output": "0",
        "idx": "19602"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_21()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_21Static = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_21Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "17948"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_54b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_54bSink(int data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_54c_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_54bSink(data);\n}\n",
        "output": "0",
        "idx": "2691"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_53b_CWE121_Stack_Based_Buffer_Overflow__CWE135_53bSink(void * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_53c_CWE121_Stack_Based_Buffer_Overflow__CWE135_53bSink(data);\n}\n",
        "output": "0",
        "idx": "4062"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_72a()\n{\n    char * data;\n    vector<char *> dataVector;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_72aSink(dataVector);\n}\n",
        "output": "0",
        "idx": "13835"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_73a()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "17725"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_34()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_34_unionType myUnion;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n            strcat(dest, data);\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "18126"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_63a()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_63aSink(&data);\n}\n",
        "output": "1",
        "idx": "13488"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_21()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_21Static = 1; /* true */\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_21Sink(data);\n}\n",
        "output": "0",
        "idx": "3101"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_16()\n{\n    while(1)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FLAW: Use the sizeof(structCharVoid) which will overwrite the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n        break;\n    }\n}\n",
        "output": "1",
        "idx": "2024"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_22a()\n{\n    void * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_22_CWE121_Stack_Based_Buffer_Overflow__CWE135_22aGlobal = 0; /* false */\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_22_CWE121_Stack_Based_Buffer_Overflow__CWE135_22aSink(data);\n}\n",
        "output": "0",
        "idx": "3994"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_45()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_45Sink();\n}\n",
        "output": "0",
        "idx": "10470"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67a()\n{\n    int data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67_structType myStruct;\n    /* Initialize data */\n    data = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "2494"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    data = NULL;\n    {\n        wchar_t * data = *dataPtr1;\n        /* FIX: Allocate space for a null terminator */\n        data = new wchar_t[10+1];\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n            printWLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "21888"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_74bSink(map<int, char *> dataMap)\n{\n    /* copy data out of dataMap */\n    char * data = dataMap[2];\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "13361"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_15()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "6319"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_22a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_22aGlobal = 1; /* true */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_22aSink(data);\n}\n",
        "output": "1",
        "idx": "20047"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_54bSink(data);\n}\n",
        "output": "0",
        "idx": "14439"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_53cSink(data);\n}\n",
        "output": "0",
        "idx": "14272"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE114_Process_Control__w32_wchar_t_connect_socket_21()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    CWE114_Process_Control__w32_wchar_t_connect_socket_21Static = 0; /* false */\n    data = CWE114_Process_Control__w32_wchar_t_connect_socket_21Source(data);\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "0",
        "idx": "1018"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_68a()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_68aSink();\n}\n",
        "output": "1",
        "idx": "9189"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_68a()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_68aSink();\n}\n",
        "output": "0",
        "idx": "8658"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_67a()\n{\n    twoIntsStruct * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_67_structType myStruct;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "10382"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_54c_CWE121_Stack_Based_Buffer_Overflow__CWE135_54cSink(void * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_54d_CWE121_Stack_Based_Buffer_Overflow__CWE135_54cSink(data);\n}\n",
        "output": "0",
        "idx": "4077"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_66a()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_66b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "6256"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_41()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_41Sink(data);\n}\n",
        "output": "1",
        "idx": "10726"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_54c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_54d_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_54cSink(data);\n}\n",
        "output": "0",
        "idx": "16885"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_45()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_45Sink();\n}\n",
        "output": "1",
        "idx": "9803"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_45()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_45Sink();\n}\n",
        "output": "1",
        "idx": "24808"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_68a()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_68aSink();\n}\n",
        "output": "1",
        "idx": "8923"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_54bSink_b(int * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "24509"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "6754"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_73bSink(list<char *> dataList)\n{\n    char * data = dataList.back();\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "21175"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67a()\n{\n    int data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67_structType myStruct;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "2986"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_74a()\n{\n    char * data;\n    map<int, char *> dataMap;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_74aSink(dataMap);\n}\n",
        "output": "0",
        "idx": "6941"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_73bSink(list<char *> dataList)\n{\n    /* copy data out of dataList */\n    char * data = dataList.back();\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "13357"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_45()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_45Sink();\n}\n",
        "output": "0",
        "idx": "9007"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    {\n        wchar_t * data = *dataPtr1;\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            wcsncpy(data, source, 100-1);\n            data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "11385"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_64b_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    int * * dataPtr = (int * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    int * data = (*dataPtr);\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "3743"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "5172"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_17()\n{\n    int h;\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4463"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_02()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    if(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "9874"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_41()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_41Sink(data);\n}\n",
        "output": "1",
        "idx": "3369"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_18()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    goto source;\nsource:\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "15826"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_68a()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_68aSink();\n}\n",
        "output": "1",
        "idx": "16511"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_52bSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "9414"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_53cSink(data);\n}\n",
        "output": "0",
        "idx": "13467"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_16()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    while(1)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "18908"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_54c_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_54d_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_54cSink(data);\n}\n",
        "output": "0",
        "idx": "16353"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_21()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_21Static = 1; /* true */\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_21Sink(data);\n}\n",
        "output": "1",
        "idx": "2357"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_54dSink_d(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "22581"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_73a()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "7734"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_68a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_68aSink();\n}\n",
        "output": "1",
        "idx": "2990"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_64a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_64b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_64aSink(&data);\n}\n",
        "output": "0",
        "idx": "2968"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_68a()\n{\n    int64_t * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int64_t[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_68_CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_68aSink();\n}\n",
        "output": "0",
        "idx": "23902"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_16()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    while(1)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "27342"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_04()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "5223"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_53cSink_c(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "17662"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_45()\n{\n    void * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_45Sink();\n}\n",
        "output": "1",
        "idx": "4038"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_41Sink(int64_t * data)\n{\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "8597"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_74a()\n{\n    char * data;\n    map<int, char *> dataMap;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "5344"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_54cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "22257"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_52bSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_52bSink(data);\n}\n",
        "output": "0",
        "idx": "10345"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_15()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n",
        "output": "0",
        "idx": "2099"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_52bSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_52bSink(data);\n}\n",
        "output": "0",
        "idx": "10079"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_54cSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "9430"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_console_72a()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        /* Read input from the console */\n        size_t dataLen = wcslen(data);\n        /* if there is room in data, read into it from the console */\n        if (100-dataLen > 1)\n        {\n            /* POTENTIAL FLAW: Read data from the console */\n            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                /* The next few lines remove the carriage return from the string that is\n                 * inserted by fgetws() */\n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                /* Restore NUL terminator if fgetws fails */\n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE114_Process_Control__w32_wchar_t_console_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "1276"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_53cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "21605"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_45()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_45Sink();\n}\n",
        "output": "0",
        "idx": "10603"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_73a()\n{\n    char * data;\n    list<char *> dataList;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n    data = dataGoodBuffer;\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "17520"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_67a()\n{\n    int * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_67_structType myStruct;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "9452"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_22a()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_22_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_22aGlobal = 0; /* false */\n    data = CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_22_CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_22aSource(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "18276"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67b_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67_structType myStruct)\n{\n    int data = myStruct.structFirst;\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}\n",
        "output": "0",
        "idx": "2250"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_63a()\n{\n    char * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new char[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_63aSink(&data);\n}\n",
        "output": "1",
        "idx": "20822"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_02()\n{\n    char * data;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    if(1)\n    {\n        /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n        data = dataBadBuffer;\n    }\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* The Visual C++ compiler generates a warning if you initialize the class with ().\n             * This will cause the compile to default-initialize the object.\n             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n             */\n            /* FIX: data will at least be the sizeof(OneIntClass) */\n            OneIntClass * classOne = new(data) OneIntClass;\n            /* Initialize and make use of the class */\n            classOne->intOne = 5;\n            printIntLine(classOne->intOne);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "17535"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_54dSink_d(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "20810"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_52bSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_52bSink(data);\n}\n",
        "output": "0",
        "idx": "8882"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_17()\n{\n    int i,j;\n    char * data;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    for(i = 0; i < 1; i++)\n    {\n        /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n        data = dataBadBuffer;\n    }\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* The Visual C++ compiler generates a warning if you initialize the class with ().\n             * This will cause the compile to default-initialize the object.\n             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n             */\n            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n            TwoIntsClass * classTwo = new(data) TwoIntsClass;\n            /* Initialize and make use of the class */\n            classTwo->intOne = 5;\n            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n            printIntLine(classTwo->intOne);\n            /* skip printing classTwo->intTwo since that could be a buffer overread */\n        }\n    }\n}\n",
        "output": "1",
        "idx": "17605"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_15()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4192"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_73bSink(list<wchar_t *> dataList)\n{\n    /* copy data out of dataList */\n    wchar_t * data = dataList.back();\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "14484"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_53cSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "8624"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_02()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    if(1)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "8808"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_52bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "21436"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_44()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_44Sink;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "11663"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_07()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(staticFive==5)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        wmemset(data, L'A', 100-1); /* fill with L'A's */\n        data[100-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "15956"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_18()\n{\n    goto sink;\nsink:\n    {\n        charVoid structCharVoid;\n        structCharVoid.voidSecond = (void *)SRC_STR;\n        /* Print the initial block pointed to by structCharVoid.voidSecond */\n        printLine((char *)structCharVoid.voidSecond);\n        /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n        memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n        structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n        printLine((char *)structCharVoid.charFirst);\n        printLine((char *)structCharVoid.voidSecond);\n    }\n}\n",
        "output": "0",
        "idx": "2029"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_66bSink(wchar_t * dataArray[])\n{\n    /* copy data out of dataArray */\n    wchar_t * data = dataArray[2];\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "18520"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_53cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "26757"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_03()\n{\n    int * data;\n    data = NULL;\n    if(5==5)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int[100];\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "24407"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_34()\n{\n    wchar_t * data;\n    unionType myUnion;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new wchar_t[100];\n    data[0] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n            memcpy(data, source, 100*sizeof(wchar_t));\n            data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "24951"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_02()\n{\n    char * data;\n    data = new char[100];\n    if(1)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "26334"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_41()\n{\n    char * data;\n    data = new char[100];\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_41Sink(data);\n}\n",
        "output": "1",
        "idx": "26241"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_connect_socket_72bSink(vector<char *> dataVector)\n{\n    char * data = dataVector[2];\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "0",
        "idx": "152"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_61bSource(char * data)\n{\n    /* FIX: Allocate space for a null terminator */\n    data = new char[10+1];\n    return data;\n}\n",
        "output": "0",
        "idx": "20817"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_54bSink_b(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "19881"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_52bSink(data);\n}\n",
        "output": "0",
        "idx": "4626"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_74bSink(map<int, char *> dataMap)\n{\n    char * data = dataMap[2];\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "12718"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_54dSink(data);\n}\n",
        "output": "0",
        "idx": "7703"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_63bSink(char * * dataPtr)\n{\n    char * data = *dataPtr;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "17864"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static wchar_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_21Source(wchar_t * data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_21Static)\n    {\n        /* FLAW: Did not leave space for a null terminator */\n        data = new wchar_t[10];\n    }\n    return data;\n}\n",
        "output": "1",
        "idx": "22034"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_41Sink(char * data)\n{\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "7001"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_54cSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "8632"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_01()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3639"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_67_structType myStruct)\n{\n    char * data = myStruct.structFirst;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "18041"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_68a()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_68aSink();\n}\n",
        "output": "1",
        "idx": "9322"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67a()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67_structType myStruct;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "4265"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_74bSink(map<int, wchar_t *> dataMap)\n{\n    wchar_t * data = dataMap[2];\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "21984"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_67a()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_67_structType myStruct;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "7722"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_66bSink(char * dataArray[])\n{\n    /* copy data out of dataArray */\n    char * data = dataArray[2];\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "21480"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_18()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    goto source;\nsource:\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "7124"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_44()\n{\n    wchar_t * data;\n    /* define a function pointer */\n    void (*funcPtr) (wchar_t *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_44Sink;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new wchar_t[10];\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "21745"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_53bSink_b(TwoIntsClass * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "23374"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_16()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    while(1)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        break;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "8450"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_32()\n{\n    int data;\n    int *dataPtr1 = &data;\n    int *dataPtr2 = &data;\n    /* Initialize data */\n    data = -1;\n    {\n        int data = *dataPtr1;\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n        *dataPtr1 = data;\n    }\n    {\n        int data = *dataPtr2;\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}\n",
        "output": "0",
        "idx": "2130"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_45()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_45Sink();\n}\n",
        "output": "0",
        "idx": "8342"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_66bSink(char * dataArray[])\n{\n    /* copy data out of dataArray */\n    char * data = dataArray[2];\n    {\n        /* The Visual C++ compiler generates a warning if you initialize the class with ().\n         * This will cause the compile to default-initialize the object.\n         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n         */\n        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n        TwoIntsClass * classTwo = new(data) TwoIntsClass;\n        /* Initialize and make use of the class */\n        classTwo->intOne = 5;\n        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n        printIntLine(classTwo->intOne);\n        /* skip printing classTwo->intTwo since that could be a buffer overread */\n    }\n}\n",
        "output": "1",
        "idx": "17498"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_34()\n{\n    int * data;\n    unionType myUnion;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int[100];\n    myUnion.unionFirst = data;\n    {\n        int * data = myUnion.unionSecond;\n        {\n            int source[100] = {0}; /* fill with 0's */\n            {\n                size_t i;\n                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n                for (i = 0; i < 100; i++)\n                {\n                    data[i] = source[i];\n                }\n                printIntLine(data[0]);\n                delete [] data;\n            }\n        }\n    }\n}\n",
        "output": "0",
        "idx": "24307"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_34()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_34_unionType myUnion;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            SNPRINTF(dest, wcslen(data), L\"%s\", data);\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "16167"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_16()\n{\n    char * data;\n    data = new char[100];\n    while(1)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "26376"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_06()\n{\n    void * data;\n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Set data to point to a wide string */\n        data = (void *)WIDE_STRING;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n            size_t dataLen = strlen((char *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy(dest, data);\n            printLine((char *)dest);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "3928"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_67a()\n{\n    int64_t * data;\n    structType myStruct;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int64_t[50];\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "23897"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_06()\n{\n    wchar_t * data;\n    data = NULL;\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new wchar_t[100];\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "24898"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_53cSink_c(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "19380"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_54a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_54aSink_b(data);\n}\n",
        "output": "1",
        "idx": "20124"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_03()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(5==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "9345"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_54bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "28051"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_53bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "22086"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_67a()\n{\n    int64_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_67_structType myStruct;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "9186"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_53b_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_53c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_53bSink(data);\n}\n",
        "output": "0",
        "idx": "16875"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_03()\n{\n    wchar_t * data;\n    data = NULL;\n    if(5==5)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new wchar_t[50];\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "24727"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_console_72a()\n{\n    char * data;\n    vector<char *> dataVector;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        /* Read input from the console */\n        size_t dataLen = strlen(data);\n        /* if there is room in data, read into it from the console */\n        if (100-dataLen > 1)\n        {\n            /* POTENTIAL FLAW: Read data from the console */\n            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                /* The next few lines remove the carriage return from the string that is\n                 * inserted by fgets() */\n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE114_Process_Control__w32_char_console_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "310"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53bSink(data);\n}\n",
        "output": "0",
        "idx": "12982"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_53c_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_53d_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_53cSink(data);\n}\n",
        "output": "0",
        "idx": "17841"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_54d_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_54e_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_54dSink(data);\n}\n",
        "output": "0",
        "idx": "17153"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_73bSink(list<char *> dataList)\n{\n    /* copy data out of dataList */\n    char * data = dataList.back();\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "22462"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_17()\n{\n    int h;\n    char * data;\n    data = new char[100];\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "28310"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_34()\n{\n    TwoIntsClass * data;\n    unionType myUnion;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new TwoIntsClass[100];\n    myUnion.unionFirst = data;\n    {\n        TwoIntsClass * data = myUnion.unionSecond;\n        {\n            TwoIntsClass source[100];\n            {\n                size_t i;\n                /* Initialize array */\n                for (i = 0; i < 100; i++)\n                {\n                    source[i].intOne = 0;\n                    source[i].intTwo = 0;\n                }\n            }\n            {\n                size_t i;\n                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n                for (i = 0; i < 100; i++)\n                {\n                    data[i] = source[i];\n                }\n                printIntLine(data[0].intOne);\n                delete [] data;\n            }\n        }\n    }\n}\n",
        "output": "0",
        "idx": "23341"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    wchar_t * data = (*dataPtr);\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "25658"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_53cSink_c(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "19872"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_54dSink_d(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "21776"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_52bSink(data);\n}\n",
        "output": "0",
        "idx": "14264"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_45()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_45Sink();\n}\n",
        "output": "1",
        "idx": "18145"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_72bSink(vector<char *> dataVector)\n{\n    /* copy data out of dataVector */\n    char * data = dataVector[2];\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "13353"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_22a()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_22_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_22aGlobal = 0; /* false */\n    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_22_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_22aSource(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "18598"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_54bSink_b(int * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "24348"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54dSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "10629"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_listen_socket_53c_CWE114_Process_Control__w32_wchar_t_listen_socket_53cSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_listen_socket_53d_CWE114_Process_Control__w32_wchar_t_listen_socket_53cSink(data);\n}\n",
        "output": "0",
        "idx": "1714"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_53cSink(data);\n}\n",
        "output": "0",
        "idx": "12823"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_12()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "6045"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_21()\n{\n    char * data;\n    data = new char[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_21Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "28314"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_52bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "27232"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_03()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(5==5)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "12003"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_61bSource(wchar_t * data)\n{\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    return data;\n}\n",
        "output": "1",
        "idx": "14609"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_06()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        wmemset(data, L'A', 100-1); /* fill with L'A's */\n        data[100-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "15148"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_53bSink(data);\n}\n",
        "output": "0",
        "idx": "14914"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_45Sink()\n{\n    int * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_45Data;\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "9935"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_51a()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_51aSink(data);\n}\n",
        "output": "1",
        "idx": "3708"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_64a()\n{\n    int * data;\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_64b_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_64aSink(&data);\n}\n",
        "output": "0",
        "idx": "3608"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "5831"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_73a()\n{\n    int * data;\n    list<int *> dataList;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int[100];\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "24393"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "7038"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_54e_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "18978"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_34()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_34_unionType myUnion;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            size_t i;\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "7664"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_01()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new wchar_t[10];\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "21985"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_15()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "26856"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_67a()\n{\n    int64_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_67_structType myStruct;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "9052"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_54cSink(data);\n}\n",
        "output": "0",
        "idx": "15246"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_73a()\n{\n    wchar_t * data;\n    list<wchar_t *> dataList;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new wchar_t[10];\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "22299"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_53bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "27560"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_66bSink(char * dataArray[])\n{\n    char * data = dataArray[2];\n    {\n        /* The Visual C++ compiler generates a warning if you initialize the class with ().\n         * This will cause the compile to default-initialize the object.\n         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n         */\n        /* FIX: data will at least be the sizeof(OneIntClass) */\n        OneIntClass * classOne = new(data) OneIntClass;\n        /* Initialize and make use of the class */\n        classOne->intOne = 5;\n        printIntLine(classOne->intOne);\n    }\n}\n",
        "output": "0",
        "idx": "17500"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_45Sink()\n{\n    wchar_t * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_45Data;\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "27383"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_67a()\n{\n    int data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_67_structType myStruct;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_67b_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "3477"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_53cSink_c(int * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "24342"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_73bSink(list<char *> dataList)\n{\n    /* copy data out of dataList */\n    char * data = dataList.back();\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "21013"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_33()\n{\n    wchar_t * data;\n    wchar_t * &dataRef = data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t * data = dataRef;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            memcpy(data, source, 100*sizeof(wchar_t));\n            data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "11785"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_listen_socket_54b_CWE114_Process_Control__w32_char_listen_socket_54bSink(char * data)\n{\n    CWE114_Process_Control__w32_char_listen_socket_54c_CWE114_Process_Control__w32_char_listen_socket_54bSink(data);\n}\n",
        "output": "0",
        "idx": "754"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    {\n        wchar_t * data = *dataPtr1;\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            memcpy(data, source, 100*sizeof(wchar_t));\n            data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "10985"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_73a()\n{\n    int data;\n    list<int> dataList;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "2756"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_53bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "21603"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_53a()\n{\n    void * data;\n    data = NULL;\n    /* FIX: Set data to point to a char string */\n    data = (void *)CHAR_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_53b_CWE121_Stack_Based_Buffer_Overflow__CWE135_53aSink(data);\n}\n",
        "output": "0",
        "idx": "4059"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_45Sink()\n{\n    int * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_45Data;\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "9538"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE114_Process_Control__w32_wchar_t_console_74a()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    /* FIX: Specify the full pathname for the library */\n    wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE114_Process_Control__w32_wchar_t_console_74aSink(dataMap);\n}\n",
        "output": "0",
        "idx": "1285"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_66a()\n{\n    int * data;\n    int * dataArray[5];\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int[50];\n    /* put data in array */\n    dataArray[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "24537"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_62a()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_62aSource(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "14289"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_16()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    while(1)\n    {\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "5125"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_53bSink(data);\n}\n",
        "output": "0",
        "idx": "4632"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_67a()\n{\n    wchar_t * data;\n    structType myStruct;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new wchar_t[100];\n    data[0] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "25025"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_67b_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_67_structType myStruct)\n{\n    int * data = myStruct.structFirst;\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "3622"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_54a()\n{\n    char * data;\n    data = new char[100];\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_54aSink_b(data);\n}\n",
        "output": "0",
        "idx": "26118"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_67a()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_67_structType myStruct;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_67b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "14954"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    char * * dataPtr = (char * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    char * data = (*dataPtr);\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "20989"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_74a()\n{\n    int data;\n    map<int, int> dataMap;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_74aSink(dataMap);\n}\n",
        "output": "0",
        "idx": "2764"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_66a()\n{\n    int * data;\n    int * dataArray[5];\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "9714"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_44()\n{\n    char * data;\n    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_44Sink;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "12642"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_53bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "21442"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "5575"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_16()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    while(1)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strncpy(data, source, 100-1);\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "7386"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "15087"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_04()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(STATIC_CONST_TRUE)\n    {\n        /* POTENTIAL FLAW: Read data from the console using fscanf() */\n        fscanf(stdin, \"%d\", &data);\n    }\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            int i;\n            int * buffer = new int[10];\n            /* initialize buffer */\n            for (i = 0; i < 10; i++)\n            {\n                buffer[i] = 0;\n            }\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n            delete[] buffer;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "19727"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67_structType myStruct)\n{\n    char * data = myStruct.structFirst;\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4267"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_74bSink(map<int, char *> dataMap)\n{\n    /* copy data out of dataMap */\n    char * data = dataMap[2];\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4814"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_73bSink(list<int64_t *> dataList)\n{\n    int64_t * data = dataList.back();\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "8668"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_relativePath_41()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    /* FLAW: Specify just the file name for the library, not the full path */\n    wcscpy(data, L\"winsrv.dll\");\n    CWE114_Process_Control__w32_wchar_t_relativePath_41Sink(data);\n}\n",
        "output": "1",
        "idx": "1841"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_73a()\n{\n    wchar_t * data;\n    list<wchar_t *> dataList;\n    data = new wchar_t[100];\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "26968"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_34()\n{\n    char * data;\n    unionType myUnion;\n    data = NULL;\n    /* FIX: Allocate space for a null terminator */\n    data = new char[10+1];\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char source[10+1] = SRC_STRING;\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            strcpy(data, source);\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "20765"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_54a()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_54aSink(data);\n}\n",
        "output": "1",
        "idx": "3593"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_52bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "24817"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_34()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_34_unionType myUnion;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            size_t i;\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "11654"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_72a()\n{\n    int data;\n    vector<int> dataVector;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "3488"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_33()\n{\n    char * data;\n    char * &dataRef = data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    {\n        char * data = dataRef;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            strncpy(dest, data, strlen(data));\n            dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "13107"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_45()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new TwoIntsClass[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_45Sink();\n}\n",
        "output": "1",
        "idx": "23359"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_54bSink(data);\n}\n",
        "output": "0",
        "idx": "15888"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_21()\n{\n    wchar_t * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_21Source(data);\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "25098"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_73a()\n{\n    int data;\n    list<int> dataList;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "3004"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_68a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_68_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_68b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_68aSink();\n}\n",
        "output": "0",
        "idx": "2991"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_73a()\n{\n    char * data;\n    list<char *> dataList;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new char[100];\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "22461"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "4773"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static wchar_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_21Source(wchar_t * data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_21Static)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new wchar_t[100];\n        data[0] = L'\\0'; /* null terminate */\n    }\n    return data;\n}\n",
        "output": "0",
        "idx": "24775"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_67a()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_67_structType myStruct;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "11979"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_06()\n{\n    wchar_t * data;\n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new wchar_t[10+1];\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "21679"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_52bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "27554"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_17()\n{\n    int h;\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4862"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_18()\n{\n    char * data;\n    data = NULL;\n    goto source;\nsource:\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new char[50];\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */\n        strcat(data, source);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "27667"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_68a()\n{\n    int * data;\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_68_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_68b_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_68aSink();\n}\n",
        "output": "0",
        "idx": "3757"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54cSink(data);\n}\n",
        "output": "0",
        "idx": "12831"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_68bSink()\n{\n    int64_t * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_68_CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_68bData;\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "24226"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45Sink()\n{\n    twoIntsStruct * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45Data;\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "10334"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_54b_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "18008"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_45()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_45Sink();\n}\n",
        "output": "1",
        "idx": "24486"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_62bSource(int64_t * &data)\n{\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int64_t[100];\n}\n",
        "output": "0",
        "idx": "23880"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_32()\n{\n    int64_t * data;\n    int64_t * *dataPtr1 = &data;\n    int64_t * *dataPtr2 = &data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    {\n        int64_t * data = *dataPtr1;\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        *dataPtr1 = data;\n    }\n    {\n        int64_t * data = *dataPtr2;\n        {\n            int64_t source[100] = {0}; /* fill with 0's */\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memcpy(data, source, 100*sizeof(int64_t));\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "8591"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_41Sink(int * data)\n{\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3563"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_74a()\n{\n    char * data;\n    map<int, char *> dataMap;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "12554"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_05()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "8552"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_72bSink(vector<int *> dataVector)\n{\n    int * data = dataVector[2];\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "3630"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_54dSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_54dSink(data);\n}\n",
        "output": "0",
        "idx": "10097"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_62bSource(int &data)\n{\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n}\n",
        "output": "1",
        "idx": "2711"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_54d_CWE121_Stack_Based_Buffer_Overflow__CWE135_54dSink(void * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_54e_CWE121_Stack_Based_Buffer_Overflow__CWE135_54dSink(data);\n}\n",
        "output": "0",
        "idx": "4080"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_53cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "28367"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_74a()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "14486"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_54cSink(data);\n}\n",
        "output": "0",
        "idx": "10893"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_console_53b_CWE114_Process_Control__w32_wchar_t_console_53bSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_console_53c_CWE114_Process_Control__w32_wchar_t_console_53bSink(data);\n}\n",
        "output": "0",
        "idx": "1229"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_68a()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_68aSink();\n}\n",
        "output": "0",
        "idx": "8525"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_65a()\n{\n    int64_t * data;\n    /* define a function pointer */\n    void (*funcPtr) (int64_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_65aSink;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "9044"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TwoIntsClass * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_61bSource(TwoIntsClass * data)\n{\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new TwoIntsClass[100];\n    return data;\n}\n",
        "output": "0",
        "idx": "23715"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_74bSink(map<int, int64_t *> dataMap)\n{\n    /* copy data out of dataMap */\n    int64_t * data = dataMap[2];\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "8937"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    {\n        wchar_t * data = *dataPtr1;\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            size_t i;\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "11651"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_21()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_21Static = 1; /* true */\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_21Sink(data);\n}\n",
        "output": "0",
        "idx": "2363"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_53cSink(data);\n}\n",
        "output": "0",
        "idx": "4634"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_21()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_21Static = 0; /* false */\n    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_21Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "18755"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_45()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_45Sink();\n}\n",
        "output": "1",
        "idx": "3838"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "wchar_t * CWE114_Process_Control__w32_wchar_t_relativePath_22bSource(wchar_t * data)\n{\n    if(CWE114_Process_Control__w32_wchar_t_relativePath_22bGlobal)\n    {\n        /* FLAW: Specify just the file name for the library, not the full path */\n        wcscpy(data, L\"winsrv.dll\");\n    }\n    return data;\n}\n",
        "output": "1",
        "idx": "1829"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_13()\n{\n    char * data;\n    data = NULL;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new char[50];\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memmove(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "22663"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_72bSink(vector<wchar_t *> dataVector)\n{\n    wchar_t * data = dataVector[2];\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "25679"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_21()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_21Static = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_21Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "18109"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_62bSource(void * &data)\n{\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n}\n",
        "output": "1",
        "idx": "4094"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_68a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_68_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_68b_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_68aSink();\n}\n",
        "output": "0",
        "idx": "3483"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_52bSink(data);\n}\n",
        "output": "0",
        "idx": "14908"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_54dSink_d(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "26767"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "6770"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_54cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "23062"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_14()\n{\n    wchar_t * data;\n    data = NULL;\n    if(globalFive==5)\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new wchar_t[10+1];\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "21863"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67a()\n{\n    int data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67_structType myStruct;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "2984"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67_structType myStruct)\n{\n    int * data = myStruct.structFirst;\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "9587"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_67a()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_67_structType myStruct;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_67b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "15759"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_41()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_41_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_41Sink(data);\n}\n",
        "output": "0",
        "idx": "4344"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_74bSink(map<int, wchar_t *> dataMap)\n{\n    wchar_t * data = dataMap[2];\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "11066"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_54a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_54b_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_54aSink(data);\n}\n",
        "output": "0",
        "idx": "3180"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_33()\n{\n    int data;\n    int &dataRef = data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    {\n        int data = dataRef;\n        {\n            int i;\n            int * buffer = new int[10];\n            /* initialize buffer */\n            for (i = 0; i < 10; i++)\n            {\n                buffer[i] = 0;\n            }\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n            delete[] buffer;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "20553"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_06()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "5096"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_68a()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_68aSink();\n}\n",
        "output": "1",
        "idx": "10253"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_72a()\n{\n    int * data;\n    vector<int *> dataVector;\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_72aSink(dataVector);\n}\n",
        "output": "0",
        "idx": "3628"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_53d_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "18002"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_67a()\n{\n    int data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_67_structType myStruct;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "3476"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_41Sink(wchar_t * data)\n{\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "5538"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_66a()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "12107"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_32()\n{\n    int64_t * data;\n    int64_t * *dataPtr1 = &data;\n    int64_t * *dataPtr2 = &data;\n    data = NULL;\n    {\n        int64_t * data = *dataPtr1;\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int64_t[100];\n        *dataPtr1 = data;\n    }\n    {\n        int64_t * data = *dataPtr2;\n        {\n            int64_t source[100] = {0}; /* fill with 0's */\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memcpy(data, source, 100*sizeof(int64_t));\n            printLongLongLine(data[0]);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "23981"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_65a()\n{\n    int * data;\n    void (*funcPtr) (int *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_65aSink;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int[100];\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "24534"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_54b_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_54c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_54bSink(data);\n}\n",
        "output": "0",
        "idx": "17149"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_52a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_52aSink_b(data);\n}\n",
        "output": "0",
        "idx": "20104"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_04()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcscat(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "17067"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_66a()\n{\n    int data;\n    int dataArray[5];\n    /* Initialize data */\n    data = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_66b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "2488"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_54b_CWE121_Stack_Based_Buffer_Overflow__CWE135_54bSink(void * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_54c_CWE121_Stack_Based_Buffer_Overflow__CWE135_54bSink(data);\n}\n",
        "output": "0",
        "idx": "4074"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_connect_socket_54d_CWE114_Process_Control__w32_wchar_t_connect_socket_54dSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_connect_socket_54e_CWE114_Process_Control__w32_wchar_t_connect_socket_54dSink(data);\n}\n",
        "output": "0",
        "idx": "1080"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_01()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "6147"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_43Source(char * &data)\n{\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new char[100];\n    data[0] = '\\0'; /* null terminate */\n}\n",
        "output": "0",
        "idx": "22547"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "7433"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_66bSink(char * dataArray[])\n{\n    char * data = dataArray[2];\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "21320"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_53bSink_b(int64_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "24179"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "6240"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_65a()\n{\n    char * data;\n    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_65b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_65aSink;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "7848"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_74a()\n{\n    int data;\n    map<int, int> dataMap;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "3008"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "wchar_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_22bSource(wchar_t * data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_22bGlobal)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new wchar_t[100];\n        data[0] = L'\\0'; /* null terminate */\n    }\n    return data;\n}\n",
        "output": "0",
        "idx": "24782"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static wchar_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_21Source(wchar_t * data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_21Static)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new wchar_t[100];\n        data[0] = L'\\0'; /* null terminate */\n    }\n    return data;\n}\n",
        "output": "0",
        "idx": "24773"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_54bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "24992"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_72bSink(vector<TwoIntsClass *> dataVector)\n{\n    /* copy data out of dataVector */\n    TwoIntsClass * data = dataVector[2];\n    {\n        TwoIntsClass source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(TwoIntsClass));\n        printIntLine(data[0].intOne);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "23585"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_72bSink(vector<wchar_t *> dataVector)\n{\n    /* copy data out of dataVector */\n    wchar_t * data = dataVector[2];\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "15285"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    {\n        wchar_t * data = *dataPtr1;\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            size_t i, sourceLen;\n            sourceLen = wcslen(source);\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            for (i = 0; i < sourceLen + 1; i++)\n            {\n                data[i] = source[i];\n            }\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "6330"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_68a()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_68aSink();\n}\n",
        "output": "0",
        "idx": "10653"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_01()\n{\n    {\n        charVoid structCharVoid;\n        structCharVoid.voidSecond = (void *)SRC_STR;\n        /* Print the initial block pointed to by structCharVoid.voidSecond */\n        printWLine((wchar_t *)structCharVoid.voidSecond);\n        /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n        memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n        structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n        printWLine((wchar_t *)structCharVoid.charFirst);\n        printWLine((wchar_t *)structCharVoid.voidSecond);\n    }\n}\n",
        "output": "0",
        "idx": "19026"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_45()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_45Sink();\n}\n",
        "output": "0",
        "idx": "5416"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_01()\n{\n    char * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new char[10];\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "20697"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_64a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_64aSink(&data);\n}\n",
        "output": "1",
        "idx": "3458"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    char * * dataPtr = (char * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    char * data = (*dataPtr);\n    {\n        /* The Visual C++ compiler generates a warning if you initialize the class with ().\n         * This will cause the compile to default-initialize the object.\n         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n         */\n        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n        TwoIntsClass * classTwo = new(data) TwoIntsClass;\n        /* Initialize and make use of the class */\n        classTwo->intOne = 5;\n        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n        printIntLine(classTwo->intOne);\n        /* skip printing classTwo->intTwo since that could be a buffer overread */\n    }\n}\n",
        "output": "1",
        "idx": "17486"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_43Source(void * &data)\n{\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n}\n",
        "output": "0",
        "idx": "4029"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "6494"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_14()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    if(globalFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "8978"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_53bSink(data);\n}\n",
        "output": "0",
        "idx": "11947"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_54dSink_d(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "26445"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_54dSink(data);\n}\n",
        "output": "0",
        "idx": "15409"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_53a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_53b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_53aSink(data);\n}\n",
        "output": "0",
        "idx": "2677"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_05()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(staticTrue)\n    {\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "5359"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_53bSink(data);\n}\n",
        "output": "0",
        "idx": "10883"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_53cSink_c(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "17456"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_17()\n{\n    int i,j;\n    int data;\n    /* Initialize data */\n    data = -1;\n    for(i = 0; i < 1; i++)\n    {\n        /* POTENTIAL FLAW: Use an invalid index */\n        data = 10;\n    }\n    for(j = 0; j < 1; j++)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}\n",
        "output": "1",
        "idx": "2842"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_51a()\n{\n    int64_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int64_t[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_51aSink(data);\n}\n",
        "output": "1",
        "idx": "23845"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_21()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_21Static = 0; /* false */\n    data = CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_21Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "18272"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_53bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "21925"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_09()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(GLOBAL_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "9363"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_53a()\n{\n    void * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_53aSink(data);\n}\n",
        "output": "1",
        "idx": "4058"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_74a()\n{\n    char * data;\n    map<int, char *> dataMap;\n    data = new char[100];\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "26328"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_41()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_41Sink(data);\n}\n",
        "output": "0",
        "idx": "2879"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_45()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_45Sink();\n}\n",
        "output": "1",
        "idx": "24647"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_53cSink(data);\n}\n",
        "output": "0",
        "idx": "15399"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_67a()\n{\n    int * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_67_structType myStruct;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "9319"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_15()\n{\n    void * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        /* POTENTIAL FLAW: Set data to point to a wide string */\n        data = (void *)WIDE_STRING;\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(7)\n    {\n    case 7:\n    {\n        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n        size_t dataLen = strlen((char *)data);\n        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n        (void)wcscpy(dest, data);\n        printLine((char *)dest);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n",
        "output": "1",
        "idx": "3971"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68a()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_68aSink();\n}\n",
        "output": "1",
        "idx": "9854"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_34()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_34_unionType myUnion;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            memmove(data, source, 100*sizeof(wchar_t));\n            data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "11122"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54cSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "10627"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_63a()\n{\n    void * data;\n    data = NULL;\n    /* FIX: Set data to point to a char string */\n    data = (void *)CHAR_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_63b_CWE121_Stack_Based_Buffer_Overflow__CWE135_63aSink(&data);\n}\n",
        "output": "0",
        "idx": "4098"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_63a()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_63b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_63aSink(&data);\n}\n",
        "output": "0",
        "idx": "15421"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_68a()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_68aSink();\n}\n",
        "output": "1",
        "idx": "18204"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_72bSink(vector<char *> dataVector)\n{\n    char * data = dataVector[2];\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4275"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_54bSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "8630"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_54dSink(data);\n}\n",
        "output": "0",
        "idx": "11161"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54bSink(data);\n}\n",
        "output": "0",
        "idx": "13795"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_67a()\n{\n    twoIntsStruct * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_67_structType myStruct;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "10781"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_54cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "25960"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static wchar_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_21Source(wchar_t * data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_21Static)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new wchar_t[10+1];\n    }\n    return data;\n}\n",
        "output": "0",
        "idx": "21553"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_22a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_22aGlobal = 1; /* true */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_22aSink(data);\n}\n",
        "output": "0",
        "idx": "19558"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_13()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "10570"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_65a()\n{\n    wchar_t * data;\n    /* define a function pointer */\n    void (*funcPtr) (wchar_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_65aSink;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "6251"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_22a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_22aGlobal = 1; /* true */\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_22aSink(data);\n}\n",
        "output": "1",
        "idx": "2856"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_05()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4296"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_51bSink(char * data)\n{\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4488"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_53bSink(data);\n}\n",
        "output": "0",
        "idx": "4366"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_68a()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_68aSink();\n}\n",
        "output": "1",
        "idx": "6928"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_54a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_54aSink_b(data);\n}\n",
        "output": "0",
        "idx": "19387"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_15()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4325"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_68a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_68_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_68b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_68aSink();\n}\n",
        "output": "0",
        "idx": "2745"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_21Source(char * data)\n{\n    if(CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_21Static)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    return data;\n}\n",
        "output": "0",
        "idx": "12448"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    wchar_t * data = (*dataPtr);\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "11303"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_73bSink(list<char *> dataList)\n{\n    char * data = dataList.back();\n    {\n        /* The Visual C++ compiler generates a warning if you initialize the class with ().\n         * This will cause the compile to default-initialize the object.\n         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n         */\n        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n        TwoIntsClass * classTwo = new(data) TwoIntsClass;\n        /* Initialize and make use of the class */\n        classTwo->intOne = 5;\n        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n        printIntLine(classTwo->intOne);\n        /* skip printing classTwo->intTwo since that could be a buffer overread */\n    }\n}\n",
        "output": "0",
        "idx": "17523"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_67a()\n{\n    char * data;\n    structType myStruct;\n    data = NULL;\n    /* FIX: Allocate space for a null terminator */\n    data = new char[10+1];\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "21483"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_63a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_63aSink(&data);\n}\n",
        "output": "1",
        "idx": "20151"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_15()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "11240"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_67_structType myStruct)\n{\n    wchar_t * data = myStruct.structFirst;\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "18685"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_45()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_45Sink();\n}\n",
        "output": "0",
        "idx": "20586"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_67a()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_67_structType myStruct;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "5727"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "13628"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_64b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    int64_t * * dataPtr = (int64_t * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    int64_t * data = (*dataPtr);\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "8511"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_15()\n{\n    char * data;\n    data = new char[100];\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "26211"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_74bSink(map<int, int *> dataMap)\n{\n    int * data = dataMap[2];\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "24721"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_01()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    {\n        int i;\n        int * buffer = new int[10];\n        /* initialize buffer */\n        for (i = 0; i < 10; i++)\n        {\n            buffer[i] = 0;\n        }\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n        delete[] buffer;\n    }\n}\n",
        "output": "0",
        "idx": "19222"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54a()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54aSink(data);\n}\n",
        "output": "0",
        "idx": "9293"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_53bSink(data);\n}\n",
        "output": "0",
        "idx": "6893"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_01()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "24883"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54cSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54cSink(data);\n}\n",
        "output": "0",
        "idx": "9297"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_63a()\n{\n    void * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_63aSink(&data);\n}\n",
        "output": "1",
        "idx": "4097"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_64b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    char * * dataPtr = (char * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    char * data = (*dataPtr);\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4255"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_console_54b_CWE114_Process_Control__w32_char_console_54bSink(char * data)\n{\n    CWE114_Process_Control__w32_char_console_54c_CWE114_Process_Control__w32_char_console_54bSink(data);\n}\n",
        "output": "0",
        "idx": "271"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_21()\n{\n    char * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_21Static = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_21Source(data);\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "21393"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_53cSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_53cSink(data);\n}\n",
        "output": "0",
        "idx": "8890"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_18()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    goto source;\nsource:\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "18750"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_65a()\n{\n    int64_t * data;\n    void (*funcPtr) (int64_t *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_65b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_65aSink;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "9045"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_53dSink(char * data)\n{\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "12824"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_53bSink(data);\n}\n",
        "output": "0",
        "idx": "13465"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_54dSink(data);\n}\n",
        "output": "0",
        "idx": "13316"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_11()\n{\n    wchar_t * data;\n    data = NULL;\n    if(globalReturnsTrue())\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new wchar_t[10+1];\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "22016"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_45Sink()\n{\n    char * data = CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_45Data;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "28349"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_72a()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_72aSink(dataVector);\n}\n",
        "output": "0",
        "idx": "5736"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_41()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_41Sink(data);\n}\n",
        "output": "1",
        "idx": "17418"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_54cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "23223"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_45()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_45Sink();\n}\n",
        "output": "1",
        "idx": "3572"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_12()\n{\n    if(globalReturnsTrueOrFalse())\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FLAW: Use the sizeof(structCharVoid) which will overwrite the pointer voidSecond */\n            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n    else\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "1964"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    {\n        char * data = *dataPtr1;\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            SNPRINTF(dest, strlen(data), \"%s\", data);\n            printLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "14232"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22aGlobal = 0; /* false */\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_22aSink(data);\n}\n",
        "output": "0",
        "idx": "2365"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_41()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_41_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_41Sink(data);\n}\n",
        "output": "0",
        "idx": "10329"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_15()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        break;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "9645"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "15075"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_34()\n{\n    char * data;\n    unionType myUnion;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new char[50];\n    data[0] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n            memcpy(data, source, 100*sizeof(char));\n            data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "22535"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_53bSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "10218"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_52a()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_52aSink(data);\n}\n",
        "output": "1",
        "idx": "4889"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cpy_16()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    while(1)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "17235"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_45()\n{\n    int64_t * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int64_t[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_45Sink();\n}\n",
        "output": "0",
        "idx": "24005"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_04()\n{\n    wchar_t * data;\n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new wchar_t[10+1];\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "21512"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_52bSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_52bSink(data);\n}\n",
        "output": "0",
        "idx": "8483"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_53bSink_b(int64_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "23857"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_45Sink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_45Data;\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "5945"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_44()\n{\n    char * data;\n    /* define a function pointer */\n    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_44Sink;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "17630"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_15()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "6852"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_53cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "20961"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_63a()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_loop_63aSink(&data);\n}\n",
        "output": "1",
        "idx": "15420"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_03()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(5==5)\n    {\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4422"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "6768"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_73bSink(list<char *> dataList)\n{\n    char * data = dataList.back();\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "12714"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54dSink(data);\n}\n",
        "output": "0",
        "idx": "13799"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_67_structType myStruct)\n{\n    char * data = myStruct.structFirst;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "14311"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_63bSink(wchar_t * * dataPtr)\n{\n    wchar_t * data = *dataPtr;\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "21630"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53c_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53cSink(int data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53d_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53cSink(data);\n}\n",
        "output": "0",
        "idx": "3174"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_54bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "26763"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_file_54b_CWE114_Process_Control__w32_char_file_54bSink(char * data)\n{\n    CWE114_Process_Control__w32_char_file_54c_CWE114_Process_Control__w32_char_file_54bSink(data);\n}\n",
        "output": "0",
        "idx": "593"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_18()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    goto source;\nsource:\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "8587"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_72a()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    data = new wchar_t[100];\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "26964"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_52bSink(data);\n}\n",
        "output": "0",
        "idx": "16196"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_03()\n{\n    int * data;\n    data = NULL;\n    if(5==5)\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memmove(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "3779"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_52a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_52aSink(data);\n}\n",
        "output": "1",
        "idx": "2912"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_53cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "22571"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_01()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "9206"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_67a()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_67_structType myStruct;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "10914"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "4509"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_connect_socket_64b_CWE114_Process_Control__w32_char_connect_socket_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    char * * dataPtr = (char * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    char * data = (*dataPtr);\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "0",
        "idx": "132"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_console_54c_CWE114_Process_Control__w32_char_console_54cSink(char * data)\n{\n    CWE114_Process_Control__w32_char_console_54d_CWE114_Process_Control__w32_char_console_54cSink(data);\n}\n",
        "output": "0",
        "idx": "273"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_16()\n{\n    char * data;\n    data = NULL;\n    while(1)\n    {\n        /* FLAW: Did not leave space for a null terminator */\n        data = new char[10];\n        break;\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "21223"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_42()\n{\n    char * data;\n    data = new char[100];\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_42Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "26245"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "14121"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_54dSink(data);\n}\n",
        "output": "0",
        "idx": "12833"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_52cSink(char * data)\n{\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "6888"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_52bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "25300"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_21Sink(int data)\n{\n    if(CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_21Static)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}\n",
        "output": "1",
        "idx": "2110"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_68a()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_68aSink();\n}\n",
        "output": "0",
        "idx": "12382"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_54bSink_b(TwoIntsClass * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "23543"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_66a()\n{\n    char * data;\n    char * dataArray[5];\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new char[10];\n    /* put data in array */\n    dataArray[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "21478"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_53bSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "9021"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_34()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_34_unionType myUnion;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            size_t i, sourceLen;\n            sourceLen = wcslen(source);\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            for (i = 0; i < sourceLen + 1; i++)\n            {\n                data[i] = source[i];\n            }\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "6334"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_54b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_54bSink(int data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_54c_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_54bSink(data);\n}\n",
        "output": "0",
        "idx": "2937"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_53a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_53aSink(data);\n}\n",
        "output": "1",
        "idx": "2675"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_34()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_34_unionType myUnion;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            wcsncpy(dest, data, wcslen(data));\n            dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "16007"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_45()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_45Sink();\n}\n",
        "output": "1",
        "idx": "28028"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_74a()\n{\n    wchar_t * data;\n    map<int, wchar_t *> dataMap;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_74aSink(dataMap);\n}\n",
        "output": "0",
        "idx": "15614"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_54dSink(data);\n}\n",
        "output": "0",
        "idx": "5708"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_08()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "10555"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_42()\n{\n    char * data;\n    data = new char[100];\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_42Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "26567"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_45()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_45_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_45Sink();\n}\n",
        "output": "0",
        "idx": "16595"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54cSink(data);\n}\n",
        "output": "0",
        "idx": "4642"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_01()\n{\n    int * data;\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "3640"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_54dSink_d(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "27250"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_16()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    while(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "7254"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_45Sink()\n{\n    wchar_t * data = CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_45Data;\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */\n        wcscat(data, source);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "28029"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_16()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    while(1)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        wcsncpy(data, source, 100-1);\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "11376"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_41_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_41Sink(wchar_t * data)\n{\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "14561"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "wchar_t * CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_22_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_22bSource(wchar_t * data)\n{\n    if(CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_22_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_22bGlobal)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    return data;\n}\n",
        "output": "0",
        "idx": "14549"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_15()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "6984"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "6760"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_53cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "25791"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_relativePath_53b_CWE114_Process_Control__w32_char_relativePath_53bSink(char * data)\n{\n    CWE114_Process_Control__w32_char_relativePath_53c_CWE114_Process_Control__w32_char_relativePath_53bSink(data);\n}\n",
        "output": "0",
        "idx": "907"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_54dSink_d(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "20379"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_42()\n{\n    wchar_t * data;\n    data = NULL;\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_42Source(data);\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        wcsncpy(data, source, 100-1);\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "25440"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE114_Process_Control__w32_wchar_t_connect_socket_43Source(wchar_t * &data)\n{\n    /* FIX: Specify the full pathname for the library */\n    wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n}\n",
        "output": "0",
        "idx": "1045"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_18()\n{\n    char * data;\n    data = NULL;\n    goto source;\nsource:\n    /* FLAW: Did not leave space for a null terminator */\n    data = new char[10];\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "21066"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_54cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "26121"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_66bSink(wchar_t * dataArray[])\n{\n    /* copy data out of dataArray */\n    wchar_t * data = dataArray[2];\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "27598"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_relativePath_66a()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    /* FLAW: Specify just the file name for the library, not the full path */\n    strcpy(data, \"winsrv.dll\");\n    /* put data in array */\n    dataArray[2] = data;\n    CWE114_Process_Control__w32_char_relativePath_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "942"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_41()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_41Sink(data);\n}\n",
        "output": "0",
        "idx": "19824"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    data = NULL;\n    {\n        char * data = *dataPtr1;\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new char[50];\n        data[0] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            size_t i;\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "22370"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_54cSink_c(TwoIntsClass * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "23384"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22aGlobal = 0; /* false */\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_22aSink(data);\n}\n",
        "output": "0",
        "idx": "2611"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "11826"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_73a()\n{\n    wchar_t * data;\n    list<wchar_t *> dataList;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "14483"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_45()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_45Sink();\n}\n",
        "output": "1",
        "idx": "7010"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_52bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "20792"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_66a()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "7851"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_45Sink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_45Data;\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "14736"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_04()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "14016"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_54bSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_54bSink(data);\n}\n",
        "output": "0",
        "idx": "8763"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_53a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_53aSink_b(data);\n}\n",
        "output": "0",
        "idx": "19375"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_53c_CWE121_Stack_Based_Buffer_Overflow__CWE135_53cSink(void * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_53d_CWE121_Stack_Based_Buffer_Overflow__CWE135_53cSink(data);\n}\n",
        "output": "0",
        "idx": "4065"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_73bSink(list<wchar_t *> dataList)\n{\n    /* copy data out of dataList */\n    wchar_t * data = dataList.back();\n    {\n        size_t i;\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "24877"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_74a()\n{\n    char * data;\n    map<int, char *> dataMap;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_74aSink(dataMap);\n}\n",
        "output": "0",
        "idx": "12555"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_04()\n{\n    char * data;\n    data = new char[100];\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "25698"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_33()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    {\n        char * data = dataRef;\n        {\n            /* The Visual C++ compiler generates a warning if you initialize the class with ().\n             * This will cause the compile to default-initialize the object.\n             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n             */\n            /* FIX: data will at least be the sizeof(OneIntClass) */\n            OneIntClass * classOne = new(data) OneIntClass;\n            /* Initialize and make use of the class */\n            classOne->intOne = 5;\n            printIntLine(classOne->intOne);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "17619"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_54bSink_b(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "19635"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_18()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    goto source;\nsource:\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "15182"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_16()\n{\n    char * data;\n    data = NULL;\n    while(1)\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new char[10+1];\n        break;\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "21063"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_15()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "12598"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_41()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_41_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_41Sink(data);\n}\n",
        "output": "0",
        "idx": "11659"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_32()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * *dataPtr1 = &data;\n    twoIntsStruct * *dataPtr2 = &data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    {\n        twoIntsStruct * data = *dataPtr1;\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        *dataPtr1 = data;\n    }\n    {\n        twoIntsStruct * data = *dataPtr2;\n        {\n            twoIntsStruct source[100];\n            {\n                size_t i;\n                /* Initialize array */\n                for (i = 0; i < 100; i++)\n                {\n                    source[i].intOne = 0;\n                    source[i].intTwo = 0;\n                }\n            }\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memmove(data, source, 100*sizeof(twoIntsStruct));\n            printStructLine(&data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "10719"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_01()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4949"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_73a()\n{\n    int * data;\n    list<int *> dataList;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "9730"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53b_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53bSink(int data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53c_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_53bSink(data);\n}\n",
        "output": "0",
        "idx": "2187"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_34()\n{\n    int * data;\n    unionType myUnion;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int[50];\n    myUnion.unionFirst = data;\n    {\n        int * data = myUnion.unionSecond;\n        {\n            int source[100] = {0}; /* fill with 0's */\n            {\n                size_t i;\n                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n                for (i = 0; i < 100; i++)\n                {\n                    data[i] = source[i];\n                }\n                printIntLine(data[0]);\n                delete [] data;\n            }\n        }\n    }\n}\n",
        "output": "1",
        "idx": "24306"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_06()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "10150"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_73a()\n{\n    char * data;\n    list<char *> dataList;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "6936"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_43Source(int &data)\n{\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n}\n",
        "output": "0",
        "idx": "2152"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_15()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        wmemset(data, L'A', 100-1); /* fill with L'A's */\n        data[100-1] = L'\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "14369"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_68a()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_68_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_68b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memcpy_68aSink();\n}\n",
        "output": "0",
        "idx": "5200"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_68a()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_68aSink();\n}\n",
        "output": "1",
        "idx": "9721"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_74bSink(map<int, int64_t *> dataMap)\n{\n    int64_t * data = dataMap[2];\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "8539"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_17()\n{\n    int h;\n    char * data;\n    data = NULL;\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new char[10+1];\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "21065"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_01()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "6279"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_63a()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_63aSink(&data);\n}\n",
        "output": "1",
        "idx": "8903"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_72a()\n{\n    int data;\n    vector<int> dataVector;\n    /* Initialize data */\n    data = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "2504"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_53bSink_b(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "19623"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_45Sink();\n}\n",
        "output": "1",
        "idx": "2655"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_54dSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_54dSink(data);\n}\n",
        "output": "0",
        "idx": "3600"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_64a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_64aSink(&data);\n}\n",
        "output": "1",
        "idx": "2966"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_73a()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "7735"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_73bSink(list<int *> dataList)\n{\n    /* copy data out of dataList */\n    int * data = dataList.back();\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memmove(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3899"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_53bSink_b(TwoIntsClass * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "23535"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_54bSink(data);\n}\n",
        "output": "0",
        "idx": "6369"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_44()\n{\n    char * data;\n    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_44Sink;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n    data = dataGoodBuffer;\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "17632"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_16()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    while(1)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "15500"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_05()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    if(staticTrue)\n    {\n        /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n        data = dataBadBuffer;\n    }\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* The Visual C++ compiler generates a warning if you initialize the class with ().\n             * This will cause the compile to default-initialize the object.\n             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n             */\n            /* FIX: data will at least be the sizeof(OneIntClass) */\n            OneIntClass * classOne = new(data) OneIntClass;\n            /* Initialize and make use of the class */\n            classOne->intOne = 5;\n            printIntLine(classOne->intOne);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "17344"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_53cSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_53cSink(data);\n}\n",
        "output": "0",
        "idx": "9555"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_54dSink_d(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memmove_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "27089"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_63a()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_63aSink(&data);\n}\n",
        "output": "1",
        "idx": "10100"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_54bSink(data);\n}\n",
        "output": "0",
        "idx": "8098"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_68a()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_68aSink();\n}\n",
        "output": "1",
        "idx": "7061"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_64aSink(&data);\n}\n",
        "output": "0",
        "idx": "2722"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_66bSink(int * dataArray[])\n{\n    int * data = dataArray[2];\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "9583"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_63a()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_63b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_63aSink(&data);\n}\n",
        "output": "0",
        "idx": "10101"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_68a()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_68aSink();\n}\n",
        "output": "1",
        "idx": "6529"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_74bSink(map<int, TwoIntsClass *> dataMap)\n{\n    /* copy data out of dataMap */\n    TwoIntsClass * data = dataMap[2];\n    {\n        TwoIntsClass source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(TwoIntsClass));\n        printIntLine(data[0].intOne);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "23754"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_54a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_54b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_54aSink(data);\n}\n",
        "output": "0",
        "idx": "2934"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_53bSink_b(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "20115"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_17()\n{\n    int h;\n    char * data;\n    data = NULL;\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new char[100];\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "23158"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_54dSink(data);\n}\n",
        "output": "0",
        "idx": "4644"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "5573"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_53cSink(data);\n}\n",
        "output": "0",
        "idx": "13306"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_03()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(5==5)\n    {\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "6550"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_17()\n{\n    int h;\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "10581"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_74bSink(map<int, wchar_t *> dataMap)\n{\n    /* copy data out of dataMap */\n    wchar_t * data = dataMap[2];\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "14488"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_33()\n{\n    char * data;\n    char * &dataRef = data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char * data = dataRef;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n            strncat(data, source, 100);\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "8061"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_68a()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_68aSink();\n}\n",
        "output": "1",
        "idx": "10652"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_44()\n{\n    int * data;\n    /* define a function pointer */\n    void (*funcPtr) (int *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_44Sink;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "9267"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_13()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "9106"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_54bSink(data);\n}\n",
        "output": "0",
        "idx": "7300"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_15()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "12438"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_relativePath_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        char * data = *dataPtr1;\n        /* FLAW: Specify just the file name for the library, not the full path */\n        strcpy(data, \"winsrv.dll\");\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            HMODULE hModule;\n            /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n             * replace his own file with the intended library */\n            hModule = LoadLibraryA(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n",
        "output": "1",
        "idx": "868"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_33()\n{\n    int64_t * data;\n    int64_t * &dataRef = data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    {\n        int64_t * data = dataRef;\n        {\n            int64_t source[100] = {0}; /* fill with 0's */\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memcpy(data, source, 100*sizeof(int64_t));\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "8993"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_03()\n{\n    if(5==5)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n            printWLine((wchar_t *)structCharVoid.charFirst);\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "19081"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_54dSink_d(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "25479"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_41()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_41Sink(data);\n}\n",
        "output": "0",
        "idx": "17420"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_52a()\n{\n    char * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new char[50];\n    data[0] = '\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_52aSink_b(data);\n}\n",
        "output": "1",
        "idx": "22400"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_67a()\n{\n    int64_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_67_structType myStruct;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "8654"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_63bSink(char * * dataPtr)\n{\n    char * data = *dataPtr;\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4782"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_44()\n{\n    int * data;\n    /* define a function pointer */\n    void (*funcPtr) (int *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_44Sink;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "9799"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_15()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "6452"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_53bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "26433"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_22a()\n{\n    char * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_22aGlobal = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_22aSource(data);\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        strcpy(data, source);\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "27838"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_45()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_45Sink();\n}\n",
        "output": "0",
        "idx": "11800"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_68a()\n{\n    char * data;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_68aSink();\n}\n",
        "output": "1",
        "idx": "17713"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_connect_socket_54c_CWE114_Process_Control__w32_char_connect_socket_54cSink(char * data)\n{\n    CWE114_Process_Control__w32_char_connect_socket_54d_CWE114_Process_Control__w32_char_connect_socket_54cSink(data);\n}\n",
        "output": "0",
        "idx": "112"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67a()\n{\n    int64_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67_structType myStruct;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "8786"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_relativePath_15()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Specify just the file name for the library, not the full path */\n        wcscpy(data, L\"winsrv.dll\");\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "1811"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_08()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "9225"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_53bSink(data);\n}\n",
        "output": "0",
        "idx": "7691"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_21()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_21Static = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_21Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "13739"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_67a()\n{\n    char * data;\n    structType myStruct;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n    data = dataGoodBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "17502"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_45()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_45Sink();\n}\n",
        "output": "1",
        "idx": "14093"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_74bSink(map<int, wchar_t *> dataMap)\n{\n    /* copy data out of dataMap */\n    wchar_t * data = dataMap[2];\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "22144"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_environment_54c_CWE114_Process_Control__w32_wchar_t_environment_54cSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_environment_54d_CWE114_Process_Control__w32_wchar_t_environment_54cSink(data);\n}\n",
        "output": "0",
        "idx": "1400"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char * CWE114_Process_Control__w32_char_relativePath_61bSource(char * data)\n{\n    /* FLAW: Specify just the file name for the library, not the full path */\n    strcpy(data, \"winsrv.dll\");\n    return data;\n}\n",
        "output": "1",
        "idx": "924"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_42()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_42Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "18938"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_52bSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "10611"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54bSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54bSink(data);\n}\n",
        "output": "0",
        "idx": "8497"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_73bSink(list<int *> dataList)\n{\n    int * data = dataList.back();\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "24556"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_33()\n{\n    char * data;\n    char * &dataRef = data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new char[10];\n    {\n        char * data = dataRef;\n        {\n            char source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "21084"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_15()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4191"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_17()\n{\n    int i;\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    for(i = 0; i < 1; i++)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "8984"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_connect_socket_73bSink(list<char *> dataList)\n{\n    /* copy data out of dataList */\n    char * data = dataList.back();\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "155"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54dSink(data);\n}\n",
        "output": "0",
        "idx": "11959"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "6228"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_45()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_45Sink();\n}\n",
        "output": "1",
        "idx": "13449"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "11427"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_54bSink(data);\n}\n",
        "output": "0",
        "idx": "12088"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_51a()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_51aSink(data);\n}\n",
        "output": "1",
        "idx": "14418"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_17()\n{\n    int i;\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        wmemset(data, L'A', 100-1); /* fill with L'A's */\n        data[100-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "15501"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_22a()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_22_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_22aGlobal = 0; /* false */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_22_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_22aSource(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "13258"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_34()\n{\n    char * data;\n    unionType myUnion;\n    data = new char[100];\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            SNPRINTF(dest, strlen(data), \"%s\", data);\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "26560"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_34()\n{\n    char * data;\n    unionType myUnion;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new char[100];\n    data[0] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            size_t i;\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "22375"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_73bSink(list<char *> dataList)\n{\n    /* copy data out of dataList */\n    char * data = dataList.back();\n    {\n        /* The Visual C++ compiler generates a warning if you initialize the class with ().\n         * This will cause the compile to default-initialize the object.\n         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n         */\n        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n        TwoIntsClass * classTwo = new(data) TwoIntsClass;\n        /* Initialize and make use of the class */\n        classTwo->intOne = 5;\n        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n        printIntLine(classTwo->intOne);\n        /* skip printing classTwo->intTwo since that could be a buffer overread */\n    }\n}\n",
        "output": "1",
        "idx": "17728"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE114_Process_Control__w32_wchar_t_relativePath_43Source(wchar_t * &data)\n{\n    /* FLAW: Specify just the file name for the library, not the full path */\n    wcscpy(data, L\"winsrv.dll\");\n}\n",
        "output": "1",
        "idx": "1848"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_53cSink(data);\n}\n",
        "output": "0",
        "idx": "11683"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_41()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_41Sink(data);\n}\n",
        "output": "0",
        "idx": "3125"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_32()\n{\n    int64_t * data;\n    int64_t * *dataPtr1 = &data;\n    int64_t * *dataPtr2 = &data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    {\n        int64_t * data = *dataPtr1;\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        *dataPtr1 = data;\n    }\n    {\n        int64_t * data = *dataPtr2;\n        {\n            int64_t source[100] = {0}; /* fill with 0's */\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memcpy(data, source, 100*sizeof(int64_t));\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "8592"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_72bSink(vector<int *> dataVector)\n{\n    /* copy data out of dataVector */\n    int * data = dataVector[2];\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3629"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_21()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_21Static = 0; /* false */\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_21Sink(data);\n}\n",
        "output": "0",
        "idx": "2851"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_54dSink(data);\n}\n",
        "output": "0",
        "idx": "15248"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_67_structType myStruct)\n{\n    wchar_t * data = myStruct.structFirst;\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "11049"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_03()\n{\n    int64_t * data;\n    data = NULL;\n    if(5==5)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int64_t[100];\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "23763"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_45()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_45Sink();\n}\n",
        "output": "1",
        "idx": "6212"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_12()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "8572"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_53bSink(data);\n}\n",
        "output": "0",
        "idx": "14753"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_21()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_21Static = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_21Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "18914"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_54bSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_54bSink(data);\n}\n",
        "output": "0",
        "idx": "8896"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_16()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    while(1)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        wmemset(data, L'A', 100-1); /* fill with L'A's */\n        data[100-1] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "27502"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_52bSink_b(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "17650"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_53cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "28206"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_54cSink(data);\n}\n",
        "output": "0",
        "idx": "12090"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_45Sink()\n{\n    TwoIntsClass * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_45Data;\n    {\n        TwoIntsClass source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0].intOne);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "23358"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_68a()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_68aSink();\n}\n",
        "output": "1",
        "idx": "9056"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_relativePath_34()\n{\n    char * data;\n    CWE114_Process_Control__w32_char_relativePath_34_unionType myUnion;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    /* FLAW: Specify just the file name for the library, not the full path */\n    strcpy(data, \"winsrv.dll\");\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            HMODULE hModule;\n            /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n             * replace his own file with the intended library */\n            hModule = LoadLibraryA(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n",
        "output": "1",
        "idx": "872"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_21()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_21Static = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_21Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "18113"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_22_CWE121_Stack_Based_Buffer_Overflow__CWE135_22bSink(void * data)\n{\n    if(CWE121_Stack_Based_Buffer_Overflow__CWE135_22_CWE121_Stack_Based_Buffer_Overflow__CWE135_22bGlobal)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* FIX: treating pointer like a wchar_t*  */\n            size_t dataLen = wcslen((wchar_t *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy(dest, data);\n            printWLine((wchar_t *)dest);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "3998"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_54cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "22096"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_21()\n{\n    char * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cat_21Source(data);\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */\n        strcat(data, source);\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "27670"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_34()\n{\n    int64_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_34_unionType myUnion;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myUnion.unionFirst = data;\n    {\n        int64_t * data = myUnion.unionSecond;\n        {\n            int64_t source[100] = {0}; /* fill with 0's */\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memmove(data, source, 100*sizeof(int64_t));\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "8728"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_53dSink(wchar_t * data)\n{\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "5832"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_05()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    if(staticTrue)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "9482"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_15()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "8713"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_52bSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "3715"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "12223"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_74bSink(map<int, int> dataMap)\n{\n    /* copy data out of dataMap */\n    int data = dataMap[2];\n    {\n        int i;\n        int * buffer = new int[10];\n        /* initialize buffer */\n        for (i = 0; i < 10; i++)\n        {\n            buffer[i] = 0;\n        }\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n        delete[] buffer;\n    }\n}\n",
        "output": "1",
        "idx": "19464"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_54dSink_d(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "17471"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_02()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "9740"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_53bSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_53bSink(data);\n}\n",
        "output": "0",
        "idx": "9553"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_54cSink(data);\n}\n",
        "output": "0",
        "idx": "5041"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_53aSink(data);\n}\n",
        "output": "1",
        "idx": "2921"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_21()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_21Static = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_21Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "27511"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_44()\n{\n    TwoIntsClass * data;\n    void (*funcPtr) (TwoIntsClass *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_44Sink;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new TwoIntsClass[100];\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "23518"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_21()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_21Static = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_21Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "14061"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_relativePath_54b_CWE114_Process_Control__w32_wchar_t_relativePath_54bSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_relativePath_54c_CWE114_Process_Control__w32_wchar_t_relativePath_54bSink(data);\n}\n",
        "output": "0",
        "idx": "1881"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_07()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    if(staticFive==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "27478"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memmove_54cSink(data);\n}\n",
        "output": "0",
        "idx": "13797"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_73bSink(list<void *> dataList)\n{\n    /* copy data out of dataList */\n    void * data = dataList.back();\n    {\n        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n        size_t dataLen = strlen((char *)data);\n        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n        (void)wcscpy((wchar_t *)dest, (wchar_t *)data);\n        printLine((char *)dest);\n    }\n}\n",
        "output": "1",
        "idx": "4142"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_17()\n{\n    int h;\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strncpy(data, source, 100-1);\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "8187"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_17()\n{\n    int h;\n    wchar_t * data;\n    data = NULL;\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new wchar_t[10+1];\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "21548"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    {\n        wchar_t * data = *dataPtr1;\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "5798"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_53cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "23215"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_54dSink_d(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "19395"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_21()\n{\n    wchar_t * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_21Static = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_21Source(data);\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "22037"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_54cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "21291"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_45()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_45Sink();\n}\n",
        "output": "1",
        "idx": "9537"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_66a()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "10911"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_54cSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_54cSink(data);\n}\n",
        "output": "0",
        "idx": "8898"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_environment_62bSource(wchar_t * &data)\n{\n    {\n        /* Append input from an environment variable to data */\n        size_t dataLen = wcslen(data);\n        wchar_t * environment = GETENV(ENV_VARIABLE);\n        /* If there is data in the environment variable */\n        if (environment != NULL)\n        {\n            /* POTENTIAL FLAW: Read data from an environment variable */\n            wcsncat(data+dataLen, environment, 100-dataLen-1);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "1411"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_68a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_68aSink();\n}\n",
        "output": "0",
        "idx": "19444"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_52a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_52aSink_b(data);\n}\n",
        "output": "0",
        "idx": "20350"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_21()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_21Static = 0; /* false */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_21Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "15508"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_53bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "23213"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_63a()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_63b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_63aSink(&data);\n}\n",
        "output": "0",
        "idx": "9303"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_68a()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_68aSink();\n}\n",
        "output": "0",
        "idx": "9190"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_73bSink(list<wchar_t *> dataList)\n{\n    /* copy data out of dataList */\n    wchar_t * data = dataList.back();\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "5608"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_45()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_45Sink();\n}\n",
        "output": "1",
        "idx": "7409"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_21()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_21Static = 1; /* true */\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_21Sink(data);\n}\n",
        "output": "1",
        "idx": "2849"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53a()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53aSink(data);\n}\n",
        "output": "1",
        "idx": "3851"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_53b_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "18000"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_52b_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_52c_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "16470"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_16()\n{\n    while(1)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n            /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n            printWLine((wchar_t *)structCharVoid.charFirst);\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n        }\n        break;\n    }\n}\n",
        "output": "0",
        "idx": "19118"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_15()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4324"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_08()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4571"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_53bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "21764"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_07()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(staticFive==5)\n    {\n        /* POTENTIAL FLAW: Set data to a random value */\n        data = RAND32();\n    }\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}\n",
        "output": "0",
        "idx": "3289"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_45Sink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_45Data;\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "7275"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memcpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "11822"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memmove_53bSink(data);\n}\n",
        "output": "0",
        "idx": "7159"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_15()\n{\n    wchar_t * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Did not leave space for a null terminator */\n        data = new wchar_t[10];\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "22025"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_74a()\n{\n    int64_t * data;\n    map<int, int64_t *> dataMap;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "8669"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * CWE114_Process_Control__w32_char_connect_socket_21Source(char * data)\n{\n    if(CWE114_Process_Control__w32_char_connect_socket_21Static)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Specify the full pathname for the library */\n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    return data;\n}\n",
        "output": "0",
        "idx": "51"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_53cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "23054"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_21()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_21Static = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_21Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "15989"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_41()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_41_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_41Sink(data);\n}\n",
        "output": "0",
        "idx": "4876"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_74bSink(map<int, int *> dataMap)\n{\n    int * data = dataMap[2];\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "3638"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_53bSink_b(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "17453"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_12()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        wmemset(data, L'A', 100-1); /* fill with L'A's */\n        data[100-1] = L'\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "27491"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_07()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "13220"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_32()\n{\n    int * data;\n    int * *dataPtr1 = &data;\n    int * *dataPtr2 = &data;\n    data = NULL;\n    {\n        int * data = *dataPtr1;\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int[100];\n        *dataPtr1 = data;\n    }\n    {\n        int * data = *dataPtr2;\n        {\n            int source[100] = {0}; /* fill with 0's */\n            {\n                size_t i;\n                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n                for (i = 0; i < 100; i++)\n                {\n                    data[i] = source[i];\n                }\n                printIntLine(data[0]);\n                delete [] data;\n            }\n        }\n    }\n}\n",
        "output": "0",
        "idx": "24303"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_54cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "28053"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        wmemset(data, L'A', 100-1); /* fill with L'A's */\n        data[100-1] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n            dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "14553"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_54cSink(data);\n}\n",
        "output": "0",
        "idx": "7701"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    data = NULL;\n    {\n        wchar_t * data = *dataPtr1;\n        /* FLAW: Did not leave space for a null terminator */\n        data = new wchar_t[10];\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            wcscpy(data, source);\n            printWLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "21565"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "7425"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_32()\n{\n    int * data;\n    int * *dataPtr1 = &data;\n    int * *dataPtr2 = &data;\n    data = NULL;\n    {\n        int * data = *dataPtr1;\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new int[50];\n        *dataPtr1 = data;\n    }\n    {\n        int * data = *dataPtr2;\n        {\n            int source[100] = {0}; /* fill with 0's */\n            {\n                size_t i;\n                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n                for (i = 0; i < 100; i++)\n                {\n                    data[i] = source[i];\n                }\n                printIntLine(data[0]);\n                delete [] data;\n            }\n        }\n    }\n}\n",
        "output": "1",
        "idx": "24302"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_73a()\n{\n    char * data;\n    list<char *> dataList;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "17519"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_45()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_45Sink();\n}\n",
        "output": "1",
        "idx": "18306"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_44()\n{\n    int data;\n    void (*funcPtr) (int) = CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_44Sink;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "2159"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_67a()\n{\n    int64_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_67_structType myStruct;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "8919"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_72bSink(vector<int *> dataVector)\n{\n    /* copy data out of dataVector */\n    int * data = dataVector[2];\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "24551"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_45()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_45Sink();\n}\n",
        "output": "1",
        "idx": "10734"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_45Sink()\n{\n    char * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_45Data;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "26256"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_67a()\n{\n    wchar_t * data;\n    structType myStruct;\n    data = NULL;\n    /* FIX: Allocate space for a null terminator */\n    data = new wchar_t[10+1];\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "22288"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_06()\n{\n    int64_t * data;\n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new int64_t[50];\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "23931"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncpy_72bSink(vector<char *> dataVector)\n{\n    /* copy data out of dataVector */\n    char * data = dataVector[2];\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strncpy(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "13192"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "13638"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    char * * dataPtr = (char * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    char * data = (*dataPtr);\n    {\n        /* The Visual C++ compiler generates a warning if you initialize the class with ().\n         * This will cause the compile to default-initialize the object.\n         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n         */\n        /* FIX: data will at least be the sizeof(OneIntClass) */\n        OneIntClass * classOne = new(data) OneIntClass;\n        /* Initialize and make use of the class */\n        classOne->intOne = 5;\n        printIntLine(classOne->intOne);\n    }\n}\n",
        "output": "0",
        "idx": "17488"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_68a()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new wchar_t[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_68aSink();\n}\n",
        "output": "1",
        "idx": "22291"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_54cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "24833"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_01()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "9737"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE114_Process_Control__w32_char_connect_socket_73a()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    /* FIX: Specify the full pathname for the library */\n    strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE114_Process_Control__w32_char_connect_socket_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "154"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_06()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "11482"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_17()\n{\n    int h;\n    char * data;\n    data = NULL;\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new char[100];\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "22514"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_31()\n{\n    int64_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int64_t[50];\n    {\n        int64_t * dataCopy = data;\n        int64_t * data = dataCopy;\n        {\n            int64_t source[100] = {0}; /* fill with 0's */\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memcpy(data, source, 100*sizeof(int64_t));\n            printLongLongLine(data[0]);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "23978"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_53c_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_53cSink(int data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_53d_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_53cSink(data);\n}\n",
        "output": "0",
        "idx": "2436"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_01()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n    data = dataGoodBuffer;\n    {\n        /* The Visual C++ compiler generates a warning if you initialize the class with ().\n         * This will cause the compile to default-initialize the object.\n         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n         */\n        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n        TwoIntsClass * classTwo = new(data) TwoIntsClass;\n        /* Initialize and make use of the class */\n        classTwo->intOne = 5;\n        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n        printIntLine(classTwo->intOne);\n        /* skip printing classTwo->intTwo since that could be a buffer overread */\n    }\n}\n",
        "output": "0",
        "idx": "17326"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    data = new char[100];\n    {\n        char * data = *dataPtr1;\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            memmove(dest, data, strlen(data)*sizeof(char));\n            dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "26073"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_63a()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_63aSink(&data);\n}\n",
        "output": "1",
        "idx": "9701"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_68a()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_68_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_68b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_68aSink();\n}\n",
        "output": "0",
        "idx": "8924"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int64_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_21Source(int64_t * data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_21Static)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int64_t[100];\n    }\n    return data;\n}\n",
        "output": "0",
        "idx": "23968"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_45()\n{\n    int64_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int64_t[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_45Sink();\n}\n",
        "output": "1",
        "idx": "24003"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_15()\n{\n    int * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Allocate memory without using sizeof(int) */\n        data = (int *)ALLOCA(10);\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3679"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_53cSink_c(int * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "24664"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "15077"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    char * * dataPtr = (char * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    char * data = (*dataPtr);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "17868"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_05()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(staticTrue)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "13213"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_16()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    while(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        break;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "10313"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "12660"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_18()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    goto source;\nsource:\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "9651"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_13()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "5781"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_01()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4151"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_54cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "21130"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_53cSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memmove_53cSink(data);\n}\n",
        "output": "0",
        "idx": "9954"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_01()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "8940"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_54d_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_54dSink(int data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_54e_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_54dSink(data);\n}\n",
        "output": "0",
        "idx": "2205"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_34()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_34_unionType myUnion;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n            strcat(data, source);\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "16582"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_42Source(int data)\n{\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    return data;\n}\n",
        "output": "1",
        "idx": "2390"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_54bSink_b(int64_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "24187"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_34()\n{\n    twoIntsStruct * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_34_unionType myUnion;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myUnion.unionFirst = data;\n    {\n        twoIntsStruct * data = myUnion.unionSecond;\n        {\n            twoIntsStruct source[100];\n            {\n                size_t i;\n                /* Initialize array */\n                for (i = 0; i < 100; i++)\n                {\n                    source[i].intOne = 0;\n                    source[i].intTwo = 0;\n                }\n            }\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memcpy(data, source, 100*sizeof(twoIntsStruct));\n            printStructLine(&data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "10191"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_52bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "22724"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_72a()\n{\n    char * data;\n    vector<char *> dataVector;\n    data = new char[100];\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "26320"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_15()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    switch(6)\n    {\n    case 6:\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "8050"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_15()\n{\n    wchar_t * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new wchar_t[50];\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "24923"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "4910"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_21()\n{\n    char * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_21Source(data);\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "21230"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_53bSink(data);\n}\n",
        "output": "0",
        "idx": "15880"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_21()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_21Static = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_21Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "13252"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_72bSink(vector<wchar_t *> dataVector)\n{\n    /* copy data out of dataVector */\n    wchar_t * data = dataVector[2];\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "5870"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_43Source(int * &data)\n{\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int[100];\n}\n",
        "output": "0",
        "idx": "24640"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_67a()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_67_structType myStruct;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "16080"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_04()\n{\n    wchar_t * data;\n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new wchar_t[50];\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "24730"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_21()\n{\n    char * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_21Static = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_21Source(data);\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "21071"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_66a()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataArray[5];\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "10512"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_67a()\n{\n    char * data;\n    structType myStruct;\n    data = new char[100];\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "25990"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_72bSink(vector<int *> dataVector)\n{\n    int * data = dataVector[2];\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memmove(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "3896"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_68a()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new TwoIntsClass[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_68aSink();\n}\n",
        "output": "1",
        "idx": "23579"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_15()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "5522"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_13()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new TwoIntsClass[100];\n    }\n    {\n        TwoIntsClass source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(TwoIntsClass));\n        printIntLine(data[0].intOne);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "23469"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_52bSink(data);\n}\n",
        "output": "0",
        "idx": "5956"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_67a()\n{\n    int64_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_67_structType myStruct;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "9185"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_52bSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_52bSink(data);\n}\n",
        "output": "0",
        "idx": "10744"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_12()\n{\n    char * data;\n    data = NULL;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new char[100];\n        data[0] = '\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new char[100];\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        strncpy(data, source, 100-1);\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "22984"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54bSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "9029"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_snprintf_04()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "16110"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_53b_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "16742"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_67a()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_67_structType myStruct;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "11978"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_74bSink(map<int, char *> dataMap)\n{\n    /* copy data out of dataMap */\n    char * data = dataMap[2];\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "13039"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_53bSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_53bSink(data);\n}\n",
        "output": "0",
        "idx": "9287"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_67b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_67_structType myStruct)\n{\n    wchar_t * data = myStruct.structFirst;\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "15278"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53b_CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53bSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_53bSink(data);\n}\n",
        "output": "0",
        "idx": "3854"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_45()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_45Sink();\n}\n",
        "output": "0",
        "idx": "10736"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_52a()\n{\n    void * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_52aSink(data);\n}\n",
        "output": "1",
        "idx": "4049"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_45()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_45Sink();\n}\n",
        "output": "0",
        "idx": "12199"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_53bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "25628"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_54cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "25638"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_41()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new TwoIntsClass[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_41Sink(data);\n}\n",
        "output": "0",
        "idx": "23506"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_15()\n{\n    void * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        /* POTENTIAL FLAW: Set data to point to a wide string */\n        data = (void *)WIDE_STRING;\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        /* FIX: treating pointer like a wchar_t*  */\n        size_t dataLen = wcslen((wchar_t *)data);\n        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n        (void)wcscpy(dest, data);\n        printWLine((wchar_t *)dest);\n    }\n    break;\n    }\n}\n",
        "output": "0",
        "idx": "3972"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_73a()\n{\n    int64_t * data;\n    list<int64_t *> dataList;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "8932"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_34()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_34_unionType myUnion;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            SNPRINTF(data, 100, \"%s\", source);\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "8329"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memmove_54cSink(data);\n}\n",
        "output": "0",
        "idx": "7967"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_22a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_22aGlobal = 1; /* true */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_22aSink(data);\n}\n",
        "output": "1",
        "idx": "20539"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_54a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_54aSink_b(data);\n}\n",
        "output": "0",
        "idx": "20617"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void * CWE121_Stack_Based_Buffer_Overflow__CWE135_61bSource(void * data)\n{\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    return data;\n}\n",
        "output": "1",
        "idx": "4088"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_21()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_21Static = 0; /* false */\n    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_21Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "18916"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_53d_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "16744"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_67a()\n{\n    int * data;\n    structType myStruct;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int[100];\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "24703"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_45()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_45Sink();\n}\n",
        "output": "1",
        "idx": "14415"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * CWE114_Process_Control__w32_char_console_21Source(char * data)\n{\n    if(CWE114_Process_Control__w32_char_console_21Static)\n    {\n        {\n            /* Read input from the console */\n            size_t dataLen = strlen(data);\n            /* if there is room in data, read into it from the console */\n            if (100-dataLen > 1)\n            {\n                /* POTENTIAL FLAW: Read data from the console */\n                if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n                {\n                    /* The next few lines remove the carriage return from the string that is\n                     * inserted by fgets() */\n                    dataLen = strlen(data);\n                    if (dataLen > 0 && data[dataLen-1] == '\\n')\n                    {\n                        data[dataLen-1] = '\\0';\n                    }\n                }\n                else\n                {\n                    printLine(\"fgets() failed\");\n                    /* Restore NUL terminator if fgets fails */\n                    data[dataLen] = '\\0';\n                }\n            }\n        }\n    }\n    return data;\n}\n",
        "output": "1",
        "idx": "210"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_45()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_45Sink();\n}\n",
        "output": "1",
        "idx": "9670"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_45Sink();\n}\n",
        "output": "1",
        "idx": "8739"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_52b_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_52c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_52bSink(data);\n}\n",
        "output": "0",
        "idx": "18799"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_45Sink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_45_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memmove_45Data;\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4617"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_52bSink(data);\n}\n",
        "output": "0",
        "idx": "5025"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cpy_13()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "18900"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_31()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n            wcsncat(data, source, 100);\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "12048"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_54cSink(data);\n}\n",
        "output": "0",
        "idx": "11292"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_environment_02()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(1)\n    {\n        {\n            /* Append input from an environment variable to data */\n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            /* If there is data in the environment variable */\n            if (environment != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from an environment variable */\n                wcsncat(data+dataLen, environment, 100-dataLen-1);\n            }\n        }\n    }\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "1290"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_74a()\n{\n    char * data;\n    map<int, char *> dataMap;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_74aSink(dataMap);\n}\n",
        "output": "0",
        "idx": "4281"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_34()\n{\n    twoIntsStruct * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_34_unionType myUnion;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myUnion.unionFirst = data;\n    {\n        twoIntsStruct * data = myUnion.unionSecond;\n        {\n            twoIntsStruct source[100];\n            {\n                size_t i;\n                /* Initialize array */\n                for (i = 0; i < 100; i++)\n                {\n                    source[i].intOne = 0;\n                    source[i].intTwo = 0;\n                }\n            }\n            {\n                size_t i;\n                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n                for (i = 0; i < 100; i++)\n                {\n                    data[i] = source[i];\n                }\n                printStructLine(&data[0]);\n            }\n        }\n    }\n}\n",
        "output": "1",
        "idx": "10457"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_73bSink(list<TwoIntsClass *> dataList)\n{\n    /* copy data out of dataList */\n    TwoIntsClass * data = dataList.back();\n    {\n        TwoIntsClass source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(TwoIntsClass));\n        printIntLine(data[0].intOne);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "23589"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_66bSink(char * dataArray[])\n{\n    /* copy data out of dataArray */\n    char * data = dataArray[2];\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strcat(data, source);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "16372"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_68a()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_68aSink();\n}\n",
        "output": "1",
        "idx": "25511"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_45Sink()\n{\n    char * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_45Data;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "25934"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_22a()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_22aGlobal = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_22aSource(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "27515"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_02()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "12001"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_67bSink(structType myStruct)\n{\n    wchar_t * data = myStruct.structFirst;\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */\n        wcsncat(data, source, 100);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "25348"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_06()\n{\n    void * data;\n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Set data to point to a wide string */\n        data = (void *)WIDE_STRING;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            /* FIX: treating pointer like a wchar_t*  */\n            size_t dataLen = wcslen((wchar_t *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy(dest, data);\n            printWLine((wchar_t *)dest);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "3930"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_53bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "25306"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_74a()\n{\n    int data;\n    map<int, int> dataMap;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_74aSink(dataMap);\n}\n",
        "output": "0",
        "idx": "3010"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_18()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    goto source;\nsource:\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "15181"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_memcpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "7818"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_52a()\n{\n    int * data;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_loop_52aSink(data);\n}\n",
        "output": "0",
        "idx": "9678"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_66a()\n{\n    int64_t * data;\n    int64_t * dataArray[5];\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "8517"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54b_CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_54aSink(data);\n}\n",
        "output": "0",
        "idx": "2442"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_03()\n{\n    int * data;\n    data = NULL;\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "3645"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "8223"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_53bSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_53bSink(data);\n}\n",
        "output": "0",
        "idx": "10484"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_33()\n{\n    int * data;\n    int * &dataRef = data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    {\n        int * data = dataRef;\n        {\n            int source[10] = {0};\n            /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n            memmove(data, source, 10*sizeof(int));\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "3825"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_53a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_53aSink_b(data);\n}\n",
        "output": "1",
        "idx": "20112"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_21()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_21Static = 0; /* false */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_21Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "15830"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_console_54b_CWE114_Process_Control__w32_wchar_t_console_54bSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_console_54c_CWE114_Process_Control__w32_wchar_t_console_54bSink(data);\n}\n",
        "output": "0",
        "idx": "1237"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54dSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_54dSink(data);\n}\n",
        "output": "0",
        "idx": "9166"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_34()\n{\n    int * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_34_unionType myUnion;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myUnion.unionFirst = data;\n    {\n        int * data = myUnion.unionSecond;\n        {\n            int source[100] = {0}; /* fill with 0's */\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memcpy(data, source, 100*sizeof(int));\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "9393"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_connect_socket_53c_CWE114_Process_Control__w32_wchar_t_connect_socket_53cSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_connect_socket_53d_CWE114_Process_Control__w32_wchar_t_connect_socket_53cSink(data);\n}\n",
        "output": "0",
        "idx": "1070"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memmove_06()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printLine((char *)structCharVoid.voidSecond);\n            /* FLAW: Use the sizeof(structCharVoid) which will overwrite the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid.charFirst);\n            printLine((char *)structCharVoid.voidSecond);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "1995"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_54cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "21613"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53b_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_53aSink(data);\n}\n",
        "output": "0",
        "idx": "3168"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_63bSink(TwoIntsClass * * dataPtr)\n{\n    TwoIntsClass * data = *dataPtr;\n    {\n        TwoIntsClass source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(TwoIntsClass));\n        printIntLine(data[0].intOne);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "23562"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_45()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new wchar_t[10];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_45Sink();\n}\n",
        "output": "1",
        "idx": "21749"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_51a()\n{\n    int64_t * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int64_t[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_51aSink(data);\n}\n",
        "output": "0",
        "idx": "23846"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_52a()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_52aSink(data);\n}\n",
        "output": "1",
        "idx": "3712"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_61a()\n{\n    char * data;\n    data = NULL;\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_61aSource(data);\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        strncpy(data, source, 100-1);\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "23068"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_connect_socket_54d_CWE114_Process_Control__w32_char_connect_socket_54dSink(char * data)\n{\n    CWE114_Process_Control__w32_char_connect_socket_54e_CWE114_Process_Control__w32_char_connect_socket_54dSink(data);\n}\n",
        "output": "0",
        "idx": "114"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_66a()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    data = new wchar_t[100];\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    /* put data in array */\n    dataArray[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "26952"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    void * * dataPtr = (void * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    void * data = (*dataPtr);\n    {\n        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n        size_t dataLen = strlen((char *)data);\n        void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n        (void)wcscpy(dest, data);\n        printLine((char *)dest);\n    }\n}\n",
        "output": "1",
        "idx": "4106"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_01()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* FIX: Properly validate the array index and prevent a buffer overflow */\n        if (data >= 0 && data < (10))\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is out-of-bounds\");\n        }\n    }\n}\n",
        "output": "0",
        "idx": "2524"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_34()\n{\n    void * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_34_unionType myUnion;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    myUnion.unionFirst = data;\n    {\n        void * data = myUnion.unionSecond;\n        {\n            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n            size_t dataLen = strlen((char *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy(dest, data);\n            printLine((char *)dest);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "4010"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_08()\n{\n    int64_t * data;\n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int64_t[100];\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "23939"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_15()\n{\n    int * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Allocate memory without using sizeof(int) */\n        data = (int *)ALLOCA(10);\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3546"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_67bSink(structType myStruct)\n{\n    wchar_t * data = myStruct.structFirst;\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "26797"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_54bSink(void * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_54bSink(data);\n}\n",
        "output": "1",
        "idx": "4073"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_45()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_45_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_45Sink();\n}\n",
        "output": "0",
        "idx": "17127"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_02()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    if(1)\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "14816"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_53cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "27240"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_13()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4852"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_66a()\n{\n    int64_t * data;\n    int64_t * dataArray[5];\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int64_t[50];\n    /* put data in array */\n    dataArray[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "23893"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_34()\n{\n    twoIntsStruct * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_34_unionType myUnion;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myUnion.unionFirst = data;\n    {\n        twoIntsStruct * data = myUnion.unionSecond;\n        {\n            twoIntsStruct source[100];\n            {\n                size_t i;\n                /* Initialize array */\n                for (i = 0; i < 100; i++)\n                {\n                    source[i].intOne = 0;\n                    source[i].intTwo = 0;\n                }\n            }\n            {\n                size_t i;\n                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n                for (i = 0; i < 100; i++)\n                {\n                    data[i] = source[i];\n                }\n                printStructLine(&data[0]);\n            }\n        }\n    }\n}\n",
        "output": "0",
        "idx": "10458"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_snprintf_17()\n{\n    int h;\n    wchar_t * data;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "12310"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_72a()\n{\n    char * data;\n    vector<char *> dataVector;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "12546"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_41()\n{\n    char * data;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_41Sink(data);\n}\n",
        "output": "0",
        "idx": "17626"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_52bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "26105"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    data = new wchar_t[100];\n    {\n        wchar_t * data = *dataPtr1;\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        wmemset(data, L'A', 100-1); /* fill with L'A's */\n        data[100-1] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n            wcsncat(dest, data, wcslen(data));\n            dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "27200"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_06()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "26830"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_68a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_68aSink();\n}\n",
        "output": "1",
        "idx": "3482"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE114_Process_Control__w32_char_connect_socket_72a()\n{\n    char * data;\n    vector<char *> dataVector;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    /* FIX: Specify the full pathname for the library */\n    strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE114_Process_Control__w32_char_connect_socket_72aSink(dataVector);\n}\n",
        "output": "0",
        "idx": "150"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_34()\n{\n    char * data;\n    unionType myUnion;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new char[100];\n    data[0] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n            memcpy(data, source, 100*sizeof(char));\n            data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "22536"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_34()\n{\n    int * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_34_unionType myUnion;\n    int dataBadBuffer[50];\n    int dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myUnion.unionFirst = data;\n    {\n        int * data = myUnion.unionSecond;\n        {\n            int source[100] = {0}; /* fill with 0's */\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memcpy(data, source, 100*sizeof(int));\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "9792"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_01()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strncat(dest, data, strlen(data));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "13847"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_42()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_42Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "27211"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_45()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_45Sink();\n}\n",
        "output": "1",
        "idx": "8606"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_12()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        wmemset(data, L'A', 50-1); /* fill with L'A's */\n        data[50-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "15972"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_67a()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_67_structType myStruct;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "6260"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_54dSink_d(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "24835"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_54dSink_d(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "25801"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static wchar_t * CWE114_Process_Control__w32_wchar_t_file_21Source(wchar_t * data)\n{\n    if(CWE114_Process_Control__w32_wchar_t_file_21Static)\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = wcslen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgetws() failed\");\n                        /* Restore NUL terminator if fgetws fails */\n                        data[dataLen] = L'\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    return data;\n}\n",
        "output": "1",
        "idx": "1498"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_68a()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_68aSink();\n}\n",
        "output": "1",
        "idx": "3756"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_18()\n{\n    char * data;\n    data = new char[100];\n    goto source;\nsource:\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "26058"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_ncat_18()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    goto source;\nsource:\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "7258"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncpy_31()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    {\n        wchar_t * dataCopy = data;\n        wchar_t * data = dataCopy;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            wcsncpy(dest, data, wcslen(data));\n            dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "16001"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_02()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "10006"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_54bSink_b(TwoIntsClass * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "23382"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_54cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memmove_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "22740"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_53cSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_53cSink(data);\n}\n",
        "output": "0",
        "idx": "3590"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_54d_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_54e_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_54dSink(data);\n}\n",
        "output": "0",
        "idx": "18817"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_45Sink()\n{\n    wchar_t * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_45Data;\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "22070"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_16()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    while(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        break;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "8983"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_45()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_45_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_45Sink();\n}\n",
        "output": "0",
        "idx": "2905"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_02()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(1)\n    {\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "6414"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_34()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_34_unionType myUnion;\n    wchar_t dataBadBuffer[50];\n    wchar_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n            wcsncat(data, source, 100);\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "12053"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static wchar_t * CWE114_Process_Control__w32_wchar_t_environment_21Source(wchar_t * data)\n{\n    if(CWE114_Process_Control__w32_wchar_t_environment_21Static)\n    {\n        {\n            /* Append input from an environment variable to data */\n            size_t dataLen = wcslen(data);\n            wchar_t * environment = GETENV(ENV_VARIABLE);\n            /* If there is data in the environment variable */\n            if (environment != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from an environment variable */\n                wcsncat(data+dataLen, environment, 100-dataLen-1);\n            }\n        }\n    }\n    return data;\n}\n",
        "output": "1",
        "idx": "1337"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_66bSink(int * dataArray[])\n{\n    /* copy data out of dataArray */\n    int * data = dataArray[2];\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "9582"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_53bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "25145"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_21()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_21Static = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_21Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "14222"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_44()\n{\n    char * data;\n    void (*funcPtr) (char *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_44Sink;\n    data = NULL;\n    /* FIX: Allocate space for a null terminator */\n    data = new char[10+1];\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "21103"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int64_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_22bSource(int64_t * data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_22bGlobal)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new int64_t[50];\n    }\n    return data;\n}\n",
        "output": "1",
        "idx": "23975"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_53bSink(data);\n}\n",
        "output": "0",
        "idx": "13948"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "15552"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_43()\n{\n    int * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_43Source(data);\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "24641"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_66bSink(twoIntsStruct * dataArray[])\n{\n    twoIntsStruct * data = dataArray[2];\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "10248"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_01()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4816"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_52bSink(data);\n}\n",
        "output": "0",
        "idx": "8084"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_67b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_67_structType myStruct)\n{\n    wchar_t * data = myStruct.structFirst;\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "5996"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_67_structType myStruct)\n{\n    wchar_t * data = myStruct.structFirst;\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "5597"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_21()\n{\n    char * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_21Source(data);\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "21391"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_74a()\n{\n    char * data;\n    map<int, char *> dataMap;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "6940"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_74bSink(map<int, wchar_t *> dataMap)\n{\n    /* copy data out of dataMap */\n    wchar_t * data = dataMap[2];\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "5612"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_52bSink(data);\n}\n",
        "output": "0",
        "idx": "13942"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    data = NULL;\n    {\n        wchar_t * data = *dataPtr1;\n        /* FLAW: Did not leave space for a null terminator */\n        data = new wchar_t[10];\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n            printWLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "21887"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_relativePath_52b_CWE114_Process_Control__w32_wchar_t_relativePath_52bSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_relativePath_52c_CWE114_Process_Control__w32_wchar_t_relativePath_52bSink(data);\n}\n",
        "output": "0",
        "idx": "1867"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_01()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "12558"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_67a()\n{\n    int64_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_67_structType myStruct;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "9053"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_73a()\n{\n    char * data;\n    list<char *> dataList;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "4277"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_15()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "6320"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_52a()\n{\n    char * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new char[100];\n    data[0] = '\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_52aSink_b(data);\n}\n",
        "output": "0",
        "idx": "22401"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_18()\n{\n    char * data;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    goto source;\nsource:\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    goto sink;\nsink:\n    {\n        /* The Visual C++ compiler generates a warning if you initialize the class with ().\n         * This will cause the compile to default-initialize the object.\n         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n         */\n        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n        TwoIntsClass * classTwo = new(data) TwoIntsClass;\n        /* Initialize and make use of the class */\n        classTwo->intOne = 5;\n        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n        printIntLine(classTwo->intOne);\n        /* skip printing classTwo->intTwo since that could be a buffer overread */\n    }\n}\n",
        "output": "1",
        "idx": "17608"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_34()\n{\n    char * data;\n    unionType myUnion;\n    data = NULL;\n    /* FIX: Allocate space for a null terminator */\n    data = new char[10+1];\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char source[10+1] = SRC_STRING;\n            size_t i, sourceLen;\n            sourceLen = strlen(source);\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            for (i = 0; i < sourceLen + 1; i++)\n            {\n                data[i] = source[i];\n            }\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "20926"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_67bSink(structType myStruct)\n{\n    char * data = myStruct.structFirst;\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "21162"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_52bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "22563"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    {\n        char * data = *dataPtr1;\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            memmove(dest, data, strlen(data)*sizeof(char));\n            dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "12783"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_53c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_53d_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_53cSink(data);\n}\n",
        "output": "0",
        "idx": "18485"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_52b_CWE121_Stack_Based_Buffer_Overflow__CWE135_52bSink(void * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_52c_CWE121_Stack_Based_Buffer_Overflow__CWE135_52bSink(data);\n}\n",
        "output": "0",
        "idx": "4053"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_62bSource(char * &data)\n{\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new char[100];\n    data[0] = '\\0'; /* null terminate */\n}\n",
        "output": "0",
        "idx": "22431"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54bSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "10625"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54cSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "3731"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_listen_socket_52b_CWE114_Process_Control__w32_wchar_t_listen_socket_52bSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_listen_socket_52c_CWE114_Process_Control__w32_wchar_t_listen_socket_52bSink(data);\n}\n",
        "output": "0",
        "idx": "1706"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_console_01()\n{\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        /* Read input from the console */\n        size_t dataLen = strlen(data);\n        /* if there is room in data, read into it from the console */\n        if (100-dataLen > 1)\n        {\n            /* POTENTIAL FLAW: Read data from the console */\n            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                /* The next few lines remove the carriage return from the string that is\n                 * inserted by fgets() */\n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "161"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_14()\n{\n    wchar_t * data;\n    data = NULL;\n    if(globalFive==5)\n    {\n        /* FLAW: Did not leave space for a null terminator */\n        data = new wchar_t[10];\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "21539"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_54cSink_c(int64_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "24189"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    {\n        wchar_t * data = *dataPtr1;\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            wcscpy(data, source);\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "6197"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * CWE114_Process_Control__w32_char_file_21Source(char * data)\n{\n    if(CWE114_Process_Control__w32_char_file_21Static)\n    {\n        {\n            /* Read input from a file */\n            size_t dataLen = strlen(data);\n            FILE * pFile;\n            /* if there is room in data, attempt to read the input from a file */\n            if (100-dataLen > 1)\n            {\n                pFile = fopen(FILENAME, \"r\");\n                if (pFile != NULL)\n                {\n                    /* POTENTIAL FLAW: Read data from a file */\n                    if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                    {\n                        printLine(\"fgets() failed\");\n                        /* Restore NUL terminator if fgets fails */\n                        data[dataLen] = '\\0';\n                    }\n                    fclose(pFile);\n                }\n            }\n        }\n    }\n    return data;\n}\n",
        "output": "1",
        "idx": "532"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_52bSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_52bSink(data);\n}\n",
        "output": "0",
        "idx": "10478"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_68a()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_loop_68aSink();\n}\n",
        "output": "1",
        "idx": "13508"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_54dSink_d(int * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "24674"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_54dSink_d(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "25640"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_01()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "12397"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_41Sink(twoIntsStruct * data)\n{\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "10193"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_45Sink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_45Data;\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "6080"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_67b_CWE121_Stack_Based_Buffer_Overflow__CWE135_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE135_67_structType myStruct)\n{\n    void * data = myStruct.structFirst;\n    {\n        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n        size_t dataLen = strlen((char *)data);\n        void * dest = (void *)ALLOCA((dataLen+1) * 1);\n        (void)strcpy(dest, data);\n        printLine((char *)dest);\n    }\n}\n",
        "output": "0",
        "idx": "4125"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_44()\n{\n    twoIntsStruct * data;\n    /* define a function pointer */\n    void (*funcPtr) (twoIntsStruct *) = CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_44Sink;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "10065"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_53a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_53aSink_b(data);\n}\n",
        "output": "0",
        "idx": "20359"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_65a()\n{\n    char * data;\n    /* define a function pointer */\n    void (*funcPtr) (char *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_65aSink;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new char[50];\n    data[0] = '\\0'; /* null terminate */\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "22923"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_34()\n{\n    int data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_34_unionType myUnion;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    myUnion.unionFirst = data;\n    {\n        int data = myUnion.unionSecond;\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}\n",
        "output": "0",
        "idx": "3367"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int CWE121_Stack_Based_Buffer_Overflow__CWE129_large_42Source(int data)\n{\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    return data;\n}\n",
        "output": "1",
        "idx": "2882"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_21()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_21Static = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_21Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memmove(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "15667"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "4759"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_17()\n{\n    int i,k;\n    void * data;\n    data = NULL;\n    for(i = 0; i < 1; i++)\n    {\n        /* POTENTIAL FLAW: Set data to point to a wide string */\n        data = (void *)WIDE_STRING;\n    }\n    for(k = 0; k < 1; k++)\n    {\n        {\n            /* FIX: treating pointer like a wchar_t*  */\n            size_t dataLen = wcslen((wchar_t *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy(dest, data);\n            printWLine((wchar_t *)dest);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "3980"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_54cSink_c(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "20622"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_74bSink(map<int, void *> dataMap)\n{\n    void * data = dataMap[2];\n    {\n        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n        size_t dataLen = strlen((char *)data);\n        void * dest = (void *)ALLOCA((dataLen+1) * 1);\n        (void)strcpy((char *)dest, (char *)data);\n        printLine((char *)dest);\n    }\n}\n",
        "output": "0",
        "idx": "4149"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_52bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "26910"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_ncat_53cSink(data);\n}\n",
        "output": "0",
        "idx": "12984"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_54cSink(data);\n}\n",
        "output": "0",
        "idx": "5706"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_72a()\n{\n    int data;\n    vector<int> dataVector;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_72aSink(dataVector);\n}\n",
        "output": "0",
        "idx": "2998"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_alloca_cat_66bSink(wchar_t * dataArray[])\n{\n    /* copy data out of dataArray */\n    wchar_t * data = dataArray[2];\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcscat(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "16904"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    int * * dataPtr = (int * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    int * data = (*dataPtr);\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "9574"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_34()\n{\n    char * data;\n    unionType myUnion;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new char[10];\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            strncpy(data, source, strlen(source) + 1);\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "21408"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_18()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    goto source;\nsource:\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "8987"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_13()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "10968"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_18()\n{\n    goto sink;\nsink:\n    {\n        charVoid structCharVoid;\n        structCharVoid.voidSecond = (void *)SRC_STR;\n        /* Print the initial block pointed to by structCharVoid.voidSecond */\n        printWLine((wchar_t *)structCharVoid.voidSecond);\n        /* FLAW: Use the sizeof(structCharVoid) which will overwrite the pointer voidSecond */\n        memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));\n        structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n        printWLine((wchar_t *)structCharVoid.charFirst);\n        printWLine((wchar_t *)structCharVoid.voidSecond);\n    }\n}\n",
        "output": "1",
        "idx": "19121"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_66bSink(int64_t * dataArray[])\n{\n    /* copy data out of dataArray */\n    int64_t * data = dataArray[2];\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "8784"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_54cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "27570"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_73bSink(list<int *> dataList)\n{\n    int * data = dataList.back();\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "3767"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_ncpy_67_structType myStruct)\n{\n    char * data = myStruct.structFirst;\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4798"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_54bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_loop_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "20967"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_34()\n{\n    wchar_t * data;\n    unionType myUnion;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new wchar_t[10];\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            size_t i, sourceLen;\n            sourceLen = wcslen(source);\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            for (i = 0; i < sourceLen + 1; i++)\n            {\n                data[i] = source[i];\n            }\n            printWLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "21730"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_52bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "28198"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54bSink(data);\n}\n",
        "output": "0",
        "idx": "11955"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_52c_CWE121_Stack_Based_Buffer_Overflow__CWE135_52cSink(void * data)\n{\n    {\n        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n        size_t dataLen = strlen((char *)data);\n        void * dest = (void *)ALLOCA((dataLen+1) * 1);\n        (void)strcpy(dest, data);\n        printLine((char *)dest);\n    }\n}\n",
        "output": "0",
        "idx": "4056"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE114_Process_Control__w32_wchar_t_connect_socket_02()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    if(1)\n    {\n        /* FIX: Specify the full pathname for the library */\n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "0",
        "idx": "970"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_16()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    while(1)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        break;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "9515"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE114_Process_Control__w32_char_connect_socket_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        char * data = *dataPtr1;\n        /* FIX: Specify the full pathname for the library */\n        strcpy(data, \"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            HMODULE hModule;\n            /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n             * replace his own file with the intended library */\n            hModule = LoadLibraryA(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n",
        "output": "0",
        "idx": "64"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_06()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* POTENTIAL FLAW: Read data from the console using fscanf() */\n        fscanf(stdin, \"%d\", &data);\n    }\n    if(STATIC_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* FIX: Properly validate the array index and prevent a buffer overflow */\n            if (data >= 0 && data < (10))\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is out-of-bounds\");\n            }\n        }\n    }\n}\n",
        "output": "0",
        "idx": "2546"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_17()\n{\n    int h,j;\n    void * data;\n    data = NULL;\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Set data to point to a char string */\n        data = (void *)CHAR_STRING;\n    }\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n            size_t dataLen = strlen((char *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * 1);\n            (void)strcpy(dest, data);\n            printLine((char *)dest);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "3981"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_62bSource(int &data)\n{\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n}\n",
        "output": "1",
        "idx": "3449"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_66a()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataArray[5];\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "10378"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_54cSink_c(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "20130"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_73a()\n{\n    char * data;\n    list<char *> dataList;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memmove_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "12872"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_53bSink(data);\n}\n",
        "output": "0",
        "idx": "11548"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_45Sink()\n{\n    char * data = CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_45_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cpy_45Data;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "17985"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_54bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memmove_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "26119"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_67_structType myStruct)\n{\n    char * data = myStruct.structFirst;\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "12702"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_53cSink(data);\n}\n",
        "output": "0",
        "idx": "13950"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_console_52b_CWE114_Process_Control__w32_char_console_52bSink(char * data)\n{\n    CWE114_Process_Control__w32_char_console_52c_CWE114_Process_Control__w32_char_console_52bSink(data);\n}\n",
        "output": "0",
        "idx": "257"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_63a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_63aSink(&data);\n}\n",
        "output": "1",
        "idx": "20643"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_68a()\n{\n    void * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_68aSink();\n}\n",
        "output": "1",
        "idx": "4127"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_15()\n{\n    int64_t * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new int64_t[50];\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "24118"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_51a()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_51b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_cpy_51aSink(data);\n}\n",
        "output": "0",
        "idx": "6216"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_45()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_45Sink();\n}\n",
        "output": "1",
        "idx": "6345"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_01()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "25527"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_21()\n{\n    wchar_t * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_21Static = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncpy_21Source(data);\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        wcsncpy(data, source, 100-1);\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "25418"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_15()\n{\n    int * data;\n    data = NULL;\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new int[50];\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "24440"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_53bSink(data);\n}\n",
        "output": "0",
        "idx": "6361"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_64b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    char * * dataPtr = (char * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    char * data = (*dataPtr);\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4521"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_53bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "22247"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_53b_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_53c_CWE121_Stack_Based_Buffer_Overflow__dest_wchar_t_declare_cat_53bSink(data);\n}\n",
        "output": "0",
        "idx": "17141"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_44()\n{\n    char * data;\n    void (*funcPtr) (char *) = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_44Sink;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "4880"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_14()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    if(globalFive==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n    }\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printStructLine(&data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "10441"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "14604"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE114_Process_Control__w32_wchar_t_connect_socket_32()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        /* FIX: Specify the full pathname for the library */\n        wcscpy(data, L\"C:\\\\Windows\\\\System32\\\\winsrv.dll\");\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            HMODULE hModule;\n            /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n             * replace his own file with the intended library */\n            hModule = LoadLibraryW(data);\n            if (hModule != NULL)\n            {\n                FreeLibrary(hModule);\n                printLine(\"Library loaded and freed successfully\");\n            }\n            else\n            {\n                printLine(\"Unable to load library\");\n            }\n        }\n    }\n}\n",
        "output": "0",
        "idx": "1030"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_52bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "27876"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_connect_socket_72bSink(vector<char *> dataVector)\n{\n    /* copy data out of dataVector */\n    char * data = dataVector[2];\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "151"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_67a()\n{\n    int data;\n    structType myStruct;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "20669"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_listen_socket_54b_CWE114_Process_Control__w32_wchar_t_listen_socket_54bSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_listen_socket_54c_CWE114_Process_Control__w32_wchar_t_listen_socket_54bSink(data);\n}\n",
        "output": "0",
        "idx": "1720"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_64a()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_64aSink(&data);\n}\n",
        "output": "1",
        "idx": "8907"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_connect_socket_52bSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_connect_socket_52bSink(data);\n}\n",
        "output": "1",
        "idx": "1061"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_53bSink(data);\n}\n",
        "output": "0",
        "idx": "5031"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_74a()\n{\n    int data;\n    map<int, int> dataMap;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "2762"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_33()\n{\n    char * data;\n    char * &dataRef = data;\n    data = new char[100];\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    {\n        char * data = dataRef;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n            strcat(dest, data);\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "28330"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_53bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "26272"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_41()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_41Sink(data);\n}\n",
        "output": "1",
        "idx": "4209"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memcpy_15()\n{\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        charVoid structCharVoid;\n        structCharVoid.voidSecond = (void *)SRC_STR;\n        /* Print the initial block pointed to by structCharVoid.voidSecond */\n        printWLine((wchar_t *)structCharVoid.voidSecond);\n        /* FIX: Use sizeof(structCharVoid.charFirst) to avoid overwriting the pointer voidSecond */\n        memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));\n        structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n        printWLine((wchar_t *)structCharVoid.charFirst);\n        printWLine((wchar_t *)structCharVoid.voidSecond);\n    }\n    break;\n    }\n}\n",
        "output": "0",
        "idx": "19066"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_54dSink_d(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "28216"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_74bSink(map<int, int *> dataMap)\n{\n    /* copy data out of dataMap */\n    int * data = dataMap[2];\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3770"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_file_54d_CWE114_Process_Control__w32_wchar_t_file_54dSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_file_54e_CWE114_Process_Control__w32_wchar_t_file_54dSink(data);\n}\n",
        "output": "0",
        "idx": "1563"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_41Sink(int * data)\n{\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "9395"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_73a()\n{\n    void * data;\n    list<void *> dataList;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "4139"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_52a()\n{\n    void * data;\n    data = NULL;\n    /* FIX: Set data to point to a char string */\n    data = (void *)CHAR_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_52b_CWE121_Stack_Based_Buffer_Overflow__CWE135_52aSink(data);\n}\n",
        "output": "0",
        "idx": "4050"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_04()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    if(STATIC_CONST_TRUE)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "5225"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_74a()\n{\n    int data;\n    map<int, int> dataMap;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_74aSink(dataMap);\n}\n",
        "output": "0",
        "idx": "2271"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int64_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_42Source(int64_t * data)\n{\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int64_t[50];\n    return data;\n}\n",
        "output": "1",
        "idx": "24151"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "15560"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memmove_67_structType myStruct)\n{\n    int * data = myStruct.structFirst;\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "9586"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_65a()\n{\n    int * data;\n    void (*funcPtr) (int *) = CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_65b_CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_65aSink;\n    data = NULL;\n    /* FIX: Allocate memory using sizeof(int) */\n    data = (int *)ALLOCA(10*sizeof(int));\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "3612"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_68a()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_68aSink();\n}\n",
        "output": "1",
        "idx": "13669"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_63a()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_63aSink(&data);\n}\n",
        "output": "0",
        "idx": "17478"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_72bSink(vector<char *> dataVector)\n{\n    /* copy data out of dataVector */\n    char * data = dataVector[2];\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "7067"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    wchar_t * data = (*dataPtr);\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = wcslen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "21794"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "15558"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_53a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_53aSink_b(data);\n}\n",
        "output": "0",
        "idx": "19867"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_loop_13()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "10836"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_54dSink_d(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "19887"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_66bSink(int * dataArray[])\n{\n    int * data = dataArray[2];\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "9317"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_15()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4857"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_63a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_63aSink(&data);\n}\n",
        "output": "1",
        "idx": "2960"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memmove_45Sink();\n}\n",
        "output": "1",
        "idx": "10335"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_67_structType myStruct)\n{\n    int64_t * data = myStruct.structFirst;\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "8921"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_73bSink(list<char *> dataList)\n{\n    char * data = dataList.back();\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "4279"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "5823"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_53cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "25630"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_68a()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_68aSink();\n}\n",
        "output": "1",
        "idx": "3889"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_21()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_21Static = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_21Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "15506"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_68a()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_68aSink();\n}\n",
        "output": "1",
        "idx": "24867"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_22a()\n{\n    char * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_22aGlobal = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_22aSource(data);\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "21397"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_53cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "26274"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_67_structType myStruct)\n{\n    wchar_t * data = myStruct.structFirst;\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "6128"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_41()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_41_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_41Sink(data);\n}\n",
        "output": "0",
        "idx": "7669"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_connect_socket_53b_CWE114_Process_Control__w32_wchar_t_connect_socket_53bSink(wchar_t * data)\n{\n    CWE114_Process_Control__w32_wchar_t_connect_socket_53c_CWE114_Process_Control__w32_wchar_t_connect_socket_53bSink(data);\n}\n",
        "output": "0",
        "idx": "1068"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_68a()\n{\n    twoIntsStruct * data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_68aSink();\n}\n",
        "output": "1",
        "idx": "10785"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_52a()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_52aSink(data);\n}\n",
        "output": "0",
        "idx": "8880"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_53cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "25952"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memmove_53cSink(data);\n}\n",
        "output": "0",
        "idx": "5964"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_53bSink_b(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "20361"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_41()\n{\n    void * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_41Sink(data);\n}\n",
        "output": "1",
        "idx": "4014"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_17()\n{\n    int h;\n    int * data;\n    data = NULL;\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "3685"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_54dSink_d(TwoIntsClass * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "23547"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_54eSink_e(char * data)\n{\n    {\n        /* The Visual C++ compiler generates a warning if you initialize the class with ().\n         * This will cause the compile to default-initialize the object.\n         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n         */\n        /* FIX: data will at least be the sizeof(OneIntClass) */\n        OneIntClass * classOne = new(data) OneIntClass;\n        /* Initialize and make use of the class */\n        classOne->intOne = 5;\n        printIntLine(classOne->intOne);\n    }\n}\n",
        "output": "0",
        "idx": "17476"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_74a()\n{\n    int data;\n    map<int, int> dataMap;\n    /* Initialize data */\n    data = -1;\n    {\n        char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n        /* POTENTIAL FLAW: Read data from the console using fgets() */\n        if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n        {\n            /* Convert to int */\n            data = atoi(inputBuffer);\n        }\n        else\n        {\n            printLine(\"fgets() failed.\");\n        }\n    }\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "2516"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_72bSink(vector<wchar_t *> dataVector)\n{\n    wchar_t * data = dataVector[2];\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "5605"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_02()\n{\n    int * data;\n    data = NULL;\n    if(1)\n    {\n        /* FLAW: Allocate memory without using sizeof(int) */\n        data = (int *)ALLOCA(10);\n    }\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memmove(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3774"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncpy_03()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(5==5)\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        strncpy(data, source, 100-1);\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "8148"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_17()\n{\n    int i;\n    char * data;\n    data = new char[100];\n    for(i = 0; i < 1; i++)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, strlen(data)*sizeof(char));\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "25894"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_42()\n{\n    int64_t * data;\n    data = NULL;\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_42Source(data);\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "24152"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_41_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_loop_41Sink(char * data)\n{\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "6870"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "5565"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_45()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_45_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_45Sink();\n}\n",
        "output": "0",
        "idx": "9406"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_52bSink(data);\n}\n",
        "output": "0",
        "idx": "15069"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memcpy_15()\n{\n    switch(6)\n    {\n    case 6:\n    {\n        charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));\n        if (structCharVoid == NULL) {exit(-1);}\n        structCharVoid->voidSecond = (void *)SRC_STR;\n        /* Print the initial block pointed to by structCharVoid->voidSecond */\n        printLine((char *)structCharVoid->voidSecond);\n        /* FLAW: Use the sizeof(*structCharVoid) which will overwrite the pointer y */\n        memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));\n        structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n        printLine((char *)structCharVoid->charFirst);\n        printLine((char *)structCharVoid->voidSecond);\n        free(structCharVoid);\n    }\n    break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n}\n",
        "output": "1",
        "idx": "19163"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67a()\n{\n    int data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67_structType myStruct;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67b_CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "2247"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_21()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_loop_21Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        size_t i, dataLen;\n        dataLen = wcslen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "26704"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "4241"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_char_cpy_16()\n{\n    char * data;\n    data = NULL;\n    while(1)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new char[50];\n        data[0] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        strcpy(data, source);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "27824"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_52bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "25622"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_73bSink(list<int *> dataList)\n{\n    /* copy data out of dataList */\n    int * data = dataList.back();\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "24555"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_snprintf_73bSink(list<wchar_t *> dataList)\n{\n    /* copy data out of dataList */\n    wchar_t * data = dataList.back();\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, L\"%s\", source);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "11593"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_16()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    while(1)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        break;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "9115"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_18()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    goto source;\nsource:\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "8854"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67b_CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_67_structType myStruct)\n{\n    int * data = myStruct.structFirst;\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memmove(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "3888"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_34()\n{\n    char * data;\n    unionType myUnion;\n    data = new char[100];\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            memcpy(dest, data, strlen(data)*sizeof(char));\n            dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "25917"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_53cSink(data);\n}\n",
        "output": "0",
        "idx": "5033"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_64b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncat_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    wchar_t * data = (*dataPtr);\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        wcsncat(data, source, 100);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "11304"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_21()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_21Static = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_21Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "27189"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memmove_52bSink(data);\n}\n",
        "output": "0",
        "idx": "15713"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_53dSink(char * data)\n{\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "7561"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_66b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_66bSink(int64_t * dataArray[])\n{\n    int64_t * data = dataArray[2];\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "8785"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_73a()\n{\n    char * data;\n    list<char *> dataList;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n    data = dataGoodBuffer;\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "17726"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_52bSink(data);\n}\n",
        "output": "0",
        "idx": "5291"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_68a()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new TwoIntsClass[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_68_CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_68aSink();\n}\n",
        "output": "0",
        "idx": "23580"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_22a()\n{\n    wchar_t * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_22aGlobal = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_22aSource(data);\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "21559"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_74a()\n{\n    twoIntsStruct * data;\n    map<int, twoIntsStruct *> dataMap;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_74aSink(dataMap);\n}\n",
        "output": "0",
        "idx": "10532"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_54dSink_d(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "26606"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_45()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_45Sink();\n}\n",
        "output": "1",
        "idx": "9138"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_63a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_63aSink(&data);\n}\n",
        "output": "1",
        "idx": "3452"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TwoIntsClass * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_22bSource(TwoIntsClass * data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_22bGlobal)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new TwoIntsClass[50];\n    }\n    return data;\n}\n",
        "output": "1",
        "idx": "23331"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_54dSink_d(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "25157"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_52bSink(data);\n}\n",
        "output": "0",
        "idx": "5690"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_67a()\n{\n    twoIntsStruct * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_67_structType myStruct;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "10249"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_63a()\n{\n    int64_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int64_t[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_63aSink(&data);\n}\n",
        "output": "1",
        "idx": "23881"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_67a()\n{\n    int * data;\n    structType myStruct;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int[50];\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "24541"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_08()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    if(staticReturnsTrue())\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new TwoIntsClass[50];\n    }\n    {\n        TwoIntsClass source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0].intOne);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "23293"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_13()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    if(GLOBAL_CONST_FIVE!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "18255"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_22a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_22_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_22aGlobal = 1; /* true */\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_22_CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_22aSink(data);\n}\n",
        "output": "0",
        "idx": "3105"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_52bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "21919"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_42Source(char * data)\n{\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new char[100];\n    data[0] = '\\0'; /* null terminate */\n    return data;\n}\n",
        "output": "0",
        "idx": "22543"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_17()\n{\n    int i;\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "14213"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_32()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * *dataPtr1 = &data;\n    twoIntsStruct * *dataPtr2 = &data;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    {\n        twoIntsStruct * data = *dataPtr1;\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        *dataPtr1 = data;\n    }\n    {\n        twoIntsStruct * data = *dataPtr2;\n        {\n            twoIntsStruct source[100];\n            {\n                size_t i;\n                /* Initialize array */\n                for (i = 0; i < 100; i++)\n                {\n                    source[i].intOne = 0;\n                    source[i].intTwo = 0;\n                }\n            }\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            memcpy(data, source, 100*sizeof(twoIntsStruct));\n            printStructLine(&data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "10587"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_52bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cat_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "28037"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_42()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_42Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "18777"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_53bSink(data);\n}\n",
        "output": "0",
        "idx": "14431"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_relativePath_17()\n{\n    int i;\n    char * data;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        /* FLAW: Specify just the file name for the library, not the full path */\n        strcpy(data, \"winsrv.dll\");\n    }\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "850"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_21Source(char * data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_21Static)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new char[50];\n        data[0] = '\\0'; /* null terminate */\n    }\n    return data;\n}\n",
        "output": "1",
        "idx": "22839"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_68a()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new int[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_68aSink();\n}\n",
        "output": "1",
        "idx": "24384"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_74bSink(map<int, char *> dataMap)\n{\n    /* copy data out of dataMap */\n    char * data = dataMap[2];\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "22466"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_54cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncpy_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "26443"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "6097"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_53cSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "9023"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_54cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_54cSink_d(data);\n}\n",
        "output": "1",
        "idx": "22901"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_41()\n{\n    char * data;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_41Sink(data);\n}\n",
        "output": "1",
        "idx": "17624"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_67_structType myStruct)\n{\n    wchar_t * data = myStruct.structFirst;\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "6129"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_54d_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_54dSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_54e_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_54dSink(data);\n}\n",
        "output": "0",
        "idx": "13960"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_15()\n{\n    char * data;\n    data = NULL;\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new char[100];\n        data[0] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "22509"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22aGlobal = 1; /* true */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22aSink(data);\n}\n",
        "output": "1",
        "idx": "19801"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_31()\n{\n    char * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new char[50];\n    data[0] = '\\0'; /* null terminate */\n    {\n        char * dataCopy = data;\n        char * data = dataCopy;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n            memcpy(data, source, 100*sizeof(char));\n            data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "22529"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_16()\n{\n    wchar_t * data;\n    data = NULL;\n    while(1)\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new wchar_t[10+1];\n        break;\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "21868"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_53d_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "16478"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_connect_socket_74bSink(map<int, char *> dataMap)\n{\n    /* copy data out of dataMap */\n    char * data = dataMap[2];\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "159"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_06()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new TwoIntsClass[50];\n    }\n    {\n        TwoIntsClass source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(TwoIntsClass));\n        printIntLine(data[0].intOne);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "23609"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_68a()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_68aSink();\n}\n",
        "output": "1",
        "idx": "14152"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE135_73a()\n{\n    void * data;\n    list<void *> dataList;\n    data = NULL;\n    /* FIX: Set data to point to a char string */\n    data = (void *)CHAR_STRING;\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "4140"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22aGlobal = 1; /* true */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_22aSink(data);\n}\n",
        "output": "0",
        "idx": "19804"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_73a()\n{\n    wchar_t * data;\n    list<wchar_t *> dataList;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    wmemset(data, L'A', 50-1); /* fill with L'A's */\n    data[50-1] = L'\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_memcpy_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "15610"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_68a()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_68_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_68b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_68aSink();\n}\n",
        "output": "0",
        "idx": "5466"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_52bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "22080"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_54dSink_d(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memmove_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "21293"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_67a()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_67_structType myStruct;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "7058"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__char_type_overrun_memmove_06()\n{\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));\n            if (structCharVoid == NULL) {exit(-1);}\n            structCharVoid->voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid->voidSecond */\n            printLine((char *)structCharVoid->voidSecond);\n            /* FLAW: Use the sizeof(*structCharVoid) which will overwrite the pointer y */\n            memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));\n            structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n            printLine((char *)structCharVoid->charFirst);\n            printLine((char *)structCharVoid->voidSecond);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "19186"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_52bSink_b(TwoIntsClass * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "23690"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_66a()\n{\n    char * data;\n    char * dataArray[5];\n    data = new char[100];\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_memcpy_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "25987"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_06()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            char inputBuffer[CHAR_ARRAY_SIZE] = \"\";\n            /* POTENTIAL FLAW: Read data from the console using fgets() */\n            if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)\n            {\n                /* Convert to int */\n                data = atoi(inputBuffer);\n            }\n            else\n            {\n                printLine(\"fgets() failed.\");\n            }\n        }\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}\n",
        "output": "1",
        "idx": "2299"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_console_66a()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    {\n        /* Read input from the console */\n        size_t dataLen = strlen(data);\n        /* if there is room in data, read into it from the console */\n        if (100-dataLen > 1)\n        {\n            /* POTENTIAL FLAW: Read data from the console */\n            if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                /* The next few lines remove the carriage return from the string that is\n                 * inserted by fgets() */\n                dataLen = strlen(data);\n                if (dataLen > 0 && data[dataLen-1] == '\\n')\n                {\n                    data[dataLen-1] = '\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgets() failed\");\n                /* Restore NUL terminator if fgets fails */\n                data[dataLen] = '\\0';\n            }\n        }\n    }\n    /* put data in array */\n    dataArray[2] = data;\n    CWE114_Process_Control__w32_char_console_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "298"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_17()\n{\n    int h;\n    TwoIntsClass * data;\n    data = NULL;\n    for(h = 0; h < 1; h++)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new TwoIntsClass[100];\n    }\n    {\n        TwoIntsClass source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(TwoIntsClass));\n        printIntLine(data[0].intOne);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "23641"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_73bSink(list<wchar_t *> dataList)\n{\n    wchar_t * data = dataList.back();\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "25039"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_62bSource(char * &data)\n{\n    /* FIX: Allocate space for a null terminator */\n    data = new char[10+1];\n}\n",
        "output": "0",
        "idx": "20821"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_74a()\n{\n    char * data;\n    map<int, char *> dataMap;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n    data = dataGoodBuffer;\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_74aSink(dataMap);\n}\n",
        "output": "0",
        "idx": "17526"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_67a()\n{\n    int data;\n    structType myStruct;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "20175"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_33()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * &dataRef = data;\n    twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));\n    twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    {\n        twoIntsStruct * data = dataRef;\n        {\n            twoIntsStruct source[100];\n            {\n                size_t i;\n                /* Initialize array */\n                for (i = 0; i < 100; i++)\n                {\n                    source[i].intOne = 0;\n                    source[i].intTwo = 0;\n                }\n            }\n            {\n                size_t i;\n                /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n                for (i = 0; i < 100; i++)\n                {\n                    data[i] = source[i];\n                }\n                printStructLine(&data[0]);\n            }\n        }\n    }\n}\n",
        "output": "1",
        "idx": "10056"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_33()\n{\n    char * data;\n    char * &dataRef = data;\n    data = new char[100];\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    {\n        char * data = dataRef;\n        {\n            char dest[50] = \"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            SNPRINTF(dest, strlen(data), \"%s\", data);\n            printLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "26558"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_52a()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_52aSink(data);\n}\n",
        "output": "1",
        "idx": "3845"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_18()\n{\n    int * data;\n    data = NULL;\n    goto source;\nsource:\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memmove(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3819"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_68bSink()\n{\n    int * data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_68bData;\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "24708"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_54dSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_54dSink(data);\n}\n",
        "output": "0",
        "idx": "8900"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_07()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "10952"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_54dSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_54dSink(data);\n}\n",
        "output": "0",
        "idx": "10762"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memmove_16()\n{\n    wchar_t * data;\n    data = NULL;\n    while(1)\n    {\n        /* FLAW: Did not leave space for a null terminator */\n        data = new wchar_t[10];\n        break;\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "22028"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_45()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_45Sink();\n}\n",
        "output": "1",
        "idx": "9005"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_72a()\n{\n    char * data;\n    vector<char *> dataVector;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_72aSink(dataVector);\n}\n",
        "output": "0",
        "idx": "4273"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_54dSink_d(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "24996"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_03()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    if(5!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n        data = dataGoodBuffer;\n    }\n    if(5==5)\n    {\n        {\n            /* The Visual C++ compiler generates a warning if you initialize the class with ().\n             * This will cause the compile to default-initialize the object.\n             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n             */\n            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n            TwoIntsClass * classTwo = new(data) TwoIntsClass;\n            /* Initialize and make use of the class */\n            classTwo->intOne = 5;\n            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n            printIntLine(classTwo->intOne);\n            /* skip printing classTwo->intTwo since that could be a buffer overread */\n        }\n    }\n}\n",
        "output": "0",
        "idx": "17336"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_53c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_53d_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_53cSink(data);\n}\n",
        "output": "0",
        "idx": "18646"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    {\n        char * data = *dataPtr1;\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char source[10+1] = SRC_STRING;\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            strcpy(data, source);\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "4202"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_67a()\n{\n    int data;\n    structType myStruct;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    myStruct.structFirst = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "19684"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54dSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "9831"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_45()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_loop_45Sink();\n}\n",
        "output": "1",
        "idx": "8872"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_68a()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memmove_68aSink();\n}\n",
        "output": "1",
        "idx": "6662"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_68a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_68aSink();\n}\n",
        "output": "1",
        "idx": "19935"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_66a()\n{\n    int data;\n    int dataArray[5];\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_66b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "2980"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_53d_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_53cSink(data);\n}\n",
        "output": "0",
        "idx": "15238"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_66a()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new wchar_t[10];\n    /* put data in array */\n    dataArray[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_ncpy_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "22283"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_declare_ncat_17()\n{\n    int i;\n    wchar_t * data;\n    wchar_t dataBuffer[100];\n    data = dataBuffer;\n    for(i = 0; i < 1; i++)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        wmemset(data, L'A', 100-1); /* fill with L'A's */\n        data[100-1] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcsncat(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "15823"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_74a()\n{\n    void * data;\n    map<int, void *> dataMap;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "4145"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_21()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_21Static = 1; /* true */\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_21Sink(data);\n}\n",
        "output": "0",
        "idx": "2117"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_45()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_memcpy_45Sink();\n}\n",
        "output": "1",
        "idx": "13610"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_72bSink(vector<char *> dataVector)\n{\n    /* copy data out of dataVector */\n    char * data = dataVector[2];\n    {\n        /* The Visual C++ compiler generates a warning if you initialize the class with ().\n         * This will cause the compile to default-initialize the object.\n         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n         */\n        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n        TwoIntsClass * classTwo = new(data) TwoIntsClass;\n        /* Initialize and make use of the class */\n        classTwo->intOne = 5;\n        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n        printIntLine(classTwo->intOne);\n        /* skip printing classTwo->intTwo since that could be a buffer overread */\n    }\n}\n",
        "output": "1",
        "idx": "17516"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_01()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "5481"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_snprintf_34()\n{\n    wchar_t * data;\n    unionType myUnion;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new wchar_t[100];\n    data[0] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n            SNPRINTF(data, 100, L\"%s\", source);\n            printWLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "25595"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_01()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "9072"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_45Sink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cpy_45Data;\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcscpy(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "18627"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_54dSink_d(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "20625"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_15()\n{\n    wchar_t * data;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n        break;\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "10975"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_54dSink_d(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "21937"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_72a()\n{\n    char * data;\n    vector<char *> dataVector;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_72aSink(dataVector);\n}\n",
        "output": "0",
        "idx": "12547"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_54dSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_54dSink(data);\n}\n",
        "output": "0",
        "idx": "10496"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "12213"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_52b_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_52c_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_52bSink(data);\n}\n",
        "output": "0",
        "idx": "17833"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_45()\n{\n    char * data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_45_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_45Sink();\n}\n",
        "output": "0",
        "idx": "5017"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67a()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67_structType myStruct;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "4264"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_34()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_34_unionType myUnion;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            memmove(data, source, (strlen(source) + 1) * sizeof(char));\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "5270"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_72a()\n{\n    TwoIntsClass * data;\n    vector<TwoIntsClass *> dataVector;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new TwoIntsClass[100];\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_72aSink(dataVector);\n}\n",
        "output": "0",
        "idx": "23584"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "14109"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memmove_14()\n{\n    int64_t * data;\n    int64_t dataBadBuffer[50];\n    int64_t dataGoodBuffer[100];\n    if(globalFive==5)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "9109"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_54b_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_54c_CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_54bSink(data);\n}\n",
        "output": "0",
        "idx": "17847"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_44()\n{\n    wchar_t * data;\n    void (*funcPtr) (wchar_t *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_44Sink;\n    data = NULL;\n    /* FIX: Allocate space for a null terminator */\n    data = new wchar_t[10+1];\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "21747"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_22a()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_22aGlobal = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cpy_22aSource(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        strcpy(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "18275"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_54cSink(data);\n}\n",
        "output": "0",
        "idx": "8100"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_02()\n{\n    char * data;\n    data = NULL;\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new char[100];\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "22310"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_04()\n{\n    char * data;\n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Did not leave space for a null terminator */\n        data = new char[10];\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strncpy(data, source, strlen(source) + 1);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "21349"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_17()\n{\n    int i,j;\n    void * data;\n    data = NULL;\n    for(i = 0; i < 1; i++)\n    {\n        /* POTENTIAL FLAW: Set data to point to a wide string */\n        data = (void *)WIDE_STRING;\n    }\n    for(j = 0; j < 1; j++)\n    {\n        {\n            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n            size_t dataLen = strlen((char *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy(dest, data);\n            printLine((char *)dest);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "3979"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_45Sink()\n{\n    wchar_t * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_ncpy_45Data;\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcsncpy(data, source, wcslen(source) + 1);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "6078"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_18()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    goto source;\nsource:\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    goto sink;\nsink:\n    {\n        int i;\n        int buffer[10] = { 0 };\n        /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n        * This code does check to see if the array index is negative */\n        if (data >= 0)\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is negative.\");\n        }\n    }\n}\n",
        "output": "0",
        "idx": "2109"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_54a()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memmove_54aSink(data);\n}\n",
        "output": "1",
        "idx": "3859"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54d_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54e_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_54dSink(data);\n}\n",
        "output": "0",
        "idx": "18495"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_15()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    switch(5)\n    {\n    case 6:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        break;\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "8448"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_53cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "21122"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_74a()\n{\n    char * data;\n    map<int, char *> dataMap;\n    data = NULL;\n    /* FIX: Allocate space for a null terminator */\n    data = new char[10+1];\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_74aSink(dataMap);\n}\n",
        "output": "0",
        "idx": "20855"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_14()\n{\n    char * data;\n    data = NULL;\n    if(globalFive==5)\n    {\n        /* FLAW: Did not leave space for a null terminator */\n        data = new char[10];\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (strlen(source) + 1) * sizeof(char));\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "21056"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_cpy_02()\n{\n    wchar_t * data;\n    data = NULL;\n    if(1)\n    {\n        /* FLAW: Did not leave space for a null terminator */\n        data = new wchar_t[10];\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "21504"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_34()\n{\n    wchar_t * data;\n    unionType myUnion;\n    data = NULL;\n    /* FLAW: Did not leave space for a null terminator */\n    data = new wchar_t[10];\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n            printWLine(data);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "1",
        "idx": "21891"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_67_structType myStruct)\n{\n    wchar_t * data = myStruct.structFirst;\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "14633"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_65a()\n{\n    TwoIntsClass * data;\n    /* define a function pointer */\n    void (*funcPtr) (TwoIntsClass *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_65aSink;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new TwoIntsClass[50];\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "23728"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_72a()\n{\n    void * data;\n    vector<void *> dataVector;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "4133"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_67a()\n{\n    char * data;\n    structType myStruct;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n    data = dataBadBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "17501"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_34()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memcpy_34_unionType myUnion;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t dest[50] = L\"\";\n            /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n            memcpy(dest, data, wcslen(data)*sizeof(wchar_t));\n            dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "14557"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_cpy_66bSink(wchar_t * dataArray[])\n{\n    /* copy data out of dataArray */\n    wchar_t * data = dataArray[2];\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        wcscpy(data, source);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "5592"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_68a()\n{\n    int64_t * data;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_68aSink();\n}\n",
        "output": "1",
        "idx": "8524"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_54dSink_d(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_memcpy_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "21132"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_relativePath_54d_CWE114_Process_Control__w32_char_relativePath_54dSink(char * data)\n{\n    CWE114_Process_Control__w32_char_relativePath_54e_CWE114_Process_Control__w32_char_relativePath_54dSink(data);\n}\n",
        "output": "0",
        "idx": "919"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_02()\n{\n    char * data;\n    data = NULL;\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate space for a null terminator */\n        data = new char[10+1];\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        strcpy(data, source);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "20700"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_loop_61bSource(char * data)\n{\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new char[50];\n    data[0] = '\\0'; /* null terminate */\n    return data;\n}\n",
        "output": "1",
        "idx": "22426"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_03()\n{\n    wchar_t * data;\n    data = NULL;\n    if(5==5)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new wchar_t[100];\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */\n        wcsncat(data, source, 100);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "25212"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_21()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_21Static = 1; /* true */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fscanf_21Sink(data);\n}\n",
        "output": "1",
        "idx": "19794"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_74bSink(map<int, wchar_t *> dataMap)\n{\n    wchar_t * data = dataMap[2];\n    {\n        size_t i;\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "24882"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_52b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_52bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_52c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_52bSink(data);\n}\n",
        "output": "0",
        "idx": "13298"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_34()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_34_unionType myUnion;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "6468"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_loop_02()\n{\n    int * data;\n    data = NULL;\n    if(1)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int[100];\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "24243"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_54cSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memmove_54cSink(data);\n}\n",
        "output": "0",
        "idx": "10760"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_32()\n{\n    int * data;\n    int * *dataPtr1 = &data;\n    int * *dataPtr2 = &data;\n    data = NULL;\n    {\n        int * data = *dataPtr1;\n        /* FIX: Allocate memory using sizeof(int) */\n        data = (int *)ALLOCA(10*sizeof(int));\n        *dataPtr1 = data;\n    }\n    {\n        int * data = *dataPtr2;\n        {\n            int source[10] = {0};\n            /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n            memcpy(data, source, 10*sizeof(int));\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "3691"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_66a()\n{\n    char * data;\n    char * dataArray[5];\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_66b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_cpy_66aSink(dataArray);\n}\n",
        "output": "0",
        "idx": "4926"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_memcpy_73bSink(list<wchar_t *> dataList)\n{\n    /* copy data out of dataList */\n    wchar_t * data = dataList.back();\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "21979"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_52bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "25783"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_73bSink(list<wchar_t *> dataList)\n{\n    wchar_t * data = dataList.back();\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "11062"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char * CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_22_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_22bSource(char * data)\n{\n    if(CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_22_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_22bGlobal)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    return data;\n}\n",
        "output": "0",
        "idx": "12456"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_61a()\n{\n    int64_t * data;\n    data = NULL;\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_61aSource(data);\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "23874"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_45Sink()\n{\n    int * data = CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_45Data;\n    {\n        int source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0]);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "9270"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_67a()\n{\n    twoIntsStruct * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_67_structType myStruct;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "10515"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_51a()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_51aSink(data);\n}\n",
        "output": "0",
        "idx": "17436"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_src_char_cat_13()\n{\n    char * data;\n    data = new char[100];\n    if(GLOBAL_CONST_FIVE==5)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "28298"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54a()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54aSink(data);\n}\n",
        "output": "1",
        "idx": "9292"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_memmove_54cSink(data);\n}\n",
        "output": "0",
        "idx": "11957"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_53b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_53bSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_53bSink(data);\n}\n",
        "output": "0",
        "idx": "9420"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_file_52b_CWE114_Process_Control__w32_char_file_52bSink(char * data)\n{\n    CWE114_Process_Control__w32_char_file_52c_CWE114_Process_Control__w32_char_file_52bSink(data);\n}\n",
        "output": "0",
        "idx": "579"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_67a()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_67_structType myStruct;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_67b_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_memcpy_67aSink(myStruct);\n}\n",
        "output": "0",
        "idx": "4531"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_74a()\n{\n    int data;\n    map<int, int> dataMap;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_74aSink(dataMap);\n}\n",
        "output": "0",
        "idx": "3502"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_62bSource(char * &data)\n{\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n}\n",
        "output": "0",
        "idx": "12521"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_connect_socket_21()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    CWE114_Process_Control__w32_wchar_t_connect_socket_21Static = 1; /* true */\n    data = CWE114_Process_Control__w32_wchar_t_connect_socket_21Source(data);\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryW(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "1",
        "idx": "1016"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_memmove_53cSink(data);\n}\n",
        "output": "0",
        "idx": "5299"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_52bSink(twoIntsStruct * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_loop_52bSink(data);\n}\n",
        "output": "1",
        "idx": "10078"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_file_67a()\n{\n    wchar_t * data;\n    CWE114_Process_Control__w32_wchar_t_file_67_structType myStruct;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        /* Read input from a file */\n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    /* Restore NUL terminator if fgetws fails */\n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    myStruct.structFirst = data;\n    CWE114_Process_Control__w32_wchar_t_file_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "1590"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_char_declare_cat_18()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    goto source;\nsource:\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    memset(data, 'A', 100-1); /* fill with 'A's */\n    data[100-1] = '\\0'; /* null terminate */\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "18106"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_63a()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_63aSink(&data);\n}\n",
        "output": "1",
        "idx": "3736"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_72a()\n{\n    int data;\n    vector<int> dataVector;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_72aSink(dataVector);\n}\n",
        "output": "0",
        "idx": "2259"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_74bSink(map<int, char *> dataMap)\n{\n    char * data = dataMap[2];\n    {\n        /* The Visual C++ compiler generates a warning if you initialize the class with ().\n         * This will cause the compile to default-initialize the object.\n         * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n         */\n        /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n        TwoIntsClass * classTwo = new(data) TwoIntsClass;\n        /* Initialize and make use of the class */\n        classTwo->intOne = 5;\n        classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n        printIntLine(classTwo->intOne);\n        /* skip printing classTwo->intTwo since that could be a buffer overread */\n    }\n}\n",
        "output": "0",
        "idx": "17529"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_67_structType myStruct)\n{\n    int * data = myStruct.structFirst;\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3754"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54b_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54c_CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_memmove_54bSink(data);\n}\n",
        "output": "0",
        "idx": "14761"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_54cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_54cSink(data);\n}\n",
        "output": "0",
        "idx": "8366"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_53cSink_c(int64_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memcpy_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "24020"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_34()\n{\n    char * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_34_unionType myUnion;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n     * string copies in the sinks  */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        char * data = myUnion.unionSecond;\n        {\n            char source[10+1] = SRC_STRING;\n            size_t i, sourceLen;\n            sourceLen = strlen(source);\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            for (i = 0; i < sourceLen + 1; i++)\n            {\n                data[i] = source[i];\n            }\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "5004"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_53cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "20800"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_53cSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_53cSink(data);\n}\n",
        "output": "0",
        "idx": "8358"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__src_char_alloca_cat_02()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    if(0)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n        memset(data, 'A', 50-1); /* fill with 'A's */\n        data[50-1] = '\\0'; /* null terminate */\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-strlen(dest)*/\n        strcat(dest, data);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "17740"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54bSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_declare_memcpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "9827"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__char_type_overrun_memcpy_01()\n{\n    {\n        charVoid structCharVoid;\n        structCharVoid.voidSecond = (void *)SRC_STR;\n        /* Print the initial block pointed to by structCharVoid.voidSecond */\n        printLine((char *)structCharVoid.voidSecond);\n        /* FLAW: Use the sizeof(structCharVoid) which will overwrite the pointer voidSecond */\n        memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));\n        structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\\0'; /* null terminate the string */\n        printLine((char *)structCharVoid.charFirst);\n        printLine((char *)structCharVoid.voidSecond);\n    }\n}\n",
        "output": "1",
        "idx": "1932"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_64a()\n{\n    int * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_64aSink(&data);\n}\n",
        "output": "0",
        "idx": "24530"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_54bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncat_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "27246"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_51a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_51aSink(data);\n}\n",
        "output": "1",
        "idx": "2906"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_53cSink_c(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_wchar_t_loop_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "21766"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_53bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_loop_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "24823"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_relativePath_72a()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    /* FLAW: Specify just the file name for the library, not the full path */\n    wcscpy(data, L\"winsrv.dll\");\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE114_Process_Control__w32_wchar_t_relativePath_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "1920"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_33()\n{\n    char * data;\n    char * &dataRef = data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    data[0] = '\\0'; /* null terminate */\n    {\n        char * data = dataRef;\n        {\n            char source[100];\n            memset(source, 'C', 100-1); /* fill with 'C's */\n            source[100-1] = '\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n            strcat(data, source);\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "16314"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    int * * dataPtr = (int * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    int * data = (*dataPtr);\n    {\n        int source[10] = {0};\n        size_t i;\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        for (i = 0; i < 10; i++)\n        {\n            data[i] = source[i];\n        }\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3609"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__placement_new_alloca_02()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(sizeof(OneIntClass));\n    char * dataGoodBuffer = (char *)ALLOCA(sizeof(TwoIntsClass));\n    if(1)\n    {\n        /* POTENTIAL FLAW: Initialize data to a buffer smaller than the sizeof(TwoIntsClass) */\n        data = dataBadBuffer;\n    }\n    if(1)\n    {\n        {\n            /* The Visual C++ compiler generates a warning if you initialize the class with ().\n             * This will cause the compile to default-initialize the object.\n             * See http://msdn.microsoft.com/en-us/library/wewb47ee%28v=VS.100%29.aspx\n             */\n            /* POTENTIAL FLAW: data may not be large enough to hold a TwoIntsClass */\n            TwoIntsClass * classTwo = new(data) TwoIntsClass;\n            /* Initialize and make use of the class */\n            classTwo->intOne = 5;\n            classTwo->intTwo = 10; /* POTENTIAL FLAW: If sizeof(data) < sizeof(TwoIntsClass) then this line will be a buffer overflow */\n            printIntLine(classTwo->intOne);\n            /* skip printing classTwo->intTwo since that could be a buffer overread */\n        }\n    }\n}\n",
        "output": "1",
        "idx": "17328"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_54dSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_memcpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "5841"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_loop_54cSink(data);\n}\n",
        "output": "0",
        "idx": "11691"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_loop_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    {\n        char * data = *dataPtr1;\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char source[10+1] = SRC_STRING;\n            size_t i, sourceLen;\n            sourceLen = strlen(source);\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            for (i = 0; i < sourceLen + 1; i++)\n            {\n                data[i] = source[i];\n            }\n            printLine(data);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "5000"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_53c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_53cSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_53d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_53cSink(data);\n}\n",
        "output": "0",
        "idx": "8757"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_memcpy_66bSink(int * dataArray[])\n{\n    /* copy data out of dataArray */\n    int * data = dataArray[2];\n    {\n        int source[10] = {0};\n        /* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */\n        memcpy(data, source, 10*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "3750"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_21()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    goodG2bStatic = 1; /* true */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_21Sink(data);\n}\n",
        "output": "0",
        "idx": "19554"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_66bSink(char * dataArray[])\n{\n    /* copy data out of dataArray */\n    char * data = dataArray[2];\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "26632"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_console_66a()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        /* Read input from the console */\n        size_t dataLen = wcslen(data);\n        /* if there is room in data, read into it from the console */\n        if (100-dataLen > 1)\n        {\n            /* POTENTIAL FLAW: Read data from the console */\n            if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)\n            {\n                /* The next few lines remove the carriage return from the string that is\n                 * inserted by fgetws() */\n                dataLen = wcslen(data);\n                if (dataLen > 0 && data[dataLen-1] == L'\\n')\n                {\n                    data[dataLen-1] = L'\\0';\n                }\n            }\n            else\n            {\n                printLine(\"fgetws() failed\");\n                /* Restore NUL terminator if fgetws fails */\n                data[dataLen] = L'\\0';\n            }\n        }\n    }\n    /* put data in array */\n    dataArray[2] = data;\n    CWE114_Process_Control__w32_wchar_t_console_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "1264"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_06()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n         * access an index of the array in the sink that is out-of-bounds */\n        data = 7;\n    }\n    if(STATIC_CONST_FIVE==5)\n    {\n        {\n            int i;\n            int buffer[10] = { 0 };\n            /* POTENTIAL FLAW: Attempt to write to an index of the array that is above the upper bound\n            * This code does check to see if the array index is negative */\n            if (data >= 0)\n            {\n                buffer[data] = 1;\n                /* Print the array values */\n                for(i = 0; i < 10; i++)\n                {\n                    printIntLine(buffer[i]);\n                }\n            }\n            else\n            {\n                printLine(\"ERROR: Array index is negative.\");\n            }\n        }\n    }\n}\n",
        "output": "0",
        "idx": "2057"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_68a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_68aSink();\n}\n",
        "output": "0",
        "idx": "19690"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_52bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_snprintf_52bSink_c(data);\n}\n",
        "output": "1",
        "idx": "23207"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_snprintf_16()\n{\n    char * data;\n    char dataBuffer[100];\n    data = dataBuffer;\n    while(1)\n    {\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        memset(data, 'A', 100-1); /* fill with 'A's */\n        data[100-1] = '\\0'; /* null terminate */\n        break;\n    }\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "14211"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67_structType myStruct)\n{\n    int64_t * data = myStruct.structFirst;\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "8788"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_52b_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_52c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_52bSink(data);\n}\n",
        "output": "0",
        "idx": "11143"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memmove_03()\n{\n    int * data;\n    data = NULL;\n    if(5==5)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new int[50];\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "24566"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_73a()\n{\n    twoIntsStruct * data;\n    list<twoIntsStruct *> dataList;\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_memcpy_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "10660"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_54cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_ncpy_54cSink(data);\n}\n",
        "output": "0",
        "idx": "11425"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_72bSink(vector<wchar_t *> dataVector)\n{\n    wchar_t * data = dataVector[2];\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "15286"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_73a()\n{\n    int64_t * data;\n    list<int64_t *> dataList;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "8533"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_68a()\n{\n    int * data;\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_68aSink();\n}\n",
        "output": "1",
        "idx": "3623"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_65a()\n{\n    wchar_t * data;\n    /* define a function pointer */\n    void (*funcPtr) (wchar_t *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_65aSink;\n    data = new wchar_t[100];\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    /* use the function pointer */\n    funcPtr(data);\n}\n",
        "output": "1",
        "idx": "26948"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_72a()\n{\n    int64_t * data;\n    vector<int64_t *> dataVector;\n    int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));\n    int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memcpy_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "8661"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_53bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "27399"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memmove_18()\n{\n    wchar_t * data;\n    data = NULL;\n    goto source;\nsource:\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new wchar_t[100];\n    data[0] = L'\\0'; /* null terminate */\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        memmove(data, source, 100*sizeof(wchar_t));\n        data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "25092"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_64a()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new TwoIntsClass[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_64aSink(&data);\n}\n",
        "output": "0",
        "idx": "23725"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_52b_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_52bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_52c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_loop_52bSink(data);\n}\n",
        "output": "0",
        "idx": "6355"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_21()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_21Static = 0; /* false */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_21Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        wcsncpy(dest, data, wcslen(data));\n        dest[50-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "15025"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_41()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_41_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_loop_41Sink(data);\n}\n",
        "output": "0",
        "idx": "12469"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_21()\n{\n    char * data;\n    char * dataBuffer = (char *)ALLOCA(100*sizeof(char));\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_21Static = 0; /* false */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_21Source(data);\n    {\n        char dest[50] = \"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, strlen(data), \"%s\", data);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "13254"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_connect_socket_73bSink(list<char *> dataList)\n{\n    char * data = dataList.back();\n    {\n        HMODULE hModule;\n        /* POTENTIAL FLAW: If the path to the library is not specified, an attacker may be able to\n         * replace his own file with the intended library */\n        hModule = LoadLibraryA(data);\n        if (hModule != NULL)\n        {\n            FreeLibrary(hModule);\n            printLine(\"Library loaded and freed successfully\");\n        }\n        else\n        {\n            printLine(\"Unable to load library\");\n        }\n    }\n}\n",
        "output": "0",
        "idx": "156"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_45()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_45_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cpy_45Sink();\n}\n",
        "output": "0",
        "idx": "16728"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_68a()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = '\\0'; /* null terminate */\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_68_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_68b_CWE121_Stack_Based_Buffer_Overflow__dest_char_declare_cat_68aSink();\n}\n",
        "output": "0",
        "idx": "16645"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_05()\n{\n    wchar_t * data;\n    data = NULL;\n    if(staticFalse)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new wchar_t[100];\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */\n        wcsncat(data, source, 100);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "25217"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_54bSink_b(int data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "19389"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_relativePath_72a()\n{\n    char * data;\n    vector<char *> dataVector;\n    char dataBuffer[100] = \"\";\n    data = dataBuffer;\n    /* FLAW: Specify just the file name for the library, not the full path */\n    strcpy(data, \"winsrv.dll\");\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE114_Process_Control__w32_char_relativePath_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "954"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_53c_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_53cSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_53d_CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_alloca_loop_53cSink(data);\n}\n",
        "output": "0",
        "idx": "5698"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_rand_15()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    switch(6)\n    {\n    case 6:\n        /* POTENTIAL FLAW: Set data to a random value */\n        data = RAND32();\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    switch(8)\n    {\n    case 7:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    default:\n    {\n        int i;\n        int * buffer = new int[10];\n        /* initialize buffer */\n        for (i = 0; i < 10; i++)\n        {\n            buffer[i] = 0;\n        }\n        /* FIX: Properly validate the array index and prevent a buffer overflow */\n        if (data >= 0 && data < (10))\n        {\n            buffer[data] = 1;\n            /* Print the array values */\n            for(i = 0; i < 10; i++)\n            {\n                printIntLine(buffer[i]);\n            }\n        }\n        else\n        {\n            printLine(\"ERROR: Array index is out-of-bounds\");\n        }\n        delete[] buffer;\n    }\n    break;\n    }\n}\n",
        "output": "0",
        "idx": "20518"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static TwoIntsClass * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_21Source(TwoIntsClass * data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_21Static)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new TwoIntsClass[100];\n    }\n    return data;\n}\n",
        "output": "0",
        "idx": "23326"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_54dSink_d(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncpy_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "23064"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_alloca_memcpy_73bSink(list<twoIntsStruct *> dataList)\n{\n    /* copy data out of dataList */\n    twoIntsStruct * data = dataList.back();\n    {\n        twoIntsStruct source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(twoIntsStruct));\n        printStructLine(&data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "10263"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_loop_06()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(STATIC_CONST_FIVE==5)\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        size_t i;\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        for (i = 0; i < 100; i++)\n        {\n            data[i] = source[i];\n        }\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "7623"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_alloca_cat_64bSink(void * dataVoidPtr)\n{\n    /* cast void pointer to a pointer of the appropriate type */\n    wchar_t * * dataPtr = (wchar_t * *)dataVoidPtr;\n    /* dereference dataPtr into data */\n    wchar_t * data = (*dataPtr);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than sizeof(dest)-wcslen(dest)*/\n        wcscat(dest, data);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "18512"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_45()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new TwoIntsClass[50];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memmove_45Sink();\n}\n",
        "output": "1",
        "idx": "23681"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_74a()\n{\n    TwoIntsClass * data;\n    map<int, TwoIntsClass *> dataMap;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new TwoIntsClass[50];\n    /* Put data in a map */\n    dataMap[0] = data;\n    dataMap[1] = data;\n    dataMap[2] = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_74aSink(dataMap);\n}\n",
        "output": "1",
        "idx": "23591"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54dSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_declare_memcpy_54dSink(data);\n}\n",
        "output": "0",
        "idx": "9033"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_char_relativePath_52b_CWE114_Process_Control__w32_char_relativePath_52bSink(char * data)\n{\n    CWE114_Process_Control__w32_char_relativePath_52c_CWE114_Process_Control__w32_char_relativePath_52bSink(data);\n}\n",
        "output": "0",
        "idx": "901"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_66a()\n{\n    int * data;\n    int * dataArray[5];\n    data = NULL;\n    /* FLAW: Allocate memory without using sizeof(int) */\n    data = (int *)ALLOCA(10);\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "3615"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_52a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* FIX: Use a value greater than 0, but less than 10 to avoid attempting to\n     * access an index of the array in the sink that is out-of-bounds */\n    data = 7;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_52b_CWE121_Stack_Based_Buffer_Overflow__CWE129_large_52aSink(data);\n}\n",
        "output": "0",
        "idx": "2913"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_41()\n{\n    char * data;\n    data = new char[100];\n    /* FIX: Initialize data as a small buffer that as small or smaller than the small buffer used in the sink */\n    memset(data, 'A', 50-1); /* fill with 'A's */\n    data[50-1] = '\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_ncat_41Sink(data);\n}\n",
        "output": "0",
        "idx": "26243"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_15()\n{\n    int * data;\n    int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));\n    int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        int source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memcpy(data, source, 100*sizeof(int));\n        printIntLine(data[0]);\n    }\n}\n",
        "output": "1",
        "idx": "9378"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_snprintf_15()\n{\n    wchar_t * data;\n    data = new wchar_t[100];\n    switch(6)\n    {\n    case 6:\n        /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n        wmemset(data, L'A', 100-1); /* fill with L'A's */\n        data[100-1] = L'\\0'; /* null terminate */\n        break;\n    default:\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n        break;\n    }\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "27499"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_21()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_21Static = 0; /* false */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_21Source(data);\n    {\n        TwoIntsClass source[100];\n        {\n            size_t i;\n            /* Initialize array */\n            for (i = 0; i < 100; i++)\n            {\n                source[i].intOne = 0;\n                source[i].intTwo = 0;\n            }\n        }\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printIntLine(data[0].intOne);\n            delete [] data;\n        }\n    }\n    ;\n}\n",
        "output": "0",
        "idx": "23325"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_72a()\n{\n    wchar_t * data;\n    vector<wchar_t *> dataVector;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new wchar_t[100];\n    data[0] = L'\\0'; /* null terminate */\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_memcpy_72aSink(dataVector);\n}\n",
        "output": "0",
        "idx": "25033"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_68a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Read data from the console using fscanf() */\n    fscanf(stdin, \"%d\", &data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_68aData = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_fscanf_68aSink();\n}\n",
        "output": "1",
        "idx": "2744"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_16()\n{\n    void * data;\n    data = NULL;\n    while(1)\n    {\n        /* POTENTIAL FLAW: Set data to point to a wide string */\n        data = (void *)WIDE_STRING;\n        break;\n    }\n    while(1)\n    {\n        {\n            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */\n            size_t dataLen = strlen((char *)data);\n            void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));\n            (void)wcscpy(dest, data);\n            printLine((char *)dest);\n        }\n        break;\n    }\n}\n",
        "output": "1",
        "idx": "3976"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_52a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_large_52aSink_b(data);\n}\n",
        "output": "1",
        "idx": "20103"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_snprintf_12()\n{\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));\n    if(globalReturnsTrueOrFalse())\n    {\n        /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n         * buffer in various memory copying functions using a \"large\" source buffer. */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        SNPRINTF(data, 100, \"%s\", source);\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "7508"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_66a()\n{\n    int data;\n    int dataArray[5];\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "3470"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_04()\n{\n    char * data;\n    data = NULL;\n    if(STATIC_CONST_TRUE)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new char[50];\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than sizeof(data)-strlen(data) */\n        strncat(data, source, 100);\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "1",
        "idx": "22798"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE135_22a()\n{\n    void * data;\n    data = NULL;\n    /* POTENTIAL FLAW: Set data to point to a wide string */\n    data = (void *)WIDE_STRING;\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_22aGlobal = 1; /* true */\n    CWE121_Stack_Based_Buffer_Overflow__CWE135_22aSink(data);\n}\n",
        "output": "1",
        "idx": "3993"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_ncat_07()\n{\n    char * data;\n    char dataBadBuffer[50];\n    char dataGoodBuffer[100];\n    if(staticFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the sizeof(data)-strlen(data) is less than the length of source */\n        strncat(data, source, 100);\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "8026"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54dSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54e_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_loop_54dSink(data);\n}\n",
        "output": "0",
        "idx": "9299"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static TwoIntsClass * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_21Source(TwoIntsClass * data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_memcpy_21Static)\n    {\n        /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n        data = new TwoIntsClass[50];\n    }\n    return data;\n}\n",
        "output": "1",
        "idx": "23483"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_54b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_54bSink(int * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int_alloca_memcpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "9428"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_53bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_cpy_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "20798"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_54dSink_d(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_ncpy_54dSink_e(data);\n}\n",
        "output": "1",
        "idx": "27411"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_21()\n{\n    wchar_t * data;\n    data = NULL;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_21Static = 1; /* true */\n    data = CWE122_Heap_Based_Buffer_Overflow__cpp_dest_wchar_t_cpy_21Source(data);\n    {\n        wchar_t source[100];\n        wmemset(source, L'C', 100-1); /* fill with L'C's */\n        source[100-1] = L'\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if source is larger than data */\n        wcscpy(data, source);\n        printWLine(data);\n        delete [] data;\n    }\n    ;\n}\n",
        "output": "1",
        "idx": "28153"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_54a()\n{\n    int data;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Set data to a random value */\n    data = RAND32();\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_54b_CWE121_Stack_Based_Buffer_Overflow__CWE129_rand_54aSink(data);\n}\n",
        "output": "0",
        "idx": "3427"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_45()\n{\n    char * data;\n    char dataBadBuffer[sizeof(OneIntClass)];\n    char dataGoodBuffer[sizeof(TwoIntsClass)];\n    /* FIX: Initialize to a buffer at least the sizeof(TwoIntsClass) */\n    data = dataGoodBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_45Data = data;\n    CWE121_Stack_Based_Buffer_Overflow__placement_new_declare_45Sink();\n}\n",
        "output": "0",
        "idx": "17638"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_65a()\n{\n    char * data;\n    void (*funcPtr) (char *) = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_65aSink;\n    data = NULL;\n    /* FIX: Allocate space for a null terminator */\n    data = new char[10+1];\n    funcPtr(data);\n}\n",
        "output": "0",
        "idx": "21475"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__wchar_t_type_overrun_memmove_03()\n{\n    if(5==5)\n    {\n        {\n            charVoid structCharVoid;\n            structCharVoid.voidSecond = (void *)SRC_STR;\n            /* Print the initial block pointed to by structCharVoid.voidSecond */\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n            /* FLAW: Use the sizeof(structCharVoid) which will overwrite the pointer voidSecond */\n            memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));\n            structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\\0'; /* null terminate the string */\n            printWLine((wchar_t *)structCharVoid.charFirst);\n            printWLine((wchar_t *)structCharVoid.voidSecond);\n        }\n    }\n}\n",
        "output": "1",
        "idx": "19079"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_21()\n{\n    wchar_t * data;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_21Static = 1; /* true */\n    data = CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_snprintf_21Source(data);\n    {\n        wchar_t dest[50] = L\"\";\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        SNPRINTF(dest, wcslen(data), L\"%s\", data);\n        printWLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "15184"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int64_t * CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_21Source(int64_t * data)\n{\n    if(CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_memmove_21Static)\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int64_t[100];\n    }\n    return data;\n}\n",
        "output": "0",
        "idx": "24131"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_68a()\n{\n    wchar_t * data;\n    data = NULL;\n    /* FLAW: Allocate using new[] and point data to a small buffer that is smaller than the large buffer used in the sinks */\n    data = new wchar_t[50];\n    data[0] = L'\\0'; /* null terminate */\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_wchar_t_ncat_68aSink();\n}\n",
        "output": "1",
        "idx": "25350"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_68a()\n{\n    int * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new int[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_68_CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_68aData = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int_memcpy_68aSink();\n}\n",
        "output": "0",
        "idx": "24546"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_char_alloca_memcpy_72bSink(vector<char *> dataVector)\n{\n    char * data = dataVector[2];\n    {\n        char source[100];\n        memset(source, 'C', 100-1); /* fill with 'C's */\n        source[100-1] = '\\0'; /* null terminate */\n        /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n        memcpy(data, source, 100*sizeof(char));\n        data[100-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "7068"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_54b_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_54bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_54c_CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cpy_54bSink(data);\n}\n",
        "output": "0",
        "idx": "16484"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_53b_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_53bSink(wchar_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_53c_CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_53bSink(data);\n}\n",
        "output": "0",
        "idx": "18805"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_17()\n{\n    int i;\n    char * data;\n    char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));\n    char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));\n    for(i = 0; i < 1; i++)\n    {\n        /* FLAW: Set a pointer to a buffer that does not leave room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataBadBuffer;\n        data[0] = '\\0'; /* null terminate */\n    }\n    {\n        char source[10+1] = SRC_STRING;\n        size_t i, sourceLen;\n        sourceLen = strlen(source);\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        for (i = 0; i < sourceLen + 1; i++)\n        {\n            data[i] = source[i];\n        }\n        printLine(data);\n    }\n}\n",
        "output": "1",
        "idx": "4329"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE129_large_72a()\n{\n    int data;\n    vector<int> dataVector;\n    /* Initialize data */\n    data = -1;\n    /* POTENTIAL FLAW: Use an invalid index */\n    data = 10;\n    /* Put data in a vector */\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    dataVector.insert(dataVector.end(), 1, data);\n    CWE121_Stack_Based_Buffer_Overflow__CWE129_large_72aSink(dataVector);\n}\n",
        "output": "1",
        "idx": "2996"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_45()\n{\n    TwoIntsClass * data;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new TwoIntsClass[100];\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_45Data = data;\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_class_loop_45Sink();\n}\n",
        "output": "0",
        "idx": "23361"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67b_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67bSink(CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_memmove_67_structType myStruct)\n{\n    int64_t * data = myStruct.structFirst;\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n        memmove(data, source, 100*sizeof(int64_t));\n        printLongLongLine(data[0]);\n    }\n}\n",
        "output": "0",
        "idx": "8789"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_66a()\n{\n    twoIntsStruct * data;\n    twoIntsStruct * dataArray[5];\n    twoIntsStruct dataBadBuffer[50];\n    twoIntsStruct dataGoodBuffer[100];\n    /* FLAW: Set a pointer to a \"small\" buffer. This buffer will be used in the sinks as a destination\n     * buffer in various memory copying functions using a \"large\" source buffer. */\n    data = dataBadBuffer;\n    /* put data in array */\n    dataArray[2] = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_66aSink(dataArray);\n}\n",
        "output": "1",
        "idx": "10511"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_54bSink_b(wchar_t * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_wchar_t_memcpy_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "26924"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_char_declare_ncpy_32()\n{\n    char * data;\n    char * *dataPtr1 = &data;\n    char * *dataPtr2 = &data;\n    char dataBadBuffer[10];\n    char dataGoodBuffer[10+1];\n    {\n        char * data = *dataPtr1;\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = '\\0'; /* null terminate */\n        *dataPtr1 = data;\n    }\n    {\n        char * data = *dataPtr2;\n        {\n            char source[10+1] = SRC_STRING;\n            /* Copy length + 1 to include NUL terminator from source */\n            /* POTENTIAL FLAW: data may not have enough space to hold source */\n            strncpy(data, source, strlen(source) + 1);\n            printLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "5400"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_53b_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_53bSink(char * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_53c_CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_snprintf_53bSink(data);\n}\n",
        "output": "0",
        "idx": "13304"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_54bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE193_char_ncpy_54bSink_c(data);\n}\n",
        "output": "1",
        "idx": "21450"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_53cSink_c(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_snprintf_53cSink_d(data);\n}\n",
        "output": "1",
        "idx": "26596"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_73a()\n{\n    char * data;\n    list<char *> dataList;\n    data = NULL;\n    /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n    data = new char[100];\n    data[0] = '\\0'; /* null terminate */\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_ncat_73aSink(dataList);\n}\n",
        "output": "0",
        "idx": "22944"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_memcpy_10()\n{\n    wchar_t * data;\n    wchar_t dataBadBuffer[10];\n    wchar_t dataGoodBuffer[10+1];\n    if(globalTrue)\n    {\n        /* FIX: Set a pointer to a buffer that leaves room for a NULL terminator when performing\n         * string copies in the sinks  */\n        data = dataGoodBuffer;\n        data[0] = L'\\0'; /* null terminate */\n    }\n    {\n        wchar_t source[10+1] = SRC_STRING;\n        /* Copy length + 1 to include NUL terminator from source */\n        /* POTENTIAL FLAW: data may not have enough space to hold source */\n        memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));\n        printWLine(data);\n    }\n}\n",
        "output": "0",
        "idx": "6440"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE114_Process_Control__w32_wchar_t_file_73a()\n{\n    wchar_t * data;\n    list<wchar_t *> dataList;\n    wchar_t dataBuffer[100] = L\"\";\n    data = dataBuffer;\n    {\n        /* Read input from a file */\n        size_t dataLen = wcslen(data);\n        FILE * pFile;\n        /* if there is room in data, attempt to read the input from a file */\n        if (100-dataLen > 1)\n        {\n            pFile = fopen(FILENAME, \"r\");\n            if (pFile != NULL)\n            {\n                /* POTENTIAL FLAW: Read data from a file */\n                if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)\n                {\n                    printLine(\"fgetws() failed\");\n                    /* Restore NUL terminator if fgetws fails */\n                    data[dataLen] = L'\\0';\n                }\n                fclose(pFile);\n            }\n        }\n    }\n    /* Put data in a list */\n    dataList.push_back(data);\n    dataList.push_back(data);\n    dataList.push_back(data);\n    CWE114_Process_Control__w32_wchar_t_file_73aSink(dataList);\n}\n",
        "output": "1",
        "idx": "1602"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_53bSink_b(char * data)\n{\n    CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_char_memcpy_53bSink_c(data);\n}\n",
        "output": "1",
        "idx": "22569"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_67a()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_67_structType myStruct;\n    wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    data = dataBuffer;\n    /* FLAW: Initialize data as a large buffer that is larger than the small buffer used in the sink */\n    wmemset(data, L'A', 100-1); /* fill with L'A's */\n    data[100-1] = L'\\0'; /* null terminate */\n    myStruct.structFirst = data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_67aSink(myStruct);\n}\n",
        "output": "1",
        "idx": "14953"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE805_int64_t_loop_04()\n{\n    int64_t * data;\n    data = NULL;\n    if(STATIC_CONST_FALSE)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Allocate using new[] and point data to a large buffer that is at least as large as the large buffer used in the sink */\n        data = new int64_t[100];\n    }\n    {\n        int64_t source[100] = {0}; /* fill with 0's */\n        {\n            size_t i;\n            /* POTENTIAL FLAW: Possible buffer overflow if data < 100 */\n            for (i = 0; i < 100; i++)\n            {\n                data[i] = source[i];\n            }\n            printLongLongLine(data[0]);\n            delete [] data;\n        }\n    }\n}\n",
        "output": "0",
        "idx": "23765"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE122_Heap_Based_Buffer_Overflow__cpp_CWE806_char_loop_73bSink(list<char *> dataList)\n{\n    char * data = dataList.back();\n    {\n        char dest[50] = \"\";\n        size_t i, dataLen;\n        dataLen = strlen(data);\n        /* POTENTIAL FLAW: Possible buffer overflow if data is larger than dest */\n        for (i = 0; i < dataLen; i++)\n        {\n            dest[i] = data[i];\n        }\n        dest[50-1] = '\\0'; /* Ensure the destination buffer is null terminated */\n        printLine(data);\n        delete [] data;\n    }\n}\n",
        "output": "0",
        "idx": "25844"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_34()\n{\n    wchar_t * data;\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_34_unionType myUnion;\n    wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));\n    wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));\n    /* FIX: Set a pointer to a \"large\" buffer, thus avoiding buffer overflows in the sinks. */\n    data = dataGoodBuffer;\n    data[0] = L'\\0'; /* null terminate */\n    myUnion.unionFirst = data;\n    {\n        wchar_t * data = myUnion.unionSecond;\n        {\n            wchar_t source[100];\n            wmemset(source, L'C', 100-1); /* fill with L'C's */\n            source[100-1] = L'\\0'; /* null terminate */\n            /* POTENTIAL FLAW: Possible buffer overflow if the size of data is less than the length of source */\n            memcpy(data, source, 100*sizeof(wchar_t));\n            data[100-1] = L'\\0'; /* Ensure the destination buffer is null terminated */\n            printWLine(data);\n        }\n    }\n}\n",
        "output": "0",
        "idx": "10990"
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54c_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54cSink(int64_t * data)\n{\n    CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54d_CWE121_Stack_Based_Buffer_Overflow__CWE805_int64_t_alloca_loop_54cSink(data);\n}\n",
        "output": "0",
        "idx": "8499"
    }
]