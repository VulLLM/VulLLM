[
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void get_sem_elements(struct sem_data *p)\n{\n\tsize_t i;\n\n\tif (!p || !p->sem_nsems || p->sem_nsems > SIZE_MAX || p->sem_perm.id < 0)\n\t\treturn;\n\n\tp->elements = xcalloc(p->sem_nsems, sizeof(struct sem_elem));\n\n\tfor (i = 0; i < p->sem_nsems; i++) {\n\t\tstruct sem_elem *e = &p->elements[i];\n\t\tunion semun arg = { .val = 0 };\n\n\t\te->semval = semctl(p->sem_perm.id, i, GETVAL, arg);\n\t\tif (e->semval < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETVAL)\");\n\n\t\te->ncount = semctl(p->sem_perm.id, i, GETNCNT, arg);\n\t\tif (e->ncount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETNCNT)\");\n\n\t\te->zcount = semctl(p->sem_perm.id, i, GETZCNT, arg);\n\t\tif (e->zcount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETZCNT)\");\n\n\t\te->pid = semctl(p->sem_perm.id, i, GETPID, arg);\n\t\tif (e->pid < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETPID)\");\n\t}\n}",
        "output": "0",
        "idx": 6519
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "monitor_sync(struct monitor *pmonitor)\n{\n\tif (options.compression) {\n\t\tmm_share_sync(&pmonitor->m_zlib, &pmonitor->m_zback);\n\t}\n}",
        "output": "1",
        "idx": 5570
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_swevent_event(struct perf_event *event, u64 nr,\n\t\t\t       int nmi, struct perf_sample_data *data,\n\t\t\t       struct pt_regs *regs)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tlocal64_add(nr, &event->count);\n\n\tif (!regs)\n\t\treturn;\n\n\tif (!is_sampling_event(event))\n\t\treturn;\n\n\tif (nr == 1 && hwc->sample_period == 1 && !event->attr.freq)\n\t\treturn perf_swevent_overflow(event, 1, nmi, data, regs);\n\n\tif (local64_add_negative(nr, &hwc->period_left))\n\t\treturn;\n\n\tperf_swevent_overflow(event, 0, nmi, data, regs);\n}",
        "output": "1",
        "idx": 536
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_Duplicate(cJSON *item,int recurse)\n{\n\tcJSON *newitem,*cptr,*nptr=0,*newchild;\n\tif (!item) return 0;\n\tnewitem=cJSON_New_Item();\n\tif (!newitem) return 0;\n\tnewitem->type=item->type&(~cJSON_IsReference),newitem->valueint=item->valueint,newitem->valuedouble=item->valuedouble;\n\tif (item->valuestring)\t{newitem->valuestring=cJSON_strdup(item->valuestring);\tif (!newitem->valuestring)\t{cJSON_Delete(newitem);return 0;}}\n\tif (item->string)\t\t{newitem->string=cJSON_strdup(item->string);\t\t\tif (!newitem->string)\t\t{cJSON_Delete(newitem);return 0;}}\n\tif (!recurse) return newitem;\n\tcptr=item->child;\n\twhile (cptr)\n\t{\n\t\tnewchild=cJSON_Duplicate(cptr,1);\t\t\n\t\tif (!newchild) {cJSON_Delete(newitem);return 0;}\n\t\tif (nptr)\t{nptr->next=newchild,newchild->prev=nptr;nptr=newchild;}\t\n\t\telse\t\t{newitem->child=newchild;nptr=newchild;}\t\t\t\t\t\n\t\tcptr=cptr->next;\n\t}\n\treturn newitem;\n}",
        "output": "0",
        "idx": 8301
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int key_notify_sa_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\n\tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_satype = pfkey_proto2satype(c->data.proto);\n\thdr->sadb_msg_type = SADB_FLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 3269
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void arch_dup_mmap(struct mm_struct *oldmm,\n\t\t\t\t struct mm_struct *mm)\n{\n\tif (oldmm->context.asce_limit < mm->context.asce_limit)\n\t\tcrst_table_downgrade(mm, oldmm->context.asce_limit);\n}",
        "output": "1",
        "idx": 1138
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ptrace_hbptriggered(struct perf_event *bp,\n\t\t\t\t     struct perf_sample_data *data,\n\t\t\t\t     struct pt_regs *regs)\n{\n\tstruct arch_hw_breakpoint *bkpt = counter_arch_bp(bp);\n\tlong num;\n\tint i;\n\tsiginfo_t info;\n\n\tfor (i = 0; i < ARM_MAX_HBP_SLOTS; ++i)\n\t\tif (current->thread.debug.hbp[i] == bp)\n\t\t\tbreak;\n\n\tnum = (i == ARM_MAX_HBP_SLOTS) ? 0 : ptrace_hbp_idx_to_num(i);\n\n\tinfo.si_signo\t= SIGTRAP;\n\tinfo.si_errno\t= (int)num;\n\tinfo.si_code\t= TRAP_HWBKPT;\n\tinfo.si_addr\t= (void __user *)(bkpt->trigger);\n\n\tforce_sig_info(SIGTRAP, &info, current);\n}",
        "output": "0",
        "idx": 579
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "num_stmts(const node *n)\n{\n    int i, l;\n    node *ch;\n\n    switch (TYPE(n)) {\n        case single_input:\n            if (TYPE(CHILD(n, 0)) == NEWLINE)\n                return 0;\n            else\n                return num_stmts(CHILD(n, 0));\n        case file_input:\n            l = 0;\n            for (i = 0; i < NCH(n); i++) {\n                ch = CHILD(n, i);\n                if (TYPE(ch) == stmt)\n                    l += num_stmts(ch);\n            }\n            return l;\n        case stmt:\n            return num_stmts(CHILD(n, 0));\n        case compound_stmt:\n            return 1;\n        case simple_stmt:\n            return NCH(n) / 2; \n        case suite:\n            if (NCH(n) == 1)\n                return num_stmts(CHILD(n, 0));\n            else {\n                i = 2;\n                l = 0;\n                if (TYPE(CHILD(n, 1)) == TYPE_COMMENT)\n                    i += 2;\n                for (; i < (NCH(n) - 1); i++)\n                    l += num_stmts(CHILD(n, i));\n                return l;\n            }\n        default: {\n            char buf[128];\n\n            sprintf(buf, \"Non-statement found: %d %d\",\n                    TYPE(n), NCH(n));\n            Py_FatalError(buf);\n        }\n    }\n    assert(0);\n    return 0;\n}",
        "output": "1",
        "idx": 7750
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int pmd_present(pmd_t pmd)\n{\n\treturn pmd_flags(pmd) & (_PAGE_PRESENT | _PAGE_PROTNONE | _PAGE_PSE);\n}",
        "output": "0",
        "idx": 1069
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(locale_get_display_name) \n{\n    get_icu_disp_value_src_php( DISP_NAME , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}",
        "output": "1",
        "idx": 3876
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int _yr_re_is_word_char(\n    uint8_t* input,\n    int character_size)\n{\n  int result = ((isalnum(*input) || (*input) == '_'));\n\n  if (character_size == 2)\n    result = result && (*(input + 1) == 0);\n\n  return result;\n}",
        "output": "0",
        "idx": 7863
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rfbReleaseClientIterator(rfbClientIteratorPtr iterator)\n{\n  if(iterator && iterator->next) rfbDecrClientRef(iterator->next);\n  free(iterator);\n}",
        "output": "0",
        "idx": 8937
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC void httpSetCredentials(HttpConn *conn, cchar *username, cchar *password, cchar *authType)\n{\n    char    *ptok;\n\n    httpResetCredentials(conn);\n    if (password == NULL && strchr(username, ':') != 0) {\n        conn->username = ssplit(sclone(username), \":\", &ptok);\n        conn->password = sclone(ptok);\n    } else {\n        conn->username = sclone(username);\n        conn->password = sclone(password);\n    }\n    if (authType) {\n        conn->authType = sclone(authType);\n    }\n}",
        "output": "0",
        "idx": 7007
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spawn_child()\n{\n        pid_t pid;\n        sigset_t newset;\n        sigset_t oldset;\n\n        sigemptyset(&newset);\n        sigaddset(&newset, SIGCHLD);\n        sigaddset(&newset, SIGTERM);\n        sigprocmask(SIG_BLOCK, &newset, &oldset);\n        pid = fork();\n        if (pid < 0) {\n                msg(LOG_ERR, \"Could not fork (%s)\", strerror(errno));\n                goto out;\n        }\n        if (pid > 0) { \n                pid_t *pidp;\n\n                pidp = g_malloc(sizeof(pid_t));\n                *pidp = pid;\n                g_hash_table_insert(children, pidp, pidp);\n                goto out;\n        }\n        signal(SIGCHLD, SIG_DFL);\n        signal(SIGTERM, SIG_DFL);\n        signal(SIGHUP, SIG_DFL);\nout:\n        sigprocmask(SIG_SETMASK, &oldset, NULL);\n        return pid;\n}",
        "output": "0",
        "idx": 4715
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mem_resize(jas_stream_memobj_t *m, size_t bufsize)\n{\n\tunsigned char *buf;\n\n\n\tJAS_DBGLOG(100, (\"mem_resize(%p, %zu)\\n\", m, bufsize));\n\tif (!bufsize) {\n\t\tjas_eprintf(\n\t\t  \"mem_resize was not really designed to handle a buffer of size 0\\n\"\n\t\t  \"This may not work.\\n\"\n\t\t);\n\t}\n\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n\t  bufsize) {\n\t\tJAS_DBGLOG(100, (\"mem_resize realloc failed\\n\"));\n\t\treturn -1;\n\t}\n\tJAS_DBGLOG(100, (\"mem_resize realloc succeeded\\n\"));\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}",
        "output": "0",
        "idx": 7527
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char* _multi_string_alloc_and_copy( LPCWSTR in )\n{\n    char *chr;\n    int len = 0;\n\n    if ( !in )\n    {\n        return in;\n    }\n\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;\n    }\n\n    chr = malloc( len + 2 );\n\n    len = 0;\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        chr[ len ] = 0xFF & in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = '\\0';\n    chr[ len ++ ] = '\\0';\n\n    return chr;\n}",
        "output": "1",
        "idx": 7324
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "createenv(const struct rule *rule)\n{\n\tstruct env *env;\n\tu_int i;\n\n\tenv = malloc(sizeof(*env));\n\tif (!env)\n\t\terr(1, NULL);\n\tRB_INIT(&env->root);\n\tenv->count = 0;\n\n\tif (rule->options & KEEPENV) {\n\t\textern char **environ;\n\n\t\tfor (i = 0; environ[i] != NULL; i++) {\n\t\t\tstruct envnode *node;\n\t\t\tconst char *e, *eq;\n\t\t\tsize_t len;\n\t\t\tchar keybuf[1024];\n\n\t\t\te = environ[i];\n\n\t\t\tif ((eq = strchr(e, '=')) == NULL || eq == e)\n\t\t\t\tcontinue;\n\t\t\tlen = eq - e;\n\t\t\tif (len > sizeof(keybuf) - 1)\n\t\t\t\tcontinue;\n\t\t\tmemcpy(keybuf, e, len);\n\t\t\tkeybuf[len] = '\\0';\n\n\t\t\tnode = createnode(keybuf, eq + 1);\n\t\t\tif (RB_INSERT(envtree, &env->root, node)) {\n\t\t\t\tfreenode(node);\n\t\t\t} else {\n\t\t\t\tenv->count++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn env;\n}",
        "output": "1",
        "idx": 7838
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct ipv6_txoptions *txopt_get(const struct ipv6_pinfo *np)\n{\n\tstruct ipv6_txoptions *opt;\n\n\trcu_read_lock();\n\topt = rcu_dereference(np->opt);\n\tif (opt && !atomic_inc_not_zero(&opt->refcnt))\n\t\topt = NULL;\n\trcu_read_unlock();\n\treturn opt;\n}",
        "output": "0",
        "idx": 1387
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __ip_select_ident(struct net *net, struct iphdr *iph, int segs)\n{\n\tu32 hash, id;\n\n\tif (unlikely(siphash_key_is_zero(&net->ipv4.ip_id_key)))\n\t\tget_random_bytes(&net->ipv4.ip_id_key,\n\t\t\t\t sizeof(net->ipv4.ip_id_key));\n\n\thash = siphash_3u32((__force u32)iph->daddr,\n\t\t\t    (__force u32)iph->saddr,\n\t\t\t    iph->protocol,\n\t\t\t    &net->ipv4.ip_id_key);\n\tid = ip_idents_reserve(hash, segs);\n\tiph->id = htons(id);\n}",
        "output": "0",
        "idx": 4297
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int regexec(Reprog *prog, const char *sp, Resub *sub, int eflags)\n{\n\tResub scratch;\n\tint i;\n\n\tif (!sub)\n\t\tsub = &scratch;\n\n\tsub->nsub = prog->nsub;\n\tfor (i = 0; i < MAXSUB; ++i)\n\t\tsub->sub[i].sp = sub->sub[i].ep = NULL;\n\n\treturn !match(prog->start, sp, sp, prog->flags | eflags, sub);\n}",
        "output": "1",
        "idx": 7420
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __u8 *pl_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 60 && rdesc[39] == 0x2a && rdesc[40] == 0xf5 &&\n\t\t\trdesc[41] == 0x00 && rdesc[59] == 0x26 &&\n\t\t\trdesc[60] == 0xf9 && rdesc[61] == 0x00) {\n\t\thid_info(hdev, \"fixing up Petalynx Maxter Remote report descriptor\\n\");\n\t\trdesc[60] = 0xfa;\n\t\trdesc[40] = 0xfa;\n\t}\n\treturn rdesc;\n}",
        "output": "1",
        "idx": 2652
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int may_ptrace_stop(void)\n{\n\tif (!likely(current->ptrace))\n\t\treturn 0;\n\tif (unlikely(current->mm->core_state) &&\n\t    unlikely(current->mm == current->parent->mm))\n\t\treturn 0;\n\n\treturn 1;\n}",
        "output": "0",
        "idx": 1137
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_visual_text(\n    cmdarg_T\t*cap,\n    char_u\t**pp,\t    \n    int\t\t*lenp)\t    \n{\n    if (VIsual_mode != 'V')\n\tunadjust_for_sel();\n    if (VIsual.lnum != curwin->w_cursor.lnum)\n    {\n\tif (cap != NULL)\n\t    clearopbeep(cap->oap);\n\treturn FAIL;\n    }\n    if (VIsual_mode == 'V')\n    {\n\t*pp = ml_get_curline();\n\t*lenp = (int)STRLEN(*pp);\n    }\n    else\n    {\n\tif (LT_POS(curwin->w_cursor, VIsual))\n\t{\n\t    *pp = ml_get_pos(&curwin->w_cursor);\n\t    *lenp = VIsual.col - curwin->w_cursor.col + 1;\n\t}\n\telse\n\t{\n\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (has_mbyte)\n\t    *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}",
        "output": "1",
        "idx": 5694
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void txopt_put(struct ipv6_txoptions *opt)\n{\n\tif (opt && atomic_dec_and_test(&opt->refcnt))\n\t\tkfree_rcu(opt, rcu);\n}",
        "output": "0",
        "idx": 1385
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "tok_new(void)\n{\n    struct tok_state *tok = (struct tok_state *)PyMem_MALLOC(\n                                            sizeof(struct tok_state));\n    if (tok == NULL)\n        return NULL;\n    tok->buf = tok->cur = tok->end = tok->inp = tok->start = NULL;\n    tok->done = E_OK;\n    tok->fp = NULL;\n    tok->input = NULL;\n    tok->tabsize = TABSIZE;\n    tok->indent = 0;\n    tok->indstack[0] = 0;\n\n    tok->atbol = 1;\n    tok->pendin = 0;\n    tok->prompt = tok->nextprompt = NULL;\n    tok->lineno = 0;\n    tok->level = 0;\n    tok->altwarning = 1;\n    tok->alterror = 1;\n    tok->alttabsize = 1;\n    tok->altindstack[0] = 0;\n    tok->decoding_state = STATE_INIT;\n    tok->decoding_erred = 0;\n    tok->read_coding_spec = 0;\n    tok->enc = NULL;\n    tok->encoding = NULL;\n    tok->cont_line = 0;\n#ifndef PGEN\n    tok->filename = NULL;\n    tok->decoding_readline = NULL;\n    tok->decoding_buffer = NULL;\n#endif\n\n    tok->async_def = 0;\n    tok->async_def_indent = 0;\n    tok->async_def_nl = 0;\n\n    return tok;\n}",
        "output": "1",
        "idx": 7666
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "chunk_grow(chunk_t *chunk, size_t sz)\n{\n  off_t offset;\n  size_t memlen_orig = chunk->memlen;\n  tor_assert(sz > chunk->memlen);\n  offset = chunk->data - chunk->mem;\n  chunk = tor_realloc(chunk, CHUNK_ALLOC_SIZE(sz));\n  chunk->memlen = sz;\n  chunk->data = chunk->mem + offset;\n#ifdef DEBUG_CHUNK_ALLOC\n  tor_assert(chunk->DBG_alloc == CHUNK_ALLOC_SIZE(memlen_orig));\n  chunk->DBG_alloc = CHUNK_ALLOC_SIZE(sz);\n#endif\n  total_bytes_allocated_in_chunks +=\n    CHUNK_ALLOC_SIZE(sz) - CHUNK_ALLOC_SIZE(memlen_orig);\n  return chunk;\n}",
        "output": "1",
        "idx": 6064
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ip_options_get(struct net *net, struct ip_options_rcu **optp,\n\t\t   unsigned char *data, int optlen)\n{\n\tstruct ip_options_rcu *opt = ip_options_get_alloc(optlen);\n\n\tif (!opt)\n\t\treturn -ENOMEM;\n\tif (optlen)\n\t\tmemcpy(opt->opt.__data, data, optlen);\n\treturn ip_options_get_finish(net, optp, opt, optlen);\n}",
        "output": "0",
        "idx": 493
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(void *) gdImageGifPtr(gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tif (!_gdImageGifCtx(im, out)) {\n\t\trv = gdDPExtractData(out, size);\n\t} else {\n\t\trv = NULL;\n\t}\n\tout->gd_free(out);\n\treturn rv;\n}",
        "output": "0",
        "idx": 6219
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void my_free(void *ptr)\n{\n    free_called = 1;\n    free(ptr);\n}",
        "output": "0",
        "idx": 6003
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n\t\t       gss_ctx_id_t context_handle,\n\t\t       gss_buffer_t input_message_buffer,\n\t\t       gss_buffer_t input_assoc_buffer,\n\t\t       gss_buffer_t output_payload_buffer,\n\t\t       int *conf_state,\n\t\t       gss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_aead(minor_status,\n\t\t\t      context_handle,\n\t\t\t      input_message_buffer,\n\t\t\t      input_assoc_buffer,\n\t\t\t      output_payload_buffer,\n\t\t\t      conf_state,\n\t\t\t      qop_state);\n\treturn (ret);\n}",
        "output": "1",
        "idx": 102
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "__be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\n{\n\tstruct in6_addr buf[2];\n\tstruct in6_addr *addrs;\n\tu32 id;\n\n\taddrs = skb_header_pointer(skb,\n\t\t\t\t   skb_network_offset(skb) +\n\t\t\t\t   offsetof(struct ipv6hdr, saddr),\n\t\t\t\t   sizeof(buf), buf);\n\tif (!addrs)\n\t\treturn 0;\n\n\tid = __ipv6_select_ident(net, &addrs[1], &addrs[0]);\n\treturn htonl(id);\n}",
        "output": "0",
        "idx": 4303
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, numEntries);\n    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n\n    FreeStmt((ParseCommon *) &append);\n\n    return expr;\n}",
        "output": "1",
        "idx": 7000
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "u32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2, s32 idx3)\n{\n\tu32 val=0, code;\n\ts32 nb_lead = -1;\n\tu32 bits = 0;\n\tfor (code=0; !code; nb_lead++) {\n\t\tif (nb_lead>=32) {\n\t\t\tif (!gf_bs_available(bs)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] exp-golomb read failed, not enough bits in bitstream !\\n\"));\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\\n\", nb_lead));\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tcode = gf_bs_read_int(bs, 1);\n\t\tbits++;\n\t}\n\n\tif (nb_lead) {\n\t\tval = gf_bs_read_int(bs, nb_lead);\n\t\tval += (1 << nb_lead) - 1;\n\t\tbits += nb_lead;\n\t}\n\n\tif (fname) {\n\t\tgf_bs_log_idx(bs, bits, fname, val, idx1, idx2, idx3);\n\t}\n\treturn val;\n}",
        "output": "1",
        "idx": 6898
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patlen, OnigOptionType options, OnigEncoding enc, OnigSyntaxType *syntax TSRMLS_DC)\n{\n\tint err_code = 0;\n\tint found = 0;\n\tphp_mb_regex_t *retval = NULL, **rc = NULL;\n\tOnigErrorInfo err_info;\n\tOnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];\n\n\tfound = zend_hash_find(&MBREX(ht_rc), (char *)pattern, patlen+1, (void **) &rc);\n\tif (found == FAILURE || (*rc)->options != options || (*rc)->enc != enc || (*rc)->syntax != syntax) {\n\t\tif ((err_code = onig_new(&retval, (OnigUChar *)pattern, (OnigUChar *)(pattern + patlen), options, enc, syntax, &err_info)) != ONIG_NORMAL) {\n\t\t\tonig_error_code_to_str(err_str, err_code, err_info);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"mbregex compile err: %s\", err_str);\n\t\t\tretval = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tzend_hash_update(&MBREX(ht_rc), (char *) pattern, patlen + 1, (void *) &retval, sizeof(retval), NULL);\n\t} else if (found == SUCCESS) {\n\t\tretval = *rc;\n\t}\nout:\n\treturn retval; \n}",
        "output": "1",
        "idx": 4044
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void show_object(struct object *obj,\n\t\t\tstruct strbuf *path, const char *component,\n\t\t\tvoid *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tfinish_object(obj, path, component, cb_data);\n\tif (info->flags & REV_LIST_QUIET)\n\t\treturn;\n\tshow_object_with_name(stdout, obj, path, component);\n}",
        "output": "1",
        "idx": 5190
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_process_context_token(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\t\tconst gss_buffer_t token_buffer)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (!sc->opened)\n\t\treturn (GSS_S_DEFECTIVE_TOKEN);\n\n\tret = gss_process_context_token(minor_status,\n\t\t\t\t\tsc->ctx_handle,\n\t\t\t\t\ttoken_buffer);\n\n\treturn (ret);\n}",
        "output": "0",
        "idx": 97
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int AES_decrypt_DH(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen) {\n\n    if (!message) {\n        LOG_ERROR(\"Null message in AES_encrypt_DH\");\n        return -1;\n    }\n\n    if (!encr_message) {\n        LOG_ERROR(\"Null encr message in AES_encrypt_DH\");\n        return -2;\n    }\n\n\n    if (length < SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE) {\n        LOG_ERROR(\"length < SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE\");\n        return -1;\n    }\n\n\n\n    uint64_t len = length - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE;\n\n    if (msgLen < len) {\n        LOG_ERROR(\"Output buffer not large enough\");\n        return -2;\n    }\n\n    sgx_status_t status = sgx_rijndael128GCM_decrypt(&AES_DH_key,\n                                                     encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE, len,\n                                                     (unsigned char*) message,\n                                                     encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,\n                                                     NULL, 0,\n                                                     (sgx_aes_gcm_128bit_tag_t *)encr_message);\n\n    return status;\n}",
        "output": "1",
        "idx": 8698
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static EjsAny *app_env(Ejs *ejs, EjsObj *app, int argc, EjsObj **argv)\n{\n#if VXWORKS\n    return ESV(null);\n#else\n    EjsPot  *result;\n    char        **ep, *pair, *key, *value;\n\n    result = ejsCreatePot(ejs, ESV(Object), 0);\n    for (ep = environ; ep && *ep; ep++) {\n        pair = sclone(*ep);\n        key = ssplit(pair, \"=\", &value);\n        ejsSetPropertyByName(ejs, result, EN(key), ejsCreateStringFromAsc(ejs, value));\n    }\n    return result;\n#endif\n}",
        "output": "0",
        "idx": 6939
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xfs_attr_calc_size(\n\tstruct xfs_inode \t*ip,\n\tint\t\t\tnamelen,\n\tint\t\t\tvaluelen,\n\tint\t\t\t*local)\n{\n\tstruct xfs_mount \t*mp = ip->i_mount;\n\tint\t\t\tsize;\n\tint\t\t\tnblks;\n\n\tsize = xfs_attr_leaf_newentsize(namelen, valuelen,\n\t\t\t\t\tmp->m_sb.sb_blocksize, local);\n\n\tnblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);\n\tif (*local) {\n\t\tif (size > (mp->m_sb.sb_blocksize >> 1)) {\n\t\t\tnblks *= 2;\n\t\t}\n\t} else {\n\t\tuint\tdblocks = xfs_attr3_rmt_blocks(mp, valuelen);\n\t\tnblks += dblocks;\n\t\tnblks += XFS_NEXTENTADD_SPACE_RES(mp, dblocks, XFS_ATTR_FORK);\n\t}\n\n\treturn nblks;\n}",
        "output": "0",
        "idx": 3515
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PredictorDecodeRow(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)\n{\n\tTIFFPredictorState *sp = PredictorState(tif);\n\n\tassert(sp != NULL);\n\tassert(sp->decoderow != NULL);\n\tassert(sp->decodepfunc != NULL);  \n\n\tif ((*sp->decoderow)(tif, op0, occ0, s)) {\n\t\t(*sp->decodepfunc)(tif, op0, occ0);\n\t\treturn 1;\n\t} else\n\t\treturn 0;\n}",
        "output": "1",
        "idx": 4286
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_framing_cap_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_ASYNC_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_SYNC_MASK) {\n\t\tND_PRINT((ndo, \"S\"));\n\t}\n}",
        "output": "0",
        "idx": 6671
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\tsecurity_key_free(key);\n\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\n\t\tkey_user_put(key->user);\n\n\t\tif (key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\n\t\tkfree(key->description);\n\n#ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}",
        "output": "1",
        "idx": 2748
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static pfunc check_literal(struct jv_parser* p) {\n  if (p->tokenpos == 0) return 0;\n\n  const char* pattern = 0;\n  int plen;\n  jv v;\n  switch (p->tokenbuf[0]) {\n  case 't': pattern = \"true\"; plen = 4; v = jv_true(); break;\n  case 'f': pattern = \"false\"; plen = 5; v = jv_false(); break;\n  case 'n': pattern = \"null\"; plen = 4; v = jv_null(); break;\n  }\n  if (pattern) {\n    if (p->tokenpos != plen) return \"Invalid literal\";\n    for (int i=0; i<plen; i++)\n      if (p->tokenbuf[i] != pattern[i])\n        return \"Invalid literal\";\n    TRY(value(p, v));\n  } else {\n    p->tokenbuf[p->tokenpos] = 0; \n    char* end = 0;\n    double d = jvp_strtod(&p->dtoa, p->tokenbuf, &end);\n    if (end == 0 || *end != 0)\n      return \"Invalid numeric literal\";\n    TRY(value(p, jv_number(d)));\n  }\n  p->tokenpos = 0;\n  return 0;\n}",
        "output": "1",
        "idx": 5502
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void voutf(struct GlobalConfig *config,\n                  const char *prefix,\n                  const char *fmt,\n                  va_list ap)\n{\n  size_t width = (79 - strlen(prefix));\n  if(!config->mute) {\n    size_t len;\n    char *ptr;\n    char *print_buffer;\n\n    print_buffer = curlx_mvaprintf(fmt, ap);\n    if(!print_buffer)\n      return;\n    len = strlen(print_buffer);\n\n    ptr = print_buffer;\n    while(len > 0) {\n      fputs(prefix, config->errors);\n\n      if(len > width) {\n        size_t cut = width-1;\n\n        while(!ISSPACE(ptr[cut]) && cut) {\n          cut--;\n        }\n        if(0 == cut)\n          cut = width-1;\n\n        (void)fwrite(ptr, cut + 1, 1, config->errors);\n        fputs(\"\\n\", config->errors);\n        ptr += cut + 1; \n        len -= cut + 1;\n      }\n      else {\n        fputs(ptr, config->errors);\n        len = 0;\n      }\n    }\n    curl_free(print_buffer);\n  }\n}",
        "output": "0",
        "idx": 8469
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "asmlinkage long sys_oabi_semtimedop(int semid,\n\t\t\t\t    struct oabi_sembuf __user *tsops,\n\t\t\t\t    unsigned nsops,\n\t\t\t\t    const struct timespec __user *timeout)\n{\n\tstruct sembuf *sops;\n\tstruct timespec local_timeout;\n\tlong err;\n\tint i;\n\n\tif (nsops < 1 || nsops > SEMOPM)\n\t\treturn -EINVAL;\n\tsops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);\n\tif (!sops)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tfor (i = 0; i < nsops; i++) {\n\t\t__get_user_error(sops[i].sem_num, &tsops->sem_num, err);\n\t\t__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);\n\t\t__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);\n\t\ttsops++;\n\t}\n\tif (timeout) {\n\t\terr |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));\n\t\ttimeout = &local_timeout;\n\t}\n\tif (err) {\n\t\terr = -EFAULT;\n\t} else {\n\t\tmm_segment_t fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = sys_semtimedop(semid, sops, nsops, timeout);\n\t\tset_fs(fs);\n\t}\n\tkfree(sops);\n\treturn err;\n}",
        "output": "0",
        "idx": 523
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init pf_init(void)\n{\t\t\t\t\n\tstruct pf_unit *pf;\n\tint unit;\n\n\tif (disable)\n\t\treturn -EINVAL;\n\n\tpf_init_units();\n\n\tif (pf_detect())\n\t\treturn -ENODEV;\n\tpf_busy = 0;\n\n\tif (register_blkdev(major, name)) {\n\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\t\tif (!pf->disk)\n\t\t\t\tcontinue;\n\t\t\tblk_cleanup_queue(pf->disk->queue);\n\t\t\tblk_mq_free_tag_set(&pf->tag_set);\n\t\t\tput_disk(pf->disk);\n\t\t}\n\t\treturn -EBUSY;\n\t}\n\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tstruct gendisk *disk = pf->disk;\n\n\t\tif (!pf->present)\n\t\t\tcontinue;\n\t\tdisk->private_data = pf;\n\t\tadd_disk(disk);\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 4313
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t aio_setup_single_vector(int type, struct file * file, struct kiocb *kiocb)\n{\n\tint bytes;\n\n\tbytes = rw_verify_area(type, file, &kiocb->ki_pos, kiocb->ki_left);\n\tif (bytes < 0)\n\t\treturn bytes;\n\n\tkiocb->ki_iovec = &kiocb->ki_inline_vec;\n\tkiocb->ki_iovec->iov_base = kiocb->ki_buf;\n\tkiocb->ki_iovec->iov_len = bytes;\n\tkiocb->ki_nr_segs = 1;\n\tkiocb->ki_cur_seg = 0;\n\treturn 0;\n}",
        "output": "0",
        "idx": 943
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void spl_filesystem_info_set_filename(spl_filesystem_object *intern, char *path, int len, int use_copy TSRMLS_DC) \n{\n\tchar *p1, *p2;\n\t\n\tif (intern->file_name) {\n\t\tefree(intern->file_name);\n\t}\n\n\tintern->file_name = use_copy ? estrndup(path, len) : path;\n\tintern->file_name_len = len;\n\n\twhile(IS_SLASH_AT(intern->file_name, intern->file_name_len-1) && intern->file_name_len > 1) {\n\t\tintern->file_name[intern->file_name_len-1] = 0;\n\t\tintern->file_name_len--;\n\t}\n\n\tp1 = strrchr(intern->file_name, '/');\n#if defined(PHP_WIN32) || defined(NETWARE)\n\tp2 = strrchr(intern->file_name, '\\\\');\n#else\n\tp2 = 0;\n#endif\n\tif (p1 || p2) {\n\t\tintern->_path_len = (p1 > p2 ? p1 : p2) - intern->file_name;\n\t} else {\n\t\tintern->_path_len = 0;\n\t}\n\t\n\tif (intern->_path) {\n\t\tefree(intern->_path);\n\t}\n\tintern->_path = estrndup(path, intern->_path_len);\n} ",
        "output": "1",
        "idx": 3932
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}",
        "output": "0",
        "idx": 3561
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void unix_copy_addr(struct msghdr *msg, struct sock *sk)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\n\tmsg->msg_namelen = 0;\n\tif (u->addr) {\n\t\tmsg->msg_namelen = u->addr->len;\n\t\tmemcpy(msg->msg_name, u->addr->name, u->addr->len);\n\t}\n}",
        "output": "1",
        "idx": 2468
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct inode *ext4_alloc_inode(struct super_block *sb)\n{\n\tstruct ext4_inode_info *ei;\n\n\tei = kmem_cache_alloc(ext4_inode_cachep, GFP_NOFS);\n\tif (!ei)\n\t\treturn NULL;\n\n\tei->vfs_inode.i_version = 1;\n\tei->vfs_inode.i_data.writeback_index = 0;\n\tmemset(&ei->i_cached_extent, 0, sizeof(struct ext4_ext_cache));\n\tINIT_LIST_HEAD(&ei->i_prealloc_list);\n\tspin_lock_init(&ei->i_prealloc_lock);\n\tjbd2_journal_init_jbd_inode(&ei->jinode, &ei->vfs_inode);\n\tei->i_reserved_data_blocks = 0;\n\tei->i_reserved_meta_blocks = 0;\n\tei->i_allocated_meta_blocks = 0;\n\tei->i_da_metadata_calc_len = 0;\n\tei->i_delalloc_reserved_flag = 0;\n\tspin_lock_init(&(ei->i_block_reservation_lock));\n#ifdef CONFIG_QUOTA\n\tei->i_reserved_quota = 0;\n#endif\n\tINIT_LIST_HEAD(&ei->i_completed_io_list);\n\tspin_lock_init(&ei->i_completed_io_lock);\n\tei->cur_aio_dio = NULL;\n\tei->i_sync_tid = 0;\n\tei->i_datasync_tid = 0;\n\n\treturn &ei->vfs_inode;\n}",
        "output": "0",
        "idx": 3193
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )\n{\n    SQLWCHAR *chr;\n    int len = 0;\n\n    if ( !in )\n    {\n        return in;\n    }\n    \n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;\n    }\n\n    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));\n\n    len = 0;\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        chr[ len ] = in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = 0;\n    chr[ len ++ ] = 0;\n\n    return chr;\n}",
        "output": "1",
        "idx": 7322
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "__be32 ipv6_select_ident(struct net *net,\n\t\t\t const struct in6_addr *daddr,\n\t\t\t const struct in6_addr *saddr)\n{\n\tu32 id;\n\n\tid = __ipv6_select_ident(net, daddr, saddr);\n\treturn htonl(id);\n}",
        "output": "0",
        "idx": 4301
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t ocfs2_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tget_block_t *get_block;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\tif (iocb->ki_pos + iter->count > i_size_read(inode) &&\n\t    !ocfs2_supports_append_dio(osb))\n\t\treturn 0;\n\n\tif (iov_iter_rw(iter) == READ)\n\t\tget_block = ocfs2_get_block;\n\telse\n\t\tget_block = ocfs2_dio_get_block;\n\n\treturn __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t    iter, get_block,\n\t\t\t\t    ocfs2_dio_end_io, NULL, 0);\n}",
        "output": "1",
        "idx": 1762
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int unix_dgram_peer_wake_relay(wait_queue_t *q, unsigned mode, int flags,\n\t\t\t\t      void *key)\n{\n\tstruct unix_sock *u;\n\twait_queue_head_t *u_sleep;\n\n\tu = container_of(q, struct unix_sock, peer_wake);\n\n\t__remove_wait_queue(&unix_sk(u->peer_wake.private)->peer_wait,\n\t\t\t    q);\n\tu->peer_wake.private = NULL;\n\n\tu_sleep = sk_sleep(&u->sk);\n\tif (u_sleep)\n\t\twake_up_interruptible_poll(u_sleep, key);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1361
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hb_set_union (hb_set_t       *set,\n\t      const hb_set_t *other)\n{\n  set->union_ (*other);\n}",
        "output": "0",
        "idx": 7767
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void set_header(HttpResponse res, const char *name, const char *value, ...) {\n        HttpHeader h = NULL;\n\n        ASSERT(res);\n        ASSERT(name);\n\n        NEW(h);\n        h->name = Str_dup(name);\n        va_list ap;\n        va_start(ap, value);\n        h->value = Str_vcat(value, ap);\n        va_end(ap);\n        if (res->headers) {\n                HttpHeader n, p;\n                for (n = p = res->headers; p; n = p, p = p->next) {\n                        if (IS(p->name, name)) {\n                                FREE(p->value);\n                                p->value = Str_dup(value);\n                                destroy_entry(h);\n                                return;\n                        }\n                }\n                n->next = h;\n        } else {\n                res->headers = h;\n        }\n}",
        "output": "0",
        "idx": 8437
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __u8 *pl_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 62 && rdesc[39] == 0x2a && rdesc[40] == 0xf5 &&\n\t\t\trdesc[41] == 0x00 && rdesc[59] == 0x26 &&\n\t\t\trdesc[60] == 0xf9 && rdesc[61] == 0x00) {\n\t\thid_info(hdev, \"fixing up Petalynx Maxter Remote report descriptor\\n\");\n\t\trdesc[60] = 0xfa;\n\t\trdesc[40] = 0xfa;\n\t}\n\treturn rdesc;\n}",
        "output": "0",
        "idx": 3653
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_context_time(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tOM_uint32\t*time_rec)\n{\n\tOM_uint32 ret;\n\tret = gss_context_time(minor_status,\n\t\t\t    context_handle,\n\t\t\t    time_rec);\n\treturn (ret);\n}",
        "output": "1",
        "idx": 70
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "split_der(asn1buf *buf, uint8_t *const *der, size_t len, taginfo *tag_out)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n\n    ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen, 0);\n    if (ret)\n        return ret;\n    if (rlen != 0)\n        return ASN1_BAD_LENGTH;\n    insert_bytes(buf, contents, clen);\n    return 0;\n}",
        "output": "0",
        "idx": 303
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mp_decode_to_lua_array(lua_State *L, mp_cur *c, size_t len) {\n    assert(len <= UINT_MAX);\n    int index = 1;\n\n    lua_newtable(L);\n    luaL_checkstack(L, 1, \"in function mp_decode_to_lua_array\");\n    while(len--) {\n        lua_pushnumber(L,index++);\n        mp_decode_to_lua_type(L,c);\n        if (c->err) return;\n        lua_settable(L,-3);\n    }\n}",
        "output": "0",
        "idx": 5105
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(locale_get_display_language) \n{\n    get_icu_disp_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}",
        "output": "1",
        "idx": 3902
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rose_stop_heartbeat(struct sock *sk)\n{\n\tdel_timer(&sk->sk_timer);\n}",
        "output": "1",
        "idx": 2050
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cJSON_AddItemReferenceToArray( cJSON *array, cJSON *item )\n{\n\tcJSON_AddItemToArray( array, create_reference( item ) );\n}",
        "output": "1",
        "idx": 5930
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mark_commit(struct commit *c, void *data)\n{\n\tmark_object(&c->object, NULL, NULL, data);\n}",
        "output": "1",
        "idx": 5208
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "k5_asn1_full_decode(const krb5_data *code, const struct atype_info *a,\n                    void **retrep)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    taginfo t;\n\n    *retrep = NULL;\n    ret = get_tag((uint8_t *)code->data, code->length, &t, &contents,\n                  &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    if (!check_atype_tag(a, &t))\n        return ASN1_BAD_ID;\n    return decode_atype_to_ptr(&t, contents, clen, a, retrep);\n}",
        "output": "1",
        "idx": 208
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_FIELD_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_ARRAY_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n        *index_rtrn = expr->array_ref.entry;\n        return true;\n    default:\n        break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}",
        "output": "1",
        "idx": 7004
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __u8 *mr_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 31 && rdesc[29] == 0x05 && rdesc[30] == 0x09) {\n\t\thid_info(hdev, \"fixing up button/consumer in HID report descriptor\\n\");\n\t\trdesc[30] = 0x0c;\n\t}\n\treturn rdesc;\n}",
        "output": "0",
        "idx": 3651
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int is_integer(char *string)\n{\n  if (isdigit((unsigned char) string[0]) || string[0] == '-' || string[0] == '+') {\n    while (*++string && isdigit((unsigned char) *string))\n      ;                                           \n    if (!*string)\n      return 1;\n  }\n  return 0;\n}",
        "output": "0",
        "idx": 7401
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nsc_rle_decompress_data(NSC_CONTEXT* context)\n{\n\tUINT16 i;\n\tBYTE* rle;\n\tUINT32 planeSize;\n\tUINT32 originalSize;\n\trle = context->Planes;\n\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\toriginalSize = context->OrgByteCount[i];\n\t\tplaneSize = context->PlaneByteCount[i];\n\n\t\tif (planeSize == 0)\n\t\t\tFillMemory(context->priv->PlaneBuffers[i], originalSize, 0xFF);\n\t\telse if (planeSize < originalSize)\n\t\t\tnsc_rle_decode(rle, context->priv->PlaneBuffers[i], originalSize);\n\t\telse\n\t\t\tCopyMemory(context->priv->PlaneBuffers[i], rle, originalSize);\n\n\t\trle += planeSize;\n\t}\n}",
        "output": "1",
        "idx": 4220
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseParams(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprJson     *child;\n    cchar       *name, *value;\n    int         not, ji;\n\n    for (ITERATE_CONFIG(route, prop, child, ji)) {\n        name = mprReadJson(child, \"name\");\n        value = mprReadJson(child, \"value\");\n        not = smatch(mprReadJson(child, \"equals\"), \"true\") ? 0 : HTTP_ROUTE_NOT;\n        httpAddRouteParam(route, name, value, not);\n    }\n}",
        "output": "0",
        "idx": 7003
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n\t\t      gss_ctx_id_t context_handle,\n\t\t      int *conf_state,\n\t\t      gss_qop_t *qop_state,\n\t\t      gss_iov_buffer_desc *iov,\n\t\t      int iov_count)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_NO_CONTEXT);\n\n\tret = gss_unwrap_iov(minor_status,\n\t\t\t     sc->ctx_handle,\n\t\t\t     conf_state,\n\t\t\t     qop_state,\n\t\t\t     iov,\n\t\t\t     iov_count);\n\treturn (ret);\n}",
        "output": "0",
        "idx": 73
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_verify_mic(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_buffer_t msg_buffer,\n\t\tconst gss_buffer_t token_buffer,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_verify_mic(minor_status,\n\t\t\t    context_handle,\n\t\t\t    msg_buffer,\n\t\t\t    token_buffer,\n\t\t\t    qop_state);\n\treturn (ret);\n}",
        "output": "1",
        "idx": 88
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xen_netbk_fill_frags(struct xen_netbk *netbk, struct sk_buff *skb)\n{\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\tint nr_frags = shinfo->nr_frags;\n\tint i;\n\n\tfor (i = 0; i < nr_frags; i++) {\n\t\tskb_frag_t *frag = shinfo->frags + i;\n\t\tstruct xen_netif_tx_request *txp;\n\t\tstruct page *page;\n\t\tu16 pending_idx;\n\n\t\tpending_idx = frag_get_pending_idx(frag);\n\n\t\ttxp = &netbk->pending_tx_info[pending_idx].req;\n\t\tpage = virt_to_page(idx_to_kaddr(netbk, pending_idx));\n\t\t__skb_fill_page_desc(skb, i, page, txp->offset, txp->size);\n\t\tskb->len += txp->size;\n\t\tskb->data_len += txp->size;\n\t\tskb->truesize += txp->size;\n\n\t\tget_page(netbk->mmap_pages[pending_idx]);\n\t\txen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_OKAY);\n\t}\n}",
        "output": "0",
        "idx": 1163
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct rt6_info *rt = res->rt6;\n\tstruct net_device *dev = NULL;\n\n\tif (!rt)\n\t\treturn false;\n\n\tif (rt->rt6i_idev)\n\t\tdev = rt->rt6i_idev->dev;\n\n\tif (rt->rt6i_dst.plen <= rule->suppress_prefixlen)\n\t\tgoto suppress_route;\n\n\tif (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)\n\t\tgoto suppress_route;\n\n\treturn false;\n\nsuppress_route:\n\tip6_rt_put(rt);\n\treturn true;\n}",
        "output": "1",
        "idx": 3242
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int m88rs2000_frontend_attach(struct dvb_usb_adapter *adap)\n{\n\tstruct dvb_usb_device *d = adap->dev;\n\tstruct dw2102_state *state = d->priv;\n\n\tmutex_lock(&d->data_mutex);\n\n\tstate->data[0] = 0x51;\n\n\tif (dvb_usb_generic_rw(d, state->data, 1, state->data, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\n\tmutex_unlock(&d->data_mutex);\n\n\tadap->fe_adap[0].fe = dvb_attach(m88rs2000_attach,\n\t\t\t\t\t&s421_m88rs2000_config,\n\t\t\t\t\t&d->i2c_adap);\n\n\tif (adap->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\n\tif (dvb_attach(ts2020_attach, adap->fe_adap[0].fe,\n\t\t\t\t&dw2104_ts2020_config,\n\t\t\t\t&d->i2c_adap)) {\n\t\tinfo(\"Attached RS2000/TS2020!\");\n\t\treturn 0;\n\t}\n\n\tinfo(\"Failed to attach RS2000/TS2020!\");\n\treturn -EIO;\n}",
        "output": "0",
        "idx": 2191
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static CURLcode pop3_parse_url_path(struct connectdata *conn)\n{\n  struct pop3_conn *pop3c = &conn->proto.pop3c;\n  struct SessionHandle *data = conn->data;\n  const char *path = data->state.path;\n\n  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n  if(!pop3c->mailbox)\n    return CURLE_OUT_OF_MEMORY;\n\n  return CURLE_OK;\n}",
        "output": "1",
        "idx": 3592
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {\n        _cleanup_close_ int fd;\n        int r;\n\n        assert(path);\n\n        if (parents)\n                mkdir_parents(path, 0755);\n\n        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);\n        if (fd < 0)\n                return -errno;\n\n        if (mode > 0) {\n                r = fchmod(fd, mode);\n                if (r < 0)\n                        return -errno;\n        }\n\n        if (uid != UID_INVALID || gid != GID_INVALID) {\n                r = fchown(fd, uid, gid);\n                if (r < 0)\n                        return -errno;\n        }\n\n        if (stamp != USEC_INFINITY) {\n                struct timespec ts[2];\n\n                timespec_store(&ts[0], stamp);\n                ts[1] = ts[0];\n                r = futimens(fd, ts);\n        } else\n                r = futimens(fd, NULL);\n        if (r < 0)\n                return -errno;\n\n        return 0;\n}",
        "output": "1",
        "idx": 5478
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ut32 armass_assemble(const char *str, ut64 off, int thumb) {\n\tint i, j;\n\tchar buf[128];\n\tArmOpcode aop = {.off = off};\n\tfor (i = j = 0; i < sizeof (buf) - 1 && str[i]; i++, j++) {\n\t\tif (str[j] == '#') {\n\t\t\ti--; continue;\n\t\t}\n\t\tbuf[i] = tolower ((const ut8)str[j]);\n\t}\n\tbuf[i] = 0;\n\tarm_opcode_parse (&aop, buf);\n\taop.off = off;\n\tif (thumb < 0 || thumb > 1) {\n\t\treturn -1;\n\t}\n\tif (!assemble[thumb] (&aop, off, buf)) {\n\t\treturn -1;\n\t}\n\treturn aop.o;\n}",
        "output": "1",
        "idx": 6544
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct lib_t* MACH0_(get_libs)(struct MACH0_(obj_t)* bin) {\n\tstruct lib_t *libs;\n\tint i;\n\n\tif (!bin->nlibs) {\n\t\treturn NULL;\n\t}\n\tif (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tstrncpy (libs[i].name, bin->libs[i], R_BIN_MACH0_STRING_LENGTH);\n\t\tlibs[i].name[R_BIN_MACH0_STRING_LENGTH-1] = '\\0';\n\t\tlibs[i].last = 0;\n\t}\n\tlibs[i].last = 1;\n\treturn libs;\n}",
        "output": "0",
        "idx": 8635
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void save_quoted(const char *data, FILE *file)\n{\n\tconst char *p;\n\n\tfputc('\"', file);\n\tfor (p = data; p && *p; p++) {\n\t\tif ((unsigned char) *p == 0x22 ||\t\t\n\t\t    (unsigned char) *p == 0x5c)\t\t\t\n\t\t\tfputc('\\\\', file);\n\n\t\tfputc(*p, file);\n\t}\n\tfputc('\"', file);\n}",
        "output": "0",
        "idx": 6503
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_vim9_unlet(char_u *name)\n{\n    if (*name == NUL)\n    {\n\tsemsg(_(e_argument_required_for_str), \"unlet\");\n\treturn FAIL;\n    }\n\n    if (name[1] != ':' || vim_strchr((char_u *)\"gwtb\", *name) == NULL)\n    {\n\tif (*name == 's' && !script_is_vim9())\n\t    return OK;\n\tsemsg(_(e_cannot_unlet_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}",
        "output": "0",
        "idx": 8115
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int scsi_cmd_blk_ioctl(struct block_device *bd, fmode_t mode,\n\t\t       unsigned int cmd, void __user *arg)\n{\n\tint ret;\n\n\tret = scsi_verify_blk_ioctl(bd, cmd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn scsi_cmd_ioctl(bd->bd_disk->queue, bd->bd_disk, mode, cmd, arg);\n}",
        "output": "0",
        "idx": 857
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC int httpGetIntParam(HttpConn *conn, cchar *var, int defaultValue)\n{\n    cchar       *value;\n\n    value = mprLookupJson(httpGetParams(conn), var);\n    return (value) ? (int) stoi(value) : defaultValue;\n}",
        "output": "1",
        "idx": 5070
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dbOutputHexBlob(Jsi_DString *dStr, const void *pBlob, int nBlob){\n  int i;\n  char out[100], *zBlob = (char *)pBlob;\n  Jsi_DSAppend(dStr, \"X'\", NULL);\n  for(i=0; i<nBlob; i++){ snprintf(out, sizeof(out),\"%02x\",zBlob[i]&0xff);Jsi_DSAppend(dStr, out, NULL); }\n  Jsi_DSAppend(dStr, \"'\", NULL);\n}",
        "output": "1",
        "idx": 8212
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static pyc_object *get_tuple_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (tuple size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_TUPLE;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}",
        "output": "1",
        "idx": 6450
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int net_ctl_permissions(struct ctl_table_header *head,\n\t\t\t       struct ctl_table *table)\n{\n\tstruct net *net = container_of(head->set, struct net, sysctls);\n\tkuid_t root_uid = make_kuid(net->user_ns, 0);\n\tkgid_t root_gid = make_kgid(net->user_ns, 0);\n\n\tif (ns_capable(net->user_ns, CAP_NET_ADMIN) ||\n\t    uid_eq(root_uid, current_uid())) {\n\t\tint mode = (table->mode >> 6) & 7;\n\t\treturn (mode << 6) | (mode << 3) | mode;\n\t}\n\tif (gid_eq(root_gid, current_gid())) {\n\t\tint mode = (table->mode >> 3) & 7;\n\t\treturn (mode << 3) | mode;\n\t}\n\treturn table->mode;\n}",
        "output": "1",
        "idx": 2336
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static cchar *getPakVersion(cchar *name, cchar *version)\n{\n    MprDirEntry     *dp;\n    MprList         *files;\n\n    if (!version || smatch(version, \"*\")) {\n        name = stok(sclone(name), \"#\", (char**) &version);\n        if (!version) {\n            files = mprGetPathFiles(mprJoinPath(app->paksCacheDir, name), MPR_PATH_RELATIVE);\n            mprSortList(files, (MprSortProc) reverseSortFiles, 0);\n            if ((dp = mprGetFirstItem(files)) != 0) {\n                version = mprGetPathBase(dp->name);\n            }\n            if (version == 0) {\n                fail(\"Cannot find pak: %s\", name);\n                return 0;\n            }\n        }\n    }\n    return version;\n}",
        "output": "1",
        "idx": 4970
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\n\t(void)mode;\t\n\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_POSIX1E, \"posix1e\");\n\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}",
        "output": "0",
        "idx": 5159
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_q931_cc_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tprint_16bits_val(ndo, (const uint16_t *)dat);\n\tND_PRINT((ndo, \", %02x\", dat[2]));\n\tif (length > 3) {\n\t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, dat+3, length-3);\n\t}\n}",
        "output": "1",
        "idx": 4774
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof TSRMLS_DC)\n{\n\tuint64_t max_vars = PG(max_input_vars);\n\n\tvars->ptr = vars->str.c;\n\tvars->end = vars->str.c + vars->str.len;\n\twhile (add_post_var(arr, vars, eof TSRMLS_CC)) {\n\t\tif (++vars->cnt > max_vars) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\n\t\t\t\t\t\"Input variables exceeded %\" PRIu64 \". \"\n\t\t\t\t\t\"To increase the limit change max_input_vars in php.ini.\",\n\t\t\t\t\tmax_vars);\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tif (!eof && vars->str.c != vars->ptr) {\n\t\tmemmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);\n\t}\n\treturn SUCCESS;\n}",
        "output": "0",
        "idx": 5669
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xfrm_alloc_replay_state_esn(struct xfrm_replay_state_esn **replay_esn,\n\t\t\t\t       struct xfrm_replay_state_esn **preplay_esn,\n\t\t\t\t       struct nlattr *rta)\n{\n\tstruct xfrm_replay_state_esn *p, *pp, *up;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tup = nla_data(rta);\n\n\tp = kmemdup(up, xfrm_replay_state_esn_len(up), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpp = kmemdup(up, xfrm_replay_state_esn_len(up), GFP_KERNEL);\n\tif (!pp) {\n\t\tkfree(p);\n\t\treturn -ENOMEM;\n\t}\n\n\t*replay_esn = p;\n\t*preplay_esn = pp;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 774
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct dst_entry *inet_csk_route_req(struct sock *sk,\n\t\t\t\t     const struct request_sock *req)\n{\n\tstruct rtable *rt;\n\tconst struct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ip_options *opt = inet_rsk(req)->opt;\n\tstruct net *net = sock_net(sk);\n\tstruct flowi4 fl4;\n\n\tflowi4_init_output(&fl4, sk->sk_bound_dev_if, sk->sk_mark,\n\t\t\t   RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE,\n\t\t\t   sk->sk_protocol, inet_sk_flowi_flags(sk),\n\t\t\t   (opt && opt->srr) ? opt->faddr : ireq->rmt_addr,\n\t\t\t   ireq->loc_addr, ireq->rmt_port, inet_sk(sk)->inet_sport);\n\tsecurity_req_classify_flow(req, flowi4_to_flowi(&fl4));\n\trt = ip_route_output_flow(net, &fl4, sk);\n\tif (IS_ERR(rt))\n\t\tgoto no_route;\n\tif (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway)\n\t\tgoto route_err;\n\treturn &rt->dst;\n\nroute_err:\n\tip_rt_put(rt);\nno_route:\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES);\n\treturn NULL;\n}",
        "output": "1",
        "idx": 344
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int atusb_get_and_show_revision(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char *buffer;\n\tint ret;\n\n\tbuffer = kmalloc(3, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\tif (ret >= 0) {\n\t\tatusb->fw_ver_maj = buffer[0];\n\t\tatusb->fw_ver_min = buffer[1];\n\t\tatusb->fw_hw_type = buffer[2];\n\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware: major: %u, minor: %u, hardware type: %u\\n\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);\n\t}\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n\t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n\t}\n\n\tkfree(buffer);\n\treturn ret;\n}",
        "output": "0",
        "idx": 2077
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void addReply(redisClient *c, robj *obj) {\n    if (_installWriteEvent(c) != REDIS_OK) return;\n    redisAssert(!server.vm_enabled || obj->storage == REDIS_VM_MEMORY);\n\n    if (obj->encoding == REDIS_ENCODING_RAW) {\n        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK)\n            _addReplyObjectToList(c,obj);\n    } else {\n        obj = getDecodedObject(obj);\n        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK)\n            _addReplyObjectToList(c,obj);\n        decrRefCount(obj);\n    }\n}",
        "output": "1",
        "idx": 3654
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline pgd_t *pgd_alloc(struct mm_struct *mm)\n{\n\tunsigned long *table = crst_table_alloc(mm);\n\n\tif (!table)\n\t\treturn NULL;\n\tif (mm->context.asce_limit == (1UL << 31)) {\n\t\tif (!pgtable_pmd_page_ctor(virt_to_page(table))) {\n\t\t\tcrst_table_free(mm, table);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn (pgd_t *) table;\n}",
        "output": "0",
        "idx": 1679
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int update_write_order_info(rdpContext* context, wStream* s, ORDER_INFO* orderInfo,\n                                   size_t offset)\n{\n\tsize_t position;\n\tWINPR_UNUSED(context);\n\tposition = Stream_GetPosition(s);\n\tStream_SetPosition(s, offset);\n\tStream_Write_UINT8(s, orderInfo->controlFlags); \n\n\tif (orderInfo->controlFlags & ORDER_TYPE_CHANGE)\n\t\tStream_Write_UINT8(s, orderInfo->orderType); \n\n\tupdate_write_field_flags(s, orderInfo->fieldFlags, orderInfo->controlFlags,\n\t                         get_primary_drawing_order_field_bytes(orderInfo->orderType, NULL));\n\tupdate_write_bounds(s, orderInfo);\n\tStream_SetPosition(s, position);\n\treturn 0;\n}",
        "output": "0",
        "idx": 5757
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int clie_5_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *port;\n\tunsigned int pipe;\n\tint j;\n\n\n\tif (serial->num_ports < 2)\n\t\treturn -1;\n\n\tport = serial->port[0];\n\tport->bulk_out_endpointAddress =\n\t\t\t\tserial->port[1]->bulk_out_endpointAddress;\n\n\tpipe = usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress);\n\tfor (j = 0; j < ARRAY_SIZE(port->write_urbs); ++j)\n\t\tport->write_urbs[j]->pipe = pipe;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1060
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sunkbd_reinit(struct work_struct *work)\n{\n\tstruct sunkbd *sunkbd = container_of(work, struct sunkbd, tq);\n\n\twait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ);\n\n\tserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\n\tserio_write(sunkbd->serio,\n\t\t(!!test_bit(LED_CAPSL,   sunkbd->dev->led) << 3) |\n\t\t(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |\n\t\t(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |\n\t\t !!test_bit(LED_NUML,    sunkbd->dev->led));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));\n}",
        "output": "1",
        "idx": 1912
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int caif_seqpkt_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\tstruct msghdr *m, size_t len, int flags)\n\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint ret;\n\tint copylen;\n\n\tret = -EOPNOTSUPP;\n\tif (m->msg_flags&MSG_OOB)\n\t\tgoto read_error;\n\n\tm->msg_namelen = 0;\n\n\tskb = skb_recv_datagram(sk, flags, 0 , &ret);\n\tif (!skb)\n\t\tgoto read_error;\n\tcopylen = skb->len;\n\tif (len < copylen) {\n\t\tm->msg_flags |= MSG_TRUNC;\n\t\tcopylen = len;\n\t}\n\n\tret = skb_copy_datagram_iovec(skb, 0, m->msg_iov, copylen);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = (flags & MSG_TRUNC) ? skb->len : copylen;\nout_free:\n\tskb_free_datagram(sk, skb);\n\tcaif_check_flow_release(sk);\n\treturn ret;\n\nread_error:\n\treturn ret;\n}",
        "output": "0",
        "idx": 1277
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int uas_switch_interface(struct usb_device *udev,\n\t\t\t\tstruct usb_interface *intf)\n{\n\tint alt;\n\n\talt = uas_find_uas_alt_setting(intf);\n\tif (alt < 0)\n\t\treturn alt;\n\n\treturn usb_set_interface(udev,\n\t\t\tintf->altsetting[0].desc.bInterfaceNumber, alt);\n}",
        "output": "1",
        "idx": 1672
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int flakey_ioctl(struct dm_target *ti, unsigned int cmd, unsigned long arg)\n{\n\tstruct flakey_c *fc = ti->private;\n\tstruct dm_dev *dev = fc->dev;\n\tint r = 0;\n\n\tif (fc->start ||\n\t    ti->len != i_size_read(dev->bdev->bd_inode) >> SECTOR_SHIFT)\n\t\tr = scsi_verify_blk_ioctl(NULL, cmd);\n\n\treturn r ? : __blkdev_driver_ioctl(dev->bdev, dev->mode, cmd, arg);\n}",
        "output": "0",
        "idx": 865
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)\n{\n\treturn crypto_skcipher_setkey(private, key, keylen);\n}",
        "output": "1",
        "idx": 1054
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jas_iccputsint(jas_stream_t *out, int n, jas_longlong val)\n{\n\tjas_ulonglong tmp;\n\ttmp = (val < 0) ? (abort(), 0) : val;\n\treturn jas_iccputuint(out, n, tmp);\n}",
        "output": "0",
        "idx": 7551
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nfs4_xdr_dec_getacl(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t    struct nfs_getaclres *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getacl(xdr, rqstp, res);\n\nout:\n\treturn status;\n}",
        "output": "0",
        "idx": 847
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(RecursiveDirectoryIterator, getSubPath)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (intern->u.dir.sub_path) {\n\t\tRETURN_STRINGL(intern->u.dir.sub_path, intern->u.dir.sub_path_len, 1);\n\t} else {\n\t\tRETURN_STRINGL(\"\", 0, 1);\n\t}\n}",
        "output": "1",
        "idx": 3990
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, eof)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_BOOL(php_stream_eof(intern->u.file.stream));\n} ",
        "output": "0",
        "idx": 5517
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void uwbd_stop(struct uwb_rc *rc)\n{\n\tif (rc->uwbd.task)\n\t\tkthread_stop(rc->uwbd.task);\n\tuwbd_flush(rc);\n}",
        "output": "0",
        "idx": 2397
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "build_unc_path_to_root(const struct smb_vol *vol,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(full_path, vol->UNC, unc_len);\n\tpos = full_path + unc_len;\n\n\tif (pplen) {\n\t\t*pos++ = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos, vol->prepath, pplen);\n\t\tpos += pplen;\n\t}\n\n\t*pos = '\\0'; \n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}",
        "output": "1",
        "idx": 2292
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rose_start_heartbeat(struct sock *sk)\n{\n\tdel_timer(&sk->sk_timer);\n\n\tsk->sk_timer.function = rose_heartbeat_expiry;\n\tsk->sk_timer.expires  = jiffies + 5 * HZ;\n\n\tadd_timer(&sk->sk_timer);\n}",
        "output": "1",
        "idx": 2052
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "translate_hex_string(char *s, char *saved_orphan)\n{\n  int c1 = *saved_orphan;\n  char *start = s;\n  char *t = s;\n  for (; *s; s++) {\n    if (isspace((unsigned char) *s))\n      continue;\n    if (c1) {\n      *t++ = (hexval(c1) << 4) + hexval(*s);\n      c1 = 0;\n    } else\n      c1 = *s;\n  }\n  *saved_orphan = c1;\n  return t - start;\n}",
        "output": "0",
        "idx": 7407
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, ftell)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tlong ret = php_stream_tell(intern->u.file.stream);\n\n\tif (ret == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_LONG(ret);\n\t}\n} ",
        "output": "0",
        "idx": 5567
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool __net_get_random_once(void *buf, int nbytes, bool *done,\n\t\t\t   struct static_key *done_key)\n{\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lock, flags);\n\tif (*done) {\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t\treturn false;\n\t}\n\n\tget_random_bytes(buf, nbytes);\n\t*done = true;\n\tspin_unlock_irqrestore(&lock, flags);\n\n\t__net_random_once_disable_jump(done_key);\n\n\treturn true;\n}",
        "output": "1",
        "idx": 2568
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_le_3byte (SF_PRIVATE *psf, int x)\n{\tpsf->header.ptr [psf->header.indx++] = x ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n} ",
        "output": "0",
        "idx": 6899
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "stream_read(cdk_stream_t s, void *buf, size_t buflen, size_t * r_nread)\n{\n\tint res = cdk_stream_read(s, buf, buflen);\n\n\tif (res > 0) {\n\t\t*r_nread = res;\n\t\treturn 0;\n\t} else {\n\t\treturn (cdk_stream_eof(s) ? EOF : _cdk_stream_get_errno(s));\n\t}\n}",
        "output": "0",
        "idx": 6485
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "forbidden_name(struct compiling *c, identifier name, const node *n,\n               int full_checks)\n{\n    assert(PyUnicode_Check(name));\n    if (PyUnicode_CompareWithASCIIString(name, \"__debug__\") == 0) {\n        ast_error(c, n, \"assignment to keyword\");\n        return 1;\n    }\n    if (full_checks) {\n        const char * const *p;\n        for (p = FORBIDDEN; *p; p++) {\n            if (PyUnicode_CompareWithASCIIString(name, *p) == 0) {\n                ast_error(c, n, \"assignment to keyword\");\n                return 1;\n            }\n        }\n    }\n    return 0;\n}",
        "output": "1",
        "idx": 7768
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int iwch_cxgb3_ofld_send(struct t3cdev *tdev, struct sk_buff *skb)\n{\n\tint\terror = 0;\n\tstruct cxio_rdev *rdev;\n\n\trdev = (struct cxio_rdev *)tdev->ulp;\n\tif (cxio_fatal_error(rdev)) {\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\terror = cxgb3_ofld_send(tdev, skb);\n\tif (error < 0)\n\t\tkfree_skb(skb);\n\treturn error;\n}",
        "output": "1",
        "idx": 1004
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, seek)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tlong line_pos;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &line_pos) == FAILURE) {\n\t\treturn;\n\t}\n\tif (line_pos < 0) {\n\t\tzend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, \"Can't seek file %s to negative line %ld\", intern->file_name, line_pos);\n\t\tRETURN_FALSE;\t\t\n\t}\n\t\n\tspl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);\n\t\n\twhile(intern->u.file.current_line_num < line_pos) {\n\t\tif (spl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC) == FAILURE) {\n\t\t\tbreak;\n\t\t}\n\t}\n} ",
        "output": "1",
        "idx": 3982
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileInfo, getFilename)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tint path_len;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_filesystem_object_get_path(intern, &path_len TSRMLS_CC);\n\n\tif (path_len && path_len < intern->file_name_len) {\n\t\tRETURN_STRINGL(intern->file_name + path_len + 1, intern->file_name_len - (path_len + 1), 1);\n\t} else {\n\t\tRETURN_STRINGL(intern->file_name, intern->file_name_len, 1);\n\t}\n}",
        "output": "0",
        "idx": 5555
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline __u16\tinet_getid(struct inet_peer *p, int more)\n{\n\tmore++;\n\tinet_peer_refcheck(p);\n\treturn atomic_add_return(more, &p->ip_id_count) - more;\n}",
        "output": "1",
        "idx": 560
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct sk_buff **sit_gro_receive(struct sk_buff **head,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tif (NAPI_GRO_CB(skb)->encap_mark) {\n\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\treturn NULL;\n\t}\n\n\tNAPI_GRO_CB(skb)->encap_mark = 1;\n\n\treturn ipv6_gro_receive(head, skb);\n}",
        "output": "0",
        "idx": 1723
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BOOL transport_accept_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tif (transport->TlsIn == NULL)\n\t\ttransport->TlsIn = tls_new(transport->settings);\n\n\tif (transport->TlsOut == NULL)\n\t\ttransport->TlsOut = transport->TlsIn;\n\n\ttransport->layer = TRANSPORT_LAYER_TLS;\n\ttransport->TlsIn->sockfd = transport->TcpIn->sockfd;\n\n\tif (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE)\n\t\treturn FALSE;\n\n\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tfprintf(stderr, \"client authentication failure\\n\");\n\t\tcredssp_free(transport->credssp);\n\t\ttransport->credssp = NULL;\n\t\treturn FALSE;\n\t}\n\n\n\treturn TRUE;\n}",
        "output": "0",
        "idx": 5843
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int fsmMkdir(const char *path, mode_t mode)\n{\n    int rc = mkdir(path, (mode & 07777));\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,\n\t       path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n    return rc;\n}",
        "output": "1",
        "idx": 6630
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "asmlinkage void kernel_unaligned_trap(struct pt_regs *regs, unsigned int insn)\n{\n\tenum direction dir = decode_direction(insn);\n\tint size = decode_access_size(insn);\n\n\tif(!ok_for_kernel(insn) || dir == both) {\n\t\tprintk(\"Unsupported unaligned load/store trap for kernel at <%08lx>.\\n\",\n\t\t       regs->pc);\n\t\tunaligned_panic(\"Wheee. Kernel does fpu/atomic unaligned load/store.\");\n\t} else {\n\t\tunsigned long addr = compute_effective_address(regs, insn);\n\t\tint err;\n\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, addr);\n\t\tswitch (dir) {\n\t\tcase load:\n\t\t\terr = do_int_load(fetch_reg_addr(((insn>>25)&0x1f),\n\t\t\t\t\t\t\t regs),\n\t\t\t\t\t  size, (unsigned long *) addr,\n\t\t\t\t\t  decode_signedness(insn));\n\t\t\tbreak;\n\n\t\tcase store:\n\t\t\terr = do_int_store(((insn>>25)&0x1f), size,\n\t\t\t\t\t   (unsigned long *) addr, regs);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpanic(\"Impossible kernel unaligned trap.\");\n\t\t}\n\t\tif (err)\n\t\t\tkernel_mna_trap_fault(regs, insn);\n\t\telse\n\t\t\tadvance(regs);\n\t}\n}",
        "output": "0",
        "idx": 633
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint32_t virtio_config_readl(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val;\n\n    k->get_config(vdev, vdev->config);\n\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n\n    val = ldl_p(vdev->config + addr);\n    return val;\n}",
        "output": "1",
        "idx": 3766
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xen_netbk_get_extras(struct xenvif *vif,\n\t\t\t\tstruct xen_netif_extra_info *extras,\n\t\t\t\tint work_to_do)\n{\n\tstruct xen_netif_extra_info extra;\n\tRING_IDX cons = vif->tx.req_cons;\n\n\tdo {\n\t\tif (unlikely(work_to_do-- <= 0)) {\n\t\t\tnetdev_err(vif->dev, \"Missing extra info\\n\");\n\t\t\tnetbk_fatal_tx_err(vif);\n\t\t\treturn -EBADR;\n\t\t}\n\n\t\tmemcpy(&extra, RING_GET_REQUEST(&vif->tx, cons),\n\t\t       sizeof(extra));\n\t\tif (unlikely(!extra.type ||\n\t\t\t     extra.type >= XEN_NETIF_EXTRA_TYPE_MAX)) {\n\t\t\tvif->tx.req_cons = ++cons;\n\t\t\tnetdev_err(vif->dev,\n\t\t\t\t   \"Invalid extra type: %d\\n\", extra.type);\n\t\t\tnetbk_fatal_tx_err(vif);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy(&extras[extra.type - 1], &extra, sizeof(extra));\n\t\tvif->tx.req_cons = ++cons;\n\t} while (extra.flags & XEN_NETIF_EXTRA_FLAG_MORE);\n\n\treturn work_to_do;\n}",
        "output": "0",
        "idx": 1157
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int digest_generic_verify(struct digest *d, const unsigned char *md)\n{\n\tint ret;\n\tint len = digest_length(d);\n\tunsigned char *tmp;\n\n\ttmp = xmalloc(len);\n\n\tret = digest_final(d, tmp);\n\tif (ret)\n\t\tgoto end;\n\n\tret = memcmp(md, tmp, len);\n\tret = ret ? -EINVAL : 0;\nend:\n\tfree(tmp);\n\treturn ret;\n}",
        "output": "1",
        "idx": 8774
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int gdAlphaBlend (int dst, int src) {\n    int src_alpha = gdTrueColorGetAlpha(src);\n    int dst_alpha, alpha, red, green, blue;\n    int src_weight, dst_weight, tot_weight;\n\n    if( src_alpha == gdAlphaOpaque )\n        return src;\n\n    dst_alpha = gdTrueColorGetAlpha(dst);\n    if( src_alpha == gdAlphaTransparent )\n        return dst;\n    if( dst_alpha == gdAlphaTransparent )\n        return src;\n\n    src_weight = gdAlphaTransparent - src_alpha;\n    dst_weight = (gdAlphaTransparent - dst_alpha) * src_alpha / gdAlphaMax;\n    tot_weight = src_weight + dst_weight;\n\n    alpha = src_alpha * dst_alpha / gdAlphaMax;\n\n    red = (gdTrueColorGetRed(src) * src_weight\n           + gdTrueColorGetRed(dst) * dst_weight) / tot_weight;\n    green = (gdTrueColorGetGreen(src) * src_weight\n           + gdTrueColorGetGreen(dst) * dst_weight) / tot_weight;\n    blue = (gdTrueColorGetBlue(src) * src_weight\n           + gdTrueColorGetBlue(dst) * dst_weight) / tot_weight;\n\n    return ((alpha << 24) + (red << 16) + (green << 8) + blue);\n\n}",
        "output": "0",
        "idx": 5625
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l_strnstart(const char *tstr1, u_int tl1, const char *str2, u_int l2)\n{\n\n\tif (tl1 > l2)\n\t\treturn 0;\n\n\treturn (strncmp(tstr1, str2, tl1) == 0 ? 1 : 0);\n}",
        "output": "1",
        "idx": 4778
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int secure_check(void *data)\n{\n\tconst at91_secure_header_t *header;\n\tvoid *file;\n\n\tif (secure_decrypt(data, sizeof(*header), 0))\n\t\treturn -1;\n\n\theader = (const at91_secure_header_t *)data;\n\tif (header->magic != AT91_SECURE_MAGIC)\n\t\treturn -1;\n\n\tfile = (unsigned char *)data + sizeof(*header);\n\treturn secure_decrypt(file, header->file_size, 1);\n}",
        "output": "1",
        "idx": 7866
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool inode_capable(const struct inode *inode, int cap)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\n\treturn ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid);\n}",
        "output": "1",
        "idx": 2590
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static entity_table_opt determine_entity_table(int all, int doctype)\n{\n\tentity_table_opt retval = {NULL};\n\n\tassert(!(doctype == ENT_HTML_DOC_XML1 && all));\n\n\tif (all) {\n\t\tretval.ms_table = (doctype == ENT_HTML_DOC_HTML5) ?\n\t\t\tentity_ms_table_html5 : entity_ms_table_html4;\n\t} else {\n\t\tretval.table = (doctype == ENT_HTML_DOC_HTML401) ?\n\t\t\tstage3_table_be_noapos_00000 : stage3_table_be_apos_00000;\n\t}\n\treturn retval;\n}",
        "output": "0",
        "idx": 5379
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rfc2253_name(X509_NAME *name, char **str_out)\n{\n    BIO *b = NULL;\n    char *str;\n\n    *str_out = NULL;\n    b = BIO_new(BIO_s_mem());\n    if (b == NULL)\n        return ENOMEM;\n    if (X509_NAME_print_ex(b, name, 0, XN_FLAG_SEP_COMMA_PLUS) < 0)\n        goto error;\n    str = calloc(BIO_number_written(b) + 1, 1);\n    if (str == NULL)\n        goto error;\n    BIO_read(b, str, BIO_number_written(b));\n    BIO_free(b);\n    *str_out = str;\n    return 0;\n\nerror:\n    BIO_free(b);\n    return ENOMEM;\n}",
        "output": "0",
        "idx": 287
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void beforeSleep(struct aeEventLoop *eventLoop) {\n    REDIS_NOTUSED(eventLoop);\n    listNode *ln;\n    redisClient *c;\n\n    if (server.ds_enabled && listLength(server.io_ready_clients)) {\n        listIter li;\n\n        listRewind(server.io_ready_clients,&li);\n        while((ln = listNext(&li))) {\n            c = ln->value;\n            struct redisCommand *cmd;\n\n            listDelNode(server.io_ready_clients,ln);\n            c->flags &= (~REDIS_IO_WAIT);\n            server.cache_blocked_clients--;\n            aeCreateFileEvent(server.el, c->fd, AE_READABLE,\n                readQueryFromClient, c);\n            cmd = lookupCommand(c->argv[0]->ptr);\n            redisAssert(cmd != NULL);\n            call(c,cmd);\n            resetClient(c);\n            if (c->querybuf && sdslen(c->querybuf) > 0)\n                processInputBuffer(c);\n        }\n    }\n\n    while (listLength(server.unblocked_clients)) {\n        ln = listFirst(server.unblocked_clients);\n        redisAssert(ln != NULL);\n        c = ln->value;\n        listDelNode(server.unblocked_clients,ln);\n\n        if (c->querybuf && sdslen(c->querybuf) > 0)\n            processInputBuffer(c);\n    }\n\n    flushAppendOnlyFile();\n}",
        "output": "0",
        "idx": 5129
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool __init is_skylake_era(void)\n{\n\tif (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL &&\n\t    boot_cpu_data.x86 == 6) {\n\t\tswitch (boot_cpu_data.x86_model) {\n\t\tcase INTEL_FAM6_SKYLAKE_MOBILE:\n\t\tcase INTEL_FAM6_SKYLAKE_DESKTOP:\n\t\tcase INTEL_FAM6_SKYLAKE_X:\n\t\tcase INTEL_FAM6_KABYLAKE_MOBILE:\n\t\tcase INTEL_FAM6_KABYLAKE_DESKTOP:\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
        "output": "1",
        "idx": 2998
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ImagingPcdDecode(Imaging im, ImagingCodecState state, UINT8* buf, int bytes)\n{\n    int x;\n    int chunk;\n    UINT8* out;\n    UINT8* ptr;\n\n    ptr = buf;\n\n    chunk = 3 * state->xsize;\n\n    for (;;) {\n\n\tif (bytes < chunk)\n\t    return ptr - buf;\n\n\tout = state->buffer;\n\tfor (x = 0; x < state->xsize; x++) {\n\t    out[0] = ptr[x];\n\t    out[1] = ptr[(x+4*state->xsize)/2];\n\t    out[2] = ptr[(x+5*state->xsize)/2];\n\t    out += 3;\n\t}\n\n\tstate->shuffle((UINT8*) im->image[state->y],\n\t\t       state->buffer, state->xsize);\n\n\tif (++state->y >= state->ysize)\n\t    return -1; \n\n\tout = state->buffer;\n\tfor (x = 0; x < state->xsize; x++) {\n\t    out[0] = ptr[x+state->xsize];\n\t    out[1] = ptr[(x+4*state->xsize)/2];\n\t    out[2] = ptr[(x+5*state->xsize)/2];\n\t    out += 3;\n\t}\n\n\tstate->shuffle((UINT8*) im->image[state->y],\n\t\t       state->buffer, state->xsize);\n\n\tif (++state->y >= state->ysize)\n\t    return -1;\n\n\tptr += chunk;\n\tbytes -= chunk;\n\n    }\n}",
        "output": "0",
        "idx": 6387
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void Sp_search(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tResub m;\n\n\ttext = checkstring(J, 0);\n\n\tif (js_isregexp(J, 1))\n\t\tjs_copy(J, 1);\n\telse if (js_isundefined(J, 1))\n\t\tjs_newregexp(J, \"\", 0);\n\telse\n\t\tjs_newregexp(J, js_tostring(J, 1), 0);\n\n\tre = js_toregexp(J, -1);\n\n\tif (!js_regexec(re->prog, text, &m, 0))\n\t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n\telse\n\t\tjs_pushnumber(J, -1);\n}",
        "output": "1",
        "idx": 7414
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_show_object(struct object *object, const char *name,\n\t\t\t     void *data)\n{\n\tstruct bitmap_test_data *tdata = data;\n\tint bitmap_pos;\n\n\tbitmap_pos = bitmap_position(object->oid.hash);\n\tif (bitmap_pos < 0)\n\t\tdie(\"Object not in bitmap: %s\\n\", oid_to_hex(&object->oid));\n\n\tbitmap_set(tdata->base, bitmap_pos);\n\tdisplay_progress(tdata->prg, ++tdata->seen);\n}",
        "output": "0",
        "idx": 7235
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_unwrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer,\n\t\tgss_buffer_t output_message_buffer,\n\t\tint *conf_state,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_NO_CONTEXT);\n\n\tret = gss_unwrap(minor_status,\n\t\t\tsc->ctx_handle,\n\t\t\tinput_message_buffer,\n\t\t\toutput_message_buffer,\n\t\t\tconf_state,\n\t\t\tqop_state);\n\n\treturn (ret);\n}",
        "output": "0",
        "idx": 117
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "add_header_value(VALUE hh, const char *key, int klen, const char *val, int vlen) {\n    if (sizeof(content_type) - 1 == klen && 0 == strncasecmp(key, content_type, sizeof(content_type) - 1)) {\n\trb_hash_aset(hh, content_type_val, rb_str_new(val, vlen));\n    } else if (sizeof(content_length) - 1 == klen && 0 == strncasecmp(key, content_length, sizeof(content_length) - 1)) {\n\trb_hash_aset(hh, content_length_val, rb_str_new(val, vlen));\n    } else {\n\tchar\t\thkey[1024];\n\tchar\t\t*k = hkey;\n\tvolatile VALUE\tsval = rb_str_new(val, vlen);\n\n\tstrcpy(hkey, \"HTTP_\");\n\tk = hkey + 5;\n\tif ((int)(sizeof(hkey) - 5) <= klen) {\n\t    klen = sizeof(hkey) - 6;\n\t}\n\tstrncpy(k, key, klen);\n\thkey[klen + 5] = '\\0';\n\n\tfor (k = hkey + 5; '\\0' != *k; k++) {\n\t    if ('-' == *k) {\n\t\t*k = '_';\n\t    } else {\n\t\t*k = toupper(*k);\n\t    }\n\t}\n\trb_hash_aset(hh, rb_str_new(hkey, klen + 5), sval);\n    }\n}",
        "output": "1",
        "idx": 8404
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init ipip_init(void)\n{\n\tint err;\n\n\tprintk(banner);\n\n\terr = register_pernet_device(&ipip_net_ops);\n\tif (err < 0)\n\t\treturn err;\n\terr = xfrm4_tunnel_register(&ipip_handler, AF_INET);\n\tif (err < 0) {\n\t\tunregister_pernet_device(&ipip_net_ops);\n\t\tprintk(KERN_INFO \"ipip init: can't register tunnel\\n\");\n\t}\n\treturn err;\n}",
        "output": "0",
        "idx": 3139
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long madvise_remove(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_area_struct **prev,\n\t\t\t\tunsigned long start, unsigned long end)\n{\n\tloff_t offset;\n\tint error;\n\tstruct file *f;\n\n\t*prev = NULL;\t\n\n\tif (vma->vm_flags & (VM_LOCKED|VM_NONLINEAR|VM_HUGETLB))\n\t\treturn -EINVAL;\n\n\tf = vma->vm_file;\n\n\tif (!f || !f->f_mapping || !f->f_mapping->host) {\n\t\t\treturn -EINVAL;\n\t}\n\n\tif ((vma->vm_flags & (VM_SHARED|VM_WRITE)) != (VM_SHARED|VM_WRITE))\n\t\treturn -EACCES;\n\n\toffset = (loff_t)(start - vma->vm_start)\n\t\t\t+ ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n\n\tget_file(f);\n\tup_read(&current->mm->mmap_sem);\n\terror = do_fallocate(f,\n\t\t\t\tFALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n\t\t\t\toffset, end - start);\n\tfput(f);\n\tdown_read(&current->mm->mmap_sem);\n\treturn error;\n}",
        "output": "0",
        "idx": 979
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "INST_HANDLER (sts) {\t\n\tif (len < 4) {\n\t\treturn;\n\t}\n\tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tint k = (buf[3] << 8) | buf[2];\n\top->ptr = k;\n\n\tESIL_A (\"r%d,\", r);\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 1);\n\n\top->cycles = 2;\n}",
        "output": "0",
        "idx": 8713
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int search_old_relocation(struct reloc_struct_t *reloc_table, ut32 addr_to_patch, int n_reloc) {\n\tint i;\n\tfor (i = 0; i < n_reloc; i++) {\n\t\tif (addr_to_patch == reloc_table[i].data_offset) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
        "output": "1",
        "idx": 6124
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&dev->lock);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tbuf[1] &= ~(1 << offset);\n\tbuf[2] = gpio_push_pull;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = 0;\n\nexit:\n\tmutex_unlock(&dev->lock);\n\treturn ret <= 0 ? ret : -EIO;\n}",
        "output": "0",
        "idx": 2109
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int cg_mkdir(const char *path, mode_t mode)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *path1, *cgdir = NULL, *controller;\n\tconst char *cgroup;\n\tint ret;\n\n\tif (!fc)\n\t\treturn -EIO;\n\n\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EINVAL;\n\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath)\n\t\tpath1 = \"/\";\n\telse\n\t\tpath1 = cgdir;\n\n\tif (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, path1, NULL)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\n\tret = cgfs_create(controller, cgroup, fc->uid, fc->gid);\n\tprintf(\"cgfs_create returned %d for %s %s\\n\", ret, controller, cgroup);\n\nout:\n\tfree(cgdir);\n\treturn ret;\n}",
        "output": "1",
        "idx": 5216
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gdImageScaleTwoPass(const gdImagePtr src, const unsigned int new_width,\n                    const unsigned int new_height)\n{\n    const unsigned int src_width = src->sx;\n    const unsigned int src_height = src->sy;\n\tgdImagePtr tmp_im = NULL;\n\tgdImagePtr dst = NULL;\n\n    if (src_width == new_width && src_height == new_height) {\n        return gdImageClone(src);\n    }\n\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n    if (src_width == new_width) {\n        tmp_im = src;\n    } else {\n        tmp_im = gdImageCreateTrueColor(new_width, src_height);\n        if (tmp_im == NULL) {\n            return NULL;\n        }\n        gdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n\n        _gdScalePass(src, src_width, tmp_im, new_width, src_height, HORIZONTAL);\n    }\n\n    if (src_height == new_height) {\n        assert(tmp_im != src);\n        return tmp_im;\n    }\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst != NULL) {\n        gdImageSetInterpolationMethod(dst, src->interpolation_id);\n        _gdScalePass(tmp_im, src_height, dst, new_height, new_width, VERTICAL);\n    }\n\n    if (src != tmp_im) {\n        gdImageDestroy(tmp_im);\n    }\n\n\treturn dst;\n}",
        "output": "0",
        "idx": 6235
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void jas_deprecated(const char *s)\n{\n\tstatic char message[] =\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"YOUR CODE IS RELYING ON DEPRECATED FUNCTIONALTIY IN THE JASPER LIBRARY.\\n\"\n\t\"THIS FUNCTIONALITY WILL BE REMOVED IN THE NEAR FUTURE.\\n\"\n\t\"PLEASE FIX THIS PROBLEM BEFORE YOUR CODE STOPS WORKING!\\n\"\n\t;\n\tjas_eprintf(\"%s\", message);\n\tjas_eprintf(\"The specific problem is as follows:\\n%s\\n\", s);\n}",
        "output": "0",
        "idx": 7521
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ceph_x_proc_ticket_reply(struct ceph_auth_client *ac,\n\t\t\t\t    struct ceph_crypto_key *secret,\n\t\t\t\t    void *buf, void *end)\n{\n\tvoid *p = buf;\n\tu8 reply_struct_v;\n\tu32 num;\n\tint ret;\n\n\tceph_decode_8_safe(&p, end, reply_struct_v, bad);\n\tif (reply_struct_v != 1)\n\t\treturn -EINVAL;\n\n\tceph_decode_32_safe(&p, end, num, bad);\n\tdout(\"%d tickets\\n\", num);\n\n\twhile (num--) {\n\t\tret = process_one_ticket(ac, secret, &p, end);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n\nbad:\n\treturn -EINVAL;\n}",
        "output": "0",
        "idx": 3665
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ssh_packet_set_compress_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct sshbuf *b = NULL;\n\tint r;\n\tconst u_char *inblob, *outblob;\n\tsize_t inl, outl;\n\n\tif ((r = sshbuf_froms(m, &b)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_string_direct(b, &inblob, &inl)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, &outblob, &outl)) != 0)\n\t\tgoto out;\n\tif (inl == 0)\n\t\tstate->compression_in_started = 0;\n\telse if (inl != sizeof(state->compression_in_stream)) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t} else {\n\t\tstate->compression_in_started = 1;\n\t\tmemcpy(&state->compression_in_stream, inblob, inl);\n\t}\n\tif (outl == 0)\n\t\tstate->compression_out_started = 0;\n\telse if (outl != sizeof(state->compression_out_stream)) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t} else {\n\t\tstate->compression_out_started = 1;\n\t\tmemcpy(&state->compression_out_stream, outblob, outl);\n\t}\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}",
        "output": "1",
        "idx": 5582
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned int get_random_int(void)\n{\n\t__u32 *hash = get_cpu_var(get_random_int_hash);\n\tunsigned int ret;\n\n\thash[0] += current->pid + jiffies + get_cycles();\n\tmd5_transform(hash, random_int_secret);\n\tret = hash[0];\n\tput_cpu_var(get_random_int_hash);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 771
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void error_handler(int priority, const char *format, ...)\r\n{\r\n    gdTestAssert(priority == GD_WARNING);\r\n    gdTestAssert(!strcmp(format, MSG));\r\n}\r",
        "output": "0",
        "idx": 6211
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void f_parser (lua_State *L, void *ud) {\n  int i;\n  Proto *tf;\n  Closure *cl;\n  struct SParser *p = cast(struct SParser *, ud);\n  int c = luaZ_lookahead(p->z);\n  luaC_checkGC(L);\n  tf = (luaY_parser)(L, p->z,\n                                                             &p->buff, p->name);\n  cl = luaF_newLclosure(L, tf->nups, hvalue(gt(L)));\n  cl->l.p = tf;\n  for (i = 0; i < tf->nups; i++)  \n    cl->l.upvals[i] = luaF_newupval(L);\n  setclvalue(L, L->top, cl);\n  incr_top(L);\n}",
        "output": "0",
        "idx": 5089
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nfs4_open_recover_helper(struct nfs4_opendata *opendata, fmode_t fmode, struct nfs4_state **res)\n{\n\tstruct nfs4_state *newstate;\n\tint ret;\n\n\topendata->o_arg.open_flags = 0;\n\topendata->o_arg.fmode = fmode;\n\tmemset(&opendata->o_res, 0, sizeof(opendata->o_res));\n\tmemset(&opendata->c_res, 0, sizeof(opendata->c_res));\n\tnfs4_init_opendata_res(opendata);\n\tret = _nfs4_proc_open(opendata);\n\tif (ret != 0)\n\t\treturn ret; \n\tnewstate = nfs4_opendata_to_nfs4_state(opendata);\n\tif (IS_ERR(newstate))\n\t\treturn PTR_ERR(newstate);\n\tnfs4_close_state(&opendata->path, newstate, fmode);\n\t*res = newstate;\n\treturn 0;\n}",
        "output": "0",
        "idx": 3049
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void expire_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\n\tif (likely((s64)(rq_clock(rq_of(cfs_rq)) - cfs_rq->runtime_expires) < 0))\n\t\treturn;\n\n\tif (cfs_rq->runtime_remaining < 0)\n\t\treturn;\n\n\tif (cfs_rq->expires_seq == cfs_b->expires_seq) {\n\t\tcfs_rq->runtime_expires += TICK_NSEC;\n\t} else {\n\t\tcfs_rq->runtime_remaining = 0;\n\t}\n}",
        "output": "1",
        "idx": 3230
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ConnectClientToUnixSock(const char *sockFile)\n{\n#ifdef WIN32\n  rfbClientErr(\"Windows doesn't support UNIX sockets\\n\");\n  return -1;\n#else\n  int sock;\n  struct sockaddr_un addr;\n  addr.sun_family = AF_UNIX;\n  if(strlen(sockFile) + 1 > sizeof(addr.sun_path)) {\n      rfbClientErr(\"ConnectToUnixSock: socket file name too long\\n\");\n      return -1;\n  }\n  strcpy(addr.sun_path, sockFile);\n\n  sock = socket(AF_UNIX, SOCK_STREAM, 0);\n  if (sock < 0) {\n    rfbClientErr(\"ConnectToUnixSock: socket (%s)\\n\",strerror(errno));\n    return -1;\n  }\n\n  if (connect(sock, (struct sockaddr *)&addr, sizeof(addr.sun_family) + strlen(addr.sun_path)) < 0) {\n    rfbClientErr(\"ConnectToUnixSock: connect\\n\");\n    close(sock);\n    return -1;\n  }\n\n  return sock;\n#endif\n}",
        "output": "0",
        "idx": 8919
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BOOL rdp_read_font_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (length > 4)\n\t\tStream_Seek_UINT16(s); \n\n\tif (length > 6)\n\t\tStream_Seek_UINT16(s); \n\n\treturn TRUE;\n}",
        "output": "1",
        "idx": 4140
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct socket *sock;\n\tint err = 0;\n\n\tif (!net_eq(current->nsproxy->net_ns, sock_net(sk)))\n\t\treturn -EINVAL;\n\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tif (waitqueue_active(&asoc->wait))\n\t\treturn -EBUSY;\n\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\n\t*sockp = sock;\n\n\treturn err;\n}",
        "output": "0",
        "idx": 2523
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){\n  assert( p->nOp>0 || p->aOp==0 );\n  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );\n  if( p->nOp ){\n    assert( p->aOp );\n    sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);\n    p->aOp[p->nOp-1].zComment = sqlite3VMPrintf(p->db, zFormat, ap);\n  }\n}",
        "output": "1",
        "idx": 7644
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main(int argc, char *argv[])\n{\n\tint ret;\n\tstruct lxc_lock *lock;\n\n\tlock = lxc_newlock(NULL, NULL);\n\tif (!lock) {\n\t\tfprintf(stderr, \"%d: failed to get unnamed lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tret = lxclock(lock, 0);\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to take unnamed lock (%d)\\n\", __LINE__, ret);\n\t\texit(1);\n\t}\n\n\tret = lxcunlock(lock);\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to put unnamed lock (%d)\\n\", __LINE__, ret);\n\t\texit(1);\n\t}\n\tlxc_putlock(lock);\n\n\tlock = lxc_newlock(\"/var/lib/lxc\", mycontainername);\n\tif (!lock) {\n\t\tfprintf(stderr, \"%d: failed to get lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tstruct stat sb;\n\tchar *pathname = RUNTIME_PATH \"/lock/lxc/var/lib/lxc/\";\n\tret = stat(pathname, &sb);\n\tif (ret != 0) {\n\t\tfprintf(stderr, \"%d: filename %s not created\\n\", __LINE__,\n\t\t\tpathname);\n\t\texit(1);\n\t}\n\tlxc_putlock(lock);\n\n\ttest_two_locks();\n\n\tfprintf(stderr, \"all tests passed\\n\");\n\n\texit(ret);\n}",
        "output": "1",
        "idx": 4344
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void user_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_positive(key))\n\t\tseq_printf(m, \": %u\", key->datalen);\n}",
        "output": "0",
        "idx": 2519
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n\t\t\t\t   size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\tint ret = 0;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp >= O2NM_MAX_NODES)\n\t\treturn -ERANGE;\n\n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL; \n\n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (cluster->cl_nodes[tmp])\n\t\tret = -EEXIST;\n\telse if (test_and_set_bit(O2NM_NODE_ATTR_NUM,\n\t\t\t&node->nd_set_attributes))\n\t\tret = -EBUSY;\n\telse  {\n\t\tcluster->cl_nodes[tmp] = node;\n\t\tnode->nd_num = tmp;\n\t\tset_bit(tmp, cluster->cl_nodes_bitmap);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}",
        "output": "1",
        "idx": 1772
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nft_flush_table(struct nft_ctx *ctx)\n{\n\tint err;\n\tstruct nft_chain *chain, *nc;\n\tstruct nft_set *set, *ns;\n\n\tlist_for_each_entry(chain, &ctx->table->chains, list) {\n\t\tctx->chain = chain;\n\n\t\terr = nft_delrule_by_chain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry_safe(set, ns, &ctx->table->sets, list) {\n\t\tif (set->flags & NFT_SET_ANONYMOUS &&\n\t\t    !list_empty(&set->bindings))\n\t\t\tcontinue;\n\n\t\terr = nft_delset(ctx, set);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {\n\t\tctx->chain = chain;\n\n\t\terr = nft_delchain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\terr = nft_deltable(ctx);\nout:\n\treturn err;\n}",
        "output": "0",
        "idx": 3805
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int srpt_rx_mgmt_fn_tag(struct srpt_send_ioctx *ioctx, u64 tag)\n{\n\tstruct srpt_device *sdev;\n\tstruct srpt_rdma_ch *ch;\n\tstruct srpt_send_ioctx *target;\n\tint ret, i;\n\n\tret = -EINVAL;\n\tch = ioctx->ch;\n\tBUG_ON(!ch);\n\tBUG_ON(!ch->sport);\n\tsdev = ch->sport->sdev;\n\tBUG_ON(!sdev);\n\tspin_lock_irq(&sdev->spinlock);\n\tfor (i = 0; i < ch->rq_size; ++i) {\n\t\ttarget = ch->ioctx_ring[i];\n\t\tif (target->cmd.se_lun == ioctx->cmd.se_lun &&\n\t\t    target->cmd.tag == tag &&\n\t\t    srpt_get_cmd_state(target) != SRPT_STATE_DONE) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irq(&sdev->spinlock);\n\treturn ret;\n}",
        "output": "1",
        "idx": 1128
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline pmd_t pmd_read_atomic(pmd_t *pmdp)\n{\n\treturn *pmdp;\n}",
        "output": "0",
        "idx": 959
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_gets (SF_PRIVATE *psf, char *ptr, int bufsize)\n{\tint\t\tk ;\n\n\tfor (k = 0 ; k < bufsize - 1 ; k++)\n\t{\tif (psf->headindex < psf->headend)\n\t\t{\tptr [k] = psf->header [psf->headindex] ;\n\t\t\tpsf->headindex ++ ;\n\t\t\t}\n\t\telse\n\t\t{\tpsf->headend += psf_fread (psf->header + psf->headend, 1, 1, psf) ;\n\t\t\tptr [k] = psf->header [psf->headindex] ;\n\t\t\tpsf->headindex = psf->headend ;\n\t\t\t} ;\n\n\t\tif (ptr [k] == '\\n')\n\t\t\tbreak ;\n\t\t} ;\n\n\tptr [k] = 0 ;\n\n\treturn k ;\n} ",
        "output": "1",
        "idx": 4942
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ImagingPcdDecode(Imaging im, ImagingCodecState state, UINT8* buf, int bytes)\n{\n    int x;\n    int chunk;\n    UINT8* out;\n    UINT8* ptr;\n\n    ptr = buf;\n\n    chunk = 3 * state->xsize;\n\n    for (;;) {\n\n\tif (bytes < chunk)\n\t    return ptr - buf;\n\n\tout = state->buffer;\n\tfor (x = 0; x < state->xsize; x++) {\n\t    out[0] = ptr[x];\n\t    out[1] = ptr[(x+4*state->xsize)/2];\n\t    out[2] = ptr[(x+5*state->xsize)/2];\n\t    out += 4;\n\t}\n\n\tstate->shuffle((UINT8*) im->image[state->y],\n\t\t       state->buffer, state->xsize);\n\n\tif (++state->y >= state->ysize)\n\t    return -1; \n\n\tout = state->buffer;\n\tfor (x = 0; x < state->xsize; x++) {\n\t    out[0] = ptr[x+state->xsize];\n\t    out[1] = ptr[(x+4*state->xsize)/2];\n\t    out[2] = ptr[(x+5*state->xsize)/2];\n\t    out += 4;\n\t}\n\n\tstate->shuffle((UINT8*) im->image[state->y],\n\t\t       state->buffer, state->xsize);\n\n\tif (++state->y >= state->ysize)\n\t    return -1;\n\n\tptr += chunk;\n\tbytes -= chunk;\n\n    }\n}",
        "output": "1",
        "idx": 4560
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int sas_discover_sata(struct domain_device *dev)\n{\n\tint res;\n\n\tif (dev->dev_type == SAS_SATA_PM)\n\t\treturn -ENODEV;\n\n\tdev->sata_dev.class = sas_get_ata_command_set(dev);\n\tsas_fill_in_rphy(dev, dev->rphy);\n\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\n\tsas_discover_event(dev->port, DISCE_PROBE);\n\treturn 0;\n}",
        "output": "1",
        "idx": 1820
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "init_pyfribidi (void)\n{\n        PyObject *module = Py_InitModule (\"_pyfribidi\", PyfribidiMethods);\n\tPyModule_AddIntConstant (module, \"RTL\", (long) FRIBIDI_TYPE_RTL);\n\tPyModule_AddIntConstant (module, \"LTR\", (long) FRIBIDI_TYPE_LTR);\n\tPyModule_AddIntConstant (module, \"ON\", (long) FRIBIDI_TYPE_ON);\n}",
        "output": "0",
        "idx": 5049
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)\n{\n\tflush_fp_to_thread(src);\n\tflush_altivec_to_thread(src);\n\tflush_vsx_to_thread(src);\n\tflush_spe_to_thread(src);\n\t__switch_to_tm(src);\n\ttm_recheckpoint_new_task(src);\n\n\t*dst = *src;\n\n\tclear_task_ebb(dst);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 3485
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int setup_dev_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console)\n{\n\tchar path[MAXPATHLEN];\n\tstruct stat s;\n\tint ret;\n\n\tret = snprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\n\tif (access(path, F_OK)) {\n\t\tWARN(\"rootfs specified but no console found at '%s'\", path);\n\t\treturn 0;\n\t}\n\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\n\tif (stat(path, &s)) {\n\t\tSYSERROR(\"failed to stat '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif (chmod(console->name, s.st_mode)) {\n\t\tSYSERROR(\"failed to set mode '0%o' to '%s'\",\n\t\t\t s.st_mode, console->name);\n\t\treturn -1;\n\t}\n\n\tif (mount(console->name, path, \"none\", MS_BIND, 0)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, path);\n\t\treturn -1;\n\t}\n\n\tINFO(\"console has been setup\");\n\treturn 0;\n}",
        "output": "1",
        "idx": 4362
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_be_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n\t{\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} ",
        "output": "1",
        "idx": 4928
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint8_t ethereum_extractThorchainData(const EthereumSignTx *msg,\n                                          char *buffer) {\n  uint16_t offset = 4 + (5 * 32);\n  int16_t len = msg->data_length - offset;\n  if (msg->has_data_length && len > 0) {\n    memcpy(buffer, msg->data_initial_chunk.bytes + offset, len);\n    return len < 256 ? (uint8_t)len : 0;\n  }\n  return 0;\n}",
        "output": "1",
        "idx": 7558
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "snmp_ber_decode_null(unsigned char *buf, uint32_t *buff_len)\n{\n  buf++;\n  (*buff_len)--;\n\n  buf++;\n  (*buff_len)--;\n\n  return buf;\n}",
        "output": "1",
        "idx": 7950
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n{\n\n\tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\n\t\tIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n\t\t\t\"addr %pM\\n\",\n\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {\n\t\tIWL_DEBUG_ASSOC(priv,\n\t\t\t\t\"STA id %u addr %pM already present in uCode \"\n\t\t\t\t\"(according to driver)\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t} else {\n\t\tpriv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;\n\t\tIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t}\n}",
        "output": "1",
        "idx": 670
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void save_text_if_changed(const char *name, const char *new_value)\n{\n    if (!g_hash_table_lookup(g_loaded_texts, name))\n        return;\n\n    const char *old_value = g_cd ? problem_data_get_content_or_NULL(g_cd, name) : \"\";\n    if (!old_value)\n        old_value = \"\";\n    if (strcmp(new_value, old_value) != 0)\n    {\n        struct dump_dir *dd = wizard_open_directory_for_writing(g_dump_dir_name);\n        if (dd)\n            dd_save_text(dd, name, new_value);\n\n        dd_close(dd);\n        problem_data_reload_from_dump_dir();\n        update_gui_state_from_problem_data( 0);\n    }\n}",
        "output": "1",
        "idx": 5234
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline void update_rq_clock(struct rq *rq)\n{\n\tint cpu = cpu_of(rq);\n\tu64 irq_time;\n\n\tif (rq->skip_clock_update)\n\t\treturn;\n\n\trq->clock = sched_clock_cpu(cpu);\n\tirq_time = irq_time_cpu(cpu);\n\tif (rq->clock - irq_time > rq->clock_task)\n\t\trq->clock_task = rq->clock - irq_time;\n\n\tsched_irq_time_avg_update(rq, irq_time);\n}",
        "output": "0",
        "idx": 351
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct inode *__isofs_iget(struct super_block *sb,\n\t\t\t   unsigned long block,\n\t\t\t   unsigned long offset,\n\t\t\t   int relocated)\n{\n\tunsigned long hashval;\n\tstruct inode *inode;\n\tstruct isofs_iget5_callback_data data;\n\tlong ret;\n\n\tif (offset >= 1ul << sb->s_blocksize_bits)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdata.block = block;\n\tdata.offset = offset;\n\n\thashval = (block << sb->s_blocksize_bits) | offset;\n\n\tinode = iget5_locked(sb, hashval, &isofs_iget5_test,\n\t\t\t\t&isofs_iget5_set, &data);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tret = isofs_read_inode(inode, relocated);\n\t\tif (ret < 0) {\n\t\t\tiget_failed(inode);\n\t\t\tinode = ERR_PTR(ret);\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t}\n\t}\n\n\treturn inode;\n}",
        "output": "0",
        "idx": 3631
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "raptor_libxml_resolveEntity(void* user_data, \n                            const xmlChar *publicId, const xmlChar *systemId)\n{\n  raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  xmlParserCtxtPtr ctxt = sax2->xc;\n  const unsigned char *uri_string = NULL;\n  xmlParserInputPtr entity_input;\n  int load_entity = 0;\n\n  if(ctxt->input)\n    uri_string = RAPTOR_GOOD_CAST(const unsigned char *, ctxt->input->filename);\n\n  if(!uri_string)\n    uri_string = RAPTOR_GOOD_CAST(const unsigned char *, ctxt->directory);\n\n  load_entity = RAPTOR_OPTIONS_GET_NUMERIC(sax2, RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES);\n  if(load_entity)\n    load_entity = raptor_sax2_check_load_uri_string(sax2, uri_string);\n\n  if(load_entity) {\n    entity_input = xmlLoadExternalEntity(RAPTOR_GOOD_CAST(const char*, uri_string),\n                                         RAPTOR_GOOD_CAST(const char*, publicId),\n                                         ctxt);\n  } else {\n    RAPTOR_DEBUG4(\"Not loading entity URI %s by policy for publicId '%s' systemId '%s'\\n\", uri_string, publicId, systemId);\n  }\n  \n  return entity_input;\n}",
        "output": "0",
        "idx": 5033
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "k5_asn1_full_decode(const krb5_data *code, const struct atype_info *a,\n                    void **retrep)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    taginfo t;\n\n    *retrep = NULL;\n    ret = get_tag((uint8_t *)code->data, code->length, &t, &contents,\n                  &clen, &remainder, &rlen, 0);\n    if (ret)\n        return ret;\n    if (!check_atype_tag(a, &t))\n        return ASN1_BAD_ID;\n    return decode_atype_to_ptr(&t, contents, clen, a, retrep);\n}",
        "output": "0",
        "idx": 311
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ZydisFormatterBufferInitTokenized(ZydisFormatterBuffer* buffer,\n    ZydisFormatterToken** first_token, void* user_buffer, ZyanUSize length)\n{\n    ZYAN_ASSERT(buffer);\n    ZYAN_ASSERT(first_token);\n    ZYAN_ASSERT(user_buffer);\n    ZYAN_ASSERT(length);\n\n    *first_token = user_buffer;\n    (*first_token)->type = ZYDIS_TOKEN_INVALID;\n    (*first_token)->next = 0;\n\n    user_buffer = (ZyanU8*)user_buffer + sizeof(ZydisFormatterToken);\n    length -= sizeof(ZydisFormatterToken);\n\n    buffer->is_token_list              = ZYAN_TRUE;\n    buffer->capacity                   = length;\n    buffer->string.flags               = ZYAN_STRING_HAS_FIXED_CAPACITY;\n    buffer->string.vector.allocator    = ZYAN_NULL;\n    buffer->string.vector.element_size = sizeof(char);\n    buffer->string.vector.size         = 1;\n    buffer->string.vector.capacity     = length;\n    buffer->string.vector.data         = user_buffer;\n    *(char*)user_buffer = '\\0';\n}",
        "output": "1",
        "idx": 8828
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int unlinkat_harder(int dfd, const char *filename, int unlink_flags, RemoveFlags remove_flags) {\n\n        mode_t old_mode;\n        int r;\n\n\n        if (unlinkat(dfd, filename, unlink_flags) >= 0)\n                return 0;\n        if (errno != EACCES || !FLAGS_SET(remove_flags, REMOVE_CHMOD))\n                return -errno;\n\n        r = patch_dirfd_mode(dfd, &old_mode);\n        if (r < 0)\n                return r;\n\n        if (unlinkat(dfd, filename, unlink_flags) < 0) {\n                r = -errno;\n                (void) fchmod(dfd, old_mode);\n                return r;\n        }\n\n        if (FLAGS_SET(remove_flags, REMOVE_CHMOD_RESTORE) && fchmod(dfd, old_mode) < 0)\n                return -errno;\n\n        return 0;\n}",
        "output": "1",
        "idx": 5496
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int gdTransformAffineGetImage(gdImagePtr *dst,\n\t\t  const gdImagePtr src,\n\t\t  gdRectPtr src_area,\n\t\t  const double affine[6])\n{\n\tint res;\n\tdouble m[6];\n\tgdRect bbox;\n\tgdRect area_full;\n\n\tif (src_area == NULL) {\n\t\tarea_full.x = 0;\n\t\tarea_full.y = 0;\n\t\tarea_full.width  = gdImageSX(src);\n\t\tarea_full.height = gdImageSY(src);\n\t\tsrc_area = &area_full;\n\t}\n\n\tgdTransformAffineBoundingBox(src_area, affine, &bbox);\n\n\t*dst = gdImageCreateTrueColor(bbox.width, bbox.height);\n\tif (*dst == NULL) {\n\t\treturn GD_FALSE;\n\t}\n\t(*dst)->saveAlphaFlag = 1;\n\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n\tgdAffineTranslate(m, -bbox.x, -bbox.y);\n\tgdAffineConcat(m, affine, m);\n\n\tgdImageAlphaBlending(*dst, 0);\n\n\tres = gdTransformAffineCopy(*dst,\n\t\t  0,0,\n\t\t  src,\n\t\t  src_area,\n\t\t  m);\n\n\tif (res != GD_TRUE) {\n\t\tgdImageDestroy(*dst);\n\t\tdst = NULL;\n\t\treturn GD_FALSE;\n\t} else {\n\t\treturn GD_TRUE;\n\t}\n}",
        "output": "0",
        "idx": 5457
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "clear_evalarg(evalarg_T *evalarg, exarg_T *eap)\n{\n    if (evalarg != NULL)\n    {\n\tif (evalarg->eval_tofree != NULL)\n\t{\n\t    if (eap != NULL)\n\t    {\n\t\tvim_free(eap->cmdline_tofree);\n\t\teap->cmdline_tofree = *eap->cmdlinep;\n\t\t*eap->cmdlinep = evalarg->eval_tofree;\n\t    }\n\t    else\n\t\tvim_free(evalarg->eval_tofree);\n\t    evalarg->eval_tofree = NULL;\n\t}\n\n\tga_clear_strings(&evalarg->eval_tofree_ga);\n\tVIM_CLEAR(evalarg->eval_tofree_lambda);\n    }\n}",
        "output": "1",
        "idx": 5820
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vmx_complete_atomic_exit(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\n\tif (!(vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY\n\t      || vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI))\n\t\treturn;\n\n\tvmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\texit_intr_info = vmx->exit_intr_info;\n\n\tif (is_machine_check(exit_intr_info))\n\t\tkvm_machine_check();\n\n\tif ((exit_intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR &&\n\t    (exit_intr_info & INTR_INFO_VALID_MASK)) {\n\t\tkvm_before_handle_nmi(&vmx->vcpu);\n\t\tasm(\"int $2\");\n\t\tkvm_after_handle_nmi(&vmx->vcpu);\n\t}\n}",
        "output": "1",
        "idx": 1400
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool new_idmap_permitted(struct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, current_fsuid()))\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (gid_eq(gid, current_fsgid()))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\n\tif (ns_capable(ns->parent, cap_setid))\n\t\treturn true;\n\n\treturn false;\n}",
        "output": "1",
        "idx": 902
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sd_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_interface_cache *intfc;\n\tstruct usb_host_interface *alt;\n\tint max_packet_size;\n\n\tswitch (gspca_dev->pixfmt.width) {\n\tcase 160:\n\t\tmax_packet_size = 450;\n\t\tbreak;\n\tcase 176:\n\t\tmax_packet_size = 600;\n\t\tbreak;\n\tdefault:\n\t\tmax_packet_size = 1022;\n\t\tbreak;\n\t}\n\n\tintfc = gspca_dev->dev->actconfig->intf_cache[0];\n\n\tif (intfc->num_altsetting < 2)\n\t\treturn -ENODEV;\n\n\talt = &intfc->altsetting[1];\n\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(max_packet_size);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 4627
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline __u64 dccp_v6_init_sequence(struct sk_buff *skb)\n{\n\treturn secure_dccpv6_sequence_number(ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\t\t     ipv6_hdr(skb)->saddr.s6_addr32,\n\t\t\t\t\t     dccp_hdr(skb)->dccph_dport,\n\t\t\t\t\t     dccp_hdr(skb)->dccph_sport     );\n\n}",
        "output": "0",
        "idx": 795
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rad_get_vendor_attr(u_int32_t *vendor, unsigned char *type, const void **data, size_t *len, const void *raw, size_t raw_len)\n{\n\tstruct vendor_attribute *attr;\n\n\tif (raw_len < sizeof(struct vendor_attribute)) {\n\t\treturn -1;\n\t}\n\n\tattr = (struct vendor_attribute *) raw;\n\t*vendor = ntohl(attr->vendor_value);\n\t*type = attr->attrib_type;\n\t*data = attr->attrib_data;\n\t*len = attr->attrib_len - 2;\n\n\tif ((attr->attrib_len + 4) > raw_len) {\n\t\treturn -1;\n\t}\n\n\treturn (attr->attrib_type);\n}",
        "output": "0",
        "idx": 5361
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *zap = NULL;\n\tint ret;\n\n\tret = key_payload_reserve(key, prep->datalen);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tkey->expiry = prep->expiry;\n\tif (key_is_positive(key))\n\t\tzap = dereference_key_locked(key);\n\trcu_assign_keypointer(key, prep->payload.data[0]);\n\tprep->payload.data[0] = NULL;\n\n\tif (zap)\n\t\tcall_rcu(&zap->rcu, user_free_payload_rcu);\n\treturn ret;\n}",
        "output": "0",
        "idx": 2517
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int picolcd_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *raw_data, int size)\n{\n\tstruct picolcd_data *data = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (!data)\n\t\treturn 1;\n\n\tif (size > 64) {\n\t\thid_warn(hdev, \"invalid size value (%d) for picolcd raw event\\n\",\n\t\t\t\tsize);\n\t\treturn 0;\n\t}\n\n\tif (report->id == REPORT_KEY_STATE) {\n\t\tif (data->input_keys)\n\t\t\tret = picolcd_raw_keypad(data, report, raw_data+1, size-1);\n\t} else if (report->id == REPORT_IR_DATA) {\n\t\tret = picolcd_raw_cir(data, report, raw_data+1, size-1);\n\t} else {\n\t\tspin_lock_irqsave(&data->lock, flags);\n\t\tif (data->pending) {\n\t\t\tmemcpy(data->pending->raw_data, raw_data+1, size-1);\n\t\t\tdata->pending->raw_size  = size-1;\n\t\t\tdata->pending->in_report = report;\n\t\t\tcomplete(&data->pending->ready);\n\t\t}\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t}\n\n\tpicolcd_debug_raw_event(data, hdev, report, raw_data, size);\n\treturn 1;\n}",
        "output": "0",
        "idx": 3661
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int proc_sys_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct ctl_table_header *head = grab_header(file_inode(file));\n\tstruct ctl_table_header *h = NULL;\n\tstruct ctl_table *entry;\n\tstruct ctl_dir *ctl_dir;\n\tunsigned long pos;\n\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n\tctl_dir = container_of(head, struct ctl_dir, header);\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\n\tpos = 2;\n\n\tfor (first_entry(ctl_dir, &h, &entry); h; next_entry(&h, &entry)) {\n\t\tif (!scan(h, entry, &pos, file, ctx)) {\n\t\t\tsysctl_head_finish(h);\n\t\t\tbreak;\n\t\t}\n\t}\n\tsysctl_head_finish(head);\n\treturn 0;\n}",
        "output": "1",
        "idx": 1406
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ipc_rcu_getref(void *ptr)\n{\n\treturn atomic_inc_not_zero(&container_of(ptr, struct ipc_rcu_hdr, data)->refcount);\n}",
        "output": "0",
        "idx": 3235
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __u8 *nci_extract_rf_params_nfca_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfca_poll *nfca_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfca_poll->sens_res = __le16_to_cpu(*((__u16 *)data));\n\tdata += 2;\n\n\tnfca_poll->nfcid1_len = min_t(__u8, *data++, NFC_NFCID1_MAXSIZE);\n\n\tpr_debug(\"sens_res 0x%x, nfcid1_len %d\\n\",\n\t\t nfca_poll->sens_res, nfca_poll->nfcid1_len);\n\n\tmemcpy(nfca_poll->nfcid1, data, nfca_poll->nfcid1_len);\n\tdata += nfca_poll->nfcid1_len;\n\n\tnfca_poll->sel_res_len = *data++;\n\n\tif (nfca_poll->sel_res_len != 0)\n\t\tnfca_poll->sel_res = *data++;\n\n\tpr_debug(\"sel_res_len %d, sel_res 0x%x\\n\",\n\t\t nfca_poll->sel_res_len,\n\t\t nfca_poll->sel_res);\n\n\treturn data;\n}",
        "output": "0",
        "idx": 967
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int check_ptrace_options(unsigned long data)\n{\n\tif (data & ~(unsigned long)PTRACE_O_MASK)\n\t\treturn -EINVAL;\n\n\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {\n\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||\n\t\t    !IS_ENABLED(CONFIG_SECCOMP))\n\t\t\treturn -EINVAL;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||\n\t\t    current->ptrace & PT_SUSPEND_SECCOMP)\n\t\t\treturn -EPERM;\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 2913
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bt_tags_for_each(struct blk_mq_tags *tags,\n\t\tstruct blk_mq_bitmap_tags *bt, unsigned int off,\n\t\tbusy_tag_iter_fn *fn, void *data, bool reserved)\n{\n\tstruct request *rq;\n\tint bit, i;\n\n\tif (!tags->rqs)\n\t\treturn;\n\tfor (i = 0; i < bt->map_nr; i++) {\n\t\tstruct blk_align_bitmap *bm = &bt->map[i];\n\n\t\tfor (bit = find_first_bit(&bm->word, bm->depth);\n\t\t     bit < bm->depth;\n\t\t     bit = find_next_bit(&bm->word, bm->depth, bit + 1)) {\n\t\t\trq = blk_mq_tag_to_rq(tags, off + bit);\n\t\t\tfn(rq, data, reserved);\n\t\t}\n\n\t\toff += (1 << bt->bits_per_word);\n\t}\n}",
        "output": "1",
        "idx": 2890
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,\n\t\t\t     size_t outlen, int invert)\n{\n\tconst u8 *in = inbuf;\n\tu8 *out = (u8 *) outbuf;\n\tint zero_bits = *in & 0x07;\n\tsize_t octets_left = inlen - 1;\n\tint i, count = 0;\n\n\tmemset(outbuf, 0, outlen);\n\tin++;\n\tif (outlen < octets_left)\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\tif (inlen < 1)\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\twhile (octets_left) {\n\t\tint bits_to_go;\n\n\t\t*out = 0;\n\t\tif (octets_left == 1)\n\t\t\tbits_to_go = 8 - zero_bits;\n\t\telse\n\t\t\tbits_to_go = 8;\n\t\tif (invert)\n\t\t\tfor (i = 0; i < bits_to_go; i++) {\n\t\t\t\t*out |= ((*in >> (7 - i)) & 1) << i;\n\t\t\t}\n\t\telse {\n\t\t\t*out = *in;\n\t\t}\n\t\tout++;\n\t\tin++;\n\t\toctets_left--;\n\t\tcount++;\n\t}\n\treturn (count * 8) - zero_bits;\n}",
        "output": "1",
        "idx": 7038
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ex_copy(linenr_T line1, linenr_T line2, linenr_T n)\n{\n    linenr_T\tcount;\n    char_u\t*p;\n\n    count = line2 - line1 + 1;\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start.lnum = n + 1;\n\tcurbuf->b_op_end.lnum = n + count;\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    }\n\n    if (u_save(n, n + 1) == FAIL)\n\treturn;\n\n    curwin->w_cursor.lnum = n;\n    while (line1 <= line2)\n    {\n\tp = vim_strsave(ml_get(line1));\n\tif (p != NULL)\n\t{\n\t    ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, FALSE);\n\t    vim_free(p);\n\t}\n\tif (line1 == n)\n\t    line1 = curwin->w_cursor.lnum;\n\t++line1;\n\tif (curwin->w_cursor.lnum < line1)\n\t    ++line1;\n\tif (curwin->w_cursor.lnum < line2)\n\t    ++line2;\n\t++curwin->w_cursor.lnum;\n    }\n\n    appended_lines_mark(n, count);\n    if (VIsual_active)\n\tcheck_pos(curbuf, &VIsual);\n\n    msgmore((long)count);\n}",
        "output": "0",
        "idx": 7967
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void sem_lock_and_putref(struct sem_array *sma)\n{\n\tipc_lock_by_ptr(&sma->sem_perm);\n\tipc_rcu_putref(sma);\n}",
        "output": "1",
        "idx": 2250
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_cmd (xd3_stream *stream, const char *buf)\n{\n  int ret;\n  if ((ret = system (buf)) != 0)\n    {\n      if (WIFEXITED (ret))\n\t{\n\t  stream->msg = \"command exited non-zero\";\n\t  IF_DEBUG1 (XPR(NT \"command was: %s\\n\", buf));\n\t}\n      else\n\t{\n\t  stream->msg = \"abnormal command termination\";\n\t}\n      return ret;\n    }\n  return 0;\n}",
        "output": "0",
        "idx": 7107
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n\n  while (new_len > string->space)\n    {\n      if (string->space == 0)\n\t{\n\t  string->space = 4;\n\t}\n      else\n\t{\n\t  const guint max_space =\n\t    MIN (G_MAXINT, G_MAXSIZE / MAX (sizeof(PangoGlyphInfo), sizeof(gint)));\n\n\t  guint more_space = (guint)string->space * 2;\n\n\t  if (more_space > max_space)\n\t    {\n\t      more_space = max_space;\n\n\t      if ((guint)new_len > max_space)\n\t\t{\n\t\t  g_error (\"%s: failed to allocate glyph string of length %i\\n\",\n\t\t\t   G_STRLOC, new_len);\n\t\t}\n\t    }\n\n\t  string->space = more_space;\n\t}\n    }\n\n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}",
        "output": "0",
        "idx": 4639
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mongo_pass_digest( const char *user, const char *pass, char hex_digest[33] ) {\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )\":mongo:\", 7 );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )pass, strlen( pass ) );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n}",
        "output": "1",
        "idx": 7912
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void lateeoi_list_del(struct irq_info *info)\n{\n\tstruct lateeoi_work *eoi = &per_cpu(lateeoi, info->eoi_cpu);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&eoi->eoi_list_lock, flags);\n\tlist_del_init(&info->eoi_list);\n\tspin_unlock_irqrestore(&eoi->eoi_list_lock, flags);\n}",
        "output": "0",
        "idx": 2727
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateNumber(double num)\t\t\t{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int64_t)num;}return item;}",
        "output": "0",
        "idx": 8251
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct port_buffer *get_inbuf(struct port *port)\n{\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\n\tif (port->inbuf)\n\t\treturn port->inbuf;\n\n\tbuf = virtqueue_get_buf(port->in_vq, &len);\n\tif (buf) {\n\t\tbuf->len = len;\n\t\tbuf->offset = 0;\n\t\tport->stats.bytes_received += len;\n\t}\n\treturn buf;\n}",
        "output": "1",
        "idx": 1960
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "qedi_dbg_warn(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & QEDI_LOG_WARN))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_warn(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_warn(\"[0000:00:00.0]:[%s:%d]: %pV\", func, line, &vaf);\n\nret:\n\tva_end(va);\n}",
        "output": "0",
        "idx": 4401
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void send(node_t *node, node_t *child, byte *fout) {\n\tif (node->parent) {\n\t\tsend(node->parent, node, fout);\n\t}\n\tif (child) {\n\t\tif (node->right == child) {\n\t\t\tadd_bit(1, fout);\n\t\t} else {\n\t\t\tadd_bit(0, fout);\n\t\t}\n\t}\n}",
        "output": "1",
        "idx": 6230
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_archive_write_data(struct archive *_a, const void *buff, size_t s)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tconst size_t max_write = INT_MAX;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_DATA, \"archive_write_data\");\n\tif (s > max_write)\n\t\ts = max_write;\n\tarchive_clear_error(&a->archive);\n\treturn ((a->format_write_data)(a, buff, s));\n}",
        "output": "0",
        "idx": 5209
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hashtable_do_rehash(hashtable_t *hashtable)\n{\n    list_t *list, *next;\n    pair_t *pair;\n    size_t i, index, new_size;\n\n    jsonp_free(hashtable->buckets);\n\n    hashtable->num_buckets++;\n    new_size = num_buckets(hashtable);\n\n    hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n    if(!hashtable->buckets)\n        return -1;\n\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n\n    list = hashtable->list.next;\n    list_init(&hashtable->list);\n\n    for(; list != &hashtable->list; list = next) {\n        next = list->next;\n        pair = list_to_pair(list);\n        index = pair->hash % new_size;\n        insert_to_bucket(hashtable, &hashtable->buckets[index], &pair->list);\n    }\n\n    return 0;\n}",
        "output": "1",
        "idx": 4312
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t aio_setup_single_vector(struct kiocb *kiocb,\n\t\t\t\t       int rw, char __user *buf,\n\t\t\t\t       unsigned long *nr_segs,\n\t\t\t\t       size_t len,\n\t\t\t\t       struct iovec *iovec,\n\t\t\t\t       struct iov_iter *iter)\n{\n\tif (len > MAX_RW_COUNT)\n\t\tlen = MAX_RW_COUNT;\n\tif (unlikely(!access_ok(!rw, buf, len)))\n\t\treturn -EFAULT;\n\n\tiovec->iov_base = buf;\n\tiovec->iov_len = len;\n\t*nr_segs = 1;\n\tiov_iter_init(iter, rw, iovec, *nr_segs, len);\n\treturn 0;\n}",
        "output": "0",
        "idx": 3921
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int get_evtchn_to_irq(evtchn_port_t evtchn)\n{\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -1;\n\tif (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)\n\t\treturn -1;\n\treturn READ_ONCE(evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)]);\n}",
        "output": "0",
        "idx": 2715
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool key_is_instantiated(const struct key *key)\n{\n\treturn test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t!test_bit(KEY_FLAG_NEGATIVE, &key->flags);\n}",
        "output": "1",
        "idx": 1710
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct clock_source *dce100_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "output": "0",
        "idx": 4515
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u32 seq_scale(u32 seq)\n{\n\treturn seq + (ktime_to_ns(ktime_get_real()) >> 6);\n}",
        "output": "0",
        "idx": 789
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}",
        "output": "0",
        "idx": 8307
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_open(const char *path)\n{\n\tint fd = open(path, O_RDONLY);\n\tif (fd >= 0) {\n\t\tfprintf(stderr, \"leak at open of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at open of %s: errno was %d\\n\", path, errno);\n\t\texit(1);\n\t}\n}",
        "output": "0",
        "idx": 7297
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ceph_x_proc_ticket_reply(struct ceph_auth_client *ac,\n\t\t\t\t    struct ceph_crypto_key *secret,\n\t\t\t\t    void *buf, void *end)\n{\n\tvoid *p = buf;\n\tchar *dbuf;\n\tchar *ticket_buf;\n\tu8 reply_struct_v;\n\tu32 num;\n\tint ret;\n\n\tdbuf = kmalloc(TEMP_TICKET_BUF_LEN, GFP_NOFS);\n\tif (!dbuf)\n\t\treturn -ENOMEM;\n\n\tret = -ENOMEM;\n\tticket_buf = kmalloc(TEMP_TICKET_BUF_LEN, GFP_NOFS);\n\tif (!ticket_buf)\n\t\tgoto out_dbuf;\n\n\tceph_decode_8_safe(&p, end, reply_struct_v, bad);\n\tif (reply_struct_v != 1)\n\t\treturn -EINVAL;\n\n\tceph_decode_32_safe(&p, end, num, bad);\n\tdout(\"%d tickets\\n\", num);\n\n\twhile (num--) {\n\t\tret = process_one_ticket(ac, secret, &p, end,\n\t\t\t\t\t dbuf, ticket_buf);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tkfree(ticket_buf);\nout_dbuf:\n\tkfree(dbuf);\n\treturn ret;\n\nbad:\n\tret = -EINVAL;\n\tgoto out;\n}",
        "output": "1",
        "idx": 2660
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void addParamsFromBuf(HttpConn *conn, cchar *buf, ssize len)\n{\n    MprJson     *params, *prior;\n    char        *newValue, *decoded, *keyword, *value, *tok;\n\n    assert(conn);\n    params = httpGetParams(conn);\n    decoded = mprAlloc(len + 1);\n    decoded[len] = '\\0';\n    memcpy(decoded, buf, len);\n\n    keyword = stok(decoded, \"&\", &tok);\n    while (keyword != 0) {\n        if ((value = strchr(keyword, '=')) != 0) {\n            *value++ = '\\0';\n            value = mprUriDecode(value);\n        } else {\n            value = MPR->emptyString;\n        }\n        keyword = mprUriDecode(keyword);\n        if (*keyword) {\n            prior = mprReadJsonObj(params, keyword);\n#if ME_EJS_PRODUCT\n            if (prior && prior->type == MPR_JSON_VALUE) {\n                if (*value) {\n                    newValue = sjoin(prior->value, \" \", value, NULL);\n                    mprSetJson(params, keyword, newValue);\n                }\n            } else {\n                mprSetJson(params, keyword, value);\n            }\n#else\n            if (prior && prior->type == MPR_JSON_VALUE) {\n                if (*value) {\n                    newValue = sjoin(prior->value, \" \", value, NULL);\n                    mprWriteJson(params, keyword, newValue);\n                }\n            } else {\n                mprWriteJson(params, keyword, value);\n            }\n#endif\n        }\n        keyword = stok(0, \"&\", &tok);\n    }\n}",
        "output": "0",
        "idx": 7035
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int gup_huge_pgd(pgd_t orig, pgd_t *pgdp, unsigned long addr,\n\t\t\tunsigned long end, int write,\n\t\t\tstruct page **pages, int *nr)\n{\n\tint refs;\n\tstruct page *head, *page;\n\n\tif (!pgd_access_permitted(orig, write))\n\t\treturn 0;\n\n\tBUILD_BUG_ON(pgd_devmap(orig));\n\trefs = 0;\n\tpage = pgd_page(orig) + ((addr & ~PGDIR_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\thead = compound_head(pgd_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(pgd_val(orig) != pgd_val(*pgdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\n\tSetPageReferenced(head);\n\treturn 1;\n}",
        "output": "1",
        "idx": 3146
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cJSON_Minify(char *json)\n{\n\tchar *into=json;\n\twhile (*json)\n\t{\n\t\tif (*json==' ') json++;\n\t\telse if (*json=='\\t') json++;\t\n\t\telse if (*json=='\\r') json++;\n\t\telse if (*json=='\\n') json++;\n\t\telse if (*json=='/' && json[1]=='/')  while (*json && *json!='\\n') json++;\t\n\t\telse if (*json=='/' && json[1]=='*') {while (*json && !(*json=='*' && json[1]=='/')) json++;json+=2;}\t\n\t\telse if (*json=='\\\"'){*into++=*json++;while (*json && *json!='\\\"'){if (*json=='\\\\') *into++=*json++;*into++=*json++;}*into++=*json++;} \n\t\telse *into++=*json++;\t\t\t\n\t}\n\t*into=0;\t\n}",
        "output": "0",
        "idx": 8273
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int my_redel(const char *org_name, const char *tmp_name, myf MyFlags)\n{\n  int error=1;\n  DBUG_ENTER(\"my_redel\");\n  DBUG_PRINT(\"my\",(\"org_name: '%s' tmp_name: '%s'  MyFlags: %d\",\n\t\t   org_name,tmp_name,MyFlags));\n\n  if (my_copystat(org_name,tmp_name,MyFlags) < 0)\n    goto end;\n  if (MyFlags & MY_REDEL_MAKE_BACKUP)\n  {\n    char name_buff[FN_REFLEN+20];    \n    char ext[20];\n    ext[0]='-';\n    get_date(ext+1,2+4,(time_t) 0);\n    strmov(strend(ext),REDEL_EXT);\n    if (my_rename(org_name, fn_format(name_buff, org_name, \"\", ext, 2),\n\t\t  MyFlags))\n      goto end;\n  }\n  else if (my_delete_allow_opened(org_name, MyFlags))\n      goto end;\n  if (my_rename(tmp_name,org_name,MyFlags))\n    goto end;\n\n  error=0;\nend:\n  DBUG_RETURN(error);\n} ",
        "output": "1",
        "idx": 5254
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void init_fs_pin(struct fs_pin *p, void (*kill)(struct fs_pin *))\n{\n\tinit_waitqueue_head(&p->wait);\n\tINIT_HLIST_NODE(&p->s_list);\n\tINIT_HLIST_NODE(&p->m_list);\n\tp->kill = kill;\n}",
        "output": "0",
        "idx": 3905
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iakerb_gss_get_mic_iov_length(OM_uint32 *minor_status,\n                              gss_ctx_id_t context_handle, gss_qop_t qop_req,\n                              gss_iov_buffer_desc *iov, int iov_count)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_get_mic_iov_length(minor_status, ctx->gssc, qop_req, iov,\n                                       iov_count);\n}",
        "output": "0",
        "idx": 163
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n{\n    pair_t *pair;\n    size_t hash;\n    bucket_t *bucket;\n\n    hash = hash_str(key);\n    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return NULL;\n\n    return &pair->list;\n}",
        "output": "1",
        "idx": 4322
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EACCES;\n\n\tpath_put(&nd->path);\n\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\n\terror = PROC_I(inode)->op.proc_get_link(inode, &nd->path);\n\tnd->last_type = LAST_BIND;\nout:\n\treturn ERR_PTR(error);\n}",
        "output": "1",
        "idx": 2198
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int update_alu_sanitation_state(struct bpf_insn_aux_data *aux,\n\t\t\t\t       u32 alu_state, u32 alu_limit)\n{\n\tif (aux->alu_state &&\n\t    (aux->alu_state != alu_state ||\n\t     aux->alu_limit != alu_limit))\n\t\treturn -EACCES;\n\n\taux->alu_state = alu_state;\n\taux->alu_limit = alu_limit;\n\treturn 0;\n}",
        "output": "0",
        "idx": 4223
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mutex_lock_double(struct mutex *a, struct mutex *b)\n{\n\tif (b < a)\n\t\tswap(a, b);\n\n\tmutex_lock(a);\n\tmutex_lock_nested(b, SINGLE_DEPTH_NESTING);\n}",
        "output": "0",
        "idx": 3837
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_visual_text(\n    cmdarg_T\t*cap,\n    char_u\t**pp,\t    \n    int\t\t*lenp)\t    \n{\n    if (VIsual_mode != 'V')\n\tunadjust_for_sel();\n    if (VIsual.lnum != curwin->w_cursor.lnum)\n    {\n\tif (cap != NULL)\n\t    clearopbeep(cap->oap);\n\treturn FAIL;\n    }\n    if (VIsual_mode == 'V')\n    {\n\t*pp = ml_get_curline();\n\t*lenp = (int)STRLEN(*pp);\n    }\n    else\n    {\n\tif (LT_POS(curwin->w_cursor, VIsual))\n\t{\n\t    *pp = ml_get_pos(&curwin->w_cursor);\n\t    *lenp = VIsual.col - curwin->w_cursor.col + 1;\n\t}\n\telse\n\t{\n\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (**pp == NUL)\n\t    *lenp = 0;\n\tif (*lenp > 0)\n\t{\n\t    if (has_mbyte)\n\t\t*lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n\t    else if ((*pp)[*lenp - 1] == NUL)\n\t\t*lenp -= 1;\n\t}\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}",
        "output": "0",
        "idx": 8031
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int wait_for_key_construction(struct key *key, bool intr)\n{\n\tint ret;\n\n\tret = wait_on_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT,\n\t\t\t  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\tif (ret)\n\t\treturn -ERESTARTSYS;\n\tret = key_read_state(key);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn key_validate(key);\n}",
        "output": "0",
        "idx": 2511
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\n\tstrncpy(rblkcipher.type, \"blkcipher\", sizeof(rblkcipher.type));\n\tstrncpy(rblkcipher.geniv, alg->cra_blkcipher.geniv ?: \"<default>\",\n\t\tsizeof(rblkcipher.geniv));\n\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_blkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_blkcipher.ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "0",
        "idx": 1179
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void consume_one_event(unsigned cpu, struct evtchn_loop_ctrl *ctrl,\n\t\t\t      struct evtchn_fifo_control_block *control_block,\n\t\t\t      unsigned priority, unsigned long *ready)\n{\n\tstruct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);\n\tuint32_t head;\n\tevtchn_port_t port;\n\tevent_word_t *word;\n\n\thead = q->head[priority];\n\n\tif (head == 0) {\n\t\tvirt_rmb(); \n\t\thead = control_block->head[priority];\n\t}\n\n\tport = head;\n\tword = event_word_from_port(port);\n\thead = clear_linked(word);\n\n\tif (head == 0)\n\t\tclear_bit(priority, ready);\n\n\tif (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port)) {\n\t\tif (unlikely(!ctrl))\n\t\t\tpr_warn(\"Dropping pending event for port %u\\n\", port);\n\t\telse\n\t\t\thandle_irq_for_port(port, ctrl);\n\t}\n\n\tq->head[priority] = head;\n}",
        "output": "0",
        "idx": 2749
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BITMAP_UPDATE* update_read_bitmap_update(rdpUpdate* update, wStream* s)\n{\n\tUINT32 i;\n\tBITMAP_UPDATE* bitmapUpdate = calloc(1, sizeof(BITMAP_UPDATE));\n\n\tif (!bitmapUpdate)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, bitmapUpdate->number); \n\tWLog_Print(update->log, WLOG_TRACE, \"BitmapUpdate: %\"PRIu32\"\", bitmapUpdate->number);\n\n\tif (bitmapUpdate->number > bitmapUpdate->count)\n\t{\n\t\tUINT32 count = bitmapUpdate->number * 2;\n\t\tBITMAP_DATA* newdata = (BITMAP_DATA*) realloc(bitmapUpdate->rectangles,\n\t\t                       sizeof(BITMAP_DATA) * count);\n\n\t\tif (!newdata)\n\t\t\tgoto fail;\n\n\t\tbitmapUpdate->rectangles = newdata;\n\t\tZeroMemory(&bitmapUpdate->rectangles[bitmapUpdate->count],\n\t\t           sizeof(BITMAP_DATA) * (count - bitmapUpdate->count));\n\t\tbitmapUpdate->count = count;\n\t}\n\n\tfor (i = 0; i < bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_read_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\tgoto fail;\n\t}\n\n\treturn bitmapUpdate;\nfail:\n\tfree_bitmap_update(update->context, bitmapUpdate);\n\treturn NULL;\n}",
        "output": "0",
        "idx": 5811
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void sas_unregister_dev(struct asd_sas_port *port, struct domain_device *dev)\n{\n\tif (!test_bit(SAS_DEV_DESTROY, &dev->state) &&\n\t    !list_empty(&dev->disco_list_node)) {\n\t\tlist_del_init(&dev->disco_list_node);\n\t\tsas_rphy_free(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t\treturn;\n\t}\n\n\tif (!test_and_set_bit(SAS_DEV_DESTROY, &dev->state)) {\n\t\tsas_rphy_unlink(dev->rphy);\n\t\tlist_move_tail(&dev->disco_list_node, &port->destroy_list);\n\t\tsas_discover_event(dev->port, DISCE_DESTRUCT);\n\t}\n}",
        "output": "1",
        "idx": 1826
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mrb_obj_clone(mrb_state *mrb, mrb_value self)\n{\n  struct RObject *p;\n  mrb_value clone;\n\n  if (mrb_immediate_p(self)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't clone %S\", self);\n  }\n  if (mrb_type(self) == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't clone singleton class\");\n  }\n  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));\n  p->c = mrb_singleton_class_clone(mrb, self);\n  mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n  clone = mrb_obj_value(p);\n  init_copy(mrb, clone, self);\n  p->flags = mrb_obj_ptr(self)->flags;\n\n  return clone;\n}",
        "output": "1",
        "idx": 6714
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NOEXPORT int parse_socket_error(CLI *c, const char *text) {\n    switch(get_last_socket_error()) {\n        /* http:\n    case 0: \n#ifndef USE_WIN32\n    case EPIPE: \n#endif\n    case S_ECONNABORTED:\n        s_log(LOG_INFO, \"%s: Socket is closed\", text);\n        return 0;\n    case S_EINTR:\n        s_log(LOG_DEBUG, \"%s: Interrupted by a signal: retrying\", text);\n        return 1;\n    case S_EWOULDBLOCK:\n        s_log(LOG_NOTICE, \"%s: Would block: retrying\", text);\n        s_poll_sleep(1, 0); \n        return 1;\n#if S_EAGAIN!=S_EWOULDBLOCK\n    case S_EAGAIN:\n        s_log(LOG_DEBUG,\n            \"%s: Temporary lack of resources: retrying\", text);\n        return 1;\n#endif\n#ifdef USE_WIN32\n    case S_ECONNRESET:\n        if(c->opt->exec_name) {\n            s_log(LOG_INFO, \"%s: Socket is closed (exec)\", text);\n            return 0;\n        }\n#endif\n    default:\n        sockerror(text);\n        throw_exception(c, 1);\n        return -1; \n    }\n}",
        "output": "1",
        "idx": 8432
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_19current_buffer_size_2__set__(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self, PyObject *__pyx_v_value) {\n  int __pyx_r;\n  __Pyx_RefNannyDeclarations\n  Py_ssize_t __pyx_t_1;\n  __Pyx_RefNannySetupContext(\"__set__\", 0);\n  __pyx_t_1 = __Pyx_PyIndex_AsSsize_t(__pyx_v_value); if (unlikely((__pyx_t_1 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 11, __pyx_L1_error)\n  __pyx_v_self->current_buffer_size = __pyx_t_1;\n\n  __pyx_r = 0;\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedReader.current_buffer_size.__set__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = -1;\n  __pyx_L0:;\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}",
        "output": "1",
        "idx": 8310
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct clock_source *dcn20_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dcn20_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "output": "0",
        "idx": 4527
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "INST_HANDLER (sbrx) {\t\n\tint b = buf[0] & 0x7;\n\tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);\n\tRAnalOp next_op;\n\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\n\top->cycles = 1;\t\n\tESIL_A (\"%d,1,<<,r%d,&,\", b, r);\t\t\t\n\tESIL_A ((buf[1] & 0xe) == 0xc\n\t\t\t? \"!,\"\t\t\n\t\t\t: \"!,!,\");\t\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t\n}",
        "output": "1",
        "idx": 6186
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_proxy_auth_id_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\tND_PRINT((ndo, \"%u\", EXTRACT_16BITS(ptr) & L2TP_PROXY_AUTH_ID_MASK));\n}",
        "output": "1",
        "idx": 4752
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(RecursiveDirectoryIterator, getSubPath)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (intern->u.dir.sub_path) {\n\t\tRETURN_STRINGL(intern->u.dir.sub_path, intern->u.dir.sub_path_len, 1);\n\t} else {\n\t\tRETURN_STRINGL(\"\", 0, 1);\n\t}\n}",
        "output": "0",
        "idx": 5581
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error = 0;\n\n\tif (!acl)\n\t\tgoto set_acl;\n\n\terror = -E2BIG;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\n\t\treturn error;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode;\n\n\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_set_mode(inode, mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n set_acl:\n\treturn __xfs_set_acl(inode, type, acl);\n}",
        "output": "0",
        "idx": 1961
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sunkbd_reinit(struct work_struct *work)\n{\n\tstruct sunkbd *sunkbd = container_of(work, struct sunkbd, tq);\n\n\twait_event_interruptible_timeout(sunkbd->wait,\n\t\t\t\t\t sunkbd->reset >= 0 || !sunkbd->enabled,\n\t\t\t\t\t HZ);\n\n\tif (sunkbd->reset >= 0 && sunkbd->enabled)\n\t\tsunkbd_set_leds_beeps(sunkbd);\n}",
        "output": "0",
        "idx": 2759
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tint err;\n\tstruct sock_diag_req *req = nlmsg_data(nlh);\n\tconst struct sock_diag_handler *hndl;\n\n\tif (nlmsg_len(nlh) < sizeof(*req))\n\t\treturn -EINVAL;\n\n\tif (req->sdiag_family >= AF_MAX)\n\t\treturn -EINVAL;\n\n\thndl = sock_diag_lock_handler(req->sdiag_family);\n\tif (hndl == NULL)\n\t\terr = -ENOENT;\n\telse\n\t\terr = hndl->dump(skb, nlh);\n\tsock_diag_unlock_handler(hndl);\n\n\treturn err;\n}",
        "output": "0",
        "idx": 1195
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int evm_update_evmxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\tconst char *xattr_value, size_t xattr_value_len)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct evm_ima_xattr_data xattr_data;\n\tint rc = 0;\n\n\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t   xattr_value_len, xattr_data.digest);\n\tif (rc == 0) {\n\t\txattr_data.type = EVM_XATTR_HMAC;\n\t\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,\n\t\t\t\t\t   &xattr_data,\n\t\t\t\t\t   sizeof(xattr_data), 0);\n\t}\n\telse if (rc == -ENODATA)\n\t\trc = inode->i_op->removexattr(dentry, XATTR_NAME_EVM);\n\treturn rc;\n}",
        "output": "1",
        "idx": 814
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool checkCurl() {\n\tconst char nul[] = R_SYS_DEVNULL;\n\tif (r_sys_cmdf (\"curl --version > %s\", nul) != 0) {\n\t\treturn false;\n\t}\n\treturn true;\n}",
        "output": "1",
        "idx": 6408
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void altivec_unavailable_exception(struct pt_regs *regs)\n{\n\tif (user_mode(regs)) {\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\treturn;\n\t}\n\n\tprintk(KERN_EMERG \"Unrecoverable VMX/Altivec Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable VMX/Altivec Unavailable Exception\", regs, SIGABRT);\n}",
        "output": "0",
        "idx": 2975
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "isis_print_id(const uint8_t *cp, int id_len)\n{\n    int i;\n    static char id[sizeof(\"xxxx.xxxx.xxxx.yy-zz\")];\n    char *pos = id;\n    int sysid_len;\n\n    sysid_len = SYSTEM_ID_LEN;\n    if (sysid_len > id_len)\n        sysid_len = id_len;\n    for (i = 1; i <= sysid_len; i++) {\n        snprintf(pos, sizeof(id) - (pos - id), \"%02x\", *cp++);\n\tpos += strlen(pos);\n\tif (i == 2 || i == 4)\n\t    *pos++ = '.';\n\t}\n    if (id_len >= NODE_ID_LEN) {\n        snprintf(pos, sizeof(id) - (pos - id), \".%02x\", *cp++);\n\tpos += strlen(pos);\n    }\n    if (id_len == LSP_ID_LEN)\n        snprintf(pos, sizeof(id) - (pos - id), \"-%02x\", *cp);\n    return (id);\n}",
        "output": "0",
        "idx": 6757
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct resource_pool *dcn10_create_resource_pool(\n\t\tconst struct dc_init_data *init_data,\n\t\tstruct dc *dc)\n{\n\tstruct dcn10_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(init_data->num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "output": "0",
        "idx": 4485
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static freelist_idx_t next_random_slot(union freelist_init_state *state)\n{\n\treturn (state->list[state->pos++] + state->rand) % state->count;\n}",
        "output": "1",
        "idx": 1414
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tbuf->ops->get(pipe, buf);\n}",
        "output": "1",
        "idx": 3168
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __mb2_cache_entry_free(struct mb2_cache_entry *entry)\n{\n\tkmem_cache_free(mb2_entry_cache, entry);\n}",
        "output": "0",
        "idx": 1605
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main() {\n  int selftest;\n\n  MSPACK_SYS_SELFTEST(selftest);\n  TEST(selftest == MSPACK_ERR_OK);\n\n  kwajd_open_test_01();\n\n  printf(\"ALL %d TESTS PASSED.\\n\", test_count);\n  return 0;\n}",
        "output": "0",
        "idx": 7427
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *url_decode_r(char *to, char *url, size_t size) {\n    char *s = url,           \n         *d = to,            \n         *e = &to[size - 1]; \n\n    while(*s && d < e) {\n        if(unlikely(*s == '%')) {\n            if(likely(s[1] && s[2])) {\n                *d++ = from_hex(s[1]) << 4 | from_hex(s[2]);\n                s += 2;\n            }\n        }\n        else if(unlikely(*s == '+'))\n            *d++ = ' ';\n\n        else\n            *d++ = *s;\n\n        s++;\n    }\n\n    *d = '\\0';\n\n    return to;\n}",
        "output": "1",
        "idx": 7076
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cib_remote_auth(xmlNode *login)\n{\n    const char *user = NULL;\n    const char *pass = NULL;\n    const char *tmp = NULL;\n\n    crm_log_xml_info(login, \"Login: \");\n    if (login == NULL) {\n        return FALSE;\n    }\n\n    tmp = crm_element_name(login);\n    if (safe_str_neq(tmp, \"cib_command\")) {\n        crm_err(\"Wrong tag: %s\", tmp);\n        return FALSE;\n    }\n\n    tmp = crm_element_value(login, \"op\");\n    if (safe_str_neq(tmp, \"authenticate\")) {\n        crm_err(\"Wrong operation: %s\", tmp);\n        return FALSE;\n    }\n\n    user = crm_element_value(login, \"user\");\n    pass = crm_element_value(login, \"password\");\n\n    if (!user || !pass) {\n        crm_err(\"missing auth credentials\");\n        return FALSE;\n    }\n\n    if (check_group_membership(user, CRM_DAEMON_GROUP) == FALSE) {\n        crm_err(\"User is not a member of the required group\");\n        return FALSE;\n\n    } else if (authenticate_user(user, pass) == FALSE) {\n        crm_err(\"PAM auth failed\");\n        return FALSE;\n    }\n\n    return TRUE;\n}",
        "output": "0",
        "idx": 5221
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rawsock_create(struct net *net, struct socket *sock,\n\t\t\t  const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\n\tpr_debug(\"sock=%p\\n\", sock);\n\n\tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW) {\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tsock->ops = &rawsock_raw_ops;\n\t} else {\n\t\tsock->ops = &rawsock_ops;\n\t}\n\n\tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsk->sk_protocol = nfc_proto->id;\n\tsk->sk_destruct = rawsock_destruct;\n\tsock->state = SS_UNCONNECTED;\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_sock_link(&raw_sk_list, sk);\n\telse {\n\t\tINIT_WORK(&nfc_rawsock(sk)->tx_work, rawsock_tx_work);\n\t\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\t}\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2703
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vim_isalpha(int c)\n{\n    return vim_islower(c) || vim_isupper(c);\n}",
        "output": "0",
        "idx": 7997
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "print_arrays_for(char *set)\n{\n  FILE *f;\n\n  sprintf(buf, \"%s.conf\", set);\n\n  if ((f = fopen(buf, \"r\")) == NULL) {\n    fprintf(stderr, \"%s: can't read conf file for charset %s\\n\", prog, set);\n    exit(EXIT_FAILURE);\n  }\n\n  printf(\"\\\n\\n\\n\",\n\t set, prog);\n\n  print_array(f, set, \"ctype\",      CTYPE_TABLE_SIZE);\n  print_array(f, set, \"to_lower\",   TO_LOWER_TABLE_SIZE);\n  print_array(f, set, \"to_upper\",   TO_UPPER_TABLE_SIZE);\n  print_array(f, set, \"sort_order\", SORT_ORDER_TABLE_SIZE);\n  printf(\"\\n\");\n\n  fclose(f);\n\n  return;\n}",
        "output": "1",
        "idx": 5248
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_TIFFmalloc(tsize_t s)\n{\n        if (s == 0)\n                return ((void *) NULL);\n\n\treturn (malloc((size_t) s));\n}",
        "output": "0",
        "idx": 5855
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "AsyncFor(expr_ty target, expr_ty iter, asdl_seq * body, asdl_seq * orelse, int\n         lineno, int col_offset, int end_lineno, int end_col_offset, PyArena\n         *arena)\n{\n    stmt_ty p;\n    if (!target) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field target is required for AsyncFor\");\n        return NULL;\n    }\n    if (!iter) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field iter is required for AsyncFor\");\n        return NULL;\n    }\n    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->kind = AsyncFor_kind;\n    p->v.AsyncFor.target = target;\n    p->v.AsyncFor.iter = iter;\n    p->v.AsyncFor.body = body;\n    p->v.AsyncFor.orelse = orelse;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    p->end_lineno = end_lineno;\n    p->end_col_offset = end_col_offset;\n    return p;\n}",
        "output": "1",
        "idx": 7174
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int has_rdrand()\n{\n    int regs[4];\n    do_cpuid(regs, 1);\n    return (regs[2] & (1 << 30)) != 0;\n}",
        "output": "0",
        "idx": 5965
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mount_proc_if_needed(const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tchar link[20];\n\tint linklen, ret;\n\tint mypid;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc/self\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tmemset(link, 0, 20);\n\tlinklen = readlink(path, link, 20);\n\tmypid = (int)getpid();\n\tINFO(\"I am %d, /proc/self points to '%s'\", mypid, link);\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tif (linklen < 0) \n\t\tgoto domount;\n\tif (atoi(link) != mypid) {\n\t\tumount2(path, MNT_DETACH); \n\t\tgoto domount;\n\t}\n\treturn 0;\n\ndomount:\n\tif (mount(\"proc\", path, \"proc\", 0, NULL))\n\t\treturn -1;\n\tINFO(\"Mounted /proc in container for security transition\");\n\treturn 1;\n}",
        "output": "1",
        "idx": 4376
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool _valid_hex(char *s, const char *file, const char *func, const int line)\n{\n\tbool ret = false;\n\tint i, len;\n\n\tif (unlikely(!s)) {\n\t\tapplog(LOG_ERR, \"Null string passed to valid_hex from\"IN_FMT_FFL, file, func, line);\n\t\treturn ret;\n\t}\n\tlen = strlen(s);\n\tif (unlikely(!len)) {\n\t\tapplog(LOG_ERR, \"Zero length string passed to valid_hex from\"IN_FMT_FFL, file, func, line);\n\t\treturn ret;\n\t}\n\tfor (i = 0; i < len; i++) {\n\t\tunsigned char idx = s[i];\n\n\t\tif (unlikely(hex2bin_tbl[idx] < 0)) {\n\t\t\tapplog(LOG_ERR, \"Invalid char %x passed to valid_hex from\"IN_FMT_FFL, idx, file, func, line);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = true;\n\treturn ret;\n}",
        "output": "0",
        "idx": 6421
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jsi_wsGetHeaders(jsi_wsPss *pss, struct lws *wsi, Jsi_DString* dStr, int lens[], int hmax)\n{\n    int n = 0, i = 0, nlen;\n    char buf[1000];\n    const char *cp;\n    while ((cp = (char*)lws_token_to_string((enum lws_token_indexes)n))) {\n        int len = lws_hdr_copy(wsi, buf, sizeof(buf), ( enum lws_token_indexes)n);\n        n++;\n        if (i>=(n*2+2)) break;\n        if (len<=0) continue;\n        buf[sizeof(buf)-1] = 0;\n        if (!buf[0]) continue;\n        nlen = Jsi_Strlen(cp);\n        if (nlen>0 && cp[nlen-1]==' ') nlen--;\n        if (nlen>0 && cp[nlen-1]==':') nlen--;\n        Jsi_DSAppendLen(dStr, cp, nlen);\n        Jsi_DSAppend(dStr, \"=\", buf, \"\\n\", NULL);\n        if (lens) {\n            lens[i++] = nlen;\n            lens[i++] = Jsi_Strlen(buf);\n        }\n    }\n    return i;\n}",
        "output": "1",
        "idx": 8226
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jas_iccgetuint64(jas_stream_t *in, jas_iccuint64_t *val)\n{\n\tjas_ulonglong tmp;\n\tif (jas_iccgetuint(in, 8, &tmp))\n\t\treturn -1;\n\t*val = tmp;\n\treturn 0;\n}",
        "output": "0",
        "idx": 7553
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));\n\tkvm_pit_load_count(kvm, 0, ps->channels[0].count, 0);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn 0;\n}",
        "output": "1",
        "idx": 1002
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void big_key_describe(const struct key *key, struct seq_file *m)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\n\tseq_puts(m, key->description);\n\n\tif (key_is_positive(key))\n\t\tseq_printf(m, \": %zu [%s]\",\n\t\t\t   datalen,\n\t\t\t   datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");\n}",
        "output": "0",
        "idx": 2483
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bittok2str_internal(register const struct tok *lp, register const char *fmt,\n\t   register u_int v, const char *sep)\n{\n        static char buf[1024+1]; \n        char *bufp = buf;\n        size_t space_left = sizeof(buf), string_size;\n        register u_int rotbit; \n        register u_int tokval;\n        const char * sepstr = \"\";\n\n\twhile (lp != NULL && lp->s != NULL) {\n            tokval=lp->v;   \n            rotbit=1;\n            while (rotbit != 0) {\n\t\tif (tokval == (v&rotbit)) {\n                    if (space_left <= 1)\n                        return (buf); \n                    string_size = strlcpy(bufp, sepstr, space_left);\n                    if (string_size >= space_left)\n                        return (buf);    \n                    bufp += string_size;\n                    space_left -= string_size;\n                    if (space_left <= 1)\n                        return (buf); \n                    string_size = strlcpy(bufp, lp->s, space_left);\n                    if (string_size >= space_left)\n                        return (buf);    \n                    bufp += string_size;\n                    space_left -= string_size;\n                    sepstr = sep;\n                    break;\n                }\n                rotbit=rotbit<<1; \n            }\n            lp++;\n\t}\n\n        if (bufp == buf)\n            (void)snprintf(buf, sizeof(buf), fmt == NULL ? \"#%08x\" : fmt, v);\n        return (buf);\n}",
        "output": "0",
        "idx": 6689
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *path_name(struct strbuf *path, const char *name)\n{\n\tstruct strbuf ret = STRBUF_INIT;\n\tif (path)\n\t\tstrbuf_addbuf(&ret, path);\n\tstrbuf_addstr(&ret, name);\n\treturn strbuf_detach(&ret, NULL);\n}",
        "output": "1",
        "idx": 5210
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "add_link_ref(\n\tstruct link_ref **references,\n\tconst uint8_t *name, size_t name_size)\n{\n\tstruct link_ref *ref = calloc(1, sizeof(struct link_ref));\n\n\tif (!ref)\n\t\treturn NULL;\n\n\tref->id = hash_link_ref(name, name_size);\n\tref->next = references[ref->id % REF_TABLE_SIZE];\n\n\treferences[ref->id % REF_TABLE_SIZE] = ref;\n\treturn ref;\n}",
        "output": "1",
        "idx": 8814
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int perf_swevent_add(struct perf_event *event, int flags)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct hlist_head *head;\n\n\tif (is_sampling_event(event)) {\n\t\thwc->last_period = hwc->sample_period;\n\t\tperf_swevent_set_period(event);\n\t}\n\n\thwc->state = !(flags & PERF_EF_START);\n\n\thead = find_swevent_head(swhash, event);\n\tif (!head) {\n\t\tWARN_ON_ONCE(swhash->online);\n\t\treturn -EINVAL;\n\t}\n\n\thlist_add_head_rcu(&event->hlist_entry, head);\n\tperf_event_update_userpage(event);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1016
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer)\n{\n\tif (mixer->disconnected)\n\t\treturn;\n\tif (mixer->urb)\n\t\tusb_kill_urb(mixer->urb);\n\tif (mixer->rc_urb)\n\t\tusb_kill_urb(mixer->rc_urb);\n\tmixer->disconnected = true;\n}",
        "output": "0",
        "idx": 2453
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned long lh_char_hash(const void *k)\n{\n\tunsigned int h = 0;\n\tconst char* data = (const char*)k;\n \n\twhile( *data!=0 ) h = h*129 + (unsigned int)(*data++) + LH_PRIME;\n\n\treturn h;\n}",
        "output": "1",
        "idx": 4304
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void scsi_read_complete(void * opaque, int ret)\n{\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    int n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_READ)) {\n            return;\n        }\n    }\n\n    DPRINTF(\"Data ready tag=0x%x len=%zd\\n\", r->req.tag, r->qiov.size);\n\n    n = r->qiov.size / 512;\n    r->sector += n;\n    r->sector_count -= n;\n    scsi_req_data(&r->req, r->qiov.size);\n}",
        "output": "0",
        "idx": 4995
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "exit_ext2_xattr(void)\n{\n\tmb_cache_destroy(ext2_xattr_cache);\n}",
        "output": "1",
        "idx": 1112
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct bpf_prog *bpf_prog_inc(struct bpf_prog *prog)\n{\n\tif (atomic_inc_return(&prog->aux->refcnt) > BPF_MAX_REFCNT) {\n\t\tatomic_dec(&prog->aux->refcnt);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\treturn prog;\n}",
        "output": "0",
        "idx": 1841
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ikev2_ke_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_ke ke;\n\tconst struct ikev2_ke *k;\n\n\tk = (const struct ikev2_ke *)ext;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&ke, ext, sizeof(ke));\n\tikev2_pay_print(ndo, NPSTR(tpay), ke.h.critical);\n\n\tND_PRINT((ndo,\" len=%u group=%s\", ntohs(ke.h.len) - 8,\n\t\t  STR_OR_ID(ntohs(ke.ke_group), dh_p_map)));\n\n\tif (2 < ndo->ndo_vflag && 8 < ntohs(ke.h.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(k + 1), ntohs(ke.h.len) - 8))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(ke.h.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}",
        "output": "1",
        "idx": 4870
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Jsi_RC Jsi_RegExpMatch(Jsi_Interp *interp, Jsi_Value *pattern, const char *v, int *rc, Jsi_DString *dStr)\n{\n    Jsi_Regex *re;\n    int regexec_flags = 0;\n    if (rc)\n        *rc = 0;\n    if (pattern == NULL || pattern->vt != JSI_VT_OBJECT || pattern->d.obj->ot != JSI_OT_REGEXP) \n        return Jsi_LogError(\"expected pattern\");\n    re = pattern->d.obj->d.robj;\n    regex_t *reg = &re->reg;\n    \n    regmatch_t pos = {};\n    if (dStr)\n        Jsi_DSInit(dStr);\n        \n    int r  = regexec(reg, v, 1, &pos, regexec_flags);\n\n    if (r >= REG_BADPAT) {\n        char buf[100];\n\n        regerror(r, reg, buf, sizeof(buf));\n        return Jsi_LogError(\"error while matching pattern: %s\", buf);\n    }\n    if (r != REG_NOMATCH) {\n        if (rc) *rc = 1;\n        if (dStr && pos.rm_so >= 0 && pos.rm_eo >= 0 &&  pos.rm_eo >= pos.rm_so)\n            Jsi_DSAppendLen(dStr, v + pos.rm_so, pos.rm_eo - pos.rm_so);\n    }\n    \n    return JSI_OK;\n}",
        "output": "1",
        "idx": 8206
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mt76_add_fragment(struct mt76_dev *dev, struct mt76_queue *q, void *data,\n\t\t  int len, bool more)\n{\n\tstruct page *page = virt_to_head_page(data);\n\tint offset = data - page_address(page);\n\tstruct sk_buff *skb = q->rx_head;\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\n\tif (shinfo->nr_frags < ARRAY_SIZE(shinfo->frags)) {\n\t\toffset += q->buf_offset;\n\t\tskb_add_rx_frag(skb, shinfo->nr_frags, page, offset, len,\n\t\t\t\tq->buf_size);\n\t}\n\n\tif (more)\n\t\treturn;\n\n\tq->rx_head = NULL;\n\tdev->drv->rx_skb(dev, q - dev->q_rx, skb);\n}",
        "output": "0",
        "idx": 4609
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_8position_2__set__(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self, PyObject *__pyx_v_value) {\n  int __pyx_r;\n  __Pyx_RefNannyDeclarations\n  Py_ssize_t __pyx_t_1;\n  __Pyx_RefNannySetupContext(\"__set__\", 0);\n  __pyx_t_1 = __Pyx_PyIndex_AsSsize_t(__pyx_v_value); if (unlikely((__pyx_t_1 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 11, __pyx_L1_error)\n  __pyx_v_self->position = __pyx_t_1;\n\n  __pyx_r = 0;\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedReader.position.__set__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = -1;\n  __pyx_L0:;\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}",
        "output": "1",
        "idx": 8288
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC int espLoadApp(HttpRoute *route)\n{\n#if !ME_STATIC\n    EspRoute    *eroute;\n    eroute = route->eroute;\n    if (!eroute->skipApps) {\n        MprJson     *preload, *item;\n        cchar       *errMsg, *source;\n        char        *kind;\n        int         i;\n\n        if (!loadApp(route, NULL)) {\n            return MPR_ERR_CANT_LOAD;\n        }\n        if (!route->combine && (preload = mprGetJsonObj(route->config, \"esp.preload\")) != 0) {\n            for (ITERATE_JSON(preload, item, i)) {\n                source = ssplit(sclone(item->value), \":\", &kind);\n                if (*kind == '\\0') {\n                    kind = \"controller\";\n                }\n                source = mprJoinPath(httpGetDir(route, \"controllers\"), source);\n                if (espLoadModule(route, NULL, kind, source, &errMsg) < 0) {\n                    mprLog(\"error esp\", 0, \"Cannot preload esp module %s. %s\", source, errMsg);\n                    return MPR_ERR_CANT_LOAD;\n                }\n            }\n        }\n    }\n#endif\n    return 0;\n}",
        "output": "0",
        "idx": 6969
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *ndpGetOption(uint8_t *options, size_t length, uint8_t type)\n{\n   size_t i;\n   NdpOption *option;\n\n   i = 0;\n\n   while((i + sizeof(NdpOption)) <= length)\n   {\n      option = (NdpOption *) (options + i);\n\n      if(option->length == 0)\n         break;\n      if((i + option->length * 8) > length)\n         break;\n\n      if(option->type == type || type == NDP_OPT_ANY)\n         return option;\n\n      i += option->length * 8;\n   }\n\n   return NULL;\n}",
        "output": "1",
        "idx": 8656
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_DetachItemFromObject( cJSON *object, const char *string )\n{\n\tint i = 0;\n\tcJSON *c = object->child;\n\twhile ( c && cJSON_strcasecmp( c->string, string ) ) {\n\t\t++i;\n\t\tc = c->next;\n\t}\n\tif ( c )\n\t\treturn cJSON_DetachItemFromArray( object, i );\n\treturn 0;\n}",
        "output": "1",
        "idx": 5952
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gdCtxPrintf(gdIOCtx * out, const char *format, ...)\n{\n\tchar buf[1024];\n\tint len;\n\tva_list args;\n\n\tva_start(args, format);\n\tlen = vsnprintf(buf, sizeof(buf)-1, format, args);\n\tva_end(args);\n\tout->putBuf(out, buf, len);\n}",
        "output": "0",
        "idx": 6241
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void set_header(HttpResponse res, const char *name, const char *value) {\n        HttpHeader h = NULL;\n\n        ASSERT(res);\n        ASSERT(name);\n\n        NEW(h);\n        h->name = Str_dup(name);\n        h->value = Str_dup(value);\n        if (res->headers) {\n                HttpHeader n, p;\n                for (n = p = res->headers; p; n = p, p = p->next) {\n                        if (IS(p->name, name)) {\n                                FREE(p->value);\n                                p->value = Str_dup(value);\n                                destroy_entry(h);\n                                return;\n                        }\n                }\n                n->next = h;\n        } else {\n                res->headers = h;\n        }\n}",
        "output": "1",
        "idx": 6020
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "kvm_irqfd(struct kvm *kvm, struct kvm_irqfd *args)\n{\n\tif (args->flags & ~(KVM_IRQFD_FLAG_DEASSIGN | KVM_IRQFD_FLAG_RESAMPLE))\n\t\treturn -EINVAL;\n\tif (args->gsi >= KVM_MAX_IRQ_ROUTES)\n\t\treturn -EINVAL;\n\n\tif (args->flags & KVM_IRQFD_FLAG_DEASSIGN)\n\t\treturn kvm_irqfd_deassign(kvm, args);\n\n\treturn kvm_irqfd_assign(kvm, args);\n}",
        "output": "0",
        "idx": 2391
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __xen_evtchn_do_upcall(void)\n{\n\tstruct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu);\n\tint cpu = smp_processor_id();\n\n\tread_lock(&evtchn_rwlock);\n\n\tdo {\n\t\tvcpu_info->evtchn_upcall_pending = 0;\n\n\t\txen_evtchn_handle_events(cpu);\n\n\t\tBUG_ON(!irqs_disabled());\n\n\t\tvirt_rmb(); \n\n\t} while (vcpu_info->evtchn_upcall_pending);\n\n\tread_unlock(&evtchn_rwlock);\n}",
        "output": "0",
        "idx": 2719
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void binder_deferred_fd_close(int fd)\n{\n\tstruct binder_task_work_cb *twcb;\n\n\ttwcb = kzalloc(sizeof(*twcb), GFP_KERNEL);\n\tif (!twcb)\n\t\treturn;\n\tinit_task_work(&twcb->twork, binder_do_fd_close);\n\t__close_fd_get_file(fd, &twcb->file);\n\tif (twcb->file)\n\t\ttask_work_add(current, &twcb->twork, TWA_RESUME);\n\telse\n\t\tkfree(twcb);\n}",
        "output": "1",
        "idx": 8898
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs4_xdr_enc_getacl(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tstruct nfs_getaclargs *args)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\tuint32_t replen;\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\treplen = hdr.replen + op_decode_hdr_maxsz + 1;\n\tencode_getattr_two(xdr, FATTR4_WORD0_ACL, 0, &hdr);\n\n\txdr_inline_pages(&req->rq_rcv_buf, replen << 2,\n\t\targs->acl_pages, args->acl_pgbase, args->acl_len);\n\txdr_set_scratch_buffer(xdr, page_address(args->acl_scratch), PAGE_SIZE);\n\n\tencode_nops(&hdr);\n}",
        "output": "0",
        "idx": 849
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_visual_text(\n    cmdarg_T\t*cap,\n    char_u\t**pp,\t    \n    int\t\t*lenp)\t    \n{\n    if (VIsual_mode != 'V')\n\tunadjust_for_sel();\n    if (VIsual.lnum != curwin->w_cursor.lnum)\n    {\n\tif (cap != NULL)\n\t    clearopbeep(cap->oap);\n\treturn FAIL;\n    }\n    if (VIsual_mode == 'V')\n    {\n\t*pp = ml_get_curline();\n\t*lenp = (int)STRLEN(*pp);\n    }\n    else\n    {\n\tif (LT_POS(curwin->w_cursor, VIsual))\n\t{\n\t    *pp = ml_get_pos(&curwin->w_cursor);\n\t    *lenp = VIsual.col - curwin->w_cursor.col + 1;\n\t}\n\telse\n\t{\n\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (**pp == NUL)\n\t    *lenp = 0;\n\tif (has_mbyte && *lenp > 0)\n\t    *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}",
        "output": "0",
        "idx": 7925
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int find_low_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=0;i<=31;i++) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 6642
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ppp_unregister_channel(struct ppp_channel *chan)\n{\n\tstruct channel *pch = chan->ppp;\n\tstruct ppp_net *pn;\n\n\tif (!pch)\n\t\treturn;\t\t\n\n\tchan->ppp = NULL;\n\n\tdown_write(&pch->chan_sem);\n\tspin_lock_bh(&pch->downl);\n\tpch->chan = NULL;\n\tspin_unlock_bh(&pch->downl);\n\tup_write(&pch->chan_sem);\n\tppp_disconnect_channel(pch);\n\n\tpn = ppp_pernet(pch->chan_net);\n\tspin_lock_bh(&pn->all_channels_lock);\n\tlist_del(&pch->list);\n\tspin_unlock_bh(&pn->all_channels_lock);\n\tput_net(pch->chan_net);\n\tpch->chan_net = NULL;\n\n\tpch->file.dead = 1;\n\twake_up_interruptible(&pch->file.rwait);\n\tif (atomic_dec_and_test(&pch->file.refcnt))\n\t\tppp_destroy_channel(pch);\n}",
        "output": "0",
        "idx": 1731
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t scsi_init_iovec(SCSIDiskReq *r)\n{\n    r->iov.iov_len = MIN(r->sector_count * 512, SCSI_DMA_BUF_SIZE);\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n    return r->qiov.size / 512;\n}",
        "output": "0",
        "idx": 4997
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ctcompare(const char *a,\t\t\n          const char *b)\t\t\n{\n  int\tresult = 0;\t\t\t\n\n\n  while (*a && *b)\n  {\n    result |= *a ^ *b;\n    a ++;\n    b ++;\n  }\n\n  return (result);\n}",
        "output": "1",
        "idx": 8914
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean netscreen_read(wtap *wth, int *err, gchar **err_info,\n    gint64 *data_offset)\n{\n\tgint64\t\toffset;\n\tint\t\tpkt_len;\n\tchar\t\tline[NETSCREEN_LINE_LENGTH];\n\tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\n\tgboolean\tcap_dir;\n\tchar\t\tcap_dst[13];\n\n\toffset = netscreen_seek_next_packet(wth, err, err_info, line);\n\tif (offset < 0)\n\t\treturn FALSE;\n\n\tpkt_len = parse_netscreen_rec_hdr(&wth->phdr, line, cap_int, &cap_dir,\n\t    cap_dst, err, err_info);\n\tif (pkt_len == -1)\n\t\treturn FALSE;\n\n\tif (!parse_netscreen_hex_dump(wth->fh, pkt_len, cap_int,\n\t    cap_dst, &wth->phdr, wth->frame_buffer, err, err_info))\n\t\treturn FALSE;\n\n\tif (wth->file_encap == WTAP_ENCAP_UNKNOWN)\n\t\twth->file_encap = wth->phdr.pkt_encap;\n\telse {\n\t\tif (wth->file_encap != wth->phdr.pkt_encap)\n\t\t\twth->file_encap = WTAP_ENCAP_PER_PACKET;\n\t}\n\n\t*data_offset = offset;\n\treturn TRUE;\n}",
        "output": "1",
        "idx": 5980
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmalloc(size, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,\n\t\t\t      indx, buf, size, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\telse if (ret <= size)\n\t\tmemcpy(data, buf, ret);\n\tkfree(buf);\n\treturn ret;\n}",
        "output": "0",
        "idx": 2125
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_TARGET_INDEX])\n\t\treturn -EINVAL;\n\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\n\trc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}",
        "output": "0",
        "idx": 4411
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC void httpSetParam(HttpConn *conn, cchar *var, cchar *value) \n{\n    mprSetJson(httpGetParams(conn), var, value);\n}",
        "output": "1",
        "idx": 5042
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *MACH0_(mach0_free)(struct MACH0_(obj_t) *mo) {\n\tif (!mo) {\n\t\treturn NULL;\n\t}\n\n\tsize_t i;\n\tif (mo->symbols) {\n\t\tfor (i = 0; !mo->symbols[i].last; i++) {\n\t\t\tfree (mo->symbols[i].name);\n\t\t}\n\t\tfree (mo->symbols);\n\t}\n\tfree (mo->segs);\n\tfree (mo->sects);\n\tfree (mo->symtab);\n\tfree (mo->symstr);\n\tfree (mo->indirectsyms);\n\tfree (mo->imports_by_ord);\n\tht_pp_free (mo->imports_by_name);\n\tfree (mo->dyld_info);\n\tfree (mo->toc);\n\tfree (mo->modtab);\n\tfree (mo->libs);\n\tfree (mo->func_start);\n\tfree (mo->signature);\n\tfree (mo->intrp);\n\tfree (mo->compiler);\n\tif (mo->chained_starts) {\n\t\tfor (i = 0; i < mo->nsegs; i++) {\n\t\t\tif (mo->chained_starts[i]) {\n\t\t\t\tfree (mo->chained_starts[i]->page_start);\n\t\t\t\tfree (mo->chained_starts[i]);\n\t\t\t}\n\t\t}\n\t\tfree (mo->chained_starts);\n\t}\n\tr_buf_free (mo->b);\n\tfree (mo);\n\treturn NULL;\n}",
        "output": "1",
        "idx": 6498
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ib_update_cm_av(struct ib_cm_id *id, const u8 *smac, const u8 *alt_smac)\n{\n\tstruct cm_id_private *cm_id_priv;\n\n\tcm_id_priv = container_of(id, struct cm_id_private, id);\n\n\tif (smac != NULL)\n\t\tmemcpy(cm_id_priv->av.smac, smac, sizeof(cm_id_priv->av.smac));\n\n\tif (alt_smac != NULL)\n\t\tmemcpy(cm_id_priv->alt_av.smac, alt_smac,\n\t\t       sizeof(cm_id_priv->alt_av.smac));\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 2528
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_exif_tag_int_value(struct iw_exif_state *e, unsigned int tag_pos,\n\tunsigned int *pv)\n{\n\tunsigned int field_type;\n\tunsigned int value_count;\n\n\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n\n\tif(value_count!=1) return 0;\n\n\tif(field_type==3) { \n\t\t*pv = iw_get_ui16_e(&e->d[tag_pos+8],e->endian);\n\t\treturn 1;\n\t}\n\telse if(field_type==4) { \n\t\t*pv = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 6656
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dns_resolver_match(const struct key *key,\n\t\t   const struct key_match_data *match_data)\n{\n\tint slen, dlen, ret = 0;\n\tconst char *src = key->description, *dsp = match_data->raw_data;\n\n\tkenter(\"%s,%s\", src, dsp);\n\n\tif (!src || !dsp)\n\t\tgoto no_match;\n\n\tif (strcasecmp(src, dsp) == 0)\n\t\tgoto matched;\n\n\tslen = strlen(src);\n\tdlen = strlen(dsp);\n\tif (slen <= 0 || dlen <= 0)\n\t\tgoto no_match;\n\tif (src[slen - 1] == '.')\n\t\tslen--;\n\tif (dsp[dlen - 1] == '.')\n\t\tdlen--;\n\tif (slen != dlen || strncasecmp(src, dsp, slen) != 0)\n\t\tgoto no_match;\n\nmatched:\n\tret = 1;\nno_match:\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}",
        "output": "1",
        "idx": 2672
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cdf_count_chain(const cdf_sat_t *sat, cdf_secid_t sid, size_t size)\n{\n\tsize_t i, j;\n\tcdf_secid_t maxsector = (cdf_secid_t)((sat->sat_len * size)\n\t    / sizeof(maxsector));\n\n\tDPRINTF((\"Chain:\"));\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tDPRINTF((\" %d\", sid));\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Counting chain loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\treturn (size_t)-1;\n\t\t}\n\t\tif (sid >= maxsector) {\n\t\t\tDPRINTF((\"Sector %d >= %d\\n\", sid, maxsector));\n\t\t\terrno = EFTYPE;\n\t\t\treturn (size_t)-1;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)sat->sat_tab[sid]);\n\t}\n\tif (i == 0) {\n\t\tDPRINTF((\" none, sid: %d\\n\", sid));\n\t\treturn (size_t)-1;\n\n\t}\n\tDPRINTF((\"\\n\"));\n\treturn i;\n}",
        "output": "0",
        "idx": 6093
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));\n  if (keepinvariant(g)) {  \n    reallymarkobject(g, v);  \n    if (isold(o)) {\n      lua_assert(!isold(v));  \n      setage(v, G_OLD0);  \n    }\n  }\n  else {  \n    lua_assert(issweepphase(g));\n    makewhite(g, o);  \n  }\n}",
        "output": "1",
        "idx": 8110
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void account_pipe_buffers(struct pipe_inode_info *pipe,\n                                 unsigned long old, unsigned long new)\n{\n\tatomic_long_add(new - old, &pipe->user->pipe_bufs);\n}",
        "output": "0",
        "idx": 1553
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t\t  const struct flowi6 *fl6)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\n\tif (!dst)\n\t\tgoto out;\n\n\tif (ip6_rt_check(&rt->rt6i_dst, &fl6->daddr, np->daddr_cache) ||\n#ifdef CONFIG_IPV6_SUBTREES\n\t    ip6_rt_check(&rt->rt6i_src, &fl6->saddr, np->saddr_cache) ||\n#endif\n\t    (fl6->flowi6_oif && fl6->flowi6_oif != dst->dev->ifindex)) {\n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\n\nout:\n\treturn dst;\n}",
        "output": "1",
        "idx": 2306
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pipe_advance(struct iov_iter *i, size_t size)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tif (unlikely(i->count < size))\n\t\tsize = i->count;\n\tif (size) {\n\t\tstruct pipe_buffer *buf;\n\t\tsize_t off = i->iov_offset, left = size;\n\t\tint idx = i->idx;\n\t\tif (off) \n\t\t\tleft += off - pipe->bufs[idx].offset;\n\t\twhile (1) {\n\t\t\tbuf = &pipe->bufs[idx];\n\t\t\tif (left <= buf->len)\n\t\t\t\tbreak;\n\t\t\tleft -= buf->len;\n\t\t\tidx = next_idx(idx, pipe);\n\t\t}\n\t\ti->idx = idx;\n\t\ti->iov_offset = buf->offset + left;\n\t}\n\ti->count -= size;\n\tpipe_truncate(i);\n}",
        "output": "0",
        "idx": 2091
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {\n  StkId base = ci->func + 1;\n  const char *name = NULL;\n  if (isLua(ci)) {\n    if (n < 0)  \n      return findvararg(ci, -n, pos);\n    else\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n  }\n  if (name == NULL) {  \n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) {  \n      name = isLua(ci) ? \"(temporary)\" : \"(C temporary)\";\n    }\n    else\n      return NULL;  \n  }\n  if (pos)\n    *pos = base + (n - 1);\n  return name;\n}",
        "output": "1",
        "idx": 8114
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ZEND_API void zend_object_store_ctor_failed(zval *zobject TSRMLS_DC)\n{\n\tzend_object_handle handle = Z_OBJ_HANDLE_P(zobject);\n\tzend_object_store_bucket *obj_bucket = &EG(objects_store).object_buckets[handle];\n\n\tobj_bucket->bucket.obj.handlers = Z_OBJ_HT_P(zobject);\n\tobj_bucket->destructor_called = 1;\n}",
        "output": "0",
        "idx": 5649
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void virtio_config_writeb(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val = data;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return;\n    }\n\n    stb_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}",
        "output": "0",
        "idx": 5303
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "decode_sequence_of(const uint8_t *asn1, size_t len,\n                   const struct atype_info *elemtype, void **seq_out,\n                   size_t *count_out)\n{\n    krb5_error_code ret;\n    void *seq = NULL, *elem, *newseq;\n    const uint8_t *contents;\n    size_t clen, count = 0;\n    taginfo t;\n\n    *seq_out = NULL;\n    *count_out = 0;\n    while (len > 0) {\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len, 0);\n        if (ret)\n            goto error;\n        if (!check_atype_tag(elemtype, &t)) {\n            ret = ASN1_BAD_ID;\n            goto error;\n        }\n        newseq = realloc(seq, (count + 1) * elemtype->size);\n        if (newseq == NULL) {\n            ret = ENOMEM;\n            goto error;\n        }\n        seq = newseq;\n        elem = (char *)seq + count * elemtype->size;\n        memset(elem, 0, elemtype->size);\n        ret = decode_atype(&t, contents, clen, elemtype, elem);\n        if (ret)\n            goto error;\n        count++;\n    }\n    *seq_out = seq;\n    *count_out = count;\n    return 0;\n\nerror:\n    free_sequence_of(elemtype, seq, count);\n    free(seq);\n    return ret;\n}",
        "output": "0",
        "idx": 305
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "eval_next_line(char_u *arg, evalarg_T *evalarg)\n{\n    garray_T\t*gap = &evalarg->eval_ga;\n    char_u\t*line;\n\n    if (arg != NULL)\n    {\n\tif (*arg == NL)\n\t    return newline_skip_comments(arg);\n\tif (*skipwhite(arg) == '#')\n\t    *arg = NUL;\n    }\n\n    if (evalarg->eval_cookie != NULL)\n\tline = evalarg->eval_getline(0, evalarg->eval_cookie, 0,\n\t\t\t\t\t\t\t   GETLINE_CONCAT_ALL);\n    else\n\tline = next_line_from_context(evalarg->eval_cctx, TRUE);\n    if (line == NULL)\n\treturn NULL;\n\n    ++evalarg->eval_break_count;\n    if (gap->ga_itemsize > 0 && ga_grow(gap, 1) == OK)\n    {\n\tchar_u *p = skipwhite(line);\n\n\tif (*p == NUL || vim9_comment_start(p))\n\t{\n\t    vim_free(line);\n\t    line = vim_strsave((char_u *)\"\");\n\t}\n\n\t((char_u **)gap->ga_data)[gap->ga_len] = line;\n\t++gap->ga_len;\n    }\n    else if (evalarg->eval_cookie != NULL)\n    {\n\tfree_eval_tofree_later(evalarg);\n\tevalarg->eval_tofree = line;\n    }\n\n    evalarg->eval_using_cmdline = FALSE;\n    return skipwhite(line);\n}",
        "output": "0",
        "idx": 8133
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline Quantum ClampPixel(const MagickRealType value)\n{\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  return((Quantum) value);\n#else\n  if (value < 0.0)\n    return((Quantum) 0.0);\n  if (value >= (MagickRealType) QuantumRange)\n    return((Quantum) QuantumRange);\n  return((Quantum) value);\n#endif\n}",
        "output": "0",
        "idx": 7185
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static double ipow( double n, int exp )\n{\n\tdouble r;\n\n\tif ( exp < 0 )\n\t\treturn 1.0 / ipow( n, -exp );\n\tr = 1;\n\twhile ( exp > 0 ) {\n\t\tif ( exp & 1 )\n\t\t\tr *= n;\n\t\texp >>= 1;\n\t\tn *= n;\n\t}\n\treturn r;\n}",
        "output": "1",
        "idx": 5876
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tstruct shmem_sb_info *sbinfo = SHMEM_SB(sb);\n\tstruct shmem_sb_info config = *sbinfo;\n\tunsigned long inodes;\n\tint error = -EINVAL;\n\n\tif (shmem_parse_options(data, &config, true))\n\t\treturn error;\n\n\tspin_lock(&sbinfo->stat_lock);\n\tinodes = sbinfo->max_inodes - sbinfo->free_inodes;\n\tif (percpu_counter_compare(&sbinfo->used_blocks, config.max_blocks) > 0)\n\t\tgoto out;\n\tif (config.max_inodes < inodes)\n\t\tgoto out;\n\tif (config.max_blocks && !sbinfo->max_blocks)\n\t\tgoto out;\n\tif (config.max_inodes && !sbinfo->max_inodes)\n\t\tgoto out;\n\n\terror = 0;\n\tsbinfo->max_blocks  = config.max_blocks;\n\tsbinfo->max_inodes  = config.max_inodes;\n\tsbinfo->free_inodes = config.max_inodes - inodes;\n\n\tmpol_put(sbinfo->mpol);\n\tsbinfo->mpol        = config.mpol;\t\nout:\n\tspin_unlock(&sbinfo->stat_lock);\n\treturn error;\n}",
        "output": "1",
        "idx": 864
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_rpsi(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tpjmedia_rtcp_fb_rpsi *rpsi)\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n    pj_uint8_t *p;\n    pj_uint8_t padlen;\n    pj_size_t rpsi_len;\n\n    PJ_ASSERT_RETURN(buf && rpsi, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n\n    if (hdr->pt != RTCP_PSFB || hdr->count != 3)\n\treturn PJ_ENOTFOUND;\n\n    rpsi_len = (pj_ntohs((pj_uint16_t)hdr->length)-2) * 4;\n    if (length < rpsi_len + 12)\n\treturn PJ_ETOOSMALL;\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    padlen = *p++;\n    rpsi->pt = (*p++ & 0x7F);\n    rpsi->rpsi_bit_len = rpsi_len*8 - 16 - padlen;\n    pj_strset(&rpsi->rpsi, (char*)p, (rpsi->rpsi_bit_len + 7)/8);\n\n    return PJ_SUCCESS;\n}",
        "output": "1",
        "idx": 8070
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,\n\t\t\t\t\t  unsigned long addr,\n\t\t\t\t\t  unsigned long length)\n{\n\tunsigned long result = 0;\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\tresult = ((((IOAPIC_NUM_PINS - 1) & 0xff) << 16)\n\t\t\t  | (IOAPIC_VERSION_ID & 0xff));\n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\tcase IOAPIC_REG_ARB_ID:\n\t\tresult = ((ioapic->id & 0xf) << 24);\n\t\tbreak;\n\n\tdefault:\n\t\t{\n\t\t\tu32 redir_index = (ioapic->ioregsel - 0x10) >> 1;\n\t\t\tu64 redir_content;\n\n\t\t\tif (redir_index < IOAPIC_NUM_PINS)\n\t\t\t\tredir_content =\n\t\t\t\t\tioapic->redirtbl[redir_index].bits;\n\t\t\telse\n\t\t\t\tredir_content = ~0ULL;\n\n\t\t\tresult = (ioapic->ioregsel & 0x1) ?\n\t\t\t    (redir_content >> 32) & 0xffffffff :\n\t\t\t    redir_content & 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}",
        "output": "0",
        "idx": 1253
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err hdlr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_HandlerBox *p = (GF_HandlerBox *)a;\n\tgf_isom_box_dump_start(a, \"HandlerBox\", trace);\n\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);\n\t} else {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8);\n\t}\n\tfprintf(trace, \"reserved1=\\\"%d\\\" reserved2=\\\"\", p->reserved1);\n\tdump_data(trace, (char *) p->reserved2, 12);\n\tfprintf(trace, \"\\\"\");\n\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"HandlerBox\", a, trace);\n\treturn GF_OK;\n}",
        "output": "1",
        "idx": 6792
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "stf_status ikev2parent_inI2outR2(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\n\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\n\t\t    \"ikev2 parent inI2outR2: calculating g^{xy} in order to decrypt I2\"));\n\n\tif (!md->chain[ISAKMP_NEXT_v2E]) {\n\t\tlibreswan_log(\"R2 state should receive an encrypted payload\");\n\t\treset_globals();\n\t\treturn STF_FATAL;\n\t}\n\n\t{\n\t\tstruct dh_continuation *dh = alloc_thing(\n\t\t\tstruct dh_continuation,\n\t\t\t\"ikev2_inI2outR2 KE\");\n\t\tstf_status e;\n\n\t\tdh->md = md;\n\t\tset_suspended(st, dh->md);\n\n\t\tpcrc_init(&dh->dh_pcrc);\n\t\tdh->dh_pcrc.pcrc_func = ikev2_parent_inI2outR2_continue;\n\t\te = start_dh_v2(&dh->dh_pcrc, st, st->st_import, RESPONDER,\n\t\t\t\tst->st_oakley.groupnum);\n\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");\n\t\t\tdelete_state(st);\n\t\t}\n\n\t\treset_globals();\n\n\t\treturn e;\n\t}\n}",
        "output": "1",
        "idx": 4378
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct htx_blk *htx_add_trailer(struct htx *htx, const struct ist name,\n\t\t\t\t\t      const struct ist value)\n{\n\tstruct htx_blk *blk;\n\n\tblk = htx_add_blk(htx, HTX_BLK_TLR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}",
        "output": "1",
        "idx": 8792
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tif (ctx->might_cancel) {\n\t\tctx->might_cancel = false;\n\t\tspin_lock(&cancel_lock);\n\t\tlist_del_rcu(&ctx->clist);\n\t\tspin_unlock(&cancel_lock);\n\t}\n}",
        "output": "1",
        "idx": 1474
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u32 read_32(cdk_stream_t s)\n{\n\tbyte buf[4];\n\tsize_t nread = 0;\n\n\tassert(s != NULL);\n\n\tstream_read(s, buf, 4, &nread);\n\tif (nread != 4)\n\t\treturn (u32) -1;\n\treturn buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3];\n}",
        "output": "0",
        "idx": 6489
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error_t lpc546xxEthUpdateMacAddrFilter(NetInterface *interface)\n{\n   uint_t i;\n   bool_t acceptMulticast;\n\n   TRACE_DEBUG(\"Updating MAC filter...\\r\\n\");\n\n   ENET->MAC_ADDR_LOW = interface->macAddr.w[0] | (interface->macAddr.w[1] << 16);\n   ENET->MAC_ADDR_HIGH = interface->macAddr.w[2];\n\n   acceptMulticast = FALSE;\n\n   for(i = 0; i < MAC_ADDR_FILTER_SIZE; i++)\n   {\n      if(interface->macAddrFilter[i].refCount > 0)\n      {\n         acceptMulticast = TRUE;\n         break;\n      }\n   }\n\n   if(acceptMulticast)\n   {\n      ENET->MAC_FRAME_FILTER |= ENET_MAC_FRAME_FILTER_PM_MASK;\n   }\n   else\n   {\n      ENET->MAC_FRAME_FILTER &= ~ENET_MAC_FRAME_FILTER_PM_MASK;\n   }\n\n   return NO_ERROR;\n}",
        "output": "1",
        "idx": 8598
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n{\n    int i, j, v;\n\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->intra_matrix[j]        = v;\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n\n    next_start_code_studio(gb);\n}",
        "output": "1",
        "idx": 3414
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void opl3_panning(int dev, int voice, int value)\n{\n\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tdevc->voc[voice].panning = value;\n}",
        "output": "0",
        "idx": 395
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2269
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct phy *serdes_simple_xlate(struct device *dev,\n\t\t\t\t       struct of_phandle_args *args)\n{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tport = args->args[0];\n\tidx = args->args[1];\n\n\tfor (i = 0; i < SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\n\t\tif (idx != SERDES6G(0) && macro->port >= 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\n\t\tmacro->port = port;\n\t\treturn ctrl->phys[i];\n\t}\n\n\treturn ERR_PTR(-ENODEV);\n}",
        "output": "0",
        "idx": 4169
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cp2112_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tbuf[0] = CP2112_GPIO_SET;\n\tbuf[1] = value ? 0xff : 0;\n\tbuf[2] = 1 << offset;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_SET, buf,\n\t\t\t\t CP2112_GPIO_SET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0)\n\t\thid_err(hdev, \"error setting GPIO values: %d\\n\", ret);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}",
        "output": "1",
        "idx": 1442
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main()\n{\n\tgdImagePtr im, exp;\n\tint error = 0;\n\n\tim = gdImageCreate(50, 50);\n\n\tif (!im) {\n\t\tgdTestErrorMsg(\"gdImageCreate failed.\\n\");\n\t\treturn 1;\n\t}\n\n\tgdImageCropThreshold(im, 1337, 0);\n\tgdImageDestroy(im);\n\treturn 0;\n}",
        "output": "0",
        "idx": 6249
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "asmlinkage void kernel_unaligned_trap(struct pt_regs *regs, unsigned int insn)\n{\n\tenum direction dir = decode_direction(insn);\n\tint size = decode_access_size(insn);\n\n\tif(!ok_for_kernel(insn) || dir == both) {\n\t\tprintk(\"Unsupported unaligned load/store trap for kernel at <%08lx>.\\n\",\n\t\t       regs->pc);\n\t\tunaligned_panic(\"Wheee. Kernel does fpu/atomic unaligned load/store.\");\n\t} else {\n\t\tunsigned long addr = compute_effective_address(regs, insn);\n\t\tint err;\n\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, addr);\n\t\tswitch (dir) {\n\t\tcase load:\n\t\t\terr = do_int_load(fetch_reg_addr(((insn>>25)&0x1f),\n\t\t\t\t\t\t\t regs),\n\t\t\t\t\t  size, (unsigned long *) addr,\n\t\t\t\t\t  decode_signedness(insn));\n\t\t\tbreak;\n\n\t\tcase store:\n\t\t\terr = do_int_store(((insn>>25)&0x1f), size,\n\t\t\t\t\t   (unsigned long *) addr, regs);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpanic(\"Impossible kernel unaligned trap.\");\n\t\t}\n\t\tif (err)\n\t\t\tkernel_mna_trap_fault(regs, insn);\n\t\telse\n\t\t\tadvance(regs);\n\t}\n}",
        "output": "1",
        "idx": 474
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u16 read_16(cdk_stream_t s)\n{\n\tbyte buf[2];\n\tsize_t nread;\n\n\tassert(s != NULL);\n\n\tstream_read(s, buf, 2, &nread);\n\tif (nread != 2)\n\t\treturn (u16) - 1;\n\treturn buf[0] << 8 | buf[1];\n}",
        "output": "1",
        "idx": 4636
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nfs4_open_revalidate(struct inode *dir, struct dentry *dentry, int openflags, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct rpc_cred *cred;\n\tstruct nfs4_state *state;\n\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn PTR_ERR(cred);\n\tstate = nfs4_do_open(dir, &path, openflags, NULL, cred);\n\tput_rpccred(cred);\n\tif (IS_ERR(state)) {\n\t\tswitch (PTR_ERR(state)) {\n\t\t\tcase -EPERM:\n\t\t\tcase -EACCES:\n\t\t\tcase -EDQUOT:\n\t\t\tcase -ENOSPC:\n\t\t\tcase -EROFS:\n\t\t\t\tlookup_instantiate_filp(nd, (struct dentry *)state, NULL);\n\t\t\t\treturn 1;\n\t\t\tdefault:\n\t\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (state->inode == dentry->d_inode) {\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\tnfs4_intent_set_file(nd, &path, state);\n\t\treturn 1;\n\t}\n\tnfs4_close_sync(&path, state, openflags);\nout_drop:\n\td_drop(dentry);\n\treturn 0;\n}",
        "output": "1",
        "idx": 2148
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs_set_open_stateid_locked(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tmemcpy(state->stateid.data, stateid->data, sizeof(state->stateid.data));\n\tmemcpy(state->open_stateid.data, stateid->data, sizeof(state->open_stateid.data));\n\tswitch (open_flags) {\n\t\tcase FMODE_READ:\n\t\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tset_bit(NFS_O_RDWR_STATE, &state->flags);\n\t}\n}",
        "output": "1",
        "idx": 2126
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_populate_msicap(struct msicap *msicap, int msgnum, int nextptr)\n{\n\tint mmc;\n\n\tassert((msgnum & (msgnum - 1)) == 0 && msgnum >= 1 && msgnum <= 32);\n\tmmc = ffs(msgnum) - 1;\n\n\tbzero(msicap, sizeof(struct msicap));\n\tmsicap->capid = PCIY_MSI;\n\tmsicap->nextptr = nextptr;\n\tmsicap->msgctrl = PCIM_MSICTRL_64BIT | (mmc << 1);\n}",
        "output": "1",
        "idx": 7602
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct sem_array *sem_obtain_lock(struct ipc_namespace *ns,\n\t\t\tint id, struct sembuf *sops, int nsops, int *locknum)\n{\n\tstruct kern_ipc_perm *ipcp;\n\tstruct sem_array *sma;\n\n\trcu_read_lock();\n\tipcp = ipc_obtain_object(&sem_ids(ns), id);\n\tif (IS_ERR(ipcp)) {\n\t\tsma = ERR_CAST(ipcp);\n\t\tgoto err;\n\t}\n\n\tsma = container_of(ipcp, struct sem_array, sem_perm);\n\t*locknum = sem_lock(sma, sops, nsops);\n\n\tif (!ipcp->deleted)\n\t\treturn container_of(ipcp, struct sem_array, sem_perm);\n\n\tsem_unlock(sma, *locknum);\n\tsma = ERR_PTR(-EINVAL);\nerr:\n\trcu_read_unlock();\n\treturn sma;\n}",
        "output": "0",
        "idx": 3215
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ext2_xattr_put_super(struct super_block *sb)\n{\n\tmb_cache_shrink(sb->s_bdev);\n}",
        "output": "1",
        "idx": 1116
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SIZED_STRING* sized_string_dup(\n    SIZED_STRING* s)\n{\n  SIZED_STRING* result = (SIZED_STRING*) yr_malloc(\n      sizeof(SIZED_STRING) + s->length);\n\n  if (result == NULL)\n    return NULL;\n\n  result->length = s->length;\n  result->flags = s->flags;\n\n  strncpy(result->c_string, s->c_string, s->length + 1);\n\n  return result;\n}",
        "output": "0",
        "idx": 7873
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(locale_get_primary_language )\n{\n\tget_icu_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}",
        "output": "0",
        "idx": 5417
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\tjbd2_might_wait_for_commit(journal);\n\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\n\tjbd2_journal_wait_updates(journal);\n\n\twrite_unlock(&journal->j_state_lock);\n\n\tmutex_lock(&journal->j_barrier);\n}",
        "output": "1",
        "idx": 2010
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int gss_iakerbmechglue_init(void)\n{\n    struct gss_mech_config mech_iakerb;\n    struct gss_config iakerb_mechanism = krb5_mechanism;\n\n    iakerb_mechanism.gss_accept_sec_context = iakerb_gss_accept_sec_context;\n    iakerb_mechanism.gss_init_sec_context   = iakerb_gss_init_sec_context;\n    iakerb_mechanism.gss_delete_sec_context = iakerb_gss_delete_sec_context;\n    iakerb_mechanism.gss_acquire_cred       = iakerb_gss_acquire_cred;\n    iakerb_mechanism.gssspi_acquire_cred_with_password\n                                    = iakerb_gss_acquire_cred_with_password;\n\n    memset(&mech_iakerb, 0, sizeof(mech_iakerb));\n    mech_iakerb.mech = &iakerb_mechanism;\n\n    mech_iakerb.mechNameStr = \"iakerb\";\n    mech_iakerb.mech_type = (gss_OID)gss_mech_iakerb;\n    gssint_register_mechinfo(&mech_iakerb);\n\n    return 0;\n}",
        "output": "1",
        "idx": 112
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_populate_msixcap(struct msixcap *msixcap, int msgnum, int barnum,\n\t\t     uint32_t msix_tab_size)\n{\n\n\tassert(msix_tab_size % 4096 == 0);\n\n\tbzero(msixcap, sizeof(struct msixcap));\n\tmsixcap->capid = PCIY_MSIX;\n\n\tmsixcap->msgctrl = msgnum - 1;\n\n\tmsixcap->table_info = barnum & PCIM_MSIX_BIR_MASK;\n\tmsixcap->pba_info = msix_tab_size | (barnum & PCIM_MSIX_BIR_MASK);\n}",
        "output": "1",
        "idx": 7608
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ext4_end_io_work(struct work_struct *work)\n{\n\text4_io_end_t *io  = container_of(work, ext4_io_end_t, work);\n\tstruct inode *inode = io->inode;\n\tint ret = 0;\n\n\tmutex_lock(&inode->i_mutex);\n\tret = ext4_end_io_nolock(io);\n\tif (ret >= 0) {\n\t\tif (!list_empty(&io->list))\n\t\t\tlist_del_init(&io->list);\n\t\text4_free_io_end(io);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n}",
        "output": "1",
        "idx": 2244
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  \n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse if (rmp->regprog != NULL)\n\t{\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}",
        "output": "0",
        "idx": 8025
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void copy_to_user_policy(struct xfrm_policy *xp, struct xfrm_userpolicy_info *p, int dir)\n{\n\tmemset(p, 0, sizeof(*p));\n\tmemcpy(&p->sel, &xp->selector, sizeof(p->sel));\n\tmemcpy(&p->lft, &xp->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &xp->curlft, sizeof(p->curlft));\n\tp->priority = xp->priority;\n\tp->index = xp->index;\n\tp->sel.family = xp->family;\n\tp->dir = dir;\n\tp->action = xp->action;\n\tp->flags = xp->flags;\n\tp->share = XFRM_SHARE_ANY; \n}",
        "output": "0",
        "idx": 1055
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tcp_illinois_info(struct sock *sk, u32 ext,\n\t\t\t      struct sk_buff *skb)\n{\n\tconst struct illinois *ca = inet_csk_ca(sk);\n\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tstruct tcpvegas_info info = {\n\t\t\t.tcpv_enabled = 1,\n\t\t\t.tcpv_rttcnt = ca->cnt_rtt,\n\t\t\t.tcpv_minrtt = ca->base_rtt,\n\t\t};\n\t\tu64 t = ca->sum_rtt;\n\n\t\tdo_div(t, ca->cnt_rtt);\n\t\tinfo.tcpv_rtt = t;\n\n\t\tnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n\t}\n}",
        "output": "1",
        "idx": 792
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\n\tret = snprintf(path, sizeof(path), \"%s/%s\", rootfs, mntent->mnt_dir);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, rootfs);\n}",
        "output": "0",
        "idx": 6047
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static CURLcode imap_parse_url_path(struct connectdata *conn)\n{\n  struct imap_conn *imapc = &conn->proto.imapc;\n  struct SessionHandle *data = conn->data;\n  const char *path = data->state.path;\n  int len;\n\n  if(!*path)\n    path = \"INBOX\";\n\n  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n  if(!imapc->mailbox)\n    return CURLE_OUT_OF_MEMORY;\n\n  return CURLE_OK;\n}",
        "output": "1",
        "idx": 3590
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_checkout_nasty__git_tilde1(void)\n{\n#ifdef GIT_WIN32\n\ttest_checkout_fails(\"refs/heads/git_tilde1\", \".git/foobar\");\n#endif\n}",
        "output": "1",
        "idx": 4888
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int update(printbuffer *p)\n{\n\tchar *str;\n\tif (!p || !p->buffer) return 0;\n\tstr=p->buffer+p->offset;\n\treturn p->offset+strlen(str);\n}",
        "output": "0",
        "idx": 8277
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_event_task_output(struct perf_event *event,\n\t\t\t\t     struct perf_task_event *task_event)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data\tsample;\n\tstruct task_struct *task = task_event->task;\n\tint ret, size = task_event->event_id.header.size;\n\n\tperf_event_header__init_id(&task_event->event_id.header, &sample, event);\n\n\tret = perf_output_begin(&handle, event,\n\t\t\t\ttask_event->event_id.header.size, 0, 0);\n\tif (ret)\n\t\tgoto out;\n\n\ttask_event->event_id.pid = perf_event_pid(event, task);\n\ttask_event->event_id.ppid = perf_event_pid(event, current);\n\n\ttask_event->event_id.tid = perf_event_tid(event, task);\n\ttask_event->event_id.ptid = perf_event_tid(event, current);\n\n\tperf_output_put(&handle, task_event->event_id);\n\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\nout:\n\ttask_event->event_id.header.size = size;\n}",
        "output": "1",
        "idx": 522
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ext4_dax_pfn_mkwrite(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct super_block *sb = inode->i_sb;\n\tint ret = VM_FAULT_NOPAGE;\n\tloff_t size;\n\n\tsb_start_pagefault(sb);\n\tfile_update_time(vma->vm_file);\n\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (vmf->pgoff >= size)\n\t\tret = VM_FAULT_SIGBUS;\n\tup_read(&EXT4_I(inode)->i_mmap_sem);\n\tsb_end_pagefault(sb);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 1437
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)\n{\n\tirda_queue_t* queue;\n\tunsigned long flags = 0;\n\tint i;\n\n\tIRDA_ASSERT(hashbin != NULL, return -1;);\n\tIRDA_ASSERT(hashbin->magic == HB_MAGIC, return -1;);\n\n\tif (hashbin->hb_type & HB_LOCK)\n\t\tspin_lock_irqsave(&hashbin->hb_spinlock, flags);\n\n\tfor (i = 0; i < HASHBIN_SIZE; i ++ ) {\n\t\twhile (1) {\n\t\t\tqueue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);\n\n\t\t\tif (!queue)\n\t\t\t\tbreak;\n\n\t\t\tif (free_func) {\n\t\t\t\tif (hashbin->hb_type & HB_LOCK)\n\t\t\t\t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n\t\t\t\tfree_func(queue);\n\t\t\t\tif (hashbin->hb_type & HB_LOCK)\n\t\t\t\t\tspin_lock_irqsave(&hashbin->hb_spinlock, flags);\n\t\t\t}\n\t\t}\n\t}\n\n\thashbin->hb_current = NULL;\n\thashbin->magic = ~HB_MAGIC;\n\n\tif (hashbin->hb_type & HB_LOCK)\n\t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n\n\tkfree(hashbin);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2163
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE cState_indent_set(VALUE self, VALUE indent)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(indent, T_STRING);\n    len = RSTRING_LEN(indent);\n    if (len == 0) {\n        if (state->indent) {\n            ruby_xfree(state->indent);\n            state->indent = NULL;\n            state->indent_len = 0;\n        }\n    } else {\n        if (state->indent) ruby_xfree(state->indent);\n        state->indent = strdup(RSTRING_PTR(indent));\n        state->indent_len = len;\n    }\n    return Qnil;\n}",
        "output": "1",
        "idx": 6276
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int find_high_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=31;i>=0;i--) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 6640
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ptirq_free_irte(const struct ptirq_remapping_info *entry)\n{\n\tstruct intr_source intr_src;\n\n\tif (entry->irte_idx < CONFIG_MAX_IR_ENTRIES) {\n\t\tif (entry->intr_type == PTDEV_INTR_MSI) {\n\t\t\tintr_src.is_msi = true;\n\t\t\tintr_src.src.msi.value = entry->phys_sid.msi_id.bdf;\n\t\t} else {\n\t\t\tintr_src.is_msi = false;\n\t\t\tintr_src.src.ioapic_id = ioapic_irq_to_ioapic_id(entry->allocated_pirq);\n\t\t}\n\t\tdmar_free_irte(&intr_src, entry->irte_idx);\n\t}\n}",
        "output": "1",
        "idx": 7566
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dev_forward_skb(struct net_device *dev, struct sk_buff *skb)\n{\n\tskb_orphan(skb);\n\n\tif (!(dev->flags & IFF_UP))\n\t\treturn NET_RX_DROP;\n\n\tif (skb->len > (dev->mtu + dev->hard_header_len))\n\t\treturn NET_RX_DROP;\n\n\tskb_set_dev(skb, dev);\n\tskb->tstamp.tv64 = 0;\n\tskb->pkt_type = PACKET_HOST;\n\tskb->protocol = eth_type_trans(skb, dev);\n\treturn netif_rx(skb);\n}",
        "output": "1",
        "idx": 216
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vmx_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL, vmx_pin_based_exec_ctrl(vmx));\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\tif (kvm_vcpu_apicv_active(vcpu))\n\t\t\tvmcs_set_bits(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t      SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t      SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\t\telse\n\t\t\tvmcs_clear_bits(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\t}\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_set_msr_bitmap(vcpu);\n}",
        "output": "0",
        "idx": 1885
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void process_blob(struct rev_info *revs,\n\t\t\t struct blob *blob,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *path,\n\t\t\t const char *name,\n\t\t\t void *cb_data)\n{\n\tstruct object *obj = &blob->object;\n\tsize_t pathlen;\n\n\tif (!revs->blob_objects)\n\t\treturn;\n\tif (!obj)\n\t\tdie(\"bad blob object\");\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn;\n\tobj->flags |= SEEN;\n\n\tpathlen = path->len;\n\tstrbuf_addstr(path, name);\n\tshow(obj, path->buf, cb_data);\n\tstrbuf_setlen(path, pathlen);\n}",
        "output": "0",
        "idx": 7227
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(FilesystemIterator, key)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (SPL_FILE_DIR_KEY(intern, SPL_FILE_DIR_KEY_AS_FILENAME)) {\n\t\tRETURN_STRING(intern->u.dir.entry.d_name, 1);\n\t} else {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t\tRETURN_STRINGL(intern->file_name, intern->file_name_len, 1);\n\t}\n}",
        "output": "0",
        "idx": 5561
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "validate_event(struct pmu *pmu, struct pmu_hw_events *hw_events,\n\t\t\t\tstruct perf_event *event)\n{\n\tstruct arm_pmu *armpmu;\n\tstruct hw_perf_event fake_event = event->hw;\n\tstruct pmu *leader_pmu = event->group_leader->pmu;\n\n\tif (is_software_event(event))\n\t\treturn 1;\n\n\tif (event->pmu != pmu)\n\t\treturn 0;\n\n\tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n\t\treturn 1;\n\n\tif (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)\n\t\treturn 1;\n\n\tarmpmu = to_arm_pmu(event->pmu);\n\treturn armpmu->get_event_idx(hw_events, &fake_event) >= 0;\n}",
        "output": "0",
        "idx": 3891
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ikev2_parent_outI1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\tstruct pluto_crypto_req *r,\n\t\t\t\t\terr_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent outI1: calculated ke+nonce, sending I1\"));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); \n\n\tset_cur_state(st);\n\n\tst->st_calculating = FALSE;\n\n\te = ikev2_parent_outI1_tail(pcrc, r);\n\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t}\n\treset_cur_state();\n\treset_globals();\n\n\tpassert(GLOBALS_ARE_RESET());\n}",
        "output": "1",
        "idx": 4388
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dev_load(struct net *net, const char *name)\n{\n\tstruct net_device *dev;\n\tint no_module;\n\n\trcu_read_lock();\n\tdev = dev_get_by_name_rcu(net, name);\n\trcu_read_unlock();\n\n\tno_module = !dev;\n\tif (no_module && capable(CAP_NET_ADMIN))\n\t\tno_module = request_module(\"netdev-%s\", name);\n\tif (no_module && capable(CAP_SYS_MODULE)) {\n\t\tif (!request_module(\"%s\", name))\n\t\t\tpr_err(\"Loading kernel module for a network device \"\n\"with CAP_SYS_MODULE (deprecated).  Use CAP_NET_ADMIN and alias netdev-%s \"\n\"instead\\n\", name);\n\t}\n}",
        "output": "0",
        "idx": 373
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,\n\t\t\t\t\t struct nlattr *rp)\n{\n\tstruct xfrm_replay_state_esn *up;\n\tint ulen;\n\n\tif (!replay_esn || !rp)\n\t\treturn 0;\n\n\tup = nla_data(rp);\n\tulen = xfrm_replay_state_esn_len(up);\n\n\tif (nla_len(rp) < ulen || xfrm_replay_state_esn_len(replay_esn) != ulen)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1059
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC bool updateFields(cchar *tableName, MprJson *params)\n{\n    EdiRec  *rec;\n    cchar   *key;\n\n    key = mprLookupJson(params, \"id\");\n    if ((rec = ediSetFields(ediReadRec(getDatabase(), tableName, key), params)) == 0) {\n        return 0;\n    }\n    return updateRec(rec);\n}",
        "output": "1",
        "idx": 5000
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int sas_ex_revalidate_domain(struct domain_device *port_dev)\n{\n\tint res;\n\tstruct domain_device *dev = NULL;\n\n\tres = sas_find_bcast_dev(port_dev, &dev);\n\twhile (res == 0 && dev) {\n\t\tstruct expander_device *ex = &dev->ex_dev;\n\t\tint i = 0, phy_id;\n\n\t\tdo {\n\t\t\tphy_id = -1;\n\t\t\tres = sas_find_bcast_phy(dev, &phy_id, i, true);\n\t\t\tif (phy_id == -1)\n\t\t\t\tbreak;\n\t\t\tres = sas_rediscover(dev, phy_id);\n\t\t\ti = phy_id + 1;\n\t\t} while (i < ex->num_phys);\n\n\t\tdev = NULL;\n\t\tres = sas_find_bcast_dev(port_dev, &dev);\n\t}\n\treturn res;\n}",
        "output": "1",
        "idx": 1834
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __ip_select_ident(struct net *net, struct iphdr *iph, int segs)\n{\n\tstatic u32 ip_idents_hashrnd __read_mostly;\n\tu32 hash, id;\n\n\tnet_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));\n\n\thash = jhash_3words((__force u32)iph->daddr,\n\t\t\t    (__force u32)iph->saddr,\n\t\t\t    iph->protocol ^ net_hash_mix(net),\n\t\t\t    ip_idents_hashrnd);\n\tid = ip_idents_reserve(hash, segs);\n\tiph->id = htons(id);\n}",
        "output": "1",
        "idx": 3124
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, key)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_LONG(intern->u.file.current_line_num);\n} ",
        "output": "0",
        "idx": 5547
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int pure_strcmp(const char * const s1, const char * const s2)\n{\n    const size_t s1_len = strlen(s1);\n    const size_t s2_len = strlen(s2);\n    const size_t len = (s1_len < s2_len) ? s1_len : s2_len;\n\n    return pure_memcmp(s1, s2, len + 1);\n}",
        "output": "0",
        "idx": 4733
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "f_pyeval(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n\n    if (check_restricted() || check_secure())\n\treturn;\n\n    if (p_pyx == 0)\n\tp_pyx = 2;\n\n    str = tv_get_string_buf(&argvars[0], buf);\n    do_pyeval(str, rettv);\n}",
        "output": "0",
        "idx": 8181
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void setup_private_mount(const char *snap_name)\n{\n\tuid_t uid = getuid();\n\tgid_t gid = getgid();\n\tchar tmpdir[MAX_BUF] = { 0 };\n\n\tsc_must_snprintf(tmpdir, sizeof(tmpdir), \"/tmp/snap.%s_XXXXXX\", snap_name);\n\tif (mkdtemp(tmpdir) == NULL) {\n\t\tdie(\"cannot create temporary directory essential for private /tmp\");\n\t}\n\tmode_t old_mask = umask(0);\n\tchar *d = sc_strdup(tmpdir);\n\tsc_must_snprintf(tmpdir, sizeof(tmpdir), \"%s/tmp\", d);\n\tfree(d);\n\n\tif (mkdir(tmpdir, 01777) != 0) {\n\t\tdie(\"cannot create temporary directory for private /tmp\");\n\t}\n\tumask(old_mask);\n\n\tchar *pwd = get_current_dir_name();\n\tif (pwd == NULL)\n\t\tdie(\"cannot get current working directory\");\n\tif (chdir(\"/\") != 0)\n\t\tdie(\"cannot change directory to '/'\");\n\n\tsc_do_mount(tmpdir, \"/tmp\", NULL, MS_BIND, NULL);\n\tsc_do_mount(\"none\", \"/tmp\", NULL, MS_PRIVATE, NULL);\n\tif (chown(\"/tmp/\", uid, gid) < 0) {\n\t\tdie(\"cannot change ownership of /tmp\");\n\t}\n\tif (chdir(pwd) != 0)\n\t\tdie(\"cannot change current working directory to the original directory\");\n\tfree(pwd);\n}",
        "output": "1",
        "idx": 7428
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "setup_efi_state(struct boot_params *params, unsigned long params_load_addr,\n\t\tunsigned int efi_map_offset, unsigned int efi_map_sz,\n\t\tunsigned int efi_setup_data_offset)\n{\n\tstruct efi_info *current_ei = &boot_params.efi_info;\n\tstruct efi_info *ei = &params->efi_info;\n\n\tif (!current_ei->efi_memmap_size)\n\t\treturn 0;\n\n\tif (efi_enabled(EFI_OLD_MEMMAP))\n\t\treturn 0;\n\n\tparams->secure_boot = boot_params.secure_boot;\n\tei->efi_loader_signature = current_ei->efi_loader_signature;\n\tei->efi_systab = current_ei->efi_systab;\n\tei->efi_systab_hi = current_ei->efi_systab_hi;\n\n\tei->efi_memdesc_version = current_ei->efi_memdesc_version;\n\tei->efi_memdesc_size = efi_get_runtime_map_desc_size();\n\n\tsetup_efi_info_memmap(params, params_load_addr, efi_map_offset,\n\t\t\t      efi_map_sz);\n\tprepare_add_efi_setup_data(params, params_load_addr,\n\t\t\t\t   efi_setup_data_offset);\n\treturn 0;\n}",
        "output": "0",
        "idx": 7663
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spaddr_print_ip(netdissect_options *ndo,\n\t        const struct arp_pkthdr *ap, u_short pro)\n{\n\tif (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)\n\t\tND_PRINT((ndo, \"<wrong proto type>\"));\n\telse if (PROTO_LEN(ap) != 4)\n\t\tND_PRINT((ndo, \"<wrong len>\"));\n\telse\n\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, SPA(ap))));\n}",
        "output": "0",
        "idx": 6697
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int sas_discover_end_dev(struct domain_device *dev)\n{\n\tint res;\n\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\tsas_discover_event(dev->port, DISCE_PROBE);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1822
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parserep(netdissect_options *ndo,\n         register const struct sunrpc_msg *rp, register u_int length)\n{\n\tregister const uint32_t *dp;\n\tu_int len;\n\tenum sunrpc_accept_stat astat;\n\n\tdp = ((const uint32_t *)&rp->rm_reply) + 1;\n\tND_TCHECK(dp[1]);\n\tlen = EXTRACT_32BITS(&dp[1]);\n\tif (len >= length)\n\t\treturn (NULL);\n\tdp += (len + (2*sizeof(uint32_t) + 3)) / sizeof(uint32_t);\n\n\tND_TCHECK(dp[0]);\n\tastat = (enum sunrpc_accept_stat) EXTRACT_32BITS(dp);\n\tif (astat != SUNRPC_SUCCESS) {\n\t\tND_PRINT((ndo, \" %s\", tok2str(sunrpc_str, \"ar_stat %d\", astat)));\n\t\tnfserr = 1;\t\t\n\t\treturn (NULL);\n\t}\n\tND_TCHECK2(*dp, sizeof(astat));\n\treturn ((const uint32_t *) (sizeof(astat) + ((const char *)dp)));\ntrunc:\n\treturn (0);\n}",
        "output": "0",
        "idx": 6563
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct bpf_map *bpf_map_get_with_uref(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_map *map;\n\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn map;\n\n\tmap = bpf_map_inc(map, true);\n\tfdput(f);\n\n\treturn map;\n}",
        "output": "0",
        "idx": 1837
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_akcipher rakcipher;\n\n\tstrlcpy(rakcipher.type, \"akcipher\", sizeof(rakcipher.type));\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,\n\t\t    sizeof(struct crypto_report_akcipher), &rakcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "1",
        "idx": 3034
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sctp_chunk_length_valid(struct sctp_chunk *chunk,\n\t\t\t   __u16 required_length)\n{\n\t__u16 chunk_length = ntohs(chunk->chunk_hdr->length);\n\n\tif (unlikely(chunk->pdiscard))\n\t\treturn 0;\n\tif (unlikely(chunk_length < required_length))\n\t\treturn 0;\n\n\treturn 1;\n}",
        "output": "0",
        "idx": 3715
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateTrue(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}",
        "output": "0",
        "idx": 8333
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_NAMED_FUNCTION(zif_locale_set_default)\n{\n\tchar* locale_name = NULL;\n\tint   len=0;\t\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  \"s\",\n\t\t&locale_name ,&len ) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \t\"locale_set_default: unable to parse input params\", 0 TSRMLS_CC );\n\n\t\tRETURN_FALSE;\n\t}\n\n\tif(len == 0) {\n\t\tlocale_name =  (char *)uloc_getDefault() ;\n\t\tlen = strlen(locale_name);\n\t}\n\n\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\t\n\n\tRETURN_TRUE;\n}",
        "output": "1",
        "idx": 3852
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fpm_child_init(struct fpm_worker_pool_s *wp) \n{\n\tfpm_globals.max_requests = wp->config->pm_max_requests;\n\tfpm_globals.listening_socket = dup(wp->listening_socket);\n\n\tif (0 > fpm_stdio_init_child(wp)  ||\n\t    0 > fpm_log_init_child(wp)    ||\n\t    0 > fpm_status_init_child(wp) ||\n\t    0 > fpm_unix_init_child(wp)   ||\n\t    0 > fpm_signals_init_child()  ||\n\t    0 > fpm_env_init_child(wp)    ||\n\t    0 > fpm_php_init_child(wp)) {\n\n\t\tzlog(ZLOG_ERROR, \"[pool %s] child failed to initialize\", wp->config->name);\n\t\texit(FPM_EXIT_SOFTWARE);\n\t}\n}",
        "output": "0",
        "idx": 5671
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned long randomize_stack_top(unsigned long stack_top)\n{\n\tunsigned int random_variable = 0;\n\n\tif ((current->flags & PF_RANDOMIZE) &&\n\t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\trandom_variable = get_random_int() & STACK_RND_MASK;\n\t\trandom_variable <<= PAGE_SHIFT;\n\t}\n#ifdef CONFIG_STACK_GROWSUP\n\treturn PAGE_ALIGN(stack_top) + random_variable;\n#else\n\treturn PAGE_ALIGN(stack_top) - random_variable;\n#endif\n}",
        "output": "1",
        "idx": 2790
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct clock_source *dce120_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(*clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\t\t     regs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "output": "0",
        "idx": 4521
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\t__releases(&keyring_serialise_link_sem)\n{\n\tBUG_ON(index_key->type == NULL);\n\tkenter(\"%d,%s,\", keyring->serial, index_key->type->name);\n\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\n\n\tif (edit) {\n\t\tif (!edit->dead_leaf) {\n\t\t\tkey_payload_reserve(keyring,\n\t\t\t\tkeyring->datalen - KEYQUOTA_LINK_BYTES);\n\t\t}\n\t\tassoc_array_cancel_edit(edit);\n\t}\n\tup_write(&keyring->sem);\n}",
        "output": "0",
        "idx": 3981
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ipc_rcu_putref(void *ptr)\n{\n\tif (--container_of(ptr, struct ipc_rcu_hdr, data)->refcount > 0)\n\t\treturn;\n\n\tif (container_of(ptr, struct ipc_rcu_hdr, data)->is_vmalloc) {\n\t\tcall_rcu(&container_of(ptr, struct ipc_rcu_grace, data)->rcu,\n\t\t\t\tipc_schedule_free);\n\t} else {\n\t\tkfree_rcu(container_of(ptr, struct ipc_rcu_grace, data), rcu);\n\t}\n}",
        "output": "1",
        "idx": 2280
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_pyfribidi_log2vis (PyObject * self, PyObject * args, PyObject * kw)\n{\n\tPyObject *logical = NULL;\t\n\tFriBidiParType base = FRIBIDI_TYPE_RTL;\t\n\tconst char *encoding = \"utf-8\";\t\n\tint clean = 0; \n\tint reordernsm = 1; \n\n\tstatic char *kwargs[] =\n\t        { \"logical\", \"base_direction\", \"encoding\", \"clean\", \"reordernsm\", NULL };\n\n        if (!PyArg_ParseTupleAndKeywords (args, kw, \"O|isii\", kwargs,\n\t\t\t\t\t  &logical, &base, &encoding, &clean, &reordernsm))\n\t\treturn NULL;\n\n\n\tif (!(base == FRIBIDI_TYPE_RTL ||\n\t      base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON))\n\t\treturn PyErr_Format (PyExc_ValueError,\n\t\t\t\t     \"invalid value %d: use either RTL, LTR or ON\",\n\t\t\t\t     base);\n\n\n\tif (PyUnicode_Check (logical))\n\t        return log2vis_unicode (logical, base, clean, reordernsm);\n\telse if (PyString_Check (logical))\n\t        return log2vis_encoded_string (logical, encoding, base, clean, reordernsm);\n\telse\n\t\treturn PyErr_Format (PyExc_TypeError,\n\t\t\t\t     \"expected unicode or str, not %s\",\n\t\t\t\t     logical->ob_type->tp_name);\n}",
        "output": "1",
        "idx": 3608
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int serdes_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *provider;\n\tstruct serdes_ctrl *ctrl;\n\tunsigned int i;\n\tint ret;\n\n\tctrl = devm_kzalloc(&pdev->dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tctrl->dev = &pdev->dev;\n\tctrl->regs = syscon_node_to_regmap(pdev->dev.parent->of_node);\n\tif (IS_ERR(ctrl->regs))\n\t\treturn PTR_ERR(ctrl->regs);\n\n\tfor (i = 0; i < SERDES_MAX; i++) {\n\t\tret = serdes_phy_create(ctrl, i, &ctrl->phys[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdev_set_drvdata(&pdev->dev, ctrl);\n\n\tprovider = devm_of_phy_provider_register(ctrl->dev,\n\t\t\t\t\t\t serdes_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(provider);\n}",
        "output": "0",
        "idx": 4167
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "INTERNAL void vterm_allocator_free(VTerm *vt, void *ptr)\n{\n  if (ptr)\n    (*vt->allocator->free)(ptr, vt->allocdata);\n}",
        "output": "0",
        "idx": 8151
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ast_for_with_stmt(struct compiling *c, const node *n0, bool is_async)\n{\n    const node * const n = is_async ? CHILD(n0, 1) : n0;\n    int i, n_items, end_lineno, end_col_offset;\n    asdl_seq *items, *body;\n\n    REQ(n, with_stmt);\n\n    n_items = (NCH(n) - 2) / 2;\n    items = _Py_asdl_seq_new(n_items, c->c_arena);\n    if (!items)\n        return NULL;\n    for (i = 1; i < NCH(n) - 2; i += 2) {\n        withitem_ty item = ast_for_with_item(c, CHILD(n, i));\n        if (!item)\n            return NULL;\n        asdl_seq_SET(items, (i - 1) / 2, item);\n    }\n\n    body = ast_for_suite(c, CHILD(n, NCH(n) - 1));\n    if (!body)\n        return NULL;\n    get_last_end_pos(body, &end_lineno, &end_col_offset);\n\n    if (is_async)\n        return AsyncWith(items, body, LINENO(n0), n0->n_col_offset,\n                         end_lineno, end_col_offset, c->c_arena);\n    else\n        return With(items, body, LINENO(n), n->n_col_offset,\n                    end_lineno, end_col_offset, c->c_arena);\n}",
        "output": "1",
        "idx": 7216
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_wrap_iov(OM_uint32 *minor_status,\n\t\t    gss_ctx_id_t context_handle,\n\t\t    int conf_req_flag,\n\t\t    gss_qop_t qop_req,\n\t\t    int *conf_state,\n\t\t    gss_iov_buffer_desc *iov,\n\t\t    int iov_count)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_NO_CONTEXT);\n\n\tret = gss_wrap_iov(minor_status,\n\t\t\t   sc->ctx_handle,\n\t\t\t   conf_req_flag,\n\t\t\t   qop_req,\n\t\t\t   conf_state,\n\t\t\t   iov,\n\t\t\t   iov_count);\n\treturn (ret);\n}",
        "output": "0",
        "idx": 75
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n\n    memset((char *)&sct, 0, sizeof(sct));\n\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        LOCK(cl->sendMutex);\n        if (rfbWriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            UNLOCK(cl->sendMutex);\n            continue;\n        }\n        if (rfbWriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n        UNLOCK(cl->sendMutex);\n        rfbStatRecordMessageSent(cl, rfbServerCutText, sz_rfbServerCutTextMsg+len, sz_rfbServerCutTextMsg+len);\n    }\n    rfbReleaseClientIterator(iterator);\n}",
        "output": "0",
        "idx": 8923
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_be_int (SF_PRIVATE *psf, int x)\n{\tpsf->header.ptr [psf->header.indx++] = (x >> 24) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n\tpsf->header.ptr [psf->header.indx++] = x ;\n} ",
        "output": "0",
        "idx": 6905
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t\tunsigned int dataoff, unsigned int *timeouts)\n{\n\treturn true;\n}",
        "output": "1",
        "idx": 2684
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cp2112_gpio_get_all(struct gpio_chip *chip)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,\n\t\t\t\t CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_GET_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO values: %d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto exit;\n\t}\n\n\tret = buf[1];\n\nexit:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn ret;\n}",
        "output": "1",
        "idx": 1436
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_io_accounting(struct task_struct *task, char *buffer, int whole)\n{\n\tstruct task_io_accounting acct = task->ioac;\n\tunsigned long flags;\n\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ))\n\t\treturn -EACCES;\n\n\tif (whole && lock_task_sighand(task, &flags)) {\n\t\tstruct task_struct *t = task;\n\n\t\ttask_io_accounting_add(&acct, &task->signal->ioac);\n\t\twhile_each_thread(task, t)\n\t\t\ttask_io_accounting_add(&acct, &t->ioac);\n\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\treturn sprintf(buffer,\n\t\t\t\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\",\n\t\t\t(unsigned long long)acct.rchar,\n\t\t\t(unsigned long long)acct.wchar,\n\t\t\t(unsigned long long)acct.syscr,\n\t\t\t(unsigned long long)acct.syscw,\n\t\t\t(unsigned long long)acct.read_bytes,\n\t\t\t(unsigned long long)acct.write_bytes,\n\t\t\t(unsigned long long)acct.cancelled_write_bytes);\n}",
        "output": "0",
        "idx": 569
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = NULL;\n\n    if ((object == NULL) || (name == NULL))\n    {\n        return NULL;\n    }\n\n    current_element = object->child;\n    if (case_sensitive)\n    {\n        while ((current_element != NULL) && (current_element->string != NULL) && (strcmp(name, current_element->string) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n    else\n    {\n        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n\n    if ((current_element == NULL) || (current_element->string == NULL)) {\n        return NULL;\n    }\n\n    return current_element;\n}",
        "output": "0",
        "idx": 7895
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __init files_init(unsigned long mempages)\n{ \n\tunsigned long n;\n\n\tfilp_cachep = kmem_cache_create(\"filp\", sizeof(struct file), 0,\n\t\t\tSLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);\n\n\n\tn = (mempages * (PAGE_SIZE / 1024)) / 10;\n\tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n\tfiles_defer_init();\n\tlg_lock_init(&files_lglock, \"files_lglock\");\n\tpercpu_counter_init(&nr_files, 0);\n} ",
        "output": "1",
        "idx": 2388
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, getCsvControl)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar delimiter[2], enclosure[2];\n\n\tarray_init(return_value);\n\n\tdelimiter[0] = intern->u.file.delimiter;\n\tdelimiter[1] = '\\0';\n\tenclosure[0] = intern->u.file.enclosure;\n\tenclosure[1] = '\\0';\n\n\tadd_next_index_string(return_value, delimiter, 1);\n\tadd_next_index_string(return_value, enclosure, 1);\n}",
        "output": "0",
        "idx": 5523
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool nfs_request_too_big(struct svc_rqst *rqstp,\n\t\t\t\tstruct svc_procedure *proc)\n{\n\tif (rqstp->rq_prog != NFS_PROGRAM)\n\t\treturn false;\n\tif (rqstp->rq_vers >= 4)\n\t\treturn false;\n\tif (proc->pc_xdrressize > 0 &&\n\t    proc->pc_xdrressize < XDR_QUADLEN(PAGE_SIZE))\n\t\treturn false;\n\n\treturn rqstp->rq_arg.len > PAGE_SIZE;\n}",
        "output": "0",
        "idx": 2255
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ovl_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint err;\n\tstruct dentry *upperdentry;\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\n\tupperdentry = ovl_dentry_upper(dentry);\n\tif (upperdentry) {\n\t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n\t\terr = notify_change(upperdentry, attr, NULL);\n\t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n\t} else {\n\t\terr = ovl_copy_up_last(dentry, attr, false);\n\t}\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}",
        "output": "1",
        "idx": 980
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const char *rootfs)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\n\tret = mount_entry_create_dir_file(mntent, path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,\n\t\t\t  mntflags, mntdata, optional, rootfs);\n\n\tfree(mntdata);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 6039
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dns_resolver_cmp(const struct key *key,\n\t\t\t    const struct key_match_data *match_data)\n{\n\tint slen, dlen, ret = 0;\n\tconst char *src = key->description, *dsp = match_data->raw_data;\n\n\tkenter(\"%s,%s\", src, dsp);\n\n\tif (!src || !dsp)\n\t\tgoto no_match;\n\n\tif (strcasecmp(src, dsp) == 0)\n\t\tgoto matched;\n\n\tslen = strlen(src);\n\tdlen = strlen(dsp);\n\tif (slen <= 0 || dlen <= 0)\n\t\tgoto no_match;\n\tif (src[slen - 1] == '.')\n\t\tslen--;\n\tif (dsp[dlen - 1] == '.')\n\t\tdlen--;\n\tif (slen != dlen || strncasecmp(src, dsp, slen) != 0)\n\t\tgoto no_match;\n\nmatched:\n\tret = 1;\nno_match:\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}",
        "output": "0",
        "idx": 3679
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(locale_get_display_variant) \n{\n    get_icu_disp_value_src_php( LOC_VARIANT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}",
        "output": "1",
        "idx": 3882
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_lintr_request(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tint bestpin, bestcount, pin;\n\n\tbi = pci_businfo[dev->bus];\n\tassert(bi != NULL);\n\n\tsi = &bi->slotinfo[dev->slot];\n\tbestpin = 0;\n\tbestcount = si->si_intpins[0].ii_count;\n\tfor (pin = 1; pin < 4; pin++) {\n\t\tif (si->si_intpins[pin].ii_count < bestcount) {\n\t\t\tbestpin = pin;\n\t\t\tbestcount = si->si_intpins[pin].ii_count;\n\t\t}\n\t}\n\n\tsi->si_intpins[bestpin].ii_count++;\n\tdev->lintr.pin = bestpin + 1;\n\tpci_set_cfgdata8(dev, PCIR_INTPIN, bestpin + 1);\n}",
        "output": "1",
        "idx": 7572
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint32_t virtio_config_readb(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val;\n\n    k->get_config(vdev, vdev->config);\n\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n\n    val = ldub_p(vdev->config + addr);\n    return val;\n}",
        "output": "1",
        "idx": 3762
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __net_init sctp_ctrlsock_init(struct net *net)\n{\n\tint status;\n\n\tstatus = sctp_ctl_sock_init(net);\n\tif (status)\n\t\tpr_err(\"Failed to initialize the SCTP control sock\\n\");\n\n\treturn status;\n}",
        "output": "0",
        "idx": 4017
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void * calloc(size_t n, size_t lb)\n{\n    if (lb && n > GC_SIZE_MAX / lb)\n      return NULL;\n#   if defined(GC_LINUX_THREADS) \n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}",
        "output": "0",
        "idx": 5067
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xfrm_dump_policy_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct net *net = sock_net(cb->skb->sk);\n\n\txfrm_policy_walk_done(walk, net);\n\treturn 0;\n}",
        "output": "1",
        "idx": 1752
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, ftruncate)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tlong size;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &size) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!php_stream_truncate_supported(intern->u.file.stream)) {\n\t\tzend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, \"Can't truncate file %s\", intern->file_name);\n\t\tRETURN_FALSE;\n\t}\n\t\n\tRETURN_BOOL(0 == php_stream_truncate_set_size(intern->u.file.stream, size));\n} ",
        "output": "1",
        "idx": 3972
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct uvesafb_pal_entry *entries;\n\tint shift = 16 - dac_width;\n\tint i, err = 0;\n\n\tif (info->var.bits_per_pixel == 8) {\n\t\tif (cmap->start + cmap->len > info->cmap.start +\n\t\t    info->cmap.len || cmap->start < info->cmap.start)\n\t\t\treturn -EINVAL;\n\n\t\tentries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);\n\t\tif (!entries)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\tentries[i].red   = cmap->red[i]   >> shift;\n\t\t\tentries[i].green = cmap->green[i] >> shift;\n\t\t\tentries[i].blue  = cmap->blue[i]  >> shift;\n\t\t\tentries[i].pad   = 0;\n\t\t}\n\t\terr = uvesafb_setpalette(entries, cmap->len, cmap->start, info);\n\t\tkfree(entries);\n\t} else {\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\terr |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],\n\t\t\t\t\t\tcmap->green[i], cmap->blue[i],\n\t\t\t\t\t\t0, info);\n\t\t}\n\t}\n\treturn err;\n}",
        "output": "1",
        "idx": 2978
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\n\tStream_Read_UINT16(s, fields->Len); \n\tStream_Read_UINT16(s, fields->MaxLen); \n\tStream_Read_UINT32(s, fields->BufferOffset); \n\treturn 1;\n}",
        "output": "0",
        "idx": 5793
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct port_buffer *get_inbuf(struct port *port)\n{\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\n\tif (port->inbuf)\n\t\treturn port->inbuf;\n\n\tbuf = virtqueue_get_buf(port->in_vq, &len);\n\tif (buf) {\n\t\tbuf->len = min_t(size_t, len, buf->size);\n\t\tbuf->offset = 0;\n\t\tport->stats.bytes_received += len;\n\t}\n\treturn buf;\n}",
        "output": "0",
        "idx": 2821
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void exit_io_context(void)\n{\n\tstruct io_context *ioc;\n\n\ttask_lock(current);\n\tioc = current->io_context;\n\tcurrent->io_context = NULL;\n\ttask_unlock(current);\n\n\tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n\t\tif (ioc->aic && ioc->aic->exit)\n\t\t\tioc->aic->exit(ioc->aic);\n\t\tcfq_exit(ioc);\n\n\t}\n\tput_io_context(ioc);\n}",
        "output": "0",
        "idx": 3117
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init ipgre_init(void)\n{\n\tint err;\n\n\tprintk(KERN_INFO \"GRE over IPv4 tunneling driver\\n\");\n\n\tif (inet_add_protocol(&ipgre_protocol, IPPROTO_GRE) < 0) {\n\t\tprintk(KERN_INFO \"ipgre init: can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\terr = register_pernet_device(&ipgre_net_ops);\n\tif (err < 0)\n\t\tgoto gen_device_failed;\n\n\terr = rtnl_link_register(&ipgre_link_ops);\n\tif (err < 0)\n\t\tgoto rtnl_link_failed;\n\n\terr = rtnl_link_register(&ipgre_tap_ops);\n\tif (err < 0)\n\t\tgoto tap_ops_failed;\n\nout:\n\treturn err;\n\ntap_ops_failed:\n\trtnl_link_unregister(&ipgre_link_ops);\nrtnl_link_failed:\n\tunregister_pernet_device(&ipgre_net_ops);\ngen_device_failed:\n\tinet_del_protocol(&ipgre_protocol, IPPROTO_GRE);\n\tgoto out;\n}",
        "output": "1",
        "idx": 2200
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tsize_t ss = CDF_SEC_SIZE(h);\n\tsize_t pos = CDF_SHORT_SEC_POS(h, id);\n\tassert(ss == len);\n\tif (pos > ss * sst->sst_len) {\n\t\tDPRINTF((\"Out of bounds read %\" SIZE_T_FORMAT \"u > %\"\n\t\t    SIZE_T_FORMAT \"u\\n\",\n\t\t    pos, ss * sst->sst_len));\n\t\treturn -1;\n\t}\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + pos, len);\n\treturn len;\n}",
        "output": "1",
        "idx": 3622
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = NULL;\n\n    if ((object == NULL) || (name == NULL))\n    {\n        return NULL;\n    }\n\n    current_element = object->child;\n    if (case_sensitive)\n    {\n        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n    else\n    {\n        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n\n    return current_element;\n}",
        "output": "1",
        "idx": 5672
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int xt_check_entry_offsets(const void *base,\n\t\t\t   const char *elems,\n\t\t\t   unsigned int target_offset,\n\t\t\t   unsigned int next_offset)\n{\n\tlong size_of_base_struct = elems - (const char *)base;\n\tconst struct xt_entry_target *t;\n\tconst char *e = base;\n\n\tif (target_offset < size_of_base_struct)\n\t\treturn -EINVAL;\n\n\tif (target_offset + sizeof(*t) > next_offset)\n\t\treturn -EINVAL;\n\n\tt = (void *)(e + target_offset);\n\tif (t->u.target_size < sizeof(*t))\n\t\treturn -EINVAL;\n\n\tif (target_offset + t->u.target_size > next_offset)\n\t\treturn -EINVAL;\n\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&\n\t    target_offset + sizeof(struct xt_standard_target) != next_offset)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1801
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "service_info *FindServiceEventURLPath(\n\tservice_table *table, const char *eventURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\n\tif (table &&\n\t\tparse_uri(eventURLPath, strlen(eventURLPath), &parsed_url_in) ==\n\t\t\tHTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->eventURL) {\n\t\t\t\tif (parse_uri(finger->eventURL,\n\t\t\t\t\t    strlen(finger->eventURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
        "output": "1",
        "idx": 7996
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void pipe_truncate(struct iov_iter *i)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tif (pipe->nrbufs) {\n\t\tsize_t off = i->iov_offset;\n\t\tint idx = i->idx;\n\t\tint nrbufs = (idx - pipe->curbuf) & (pipe->buffers - 1);\n\t\tif (off) {\n\t\t\tpipe->bufs[idx].len = off - pipe->bufs[idx].offset;\n\t\t\tidx = next_idx(idx, pipe);\n\t\t\tnrbufs++;\n\t\t}\n\t\twhile (pipe->nrbufs > nrbufs) {\n\t\t\tpipe_buf_release(pipe, &pipe->bufs[idx]);\n\t\t\tidx = next_idx(idx, pipe);\n\t\t\tpipe->nrbufs--;\n\t\t}\n\t}\n}",
        "output": "0",
        "idx": 2095
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct ib_ucontext *hns_roce_alloc_ucontext(struct ib_device *ib_dev,\n\t\t\t\t\t\t   struct ib_udata *udata)\n{\n\tint ret = 0;\n\tstruct hns_roce_ucontext *context;\n\tstruct hns_roce_ib_alloc_ucontext_resp resp;\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\n\n\tresp.qp_tab_size = hr_dev->caps.num_qps;\n\n\tcontext = kmalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = hns_roce_uar_alloc(hr_dev, &context->uar);\n\tif (ret)\n\t\tgoto error_fail_uar_alloc;\n\n\tif (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RECORD_DB) {\n\t\tINIT_LIST_HEAD(&context->page_list);\n\t\tmutex_init(&context->page_mutex);\n\t}\n\n\tret = ib_copy_to_udata(udata, &resp, sizeof(resp));\n\tif (ret)\n\t\tgoto error_fail_copy_to_udata;\n\n\treturn &context->ibucontext;\n\nerror_fail_copy_to_udata:\n\thns_roce_uar_free(hr_dev, &context->uar);\n\nerror_fail_uar_alloc:\n\tkfree(context);\n\n\treturn ERR_PTR(ret);\n}",
        "output": "1",
        "idx": 1850
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int check_name(char *name, int size)\n{\n\tchar *start = name;\n\n\tif(name[0] == '.') {\n\t\tif(name[1] == '.')\n\t\t\tname++;\n\t\tif(name[1] == '/' || name[1] == '\\0')\n\t\t\treturn FALSE;\n\t}\n\n\twhile(name[0] != '/' && name[0] != '\\0')\n\t\tname ++;\n\n\tif(name[0] == '/')\n\t\treturn FALSE;\n\n\tif((name - start) != size)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}",
        "output": "0",
        "idx": 7459
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE2(osf_getdomainname, char __user *, name, int, namelen)\n{\n\tunsigned len;\n\tint i;\n\n\tif (!access_ok(VERIFY_WRITE, name, namelen))\n\t\treturn -EFAULT;\n\n\tlen = namelen;\n\tif (len > 32)\n\t\tlen = 32;\n\n\tdown_read(&uts_sem);\n\tfor (i = 0; i < len; ++i) {\n\t\t__put_user(utsname()->domainname[i], name + i);\n\t\tif (utsname()->domainname[i] == '\\0')\n\t\t\tbreak;\n\t}\n\tup_read(&uts_sem);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 565
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int mb2_cache_entry_put(struct mb2_cache *cache,\n\t\t\t\t      struct mb2_cache_entry *entry)\n{\n\tif (!atomic_dec_and_test(&entry->e_refcnt))\n\t\treturn 0;\n\t__mb2_cache_entry_free(entry);\n\treturn 1;\n}",
        "output": "0",
        "idx": 1623
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "create_tls_session(int csock, int type  )\n{\n    int rc = 0;\n    gnutls_session *session = gnutls_malloc(sizeof(gnutls_session));\n\n    gnutls_init(session, type);\n#  ifdef HAVE_GNUTLS_PRIORITY_SET_DIRECT\n/*      http:\n    gnutls_priority_set_direct(*session, \"NORMAL:+ANON-DH\", NULL);\n#  else\n    gnutls_set_default_priority(*session);\n    gnutls_kx_set_priority(*session, tls_kx_order);\n#  endif\n    gnutls_transport_set_ptr(*session, (gnutls_transport_ptr) GINT_TO_POINTER(csock));\n    switch (type) {\n        case GNUTLS_SERVER:\n            gnutls_credentials_set(*session, GNUTLS_CRD_ANON, anon_cred_s);\n            break;\n        case GNUTLS_CLIENT:\n            gnutls_credentials_set(*session, GNUTLS_CRD_ANON, anon_cred_c);\n            break;\n    }\n\n    do {\n        rc = gnutls_handshake(*session);\n    } while (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN);\n\n    if (rc < 0) {\n        crm_err(\"Handshake failed: %s\", gnutls_strerror(rc));\n        gnutls_deinit(*session);\n        gnutls_free(session);\n        return NULL;\n    }\n    return session;\n}",
        "output": "1",
        "idx": 3740
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int mount_entry_on_systemfs(struct mntent *mntent)\n{\n  return mount_entry_on_generic(mntent, mntent->mnt_dir);\n}",
        "output": "1",
        "idx": 4358
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void prekey_handler(const char *userid,\n\t\t\t   const uint8_t *key, size_t key_len,\n\t\t\t   uint16_t id, const char *clientid,\n\t\t\t   bool last, void *arg)\n{\n\tstruct session *sess;\n\tchar lclientid[64];\n\tint err;\n\n\toutput(\"prekey_handler: %zu bytes, user:%s[%u] -> %s\\n\",\n\t       key_len, userid, id, clientid);\n\n\n\terr = client_id_load(lclientid, sizeof(lclientid));\n\tif (err) {\n\t\tdebug(\"my clientid not set -- cannot store prekeys\\n\");\n\t\treturn;\n\t}\n\n\tsess = cryptobox_session_find(g_cryptobox, userid, clientid, lclientid);\n\tif (sess) {\n\t\toutput(\"prekey: session found\\n\");\n\t}\n\telse {\n\t\tinfo(\"conv: adding key to cryptobox for clientid=%s\\n\",\n\t\t     clientid);\n\n\t\terr = cryptobox_session_add_send(g_cryptobox, userid, clientid, lclientid,\n\t\t\t\t\t\t key, key_len);\n\t\tif (err) {\n\t\t\twarning(\"cryptobox_session_add_send failed (%m)\\n\",\n\t\t\t\terr);\n\t\t}\n\t}\n}",
        "output": "1",
        "idx": 8826
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int may_create_in_sticky(umode_t dir_mode, kuid_t dir_uid,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\n\tif (likely(dir_mode & 0002) ||\n\t    (dir_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";\n\t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 4597
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tcp_v6_send_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t      struct flowi *fl,\n\t\t\t      struct request_sock *req,\n\t\t\t      struct tcp_fastopen_cookie *foc,\n\t\t\t      bool attach_req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tstruct sk_buff *skb;\n\tint err = -ENOMEM;\n\n\tif (!dst && (dst = inet6_csk_route_req(sk, fl6, req,\n\t\t\t\t\t       IPPROTO_TCP)) == NULL)\n\t\tgoto done;\n\n\tskb = tcp_make_synack(sk, dst, req, foc, attach_req);\n\n\tif (skb) {\n\t\t__tcp_v6_send_check(skb, &ireq->ir_v6_loc_addr,\n\t\t\t\t    &ireq->ir_v6_rmt_addr);\n\n\t\tfl6->daddr = ireq->ir_v6_rmt_addr;\n\t\tif (np->repflow && ireq->pktopts)\n\t\t\tfl6->flowlabel = ip6_flowlabel(ipv6_hdr(ireq->pktopts));\n\n\t\terr = ip6_xmit(sk, skb, fl6, np->opt, np->tclass);\n\t\terr = net_xmit_eval(err);\n\t}\n\ndone:\n\treturn err;\n}",
        "output": "1",
        "idx": 970
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "INTERNAL void vterm_screen_free(VTermScreen *screen)\n{\n  vterm_allocator_free(screen->vt, screen->buffers[0]);\n  if(screen->buffers[1])\n    vterm_allocator_free(screen->vt, screen->buffers[1]);\n\n  vterm_allocator_free(screen->vt, screen->sb_buffer);\n\n  vterm_allocator_free(screen->vt, screen);\n}",
        "output": "1",
        "idx": 5830
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_public_ int sd_bus_enqueue_for_read(sd_bus *bus, sd_bus_message *m) {\n        int r;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(m, -EINVAL);\n        assert_return(m->sealed, -EINVAL);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (!BUS_IS_OPEN(bus->state))\n                return -ENOTCONN;\n\n\n        r = bus_rqueue_make_room(bus);\n        if (r < 0)\n                return r;\n\n        bus->rqueue[bus->rqueue_size++] = bus_message_ref_queued(m, bus);\n        return 0;\n}",
        "output": "0",
        "idx": 7701
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Jsi_RC jsi_ArrayPopCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_Value *v;\n    Jsi_Obj *obj;\n    obj = _this->d.obj;\n    int i = Jsi_ObjGetLength(interp, obj) - 1;\n\n    if (i < 0) {\n        Jsi_ValueMakeUndef(interp, ret);\n        return JSI_OK;\n    }\n    \n    if (obj->arr) {\n        if ((v = obj->arr[i])) {\n            obj->arr[i] = NULL;\n            obj->arrCnt--;\n        }\n    } else {\n        v = Jsi_ValueArrayIndex(interp, _this, i);\n    }\n    if (v) {\n        Jsi_DecrRefCount(interp, *ret);\n        *ret = v;\n    }\n    Jsi_ObjSetLength(interp, obj, i);\n    return JSI_OK;\n}",
        "output": "1",
        "idx": 8164
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n\n  while (new_len > string->space)\n    {\n      if (string->space == 0)\n\tstring->space = 1;\n      else\n\tstring->space *= 2;\n\n      if (string->space < 0)\n\t{\n\t  g_warning (\"glyph string length overflows maximum integer size, truncated\");\n\t  new_len = string->space = G_MAXINT - 8;\n\t}\n    }\n\n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}",
        "output": "1",
        "idx": 3340
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "id3_skip (SF_PRIVATE * psf)\n{\tunsigned char\tbuf [10] ;\n\n\tmemset (buf, 0, sizeof (buf)) ;\n\tpsf_binheader_readf (psf, \"pb\", 0, buf, 10) ;\n\n\tif (buf [0] == 'I' && buf [1] == 'D' && buf [2] == '3')\n\t{\tint\toffset = buf [6] & 0x7f ;\n\t\toffset = (offset << 7) | (buf [7] & 0x7f) ;\n\t\toffset = (offset << 7) | (buf [8] & 0x7f) ;\n\t\toffset = (offset << 7) | (buf [9] & 0x7f) ;\n\n\t\tpsf_log_printf (psf, \"ID3 length : %d\\n--------------------\\n\", offset) ;\n\n\t\tif (offset < 0)\n\t\t\treturn 0 ;\n\n\t\tpsf->fileoffset += offset + 10 ;\n\t\tpsf_binheader_readf (psf, \"p\", psf->fileoffset) ;\n\n\t\treturn 1 ;\n\t\t} ;\n\n\treturn 0 ;\n} ",
        "output": "1",
        "idx": 4910
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long ZEXPORT inflateMark(strm)\nz_streamp strm;\n{\n    struct inflate_state FAR *state;\n\n    if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;\n    state = (struct inflate_state FAR *)strm->state;\n    return ((long)(state->back) << 16) +\n        (state->mode == COPY ? state->length :\n            (state->mode == MATCH ? state->was - state->length : 0));\n}",
        "output": "1",
        "idx": 6072
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "err_t verify_signed_hash(const struct RSA_public_key *k\n                         , u_char *s, unsigned int s_max_octets\n                         , u_char **psig\n                         , size_t hash_len\n                         , const u_char *sig_val, size_t sig_len)\n{\n    unsigned int padlen;\n\n    {\n\tchunk_t temp_s;\n\tMP_INT c;\n\n\tn_to_mpz(&c, sig_val, sig_len);\n\toswcrypto.mod_exp(&c, &c, &k->e, &k->n);\n\n\ttemp_s = mpz_to_n(&c, sig_len);\t\n        if(s_max_octets < sig_len) {\n            return \"2\"\"exponentiation failed; too many octets\";\n        }\n\tmemcpy(s, temp_s.ptr, sig_len);\n\tpfree(temp_s.ptr);\n\tmpz_clear(&c);\n    }\n\n    padlen = sig_len - 3 - hash_len;\n\n    DBG(DBG_CRYPT,\n\tDBG_dump(\"verify_sh decrypted SIG1:\", s, sig_len));\n    DBG(DBG_CRYPT, DBG_log(\"pad_len calculated: %d hash_len: %d\", padlen, (int)hash_len));\n\n    if(s[0]    != 0x00\n       || s[1] != 0x01\n       || s[padlen+2] != 0x00) {\n\treturn \"3\"\"SIG padding does not check out\";\n    }\n\n    s += padlen + 3;\n    (*psig) = s;\n\n    return NULL;\n}",
        "output": "1",
        "idx": 6990
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int do_fpu_inst(unsigned short inst, struct pt_regs *regs)\n{\n\tstruct task_struct *tsk = current;\n\tstruct sh_fpu_soft_struct *fpu = &(tsk->thread.xstate->softfpu);\n\n\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);\n\n\tif (!(task_thread_info(tsk)->status & TS_USEDFPU)) {\n\t\tfpu_init(fpu);\n\t\ttask_thread_info(tsk)->status |= TS_USEDFPU;\n\t}\n\n\treturn fpu_emulate(inst, fpu, regs);\n}",
        "output": "1",
        "idx": 466
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_pli(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length)\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n\n    PJ_ASSERT_RETURN(buf, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= 12, PJ_ETOOSMALL);\n\n    if (hdr->pt != RTCP_PSFB || hdr->count != 1)\n\treturn PJ_ENOTFOUND;\n\n    return PJ_SUCCESS;\n}",
        "output": "1",
        "idx": 8044
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ZEXPORT deflatePrime (strm, bits, value)\n    z_streamp strm;\n    int bits;\n    int value;\n{\n    deflate_state *s;\n    int put;\n\n    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;\n    s = strm->state;\n    if (s->sym_buf < s->pending_out + ((Buf_size + 7) >> 3))\n        return Z_BUF_ERROR;\n    do {\n        put = Buf_size - s->bi_valid;\n        if (put > bits)\n            put = bits;\n        s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);\n        s->bi_valid += put;\n        _tr_flush_bits(s);\n        value >>= put;\n        bits -= put;\n    } while (bits);\n    return Z_OK;\n}",
        "output": "0",
        "idx": 8551
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0;\n\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n\n    authResult = rfbClientSwap32IfLE(authResult);\n\n    switch (authResult) {\n    case rfbVncAuthOK:\n      rfbClientLog(\"VNC authentication succeeded\\n\");\n      return TRUE;\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        ReadReason(client);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:\n      rfbClientLog(\"VNC authentication failed - too many tries\\n\");\n      return FALSE;\n    }\n\n    rfbClientLog(\"Unknown VNC authentication result: %d\\n\",\n                 (int)authResult);\n    return FALSE;\n}",
        "output": "0",
        "idx": 8909
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "trustedDecryptDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret,\n                           uint32_t enc_len,\n                           uint8_t *decrypted_dkg_secret) {\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_dkg_secret);\n    CHECK_STATE(decrypted_dkg_secret);\n\n    int status = AES_decrypt(encrypted_dkg_secret, enc_len, (char *) decrypted_dkg_secret,\n                             3072);\n\n    CHECK_STATUS2(\"aes decrypt data - encrypted_dkg_secret failed with status %d\")\n\n    SET_SUCCESS\n\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}",
        "output": "1",
        "idx": 8710
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cil_reset_classperms_set(struct cil_classperms_set *cp_set)\n{\n\tif (cp_set == NULL) {\n\t\treturn;\n\t}\n\n\tcp_set->set = NULL;\n}",
        "output": "0",
        "idx": 8485
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(RecursiveDirectoryIterator, getSubPathname)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar *sub_name;\n\tint len;\n\tchar slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (intern->u.dir.sub_path) {\n\t\tlen = spprintf(&sub_name, 0, \"%s%c%s\", intern->u.dir.sub_path, slash, intern->u.dir.entry.d_name);\n\t\tRETURN_STRINGL(sub_name, len, 0);\n\t} else {\n\t\tRETURN_STRING(intern->u.dir.entry.d_name, 1);\n\t}\n}",
        "output": "1",
        "idx": 3962
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cxusb_ctrl_msg(struct dvb_usb_device *d,\n\t\t\t  u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)\n{\n\tstruct cxusb_state *st = d->priv;\n\tint ret;\n\n\tif (1 + wlen > MAX_XFER_SIZE) {\n\t\twarn(\"i2c wr: len=%d is too big!\\n\", wlen);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (rlen > MAX_XFER_SIZE) {\n\t\twarn(\"i2c rd: len=%d is too big!\\n\", rlen);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmutex_lock(&d->data_mutex);\n\tst->data[0] = cmd;\n\tmemcpy(&st->data[1], wbuf, wlen);\n\tret = dvb_usb_generic_rw(d, st->data, 1 + wlen, st->data, rlen, 0);\n\tif (!ret && rbuf && rlen)\n\t\tmemcpy(rbuf, st->data, rlen);\n\n\tmutex_unlock(&d->data_mutex);\n\treturn ret;\n}",
        "output": "0",
        "idx": 2141
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Exit_status safe_connect()\n{\n  mysql= mysql_init(NULL);\n\n  if (!mysql)\n  {\n    error(\"Failed on mysql_init.\");\n    return ERROR_STOP;\n  }\n\n  SSL_SET_OPTIONS(mysql);\n\n  if (opt_plugin_dir && *opt_plugin_dir)\n    mysql_options(mysql, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n\n  if (opt_default_auth && *opt_default_auth)\n    mysql_options(mysql, MYSQL_DEFAULT_AUTH, opt_default_auth);\n\n  if (opt_protocol)\n    mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(mysql, MYSQL_OPT_BIND, opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME,\n                  shared_memory_base_name);\n#endif\n  mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(mysql, MYSQL_OPT_CONNECT_ATTR_ADD,\n                 \"program_name\", \"mysqlbinlog\");\n  if (!mysql_real_connect(mysql, host, user, pass, 0, port, sock, 0))\n  {\n    error(\"Failed on connect: %s\", mysql_error(mysql));\n    return ERROR_STOP;\n  }\n  mysql->reconnect= 1;\n  return OK_CONTINUE;\n}",
        "output": "0",
        "idx": 7375
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int unmap_ref_private(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\t\tstruct page *page, unsigned long address)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct vm_area_struct *iter_vma;\n\tstruct address_space *mapping;\n\tstruct prio_tree_iter iter;\n\tpgoff_t pgoff;\n\n\taddress = address & huge_page_mask(h);\n\tpgoff = vma_hugecache_offset(h, vma, address);\n\tmapping = (struct address_space *)page_private(page);\n\n\tmutex_lock(&mapping->i_mmap_mutex);\n\tvma_prio_tree_foreach(iter_vma, &iter, &mapping->i_mmap, pgoff, pgoff) {\n\t\tif (iter_vma == vma)\n\t\t\tcontinue;\n\n\t\tif (!is_vma_resv_set(iter_vma, HPAGE_RESV_OWNER))\n\t\t\t__unmap_hugepage_range(iter_vma,\n\t\t\t\taddress, address + huge_page_size(h),\n\t\t\t\tpage);\n\t}\n\tmutex_unlock(&mapping->i_mmap_mutex);\n\n\treturn 1;\n}",
        "output": "1",
        "idx": 692
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "smb2_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t *of = NULL;\n\tuint16_t StructSize;\n\tuint16_t reserved1;\n\tuint32_t reserved2;\n\tsmb2fid_t smb2fid;\n\tuint32_t status;\n\tint rc = 0;\n\n\trc = smb_mbc_decodef(\n\t    &sr->smb_data, \"wwlqq\",\n\t    &StructSize,\t\t\n\t    &reserved1,\t\t\t\n\t    &reserved2,\t\t\t\n\t    &smb2fid.persistent,\t\n\t    &smb2fid.temporal);\t\t\n\tif (rc)\n\t\treturn (SDRC_ERROR);\n\tif (StructSize != 24)\n\t\treturn (SDRC_ERROR);\n\n\tstatus = smb2sr_lookup_fid(sr, &smb2fid);\n\tif (status) {\n\t\tsmb2sr_put_error(sr, status);\n\t\treturn (SDRC_SUCCESS);\n\t}\n\tof = sr->fid_ofile;\n\n\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n\n\t(void) smb_mbc_encodef(\n\t    &sr->reply, \"wwl\",\n\t    4,\t\n\t    0); \n\n\treturn (SDRC_SUCCESS);\n}",
        "output": "1",
        "idx": 4896
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "f_py3eval(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n\n    if (check_restricted() || check_secure())\n\treturn;\n\n    if (p_pyx == 0)\n\tp_pyx = 3;\n\n    str = tv_get_string_buf(&argvars[0], buf);\n    do_py3eval(str, rettv);\n}",
        "output": "0",
        "idx": 8165
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int rose_parse_facilities(unsigned char *p, unsigned packet_len,\n\tstruct rose_facilities_struct *facilities)\n{\n\tint facilities_len, len;\n\n\tfacilities_len = *p++;\n\n\tif (facilities_len == 0 || (unsigned)facilities_len > packet_len)\n\t\treturn 0;\n\n\twhile (facilities_len >= 3 && *p == 0x00) {\n\t\tfacilities_len--;\n\t\tp++;\n\n\t\tswitch (*p) {\n\t\tcase FAC_NATIONAL:\t\t\n\t\t\tlen = rose_parse_national(p + 1, facilities, facilities_len - 1);\n\t\t\tbreak;\n\n\t\tcase FAC_CCITT:\t\t\n\t\t\tlen = rose_parse_ccitt(p + 1, facilities, facilities_len - 1);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintk(KERN_DEBUG \"ROSE: rose_parse_facilities - unknown facilities family %02X\\n\", *p);\n\t\t\tlen = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (len < 0)\n\t\t\treturn 0;\n\t\tif (WARN_ON(len >= facilities_len))\n\t\t\treturn 0;\n\t\tfacilities_len -= len + 1;\n\t\tp += len + 1;\n\t}\n\n\treturn facilities_len == 0;\n}",
        "output": "0",
        "idx": 421
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool caller_may_see_dir(pid_t pid, const char *contrl, const char *cg)\n{\n\tbool answer = false;\n\tchar *c2, *task_cg;\n\tsize_t target_len, task_len;\n\n\tif (strcmp(cg, \"/\") == 0)\n\t\treturn true;\n\n\tc2 = get_pid_cgroup(pid, contrl);\n\n\tif (!c2)\n\t\treturn false;\n\n\ttask_cg = c2 + 1;\n\ttarget_len = strlen(cg);\n\ttask_len = strlen(task_cg);\n\tif (strcmp(cg, task_cg) == 0) {\n\t\tanswer = true;\n\t\tgoto out;\n\t}\n\tif (target_len < task_len) {\n\t\tif (strncmp(task_cg, cg, target_len) == 0 && task_cg[target_len] == '/')\n\t\t\tanswer = true;\n\t\tgoto out;\n\t}\n\tif (target_len > task_len) {\n\t\tif (strncmp(task_cg, cg, task_len) == 0 && cg[task_len] == '/')\n\t\t\tanswer = true;\n\t\tgoto out;\n\t}\n\nout:\n\tfree(c2);\n\treturn answer;\n}",
        "output": "0",
        "idx": 7257
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cJSON_AddItemToObject( cJSON *object, const char *string, cJSON *item )\n{\n\tif ( ! item )\n\t\treturn;\n\tif ( item->string )\n\t\tcJSON_free( item->string );\n\titem->string = cJSON_strdup( string );\n\tcJSON_AddItemToArray( object, item );\n}",
        "output": "1",
        "idx": 5900
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mnt_fs_is_deleted(struct libmnt_fs *fs)\n{\n\treturn mnt_fs_get_flags(fs) & MNT_FS_DELETED;\n}",
        "output": "1",
        "idx": 8778
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rose_start_t2timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tdel_timer(&rose->timer);\n\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t2;\n\n\tadd_timer(&rose->timer);\n}",
        "output": "1",
        "idx": 2058
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void switch_to_bitmap(unsigned long tifp)\n{\n\tif (tifp & _TIF_IO_BITMAP)\n\t\ttss_invalidate_io_bitmap(this_cpu_ptr(&cpu_tss_rw));\n}",
        "output": "1",
        "idx": 1856
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void hugetlb_vm_op_close(struct vm_area_struct *vma)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct resv_map *reservations = vma_resv_map(vma);\n\tstruct hugepage_subpool *spool = subpool_vma(vma);\n\tunsigned long reserve;\n\tunsigned long start;\n\tunsigned long end;\n\n\tif (reservations) {\n\t\tstart = vma_hugecache_offset(h, vma, vma->vm_start);\n\t\tend = vma_hugecache_offset(h, vma, vma->vm_end);\n\n\t\treserve = (end - start) -\n\t\t\tregion_count(&reservations->regions, start, end);\n\n\t\tresv_map_put(vma);\n\n\t\tif (reserve) {\n\t\t\thugetlb_acct_memory(h, -reserve);\n\t\t\thugepage_subpool_put_pages(spool, reserve);\n\t\t}\n\t}\n}",
        "output": "0",
        "idx": 953
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&dev->lock);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tbuf[1] &= ~(1 << offset);\n\tbuf[2] = gpio_push_pull;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = 0;\n\nexit:\n\tmutex_unlock(&dev->lock);\n\treturn ret < 0 ? ret : -EIO;\n}",
        "output": "0",
        "idx": 2113
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct resource_pool *dce120_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "output": "0",
        "idx": 4483
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int read_exceptions(struct pstore *ps,\n\t\t\t   int (*callback)(void *callback_context, chunk_t old,\n\t\t\t\t\t   chunk_t new),\n\t\t\t   void *callback_context)\n{\n\tint r, full = 1;\n\n\tfor (ps->current_area = 0; full; ps->current_area++) {\n\t\tr = area_io(ps, READ);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tr = insert_exceptions(ps, callback, callback_context, &full);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tps->current_area--;\n\n\tskip_metadata(ps);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 3323
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\t#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS\n\tif (cpu_feature_enabled(X86_FEATURE_OSPKE)) {\n\t\tmm->context.pkey_allocation_map = 0x1;\n\t\tmm->context.execute_only_pkey = -1;\n\t}\n\t#endif\n\tinit_new_context_ldt(tsk, mm);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1648
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ext4_set_bh_endio(struct buffer_head *bh, struct inode *inode)\n{\n\text4_io_end_t *io_end;\n\tstruct page *page = bh->b_page;\n\tloff_t offset = (sector_t)page->index << PAGE_CACHE_SHIFT;\n\tsize_t size = bh->b_size;\n\nretry:\n\tio_end = ext4_init_io_end(inode, GFP_ATOMIC);\n\tif (!io_end) {\n\t\tif (printk_ratelimit())\n\t\t\tprintk(KERN_WARNING \"%s: allocation fail\\n\", __func__);\n\t\tschedule();\n\t\tgoto retry;\n\t}\n\tio_end->offset = offset;\n\tio_end->size = size;\n\tio_end->page = page;\n\tget_page(io_end->page);\n\n\tbh->b_private = io_end;\n\tbh->b_end_io = ext4_end_io_buffer_write;\n\treturn 0;\n}",
        "output": "0",
        "idx": 3161
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)\n{\n\tu32 hash[MD5_DIGEST_WORDS];\n\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = (__force u32)dport ^ net_secret[14];\n\thash[3] = net_secret[15];\n\n\tmd5_transform(hash, net_secret);\n\n\treturn hash[0];\n}",
        "output": "0",
        "idx": 793
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __inline__ void ipv6_select_ident(struct frag_hdr *fhdr)\n{\n\tstatic u32 ipv6_fragmentation_id = 1;\n\tstatic DEFINE_SPINLOCK(ip6_id_lock);\n\n\tspin_lock_bh(&ip6_id_lock);\n\tfhdr->identification = htonl(ipv6_fragmentation_id);\n\tif (++ipv6_fragmentation_id == 0)\n\t\tipv6_fragmentation_id = 1;\n\tspin_unlock_bh(&ip6_id_lock);\n}",
        "output": "1",
        "idx": 562
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int stellaris_enet_init(SysBusDevice *sbd)\n{\n    DeviceState *dev = DEVICE(sbd);\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n\n    memory_region_init_io(&s->mmio, OBJECT(s), &stellaris_enet_ops, s,\n                          \"stellaris_enet\", 0x1000);\n    sysbus_init_mmio(sbd, &s->mmio);\n    sysbus_init_irq(sbd, &s->irq);\n    qemu_macaddr_default_if_unset(&s->conf.macaddr);\n\n    s->nic = qemu_new_nic(&net_stellaris_enet_info, &s->conf,\n                          object_get_typename(OBJECT(dev)), dev->id, s);\n    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);\n\n    stellaris_enet_reset(s);\n    register_savevm(dev, \"stellaris_enet\", -1, 1,\n                    stellaris_enet_save, stellaris_enet_load, s);\n    return 0;\n}",
        "output": "1",
        "idx": 3778
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parse_key_constraint_extension(struct sshbuf *m, char **sk_providerp)\n{\n\tchar *ext_name = NULL;\n\tint r;\n\n\tif ((r = sshbuf_get_cstring(m, &ext_name, NULL)) != 0) {\n\t\terror_fr(r, \"parse constraint extension\");\n\t\tgoto out;\n\t}\n\tdebug_f(\"constraint ext %s\", ext_name);\n\tif (strcmp(ext_name, \"sk-provider@openssh.com\") == 0) {\n\t\tif (sk_providerp == NULL) {\n\t\t\terror_f(\"%s not valid here\", ext_name);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (*sk_providerp != NULL) {\n\t\t\terror_f(\"%s already set\", ext_name);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(m, sk_providerp, NULL)) != 0) {\n\t\t\terror_fr(r, \"parse %s\", ext_name);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\terror_f(\"unsupported constraint \\\"%s\\\"\", ext_name);\n\t\tr = SSH_ERR_FEATURE_UNSUPPORTED;\n\t\tgoto out;\n\t}\n\tr = 0;\n out:\n\tfree(ext_name);\n\treturn r;\n}",
        "output": "0",
        "idx": 7651
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int MP4_ReadBox_String( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_string_t );\n\n    if( p_box->i_size < 8 || p_box->i_size > SIZE_MAX )\n        MP4_READBOX_EXIT( 0 );\n\n    p_box->data.p_string->psz_text = malloc( p_box->i_size + 1 - 8 ); \n    if( p_box->data.p_string->psz_text == NULL )\n        MP4_READBOX_EXIT( 0 );\n\n    memcpy( p_box->data.p_string->psz_text, p_peek, p_box->i_size - 8 );\n    p_box->data.p_string->psz_text[p_box->i_size - 8] = '\\0';\n\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"read box: \\\"%4.4s\\\" text=`%s'\", (char *) & p_box->i_type,\n                 p_box->data.p_string->psz_text );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}",
        "output": "0",
        "idx": 6923
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int target_xcopy_locate_se_dev_e4_iter(struct se_device *se_dev,\n\t\t\t\t\t      void *data)\n{\n\tstruct xcopy_dev_search_info *info = data;\n\tunsigned char tmp_dev_wwn[XCOPY_NAA_IEEE_REGEX_LEN];\n\tint rc;\n\n\tif (!se_dev->dev_attrib.emulate_3pc)\n\t\treturn 0;\n\n\tmemset(&tmp_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);\n\ttarget_xcopy_gen_naa_ieee(se_dev, &tmp_dev_wwn[0]);\n\n\trc = memcmp(&tmp_dev_wwn[0], info->dev_wwn, XCOPY_NAA_IEEE_REGEX_LEN);\n\tif (rc != 0)\n\t\treturn 0;\n\n\tinfo->found_dev = se_dev;\n\tpr_debug(\"XCOPY 0xe4: located se_dev: %p\\n\", se_dev);\n\n\trc = target_depend_item(&se_dev->dev_group.cg_item);\n\tif (rc != 0) {\n\t\tpr_err(\"configfs_depend_item attempt failed: %d for se_dev: %p\\n\",\n\t\t       rc, se_dev);\n\t\treturn rc;\n\t}\n\n\tpr_debug(\"Called configfs_depend_item for se_dev: %p se_dev->se_dev_group: %p\\n\",\n\t\t se_dev, &se_dev->dev_group);\n\treturn 1;\n}",
        "output": "1",
        "idx": 1916
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t aio_setup_vectored_rw(struct kiocb *kiocb,\n\t\t\t\t     int rw, char __user *buf,\n\t\t\t\t     unsigned long *nr_segs,\n\t\t\t\t     size_t *len,\n\t\t\t\t     struct iovec **iovec,\n\t\t\t\t     bool compat)\n{\n\tssize_t ret;\n\n\t*nr_segs = *len;\n\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\tret = compat_rw_copy_check_uvector(rw,\n\t\t\t\t(struct compat_iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\telse\n#endif\n\t\tret = rw_copy_check_uvector(rw,\n\t\t\t\t(struct iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*len = ret;\n\treturn 0;\n}",
        "output": "1",
        "idx": 2824
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void scsi_write_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    assert(r->req.aiocb == NULL);\n\n    if (r->req.cmd.mode != SCSI_XFER_TO_DEV) {\n        DPRINTF(\"Data transfer direction invalid\\n\");\n        scsi_write_complete(r, -EINVAL);\n        return;\n    }\n\n    n = r->qiov.size / 512;\n    if (n) {\n        if (s->tray_open) {\n            scsi_write_complete(r, -ENOMEDIUM);\n        }\n        bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);\n        r->req.aiocb = bdrv_aio_writev(s->bs, r->sector, &r->qiov, n,\n                                       scsi_write_complete, r);\n        if (r->req.aiocb == NULL) {\n            scsi_write_complete(r, -ENOMEM);\n        }\n    } else {\n        scsi_write_complete(r, 0);\n    }\n}",
        "output": "0",
        "idx": 4999
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "init_ctx_new(OM_uint32 *minor_status,\n\t     spnego_gss_cred_id_t spcred,\n\t     gss_ctx_id_t *ctx,\n\t     send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\tsc = create_spnego_ctx();\n\tif (sc == NULL)\n\t\treturn GSS_S_FAILURE;\n\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_INITIATE,\n\t\t\t\t   &sc->mech_set);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tsc->internal_mech = &sc->mech_set->elements[0];\n\n\tif (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->ctx_handle = GSS_C_NO_CONTEXT;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\t*tokflag = INIT_TOKEN_SEND;\n\tret = GSS_S_CONTINUE_NEEDED;\n\ncleanup:\n\trelease_spnego_ctx(&sc);\n\treturn ret;\n}",
        "output": "1",
        "idx": 100
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline short key_read_state(const struct key *key)\n{\n\treturn smp_load_acquire(&key->state);\n}",
        "output": "0",
        "idx": 2475
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BOOL rdp_read_font_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (length > 5)\n\t\tStream_Seek_UINT16(s); \n\n\tif (length > 7)\n\t\tStream_Seek_UINT16(s); \n\n\treturn TRUE;\n}",
        "output": "0",
        "idx": 5723
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "usage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-t life] [command [arg ...]]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}",
        "output": "1",
        "idx": 5598
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC bool httpGetStreaming(HttpHost *host, cchar *mime, cchar *uri)\n{\n    MprKey      *kp;\n\n    assert(host);\n    assert(host->streams);\n\n    if (schr(mime, ';')) {\n        mime = ssplit(sclone(mime), \";\", 0);\n    }\n    if ((kp = mprLookupKeyEntry(host->streams, mime)) != 0) {\n        if (kp->data == NULL || sstarts(uri, kp->data)) {\n            return kp->type;\n        }\n    }\n    return 1;\n}",
        "output": "0",
        "idx": 7029
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int put_chars(u32 vtermno, const char *buf, int count)\n{\n\tstruct port *port;\n\tstruct scatterlist sg[1];\n\tvoid *data;\n\tint ret;\n\n\tif (unlikely(early_put_chars))\n\t\treturn early_put_chars(vtermno, buf, count);\n\n\tport = find_port_by_vtermno(vtermno);\n\tif (!port)\n\t\treturn -EPIPE;\n\n\tdata = kmemdup(buf, count, GFP_ATOMIC);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tsg_init_one(sg, data, count);\n\tret = __send_to_port(port, sg, 1, count, data, false);\n\tkfree(data);\n\treturn ret;\n}",
        "output": "0",
        "idx": 2181
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "crm_send_tls(gnutls_session * session, const char *buf, size_t len)\n{\n    const char *unsent = buf;\n    int rc = 0;\n    int total_send;\n\n    if (buf == NULL) {\n        return -1;\n    }\n\n    total_send = len;\n    crm_trace(\"Message size: %d\", len);\n\n    while (TRUE) {\n        rc = gnutls_record_send(*session, unsent, len);\n\n        if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n            crm_debug(\"Retry\");\n\n        } else if (rc < 0) {\n            crm_err(\"Connection terminated rc = %d\", rc);\n            break;\n\n        } else if (rc < len) {\n            crm_debug(\"Only sent %d of %d bytes\", rc, len);\n            len -= rc;\n            unsent += rc;\n        } else {\n            crm_debug(\"Sent %d bytes\", rc);\n            break;\n        }\n    }\n\n    return rc < 0 ? rc : total_send;\n}",
        "output": "0",
        "idx": 5261
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int sem_lock(struct sem_array *sma, struct sembuf *sops,\n\t\t\t      int nsops)\n{\n\tint locknum;\n again:\n\tif (nsops == 1 && !sma->complex_count) {\n\t\tstruct sem *sem = sma->sem_base + sops->sem_num;\n\n\t\tspin_lock(&sem->lock);\n\n\t\tif (unlikely(sma->complex_count)) {\n\t\t\tspin_unlock(&sem->lock);\n\t\t\tgoto lock_array;\n\t\t}\n\n\t\tif (unlikely(spin_is_locked(&sma->sem_perm.lock))) {\n\t\t\tspin_unlock(&sem->lock);\n\t\t\tspin_unlock_wait(&sma->sem_perm.lock);\n\t\t\tgoto again;\n\t\t}\n\n\t\tlocknum = sops->sem_num;\n\t} else {\n\t\tint i;\n lock_array:\n\t\tspin_lock(&sma->sem_perm.lock);\n\t\tfor (i = 0; i < sma->sem_nsems; i++) {\n\t\t\tstruct sem *sem = sma->sem_base + i;\n\t\t\tspin_unlock_wait(&sem->lock);\n\t\t}\n\t\tlocknum = -1;\n\t}\n\treturn locknum;\n}",
        "output": "0",
        "idx": 3211
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u64 __skb_get_nlattr(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\tstruct nlattr *nla;\n\n\tif (skb_is_nonlinear(skb))\n\t\treturn 0;\n\n\tif (skb->len < sizeof(struct nlattr))\n\t\treturn 0;\n\n\tif (A > skb->len - sizeof(struct nlattr))\n\t\treturn 0;\n\n\tnla = nla_find((struct nlattr *) &skb->data[A], skb->len - A, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 3503
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct bsg_device *bd = file->private_data;\n\tssize_t bytes_written;\n\tint ret;\n\n\tdprintk(\"%s: write %Zd bytes\\n\", bd->name, count);\n\n\tif (unlikely(segment_eq(get_fs(), KERNEL_DS)))\n\t\treturn -EINVAL;\n\n\tbsg_set_block(bd, file);\n\n\tbytes_written = 0;\n\tret = __bsg_write(bd, buf, count, &bytes_written,\n\t\t\t  file->f_mode & FMODE_WRITE);\n\n\t*ppos = bytes_written;\n\n\tif (!bytes_written || err_block_err(ret))\n\t\tbytes_written = ret;\n\n\tdprintk(\"%s: returning %Zd\\n\", bd->name, bytes_written);\n\treturn bytes_written;\n}",
        "output": "0",
        "idx": 2059
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static netdev_tx_t veth_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_device *rcv = NULL;\n\tstruct veth_priv *priv, *rcv_priv;\n\tstruct veth_net_stats *stats, *rcv_stats;\n\tint length;\n\n\tpriv = netdev_priv(dev);\n\trcv = priv->peer;\n\trcv_priv = netdev_priv(rcv);\n\n\tstats = this_cpu_ptr(priv->stats);\n\trcv_stats = this_cpu_ptr(rcv_priv->stats);\n\n\tif (!(rcv->flags & IFF_UP))\n\t\tgoto tx_drop;\n\n\tif (dev->features & NETIF_F_NO_CSUM)\n\t\tskb->ip_summed = rcv_priv->ip_summed;\n\n\tlength = skb->len + ETH_HLEN;\n\tif (dev_forward_skb(rcv, skb) != NET_RX_SUCCESS)\n\t\tgoto rx_drop;\n\n\tstats->tx_bytes += length;\n\tstats->tx_packets++;\n\n\trcv_stats->rx_bytes += length;\n\trcv_stats->rx_packets++;\n\n\treturn NETDEV_TX_OK;\n\ntx_drop:\n\tkfree_skb(skb);\n\tstats->tx_dropped++;\n\treturn NETDEV_TX_OK;\n\nrx_drop:\n\tkfree_skb(skb);\n\trcv_stats->rx_dropped++;\n\treturn NETDEV_TX_OK;\n}",
        "output": "1",
        "idx": 214
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void watchdog_overflow_callback(struct perf_event *event,\n\t\t struct perf_sample_data *data,\n\t\t struct pt_regs *regs)\n{\n\tevent->hw.interrupts = 0;\n\n\tif (__this_cpu_read(watchdog_nmi_touch) == true) {\n\t\t__this_cpu_write(watchdog_nmi_touch, false);\n\t\treturn;\n\t}\n\n\tif (is_hardlockup()) {\n\t\tint this_cpu = smp_processor_id();\n\n\t\tif (__this_cpu_read(hard_watchdog_warn) == true)\n\t\t\treturn;\n\n\t\tif (hardlockup_panic)\n\t\t\tpanic(\"Watchdog detected hard LOCKUP on cpu %d\", this_cpu);\n\t\telse\n\t\t\tWARN(1, \"Watchdog detected hard LOCKUP on cpu %d\", this_cpu);\n\n\t\t__this_cpu_write(hard_watchdog_warn, true);\n\t\treturn;\n\t}\n\n\t__this_cpu_write(hard_watchdog_warn, false);\n\treturn;\n}",
        "output": "0",
        "idx": 711
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_q931_cc_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tif (length < 3) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tprint_16bits_val(ndo, (const uint16_t *)dat);\n\tND_PRINT((ndo, \", %02x\", dat[2]));\n\tdat += 3;\n\tlength -= 3;\n\tif (length != 0) {\n\t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, dat, length);\n\t}\n}",
        "output": "0",
        "idx": 6657
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(void) gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n{\n\tgdImagePtr pim = 0, tim = im;\n\tint interlace, BitsPerPixel;\n\tinterlace = im->interlace;\n\n\tif(im->trueColor) {\n\t\tpim = gdImageCreatePaletteFromTrueColor(im, 1, 256);\n\t\tif(!pim) {\n\t\t\treturn;\n\t\t}\n\t\ttim = pim;\n\t}\n\n\tBitsPerPixel = colorstobpp(tim->colorsTotal);\n\n\tGIFEncode(\n\t    out, tim->sx, tim->sy, interlace, 0, tim->transparent, BitsPerPixel,\n\t    tim->red, tim->green, tim->blue, tim);\n\n\tif(pim) {\n\t\tgdImageDestroy(\tpim);\n\t}\n}",
        "output": "1",
        "idx": 4458
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cipso_v4_req_delattr(struct request_sock *req)\n{\n\tstruct ip_options_rcu *opt;\n\tstruct inet_request_sock *req_inet;\n\n\treq_inet = inet_rsk(req);\n\topt = req_inet->opt;\n\tif (opt == NULL || opt->opt.cipso == 0)\n\t\treturn;\n\n\tcipso_v4_delopt(&req_inet->opt);\n}",
        "output": "0",
        "idx": 475
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void snd_msndmidi_input_read(void *mpuv)\n{\n\tunsigned long flags;\n\tstruct snd_msndmidi *mpu = mpuv;\n\tvoid *pwMIDQData = mpu->dev->mappedbase + MIDQ_DATA_BUFF;\n\n\tspin_lock_irqsave(&mpu->input_lock, flags);\n\twhile (readw(mpu->dev->MIDQ + JQS_wTail) !=\n\t       readw(mpu->dev->MIDQ + JQS_wHead)) {\n\t\tu16 wTmp, val;\n\t\tval = readw(pwMIDQData + 2 * readw(mpu->dev->MIDQ + JQS_wHead));\n\n\t\t\tif (test_bit(MSNDMIDI_MODE_BIT_INPUT_TRIGGER,\n\t\t\t\t     &mpu->mode))\n\t\t\t\tsnd_rawmidi_receive(mpu->substream_input,\n\t\t\t\t\t\t    (unsigned char *)&val, 1);\n\n\t\twTmp = readw(mpu->dev->MIDQ + JQS_wHead) + 1;\n\t\tif (wTmp > readw(mpu->dev->MIDQ + JQS_wSize))\n\t\t\twritew(0,  mpu->dev->MIDQ + JQS_wHead);\n\t\telse\n\t\t\twritew(wTmp,  mpu->dev->MIDQ + JQS_wHead);\n\t}\n\tspin_unlock_irqrestore(&mpu->input_lock, flags);\n}",
        "output": "1",
        "idx": 1614
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void doPost(HttpRequest req, HttpResponse res) {\n        set_content_type(res, \"text/html\");\n        if (ACTION(RUN))\n                handle_run(req, res);\n        else if (ACTION(STATUS))\n                print_status(req, res, 1);\n        else if (ACTION(STATUS2))\n                print_status(req, res, 2);\n        else if (ACTION(SUMMARY))\n                print_summary(req, res);\n        else if (ACTION(REPORT))\n                _printReport(req, res);\n        else if (ACTION(DOACTION))\n                handle_do_action(req, res);\n        else\n                handle_action(req, res);\n}",
        "output": "1",
        "idx": 6008
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int getSingletonPos(const char* str)\n{\n\tint result =-1;\n\tint i=0;\n\tint len = 0;\n\t\n\tif( str && ((len=strlen(str))>0) ){\n\t\tfor( i=0; i<len ; i++){\n\t\t\tif( isIDSeparator(*(str+i)) ){\n\t\t\t\tif( i==1){\n\t\t\t\t\tresult =0;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tif( isIDSeparator(*(str+i+2)) ){\n\t\t\t\t\t\tresult = i+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn result;\n}",
        "output": "1",
        "idx": 3872
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void pin_remove(struct fs_pin *pin)\n{\n\tspin_lock(&pin_lock);\n\thlist_del_init(&pin->m_list);\n\thlist_del_init(&pin->s_list);\n\tspin_unlock(&pin_lock);\n\tspin_lock_irq(&pin->wait.lock);\n\tpin->done = 1;\n\twake_up_locked(&pin->wait);\n\tspin_unlock_irq(&pin->wait.lock);\n}",
        "output": "0",
        "idx": 3903
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mark_object(struct object *obj, const char *name, void *data)\n{\n\tupdate_progress(data);\n}",
        "output": "0",
        "idx": 7241
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct desc;\n\tshort sel;\n\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn -1L;\n\n\tif (v8086_mode(regs))\n\t\treturn (unsigned long)(sel << 4);\n\n\tif (user_64bit_mode(regs)) {\n\t\tunsigned long base;\n\n\t\tif (seg_reg_idx == INAT_SEG_REG_FS)\n\t\t\trdmsrl(MSR_FS_BASE, base);\n\t\telse if (seg_reg_idx == INAT_SEG_REG_GS)\n\t\t\trdmsrl(MSR_KERNEL_GS_BASE, base);\n\t\telse\n\t\t\tbase = 0;\n\t\treturn base;\n\t}\n\n\tif (!sel)\n\t\treturn -1L;\n\n\tif (!get_desc(&desc, sel))\n\t\treturn -1L;\n\n\treturn get_desc_base(&desc);\n}",
        "output": "0",
        "idx": 4407
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_framing_cap_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_ASYNC_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_SYNC_MASK) {\n\t\tND_PRINT((ndo, \"S\"));\n\t}\n}",
        "output": "1",
        "idx": 4756
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ext4_xattr_cache_insert(struct mb2_cache *ext4_mb_cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tint error;\n\n\terror = mb2_cache_entry_create(ext4_mb_cache, GFP_NOFS, hash,\n\t\t\t\t       bh->b_blocknr);\n\tif (error) {\n\t\tif (error == -EBUSY)\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t} else\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n}",
        "output": "0",
        "idx": 1635
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)\n{\n\tunsigned char present = 0;\n\tstruct page *page;\n\n#ifdef CONFIG_SWAP\n\tif (shmem_mapping(mapping)) {\n\t\tpage = find_get_entry(mapping, pgoff);\n\t\tif (xa_is_value(page)) {\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n\t\t\tpage = find_get_page(swap_address_space(swp),\n\t\t\t\t\t     swp_offset(swp));\n\t\t}\n\t} else\n\t\tpage = find_get_page(mapping, pgoff);\n#else\n\tpage = find_get_page(mapping, pgoff);\n#endif\n\tif (page) {\n\t\tpresent = PageUptodate(page);\n\t\tput_page(page);\n\t}\n\n\treturn present;\n}",
        "output": "1",
        "idx": 3070
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void scsi_write_data(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    assert(r->req.aiocb == NULL);\n\n    if (r->req.cmd.mode != SCSI_XFER_TO_DEV) {\n        DPRINTF(\"Data transfer direction invalid\\n\");\n        scsi_write_complete(r, -EINVAL);\n        return;\n    }\n\n    n = r->iov.iov_len / 512;\n    if (n) {\n        if (s->tray_open) {\n            scsi_write_complete(r, -ENOMEDIUM);\n        }\n        qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n\n        bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);\n        r->req.aiocb = bdrv_aio_writev(s->bs, r->sector, &r->qiov, n,\n                                   scsi_write_complete, r);\n        if (r->req.aiocb == NULL) {\n            scsi_write_complete(r, -ENOMEM);\n        }\n    } else {\n        scsi_write_complete(r, 0);\n    }\n}",
        "output": "1",
        "idx": 3572
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned int xdr_set_page_base(struct xdr_stream *xdr,\n\t\t\t\t      unsigned int base, unsigned int len)\n{\n\tunsigned int pgnr;\n\tunsigned int maxlen;\n\tunsigned int pgoff;\n\tunsigned int pgend;\n\tvoid *kaddr;\n\n\tmaxlen = xdr->buf->page_len;\n\tif (base >= maxlen) {\n\t\tbase = maxlen;\n\t\tmaxlen = 0;\n\t} else\n\t\tmaxlen -= base;\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\n\txdr_stream_page_set_pos(xdr, base);\n\tbase += xdr->buf->page_base;\n\n\tpgnr = base >> PAGE_SHIFT;\n\txdr->page_ptr = &xdr->buf->pages[pgnr];\n\tkaddr = page_address(*xdr->page_ptr);\n\n\tpgoff = base & ~PAGE_MASK;\n\txdr->p = (__be32*)(kaddr + pgoff);\n\n\tpgend = pgoff + len;\n\tif (pgend > PAGE_SIZE)\n\t\tpgend = PAGE_SIZE;\n\txdr->end = (__be32*)(kaddr + pgend);\n\txdr->iov = NULL;\n\treturn len;\n}",
        "output": "1",
        "idx": 1946
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE from_document(VALUE klass, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlRelaxNGParserCtxtPtr ctx;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n\n  Data_Get_Struct(document, xmlDoc, doc);\n\n  doc = doc->doc;\n\n  ctx = xmlRelaxNGNewDocParserCtxt(doc);\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  schema = xmlRelaxNGParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n\n  return rb_schema;\n}",
        "output": "1",
        "idx": 8246
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_chainname_rulenum(const struct ip6t_entry *s, const struct ip6t_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ip6t_get_target_c(s);\n\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\n\t\tif (s->target_offset == sizeof(struct ip6t_entry) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t    t->verdict < 0 &&\n\t\t    unconditional(&s->ipv6)) {\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP6_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP6_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1200
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n{\n    char *buffer=NULL;\n    int   n=0;\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);\n\n    if(length == SIZE_MAX || length > INT_MAX) {\n\trfbErr(\"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\", (unsigned int)length);\n\trfbCloseClient(cl);\n\treturn NULL;\n    }\n\n    if (length>0) {\n        buffer=malloc((size_t)length+1);\n        if (buffer!=NULL) {\n            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(cl);\n                if (buffer!=NULL) free(buffer);\n                return NULL;\n            }\n            buffer[length]=0;\n        }\n    }\n    return buffer;\n}",
        "output": "0",
        "idx": 8917
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *arm_coherent_dma_alloc(struct device *dev, size_t size,\n\tdma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)\n{\n\tpgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);\n\tvoid *memory;\n\n\tif (dma_alloc_from_coherent(dev, size, handle, &memory))\n\t\treturn memory;\n\n\treturn __dma_alloc(dev, size, handle, gfp, prot, true,\n\t\t\t   __builtin_return_address(0));\n}",
        "output": "0",
        "idx": 3333
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bit_write_UMC (Bit_Chain *dat, BITCODE_UMC val)\n{\n  int i, j;\n  int negative;\n  unsigned char byte[5];\n  BITCODE_UMC mask;\n  BITCODE_UMC value;\n\n  value = val;\n  mask = 0x0000007f;\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = (unsigned char)((value & mask) >> j);\n      byte[i] |= 0x80;\n      mask = mask << 7;\n    }\n  for (i = 0; i < 4; i++)\n    if (byte[i] & 0x7f)\n      break;\n\n  if (byte[i] & 0x40)\n    i--;\n  byte[i] &= 0x7f;\n  for (j = 4; j >= i; j--)\n    bit_write_RC (dat, byte[j]);\n}",
        "output": "1",
        "idx": 7826
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void grubfs_free (GrubFS *gf) {\n\tif (gf) {\n\t\tif (gf->file && gf->file->device)\n\t\t\tfree (gf->file->device->disk);\n\t\tfree (gf->file);\n\t\tfree (gf);\n\t}\n}",
        "output": "1",
        "idx": 6170
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "memcmp_constant_time (const void *a, const void *b, size_t size) {\n  const uint8_t * a1 = a;\n  const uint8_t * b1 = b;\n  int ret = 0;\n  size_t i;\n\n  for (i = 0; i < size; i++) {\n      ret |= *a1++ ^ *b1++;\n  }\n\n  return ret;\n}",
        "output": "0",
        "idx": 5343
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct nfs4_opendata *nfs4_open_recoverdata_alloc(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs4_opendata *opendata;\n\n\topendata = nfs4_opendata_alloc(&ctx->path, state->owner, 0, NULL);\n\tif (opendata == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\topendata->state = state;\n\tatomic_inc(&state->count);\n\treturn opendata;\n}",
        "output": "1",
        "idx": 2122
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int Jsi_ObjArraySizer(Jsi_Interp *interp, Jsi_Obj *obj, uint len)\n{\n    int nsiz = len + 1, mod = ALLOC_MOD_SIZE;\n    assert(obj->isarrlist);\n    if (mod>1)\n        nsiz = nsiz + ((mod-1) - (nsiz + mod - 1)%mod);\n    if (nsiz > MAX_ARRAY_LIST) {\n        Jsi_LogError(\"array size too large\");\n        return 0;\n    }\n    if (len >= obj->arrMaxSize) {\n        int oldsz = (nsiz-obj->arrMaxSize);\n        obj->arr = (Jsi_Value**)Jsi_Realloc(obj->arr, nsiz*sizeof(Jsi_Value*));\n        memset(obj->arr+obj->arrMaxSize, 0, oldsz*sizeof(Jsi_Value*));\n        obj->arrMaxSize = nsiz;\n    }\n    if (len>obj->arrCnt)\n        obj->arrCnt = len;\n    return nsiz;\n}",
        "output": "1",
        "idx": 8230
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dotraplinkage void do_stack_segment(struct pt_regs *regs, long error_code)\n{\n\tenum ctx_state prev_state;\n\n\tprev_state = exception_enter();\n\tif (notify_die(DIE_TRAP, \"stack segment\", regs, error_code,\n\t\t       X86_TRAP_SS, SIGBUS) != NOTIFY_STOP) {\n\t\tpreempt_conditional_sti(regs);\n\t\tdo_trap(X86_TRAP_SS, SIGBUS, \"stack segment\", regs, error_code, NULL);\n\t\tpreempt_conditional_cli(regs);\n\t}\n\texception_exit(prev_state);\n}",
        "output": "1",
        "idx": 2724
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)\n{\n  mrb_value blk;\n  mrb_value proc;\n  struct RProc *p;\n\n  mrb_get_args(mrb, \"&!\", &blk);\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));\n  mrb_proc_copy(p, mrb_proc_ptr(blk));\n  proc = mrb_obj_value(p);\n  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);\n  if (!MRB_PROC_STRICT_P(p) &&\n      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {\n    p->flags |= MRB_PROC_ORPHAN;\n  }\n  return proc;\n}",
        "output": "1",
        "idx": 6690
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mount_proc_if_needed(const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tchar link[20];\n\tint linklen, ret;\n\tint mypid;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc/self\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tmemset(link, 0, 20);\n\tlinklen = readlink(path, link, 20);\n\tmypid = (int)getpid();\n\tINFO(\"I am %d, /proc/self points to '%s'\", mypid, link);\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tif (linklen < 0) \n\t\tgoto domount;\n\tif (atoi(link) != mypid) {\n\t\tumount2(path, MNT_DETACH); \n\t\tgoto domount;\n\t}\n\treturn 0;\n\ndomount:\n\tif (safe_mount(\"proc\", path, \"proc\", 0, NULL, rootfs) < 0)\n\t\treturn -1;\n\tINFO(\"Mounted /proc in container for security transition\");\n\treturn 1;\n}",
        "output": "0",
        "idx": 6061
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xfrm6_tunnel_rcv(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\t__be32 spi;\n\n\tspi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);\n\treturn xfrm6_rcv_spi(skb, spi);\n}",
        "output": "1",
        "idx": 2074
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void * gdImageGifPtr (gdImagePtr im, int *size)\n{\n  void *rv;\n  gdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n  gdImageGifCtx (im, out);\n  rv = gdDPExtractData (out, size);\n  out->gd_free (out);\n  return rv;\n}",
        "output": "1",
        "idx": 4116
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct key *find_keyring_by_name(const char *name, bool skip_perm_check)\n{\n\tstruct key *keyring;\n\tint bucket;\n\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbucket = keyring_hash(name);\n\n\tread_lock(&keyring_name_lock);\n\n\tif (keyring_name_hash[bucket].next) {\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    name_link\n\t\t\t\t    ) {\n\t\t\tif (!kuid_has_mapping(current_user_ns(), keyring->user->uid))\n\t\t\t\tcontinue;\n\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (!skip_perm_check &&\n\t\t\t    key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t   KEY_NEED_SEARCH) < 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (!refcount_inc_not_zero(&keyring->usage))\n\t\t\t\tcontinue;\n\t\t\tkeyring->last_used_at = current_kernel_time().tv_sec;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tkeyring = ERR_PTR(-ENOKEY);\nout:\n\tread_unlock(&keyring_name_lock);\n\treturn keyring;\n}",
        "output": "1",
        "idx": 1676
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jas_iccgetuint16(jas_stream_t *in, jas_iccuint16_t *val)\n{\n\tjas_ulonglong tmp;\n\tif (jas_iccgetuint(in, 2, &tmp))\n\t\treturn -1;\n\t*val = tmp;\n\treturn 0;\n}",
        "output": "0",
        "idx": 7559
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int khugepaged_enter_vma_merge(struct vm_area_struct *vma)\n{\n\tunsigned long hstart, hend;\n\tif (!vma->anon_vma)\n\t\treturn 0;\n\tif (vma->vm_file || vma->vm_ops)\n\t\treturn 0;\n\tVM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (hstart < hend)\n\t\treturn khugepaged_enter(vma);\n\treturn 0;\n}",
        "output": "1",
        "idx": 306
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tif (_gdImageWebpCtx(im, out, -1)) {\n\t\trv = NULL;\n\t} else {\n\t\trv = gdDPExtractData(out, size);\n\t}\n\tout->gd_free(out);\n\n\treturn rv;\n}",
        "output": "0",
        "idx": 6191
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int atusb_get_and_show_build(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tchar build[ATUSB_BUILD_SIZE + 1];\n\tint ret;\n\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_BUILD, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuild, ATUSB_BUILD_SIZE, 1000);\n\tif (ret >= 0) {\n\t\tbuild[ret] = 0;\n\t\tdev_info(&usb_dev->dev, \"Firmware: build %s\\n\", build);\n\t}\n\n\treturn ret;\n}",
        "output": "1",
        "idx": 1418
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cJSON_AddItemToArray( cJSON *array, cJSON *item )\n{\n\tcJSON *c = array->child;\n\tif ( ! item )\n\t\treturn;\n\tif ( ! c ) {\n\t\tarray->child = item;\n\t} else {\n\t\twhile ( c && c->next )\n\t\t\tc = c->next;\n\t\tsuffix_object( c, item );\n\t}\n}",
        "output": "1",
        "idx": 5916
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ntlm_free_message_fields_buffer(NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields)\n\t{\n\t\tif (fields->Buffer)\n\t\t{\n\t\t\tfree(fields->Buffer);\n\t\t\tfields->Len = 0;\n\t\t\tfields->MaxLen = 0;\n\t\t\tfields->Buffer = NULL;\n\t\t\tfields->BufferOffset = 0;\n\t\t}\n\t}\n}",
        "output": "0",
        "idx": 5797
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "chdlc_if_print(netdissect_options *ndo, const struct pcap_pkthdr *h, register const u_char *p)\n{\n\tregister u_int length = h->len;\n\tregister u_int caplen = h->caplen;\n\n\tif (caplen < CHDLC_HDRLEN) {\n\t\tND_PRINT((ndo, \"[|chdlc]\"));\n\t\treturn (caplen);\n\t}\n        return (chdlc_print(ndo, p,length));\n}",
        "output": "1",
        "idx": 4666
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void show_object(struct object *obj, const char *name, void *data)\n{\n\tadd_preferred_base_object(name);\n\tadd_object_entry(obj->oid.hash, obj->type, name, 0);\n\tobj->flags |= OBJECT_ADDED;\n}",
        "output": "0",
        "idx": 7221
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xen_netbk_get_extras(struct xenvif *vif,\n\t\t\t\tstruct xen_netif_extra_info *extras,\n\t\t\t\tint work_to_do)\n{\n\tstruct xen_netif_extra_info extra;\n\tRING_IDX cons = vif->tx.req_cons;\n\n\tdo {\n\t\tif (unlikely(work_to_do-- <= 0)) {\n\t\t\tnetdev_dbg(vif->dev, \"Missing extra info\\n\");\n\t\t\treturn -EBADR;\n\t\t}\n\n\t\tmemcpy(&extra, RING_GET_REQUEST(&vif->tx, cons),\n\t\t       sizeof(extra));\n\t\tif (unlikely(!extra.type ||\n\t\t\t     extra.type >= XEN_NETIF_EXTRA_TYPE_MAX)) {\n\t\t\tvif->tx.req_cons = ++cons;\n\t\t\tnetdev_dbg(vif->dev,\n\t\t\t\t   \"Invalid extra type: %d\\n\", extra.type);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy(&extras[extra.type - 1], &extra, sizeof(extra));\n\t\tvif->tx.req_cons = ++cons;\n\t} while (extra.flags & XEN_NETIF_EXTRA_FLAG_MORE);\n\n\treturn work_to_do;\n}",
        "output": "1",
        "idx": 826
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_wrap_size_limit(\n\tOM_uint32\t*minor_status,\n\tconst gss_ctx_id_t context_handle,\n\tint\t\tconf_req_flag,\n\tgss_qop_t\tqop_req,\n\tOM_uint32\treq_output_size,\n\tOM_uint32\t*max_input_size)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_size_limit(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tconf_req_flag,\n\t\t\t\tqop_req,\n\t\t\t\treq_output_size,\n\t\t\t\tmax_input_size);\n\treturn (ret);\n}",
        "output": "1",
        "idx": 78
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct mobj *alloc_ta_mem(size_t size)\n{\n#ifdef CFG_PAGED_USER_TA\n\treturn mobj_paged_alloc(size);\n#else\n\tstruct mobj *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr);\n\n\tif (mobj)\n\t\tmemset(mobj_get_va(mobj, 0), 0, size);\n\treturn mobj;\n#endif\n}",
        "output": "1",
        "idx": 7360
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __u8 *nci_extract_rf_params_nfcb_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcb_poll *nfcb_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcb_poll->sensb_res_len = *data++;\n\n\tpr_debug(\"sensb_res_len %d\\n\", nfcb_poll->sensb_res_len);\n\n\tmemcpy(nfcb_poll->sensb_res, data, nfcb_poll->sensb_res_len);\n\tdata += nfcb_poll->sensb_res_len;\n\n\treturn data;\n}",
        "output": "1",
        "idx": 726
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static irqreturn_t armv7pmu_handle_irq(int irq_num, void *dev)\n{\n\tunsigned long pmnc;\n\tstruct perf_sample_data data;\n\tstruct cpu_hw_events *cpuc;\n\tstruct pt_regs *regs;\n\tint idx;\n\n\tpmnc = armv7_pmnc_getreset_flags();\n\n\tif (!armv7_pmnc_has_overflowed(pmnc))\n\t\treturn IRQ_NONE;\n\n\tregs = get_irq_regs();\n\n\tperf_sample_data_init(&data, 0);\n\n\tcpuc = &__get_cpu_var(cpu_hw_events);\n\tfor (idx = 0; idx <= armpmu->num_events; ++idx) {\n\t\tstruct perf_event *event = cpuc->events[idx];\n\t\tstruct hw_perf_event *hwc;\n\n\t\tif (!test_bit(idx, cpuc->active_mask))\n\t\t\tcontinue;\n\n\t\tif (!armv7_pmnc_counter_has_overflowed(pmnc, idx))\n\t\t\tcontinue;\n\n\t\thwc = &event->hw;\n\t\tarmpmu_event_update(event, hwc, idx, 1);\n\t\tdata.period = event->hw.last_period;\n\t\tif (!armpmu_event_set_period(event, hwc, idx))\n\t\t\tcontinue;\n\n\t\tif (perf_event_overflow(event, 0, &data, regs))\n\t\t\tarmpmu->disable(hwc, idx);\n\t}\n\n\tirq_work_run();\n\n\treturn IRQ_HANDLED;\n}",
        "output": "1",
        "idx": 418
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "didset_options2(void)\n{\n    (void)highlight_changed();\n\n    check_opt_wim();\n\n    (void)set_chars_option(curwin, &curwin->w_p_lcs);\n\n    (void)set_chars_option(curwin, &p_fcs);\n\n#ifdef FEAT_CLIPBOARD\n    (void)check_clipboard_option();\n#endif\n#ifdef FEAT_VARTABS\n    vim_free(curbuf->b_p_vsts_array);\n    tabstop_set(curbuf->b_p_vsts, &curbuf->b_p_vsts_array);\n    vim_free(curbuf->b_p_vts_array);\n    tabstop_set(curbuf->b_p_vts,  &curbuf->b_p_vts_array);\n#endif\n}",
        "output": "1",
        "idx": 5680
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean match_hostname(const char *cert_hostname, const char *hostname)\n{\n\tconst char *hostname_left;\n\n\tif (!strcasecmp(cert_hostname, hostname)) { \n\t\treturn TRUE;\n\t} else if (cert_hostname[0] == '*' && cert_hostname[1] == '.' && cert_hostname[2] != 0) { \n\t\thostname_left = strchr(hostname, '.');\n\t\tif (hostname_left != NULL && ! strcasecmp(hostname_left + 1, cert_hostname + 2)) {\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}",
        "output": "0",
        "idx": 4669
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)\n{\tva_list\targptr ;\n\tint\t\tmaxlen ;\n\tchar\t*start ;\n\n\tmaxlen = strlen ((char*) psf->header) ;\n\tstart\t= ((char*) psf->header) + maxlen ;\n\tmaxlen\t= sizeof (psf->header) - maxlen ;\n\n\tva_start (argptr, format) ;\n\tvsnprintf (start, maxlen, format, argptr) ;\n\tva_end (argptr) ;\n\n\tstart [maxlen - 1] = 0 ;\n\n\tpsf->headindex = strlen ((char*) psf->header) ;\n\n\treturn ;\n} ",
        "output": "1",
        "idx": 4936
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void imap_quote_string(char *dest, size_t dlen, const char *src)\n{\n  static const char quote[] = \"\\\"\\\\\";\n  char *pt = dest;\n  const char *s = src;\n\n  *pt++ = '\"';\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}",
        "output": "1",
        "idx": 6980
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "display_dollar(colnr_T col)\n{\n    colnr_T save_col;\n\n    if (!redrawing())\n\treturn;\n\n    cursor_off();\n    save_col = curwin->w_cursor.col;\n    curwin->w_cursor.col = col;\n    if (has_mbyte)\n    {\n\tchar_u *p;\n\n\tp = ml_get_curline();\n\tcurwin->w_cursor.col -= (*mb_head_off)(p, p + col);\n    }\n    curs_columns(FALSE);\t    \n    if (curwin->w_wcol < curwin->w_width)\n    {\n\tedit_putchar('$', FALSE);\n\tdollar_vcol = curwin->w_virtcol;\n    }\n    curwin->w_cursor.col = save_col;\n}",
        "output": "1",
        "idx": 5810
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void postParse(HttpRoute *route)\n{\n    Http        *http;\n    HttpHost    *host;\n    HttpRoute   *rp;\n    MprJson     *mappings, *client;\n    int         nextHost, nextRoute;\n\n    if (route->error) {\n        return;\n    }\n    http = route->http;\n    route->mode = mprReadJson(route->config, \"app.mode\");\n\n    if ((mappings = mprReadJsonObj(route->config, \"app.client.mappings\")) != 0) {\n        client = mprCreateJson(MPR_JSON_OBJ);\n        clientCopy(route, client, mappings);\n        mprWriteJson(client, \"prefix\", route->prefix);\n        route->client = mprJsonToString(client, MPR_JSON_QUOTES);\n    }\n    httpAddHostToEndpoints(route->host);\n\n    for (nextHost = 0; (host = mprGetNextItem(http->hosts, &nextHost)) != 0; ) {\n        for (nextRoute = 0; (rp = mprGetNextItem(host->routes, &nextRoute)) != 0; ) {\n            if (!mprLookupKey(rp->extensions, \"\")) {\n                if (!rp->handler) {\n                    httpAddRouteHandler(rp, \"fileHandler\", \"\");\n                    httpAddRouteIndex(rp, \"index.html\");\n                }\n            }\n            if (rp->parent == route) {\n                rp->client = route->client;\n            }\n        }\n    }\n}",
        "output": "0",
        "idx": 7021
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int count_mounts(struct mnt_namespace *ns, struct mount *mnt)\n{\n\tunsigned int max = READ_ONCE(sysctl_mount_max);\n\tunsigned int mounts = 0, old, pending, sum;\n\tstruct mount *p;\n\n\tfor (p = mnt; p; p = next_mnt(p, mnt))\n\t\tmounts++;\n\n\told = ns->mounts;\n\tpending = ns->pending_mounts;\n\tsum = old + pending;\n\tif ((old > sum) ||\n\t    (pending > sum) ||\n\t    (max < sum) ||\n\t    (mounts > (max - sum)))\n\t\treturn -ENOSPC;\n\n\tns->pending_mounts = pending + mounts;\n\treturn 0;\n}",
        "output": "0",
        "idx": 1963
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ptrace_setoptions(struct task_struct *child, unsigned long data)\n{\n\tunsigned flags;\n\n\tif (data & ~(unsigned long)PTRACE_O_MASK)\n\t\treturn -EINVAL;\n\n\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {\n\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||\n\t\t    !IS_ENABLED(CONFIG_SECCOMP))\n\t\t\treturn -EINVAL;\n\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||\n\t\t    current->ptrace & PT_SUSPEND_SECCOMP)\n\t\t\treturn -EPERM;\n\t}\n\n\tflags = child->ptrace;\n\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);\n\tflags |= (data << PT_OPT_FLAG_SHIFT);\n\tchild->ptrace = flags;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 2016
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static size_t optsize (lua_State *L, char opt, const char **fmt) {\n  switch (opt) {\n    case 'B': case 'b': return sizeof(char);\n    case 'H': case 'h': return sizeof(short);\n    case 'L': case 'l': return sizeof(long);\n    case 'T': return sizeof(size_t);\n    case 'f':  return sizeof(float);\n    case 'd':  return sizeof(double);\n    case 'x': return 1;\n    case 'c': return getnum(L, fmt, 1);\n    case 'i': case 'I': {\n      int sz = getnum(L, fmt, sizeof(int));\n      if (sz > MAXINTSIZE)\n        luaL_error(L, \"integral size %d is larger than limit of %d\",\n                       sz, MAXINTSIZE);\n      return sz;\n    }\n    default: return 0;  \n  }\n}",
        "output": "1",
        "idx": 3642
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "search_make_new(const struct search_state *const state, int n, const char *const base_name) {\n\tconst size_t base_len = strlen(base_name);\n\tconst char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;\n\tstruct search_domain *dom;\n\n\tfor (dom = state->head; dom; dom = dom->next) {\n\t\tif (!n--) {\n\t\t\tconst u8 *const postfix = ((u8 *) dom) + sizeof(struct search_domain);\n\t\t\tconst int postfix_len = dom->len;\n\t\t\tchar *const newname = (char *) mm_malloc(base_len + need_to_append_dot + postfix_len + 1);\n\t\t\tif (!newname) return NULL;\n\t\t\tmemcpy(newname, base_name, base_len);\n\t\t\tif (need_to_append_dot) newname[base_len] = '.';\n\t\t\tmemcpy(newname + base_len + need_to_append_dot, postfix, postfix_len);\n\t\t\tnewname[base_len + need_to_append_dot + postfix_len] = 0;\n\t\t\treturn newname;\n\t\t}\n\t}\n\n\tEVUTIL_ASSERT(0);\n\treturn NULL; \n}",
        "output": "1",
        "idx": 5654
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int hashtable_set(hashtable_t *hashtable,\n                  const char *key, size_t serial,\n                  json_t *value)\n{\n    pair_t *pair;\n    bucket_t *bucket;\n    size_t hash, index;\n\n    if(hashtable->size >= num_buckets(hashtable))\n        if(hashtable_do_rehash(hashtable))\n            return -1;\n\n    hash = hash_str(key);\n    index = hash % num_buckets(hashtable);\n    bucket = &hashtable->buckets[index];\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n\n    if(pair)\n    {\n        json_decref(pair->value);\n        pair->value = value;\n    }\n    else\n    {\n        pair = jsonp_malloc(offsetof(pair_t, key) + strlen(key) + 1);\n        if(!pair)\n            return -1;\n\n        pair->hash = hash;\n        pair->serial = serial;\n        strcpy(pair->key, key);\n        pair->value = value;\n        list_init(&pair->list);\n\n        insert_to_bucket(hashtable, bucket, &pair->list);\n\n        hashtable->size++;\n    }\n    return 0;\n}",
        "output": "1",
        "idx": 4308
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\t\n\t*data = &iterator->current;\n}",
        "output": "1",
        "idx": 4000
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int on_part_data_end(multipart_parser *parser)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    data->num_of_part++;\n\n    return 0;\n}",
        "output": "1",
        "idx": 8850
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tstruct shmem_sb_info *sbinfo = SHMEM_SB(sb);\n\tstruct shmem_sb_info config = *sbinfo;\n\tunsigned long inodes;\n\tint error = -EINVAL;\n\n\tconfig.mpol = NULL;\n\tif (shmem_parse_options(data, &config, true))\n\t\treturn error;\n\n\tspin_lock(&sbinfo->stat_lock);\n\tinodes = sbinfo->max_inodes - sbinfo->free_inodes;\n\tif (percpu_counter_compare(&sbinfo->used_blocks, config.max_blocks) > 0)\n\t\tgoto out;\n\tif (config.max_inodes < inodes)\n\t\tgoto out;\n\tif (config.max_blocks && !sbinfo->max_blocks)\n\t\tgoto out;\n\tif (config.max_inodes && !sbinfo->max_inodes)\n\t\tgoto out;\n\n\terror = 0;\n\tsbinfo->max_blocks  = config.max_blocks;\n\tsbinfo->max_inodes  = config.max_inodes;\n\tsbinfo->free_inodes = config.max_inodes - inodes;\n\n\tif (config.mpol) {\n\t\tmpol_put(sbinfo->mpol);\n\t\tsbinfo->mpol = config.mpol;\t\n\t}\nout:\n\tspin_unlock(&sbinfo->stat_lock);\n\treturn error;\n}",
        "output": "0",
        "idx": 1197
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void* leak_memalign(size_t alignment, size_t bytes)\n{\n    if (alignment <= MALLOC_ALIGNMENT)\n        return leak_malloc(bytes);\n\n    if (alignment & (alignment-1))\n        alignment = 1L << (31 - __builtin_clz(alignment));\n\n    size_t size = (alignment-MALLOC_ALIGNMENT) + bytes;\n    if (size < bytes) { \n        return NULL;\n    }\n\n    void* base = leak_malloc(size);\n    if (base != NULL) {\n        intptr_t ptr = (intptr_t)base;\n        if ((ptr % alignment) == 0)\n            return base;\n\n        ptr += ((-ptr) % alignment);\n\n        ((void**)ptr)[-1] = MEMALIGN_GUARD;\n        ((void**)ptr)[-2] = base;\n\n        return (void*)ptr;\n    }\n    return base;\n}",
        "output": "0",
        "idx": 5071
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool buffer_pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n\n\tif (ref->ref > INT_MAX/2)\n\t\treturn false;\n\n\tref->ref++;\n\treturn true;\n}",
        "output": "0",
        "idx": 4365
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mono_gc_reference_queue_free (MonoReferenceQueue *queue)\n{\n\tqueue->should_be_deleted = TRUE;\n}",
        "output": "0",
        "idx": 4695
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t driver_override_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tchar *driver_override, *old, *cp;\n\n\tif (count > PATH_MAX)\n\t\treturn -EINVAL;\n\n\tdriver_override = kstrndup(buf, count, GFP_KERNEL);\n\tif (!driver_override)\n\t\treturn -ENOMEM;\n\n\tcp = strchr(driver_override, '\\n');\n\tif (cp)\n\t\t*cp = '\\0';\n\n\tdevice_lock(dev);\n\told = pdev->driver_override;\n\tif (strlen(driver_override)) {\n\t\tpdev->driver_override = driver_override;\n\t} else {\n\t\tkfree(driver_override);\n\t\tpdev->driver_override = NULL;\n\t}\n\tdevice_unlock(dev);\n\n\tkfree(old);\n\n\treturn count;\n}",
        "output": "0",
        "idx": 2321
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    \"disallowed submodule name: %s\",\n\t\t\t\t    name);\n\tif (!strcmp(key, \"url\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_URL,\n\t\t\t\t    \"disallowed submodule url: %s\",\n\t\t\t\t    value);\n\tif (!strcmp(key, \"path\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_PATH,\n\t\t\t\t    \"disallowed submodule path: %s\",\n\t\t\t\t    value);\n\tfree(name);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 7199
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rfcomm_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t       struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;\n\tint len;\n\n\tif (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {\n\t\trfcomm_dlc_accept(d);\n\t\tmsg->msg_namelen = 0;\n\t\treturn 0;\n\t}\n\n\tlen = bt_sock_stream_recvmsg(iocb, sock, msg, size, flags);\n\n\tlock_sock(sk);\n\tif (!(flags & MSG_PEEK) && len > 0)\n\t\tatomic_sub(len, &sk->sk_rmem_alloc);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) <= (sk->sk_rcvbuf >> 2))\n\t\trfcomm_dlc_unthrottle(rfcomm_pi(sk)->dlc);\n\trelease_sock(sk);\n\n\treturn len;\n}",
        "output": "0",
        "idx": 1273
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_readlink(const char *path)\n{\n\tchar *dest = alloca(2 * strlen(path));\n\n\tif (readlink(path, dest, 2 * strlen(path)) >= 0) {\n\t\tfprintf(stderr, \"leak at readlink of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at readlink of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}",
        "output": "0",
        "idx": 7265
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int _setEdgePixel(const gdImagePtr src, unsigned int x, unsigned int y, gdFixed coverage, const int bgColor)\n{\n\tconst gdFixed f_127 = gd_itofx(127);\n\tregister int c = src->tpixels[y][x];\n\tc = c | (( (int) (gd_fxtof(gd_mulfx(coverage, f_127)) + 50.5f)) << 24);\n\treturn _color_blend(bgColor, c);\n}",
        "output": "0",
        "idx": 5451
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int jpg_validate(jas_stream_t *in)\n{\n\tjas_uchar buf[JPG_MAGICLEN];\n\tint i;\n\tint n;\n\n\tassert(JAS_STREAM_MAXPUTBACK >= JPG_MAGICLEN);\n\n\tif ((n = jas_stream_read(in, buf, JPG_MAGICLEN)) < 0) {\n\t\treturn -1;\n\t}\n\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (n < JPG_MAGICLEN) {\n\t\treturn -1;\n\t}\n\n\tif (buf[0] != (JPG_MAGIC >> 8) || buf[1] != (JPG_MAGIC & 0xff)) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 7579
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)\n{\n\tstruct channel *pch;\n\tstruct ppp_net *pn;\n\n\tpch = kzalloc(sizeof(struct channel), GFP_KERNEL);\n\tif (!pch)\n\t\treturn -ENOMEM;\n\n\tpn = ppp_pernet(net);\n\n\tpch->ppp = NULL;\n\tpch->chan = chan;\n\tpch->chan_net = get_net(net);\n\tchan->ppp = pch;\n\tinit_ppp_file(&pch->file, CHANNEL);\n\tpch->file.hdrlen = chan->hdrlen;\n#ifdef CONFIG_PPP_MULTILINK\n\tpch->lastseq = -1;\n#endif \n\tinit_rwsem(&pch->chan_sem);\n\tspin_lock_init(&pch->downl);\n\trwlock_init(&pch->upl);\n\n\tspin_lock_bh(&pn->all_channels_lock);\n\tpch->file.index = ++pn->last_channel_index;\n\tlist_add(&pch->list, &pn->new_channels);\n\tatomic_inc(&channel_count);\n\tspin_unlock_bh(&pn->all_channels_lock);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1729
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void   cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem)\t\t{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) {cJSON_AddItemToArray(array,newitem);return;}\n\tnewitem->next=c;newitem->prev=c->prev;c->prev=newitem;if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;}",
        "output": "0",
        "idx": 8335
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ext4_xattr_destroy_cache(struct mb2_cache *cache)\n{\n\tif (cache)\n\t\tmb2_cache_destroy(cache);\n}",
        "output": "0",
        "idx": 1625
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void check_file(char *basename)\n{\n    gdImagePtr im;\n    char *buffer;\n    size_t size;\n\n    size = read_test_file(&buffer, basename);\n    im = gdImageCreateFromTiffPtr(size, (void *) buffer);\n    gdTestAssert(im == NULL);\n    free(buffer);\n}",
        "output": "0",
        "idx": 6183
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\n{\n\tstruct file *shm_file;\n\n\tshm_file = shp->shm_file;\n\tshp->shm_file = NULL;\n\tns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tshm_rmid(ns, shp);\n\tshm_unlock(shp);\n\tif (!is_file_hugepages(shm_file))\n\t\tshmem_lock(shm_file, 0, shp->mlock_user);\n\telse if (shp->mlock_user)\n\t\tuser_shm_unlock(file_inode(shm_file)->i_size, shp->mlock_user);\n\tfput(shm_file);\n\tipc_rcu_putref(shp, shm_rcu_free);\n}",
        "output": "0",
        "idx": 3419
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "file_push_buffer(struct magic_set *ms)\n{\n\tfile_pushbuf_t *pb;\n\n\tif (ms->event_flags & EVENT_HAD_ERR)\n\t\treturn NULL;\n\n\tif ((pb = (CAST(file_pushbuf_t *, malloc(sizeof(*pb))))) == NULL)\n\t\treturn NULL;\n\n\tpb->buf = ms->o.buf;\n\tpb->offset = ms->offset;\n\n\tms->o.buf = NULL;\n\tms->offset = 0;\n\n\treturn pb;\n}",
        "output": "0",
        "idx": 6109
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ext4_xattr_create_cache(void)\n{\n\treturn mb2_cache_create(HASH_BUCKET_BITS);\n}",
        "output": "0",
        "idx": 1629
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ip_setup_cork(struct sock *sk, struct inet_cork *cork,\n\t\t\t struct ipcm_cookie *ipc, struct rtable **rtp)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options *opt;\n\tstruct rtable *rt;\n\n\topt = ipc->opt;\n\tif (opt) {\n\t\tif (cork->opt == NULL) {\n\t\t\tcork->opt = kmalloc(sizeof(struct ip_options) + 40,\n\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (unlikely(cork->opt == NULL))\n\t\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tmemcpy(cork->opt, opt, sizeof(struct ip_options) + opt->optlen);\n\t\tcork->flags |= IPCORK_OPT;\n\t\tcork->addr = ipc->addr;\n\t}\n\trt = *rtp;\n\tif (unlikely(!rt))\n\t\treturn -EFAULT;\n\t*rtp = NULL;\n\tcork->fragsize = inet->pmtudisc == IP_PMTUDISC_PROBE ?\n\t\t\t rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\tcork->dst = &rt->dst;\n\tcork->length = 0;\n\tcork->tx_flags = ipc->tx_flags;\n\tcork->page = NULL;\n\tcork->off = 0;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 364
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page_file_mapping(page));\n}",
        "output": "0",
        "idx": 4429
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void btrfs_trans_release_chunk_metadata(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\n\tif (!trans->chunk_bytes_reserved)\n\t\treturn;\n\n\tWARN_ON_ONCE(!list_empty(&trans->new_bgs));\n\n\tbtrfs_block_rsv_release(fs_info, &fs_info->chunk_block_rsv,\n\t\t\t\ttrans->chunk_bytes_reserved, NULL);\n\tatomic64_sub(trans->chunk_bytes_reserved, &cur_trans->chunk_bytes_reserved);\n\tcond_wake_up(&cur_trans->chunk_reserve_wait);\n\ttrans->chunk_bytes_reserved = 0;\n}",
        "output": "1",
        "idx": 1964
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sf_open\t(const char *path, int mode, SF_INFO *sfinfo)\n{\tSF_PRIVATE \t*psf ;\n\n\tassert (sizeof (sf_count_t) == 8) ;\n\n\tif ((psf = psf_allocate ()) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;\n\n\tpsf_log_printf (psf, \"File : %s\\n\", path) ;\n\n\tif (copy_filename (psf, path) != 0)\n\t{\tsf_errno = psf->error ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf->file.mode = mode ;\n\tif (strcmp (path, \"-\") == 0)\n\t\tpsf->error = psf_set_stdio (psf) ;\n\telse\n\t\tpsf->error = psf_fopen (psf) ;\n\n\treturn psf_open_file (psf, sfinfo) ;\n} ",
        "output": "0",
        "idx": 6919
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "didset_options2(void)\n{\n    (void)highlight_changed();\n\n    check_opt_wim();\n\n    (void)set_chars_option(curwin, &curwin->w_p_lcs);\n\n    (void)set_chars_option(curwin, &p_fcs);\n\n#ifdef FEAT_CLIPBOARD\n    (void)check_clipboard_option();\n#endif\n#ifdef FEAT_VARTABS\n    vim_free(curbuf->b_p_vsts_array);\n    (void)tabstop_set(curbuf->b_p_vsts, &curbuf->b_p_vsts_array);\n    vim_free(curbuf->b_p_vts_array);\n    (void)tabstop_set(curbuf->b_p_vts,  &curbuf->b_p_vts_array);\n#endif\n}",
        "output": "0",
        "idx": 7913
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void scsi_dma_restart_bh(void *opaque)\n{\n    SCSIDiskState *s = opaque;\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n\n    qemu_bh_delete(s->bh);\n    s->bh = NULL;\n\n    QTAILQ_FOREACH(req, &s->qdev.requests, next) {\n        r = DO_UPCAST(SCSIDiskReq, req, req);\n        if (r->status & SCSI_REQ_STATUS_RETRY) {\n            int status = r->status;\n            int ret;\n\n            r->status &=\n                ~(SCSI_REQ_STATUS_RETRY | SCSI_REQ_STATUS_RETRY_TYPE_MASK);\n\n            switch (status & SCSI_REQ_STATUS_RETRY_TYPE_MASK) {\n            case SCSI_REQ_STATUS_RETRY_READ:\n                scsi_read_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_WRITE:\n                scsi_write_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_FLUSH:\n                ret = scsi_disk_emulate_command(r, r->iov.iov_base);\n                if (ret == 0) {\n                    scsi_req_complete(&r->req, GOOD);\n                }\n            }\n        }\n    }\n}",
        "output": "1",
        "idx": 3576
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->MaxLen < 1)\n\t\tfields->MaxLen = fields->Len;\n\n\tStream_Write_UINT16(s, fields->Len); \n\tStream_Write_UINT16(s, fields->MaxLen); \n\tStream_Write_UINT32(s, fields->BufferOffset); \n}",
        "output": "0",
        "idx": 5791
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int string_rfind(const char *input, int len, const char *s, int s_len,\n                 int pos, bool case_sensitive) {\n  assertx(input);\n  assertx(s);\n  if (!s_len || pos < -len || pos > len) {\n    return -1;\n  }\n  void *ptr;\n  if (case_sensitive) {\n    if (pos >= 0) {\n      ptr = bstrrstr(input + pos, len - pos, s, s_len);\n    } else {\n      ptr = bstrrstr(input, len + std::min(pos + s_len, 0), s, s_len);\n    }\n  } else {\n    if (pos >= 0) {\n      ptr = bstrrcasestr(input + pos, len - pos, s, s_len);\n    } else {\n      ptr = bstrrcasestr(input, len + std::min(pos + s_len, 0), s, s_len);\n    }\n  }\n  if (ptr != nullptr) {\n    return (int)((const char *)ptr - input);\n  }\n  return -1;\n}",
        "output": "0",
        "idx": 6325
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct inode *isofs_iget_reloc(struct super_block *sb,\n\t\t\t\t\t     unsigned long block,\n\t\t\t\t\t     unsigned long offset)\n{\n\treturn __isofs_iget(sb, block, offset, 1);\n}",
        "output": "0",
        "idx": 3635
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sched_read_attr(struct sched_attr __user *uattr,\n\t\t\t   struct sched_attr *attr,\n\t\t\t   unsigned int usize)\n{\n\tint ret;\n\n\tif (!access_ok(VERIFY_WRITE, uattr, usize))\n\t\treturn -EFAULT;\n\n\tif (usize < sizeof(*attr)) {\n\t\tunsigned char *addr;\n\t\tunsigned char *end;\n\n\t\taddr = (void *)attr + usize;\n\t\tend  = (void *)attr + sizeof(*attr);\n\n\t\tfor (; addr < end; addr++) {\n\t\t\tif (*addr)\n\t\t\t\tgoto err_size;\n\t\t}\n\n\t\tattr->size = usize;\n\t}\n\n\tret = copy_to_user(uattr, attr, usize);\n\tif (ret)\n\t\treturn -EFAULT;\n\nout:\n\treturn ret;\n\nerr_size:\n\tret = -E2BIG;\n\tgoto out;\n}",
        "output": "1",
        "idx": 2524
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "validate_group(struct perf_event *event)\n{\n\tstruct perf_event *sibling, *leader = event->group_leader;\n\tstruct pmu_hw_events fake_pmu;\n\tDECLARE_BITMAP(fake_used_mask, ARMPMU_MAX_HWEVENTS);\n\n\tmemset(fake_used_mask, 0, sizeof(fake_used_mask));\n\tfake_pmu.used_mask = fake_used_mask;\n\n\tif (!validate_event(&fake_pmu, leader))\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(sibling, &leader->sibling_list, group_entry) {\n\t\tif (!validate_event(&fake_pmu, sibling))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!validate_event(&fake_pmu, event))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 2808
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DefragVlanTest(void)\n{\n    Packet *p1 = NULL, *p2 = NULL, *r = NULL;\n    int ret = 0;\n\n    DefragInit();\n\n    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n    if (p1 == NULL)\n        goto end;\n    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n    if (p2 == NULL)\n        goto end;\n\n    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)\n        goto end;\n    if ((r = Defrag(NULL, NULL, p2, NULL)) == NULL)\n        goto end;\n    SCFree(r);\n\n    p1->vlan_id[0] = 1;\n    p2->vlan_id[0] = 2;\n    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)\n        goto end;\n    if ((r = Defrag(NULL, NULL, p2, NULL)) != NULL)\n        goto end;\n\n    ret = 1;\n\nend:\n    if (p1 != NULL)\n        SCFree(p1);\n    if (p2 != NULL)\n        SCFree(p2);\n    DefragDestroy();\n\n    return ret;\n}",
        "output": "1",
        "idx": 6592
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC void mprDefaultLogHandler(cchar *tags, int level, cchar *msg)\n{\n    MprFile     *file;\n    char        tbuf[128];\n    static int  check = 0;\n\n    if ((file = MPR->logFile) == 0) {\n        return;\n    }\n    if (MPR->logBackup && MPR->logSize && (check++ % 1000) == 0) {\n        backupLog();\n    }\n    if (tags && *tags) {\n        if (MPR->flags & MPR_LOG_DETAILED) {\n            fmt(tbuf, sizeof(tbuf), \"%s %d %s, \", mprGetDate(MPR_LOG_DATE), level, tags);\n            mprWriteFileString(file, tbuf);\n        } else if (MPR->flags & MPR_LOG_TAGGED) {\n            if (schr(tags, ' ')) {\n                tags = stok(sclone(tags), \" \", NULL);\n            }\n            if (!isupper((uchar) *tags)) {\n                tags = stitle(tags);\n            }\n            mprWriteFileFmt(file, \"%12s \", sfmt(\"[%s]\", tags));\n        }\n    }\n    mprWriteFileString(file, msg);\n    mprWriteFileString(file, \"\\n\");\n#if ME_MPR_OSLOG\n    if (level == 0) {\n        mprWriteToOsLog(sfmt(\"%s: %d %s: %s\", MPR->name, level, tags, msg), level);\n    }\n#endif\n}",
        "output": "1",
        "idx": 5100
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC void espAddPak(HttpRoute *route, cchar *name, cchar *version)\n{\n    if (!version || !*version || smatch(version, \"0.0.0\")) {\n        version = \"*\";\n    }\n    mprSetJson(route->config, sfmt(\"dependencies.%s\", name), version);\n}",
        "output": "1",
        "idx": 5008
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static FILE * pw_tmpfile(int lockfd)\n{\n\tFILE *fd;\n\tchar *tmpname = NULL;\n\n\tif ((fd = xfmkstemp(&tmpname, \"/etc\", \".vipw\")) == NULL) {\n\t\tulckpwdf();\n\t\terr(EXIT_FAILURE, _(\"can't open temporary file\"));\n\t}\n\n\tcopyfile(lockfd, fileno(fd));\n\ttmp_file = tmpname;\n\treturn fd;\n}",
        "output": "0",
        "idx": 6515
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void get_nb10(ut8* dbg_data, SCV_NB10_HEADER* res) {\n\tconst int nb10sz = 16;\n}",
        "output": "0",
        "idx": 8703
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct tcp_sock_t *tcp_open(uint16_t port)\n{\n\tstruct tcp_sock_t *this = calloc(1, sizeof *this);\n\tif (this == NULL) {\n\t\tERR(\"IPv4: callocing this failed\");\n\t\tgoto error;\n\t}\n\n\tthis->sd = -1;\n\tthis->sd = socket(AF_INET, SOCK_STREAM, 0);\n\tif (this->sd < 0) {\n\t\tERR(\"IPv4 socket open failed\");\n\t\tgoto error;\n\t}\n\n\tstruct sockaddr_in addr;\n\tmemset(&addr, 0, sizeof addr);\n\taddr.sin_family = AF_INET;\n\taddr.sin_port = htons(port);\n\taddr.sin_addr.s_addr = htonl(0x7F000001);\n\n\tif (bind(this->sd,\n\t        (struct sockaddr *)&addr,\n\t        sizeof addr) < 0) {\n\t\tif (g_options.only_desired_port == 1)\n\t\t\tERR(\"IPv4 bind on port failed. \"\n\t\t\t    \"Requested port may be taken or require root permissions.\");\n\t\tgoto error;\n\t}\n\n\tif (listen(this->sd, HTTP_MAX_PENDING_CONNS) < 0) {\n\t\tERR(\"IPv4 listen failed on socket\");\n\t\tgoto error;\n\t}\n\n\treturn this;\n\nerror:\n\tif (this != NULL) {\n\t\tif (this->sd != -1) {\n\t\t\tclose(this->sd);\n\t\t}\n\t\tfree(this);\n\t}\n\treturn NULL;\n}",
        "output": "0",
        "idx": 7647
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n    const void *p, size_t tail, int line)\n{\n\tconst char *b = (const char *)sst->sst_tab;\n\tconst char *e = ((const char *)p) + tail;\n\t(void)&line;\n\tif (e >= b && (size_t)(e - b) <= CDF_SEC_SIZE(h) * sst->sst_len)\n\t\treturn 0;\n\tDPRINTF((\"%d: offset begin %p < end %p || %\" SIZE_T_FORMAT \"u\"\n\t    \" > %\" SIZE_T_FORMAT \"u [%\" SIZE_T_FORMAT \"u %\"\n\t    SIZE_T_FORMAT \"u]\\n\", line, b, e, (size_t)(e - b),\n\t    CDF_SEC_SIZE(h) * sst->sst_len, CDF_SEC_SIZE(h), sst->sst_len));\n\terrno = EFTYPE;\n\treturn -1;\n}",
        "output": "1",
        "idx": 4410
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void native_tss_invalidate_io_bitmap(void)\n{\n\tthis_cpu_write(cpu_tss_rw.x86_tss.io_bitmap_base,\n\t\t       IO_BITMAP_OFFSET_INVALID);\n}",
        "output": "0",
        "idx": 2691
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void o2nm_lock_subsystem(void)\n{\n\tmutex_lock(&o2nm_cluster_group.cs_subsys.su_mutex);\n}",
        "output": "0",
        "idx": 2553
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unlinked)\n{\n\tif (sk->sk_send_head == skb_unlinked)\n\t\tsk->sk_send_head = NULL;\n\tif (tcp_sk(sk)->highest_sack == skb_unlinked)\n\t\ttcp_sk(sk)->highest_sack = NULL;\n}",
        "output": "0",
        "idx": 1921
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pagemap_open(struct inode *inode, struct file *file)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tpr_warn_once(\"Bits 55-60 of /proc/PID/pagemap entries are about \"\n\t\t\t\"to stop being page-shift some time soon. See the \"\n\t\t\t\"linux/Documentation/vm/pagemap.txt for details.\\n\");\n\treturn 0;\n}",
        "output": "0",
        "idx": 3887
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void unix_notinflight(struct user_struct *user, struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tspin_lock(&unix_gc_lock);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tBUG_ON(list_empty(&u->link));\n\n\t\tif (atomic_long_dec_and_test(&u->inflight))\n\t\t\tlist_del_init(&u->link);\n\t\tunix_tot_inflight--;\n\t}\n\tuser->unix_inflight--;\n\tspin_unlock(&unix_gc_lock);\n}",
        "output": "0",
        "idx": 1591
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct tcp_conn_t *tcp_conn_accept(struct tcp_sock_t *sock)\n{\n\tstruct tcp_conn_t *conn = calloc(1, sizeof *conn);\n\tif (conn == NULL) {\n\t\tERR(\"Calloc for connection struct failed\");\n\t\tgoto error;\n\t}\n\n\tconn->sd = accept(sock->sd, NULL, NULL);\n\tif (conn->sd < 0) {\n\t\tERR(\"accept failed\");\n\t\tgoto error;\n\t}\n\n\treturn conn;\n\nerror:\n\tif (conn != NULL)\n\t\tfree(conn);\n\treturn NULL;\n}",
        "output": "1",
        "idx": 5458
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API RSocket *r_socket_accept_timeout(RSocket *s, unsigned int timeout) {\n\tfd_set read_fds;\n\tfd_set except_fds;\n\n\tFD_ZERO (&read_fds);\n\tFD_SET (s->fd, &read_fds);\n\n\tFD_ZERO (&except_fds);\n\tFD_SET (s->fd, &except_fds);\n\n\tstruct timeval t;\n\tt.tv_sec = timeout;\n\tt.tv_usec = 0;\n\n\tint r = select (s->fd + 1, &read_fds, NULL, &except_fds, &t);\n\tif(r < 0) {\n\t\tperror (\"select\");\n\t} else if (r > 0 && FD_ISSET (s->fd, &read_fds)) {\n\t\treturn r_socket_accept (s);\n\t}\n\n\treturn NULL;\n}",
        "output": "1",
        "idx": 6414
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ossl_cipher_initialize(VALUE self, VALUE str)\n{\n    EVP_CIPHER_CTX *ctx;\n    const EVP_CIPHER *cipher;\n    char *name;\n    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };\n\n    name = StringValueCStr(str);\n    GetCipherInit(self, ctx);\n    if (ctx) {\n\tossl_raise(rb_eRuntimeError, \"Cipher already inititalized!\");\n    }\n    AllocCipher(self, ctx);\n    if (!(cipher = EVP_get_cipherbyname(name))) {\n\tossl_raise(rb_eRuntimeError, \"unsupported cipher algorithm (%\"PRIsVALUE\")\", str);\n    }\n    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n\n    return self;\n}",
        "output": "1",
        "idx": 6052
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long long *alloc_index_table(int indexes)\n{\n\tstatic long long *alloc_table = NULL;\n\tstatic int alloc_size = 0;\n\tint length = indexes * sizeof(long long);\n\n\tif(alloc_size < length) {\n\t\tlong long *table = realloc(alloc_table, length);\n\n\t\tif(table == NULL)\n\t\t\tEXIT_UNSQUASH(\"alloc_index_table: failed to allocate \"\n\t\t\t\t\"index table\\n\");\n\n\t\talloc_table = table;\n\t\talloc_size = length;\n\t}\n\n\treturn alloc_table;\n}",
        "output": "0",
        "idx": 7453
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)\n{\n\tstruct keydata *keyptr = get_keyptr();\n\tu32 hash[4];\n\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = (__force u32)dport ^ keyptr->secret[10];\n\thash[3] = keyptr->secret[11];\n\n\treturn half_md4_transform(hash, keyptr->secret);\n}",
        "output": "1",
        "idx": 596
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned int seedsize(struct crypto_alg *alg)\n{\n\tstruct rng_alg *ralg = container_of(alg, struct rng_alg, base);\n\n\treturn ralg->seedsize;\n}",
        "output": "0",
        "idx": 3933
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct net *get_net_ns_by_id(struct net *net, int id)\n{\n\tstruct net *peer;\n\n\tif (id < 0)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tspin_lock_bh(&net->nsid_lock);\n\tpeer = idr_find(&net->netns_ids, id);\n\tif (peer)\n\t\tget_net(peer);\n\tspin_unlock_bh(&net->nsid_lock);\n\trcu_read_unlock();\n\n\treturn peer;\n}",
        "output": "1",
        "idx": 1800
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hb_set_union (hb_set_t       *set,\n\t      const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n\n  set->union_ (*other);\n}",
        "output": "1",
        "idx": 5550
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int install_process_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->process_keyring)\n\t\treturn -EEXIST;\n\n\tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->process_keyring = keyring;\n\treturn 0;\n}",
        "output": "1",
        "idx": 1562
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static grub_err_t read_foo (struct grub_disk *disk, grub_disk_addr_t sector, grub_size_t size, char *buf) {\n\tif (disk != NULL) {\n\t\tconst int blocksize = 512; \n\t\tint ret;\n\t\tRIOBind *iob = disk->data;\n\t\tif (bio) iob = bio;\n\t\tret = iob->read_at (iob->io, delta+(blocksize*sector),\n\t\t\t(ut8*)buf, size*blocksize);\n\t\tif (ret == -1)\n\t\t\treturn 1;\n\t} else eprintf (\"oops. no disk\\n\");\n\treturn 0; \n}",
        "output": "1",
        "idx": 6168
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "psf_allocate (void)\n{\tSF_PRIVATE * psf ;\n\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t\treturn\tNULL ;\n\n\tif ((psf->header.ptr = calloc (1, INITAL_HEADER_SIZE)) == NULL)\n\t{\tfree (psf) ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tpsf->header.len = INITAL_HEADER_SIZE ;\n\n\treturn psf ;\n} ",
        "output": "0",
        "idx": 6885
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int ccid_hc_tx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid->ccid_ops->ccid_hc_tx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_tx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}",
        "output": "1",
        "idx": 746
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int fastrpc_dma_buf_attach(struct dma_buf *dmabuf,\n\t\t\t\t  struct dma_buf_attachment *attachment)\n{\n\tstruct fastrpc_dma_buf_attachment *a;\n\tstruct fastrpc_buf *buffer = dmabuf->priv;\n\tint ret;\n\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn -ENOMEM;\n\n\tret = dma_get_sgtable(buffer->dev, &a->sgt, buffer->virt,\n\t\t\t      FASTRPC_PHYS(buffer->phys), buffer->size);\n\tif (ret < 0) {\n\t\tdev_err(buffer->dev, \"failed to get scatterlist from DMA API\\n\");\n\t\tkfree(a);\n\t\treturn -EINVAL;\n\t}\n\n\ta->dev = attachment->dev;\n\tINIT_LIST_HEAD(&a->node);\n\tattachment->priv = a;\n\n\tmutex_lock(&buffer->lock);\n\tlist_add(&a->node, &buffer->attachments);\n\tmutex_unlock(&buffer->lock);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 4531
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "beep_print(netdissect_options *ndo, const u_char *bp, u_int length)\n{\n\n\tif (l_strnstart(\"MSG\", 4, (const char *)bp, length)) \n\t\tND_PRINT((ndo, \" BEEP MSG\"));\n\telse if (l_strnstart(\"RPY \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP RPY\"));\n\telse if (l_strnstart(\"ERR \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP ERR\"));\n\telse if (l_strnstart(\"ANS \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP ANS\"));\n\telse if (l_strnstart(\"NUL \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP NUL\"));\n\telse if (l_strnstart(\"SEQ \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP SEQ\"));\n\telse if (l_strnstart(\"END\", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP END\"));\n\telse\n\t\tND_PRINT((ndo, \" BEEP (payload or undecoded)\"));\n}",
        "output": "1",
        "idx": 4780
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_hash rhash;\n\tstruct shash_alg *salg = __crypto_shash_alg(alg);\n\n\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"shash\");\n\trhash.blocksize = alg->cra_blocksize;\n\trhash.digestsize = salg->digestsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_HASH,\n\t\t    sizeof(struct crypto_report_hash), &rhash))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "1",
        "idx": 862
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(void *) gdImageGifPtr(gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageGifCtx(im, out);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}",
        "output": "1",
        "idx": 4460
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rds6_inc_info_copy(struct rds_incoming *inc,\n\t\t\tstruct rds_info_iterator *iter,\n\t\t\tstruct in6_addr *saddr, struct in6_addr *daddr,\n\t\t\tint flip)\n{\n\tstruct rds6_info_message minfo6;\n\n\tminfo6.seq = be64_to_cpu(inc->i_hdr.h_sequence);\n\tminfo6.len = be32_to_cpu(inc->i_hdr.h_len);\n\tminfo6.tos = inc->i_conn->c_tos;\n\n\tif (flip) {\n\t\tminfo6.laddr = *daddr;\n\t\tminfo6.faddr = *saddr;\n\t\tminfo6.lport = inc->i_hdr.h_dport;\n\t\tminfo6.fport = inc->i_hdr.h_sport;\n\t} else {\n\t\tminfo6.laddr = *saddr;\n\t\tminfo6.faddr = *daddr;\n\t\tminfo6.lport = inc->i_hdr.h_sport;\n\t\tminfo6.fport = inc->i_hdr.h_dport;\n\t}\n\n\tminfo6.flags = 0;\n\n\trds_info_copy(iter, &minfo6, sizeof(minfo6));\n}",
        "output": "0",
        "idx": 4453
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "qedi_dbg_info(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      u32 level, const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & level))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_info(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_info(\"[0000:00:00.0]:[%s:%d]: %pV\", func, line, &vaf);\n\nret:\n\tva_end(va);\n}",
        "output": "0",
        "idx": 4397
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nlmclnt_unlock_callback(struct rpc_task *task, void *data)\n{\n\tstruct nlm_rqst\t*req = data;\n\tu32 status = ntohl(req->a_res.status);\n\n\tif (RPC_ASSASSINATED(task))\n\t\tgoto die;\n\n\tif (task->tk_status < 0) {\n\t\tdprintk(\"lockd: unlock failed (err = %d)\\n\", -task->tk_status);\n\t\tswitch (task->tk_status) {\n\t\tcase -EACCES:\n\t\tcase -EIO:\n\t\t\tgoto die;\n\t\tdefault:\n\t\t\tgoto retry_rebind;\n\t\t}\n\t}\n\tif (status == NLM_LCK_DENIED_GRACE_PERIOD) {\n\t\trpc_delay(task, NLMCLNT_GRACE_WAIT);\n\t\tgoto retry_unlock;\n\t}\n\tif (status != NLM_LCK_GRANTED)\n\t\tprintk(KERN_WARNING \"lockd: unexpected unlock status: %d\\n\", status);\ndie:\n\treturn;\n retry_rebind:\n\tnlm_rebind_host(req->a_host);\n retry_unlock:\n\trpc_restart_call(task);\n}",
        "output": "0",
        "idx": 553
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_complete_auth_token(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_UNAVAILABLE);\n\n\tret = gss_complete_auth_token(minor_status,\n\t\t\t\t      sc->ctx_handle,\n\t\t\t\t      input_message_buffer);\n\treturn (ret);\n}",
        "output": "0",
        "idx": 119
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
        "output": "0",
        "idx": 3557
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_task(rq->curr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (test_tsk_need_resched(rq->curr))\n\t\trq->skip_clock_update = 1;\n}",
        "output": "1",
        "idx": 244
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rekey_seq_generator(struct work_struct *work)\n{\n\tstruct keydata *keyptr = &ip_keydata[1 ^ (ip_cnt & 1)];\n\n\tget_random_bytes(keyptr->secret, sizeof(keyptr->secret));\n\tkeyptr->count = (ip_cnt & COUNT_MASK) << HASH_BITS;\n\tsmp_wmb();\n\tip_cnt++;\n\tschedule_delayed_work(&rekey_work,\n\t\t\t      round_jiffies_relative(REKEY_INTERVAL));\n}",
        "output": "1",
        "idx": 612
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int oidc_session_redirect_parent_window_to_logout(request_rec *r,\n\t\toidc_cfg *c) {\n\n\toidc_debug(r, \"enter\");\n\n\tchar *java_script = apr_psprintf(r->pool,\n\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\"      window.top.location.href = '%s?session=logout';\\n\"\n\t\t\t\"    </script>\\n\", oidc_get_redirect_uri(r, c));\n\n\treturn oidc_util_html_send(r, \"Redirecting...\", java_script, NULL, NULL,\n\t\t\tOK);\n}",
        "output": "1",
        "idx": 7356
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n\t\t\t   int fromlen, unsigned char *to)\n{\n\tstruct pathComponent *pc;\n\tint elen = 0;\n\tunsigned char *p = to;\n\n\twhile (elen < fromlen) {\n\t\tpc = (struct pathComponent *)(from + elen);\n\t\tswitch (pc->componentType) {\n\t\tcase 1:\n\t\t\tif (pc->lengthComponentIdent > 0)\n\t\t\t\tbreak;\n\t\tcase 2:\n\t\t\tp = to;\n\t\t\t*p++ = '/';\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmemcpy(p, \"../\", 3);\n\t\t\tp += 3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmemcpy(p, \"./\", 2);\n\t\t\tp += 2;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tp += udf_get_filename(sb, pc->componentIdent, p,\n\t\t\t\t\t      pc->lengthComponentIdent);\n\t\t\t*p++ = '/';\n\t\t\tbreak;\n\t\t}\n\t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n\t}\n\tif (p > to + 1)\n\t\tp[-1] = '\\0';\n\telse\n\t\tp[0] = '\\0';\n}",
        "output": "1",
        "idx": 2740
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool hostuid_to_ns(uid_t uid, pid_t pid, uid_t *answer)\n{\n\tFILE *f;\n\tchar line[400];\n\n\tsprintf(line, \"/proc/%d/uid_map\", pid);\n\tif ((f = fopen(line, \"r\")) == NULL) {\n\t\treturn false;\n\t}\n\n\t*answer = convert_id_to_ns(f, uid);\n\tfclose(f);\n\n\tif (*answer == -1)\n\t\treturn false;\n\treturn true;\n}",
        "output": "0",
        "idx": 7315
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nfs4_intent_set_file(struct nameidata *nd, struct path *path, struct nfs4_state *state)\n{\n\tstruct file *filp;\n\tint ret;\n\n\tif (nd->intent.open.flags & FMODE_EXEC) {\n\t\tret = nfs_may_open(state->inode,\n\t\t\t\tstate->owner->so_cred,\n\t\t\t\tnd->intent.open.flags);\n\t\tif (ret < 0)\n\t\t\tgoto out_close;\n\t}\n\tfilp = lookup_instantiate_filp(nd, path->dentry, NULL);\n\tif (!IS_ERR(filp)) {\n\t\tstruct nfs_open_context *ctx;\n\t\tctx = nfs_file_open_context(filp);\n\t\tctx->state = state;\n\t\treturn 0;\n\t}\n\tret = PTR_ERR(filp);\nout_close:\n\tnfs4_close_sync(path, state, nd->intent.open.flags);\n\treturn ret;\n}",
        "output": "1",
        "idx": 2152
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n{\n\treturn (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,\n\t  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),\n\t  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),\n\t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;\n}",
        "output": "1",
        "idx": 5346
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)\n{\n\tstruct pt_regs hot_regs;\n\n\tif (static_branch(&perf_swevent_enabled[event_id])) {\n\t\tif (!regs) {\n\t\t\tperf_fetch_caller_regs(&hot_regs);\n\t\t\tregs = &hot_regs;\n\t\t}\n\t\t__perf_sw_event(event_id, nr, regs, addr);\n\t}\n}",
        "output": "0",
        "idx": 673
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void gtkui_conf_read(void) {\n   FILE *fd;\n   const char *path;\n   char line[100], name[30];\n   short value;\n\n#ifdef OS_WINDOWS\n   path = ec_win_get_user_dir();\n#else\n   path = g_get_home_dir();\n#endif\n\n   filename = g_build_filename(path, \".ettercap_gtk\", NULL);\n\n   DEBUG_MSG(\"gtkui_conf_read: %s\", filename);\n\n   fd = fopen(filename, \"r\");\n   if(!fd) \n      return;\n\n   while(fgets(line, 100, fd)) {\n      sscanf(line, \"%s = %hd\", name, &value);\n\n      gtkui_conf_set(name, value);\n   }\n   fclose(fd);\n}",
        "output": "0",
        "idx": 4683
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u64 distribute_cfs_runtime(struct cfs_bandwidth *cfs_b, u64 remaining)\n{\n\tstruct cfs_rq *cfs_rq;\n\tu64 runtime;\n\tu64 starting_runtime = remaining;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(cfs_rq, &cfs_b->throttled_cfs_rq,\n\t\t\t\tthrottled_list) {\n\t\tstruct rq *rq = rq_of(cfs_rq);\n\t\tstruct rq_flags rf;\n\n\t\trq_lock_irqsave(rq, &rf);\n\t\tif (!cfs_rq_throttled(cfs_rq))\n\t\t\tgoto next;\n\n\t\truntime = -cfs_rq->runtime_remaining + 1;\n\t\tif (runtime > remaining)\n\t\t\truntime = remaining;\n\t\tremaining -= runtime;\n\n\t\tcfs_rq->runtime_remaining += runtime;\n\n\t\tif (cfs_rq->runtime_remaining > 0)\n\t\t\tunthrottle_cfs_rq(cfs_rq);\n\nnext:\n\t\trq_unlock_irqrestore(rq, &rf);\n\n\t\tif (!remaining)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn starting_runtime - remaining;\n}",
        "output": "0",
        "idx": 4447
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int tcp_filter(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcphdr *th = (struct tcphdr *)skb->data;\n\tunsigned int eaten = skb->len;\n\tint err;\n\n\terr = sk_filter_trim_cap(sk, skb, th->doff * 4);\n\tif (!err) {\n\t\teaten -= skb->len;\n\t\tTCP_SKB_CB(skb)->end_seq -= eaten;\n\t}\n\treturn err;\n}",
        "output": "0",
        "idx": 2007
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dm9000WritePhyReg(uint8_t address, uint16_t data)\n{\n   dm9000WriteReg(DM9000_REG_EPAR, 0x40 | address);\n   dm9000WriteReg(DM9000_REG_EPDRL, LSB(data));\n   dm9000WriteReg(DM9000_REG_EPDRH, MSB(data));\n\n   dm9000WriteReg(DM9000_REG_EPCR, EPCR_EPOS | EPCR_ERPRW);\n   while((dm9000ReadReg(DM9000_REG_EPCR) & EPCR_ERRE) != 0)\n   {\n   }\n\n   usleep(5);\n   dm9000WriteReg(DM9000_REG_EPCR, EPCR_EPOS);\n}",
        "output": "1",
        "idx": 8526
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int bson_string_is_db_ref( const unsigned char *string, const int length ) {\n    int result = 0;\n\n    if( length >= 4 ) {\n        if( string[1] == 'r' && string[2] == 'e' && string[3] == 'f' )\n            result = 1;\n    }\n    else if( length >= 3 ) {\n        if( string[1] == 'i' && string[2] == 'd' )\n            result = 1;\n        else if( string[1] == 'd' && string[2] == 'b' )\n            result = 1;\n    }\n\n    return result;\n}",
        "output": "1",
        "idx": 7898
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sgi_clock_set(clockid_t clockid, struct timespec *tp)\n{\n\n\tu64 nsec;\n\tu64 rem;\n\n\tnsec = rtc_time() * sgi_clock_period;\n\n\tsgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n\n\tif (rem <= tp->tv_nsec)\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec - rem;\n\telse {\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;\n\t\tsgi_clock_offset.tv_sec--;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 2088
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "t1mac_output_ascii(char *s, int len)\n{\n  if (blocktyp == POST_BINARY) {\n    output_current_post();\n    blocktyp = POST_ASCII;\n  }\n  if (len > 0 && s[len-1] == '\\n')\n    s[len-1] = '\\r';\n  t1mac_output_data((byte *)s, len);\n  if (strncmp(s, \"/FontName\", 9) == 0) {\n    for (s += 9; isspace(*s); s++) ;\n    if (*s == '/') {\n      const char *t = ++s;\n      while (*t && !isspace(*t)) t++;\n      free(font_name);\n      font_name = (char *)malloc(t - s + 1);\n      memcpy(font_name, s, t - s);\n      font_name[t - s] = 0;\n    }\n  }\n}",
        "output": "1",
        "idx": 5308
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void flush_tlb_current_task(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tpreempt_disable();\n\n\tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);\n\n\tlocal_flush_tlb();\n\n\ttrace_tlb_flush(TLB_LOCAL_SHOOTDOWN, TLB_FLUSH_ALL);\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, 0UL, TLB_FLUSH_ALL);\n\tpreempt_enable();\n}",
        "output": "0",
        "idx": 1511
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IW_IMPL(unsigned int) iw_get_ui32be(const iw_byte *b)\n{\n\treturn (b[0]<<24) | (b[1]<<16) | (b[2]<<8) | b[3];\n}",
        "output": "1",
        "idx": 6648
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gss_complete_auth_token (OM_uint32 *minor_status,\n\t                 const gss_ctx_id_t context_handle,\n\t                 gss_buffer_t input_message_buffer)\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech != NULL) {\n\tif (mech->gss_complete_auth_token != NULL) {\n\t    status = mech->gss_complete_auth_token(minor_status,\n\t\t\t\t\t\t   ctx->internal_ctx_id,\n\t\t\t\t\t\t   input_message_buffer);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_COMPLETE;\n    } else\n\tstatus = GSS_S_BAD_MECH;\n\n    return status;\n}",
        "output": "0",
        "idx": 245
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "main_get_appheader (xd3_stream *stream, main_file *ifile,\n\t\t    main_file *output, main_file *sfile)\n{\n  uint8_t *apphead;\n  usize_t appheadsz;\n  int ret;\n\n  if (! option_use_appheader) { return; }\n\n  ret = xd3_get_appheader (stream, & apphead, & appheadsz);\n\n  if (ret != 0) { return; }\n\n  if (appheadsz > 0)\n    {\n      char *start = (char*)apphead;\n      char *slash;\n      int   place = 0;\n      char *parsed[4];\n\n      memset (parsed, 0, sizeof (parsed));\n\n      while ((slash = strchr (start, '/')) != NULL)\n\t{\n\t  *slash = 0;\n\t  parsed[place++] = start;\n\t  start = slash + 1;\n\t}\n\n      parsed[place++] = start;\n\n      if (place == 2 || place == 4)\n\t{\n\t  main_get_appheader_params (output, parsed, 1, \"output\", ifile);\n\t}\n\n      if (place == 4)\n\t{\n\t  main_get_appheader_params (sfile, parsed+2, 0, \"source\", ifile);\n\t}\n    }\n\n  option_use_appheader = 0;\n  return;\n}",
        "output": "1",
        "idx": 5116
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n\t\t\t   gss_ctx_id_t context_handle,\n\t\t\t   int conf_req_flag,\n\t\t\t   gss_qop_t qop_req,\n\t\t\t   int *conf_state,\n\t\t\t   gss_iov_buffer_desc *iov,\n\t\t\t   int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov_length(minor_status,\n\t\t\t\t  context_handle,\n\t\t\t\t  conf_req_flag,\n\t\t\t\t  qop_req,\n\t\t\t\t  conf_state,\n\t\t\t\t  iov,\n\t\t\t\t  iov_count);\n\treturn (ret);\n}",
        "output": "1",
        "idx": 104
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "crm_recv_remote_raw(void *session, gboolean encrypted, size_t max_recv, size_t *recv_len, int *disconnected)\n{\n    char *reply = NULL;\n    if (recv_len) {\n        *recv_len = 0;\n    }\n\n    if (disconnected) {\n        *disconnected = 0;\n    }\n\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        reply = crm_recv_tls(session, max_recv, recv_len, disconnected);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        reply = crm_recv_plaintext(GPOINTER_TO_INT(session), max_recv, recv_len, disconnected);\n    }\n    if (reply == NULL || strlen(reply) == 0) {\n        crm_trace(\"Empty reply\");\n    }\n\n    return reply;\n}",
        "output": "0",
        "idx": 5267
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct sk_buff *xfrm_state_netlink(struct sk_buff *in_skb,\n\t\t\t\t\t  struct xfrm_state *x, u32 seq)\n{\n\tstruct xfrm_dump_info info;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = dump_one_state(x, 0, &info);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn skb;\n}",
        "output": "0",
        "idx": 1049
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_cipher rcipher;\n\n\tstrncpy(rcipher.type, \"cipher\", sizeof(rcipher.type));\n\n\trcipher.blocksize = alg->cra_blocksize;\n\trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n\trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\n\t\t    sizeof(struct crypto_report_cipher), &rcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "0",
        "idx": 1183
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char* getPreferredTag(const char* gf_tag)\n{ \n\tchar* result = NULL;\n\tint grOffset = 0;\n\n\tgrOffset = findOffset( LOC_GRANDFATHERED ,gf_tag);\n\tif(grOffset < 0) {\n\t\treturn NULL;\n\t}\n\tif( grOffset < LOC_PREFERRED_GRANDFATHERED_LEN ){\n\t\tresult = estrdup( LOC_PREFERRED_GRANDFATHERED[grOffset] );\n\t} else {\n\t\tresult = estrdup( LOC_GRANDFATHERED[grOffset] );\n\t}\n\treturn result;\n}",
        "output": "1",
        "idx": 3866
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "do_prefetch_tables (const void *gcmM, size_t gcmM_size)\n{\n  prefetch_table(gcmM, gcmM_size);\n  prefetch_table(gcmR, sizeof(gcmR));\n}",
        "output": "1",
        "idx": 7452
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void encode_openhdr(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\t__be32 *p;\n\tRESERVE_SPACE(8);\n\tWRITE32(OP_OPEN);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->fmode);\n\tRESERVE_SPACE(28);\n\tWRITE64(arg->clientid);\n\tWRITE32(16);\n\tWRITEMEM(\"open id:\", 8);\n\tWRITE64(arg->id);\n}",
        "output": "0",
        "idx": 3089
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_tp_trap(struct pt_regs *regs, unsigned int instr)\n{\n\tint reg = (instr >> 12) & 15;\n\tif (reg == 15)\n\t\treturn 1;\n\tregs->uregs[reg] = current_thread_info()->tp_value;\n\tregs->ARM_pc += 4;\n\treturn 0;\n}",
        "output": "1",
        "idx": 2302
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void sctp_generate_proto_unreach_event(unsigned long data)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) data;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\n\t\tif (!mod_timer(&transport->proto_unreach_timer,\n\t\t\t\tjiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\n\tsctp_do_sm(net, SCTP_EVENT_T_OTHER,\n\t\t   SCTP_ST_OTHER(SCTP_EVENT_ICMP_PROTO_UNREACH),\n\t\t   asoc->state, asoc->ep, asoc, transport, GFP_ATOMIC);\n\nout_unlock:\n\tbh_unlock_sock(sk);\n\tsctp_association_put(asoc);\n}",
        "output": "0",
        "idx": 4033
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileInfo, getFileInfo)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_class_entry *ce = intern->info_class;\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n\t\tspl_filesystem_object_create_type(ht, intern, SPL_FS_INFO, ce, return_value TSRMLS_CC);\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}",
        "output": "0",
        "idx": 5495
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "do_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap __attribute__((__unused__)), uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags)\n{\n\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n\t    type == NT_GNU_BUILD_ID && (descsz == 16 || descsz == 20)) {\n\t\tuint8_t desc[20];\n\t\tuint32_t i;\n\t\t*flags |= FLAGS_DID_BUILD_ID;\n\t\tif (file_printf(ms, \", BuildID[%s]=\", descsz == 16 ? \"md5/uuid\" :\n\t\t    \"sha1\") == -1)\n\t\t\treturn 1;\n\t\t(void)memcpy(desc, &nbuf[doff], descsz);\n\t\tfor (i = 0; i < descsz; i++)\n\t\t    if (file_printf(ms, \"%02x\", desc[i]) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 6137
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "buflist_match(\n    regmatch_T\t*rmp,\n    buf_T\t*buf,\n    int\t\tignore_case)  \n{\n    char_u\t*match;\n\n    match = fname_match(rmp, buf->b_sfname, ignore_case);\n    if (match == NULL && rmp->regprog != NULL)\n\tmatch = fname_match(rmp, buf->b_ffname, ignore_case);\n\n    return match;\n}",
        "output": "0",
        "idx": 8029
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void perf_event_disable(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct task_struct *task = ctx->task;\n\n\tif (!task) {\n\t\tcpu_function_call(event->cpu, __perf_event_disable, event);\n\t\treturn;\n\t}\n\nretry:\n\tif (!task_function_call(task, __perf_event_disable, event))\n\t\treturn;\n\n\traw_spin_lock_irq(&ctx->lock);\n\tif (event->state == PERF_EVENT_STATE_ACTIVE) {\n\t\traw_spin_unlock_irq(&ctx->lock);\n\t\ttask = ctx->task;\n\t\tgoto retry;\n\t}\n\n\tif (event->state == PERF_EVENT_STATE_INACTIVE) {\n\t\tupdate_group_times(event);\n\t\tevent->state = PERF_EVENT_STATE_OFF;\n\t}\n\traw_spin_unlock_irq(&ctx->lock);\n}",
        "output": "1",
        "idx": 2768
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "kg_unseal_iov(OM_uint32 *minor_status,\n              gss_ctx_id_t context_handle,\n              int *conf_state,\n              gss_qop_t *qop_state,\n              gss_iov_buffer_desc *iov,\n              int iov_count,\n              int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 code;\n\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (ctx->terminated || !ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n\n    if (kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_STREAM) != NULL) {\n        code = kg_unseal_stream_iov(minor_status, ctx, conf_state, qop_state,\n                                    iov, iov_count, toktype);\n    } else {\n        code = kg_unseal_iov_token(minor_status, ctx, conf_state, qop_state,\n                                   iov, iov_count, toktype);\n    }\n\n    return code;\n}",
        "output": "0",
        "idx": 39
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void set_module_sig_enforced(void)\n{\n\tsig_enforce = true;\n}",
        "output": "0",
        "idx": 2819
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void ext2_xattr_destroy_cache(struct mb2_cache *cache)\n{\n}",
        "output": "0",
        "idx": 1665
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int perf_event_overflow(struct perf_event *event, int nmi,\n\t\t\t  struct perf_sample_data *data,\n\t\t\t  struct pt_regs *regs)\n{\n\treturn __perf_event_overflow(event, nmi, 1, data, regs);\n}",
        "output": "1",
        "idx": 518
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sshkey_load_file(int fd, struct sshbuf *blob)\n{\n\tu_char buf[1024];\n\tsize_t len;\n\tstruct stat st;\n\tint r;\n\n\tif (fstat(fd, &st) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size > MAX_KEY_FILE_SIZE)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tfor (;;) {\n\t\tif ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tbreak;\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put(blob, buf, len)) != 0)\n\t\t\tgoto out;\n\t\tif (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size != (off_t)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_FILE_CHANGED;\n\t\tgoto out;\n\t}\n\tr = 0;\n\n out:\n\texplicit_bzero(buf, sizeof(buf));\n\tif (r != 0)\n\t\tsshbuf_reset(blob);\n\treturn r;\n}",
        "output": "1",
        "idx": 5596
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pvc_getname(struct socket *sock, struct sockaddr *sockaddr,\n\t\t       int *sockaddr_len, int peer)\n{\n\tstruct sockaddr_atmpvc *addr;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\n\tif (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))\n\t\treturn -ENOTCONN;\n\t*sockaddr_len = sizeof(struct sockaddr_atmpvc);\n\taddr = (struct sockaddr_atmpvc *)sockaddr;\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->sap_family = AF_ATMPVC;\n\taddr->sap_addr.itf = vcc->dev->number;\n\taddr->sap_addr.vpi = vcc->vpi;\n\taddr->sap_addr.vci = vcc->vci;\n\treturn 0;\n}",
        "output": "0",
        "idx": 997
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ga_add_string(garray_T *gap, char_u *p)\n{\n    char_u *cp = vim_strsave(p);\n\n    if (cp == NULL)\n\treturn FAIL;\n\n    if (ga_grow(gap, 1) == FAIL)\n    {\n\tvim_free(cp);\n\treturn FAIL;\n    }\n    ((char_u **)(gap->ga_data))[gap->ga_len++] = cp;\n    return OK;\n}",
        "output": "1",
        "idx": 5702
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "snmp_api_set_oid(snmp_varbind_t *varbind, uint32_t *oid, uint32_t *ret_oid)\n{\n\n  snmp_api_replace_oid(varbind, oid);\n  varbind->value_type = BER_DATA_TYPE_OID;\n  varbind->value.oid = ret_oid;\n}",
        "output": "1",
        "idx": 7942
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool vtable_is_value_in_text_section(RVTableContext *context, ut64 curAddress, ut64 *value) {\n\tut64 curAddressValue;\n\tif (!context->read_addr (context->anal, curAddress, &curAddressValue)) {\n\t\treturn false;\n\t}\n\tbool ret = vtable_addr_in_text_section (context, curAddressValue);\n\tif (value) {\n\t\t*value = curAddressValue;\n\t}\n\treturn ret;\n}",
        "output": "1",
        "idx": 6534
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\t} ;\n} ",
        "output": "1",
        "idx": 4918
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void show_object(struct object *object, struct strbuf *path,\n\t\t\tconst char *last, void *data)\n{\n\tstruct bitmap *base = data;\n\tint bitmap_pos;\n\n\tbitmap_pos = bitmap_position(object->oid.hash);\n\n\tif (bitmap_pos < 0) {\n\t\tchar *name = path_name(path, last);\n\t\tbitmap_pos = ext_index_add_object(object, name);\n\t\tfree(name);\n\t}\n\n\tbitmap_set(base, bitmap_pos);\n}",
        "output": "1",
        "idx": 5204
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void perf_bp_event(struct perf_event *bp, void *data)\n{\n\tstruct perf_sample_data sample;\n\tstruct pt_regs *regs = data;\n\n\tperf_sample_data_init(&sample, bp->attr.bp_addr);\n\n\tif (!bp->hw.state && !perf_exclude_event(bp, regs))\n\t\tperf_swevent_event(bp, 1, &sample, regs);\n}",
        "output": "0",
        "idx": 691
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t drop_sync(QIOChannel *ioc, size_t size)\n{\n    ssize_t ret = 0;\n    char small[1024];\n    char *buffer;\n\n    buffer = sizeof(small) >= size ? small : g_malloc(MIN(65536, size));\n    while (size > 0) {\n        ssize_t count = read_sync(ioc, buffer, MIN(65536, size));\n\n        if (count <= 0) {\n            goto cleanup;\n        }\n        assert(count <= size);\n        size -= count;\n        ret += count;\n    }\n\n cleanup:\n    if (buffer != small) {\n        g_free(buffer);\n    }\n    return ret;\n}",
        "output": "0",
        "idx": 5309
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "server_request_direct_streamlocal(void)\n{\n\tChannel *c = NULL;\n\tchar *target, *originator;\n\tu_short originator_port;\n\n\ttarget = packet_get_string(NULL);\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\n\tdebug(\"server_request_direct_streamlocal: originator %s port %d, target %s\",\n\t    originator, originator_port, target);\n\n\tif ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&\n\t    !no_port_forwarding_flag && !options.disable_forwarding) {\n\t\tc = channel_connect_to_path(target,\n\t\t    \"direct-streamlocal@openssh.com\", \"direct-streamlocal\");\n\t} else {\n\t\tlogit(\"refused streamlocal port forward: \"\n\t\t    \"originator %s port %d, target %s\",\n\t\t    originator, originator_port, target);\n\t}\n\n\tfree(originator);\n\tfree(target);\n\n\treturn c;\n}",
        "output": "1",
        "idx": 5604
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_task_ioprio(struct task_struct *p)\n{\n\tint ret;\n\n\tret = security_task_getioprio(p);\n\tif (ret)\n\t\tgoto out;\n\tret = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, IOPRIO_NORM);\n\ttask_lock(p);\n\tif (p->io_context)\n\t\tret = p->io_context->ioprio;\n\ttask_unlock(p);\nout:\n\treturn ret;\n}",
        "output": "0",
        "idx": 1903
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int khugepaged_enter_vma_merge(struct vm_area_struct *vma)\n{\n\tunsigned long hstart, hend;\n\tif (!vma->anon_vma)\n\t\treturn 0;\n\tif (vma->vm_ops)\n\t\treturn 0;\n\tVM_BUG_ON(is_linear_pfn_mapping(vma) || vma->vm_flags & VM_NO_THP);\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (hstart < hend)\n\t\treturn khugepaged_enter(vma);\n\treturn 0;\n}",
        "output": "0",
        "idx": 447
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int blk_init_allocated_queue(struct request_queue *q)\n{\n\tWARN_ON_ONCE(q->mq_ops);\n\n\tq->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);\n\tif (!q->fq)\n\t\treturn -ENOMEM;\n\n\tif (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))\n\t\tgoto out_free_flush_queue;\n\n\tif (blk_init_rl(&q->root_rl, q, GFP_KERNEL))\n\t\tgoto out_exit_flush_rq;\n\n\tINIT_WORK(&q->timeout_work, blk_timeout_work);\n\tq->queue_flags\t\t|= QUEUE_FLAG_DEFAULT;\n\n\tblk_queue_make_request(q, blk_queue_bio);\n\n\tq->sg_reserved_size = INT_MAX;\n\n\tif (elevator_init(q))\n\t\tgoto out_exit_flush_rq;\n\treturn 0;\n\nout_exit_flush_rq:\n\tif (q->exit_rq_fn)\n\t\tq->exit_rq_fn(q, q->fq->flush_rq);\nout_free_flush_queue:\n\tblk_free_flush_queue(q->fq);\n\tq->fq = NULL;\n\treturn -ENOMEM;\n}",
        "output": "0",
        "idx": 4139
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n{\n\twalk->private += __mincore_unmapped_range(addr, end,\n\t\t\t\t\t\t  walk->vma, walk->private);\n\treturn 0;\n}",
        "output": "1",
        "idx": 3064
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xar_get_numeric_from_xml_element(xmlTextReaderPtr reader, long * value)\n{\n    const xmlChar * numstr;\n    if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {\n        numstr = xmlTextReaderConstValue(reader);\n        if (numstr) {\n            *value = atol((const char *)numstr);\n            if (*value < 0) {\n                cli_dbgmsg(\"cli_scanxar: XML element value %li\\n\", *value);\n                return CL_EFORMAT;\n            }\n            return CL_SUCCESS;\n        }\n    }\n    cli_dbgmsg(\"cli_scanxar: No text for XML element\\n\");\n    return CL_EFORMAT;\n}",
        "output": "1",
        "idx": 6732
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mbochs_remove(struct mdev_device *mdev)\n{\n\tstruct mdev_state *mdev_state = dev_get_drvdata(&mdev->dev);\n\n\tmbochs_used_mbytes -= mdev_state->type->mbytes;\n\tvfio_unregister_group_dev(&mdev_state->vdev);\n\tkfree(mdev_state->pages);\n\tkfree(mdev_state->vconfig);\n\tkfree(mdev_state);\n}",
        "output": "1",
        "idx": 1980
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mrb_proc_init_copy(mrb_state *mrb, mrb_value self)\n{\n  mrb_value proc = mrb_get_arg1(mrb);\n\n  if (!mrb_proc_p(proc)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"not a proc\");\n  }\n  mrb_proc_copy(mrb_proc_ptr(self), mrb_proc_ptr(proc));\n  return self;\n}",
        "output": "1",
        "idx": 6686
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CURLcode Curl_urldecode(struct SessionHandle *data,\n                        const char *string, size_t length,\n                        char **ostring, size_t *olen,\n                        bool reject_ctrl)\n{\n  size_t alloc = (length?length:strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  size_t strindex=0;\n  unsigned long hex;\n  CURLcode res;\n\n  if(!ns)\n    return CURLE_OUT_OF_MEMORY;\n\n  while(--alloc > 0) {\n    in = *string;\n    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n      char hexstr[3];\n      char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n\n      hex = strtoul(hexstr, &ptr, 16);\n\n      in = curlx_ultouc(hex); \n\n      res = Curl_convert_from_network(data, &in, 1);\n      if(res) {\n        free(ns);\n        return res;\n      }\n\n      string+=2;\n      alloc-=2;\n    }\n    if(reject_ctrl && (in < 0x20)) {\n      free(ns);\n      return CURLE_URL_MALFORMAT;\n    }\n\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; \n\n  if(olen)\n    *olen = strindex;\n\n  if(ostring)\n    *ostring = ns;\n\n  return CURLE_OK;\n}",
        "output": "0",
        "idx": 5015
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void prefetch_enc(void)\n{\n  prefetch_table((const void *)encT, sizeof(encT));\n}",
        "output": "1",
        "idx": 7444
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "tabstop_set(char_u *var, int **array)\n{\n    int valcount = 1;\n    int t;\n    char_u *cp;\n\n    if (var[0] == NUL || (var[0] == '0' && var[1] == NUL))\n    {\n\t*array = NULL;\n\treturn TRUE;\n    }\n\n    for (cp = var; *cp != NUL; ++cp)\n    {\n\tif (cp == var || cp[-1] == ',')\n\t{\n\t    char_u *end;\n\n\t    if (strtol((char *)cp, (char **)&end, 10) <= 0)\n\t    {\n\t\tif (cp != end)\n\t\t    emsg(_(e_positive));\n\t\telse\n\t\t    emsg(_(e_invarg));\n\t\treturn FALSE;\n\t    }\n\t}\n\n\tif (VIM_ISDIGIT(*cp))\n\t    continue;\n\tif (cp[0] == ',' && cp > var && cp[-1] != ',' && cp[1] != NUL)\n\t{\n\t    ++valcount;\n\t    continue;\n\t}\n\temsg(_(e_invarg));\n\treturn FALSE;\n    }\n\n    *array = ALLOC_MULT(int, valcount + 1);\n    if (*array == NULL)\n\treturn FALSE;\n    (*array)[0] = valcount;\n\n    t = 1;\n    for (cp = var; *cp != NUL;)\n    {\n\t(*array)[t++] = atoi((char *)cp);\n\twhile (*cp  != NUL && *cp != ',')\n\t    ++cp;\n\tif (*cp != NUL)\n\t    ++cp;\n    }\n\n    return TRUE;\n}",
        "output": "1",
        "idx": 5676
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_GetArrayItem(cJSON *array,int item)\t\t\t\t{cJSON *c=array?array->child:0;while (c && item>0) item--,c=c->next; return c;}",
        "output": "0",
        "idx": 8299
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int AES_encrypt(char *message, uint8_t *encr_message, uint64_t encrLen) {\n\n    if (!message) {\n        LOG_ERROR(\"Null message in AES_encrypt\");\n        return -1;\n    }\n\n    if (!encr_message) {\n        LOG_ERROR(\"Null encr message in AES_encrypt\");\n        return -2;\n    }\n\n    uint64_t len = strlen(message) + 1;\n\n    if (len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrLen ) {\n        LOG_ERROR(\"Output buffer too small\");\n        return -3;\n    }\n\n    sgx_read_rand(encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE);\n\n    sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_key, (uint8_t*)message, strlen(message),\n                                                     encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE,\n                                                     encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,\n                                                     NULL, 0,\n                                                     (sgx_aes_gcm_128bit_tag_t *) encr_message);\n\n    return status;\n}",
        "output": "1",
        "idx": 8694
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_shellsize(void)\n{\n    if (Rows < min_rows())\t\n\tRows = min_rows();\n    limit_screen_size();\n\n    if (cmdline_row >= Rows)\n\tcmdline_row = Rows - 1;\n    if (msg_row >= Rows)\n\tmsg_row = Rows - 1;\n}",
        "output": "0",
        "idx": 8067
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_seq_ioctl_remove_events(struct snd_seq_client *client,\n\t\t\t\t       void __user *arg)\n{\n\tstruct snd_seq_remove_events info;\n\n\tif (copy_from_user(&info, arg, sizeof(info)))\n\t\treturn -EFAULT;\n\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_INPUT) {\n\t\tif (client->type == USER_CLIENT && client->data.user.fifo)\n\t\t\tsnd_seq_fifo_clear(client->data.user.fifo);\n\t}\n\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_OUTPUT)\n\t\tsnd_seq_queue_remove_cells(client->number, &info);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1515
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "qedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t\tconst char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & QEDI_LOG_NOTICE))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_notice(\"[%s]:[%s:%d]:%d: %pV\",\n\t\t\t  dev_name(&qedi->pdev->dev), nfunc, line,\n\t\t\t  qedi->host_no, &vaf);\n\telse\n\t\tpr_notice(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\n\nret:\n\tva_end(va);\n}",
        "output": "1",
        "idx": 3182
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mingw_rmdir(const char *pathname)\n{\n\tint ret, tries = 0;\n\twchar_t wpathname[MAX_PATH];\n\tif (xutftowcs_path(wpathname, pathname) < 0)\n\t\treturn -1;\n\n\twhile ((ret = _wrmdir(wpathname)) == -1 && tries < ARRAY_SIZE(delay)) {\n\t\tif (!is_file_in_use_error(GetLastError()))\n\t\t\terrno = err_win_to_posix(GetLastError());\n\t\tif (errno != EACCES)\n\t\t\tbreak;\n\t\tif (!is_dir_empty(wpathname)) {\n\t\t\terrno = ENOTEMPTY;\n\t\t\tbreak;\n\t\t}\n\t\tSleep(delay[tries]);\n\t\ttries++;\n\t}\n\twhile (ret == -1 && errno == EACCES && is_file_in_use_error(GetLastError()) &&\n\t       ask_yes_no_if_possible(\"Deletion of directory '%s' failed. \"\n\t\t\t\"Should I try again?\", pathname))\n\t       ret = _wrmdir(wpathname);\n\tif (!ret)\n\t\tinvalidate_lstat_cache();\n\treturn ret;\n}",
        "output": "0",
        "idx": 7207
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API RCmdAliasVal *r_cmd_alias_get(RCmd *cmd, const char *k) {\n\tr_return_val_if_fail (cmd && cmd->aliases && k, NULL);\n\treturn ht_pp_find(cmd->aliases, k, NULL);\n}",
        "output": "1",
        "idx": 6502
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void exit_io_context(struct task_struct *task)\n{\n}",
        "output": "0",
        "idx": 3121
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ext2_xattr_cache_insert(struct mb2_cache *cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n\tint error;\n\n\terror = mb2_cache_entry_create(cache, GFP_NOFS, hash, bh->b_blocknr);\n\tif (error) {\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache (%d cache entries)\",\n\t\t\t\tatomic_read(&ext2_xattr_cache->c_entry_count));\n\t\t\terror = 0;\n\t\t}\n\t} else\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\treturn error;\n}",
        "output": "0",
        "idx": 1653
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int add_ast_fields(void)\n{\n    PyObject *empty_tuple, *d;\n    if (PyType_Ready(&AST_type) < 0)\n        return -1;\n    d = AST_type.tp_dict;\n    empty_tuple = PyTuple_New(0);\n    if (!empty_tuple ||\n        PyDict_SetItemString(d, \"_fields\", empty_tuple) < 0 ||\n        PyDict_SetItemString(d, \"_attributes\", empty_tuple) < 0) {\n        Py_XDECREF(empty_tuple);\n        return -1;\n    }\n    Py_DECREF(empty_tuple);\n    return 0;\n}",
        "output": "1",
        "idx": 7698
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE1(inotify_init1, int, flags)\n{\n\tstruct fsnotify_group *group;\n\tstruct user_struct *user;\n\tint ret;\n\n\tBUILD_BUG_ON(IN_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(IN_NONBLOCK != O_NONBLOCK);\n\n\tif (flags & ~(IN_CLOEXEC | IN_NONBLOCK))\n\t\treturn -EINVAL;\n\n\tuser = get_current_user();\n\tif (unlikely(atomic_read(&user->inotify_devs) >=\n\t\t\tinotify_max_user_instances)) {\n\t\tret = -EMFILE;\n\t\tgoto out_free_uid;\n\t}\n\n\tgroup = inotify_new_group(user, inotify_max_queued_events);\n\tif (IS_ERR(group)) {\n\t\tret = PTR_ERR(group);\n\t\tgoto out_free_uid;\n\t}\n\n\tatomic_inc(&user->inotify_devs);\n\n\tret = anon_inode_getfd(\"inotify\", &inotify_fops, group,\n\t\t\t\t  O_RDONLY | flags);\n\tif (ret >= 0)\n\t\treturn ret;\n\n\tfsnotify_put_group(group);\n\tatomic_dec(&user->inotify_devs);\nout_free_uid:\n\tfree_uid(user);\n\treturn ret;\n}",
        "output": "0",
        "idx": 345
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n{\n\tgdImagePtr pim = 0, tim = im;\n\tint interlace, BitsPerPixel;\n\tinterlace = im->interlace;\n\n\tif(im->trueColor) {\n\t\tpim = gdImageCreatePaletteFromTrueColor(im, 1, 256);\n\t\tif(!pim) {\n\t\t\treturn 1;\n\t\t}\n\t\ttim = pim;\n\t}\n\n\tBitsPerPixel = colorstobpp(tim->colorsTotal);\n\n\tGIFEncode(\n\t    out, tim->sx, tim->sy, interlace, 0, tim->transparent, BitsPerPixel,\n\t    tim->red, tim->green, tim->blue, tim);\n\n\tif(pim) {\n\t\tgdImageDestroy(\tpim);\n\t}\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 6217
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *ipc_rcu_alloc(int size)\n{\n\tvoid *out;\n\n\tif (rcu_use_vmalloc(size)) {\n\t\tout = vmalloc(HDRLEN_VMALLOC + size);\n\t\tif (!out)\n\t\t\tgoto done;\n\n\t\tout += HDRLEN_VMALLOC;\n\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 1;\n\t} else {\n\t\tout = kmalloc(HDRLEN_KMALLOC + size, GFP_KERNEL);\n\t\tif (!out)\n\t\t\tgoto done;\n\n\t\tout += HDRLEN_KMALLOC;\n\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 0;\n\t}\n\n\tatomic_set(&container_of(out, struct ipc_rcu_hdr, data)->refcount, 1);\ndone:\n\treturn out;\n}",
        "output": "0",
        "idx": 3233
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n\t\t\t size_t sec_attr_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tif (sec_attr == NULL) {\n\t\tif (file->sec_attr != NULL)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn 0;\n\t }\n\ttmp = (u8 *) realloc(file->sec_attr, sec_attr_len);\n\tif (!tmp) {\n\t\tif (file->sec_attr)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr     = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tfile->sec_attr = tmp;\n\tmemcpy(file->sec_attr, sec_attr, sec_attr_len);\n\tfile->sec_attr_len = sec_attr_len;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 7026
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n{\n  size_t alloc = (inlength?(size_t)inlength:strlen(string))+1;\n  char *ns;\n  char *testing_ptr = NULL;\n  unsigned char in; \n  size_t newlen = alloc;\n  size_t strindex=0;\n  size_t length;\n  CURLcode res;\n\n  ns = malloc(alloc);\n  if(!ns)\n    return NULL;\n\n  length = alloc-1;\n  while(length--) {\n    in = *string;\n\n    if(Curl_isunreserved(in))\n      ns[strindex++]=in;\n    else {\n      newlen += 2; \n      if(newlen > alloc) {\n        alloc *= 2;\n        testing_ptr = realloc(ns, alloc);\n        if(!testing_ptr) {\n          free( ns );\n          return NULL;\n        }\n        else {\n          ns = testing_ptr;\n        }\n      }\n\n      res = Curl_convert_to_network(handle, &in, 1);\n      if(res) {\n        free(ns);\n        return NULL;\n      }\n\n      snprintf(&ns[strindex], 4, \"%%%02X\", in);\n\n      strindex+=3;\n    }\n    string++;\n  }\n  ns[strindex]=0; \n  return ns;\n}",
        "output": "0",
        "idx": 5013
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void * CAPSTONE_API cs_winkernel_malloc(size_t size)\n{\n\tNT_ASSERT(size);\n\n#pragma prefast(suppress : 30030)\t\t\n\tsize_t number_of_bytes = 0;\n\tCS_WINKERNEL_MEMBLOCK *block = NULL;\n\tif (!NT_SUCCESS(RtlSizeTAdd(size, sizeof(CS_WINKERNEL_MEMBLOCK), &number_of_bytes))) {\n\t\treturn NULL;\n\t}\n\tblock = (CS_WINKERNEL_MEMBLOCK *)ExAllocatePoolWithTag(\n\t\t\tNonPagedPool, number_of_bytes, CS_WINKERNEL_POOL_TAG);\n\tif (!block) {\n\t\treturn NULL;\n\t}\n\tblock->size = size;\n\n\treturn block->data;\n}",
        "output": "0",
        "idx": 8479
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *get_pid_environ_val(pid_t pid,char *val){\n  char temp[500];\n  int i=0;\n  int foundit=0;\n  FILE *fp;\n\n  sprintf(temp,\"/proc/%d/environ\",pid);\n\n  fp=fopen(temp,\"r\");\n  if(fp==NULL)\n    return NULL;\n\n  \n  for(;;){\n    temp[i]=fgetc(fp);    \n\n    if(foundit==1 && (temp[i]==0 || temp[i]=='\\0' || temp[i]==EOF)){\n      char *ret;\n      temp[i]=0;\n      ret=malloc(strlen(temp)+10);\n      sprintf(ret,\"%s\",temp);\n      fclose(fp);\n      return ret;\n    }\n\n    switch(temp[i]){\n    case EOF:\n      fclose(fp);\n      return NULL;\n    case '=':\n      temp[i]=0;\n      if(!strcmp(temp,val)){\n\tfoundit=1;\n      }\n      i=0;\n      break;\n    case '\\0':\n      i=0;\n      break;\n    default:\n      i++;\n    }\n  }\n}",
        "output": "1",
        "idx": 5236
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int x86_pmu_handle_irq(struct pt_regs *regs)\n{\n\tstruct perf_sample_data data;\n\tstruct cpu_hw_events *cpuc;\n\tstruct perf_event *event;\n\tint idx, handled = 0;\n\tu64 val;\n\n\tperf_sample_data_init(&data, 0);\n\n\tcpuc = &__get_cpu_var(cpu_hw_events);\n\n\tapic_write(APIC_LVTPC, APIC_DM_NMI);\n\n\tfor (idx = 0; idx < x86_pmu.num_counters; idx++) {\n\t\tif (!test_bit(idx, cpuc->active_mask)) {\n\t\t\tif (__test_and_clear_bit(idx, cpuc->running))\n\t\t\t\thandled++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tevent = cpuc->events[idx];\n\n\t\tval = x86_perf_event_update(event);\n\t\tif (val & (1ULL << (x86_pmu.cntval_bits - 1)))\n\t\t\tcontinue;\n\n\t\thandled++;\n\t\tdata.period\t= event->hw.last_period;\n\n\t\tif (!x86_perf_event_set_period(event))\n\t\t\tcontinue;\n\n\t\tif (perf_event_overflow(event, 1, &data, regs))\n\t\t\tx86_pmu_stop(event, 0);\n\t}\n\n\tif (handled)\n\t\tinc_irq_stat(apic_perf_irqs);\n\n\treturn handled;\n}",
        "output": "1",
        "idx": 500
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ikev2_parent_inR1outI2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inR1outI2: calculating g^{xy}, sending I2\"));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t\treturn;\n\t}\n\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\n\tpassert(st->st_suspended_md == dh->md);\n\tset_suspended(st, NULL); \n\n\tset_cur_state(st);\n\n\tst->st_calculating = FALSE;\n\n\te = ikev2_parent_inR1outI2_tail(pcrc, r);\n\n\tif (dh->md != NULL) {\n\t\tcomplete_v2_state_transition(&dh->md, e);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t}\n\treset_globals();\n\n\tpassert(GLOBALS_ARE_RESET());\n}",
        "output": "1",
        "idx": 4384
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_unwrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer,\n\t\tgss_buffer_t output_message_buffer,\n\t\tint *conf_state,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap(minor_status,\n\t\t\tcontext_handle,\n\t\t\tinput_message_buffer,\n\t\t\toutput_message_buffer,\n\t\t\tconf_state,\n\t\t\tqop_state);\n\n\treturn (ret);\n}",
        "output": "1",
        "idx": 58
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,\n\t\t\t       struct scm_cookie *scm, bool forcecreds)\n{\n\tmemset(scm, 0, sizeof(*scm));\n\tif (forcecreds)\n\t\tscm_set_cred(scm, task_tgid(current), current_cred());\n\tunix_get_peersec_dgram(sock, scm);\n\tif (msg->msg_controllen <= 0)\n\t\treturn 0;\n\treturn __scm_send(sock, msg, scm);\n}",
        "output": "0",
        "idx": 1025
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "videobuf_vm_open(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\n\tdprintk(2,\"vm_open %p [count=%u,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\n\tmap->count++;\n}",
        "output": "0",
        "idx": 2991
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_symlinks(struct archive_write_disk *a)\n{\n\tstruct archive_string error_string;\n\tint error_number;\n\tint rc;\n\tarchive_string_init(&error_string);\n\trc = check_symlinks_fsobj(a->name, &error_number, &error_string, a->flags);\n\tif (rc != ARCHIVE_OK) {\n\t\tarchive_set_error(&a->archive, error_number, \"%s\", error_string.s);\n\t}\n\tarchive_string_free(&error_string);\n\ta->pst = NULL;\t\n\treturn rc;\n}",
        "output": "0",
        "idx": 5193
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline u32 net_hash_mix(const struct net *net)\n{\n\treturn net->hash_mix;\n}",
        "output": "0",
        "idx": 4305
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "juniper_atm1_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        int llc_hdrlen;\n\n        struct juniper_l2info_t l2info;\n\n        l2info.pictype = DLT_JUNIPER_ATM1;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n\n        p+=l2info.header_len;\n\n        if (l2info.cookie[0] == 0x80) { \n            oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC);\n            return l2info.header_len;\n        }\n\n        if (EXTRACT_24BITS(p) == 0xfefe03 || \n            EXTRACT_24BITS(p) == 0xaaaa03) { \n\n            llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            if (llc_hdrlen > 0)\n                return l2info.header_len;\n        }\n\n        if (p[0] == 0x03) { \n            isoclns_print(ndo, p + 1, l2info.length - 1);\n            return l2info.header_len;\n        }\n\n        if (ip_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n\n\treturn l2info.header_len;\n}",
        "output": "0",
        "idx": 6547
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct file *get_empty_filp(void)\n{\n\tconst struct cred *cred = current_cred();\n\tstatic long old_max;\n\tstruct file *f;\n\tint error;\n\n\tif (get_nr_files() >= files_stat.max_files && !capable(CAP_SYS_ADMIN)) {\n\t\tif (percpu_counter_sum_positive(&nr_files) >= files_stat.max_files)\n\t\t\tgoto over;\n\t}\n\n\tf = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);\n\tif (unlikely(!f))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpercpu_counter_inc(&nr_files);\n\tf->f_cred = get_cred(cred);\n\terror = security_file_alloc(f);\n\tif (unlikely(error)) {\n\t\tfile_free(f);\n\t\treturn ERR_PTR(error);\n\t}\n\n\tINIT_LIST_HEAD(&f->f_u.fu_list);\n\tatomic_long_set(&f->f_count, 1);\n\trwlock_init(&f->f_owner.lock);\n\tspin_lock_init(&f->f_lock);\n\teventpoll_init_file(f);\n\treturn f;\n\nover:\n\tif (get_nr_files() > old_max) {\n\t\tpr_info(\"VFS: file-max limit %lu reached\\n\", get_max_files());\n\t\told_max = get_nr_files();\n\t}\n\treturn ERR_PTR(-ENFILE);\n}",
        "output": "1",
        "idx": 2384
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char *cmd_xml_external_entity(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"on\") == 0)  {\n        dcfg->xml_external_entity = 1;\n    }\n    else if (strcasecmp(p1, \"off\") == 0)    {\n        dcfg->xml_external_entity = 0;\n    }\n    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecXmlExternalEntity: %s\", p1);\n\n    return NULL;\n}",
        "output": "0",
        "idx": 5279
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "usm_malloc_usmStateReference(void)\n{\n    struct usmStateReference *retval = (struct usmStateReference *)\n        calloc(1, sizeof(struct usmStateReference));\n\n    return retval;\n}                               ",
        "output": "1",
        "idx": 7818
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "expand_dynamic_string_token (struct link_map *l, const char *s)\n{\n  size_t cnt;\n  size_t total;\n  char *result;\n\n  cnt = DL_DST_COUNT (s, 1);\n\n  if (cnt == 0)\n    return local_strdup (s);\n\n  total = DL_DST_REQUIRED (l, s, strlen (s), cnt);\n\n  result = (char *) malloc (total + 1);\n  if (result == NULL)\n    return NULL;\n\n  return DL_DST_SUBSTITUTE (l, s, result, 1);\n}",
        "output": "0",
        "idx": 1
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\tif (node->nd_item.ci_parent)\n\t\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n\telse\n\t\treturn NULL;\n}",
        "output": "0",
        "idx": 2557
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dev_get_valid_name(struct net *net, struct net_device *dev,\n\t\t       const char *name)\n{\n\tBUG_ON(!net);\n\n\tif (!dev_valid_name(name))\n\t\treturn -EINVAL;\n\n\tif (strchr(name, '%'))\n\t\treturn dev_alloc_name_ns(net, dev, name);\n\telse if (__dev_get_by_name(net, name))\n\t\treturn -EEXIST;\n\telse if (dev->name != name)\n\t\tstrlcpy(dev->name, name, IFNAMSIZ);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2471
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "test_copy_to (const char *from, const char *to)\n{\n  char buf[TESTBUFSIZE];\n  int ret;\n\n  snprintf_func (buf, TESTBUFSIZE, \"cp -f %s %s\", from, to);\n\n  if ((ret = system (buf)) != 0)\n    {\n      return XD3_INTERNAL;\n    }\n\n  return 0;\n}",
        "output": "0",
        "idx": 7121
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int bcm_delete_rx_op(struct list_head *ops, struct bcm_msg_head *mh,\n\t\t\t    int ifindex)\n{\n\tstruct bcm_op *op, *n;\n\n\tlist_for_each_entry_safe(op, n, ops, list) {\n\t\tif ((op->can_id == mh->can_id) && (op->ifindex == ifindex) &&\n\t\t    (op->flags & CAN_FD_FRAME) == (mh->flags & CAN_FD_FRAME)) {\n\n\t\t\tif (op->ifindex) {\n\t\t\t\tif (op->rx_reg_dev) {\n\t\t\t\t\tstruct net_device *dev;\n\n\t\t\t\t\tdev = dev_get_by_index(sock_net(op->sk),\n\t\t\t\t\t\t\t       op->ifindex);\n\t\t\t\t\tif (dev) {\n\t\t\t\t\t\tbcm_rx_unreg(dev, op);\n\t\t\t\t\t\tdev_put(dev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tcan_rx_unregister(sock_net(op->sk), NULL,\n\t\t\t\t\t\t  op->can_id,\n\t\t\t\t\t\t  REGMASK(op->can_id),\n\t\t\t\t\t\t  bcm_rx_handler, op);\n\n\t\t\tlist_del(&op->list);\n\t\t\tsynchronize_rcu();\n\t\t\tbcm_remove_op(op);\n\t\t\treturn 1; \n\t\t}\n\t}\n\n\treturn 0; \n}",
        "output": "0",
        "idx": 2817
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs4_xdr_enc_getacl(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tstruct nfs_getaclargs *args)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\tuint32_t replen;\n\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\treplen = hdr.replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1;\n\tencode_getattr_two(xdr, FATTR4_WORD0_ACL, 0, &hdr);\n\n\txdr_inline_pages(&req->rq_rcv_buf, replen << 2,\n\t\targs->acl_pages, args->acl_pgbase, args->acl_len);\n\tencode_nops(&hdr);\n}",
        "output": "1",
        "idx": 660
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int encode_open_downgrade(struct xdr_stream *xdr, const struct nfs_closeargs *arg)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4+NFS4_STATEID_SIZE+4);\n\tWRITE32(OP_OPEN_DOWNGRADE);\n\tWRITEMEM(arg->stateid->data, NFS4_STATEID_SIZE);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->fmode);\n\treturn 0;\n}",
        "output": "0",
        "idx": 3091
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "read_file(gchar* filepath)\n{\n\tFILE * f;\n\tsize_t length;\n\tgchar *ret = NULL;\n\n\tf = fopen(filepath, \"rb\");\n\tif (f) {\n\t\tfseek(f, 0, SEEK_END);\n\t\tlength = (size_t)ftell(f);\n\t\tfseek(f, 0, SEEK_SET);\n\n\t\tret = MALLOC(length + 1);\n\t\tif (ret) {\n\t\t\tif (fread(ret, length, 1, f) != 1) {\n\t\t\t\tlog_message(LOG_INFO, \"Failed to read all of %s\", filepath);\n\t\t\t}\n\t\t\tret[length] = '\\0';\n\t\t}\n\t\telse\n\t\t\tlog_message(LOG_INFO, \"Unable to read Dbus file %s\", filepath);\n\n\t\tfclose(f);\n\t}\n\treturn ret;\n}",
        "output": "1",
        "idx": 7086
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "file_check_mem(struct magic_set *ms, unsigned int level)\n{\n\tsize_t len;\n\n\tif (level >= ms->c.len) {\n\t\tlen = (ms->c.len = 20 + level) * sizeof(*ms->c.li);\n\t\tms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?\n\t\t    malloc(len) :\n\t\t    realloc(ms->c.li, len));\n\t\tif (ms->c.li == NULL) {\n\t\t\tfile_oomem(ms, len);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tms->c.li[level].got_match = 0;\n#ifdef ENABLE_CONDITIONALS\n\tms->c.li[level].last_match = 0;\n\tms->c.li[level].last_cond = COND_NONE;\n#endif \n\treturn 0;\n}",
        "output": "0",
        "idx": 6149
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_event_task_output(struct perf_event *event,\n\t\t\t\t     struct perf_task_event *task_event)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data\tsample;\n\tstruct task_struct *task = task_event->task;\n\tint ret, size = task_event->event_id.header.size;\n\n\tperf_event_header__init_id(&task_event->event_id.header, &sample, event);\n\n\tret = perf_output_begin(&handle, event,\n\t\t\t\ttask_event->event_id.header.size, 0);\n\tif (ret)\n\t\tgoto out;\n\n\ttask_event->event_id.pid = perf_event_pid(event, task);\n\ttask_event->event_id.ppid = perf_event_pid(event, current);\n\n\ttask_event->event_id.tid = perf_event_tid(event, task);\n\ttask_event->event_id.ptid = perf_event_tid(event, current);\n\n\tperf_output_put(&handle, task_event->event_id);\n\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\nout:\n\ttask_event->event_id.header.size = size;\n}",
        "output": "0",
        "idx": 685
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int check_directory(struct dir *dir)\n{\n\tint i;\n\tstruct dir_ent *ent;\n\n\tif(dir->dir_count < 2)\n\t\treturn TRUE;\n\n\tfor(ent = dir->dirs, i = 0; i < dir->dir_count - 1; ent = ent->next, i++)\n\t\tif(strcmp(ent->name, ent->next->name) >= 0)\n\t\t\treturn FALSE;\n\n\treturn TRUE;\n}",
        "output": "0",
        "idx": 7435
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int input_set_keycode(struct input_dev *dev,\n\t\t      const struct input_keymap_entry *ke)\n{\n\tunsigned long flags;\n\tunsigned int old_keycode;\n\tint retval;\n\n\tif (ke->keycode > KEY_MAX)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\n\tretval = dev->setkeycode(dev, ke, &old_keycode);\n\tif (retval)\n\t\tgoto out;\n\n\t__clear_bit(KEY_RESERVED, dev->keybit);\n\n\tif (old_keycode > KEY_MAX) {\n\t\tdev_warn(dev->dev.parent ?: &dev->dev,\n\t\t\t \"%s: got too big old keycode %#x\\n\",\n\t\t\t __func__, old_keycode);\n\t} else if (test_bit(EV_KEY, dev->evbit) &&\n\t\t   !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&\n\t\t   __test_and_clear_bit(old_keycode, dev->key)) {\n\t\tstruct input_value vals[] =  {\n\t\t\t{ EV_KEY, old_keycode, 0 },\n\t\t\tinput_value_sync\n\t\t};\n\n\t\tinput_pass_values(dev, vals, ARRAY_SIZE(vals));\n\t}\n\n out:\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\n\treturn retval;\n}",
        "output": "0",
        "idx": 4595
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline key_ref_t __key_update(key_ref_t key_ref,\n\t\t\t\t     struct key_preparsed_payload *prep)\n{\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = -EEXIST;\n\tif (!key->type->update)\n\t\tgoto error;\n\n\tdown_write(&key->sem);\n\n\tret = key->type->update(key, prep);\n\tif (ret == 0)\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\n\tup_write(&key->sem);\n\n\tif (ret < 0)\n\t\tgoto error;\nout:\n\treturn key_ref;\n\nerror:\n\tkey_put(key);\n\tkey_ref = ERR_PTR(ret);\n\tgoto out;\n}",
        "output": "1",
        "idx": 1724
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void regulator_ena_gpio_free(struct regulator_dev *rdev)\n{\n\tstruct regulator_enable_gpio *pin, *n;\n\n\tif (!rdev->ena_pin)\n\t\treturn;\n\n\tlist_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {\n\t\tif (pin->gpiod == rdev->ena_pin->gpiod) {\n\t\t\tif (pin->request_count <= 1) {\n\t\t\t\tpin->request_count = 0;\n\t\t\t\tgpiod_put(pin->gpiod);\n\t\t\t\tlist_del(&pin->list);\n\t\t\t\tkfree(pin);\n\t\t\t\trdev->ena_pin = NULL;\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tpin->request_count--;\n\t\t\t}\n\t\t}\n\t}\n}",
        "output": "0",
        "idx": 3767
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void esp32EthDisableIrq(NetInterface *interface)\n{\n\n   if(interface->phyDriver != NULL)\n   {\n      interface->phyDriver->disableIrq(interface);\n   }\n   else if(interface->switchDriver != NULL)\n   {\n      interface->switchDriver->disableIrq(interface);\n   }\n   else\n   {\n   }\n}",
        "output": "1",
        "idx": 8586
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void luaT_adjustvarargs (lua_State *L, int nfixparams, CallInfo *ci,\n                         const Proto *p) {\n  int i;\n  int actual = cast_int(L->top - ci->func) - 1;  \n  int nextra = actual - nfixparams;  \n  ci->u.l.nextraargs = nextra;\n  checkstackGC(L, p->maxstacksize + 1);\n  setobjs2s(L, L->top++, ci->func);\n  for (i = 1; i <= nfixparams; i++) {\n    setobjs2s(L, L->top++, ci->func + i);\n    setnilvalue(s2v(ci->func + i));  \n  }\n  ci->func += actual + 1;\n  ci->top += actual + 1;\n  lua_assert(L->top <= ci->top && ci->top <= L->stack_last);\n}",
        "output": "1",
        "idx": 8096
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void jsonNewDString(Jsi_Interp *interp, Jsi_DString *dStr, const char* str, int len)\n{\n    char buf[100], *dp = buf;\n    const char *cp = str;\n    int ulen;\n    \n    while ((cp-str)<len) {\n        if (*cp == '\\\\') {\n            switch (cp[1]) {\n                case 'b': *dp++ = '\\b'; break;\n                case 'n': *dp++ = '\\n'; break;\n                case 'r': *dp++ = '\\r'; break;\n                case 'f': *dp++ = '\\f'; break;\n                case 't': *dp++ = '\\t'; break;\n                case '\\\"': *dp++ = '\\\"'; break;\n                case '\\\\': *dp++ = '\\\\'; break;\n                case 'u': \n                    if ((ulen=Jsi_UtfDecode(cp+2, dp))) {\n                        dp += ulen;\n                        cp += 4;\n                    } else {                    \n                        *dp++ = '\\\\';\n                        *dp++ = 'u';\n                    }\n                    break;\n            }\n            cp+=2;\n        } else {\n            *dp++ = *cp++;\n        }\n        if ((dp-buf)>90) {\n            *dp = 0;\n            Jsi_DSAppendLen(dStr, buf, dp-buf);\n            dp = buf;\n        }\n    }\n    *dp = 0;\n    Jsi_DSAppendLen(dStr, buf, dp-buf);\n}",
        "output": "1",
        "idx": 8192
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateObject( void )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item )\n\t\titem->type = cJSON_Object;\n\treturn item;\n}",
        "output": "1",
        "idx": 5928
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)\n{\n\tu64 elem_size = sizeof(struct stack_map_bucket) +\n\t\t\t(u64)smap->map.value_size;\n\tint err;\n\n\tsmap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,\n\t\t\t\t\t smap->map.numa_node);\n\tif (!smap->elems)\n\t\treturn -ENOMEM;\n\n\terr = pcpu_freelist_init(&smap->freelist);\n\tif (err)\n\t\tgoto free_elems;\n\n\tpcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,\n\t\t\t       smap->map.max_entries);\n\treturn 0;\n\nfree_elems:\n\tbpf_map_area_free(smap->elems);\n\treturn err;\n}",
        "output": "0",
        "idx": 2861
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_emul_alloc_resource(uint64_t *baseptr, uint64_t limit, uint64_t size,\n\t\t\tuint64_t *addr)\n{\n\tuint64_t base;\n\n\tassert((size & (size - 1)) == 0);\t\n\n\tbase = roundup2(*baseptr, size);\n\n\tif (base + size <= limit) {\n\t\t*addr = base;\n\t\t*baseptr = base + size;\n\t\treturn 0;\n\t} else\n\t\treturn -1;\n}",
        "output": "1",
        "idx": 7604
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int flush_completed_IO(struct inode *inode)\n{\n\text4_io_end_t *io;\n\tint ret = 0;\n\tint ret2 = 0;\n\n\tif (list_empty(&EXT4_I(inode)->i_completed_io_list))\n\t\treturn ret;\n\n\tdump_completed_IO(inode);\n\twhile (!list_empty(&EXT4_I(inode)->i_completed_io_list)){\n\t\tio = list_entry(EXT4_I(inode)->i_completed_io_list.next,\n\t\t\t\text4_io_end_t, list);\n\t\tret = ext4_end_io_nolock(io);\n\t\tif (ret < 0)\n\t\t\tret2 = ret;\n\t\telse\n\t\t\tlist_del_init(&io->list);\n\t}\n\treturn (ret2 < 0) ? ret2 : 0;\n}",
        "output": "1",
        "idx": 2232
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mrb_mod_define_method_m(mrb_state *mrb, struct RClass *c)\n{\n  struct RProc *p;\n  mrb_method_t m;\n  mrb_sym mid;\n  mrb_value proc = mrb_undef_value();\n  mrb_value blk;\n\n  mrb_get_args(mrb, \"n|o&\", &mid, &proc, &blk);\n  switch (mrb_type(proc)) {\n    case MRB_TT_PROC:\n      blk = proc;\n      break;\n    case MRB_TT_UNDEF:\n      break;\n    default:\n      mrb_raisef(mrb, E_TYPE_ERROR, \"wrong argument type %T (expected Proc)\", proc);\n      break;\n  }\n  if (mrb_nil_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"no block given\");\n  }\n  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb->proc_class);\n  mrb_proc_copy(p, mrb_proc_ptr(blk));\n  p->flags |= MRB_PROC_STRICT;\n  MRB_METHOD_FROM_PROC(m, p);\n  mrb_define_method_raw(mrb, c, mid, m);\n  mrb_method_added(mrb, c, mid);\n  return mrb_symbol_value(mid);\n}",
        "output": "1",
        "idx": 6682
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr_storage *address, int mode)\n{\n\tint size, ct, err;\n\n\tif (m->msg_namelen) {\n\t\tif (mode == VERIFY_READ) {\n\t\t\tvoid __user *namep;\n\t\t\tnamep = (void __user __force *) m->msg_name;\n\t\t\terr = move_addr_to_kernel(namep, m->msg_namelen,\n\t\t\t\t\t\t  address);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tm->msg_name = address;\n\t} else {\n\t\tm->msg_name = NULL;\n\t}\n\n\tsize = m->msg_iovlen * sizeof(struct iovec);\n\tif (copy_from_user(iov, (void __user __force *) m->msg_iov, size))\n\t\treturn -EFAULT;\n\n\tm->msg_iov = iov;\n\terr = 0;\n\n\tfor (ct = 0; ct < m->msg_iovlen; ct++) {\n\t\tsize_t len = iov[ct].iov_len;\n\n\t\tif (len > INT_MAX - err) {\n\t\t\tlen = INT_MAX - err;\n\t\t\tiov[ct].iov_len = len;\n\t\t}\n\t\terr += len;\n\t}\n\n\treturn err;\n}",
        "output": "1",
        "idx": 2442
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "checked_xmalloc (size_t size)\n{\n    alloc_limit_assert (\"checked_xmalloc\", size);\n    return xmalloc (size);\n}",
        "output": "1",
        "idx": 6400
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "main (void)\n{\n  char *login;\n  int errors = 0;\n\n  login = getlogin ();\n  if (login == NULL)\n    puts (\"getlogin returned NULL, no further tests\");\n  else\n    {\n      char name[1024];\n      int ret;\n\n      printf (\"getlogin returned: `%s'\\n\", login);\n\n      ret = getlogin_r (name, sizeof (name));\n      if (ret == 0)\n\t{\n\t  printf (\"getlogin_r returned: `%s'\\n\", name);\n\t  if (strcmp (name, login) != 0)\n\t    {\n\t      puts (\"Error: getlogin and getlogin_r returned different names\");\n\t      ++errors;\n\t    }\n\t}\n      else\n\t{\n\t  printf (\"Error: getlogin_r returned: %d (%s)\\n\",\n\t\t  ret, strerror (ret));\n\t  ++errors;\n\t}\n    }\n\n  return errors != 0;\n}",
        "output": "0",
        "idx": 7
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret;\n\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\t__pipe_lock(pipe);\n\n\tswitch (cmd) {\n\tcase F_SETPIPE_SZ: {\n\t\tunsigned int size, nr_pages;\n\n\t\tsize = round_pipe_size(arg);\n\t\tnr_pages = size >> PAGE_SHIFT;\n\n\t\tret = -EINVAL;\n\t\tif (!nr_pages)\n\t\t\tgoto out;\n\n\t\tif (!capable(CAP_SYS_RESOURCE) && size > pipe_max_size) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t} else if ((too_many_pipe_buffers_hard(pipe->user) ||\n\t\t\t    too_many_pipe_buffers_soft(pipe->user)) &&\n\t\t           !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = pipe_set_size(pipe, nr_pages);\n\t\tbreak;\n\t\t}\n\tcase F_GETPIPE_SZ:\n\t\tret = pipe->buffers * PAGE_SIZE;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nout:\n\t__pipe_unlock(pipe);\n\treturn ret;\n}",
        "output": "0",
        "idx": 1565
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_lnums(int do_curwin)\n{\n    check_lnums_both(do_curwin, FALSE);\n}",
        "output": "0",
        "idx": 8107
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) {\n    MOBIIndexEntry e = indx->entries[i];\n    char *inflected = e.label;\n    for (size_t j = 0; j < e.tags_count; j++) {\n        MOBIIndexTag t = e.tags[j];\n        if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) {\n            for (size_t k = 0; k < t.tagvalues_count - 1; k += 2) {\n                uint32_t len = t.tagvalues[k];\n                uint32_t offset = t.tagvalues[k + 1];\n                char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len);\n                if (base == NULL) {\n                    return MOBI_MALLOC_FAILED;\n                }\n                MOBI_RET ret = mobi_trie_insert_reversed(root, base, inflected);\n                free(base);\n                if (ret != MOBI_SUCCESS) {\n                    return ret;\n                }\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}",
        "output": "1",
        "idx": 8756
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool is_exception(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_HARD_EXCEPTION | INTR_INFO_VALID_MASK);\n}",
        "output": "1",
        "idx": 1404
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API int r_socket_ready(RSocket *s, int secs, int usecs) {\n#if __UNIX__\n\tint msecs = (usecs / 1000);\n\tstruct pollfd fds[1];\n\tfds[0].fd = s->fd;\n\tfds[0].events = POLLIN | POLLPRI;\n\tfds[0].revents = POLLNVAL | POLLHUP | POLLERR;\n\treturn poll ((struct pollfd *)&fds, 1, msecs);\n#elif __WINDOWS__\n\tfd_set rfds;\n\tstruct timeval tv;\n\tif (s->fd == R_INVALID_SOCKET) {\n\t\treturn -1;\n\t}\n\tFD_ZERO (&rfds);\n\tFD_SET (s->fd, &rfds);\n\ttv.tv_sec = secs;\n\ttv.tv_usec = usecs;\n\treturn select (s->fd + 1, &rfds, NULL, NULL, &tv);\n#else\n\treturn true; \n#endif\n}",
        "output": "1",
        "idx": 6416
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void IGDstartelt(void * d, const char * name, int l)\n{\n\tstruct IGDdatas * datas = (struct IGDdatas *)d;\n\tmemcpy( datas->cureltname, name, l);\n\tdatas->cureltname[l] = '\\0';\n\tdatas->level++;\n\tif( (l==7) && !memcmp(name, \"service\", l) ) {\n\t\tdatas->tmp.controlurl[0] = '\\0';\n\t\tdatas->tmp.eventsuburl[0] = '\\0';\n\t\tdatas->tmp.scpdurl[0] = '\\0';\n\t\tdatas->tmp.servicetype[0] = '\\0';\n\t}\n}",
        "output": "1",
        "idx": 4572
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u32 __ipv6_select_ident(struct net *net,\n\t\t\t       const struct in6_addr *dst,\n\t\t\t       const struct in6_addr *src)\n{\n\tconst struct {\n\t\tstruct in6_addr dst;\n\t\tstruct in6_addr src;\n\t} __aligned(SIPHASH_ALIGNMENT) combined = {\n\t\t.dst = *dst,\n\t\t.src = *src,\n\t};\n\tu32 hash, id;\n\n\tif (unlikely(siphash_key_is_zero(&net->ipv4.ip_id_key)))\n\t\tget_random_bytes(&net->ipv4.ip_id_key,\n\t\t\t\t sizeof(net->ipv4.ip_id_key));\n\n\thash = siphash(&combined, sizeof(combined), &net->ipv4.ip_id_key);\n\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\n\treturn id;\n}",
        "output": "0",
        "idx": 4299
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_public_ int sd_bus_enqeue_for_read(sd_bus *bus, sd_bus_message *m) {\n        int r;\n\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(m, -EINVAL);\n        assert_return(m->sealed, -EINVAL);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n\n        if (!BUS_IS_OPEN(bus->state))\n                return -ENOTCONN;\n\n\n        r = bus_rqueue_make_room(bus);\n        if (r < 0)\n                return r;\n\n        bus->rqueue[bus->rqueue_size++] = bus_message_ref_queued(m, bus);\n        return 0;\n}",
        "output": "0",
        "idx": 7691
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t interprocess_token)\n{\n    OM_uint32 maj;\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;\n\n    if (!ctx->established)\n        return GSS_S_UNAVAILABLE;\n\n    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,\n                                      interprocess_token);\n    if (ctx->gssc == GSS_C_NO_CONTEXT) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n    return maj;\n}",
        "output": "0",
        "idx": 173
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char *parse_number(cJSON *item,const char *num)\n{\n\tdouble n=0,sign=1,scale=0;int subscale=0,signsubscale=1;\n\n\tif (*num=='-') sign=-1,num++;\t\n\tif (*num=='0') num++;\t\t\t\n\tif (*num>='1' && *num<='9')\tdo\tn=(n*10.0)+(*num++ -'0');\twhile (*num>='0' && *num<='9');\t\n\tif (*num=='.' && num[1]>='0' && num[1]<='9') {num++;\t\tdo\tn=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}\t\n\tif (*num=='e' || *num=='E')\t\t\n\t{\tnum++;if (*num=='+') num++;\telse if (*num=='-') signsubscale=-1,num++;\t\t\n\t\twhile (*num>='0' && *num<='9') subscale=(subscale*10)+(*num++ - '0');\t\n\t}\n\n\tn=sign*n*pow(10.0,(scale+subscale*signsubscale));\t\n\t\n\titem->valuedouble=n;\n\titem->valueint=(int64_t)n;\n\titem->type=cJSON_Number;\n\treturn num;\n}",
        "output": "0",
        "idx": 8243
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mpeg4_encode_gop_header(MpegEncContext *s)\n{\n    int hours, minutes, seconds;\n    int64_t time;\n\n    put_bits(&s->pb, 16, 0);\n    put_bits(&s->pb, 16, GOP_STARTCODE);\n\n    time = s->current_picture_ptr->f->pts;\n    if (s->reordered_input_picture[1])\n        time = FFMIN(time, s->reordered_input_picture[1]->f->pts);\n    time = time * s->avctx->time_base.num;\n    s->last_time_base = FFUDIV(time, s->avctx->time_base.den);\n\n    seconds = FFUDIV(time, s->avctx->time_base.den);\n    minutes = FFUDIV(seconds, 60); seconds = FFUMOD(seconds, 60);\n    hours   = FFUDIV(minutes, 60); minutes = FFUMOD(minutes, 60);\n    hours   = FFUMOD(hours  , 24);\n\n    put_bits(&s->pb, 5, hours);\n    put_bits(&s->pb, 6, minutes);\n    put_bits(&s->pb, 1, 1);\n    put_bits(&s->pb, 6, seconds);\n\n    put_bits(&s->pb, 1, !!(s->avctx->flags & AV_CODEC_FLAG_CLOSED_GOP));\n    put_bits(&s->pb, 1, 0);  \n\n    ff_mpeg4_stuffing(&s->pb);\n}",
        "output": "1",
        "idx": 3400
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sas_init_port(struct asd_sas_port *port,\n\t\t\t  struct sas_ha_struct *sas_ha, int i)\n{\n\tmemset(port, 0, sizeof(*port));\n\tport->id = i;\n\tINIT_LIST_HEAD(&port->dev_list);\n\tINIT_LIST_HEAD(&port->disco_list);\n\tINIT_LIST_HEAD(&port->destroy_list);\n\tINIT_LIST_HEAD(&port->sas_port_del_list);\n\tspin_lock_init(&port->phy_list_lock);\n\tINIT_LIST_HEAD(&port->phy_list);\n\tport->ha = sas_ha;\n\n\tspin_lock_init(&port->dev_list_lock);\n}",
        "output": "0",
        "idx": 2657
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_event_mmap_output(struct perf_event *event,\n\t\t\t\t     struct perf_mmap_event *mmap_event)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint size = mmap_event->event_id.header.size;\n\tint ret;\n\n\tperf_event_header__init_id(&mmap_event->event_id.header, &sample, event);\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tmmap_event->event_id.header.size, 0, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tmmap_event->event_id.pid = perf_event_pid(event, current);\n\tmmap_event->event_id.tid = perf_event_tid(event, current);\n\n\tperf_output_put(&handle, mmap_event->event_id);\n\t__output_copy(&handle, mmap_event->file_name,\n\t\t\t\t   mmap_event->file_size);\n\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\nout:\n\tmmap_event->event_id.header.size = size;\n}",
        "output": "1",
        "idx": 540
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\n\t\t\t\t\t\t struct btrfs_path *path,\n\t\t\t\t\t\t const char *name, int name_len)\n{\n\tstruct btrfs_dir_item *dir_item;\n\tunsigned long name_ptr;\n\tu32 total_len;\n\tu32 cur = 0;\n\tu32 this_len;\n\tstruct extent_buffer *leaf;\n\n\tleaf = path->nodes[0];\n\tdir_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dir_item);\n\tif (verify_dir_item(root, leaf, dir_item))\n\t\treturn NULL;\n\n\ttotal_len = btrfs_item_size_nr(leaf, path->slots[0]);\n\twhile (cur < total_len) {\n\t\tthis_len = sizeof(*dir_item) +\n\t\t\tbtrfs_dir_name_len(leaf, dir_item) +\n\t\t\tbtrfs_dir_data_len(leaf, dir_item);\n\t\tname_ptr = (unsigned long)(dir_item + 1);\n\n\t\tif (btrfs_dir_name_len(leaf, dir_item) == name_len &&\n\t\t    memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)\n\t\t\treturn dir_item;\n\n\t\tcur += this_len;\n\t\tdir_item = (struct btrfs_dir_item *)((char *)dir_item +\n\t\t\t\t\t\t     this_len);\n\t}\n\treturn NULL;\n}",
        "output": "0",
        "idx": 3757
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_SSL_check_common_name (X509 *cert, const char *host)\n{\n\tX509_NAME *name;\n\tchar *common_name = NULL;\n\tint common_name_len;\n\tint rv = -1;\n\tGInetAddress *addr;\n\n\tname = X509_get_subject_name (cert);\n\tif (name == NULL)\n\t\treturn -1;\n\n\tcommon_name_len = X509_NAME_get_text_by_NID (name, NID_commonName, NULL, 0);\n\tif (common_name_len < 0)\n\t\treturn -1;\n\n\tcommon_name = calloc (common_name_len + 1, 1);\n\tif (common_name == NULL)\n\t\treturn -1;\n\n\tX509_NAME_get_text_by_NID (name, NID_commonName, common_name, common_name_len + 1);\n\n\tif (common_name_len != (int)strlen(common_name))\n\t{\n\t\tg_warning (\"NUL byte in Common Name field, probably a malicious certificate.\\n\");\n\t\trv = -2;\n\t\tgoto out;\n\t}\n\n\tif ((addr = g_inet_address_new_from_string (host)) != NULL)\n\t{\n\t\tif (g_strcmp0 (common_name, host) == 0)\n\t\t\trv = 0;\n\t\telse\n\t\t\trv = -1;\n\n\t\tg_object_unref (addr);\n\t}\n\telse if (_SSL_match_hostname (common_name, host) == 0)\n\t\trv = 0;\n\nout:\n\tfree(common_name);\n\treturn rv;\n}",
        "output": "0",
        "idx": 6159
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int decode_zbuf(AVBPrint *bp, const uint8_t *data,\n                       const uint8_t *data_end)\n{\n    z_stream zstream;\n    unsigned char *buf;\n    unsigned buf_size;\n    int ret;\n\n    zstream.zalloc = ff_png_zalloc;\n    zstream.zfree  = ff_png_zfree;\n    zstream.opaque = NULL;\n    if (inflateInit(&zstream) != Z_OK)\n        return AVERROR_EXTERNAL;\n    zstream.next_in  = (unsigned char *)data;\n    zstream.avail_in = data_end - data;\n    av_bprint_init(bp, 0, -1);\n\n    while (zstream.avail_in > 0) {\n        av_bprint_get_buffer(bp, 1, &buf, &buf_size);\n        if (!buf_size) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n        zstream.next_out  = buf;\n        zstream.avail_out = buf_size;\n        ret = inflate(&zstream, Z_PARTIAL_FLUSH);\n        if (ret != Z_OK && ret != Z_STREAM_END) {\n            ret = AVERROR_EXTERNAL;\n            goto fail;\n        }\n        bp->len += zstream.next_out - buf;\n        if (ret == Z_STREAM_END)\n            break;\n    }\n    inflateEnd(&zstream);\n    bp->str[bp->len] = 0;\n    return 0;\n\nfail:\n    inflateEnd(&zstream);\n    av_bprint_finalize(bp, NULL);\n    return ret;\n}",
        "output": "1",
        "idx": 3468
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_pinfo *pi = sco_pi(sk);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECT2 &&\n\t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n\t\thci_conn_accept(pi->conn->hcon, 0);\n\t\tsk->sk_state = BT_CONFIG;\n\t\tmsg->msg_namelen = 0;\n\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\n\trelease_sock(sk);\n\n\treturn bt_sock_recvmsg(iocb, sock, msg, len, flags);\n}",
        "output": "0",
        "idx": 1275
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs4_open_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\tif (data->rpc_status != 0 || !data->rpc_done)\n\t\tgoto out_free;\n\tif (data->o_res.rflags & NFS4_OPEN_RESULT_CONFIRM)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.fmode);\nout_free:\n\tnfs4_opendata_put(data);\n}",
        "output": "0",
        "idx": 3035
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parse_field(netdissect_options *ndo, const char **pptr, int *len, int *truncated)\n{\n    const char *s;\n\n    s = *pptr;\n    for (;;) {\n\tif (*len == 0) {\n\t    return NULL;\n\t}\n\tif (!ND_TTEST(**pptr)) {\n\t    *truncated = 1;\n\t    return NULL;\n\t}\n\tif (**pptr == '\\0') {\n\t    break;\n\t}\n\t(*pptr)++;\n\t(*len)--;\n    }\n    (*pptr)++;\n    (*len)--;\n    return s;\n}",
        "output": "0",
        "idx": 6595
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Huff_offsetReceive (node_t *node, int *ch, byte *fin, int *offset, int maxoffset) {\n\tbloc = *offset;\n\twhile (node && node->symbol == INTERNAL_NODE) {\n\t\tif (bloc >= maxoffset) {\n\t\t\t*ch = 0;\n\t\t\t*offset = maxoffset + 1;\n\t\t\treturn;\n\t\t}\n\t\tif (get_bit(fin)) {\n\t\t\tnode = node->right;\n\t\t} else {\n\t\t\tnode = node->left;\n\t\t}\n\t}\n\tif (!node) {\n\t\t*ch = 0;\n\t\treturn;\n\t}\n\t*ch = node->symbol;\n\t*offset = bloc;\n}",
        "output": "0",
        "idx": 8747
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init pcd_init(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\n\tif (disable)\n\t\treturn -EINVAL;\n\n\tpcd_init_units();\n\n\tif (pcd_detect())\n\t\treturn -ENODEV;\n\n\tpcd_probe_capabilities();\n\n\tif (register_blkdev(major, name)) {\n\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\t\tif (!cd->disk)\n\t\t\t\tcontinue;\n\n\t\t\tblk_cleanup_queue(cd->disk->queue);\n\t\t\tblk_mq_free_tag_set(&cd->tag_set);\n\t\t\tput_disk(cd->disk);\n\t\t}\n\t\treturn -EBUSY;\n\t}\n\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (cd->present) {\n\t\t\tregister_cdrom(&cd->info);\n\t\t\tcd->disk->private_data = cd;\n\t\t\tadd_disk(cd->disk);\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 4319
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rose_start_hbtimer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tsk_stop_timer(sk, &rose->timer);\n\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->hb;\n\n\tsk_reset_timer(sk, &rose->timer, rose->timer.expires);\n}",
        "output": "0",
        "idx": 2969
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void resv_map_put(struct vm_area_struct *vma)\n{\n\tstruct resv_map *reservations = vma_resv_map(vma);\n\n\tif (!reservations)\n\t\treturn;\n\tkref_put(&reservations->refs, resv_map_release);\n}",
        "output": "0",
        "idx": 951
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static enum hrtimer_restart posix_timer_fn(struct hrtimer *timer)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\tint si_private = 0;\n\tenum hrtimer_restart ret = HRTIMER_NORESTART;\n\n\ttimr = container_of(timer, struct k_itimer, it.real.timer);\n\tspin_lock_irqsave(&timr->it_lock, flags);\n\n\ttimr->it_active = 0;\n\tif (timr->it_interval != 0)\n\t\tsi_private = ++timr->it_requeue_pending;\n\n\tif (posix_timer_event(timr, si_private)) {\n\t\tif (timr->it_interval != 0) {\n\t\t\tktime_t now = hrtimer_cb_get_time(timer);\n\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t\t\t{\n\t\t\t\tktime_t kj = NSEC_PER_SEC / HZ;\n\n\t\t\t\tif (timr->it_interval < kj)\n\t\t\t\t\tnow = ktime_add(now, kj);\n\t\t\t}\n#endif\n\t\t\ttimr->it_overrun += hrtimer_forward(timer, now,\n\t\t\t\t\t\t\t    timr->it_interval);\n\t\t\tret = HRTIMER_RESTART;\n\t\t\t++timr->it_requeue_pending;\n\t\t\ttimr->it_active = 1;\n\t\t}\n\t}\n\n\tunlock_timer(timr, flags);\n\treturn ret;\n}",
        "output": "0",
        "idx": 4125
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ext4_get_block_write(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tint ret = 0;\n\tunsigned max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tint dio_credits;\n\tint started = 0;\n\n\text4_debug(\"ext4_get_block_write: inode %lu, create flag %d\\n\",\n\t\t   inode->i_ino, create);\n\tcreate = EXT4_GET_BLOCKS_IO_CREATE_EXT;\n\n\tif (!handle) {\n\t\tif (max_blocks > DIO_MAX_BLOCKS)\n\t\t\tmax_blocks = DIO_MAX_BLOCKS;\n\t\tdio_credits = ext4_chunk_trans_blocks(inode, max_blocks);\n\t\thandle = ext4_journal_start(inode, dio_credits);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tgoto out;\n\t\t}\n\t\tstarted = 1;\n\t}\n\n\tret = ext4_get_blocks(handle, inode, iblock, max_blocks, bh_result,\n\t\t\t      create);\n\tif (ret > 0) {\n\t\tbh_result->b_size = (ret << inode->i_blkbits);\n\t\tret = 0;\n\t}\n\tif (started)\n\t\text4_journal_stop(handle);\nout:\n\treturn ret;\n}",
        "output": "0",
        "idx": 3163
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_devinfo_ioctl(struct comedi_device *dev,\n\t\t\t    struct comedi_devinfo __user *arg,\n\t\t\t    struct file *file)\n{\n\tstruct comedi_devinfo devinfo;\n\tconst unsigned minor = iminor(file->f_dentry->d_inode);\n\tstruct comedi_device_file_info *dev_file_info =\n\t    comedi_get_device_file_info(minor);\n\tstruct comedi_subdevice *read_subdev =\n\t    comedi_get_read_subdevice(dev_file_info);\n\tstruct comedi_subdevice *write_subdev =\n\t    comedi_get_write_subdevice(dev_file_info);\n\n\tmemset(&devinfo, 0, sizeof(devinfo));\n\n\tdevinfo.version_code = COMEDI_VERSION_CODE;\n\tdevinfo.n_subdevs = dev->n_subdevices;\n\tmemcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);\n\tmemcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);\n\n\tif (read_subdev)\n\t\tdevinfo.read_subdevice = read_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.read_subdevice = -1;\n\n\tif (write_subdev)\n\t\tdevinfo.write_subdevice = write_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.write_subdevice = -1;\n\n\tif (copy_to_user(arg, &devinfo, sizeof(struct comedi_devinfo)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 558
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileInfo, setFileClass)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_class_entry *ce = spl_ce_SplFileObject;\n\tzend_error_handling error_handling;\n\t\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n\t\tintern->file_class = ce;\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}",
        "output": "1",
        "idx": 3974
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "asmlinkage long compat_sys_ptrace(compat_long_t request, compat_long_t pid,\n\t\t\t\t  compat_long_t addr, compat_long_t data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tgoto out;\n\t}\n\n\tchild = ptrace_get_task_struct(pid);\n\tif (IS_ERR(child)) {\n\t\tret = PTR_ERR(child);\n\t\tgoto out;\n\t}\n\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(child);\n\t\tgoto out_put_task_struct;\n\t}\n\n\tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n\t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (!ret) {\n\t\tret = compat_arch_ptrace(child, request, addr, data);\n\t\tif (ret || request != PTRACE_DETACH)\n\t\t\tptrace_unfreeze_traced(child);\n\t}\n\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}",
        "output": "0",
        "idx": 1127
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool unconditional(const struct arpt_arp *arp)\n{\n\tstatic const struct arpt_arp uncond;\n\n\treturn memcmp(arp, &uncond, sizeof(uncond)) == 0;\n}",
        "output": "1",
        "idx": 1184
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "obj2ast_keyword(PyObject* obj, keyword_ty* out, PyArena* arena)\n{\n    PyObject* tmp = NULL;\n    identifier arg;\n    expr_ty value;\n\n    if (exists_not_none(obj, &PyId_arg)) {\n        int res;\n        tmp = _PyObject_GetAttrId(obj, &PyId_arg);\n        if (tmp == NULL) goto failed;\n        res = obj2ast_identifier(tmp, &arg, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    } else {\n        arg = NULL;\n    }\n    if (_PyObject_HasAttrId(obj, &PyId_value)) {\n        int res;\n        tmp = _PyObject_GetAttrId(obj, &PyId_value);\n        if (tmp == NULL) goto failed;\n        res = obj2ast_expr(tmp, &value, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    } else {\n        PyErr_SetString(PyExc_TypeError, \"required field \\\"value\\\" missing from keyword\");\n        return 1;\n    }\n    *out = keyword(arg, value, arena);\n    return 0;\nfailed:\n    Py_XDECREF(tmp);\n    return 1;\n}",
        "output": "1",
        "idx": 7696
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int retrieve_ptr_limit(const struct bpf_reg_state *ptr_reg,\n\t\t\t      u32 *ptr_limit, u8 opcode, bool off_is_neg)\n{\n\tbool mask_to_left = (opcode == BPF_ADD &&  off_is_neg) ||\n\t\t\t    (opcode == BPF_SUB && !off_is_neg);\n\tu32 off;\n\n\tswitch (ptr_reg->type) {\n\tcase PTR_TO_STACK:\n\t\toff = ptr_reg->off + ptr_reg->var_off.value;\n\t\tif (mask_to_left)\n\t\t\t*ptr_limit = MAX_BPF_STACK + off;\n\t\telse\n\t\t\t*ptr_limit = -off;\n\t\treturn 0;\n\tcase PTR_TO_MAP_VALUE:\n\t\tif (mask_to_left) {\n\t\t\t*ptr_limit = ptr_reg->umax_value + ptr_reg->off;\n\t\t} else {\n\t\t\toff = ptr_reg->smin_value + ptr_reg->off;\n\t\t\t*ptr_limit = ptr_reg->map_ptr->value_size - off;\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
        "output": "0",
        "idx": 4213
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sgi_clock_get(clockid_t clockid, struct timespec *tp)\n{\n\tu64 nsec;\n\n\tnsec = rtc_time() * sgi_clock_period\n\t\t\t+ sgi_clock_offset.tv_nsec;\n\t*tp = ns_to_timespec(nsec);\n\ttp->tv_sec += sgi_clock_offset.tv_sec;\n\treturn 0;\n};",
        "output": "0",
        "idx": 3001
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteIntArray* TfLiteIntArrayCreate(int size) {\n  int alloc_size = TfLiteIntArrayGetSizeInBytes(size);\n  if (alloc_size <= 0) return NULL;\n  TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size);\n  if (!ret) return ret;\n  ret->size = size;\n  return ret;\n}",
        "output": "1",
        "idx": 7238
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mark_object(struct object *obj, struct strbuf *path,\n\t\t\tconst char *name, void *data)\n{\n\tupdate_progress(data);\n}",
        "output": "1",
        "idx": 5206
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jas_iccprof_t *jas_iccprof_createfrombuf(jas_uchar *buf, int len)\n{\n\tjas_stream_t *in;\n\tjas_iccprof_t *prof;\n\tif (!(in = jas_stream_memopen(JAS_CAST(char *, buf), len)))\n\t\tgoto error;\n\tif (!(prof = jas_iccprof_load(in)))\n\t\tgoto error;\n\tjas_stream_close(in);\n\treturn prof;\nerror:\n\tif (in)\n\t\tjas_stream_close(in);\n\treturn 0;\n}",
        "output": "0",
        "idx": 7557
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_proxy_auth_type_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_authentype2str,\n\t\t\t     \"AuthType-#%u\", EXTRACT_16BITS(ptr))));\n}",
        "output": "1",
        "idx": 4750
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p,\n                                  int *got_frame, uint8_t *data_start,\n                                  unsigned int data_size)\n{\n    WebPContext *s = avctx->priv_data;\n    AVPacket pkt;\n    int ret;\n\n    if (!s->initialized) {\n        ff_vp8_decode_init(avctx);\n        s->initialized = 1;\n        if (s->has_alpha)\n            avctx->pix_fmt = AV_PIX_FMT_YUVA420P;\n    }\n    s->lossless = 0;\n\n    if (data_size > INT_MAX) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported chunk size\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    av_init_packet(&pkt);\n    pkt.data = data_start;\n    pkt.size = data_size;\n\n    ret = ff_vp8_decode_frame(avctx, p, got_frame, &pkt);\n    if (ret < 0)\n        return ret;\n\n    update_canvas_size(avctx, avctx->width, avctx->height);\n\n    if (s->has_alpha) {\n        ret = vp8_lossy_decode_alpha(avctx, p, s->alpha_data,\n                                     s->alpha_data_size);\n        if (ret < 0)\n            return ret;\n    }\n    return ret;\n}",
        "output": "1",
        "idx": 3482
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __scm_destroy(struct scm_cookie *scm)\n{\n\tstruct scm_fp_list *fpl = scm->fp;\n\tint i;\n\n\tif (fpl) {\n\t\tscm->fp = NULL;\n\t\tfor (i=fpl->count-1; i>=0; i--)\n\t\t\tfput(fpl->fp[i]);\n\t\tfree_uid(fpl->user);\n\t\tkfree(fpl);\n\t}\n}",
        "output": "0",
        "idx": 1581
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg)\n{\n\tstruct usbdevfs_connectinfo ci = {\n\t\t.devnum = ps->dev->devnum,\n\t\t.slow = ps->dev->speed == USB_SPEED_LOW\n\t};\n\n\tif (copy_to_user(arg, &ci, sizeof(ci)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
        "output": "1",
        "idx": 1254
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int xrstor_state_booting(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\n\tWARN_ON(system_state != SYSTEM_BOOTING);\n\n\tif (boot_cpu_has(X86_FEATURE_XSAVES))\n\t\tasm volatile(\"1:\"XRSTORS\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t     xstate_fault\n\t\t\t: \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\telse\n\t\tasm volatile(\"1:\"XRSTOR\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t     xstate_fault\n\t\t\t: \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\treturn err;\n}",
        "output": "0",
        "idx": 3875
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int my_redel(const char *org_name, const char *tmp_name, myf MyFlags)\n{\n  int error=1;\n  DBUG_ENTER(\"my_redel\");\n  DBUG_PRINT(\"my\",(\"org_name: '%s' tmp_name: '%s'  MyFlags: %d\",\n\t\t   org_name,tmp_name,MyFlags));\n\n  if (!(MyFlags & MY_REDEL_NO_COPY_STAT))\n  {\n    if (my_copystat(org_name,tmp_name,MyFlags) < 0)\n      goto end;\n  }\n  if (MyFlags & MY_REDEL_MAKE_BACKUP)\n  {\n    char name_buff[FN_REFLEN+20];    \n    char ext[20];\n    ext[0]='-';\n    get_date(ext+1,2+4,(time_t) 0);\n    strmov(strend(ext),REDEL_EXT);\n    if (my_rename(org_name, fn_format(name_buff, org_name, \"\", ext, 2),\n\t\t  MyFlags))\n      goto end;\n  }\n  else if (my_delete_allow_opened(org_name, MyFlags))\n      goto end;\n  if (my_rename(tmp_name,org_name,MyFlags))\n    goto end;\n\n  error=0;\nend:\n  DBUG_RETURN(error);\n} ",
        "output": "0",
        "idx": 7353
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmalloc (size_t size)\n{\n    void *ptr = malloc (size);\n    if (!ptr \n        && (size != 0))         \n    {\n        perror (\"xmalloc: Memory allocation failure\");\n        abort();\n    }\n    return ptr;\n}",
        "output": "1",
        "idx": 6396
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)\n{\n\tif (mm->context.asce_limit == (1UL << 31))\n\t\tpgtable_pmd_page_dtor(virt_to_page(pgd));\n\tcrst_table_free(mm, (unsigned long *) pgd);\n}",
        "output": "0",
        "idx": 1681
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BOOL nsc_rle_decode(BYTE* in, BYTE* out, UINT32 outSize, UINT32 originalSize)\n{\n\tUINT32 len;\n\tUINT32 left;\n\tBYTE value;\n\tleft = originalSize;\n\n\twhile (left > 4)\n\t{\n\t\tvalue = *in++;\n\n\t\tif (left == 5)\n\t\t{\n\t\t\tif (outSize < 1)\n\t\t\t\treturn FALSE;\n\n\t\t\toutSize--;\n\t\t\t*out++ = value;\n\t\t\tleft--;\n\t\t}\n\t\telse if (value == *in)\n\t\t{\n\t\t\tin++;\n\n\t\t\tif (*in < 0xFF)\n\t\t\t{\n\t\t\t\tlen = (UINT32) * in++;\n\t\t\t\tlen += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tin++;\n\t\t\t\tlen = *((UINT32*) in);\n\t\t\t\tin += 4;\n\t\t\t}\n\n\t\t\tif (outSize < len)\n\t\t\t\treturn FALSE;\n\n\t\t\toutSize -= len;\n\t\t\tFillMemory(out, len, value);\n\t\t\tout += len;\n\t\t\tleft -= len;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (outSize < 1)\n\t\t\t\treturn FALSE;\n\n\t\t\toutSize--;\n\t\t\t*out++ = value;\n\t\t\tleft--;\n\t\t}\n\t}\n\n\tif ((outSize < 4) || (left < 4))\n\t\treturn FALSE;\n\n\tmemcpy(out, in, 4);\n\treturn TRUE;\n}",
        "output": "0",
        "idx": 5815
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BOOL nsc_rle_decompress_data(NSC_CONTEXT* context)\n{\n\tUINT16 i;\n\tBYTE* rle;\n\tUINT32 planeSize;\n\tUINT32 originalSize;\n\n\tif (!context)\n\t\treturn FALSE;\n\n\trle = context->Planes;\n\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\toriginalSize = context->OrgByteCount[i];\n\t\tplaneSize = context->PlaneByteCount[i];\n\n\t\tif (planeSize == 0)\n\t\t{\n\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n\t\t\t\treturn FALSE;\n\n\t\t\tFillMemory(context->priv->PlaneBuffers[i], originalSize, 0xFF);\n\t\t}\n\t\telse if (planeSize < originalSize)\n\t\t{\n\t\t\tif (!nsc_rle_decode(rle, context->priv->PlaneBuffers[i], context->priv->PlaneBuffersLength,\n\t\t\t                    originalSize))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n\t\t\t\treturn FALSE;\n\n\t\t\tCopyMemory(context->priv->PlaneBuffers[i], rle, originalSize);\n\t\t}\n\n\t\trle += planeSize;\n\t}\n\n\treturn TRUE;\n}",
        "output": "0",
        "idx": 5819
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC int mprWriteJsonObj(MprJson *obj, cchar *key, MprJson *value)\n{\n    if (setProperty(obj, sclone(key), value) == 0) {\n        return MPR_ERR_CANT_WRITE;\n    }\n    return 0;\n}",
        "output": "0",
        "idx": 7083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ion_free(struct ion_client *client, struct ion_handle *handle)\n{\n\tbool valid_handle;\n\n\tBUG_ON(client != handle->client);\n\n\tmutex_lock(&client->lock);\n\tvalid_handle = ion_handle_validate(client, handle);\n\n\tif (!valid_handle) {\n\t\tWARN(1, \"%s: invalid handle passed to free.\\n\", __func__);\n\t\tmutex_unlock(&client->lock);\n\t\treturn;\n\t}\n\tmutex_unlock(&client->lock);\n\tion_handle_put(handle);\n}",
        "output": "1",
        "idx": 1150
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hashtable_do_del(hashtable_t *hashtable,\n                            const char *key, size_t hash)\n{\n    pair_t *pair;\n    bucket_t *bucket;\n    size_t index;\n\n    index = hash & hashmask(hashtable->order);\n    bucket = &hashtable->buckets[index];\n\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return -1;\n\n    if(&pair->list == bucket->first && &pair->list == bucket->last)\n        bucket->first = bucket->last = &hashtable->list;\n\n    else if(&pair->list == bucket->first)\n        bucket->first = pair->list.next;\n\n    else if(&pair->list == bucket->last)\n        bucket->last = pair->list.prev;\n\n    list_remove(&pair->list);\n    json_decref(pair->value);\n\n    jsonp_free(pair);\n    hashtable->size--;\n\n    return 0;\n}",
        "output": "0",
        "idx": 5969
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void show_object(struct object *object, const char *name, void *data)\n{\n\tstruct bitmap *base = data;\n\tint bitmap_pos;\n\n\tbitmap_pos = bitmap_position(object->oid.hash);\n\n\tif (bitmap_pos < 0)\n\t\tbitmap_pos = ext_index_add_object(object, name);\n\n\tbitmap_set(base, bitmap_pos);\n}",
        "output": "0",
        "idx": 7237
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_PyMemoTable_Lookup(PyMemoTable *self, PyObject *key)\n{\n    size_t i;\n    size_t perturb;\n    size_t mask = (size_t)self->mt_mask;\n    PyMemoEntry *table = self->mt_table;\n    PyMemoEntry *entry;\n    Py_hash_t hash = (Py_hash_t)key >> 3;\n\n    i = hash & mask;\n    entry = &table[i];\n    if (entry->me_key == NULL || entry->me_key == key)\n        return entry;\n\n    for (perturb = hash; ; perturb >>= PERTURB_SHIFT) {\n        i = (i << 2) + i + perturb + 1;\n        entry = &table[i & mask];\n        if (entry->me_key == NULL || entry->me_key == key)\n            return entry;\n    }\n    Py_UNREACHABLE();\n}",
        "output": "1",
        "idx": 7146
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "smbhash(unsigned char *out, const unsigned char *in, unsigned char *key)\n{\n\tunsigned char key2[8];\n\tstruct crypto_cipher *tfm_des;\n\n\tstr_to_key(key, key2);\n\n\ttfm_des = crypto_alloc_cipher(\"des\", 0, 0);\n\tif (IS_ERR(tfm_des)) {\n\t\tcifs_dbg(VFS, \"could not allocate des crypto API\\n\");\n\t\treturn PTR_ERR(tfm_des);\n\t}\n\n\tcrypto_cipher_setkey(tfm_des, key2, 8);\n\tcrypto_cipher_encrypt_one(tfm_des, out, in);\n\tcrypto_free_cipher(tfm_des);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2049
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void smp_task_done(struct sas_task *task)\n{\n\tdel_timer(&task->slow_task->timer);\n\tcomplete(&task->slow_task->completion);\n}",
        "output": "0",
        "idx": 4153
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t aio_setup_vectored_rw(int type, struct kiocb *kiocb, bool compat)\n{\n\tssize_t ret;\n\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\tret = compat_rw_copy_check_uvector(type,\n\t\t\t\t(struct compat_iovec __user *)kiocb->ki_buf,\n\t\t\t\tkiocb->ki_nbytes, 1, &kiocb->ki_inline_vec,\n\t\t\t\t&kiocb->ki_iovec, 1);\n\telse\n#endif\n\t\tret = rw_copy_check_uvector(type,\n\t\t\t\t(struct iovec __user *)kiocb->ki_buf,\n\t\t\t\tkiocb->ki_nbytes, 1, &kiocb->ki_inline_vec,\n\t\t\t\t&kiocb->ki_iovec, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = rw_verify_area(type, kiocb->ki_filp, &kiocb->ki_pos, ret);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tkiocb->ki_nr_segs = kiocb->ki_nbytes;\n\tkiocb->ki_cur_seg = 0;\n\tkiocb->ki_nbytes = ret;\n\tkiocb->ki_left = ret;\n\n\tret = 0;\nout:\n\treturn ret;\n}",
        "output": "0",
        "idx": 945
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_output_wakeup(struct perf_output_handle *handle)\n{\n\tatomic_set(&handle->rb->poll, POLL_IN);\n\n\tif (handle->nmi) {\n\t\thandle->event->pending_wakeup = 1;\n\t\tirq_work_queue(&handle->event->pending);\n\t} else\n\t\tperf_event_wakeup(handle->event);\n}",
        "output": "1",
        "idx": 550
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "snmp_ber_encode_length(unsigned char *out, uint32_t *out_len, uint8_t length)\n{\n  *out-- = length;\n  (*out_len)++;\n  return out;\n}",
        "output": "1",
        "idx": 7960
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rds_loop_xmit(struct rds_connection *conn, struct rds_message *rm,\n\t\t\t unsigned int hdr_off, unsigned int sg,\n\t\t\t unsigned int off)\n{\n\tstruct scatterlist *sgp = &rm->data.op_sg[sg];\n\tint ret = sizeof(struct rds_header) +\n\t\t\tbe32_to_cpu(rm->m_inc.i_hdr.h_len);\n\n\tif (rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\tret = min_t(int, ret, sgp->length - conn->c_xmit_data_off);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(hdr_off || sg || off);\n\n\trds_inc_init(&rm->m_inc, conn, conn->c_laddr);\n\trds_message_addref(rm);\n\n\trds_recv_incoming(conn, conn->c_laddr, conn->c_faddr, &rm->m_inc,\n\t\t\t  GFP_KERNEL, KM_USER0);\n\n\trds_send_drop_acked(conn, be64_to_cpu(rm->m_inc.i_hdr.h_sequence),\n\t\t\t    NULL);\n\n\trds_inc_put(&rm->m_inc);\nout:\n\treturn ret;\n}",
        "output": "0",
        "idx": 371
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void commit_tree(struct mount *mnt, struct mount *shadows)\n{\n\tstruct mount *parent = mnt->mnt_parent;\n\tstruct mount *m;\n\tLIST_HEAD(head);\n\tstruct mnt_namespace *n = parent->mnt_ns;\n\n\tBUG_ON(parent == mnt);\n\n\tlist_add_tail(&head, &mnt->mnt_list);\n\tlist_for_each_entry(m, &head, mnt_list)\n\t\tm->mnt_ns = n;\n\n\tlist_splice(&head, n->list.prev);\n\n\tn->mounts += n->pending_mounts;\n\tn->pending_mounts = 0;\n\n\tattach_shadowed(mnt, parent, shadows);\n\ttouch_mnt_namespace(n);\n}",
        "output": "0",
        "idx": 1967
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_openat(const char *path)\n{\n\tchar *d = strdupa(path), *f, *tmpname;\n\tint fd, fd2;\n\tf = basename(d);\n\td = dirname(d);\n\tfd = open(d, O_RDONLY);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error in openat test: could not open parent dir\\n\");\n\t\tfprintf(stderr, \"(this is expected on the second run)\\n\");\n\t\treturn;\n\t}\n\tfd2 = openat(fd, f, O_RDONLY);\n\tif (fd2 >= 0 || errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at openat of %s\\n\", f);\n\t\texit(1);\n\t}\n\tsize_t len = strlen(path) + strlen(\"/cgroup.procs\") + 1;\n\ttmpname = alloca(len);\n\tsnprintf(tmpname, len, \"%s/cgroup.procs\", f);\n\tfd2 = openat(fd, tmpname, O_RDONLY);\n\tif (fd2 >= 0 || errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at openat of %s\\n\", tmpname);\n\t\texit(1);\n\t}\n\tclose(fd);\n}",
        "output": "0",
        "idx": 7293
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline unsigned char unimap_bsearch(const uni_to_enc *table, unsigned code_key_a, size_t num)\n{\n\tconst uni_to_enc *l = table,\n\t\t\t\t\t *h = &table[num-1],\n\t\t\t\t\t *m;\n\tunsigned short code_key;\n\n\tif (code_key_a > 0xFFFFU)\n\t\treturn 0;\n\n\tcode_key = (unsigned short) code_key_a;\n\t\n\twhile (l <= h) {\n\t\tm = l + (h - l) / 2;\n\t\tif (code_key < m->un_code_point)\n\t\t\th = m - 1;\n\t\telse if (code_key > m->un_code_point)\n\t\t\tl = m + 1;\n\t\telse\n\t\t\treturn m->cs_code;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 3844
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_NAMED_FUNCTION(zif_locale_set_default)\n{\n\tchar* locale_name = NULL;\n\tint   len=0;\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  \"s\",\n\t\t&locale_name ,&len ) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \t\"locale_set_default: unable to parse input params\", 0 TSRMLS_CC );\n\n\t\tRETURN_FALSE;\n\t}\n\n\tif(len == 0) {\n\t\tlocale_name =  (char *)uloc_getDefault() ;\n\t\tlen = strlen(locale_name);\n\t}\n\n\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\n\n\tRETURN_TRUE;\n}",
        "output": "0",
        "idx": 5403
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void editPackageValue(int argc, char **argv)\n{\n    cchar   *key, *value;\n    int     i;\n\n    if (argc < 1) {\n        usageError();\n        return;\n    }\n    for (i = 0; i < argc; i++) {\n        key = ssplit(sclone(argv[i]), \"=\", (char**) &value);\n        if (value) {\n            setPackageKey(key, value);\n        } else {\n            value = getConfigValue(key, 0);\n            if (value) { \n                printf(\"%s\\n\", value);\n            } else {\n                printf(\"undefined\\n\");\n            }\n        }\n    }\n}",
        "output": "0",
        "idx": 6957
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mp_pack(lua_State *L) {\n    int nargs = lua_gettop(L);\n    int i;\n    mp_buf *buf;\n\n    if (nargs == 0)\n        return luaL_argerror(L, 0, \"MessagePack pack needs input.\");\n\n    if (!lua_checkstack(L, nargs))\n        return luaL_argerror(L, 0, \"Too many arguments for MessagePack pack.\");\n\n    buf = mp_buf_new(L);\n    for(i = 1; i <= nargs; i++) {\n        lua_pushvalue(L, i);\n\n        mp_encode_lua_type(L,buf,0);\n\n        lua_pushlstring(L,(char*)buf->b,buf->len);\n\n        buf->free += buf->len;\n        buf->len = 0;\n    }\n    mp_buf_free(L, buf);\n\n    lua_concat(L, nargs);\n    return 1;\n}",
        "output": "0",
        "idx": 5093
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_bearer_type_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_TYPE_ANALOG_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_TYPE_DIGITAL_MASK) {\n\t\tND_PRINT((ndo, \"D\"));\n\t}\n}",
        "output": "0",
        "idx": 6667
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Jsi_RC jsi_ArrayFlatSub(Jsi_Interp *interp, Jsi_Obj* nobj, Jsi_Value *arr, int depth) {\n    \n    int i, n = 0, len = Jsi_ObjGetLength(interp, arr->d.obj);\n    if (len <= 0) return JSI_OK;\n    Jsi_RC rc = JSI_OK;\n    int clen = Jsi_ObjGetLength(interp, nobj);\n    for (i = 0; i < len && rc == JSI_OK; i++) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, arr, i);\n        if (t && depth>0 && Jsi_ValueIsArray(interp, t))\n            rc = jsi_ArrayFlatSub(interp, nobj, t , depth-1);\n        else if (!Jsi_ValueIsUndef(interp, t))\n            Jsi_ObjArrayAdd(interp, nobj, t);\n        if ((++n + clen)>interp->maxArrayList)\n            return Jsi_LogError(\"array size exceeded\");\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 8148
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int snmp_version(void *context, size_t hdrlen, unsigned char tag,\n\t\t const void *data, size_t datalen)\n{\n\tif (datalen != 1)\n\t\treturn -EINVAL;\n\tif (*(unsigned char *)data > 1)\n\t\treturn -ENOTSUPP;\n\treturn 1;\n}",
        "output": "0",
        "idx": 4243
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "create_vterm(term_T *term, int rows, int cols)\n{\n    VTerm\t    *vterm;\n    VTermScreen\t    *screen;\n    VTermState\t    *state;\n    VTermValue\t    value;\n\n    vterm = vterm_new_with_allocator(rows, cols, &vterm_allocator, NULL);\n    term->tl_vterm = vterm;\n    screen = vterm_obtain_screen(vterm);\n    vterm_screen_set_callbacks(screen, &screen_callbacks, term);\n    vterm_set_utf8(vterm, 1);\n\n    init_default_colors(term);\n\n    vterm_state_set_default_colors(\n\t    vterm_obtain_state(vterm),\n\t    &term->tl_default_color.fg,\n\t    &term->tl_default_color.bg);\n\n    if (t_colors >= 16)\n\tvterm_state_set_bold_highbright(vterm_obtain_state(vterm), 1);\n\n    vterm_screen_reset(screen, 1 );\n\n    vterm_screen_enable_altscreen(screen, 1);\n\n#ifdef WIN3264\n    if (GetCaretBlinkTime() == INFINITE)\n\tvalue.boolean = 0;\n    else\n\tvalue.boolean = 1;\n#else\n    value.boolean = 0;\n#endif\n    state = vterm_obtain_state(vterm);\n    vterm_state_set_termprop(state, VTERM_PROP_CURSORBLINK, &value);\n    vterm_state_set_unrecognised_fallbacks(state, &parser_fallbacks, term);\n}",
        "output": "1",
        "idx": 5840
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mono_gc_reference_queue_add (MonoReferenceQueue *queue, MonoObject *obj, void *user_data)\n{\n\tRefQueueEntry *head;\n\tRefQueueEntry *entry;\n\tif (queue->should_be_deleted)\n\t\treturn FALSE;\n\n\tentry = g_new0 (RefQueueEntry, 1);\n\tentry->user_data = user_data;\n\tmono_gc_weak_link_add (&entry->dis_link, obj, TRUE);\n\tref_list_push (&queue->queue, entry);\n\treturn TRUE;\n}",
        "output": "0",
        "idx": 4707
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void usb_serial_console_disconnect(struct usb_serial *serial)\n{\n\tif (serial->port[0] && serial->port[0] == usbcons_info.port) {\n\t\tusb_serial_console_exit();\n\t\tusb_serial_put(serial);\n\t}\n}",
        "output": "0",
        "idx": 2447
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "zend_function *spl_filesystem_object_get_method_check(zval **object_ptr, char *method, int method_len, const struct _zend_literal *key TSRMLS_DC) \n{\n\tspl_filesystem_object *fsobj = zend_object_store_get_object(*object_ptr TSRMLS_CC);\n\n\tif (fsobj->u.dir.entry.d_name[0] == '\\0' && fsobj->orig_path == NULL) {\n\t\tmethod = \"_bad_state_ex\";\n\t\tmethod_len = sizeof(\"_bad_state_ex\") - 1;\n\t\tkey = NULL;\n\t}\n\n\treturn zend_get_std_object_handlers()->get_method(object_ptr, method, method_len, key TSRMLS_CC);\n}",
        "output": "0",
        "idx": 5483
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool caller_is_in_ancestor(pid_t pid, const char *contrl, const char *cg, char **nextcg)\n{\n\tbool answer = false;\n\tchar *c2 = get_pid_cgroup(pid, contrl);\n\tchar *linecmp;\n\n\tif (!c2)\n\t\treturn false;\n\tprune_init_slice(c2);\n\n\tlinecmp = *cg == '/' ? c2 : c2+1;\n\tif (strncmp(linecmp, cg, strlen(linecmp)) != 0) {\n\t\tif (nextcg) {\n\t\t\t*nextcg = get_next_cgroup_dir(linecmp, cg);\n\t\t}\n\t\tgoto out;\n\t}\n\tanswer = true;\n\nout:\n\tfree(c2);\n\treturn answer;\n}",
        "output": "0",
        "idx": 7259
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int DefragMfIpv4Test(void)\n{\n    int retval = 0;\n    int ip_id = 9;\n    Packet *p = NULL;\n\n    DefragInit();\n\n    Packet *p1 = BuildTestPacket(ip_id, 2, 1, 'C', 8);\n    Packet *p2 = BuildTestPacket(ip_id, 0, 1, 'A', 8);\n    Packet *p3 = BuildTestPacket(ip_id, 1, 0, 'B', 8);\n    if (p1 == NULL || p2 == NULL || p3 == NULL) {\n        goto end;\n    }\n\n    p = Defrag(NULL, NULL, p1, NULL);\n    if (p != NULL) {\n        goto end;\n    }\n\n    p = Defrag(NULL, NULL, p2, NULL);\n    if (p != NULL) {\n        goto end;\n    }\n\n    p = Defrag(NULL, NULL, p3, NULL);\n    if (p == NULL) {\n        goto end;\n    }\n\n    if (IPV4_GET_IPLEN(p) != 36) {\n        goto end;\n    }\n\n    retval = 1;\nend:\n    if (p1 != NULL) {\n        SCFree(p1);\n    }\n    if (p2 != NULL) {\n        SCFree(p2);\n    }\n    if (p3 != NULL) {\n        SCFree(p3);\n    }\n    if (p != NULL) {\n        SCFree(p);\n    }\n    DefragDestroy();\n    return retval;\n}",
        "output": "1",
        "idx": 6594
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "zend_object_iterator *spl_filesystem_tree_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator;\n\tspl_filesystem_object *dir_object;\n\n\tif (by_ref) {\n\t\tzend_error(E_ERROR, \"An iterator cannot be used with foreach by reference\");\n\t}\n\tdir_object = (spl_filesystem_object*)zend_object_store_get_object(object TSRMLS_CC);\n\titerator   = spl_filesystem_object_to_iterator(dir_object);\n\n\tif (iterator->intern.data == NULL) {\n\t\titerator->intern.data = object;\n\t\titerator->intern.funcs = &spl_filesystem_tree_it_funcs;\n\t}\n\tzval_add_ref(&object);\n\t\n\treturn (zend_object_iterator*)iterator;\n}",
        "output": "1",
        "idx": 4020
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int set_default_flags(int *flags)\n{\n  if (((*flags) & IDN2_TRANSITIONAL) && ((*flags) & IDN2_NONTRANSITIONAL))\n    return IDN2_INVALID_FLAGS;\n\n  if (((*flags) & (IDN2_TRANSITIONAL|IDN2_NONTRANSITIONAL)) && ((*flags) & IDN2_NO_TR46))\n    return IDN2_INVALID_FLAGS;\n\n  if (((*flags) & IDN2_ALABEL_ROUNDTRIP) && ((*flags) & IDN2_NO_ALABEL_ROUNDTRIP))\n    return IDN2_INVALID_FLAGS;\n\n  if (!((*flags) & (IDN2_NO_TR46|IDN2_TRANSITIONAL)))\n    *flags |= IDN2_NONTRANSITIONAL;\n\n  return IDN2_OK;\n}",
        "output": "0",
        "idx": 8793
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int64 asNumber(cchar *version)\n{\n    char    *tok;\n    int64   major, minor, patch;\n\n    major = stoi(ssplit(sclone(version), \".\", &tok));\n    minor = stoi(ssplit(tok, \".\", &tok));\n    patch = stoi(ssplit(tok, \".\", &tok));\n    return (((major * VER_FACTOR) + minor) * VER_FACTOR) + patch;\n}",
        "output": "0",
        "idx": 6965
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (unlikely(atomic_read(&modifying_ftrace_code)) &&\n\t    ftrace_int3_handler(regs))\n\t\treturn;\n#endif\n\tif (poke_int3_handler(regs))\n\t\treturn;\n\n\tist_enter(regs);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n#ifdef CONFIG_KGDB_LOW_LEVEL_TRAP\n\tif (kgdb_ll_trap(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n#endif \n\n#ifdef CONFIG_KPROBES\n\tif (kprobe_int3_handler(regs))\n\t\tgoto exit;\n#endif\n\n\tif (notify_die(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n\n\tcond_local_irq_enable(regs);\n\tdo_trap(X86_TRAP_BP, SIGTRAP, \"int3\", regs, error_code, NULL);\n\tcond_local_irq_disable(regs);\n\nexit:\n\tist_exit(regs);\n}",
        "output": "0",
        "idx": 4061
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "socket_accept(const int sock)\n{\n        struct sockaddr_storage addrin;\n        socklen_t addrinlen = sizeof(addrin);\n        int net;\n\n        net = accept(sock, (struct sockaddr *) &addrin, &addrinlen);\n        if (net < 0) {\n                err_nonfatal(\"Failed to accept socket connection: %m\");\n        }\n\n        return net;\n}",
        "output": "0",
        "idx": 4719
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ZydisFormatterBufferInit(ZydisFormatterBuffer* buffer, char* user_buffer,\n    ZyanUSize length)\n{\n    ZYAN_ASSERT(buffer);\n    ZYAN_ASSERT(user_buffer);\n    ZYAN_ASSERT(length);\n\n    buffer->is_token_list              = ZYAN_FALSE;\n    buffer->string.flags               = ZYAN_STRING_HAS_FIXED_CAPACITY;\n    buffer->string.vector.allocator    = ZYAN_NULL;\n    buffer->string.vector.element_size = sizeof(char);\n    buffer->string.vector.size         = 1;\n    buffer->string.vector.capacity     = length;\n    buffer->string.vector.data         = user_buffer;\n    *user_buffer = '\\0';\n}",
        "output": "1",
        "idx": 8830
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_pickle_UnpicklerMemoProxy_copy_impl(UnpicklerMemoProxyObject *self)\n{\n    Py_ssize_t i;\n    PyObject *new_memo = PyDict_New();\n    if (new_memo == NULL)\n        return NULL;\n\n    for (i = 0; i < self->unpickler->memo_size; i++) {\n        int status;\n        PyObject *key, *value;\n\n        value = self->unpickler->memo[i];\n        if (value == NULL)\n            continue;\n\n        key = PyLong_FromSsize_t(i);\n        if (key == NULL)\n            goto error;\n        status = PyDict_SetItem(new_memo, key, value);\n        Py_DECREF(key);\n        if (status < 0)\n            goto error;\n    }\n    return new_memo;\n\nerror:\n    Py_DECREF(new_memo);\n    return NULL;\n}",
        "output": "1",
        "idx": 7144
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int __fsnotify_parent(const struct path *path, struct dentry *dentry, __u32 mask)\n{\n\tstruct dentry *parent;\n\tstruct inode *p_inode;\n\tint ret = 0;\n\n\tif (!dentry)\n\t\tdentry = path->dentry;\n\n\tif (!(dentry->d_flags & DCACHE_FSNOTIFY_PARENT_WATCHED))\n\t\treturn 0;\n\n\tparent = dget_parent(dentry);\n\tp_inode = parent->d_inode;\n\n\tif (unlikely(!fsnotify_inode_watches_children(p_inode)))\n\t\t__fsnotify_update_child_dentry_flags(p_inode);\n\telse if (p_inode->i_fsnotify_mask & mask) {\n\t\tmask |= FS_EVENT_ON_CHILD;\n\n\t\tif (path)\n\t\t\tret = fsnotify(p_inode, mask, path, FSNOTIFY_EVENT_PATH,\n\t\t\t\t       dentry->d_name.name, 0);\n\t\telse\n\t\t\tret = fsnotify(p_inode, mask, dentry->d_inode, FSNOTIFY_EVENT_INODE,\n\t\t\t\t       dentry->d_name.name, 0);\n\t}\n\n\tdput(parent);\n\n\treturn ret;\n}",
        "output": "1",
        "idx": 1622
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main()\n{\n    check_file(\"tiff_invalid_read_1.tiff\");\n    check_file(\"tiff_invalid_read_2.tiff\");\n    check_file(\"tiff_invalid_read_3.tiff\");\n\n    return gdNumFailures();\n}",
        "output": "0",
        "idx": 6185
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void show_object(struct object *obj, const char *name, void *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tfinish_object(obj, name, cb_data);\n\tif (info->flags & REV_LIST_QUIET)\n\t\treturn;\n\tshow_object_with_name(stdout, obj, name);\n}",
        "output": "0",
        "idx": 7223
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseAuthAutoRoles(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprHash     *abilities;\n    MprKey      *kp;\n    MprJson     *child, *job;\n    int         ji;\n\n    if ((job = mprGetJsonObj(route->config, \"app.http.auth.roles\")) != 0) {\n        parseAuthRoles(route, \"app.http.auth.roles\", job);\n    }\n    abilities = mprCreateHash(0, 0);\n    for (ITERATE_CONFIG(route, prop, child, ji)) {\n        httpComputeRoleAbilities(route->auth, abilities, child->value);\n    }\n    if (mprGetHashLength(abilities) > 0) {\n        job = mprCreateJson(MPR_JSON_ARRAY);\n        for (ITERATE_KEYS(abilities, kp)) {\n            mprSetJson(job, \"$\", kp->key);\n        }\n        mprSetJsonObj(route->config, \"app.http.auth.auto.abilities\", job);\n    }\n}",
        "output": "1",
        "idx": 5058
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) \n{\n\tstruct fpm_worker_pool_config_s *c = wp->config;\n\n\twp->socket_uid = -1;\n\twp->socket_gid = -1;\n\twp->socket_mode = 0666;\n\n\tif (!c) {\n\t\treturn 0;\n\t}\n\n\tif (c->listen_owner && *c->listen_owner) {\n\t\tstruct passwd *pwd;\n\n\t\tpwd = getpwnam(c->listen_owner);\n\t\tif (!pwd) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get uid for user '%s'\", wp->config->name, c->listen_owner);\n\t\t\treturn -1;\n\t\t}\n\n\t\twp->socket_uid = pwd->pw_uid;\n\t\twp->socket_gid = pwd->pw_gid;\n\t}\n\n\tif (c->listen_group && *c->listen_group) {\n\t\tstruct group *grp;\n\n\t\tgrp = getgrnam(c->listen_group);\n\t\tif (!grp) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get gid for group '%s'\", wp->config->name, c->listen_group);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_gid = grp->gr_gid;\n\t}\n\n\tif (c->listen_mode && *c->listen_mode) {\n\t\twp->socket_mode = strtoul(c->listen_mode, 0, 8);\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 4110
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init pcd_init(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\n\tif (disable)\n\t\treturn -EINVAL;\n\n\tpcd_init_units();\n\n\tif (pcd_detect())\n\t\treturn -ENODEV;\n\n\tpcd_probe_capabilities();\n\n\tif (register_blkdev(major, name)) {\n\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++)\n\t\t\tput_disk(cd->disk);\n\t\treturn -EBUSY;\n\t}\n\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (cd->present) {\n\t\t\tregister_cdrom(&cd->info);\n\t\t\tcd->disk->private_data = cd;\n\t\t\tadd_disk(cd->disk);\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 3140
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kgdb_hw_overflow_handler(struct perf_event *event, int nmi,\n\t\tstruct perf_sample_data *data, struct pt_regs *regs)\n{\n\tstruct task_struct *tsk = current;\n\tint i;\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (breakinfo[i].enabled)\n\t\t\ttsk->thread.debugreg6 |= (DR_TRAP0 << i);\n}",
        "output": "1",
        "idx": 508
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) \n{\n\tstruct fpm_worker_pool_config_s *c = wp->config;\n\n\twp->socket_uid = -1;\n\twp->socket_gid = -1;\n\twp->socket_mode = 0660;\n\n\tif (!c) {\n\t\treturn 0;\n\t}\n\n\tif (c->listen_owner && *c->listen_owner) {\n\t\tstruct passwd *pwd;\n\n\t\tpwd = getpwnam(c->listen_owner);\n\t\tif (!pwd) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get uid for user '%s'\", wp->config->name, c->listen_owner);\n\t\t\treturn -1;\n\t\t}\n\n\t\twp->socket_uid = pwd->pw_uid;\n\t\twp->socket_gid = pwd->pw_gid;\n\t}\n\n\tif (c->listen_group && *c->listen_group) {\n\t\tstruct group *grp;\n\n\t\tgrp = getgrnam(c->listen_group);\n\t\tif (!grp) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get gid for group '%s'\", wp->config->name, c->listen_group);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_gid = grp->gr_gid;\n\t}\n\n\tif (c->listen_mode && *c->listen_mode) {\n\t\twp->socket_mode = strtoul(c->listen_mode, 0, 8);\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 5677
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_proxy_auth_type_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\tif (length < 2) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_authentype2str,\n\t\t\t     \"AuthType-#%u\", EXTRACT_16BITS(ptr))));\n}",
        "output": "0",
        "idx": 6663
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)\n{\n\tint x, y, pos;\n\tWbmp *wbmp;\n\n\tif ((wbmp = createwbmp (gdImageSX (image), gdImageSY (image), WBMP_WHITE)) == NULL) {\n\t\tgd_error(\"Could not create WBMP\");\n\t\treturn;\n\t}\n\n\tpos = 0;\n\tfor (y = 0; y < gdImageSY(image); y++) {\n\t\tfor (x = 0; x < gdImageSX(image); x++) {\n\t\t\tif (gdImageGetPixel (image, x, y) == fg) {\n\t\t\t\twbmp->bitmap[pos] = WBMP_BLACK;\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t}\n\n\tif (writewbmp (wbmp, &gd_putout, out)) {\n\t\tgd_error(\"Could not save WBMP\");\n\t}\n\tfreewbmp(wbmp);\n}",
        "output": "1",
        "idx": 4124
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "w3m_exit(int i)\n{\n#ifdef USE_MIGEMO\n    init_migemo();\t\t\n#endif\n    stopDownload();\n    deleteFiles();\n#ifdef USE_SSL\n    free_ssl_ctx();\n#endif\n    disconnectFTP();\n#ifdef USE_NNTP\n    disconnectNews();\n#endif\n#ifdef __MINGW32_VERSION\n    WSACleanup();\n#endif\n#ifdef HAVE_MKDTEMP\n    if (no_rc_dir && tmp_dir != rc_dir)\n\tif (rmdir(tmp_dir) != 0) {\n\t    fprintf(stderr, \"Can't remove temporary directory (%s)!\\n\", tmp_dir);\n\t    exit(1);\n\t}\n#endif\n    exit(i);\n}",
        "output": "0",
        "idx": 8539
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int cJSON_HasObjectItem(cJSON *object,const char *string)\t\t{return cJSON_GetObjectItem(object,string)?1:0;}",
        "output": "0",
        "idx": 8329
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void llc_cmsg_rcv(struct msghdr *msg, struct sk_buff *skb)\n{\n\tstruct llc_sock *llc = llc_sk(skb->sk);\n\n\tif (llc->cmsg_flags & LLC_CMSG_PKTINFO) {\n\t\tstruct llc_pktinfo info;\n\n\t\tmemset(&info, 0, sizeof(info));\n\t\tinfo.lpi_ifindex = llc_sk(skb->sk)->dev->ifindex;\n\t\tllc_pdu_decode_dsap(skb, &info.lpi_sap);\n\t\tllc_pdu_decode_da(skb, info.lpi_mac);\n\t\tput_cmsg(msg, SOL_LLC, LLC_OPT_PKTINFO, sizeof(info), &info);\n\t}\n}",
        "output": "0",
        "idx": 1847
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_isBidi (const uint32_t *label, size_t llen)\n{\n  for (; (ssize_t) llen > 0; llen--) {\n    int bc = uc_bidi_category (*label++);\n\n    if (bc == UC_BIDI_R || bc == UC_BIDI_AL || bc == UC_BIDI_AN)\n      return 1;\n  }\n\n  return 0;\n}",
        "output": "0",
        "idx": 8783
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int au1100fb_fb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)\n{\n\tstruct au1100fb_device *fbdev;\n\n\tfbdev = to_au1100fb_device(fbi);\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tpgprot_val(vma->vm_page_prot) |= (6 << 9); \n\n\treturn vm_iomap_memory(vma, fbdev->fb_phys, fbdev->fb_len);\n}",
        "output": "0",
        "idx": 3339
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dvb_usbv2_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *devname = kstrdup(dev_name(&d->udev->dev), GFP_KERNEL);\n\tconst char *drvname = d->name;\n\n\tdev_dbg(&d->udev->dev, \"%s: bInterfaceNumber=%d\\n\", __func__,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\n\tif (d->props->exit)\n\t\td->props->exit(d);\n\n\tdvb_usbv2_exit(d);\n\n\tpr_info(\"%s: '%s:%s' successfully deinitialized and disconnected\\n\",\n\t\tKBUILD_MODNAME, drvname, devname);\n\tkfree(devname);\n}",
        "output": "0",
        "idx": 2139
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateIntArray(const int *numbers,int count)\t\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}",
        "output": "0",
        "idx": 8247
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ftrace_syscall_exit(void *data, struct pt_regs *regs, long ret)\n{\n\tstruct trace_array *tr = data;\n\tstruct ftrace_event_file *ftrace_file;\n\tstruct syscall_trace_exit *entry;\n\tstruct syscall_metadata *sys_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tunsigned long irq_flags;\n\tint pc;\n\tint syscall_nr;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0)\n\t\treturn;\n\n\tftrace_file = rcu_dereference_sched(tr->exit_syscall_files[syscall_nr]);\n\tif (!ftrace_file)\n\t\treturn;\n\n\tif (ftrace_trigger_soft_disabled(ftrace_file))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\tlocal_save_flags(irq_flags);\n\tpc = preempt_count();\n\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer,\n\t\t\tsys_data->exit_event->event.type, sizeof(*entry),\n\t\t\tirq_flags, pc);\n\tif (!event)\n\t\treturn;\n\n\tentry = ring_buffer_event_data(event);\n\tentry->nr = syscall_nr;\n\tentry->ret = syscall_get_return_value(current, regs);\n\n\tevent_trigger_unlock_commit(ftrace_file, buffer, event, entry,\n\t\t\t\t    irq_flags, pc);\n}",
        "output": "1",
        "idx": 2714
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\n\tu16 offset = sizeof(struct ipv6hdr);\n\tstruct ipv6_opt_hdr *exthdr =\n\t\t\t\t(struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);\n\tunsigned int packet_len = skb_tail_pointer(skb) -\n\t\tskb_network_header(skb);\n\tint found_rhdr = 0;\n\t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n\n\twhile (offset + 1 <= packet_len) {\n\n\t\tswitch (**nexthdr) {\n\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\n\t\toffset += ipv6_optlen(exthdr);\n\t\t*nexthdr = &exthdr->nexthdr;\n\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t offset);\n\t}\n\n\treturn offset;\n}",
        "output": "1",
        "idx": 1588
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dcbnl_getperm_hwaddr(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t\tu32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tu8 perm_addr[MAX_ADDR_LEN];\n\n\tif (!netdev->dcbnl_ops->getpermhwaddr)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(perm_addr, 0, sizeof(perm_addr));\n\tnetdev->dcbnl_ops->getpermhwaddr(netdev, perm_addr);\n\n\treturn nla_put(skb, DCB_ATTR_PERM_HWADDR, sizeof(perm_addr), perm_addr);\n}",
        "output": "0",
        "idx": 1211
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc,\n\t\t       struct ath_node *an)\n{\n\tstruct ath_atx_tid *tid;\n\tstruct ath_atx_ac *ac;\n\tstruct ath_txq *txq;\n\tbool buffered;\n\tint tidno;\n\n\tfor (tidno = 0, tid = &an->tid[tidno];\n\t     tidno < IEEE80211_NUM_TIDS; tidno++, tid++) {\n\n\t\tac = tid->ac;\n\t\ttxq = ac->txq;\n\n\t\tath_txq_lock(sc, txq);\n\n\t\tif (!tid->sched) {\n\t\t\tath_txq_unlock(sc, txq);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbuffered = ath_tid_has_buffered(tid);\n\n\t\ttid->sched = false;\n\t\tlist_del(&tid->list);\n\n\t\tif (ac->sched) {\n\t\t\tac->sched = false;\n\t\t\tlist_del(&ac->list);\n\t\t}\n\n\t\tath_txq_unlock(sc, txq);\n\n\t\tieee80211_sta_set_buffered(sta, tidno, buffered);\n\t}\n}",
        "output": "0",
        "idx": 3477
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void* chk_malloc(size_t bytes)\n{\n    size_t size = bytes + CHK_OVERHEAD_SIZE;\n    if (size < bytes) { \n        return NULL;\n    }\n    uint8_t* buffer = (uint8_t*) dlmalloc(size);\n    if (buffer) {\n        memset(buffer, CHK_SENTINEL_VALUE, bytes + CHK_OVERHEAD_SIZE);\n        size_t offset = dlmalloc_usable_size(buffer) - sizeof(size_t);\n        *(size_t *)(buffer + offset) = bytes;\n        buffer += CHK_SENTINEL_HEAD_SIZE;\n    }\n    return buffer;\n}",
        "output": "0",
        "idx": 5073
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bit_write_MC (Bit_Chain *dat, BITCODE_MC val)\n{\n  int i, j;\n  int negative = 0;\n  unsigned char byte[5];\n  BITCODE_UMC mask = 0x0000007f;\n  BITCODE_UMC value = (BITCODE_UMC)val;\n\n  if (val < 0)\n    {\n      negative = 1;\n      value = (BITCODE_UMC)-val;\n    }\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = (unsigned char)((value & mask) >> j);\n      byte[i] |= 0x80;\n      mask = mask << 7;\n    }\n  for (i = 0; i < 4; i++)\n    if (byte[i] & 0x7f)\n      break;\n\n  if (byte[i] & 0x40)\n    i--;\n  byte[i] &= 0x7f;\n  if (negative)\n    byte[i] |= 0x40;\n  for (j = 4; j >= i; j--)\n    bit_write_RC (dat, byte[j]);\n}",
        "output": "1",
        "idx": 7824
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bump_cpu_timer(struct k_itimer *timer, u64 now)\n{\n\tint i;\n\tu64 delta, incr;\n\n\tif (timer->it.cpu.incr == 0)\n\t\treturn;\n\n\tif (now < timer->it.cpu.expires)\n\t\treturn;\n\n\tincr = timer->it.cpu.incr;\n\tdelta = now + incr - timer->it.cpu.expires;\n\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\n\t\ttimer->it.cpu.expires += incr;\n\t\ttimer->it_overrun += 1 << i;\n\t\tdelta -= incr;\n\t}\n}",
        "output": "1",
        "idx": 2982
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vgacon_scrollback_reset(int vc_num, size_t reset_size)\n{\n\tstruct vgacon_scrollback_info *scrollback = &vgacon_scrollbacks[vc_num];\n\n\tif (scrollback->data && reset_size > 0)\n\t\tmemset(scrollback->data, 0, reset_size);\n\n\tscrollback->cnt  = 0;\n\tscrollback->tail = 0;\n\tscrollback->cur  = 0;\n}",
        "output": "1",
        "idx": 1880
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const uint8_t *get_signature(const uint8_t *asn1_sig, int *len)\n{\n    int offset = 0;\n    const uint8_t *ptr = NULL;\n\n    if (asn1_next_obj(asn1_sig, &offset, ASN1_SEQUENCE) < 0 || \n            asn1_skip_obj(asn1_sig, &offset, ASN1_SEQUENCE))\n        goto end_get_sig;\n\n    if (asn1_sig[offset++] != ASN1_OCTET_STRING)\n        goto end_get_sig;\n    *len = get_asn1_length(asn1_sig, &offset);\n    ptr = &asn1_sig[offset];          \n\nend_get_sig:\n    return ptr;\n}",
        "output": "1",
        "idx": 7008
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mem_check_range(struct rxe_mem *mem, u64 iova, size_t length)\n{\n\tswitch (mem->type) {\n\tcase RXE_MEM_TYPE_DMA:\n\t\treturn 0;\n\n\tcase RXE_MEM_TYPE_MR:\n\tcase RXE_MEM_TYPE_FMR:\n\t\treturn ((iova < mem->iova) ||\n\t\t\t((iova + length) > (mem->iova + mem->length))) ?\n\t\t\t-EFAULT : 0;\n\n\tdefault:\n\t\treturn -EFAULT;\n\t}\n}",
        "output": "1",
        "idx": 1472
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(curl_unescape)\n{\n\tchar       *str = NULL, *out = NULL;\n\tsize_t     str_len = 0;\n\tint        out_len;\n\tzval       *zid;\n\tphp_curl   *ch;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rs\", &zid, &str, &str_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((ch = (php_curl*)zend_fetch_resource(Z_RES_P(zid), le_curl_name, le_curl)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ZEND_SIZE_T_INT_OVFL(str_len)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif ((out = curl_easy_unescape(ch->cp, str, str_len, &out_len))) {\n\t\tRETVAL_STRINGL(out, out_len);\n\t\tcurl_free(out);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}",
        "output": "0",
        "idx": 5627
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "local void init_block(s)\n    deflate_state *s;\n{\n    int n; \n\n    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;\n    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;\n    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;\n\n    s->dyn_ltree[END_BLOCK].Freq = 1;\n    s->opt_len = s->static_len = 0L;\n    s->sym_next = s->matches = 0;\n}",
        "output": "0",
        "idx": 8561
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct dst_entry *inet6_csk_route_req(const struct sock *sk,\n\t\t\t\t      struct flowi6 *fl6,\n\t\t\t\t      const struct request_sock *req,\n\t\t\t\t      u8 proto)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *final_p, final;\n\tstruct dst_entry *dst;\n\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_proto = proto;\n\tfl6->daddr = ireq->ir_v6_rmt_addr;\n\trcu_read_lock();\n\tfinal_p = fl6_update_dst(fl6, rcu_dereference(np->opt), &final);\n\trcu_read_unlock();\n\tfl6->saddr = ireq->ir_v6_loc_addr;\n\tfl6->flowi6_oif = ireq->ir_iif;\n\tfl6->flowi6_mark = ireq->ir_mark;\n\tfl6->fl6_dport = ireq->ir_rmt_port;\n\tfl6->fl6_sport = htons(ireq->ir_num);\n\tsecurity_req_classify_flow(req, flowi6_to_flowi(fl6));\n\n\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\tif (IS_ERR(dst))\n\t\treturn NULL;\n\n\treturn dst;\n}",
        "output": "0",
        "idx": 1409
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\tmsg->msg_namelen = 0;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err == 0)\n\t\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tskb_free_datagram(sk, skb);\n\n\treturn err ? : copied;\n}",
        "output": "0",
        "idx": 1271
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void posixtimer_rearm(struct siginfo *info)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\n\ttimr = lock_timer(info->si_tid, &flags);\n\tif (!timr)\n\t\treturn;\n\n\tif (timr->it_requeue_pending == info->si_sys_private) {\n\t\ttimr->kclock->timer_rearm(timr);\n\n\t\ttimr->it_active = 1;\n\t\ttimr->it_overrun_last = timr->it_overrun;\n\t\ttimr->it_overrun = -1;\n\t\t++timr->it_requeue_pending;\n\n\t\tinfo->si_overrun += timr->it_overrun_last;\n\t}\n\n\tunlock_timer(timr, flags);\n}",
        "output": "1",
        "idx": 2994
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n\n\tif (flags & MSG_CMSG_COMPAT)\n\t\treturn -EINVAL;\n\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT,\n\t\t\t\t      (struct timespec *) timeout);\n\n\tif (timeout == NULL)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n\n\tif (get_compat_timespec(&ktspec, timeout))\n\t\treturn -EFAULT;\n\n\tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n\t\tdatagrams = -EFAULT;\n\n\treturn datagrams;\n}",
        "output": "1",
        "idx": 2516
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __inline__ int scm_check_creds(struct ucred *creds)\n{\n\tconst struct cred *cred = current_cred();\n\tkuid_t uid = make_kuid(cred->user_ns, creds->uid);\n\tkgid_t gid = make_kgid(cred->user_ns, creds->gid);\n\n\tif (!uid_valid(uid) || !gid_valid(gid))\n\t\treturn -EINVAL;\n\n\tif ((creds->pid == task_tgid_vnr(current) ||\n\t     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&\n\t    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||\n\t      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&\n\t    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||\n\t      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {\n\t       return 0;\n\t}\n\treturn -EPERM;\n}",
        "output": "0",
        "idx": 3301
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vfio_msi_enable(struct vfio_pci_device *vdev, int nvec, bool msix)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tunsigned int flag = msix ? PCI_IRQ_MSIX : PCI_IRQ_MSI;\n\tint ret;\n\n\tif (!is_irq_none(vdev))\n\t\treturn -EINVAL;\n\n\tvdev->ctx = kzalloc(nvec * sizeof(struct vfio_pci_irq_ctx), GFP_KERNEL);\n\tif (!vdev->ctx)\n\t\treturn -ENOMEM;\n\n\tret = pci_alloc_irq_vectors(pdev, 1, nvec, flag);\n\tif (ret < nvec) {\n\t\tif (ret > 0)\n\t\t\tpci_free_irq_vectors(pdev);\n\t\tkfree(vdev->ctx);\n\t\treturn ret;\n\t}\n\n\tvdev->num_ctx = nvec;\n\tvdev->irq_type = msix ? VFIO_PCI_MSIX_IRQ_INDEX :\n\t\t\t\tVFIO_PCI_MSI_IRQ_INDEX;\n\n\tif (!msix) {\n\t\tvdev->msi_qmax = fls(nvec * 2 - 1) - 1;\n\t}\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1350
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void enc28j60WritePhyReg(NetInterface *interface, uint16_t address,\n   uint16_t data)\n{\n   enc28j60WriteReg(interface, ENC28J60_REG_MIREGADR, address & REG_ADDR_MASK);\n\n   enc28j60WriteReg(interface, ENC28J60_REG_MIWRL, LSB(data));\n   enc28j60WriteReg(interface, ENC28J60_REG_MIWRH, MSB(data));\n\n   while((enc28j60ReadReg(interface, ENC28J60_REG_MISTAT) & MISTAT_BUSY) != 0)\n   {\n   }\n}",
        "output": "1",
        "idx": 8544
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *cJSON_PrintUnformatted( cJSON *item )\n{\n\treturn print_value( item, 0, 0 );\n}",
        "output": "1",
        "idx": 5904
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ChunkedDecode(Request *reqPtr, bool update)\n{\n    const Tcl_DString *bufPtr;\n    const char        *end, *chunkStart;\n    bool              success = NS_TRUE;\n\n    NS_NONNULL_ASSERT(reqPtr != NULL);\n\n    bufPtr = &reqPtr->buffer;\n    end = bufPtr->string + bufPtr->length;\n    chunkStart = bufPtr->string + reqPtr->chunkStartOff;\n\n    while (reqPtr->chunkStartOff <  (size_t)bufPtr->length) {\n        char   *p = strstr(chunkStart, \"\\r\\n\");\n        size_t  chunk_length;\n\n        if (p == NULL) {\n            Ns_Log(DriverDebug, \"ChunkedDecode: chunk did not find end-of-line\");\n            success = NS_FALSE;\n            break;\n        }\n\n        *p = '\\0';\n        chunk_length = (size_t)strtol(chunkStart, NULL, 16);\n        *p = '\\r';\n\n        if (p + 2 + chunk_length > end) {\n            Ns_Log(DriverDebug, \"ChunkedDecode: chunk length past end of buffer\");\n            success = NS_FALSE;\n            break;\n        }\n        if (update) {\n            char *writeBuffer = bufPtr->string + reqPtr->chunkWriteOff;\n\n            memmove(writeBuffer, p + 2, chunk_length);\n            reqPtr->chunkWriteOff += chunk_length;\n            *(writeBuffer + chunk_length) = '\\0';\n        }\n        reqPtr->chunkStartOff += (size_t)(p - chunkStart) + 4u + chunk_length;\n        chunkStart = bufPtr->string + reqPtr->chunkStartOff;\n    }\n\n    return success;\n}",
        "output": "1",
        "idx": 7990
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int handle_vmptrst(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t vmcs_gva;\n\tstruct x86_exception e;\n\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\n\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\tvmx_instruction_info, true, &vmcs_gva))\n\t\treturn 1;\n\tif (kvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, vmcs_gva,\n\t\t\t\t (void *)&to_vmx(vcpu)->nested.current_vmptr,\n\t\t\t\t sizeof(u64), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}",
        "output": "1",
        "idx": 2974
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static pyc_object *get_list_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (list size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_LIST;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}",
        "output": "1",
        "idx": 6446
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parsePipelineFilters(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprJson     *child;\n    cchar       *name, *extensions;\n    int         flags, ji;\n\n    for (ITERATE_CONFIG(route, prop, child, ji)) {\n        if (child->type & MPR_JSON_STRING) {\n            flags = HTTP_STAGE_RX | HTTP_STAGE_TX;\n            extensions = 0;\n            name = child->value;\n        } else {\n            name = mprGetJson(child, \"name\");\n            extensions = getList(mprGetJsonObj(child, \"extensions\"));\n#if KEEP\n            direction = mprGetJson(child, \"direction\");\n            flags |= smatch(direction, \"input\") ? HTTP_STAGE_RX : 0;\n            flags |= smatch(direction, \"output\") ? HTTP_STAGE_TX : 0;\n            flags |= smatch(direction, \"both\") ? HTTP_STAGE_RX | HTTP_STAGE_TX : 0;\n#else\n            flags = HTTP_STAGE_RX | HTTP_STAGE_TX;\n#endif\n        }\n        if (httpAddRouteFilter(route, name, extensions, flags) < 0) {\n            httpParseError(route, \"Cannot add filter %s\", name);\n            break;\n        }\n    }\n}",
        "output": "1",
        "idx": 5020
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "netsnmp_mibindex_new( const char *dirname )\n{\n    FILE *fp;\n    char  tmpbuf[300];\n    char *cp;\n    int   i;\n\n    cp = netsnmp_mibindex_lookup( dirname );\n    if (!cp) {\n        i  = _mibindex_add( dirname, -1 );\n        snprintf( tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes/%d\",\n                  get_persistent_directory(), i );\n        tmpbuf[sizeof(tmpbuf)-1] = 0;\n        cp = tmpbuf;\n    }\n    DEBUGMSGTL((\"mibindex\", \"new: %s (%s)\\n\", dirname, cp ));\n    fp = fopen( cp, \"w\" );\n    if (fp)\n        fprintf( fp, \"DIR %s\\n\", dirname );\n    return fp;\n}",
        "output": "1",
        "idx": 7800
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sf_flac_write_callback (const FLAC__StreamDecoder * UNUSED (decoder), const FLAC__Frame *frame, const int32_t * const buffer [], void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\n\tpflac->frame = frame ;\n\tpflac->bufferpos = 0 ;\n\n\tpflac->bufferbackup = SF_FALSE ;\n\tpflac->wbuffer = buffer ;\n\n\tflac_buffer_copy (psf) ;\n\n\treturn FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE ;\n} ",
        "output": "1",
        "idx": 4906
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "init_normalization(struct compiling *c)\n{\n    PyObject *m = PyImport_ImportModuleNoBlock(\"unicodedata\");\n    if (!m)\n        return 0;\n    c->c_normalize = PyObject_GetAttrString(m, \"normalize\");\n    Py_DECREF(m);\n    if (!c->c_normalize)\n        return 0;\n    c->c_normalize_args = Py_BuildValue(\"(sN)\", \"NFKC\", Py_None);\n    if (!c->c_normalize_args) {\n        Py_CLEAR(c->c_normalize);\n        return 0;\n    }\n    PyTuple_SET_ITEM(c->c_normalize_args, 1, NULL);\n    return 1;\n}",
        "output": "1",
        "idx": 7782
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct tcp_sock_t *tcp6_open(uint16_t port)\n{\n\tstruct tcp_sock_t *this = calloc(1, sizeof *this);\n\tif (this == NULL) {\n\t\tERR(\"IPv6: callocing this failed\");\n\t\tgoto error;\n\t}\n\n\tthis->sd = -1;\n\tthis->sd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (this->sd < 0) {\n\t\tERR(\"Ipv6 socket open failed\");\n\t\tgoto error;\n\t}\n\n\tstruct sockaddr_in6 addr;\n\tmemset(&addr, 0, sizeof addr);\n\taddr.sin6_family = AF_INET6;\n\taddr.sin6_port = htons(port);\n\taddr.sin6_addr = in6addr_loopback;\n\n\tif (bind(this->sd,\n\t        (struct sockaddr *)&addr,\n\t        sizeof addr) < 0) {\n\t\tif (g_options.only_desired_port == 1)\n\t\t\tERR(\"IPv6 bind on port failed. \"\n\t\t\t    \"Requested port may be taken or require root permissions.\");\n\t\tgoto error;\n\t}\n\n\tif (listen(this->sd, HTTP_MAX_PENDING_CONNS) < 0) {\n\t\tERR(\"IPv6 listen failed on socket\");\n\t\tgoto error;\n\t}\n\n\treturn this;\n\nerror:\n\tif (this != NULL) {\n\t\tif (this->sd != -1) {\n\t\t\tclose(this->sd);\n\t\t}\n\t\tfree(this);\n\t}\n\treturn NULL;\n}",
        "output": "0",
        "idx": 7645
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spl_filesystem_tree_it_rewind(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\tspl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);\n\n\tobject->u.dir.index = 0;\n\tif (object->u.dir.dirp) {\n\t\tphp_stream_rewinddir(object->u.dir.dirp);\n\t}\n\tdo {\n\t\tspl_filesystem_dir_read(object TSRMLS_CC);\n\t} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));\n\tif (iterator->current) {\n\t\tzval_ptr_dtor(&iterator->current);\n\t\titerator->current = NULL;\n\t}\n}",
        "output": "0",
        "idx": 5477
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_word_gray_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}",
        "output": "1",
        "idx": 6748
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mono_gc_init (void)\n{\n\tInitializeCriticalSection (&handle_section);\n\tInitializeCriticalSection (&allocator_section);\n\n\tInitializeCriticalSection (&finalizer_mutex);\n\tInitializeCriticalSection (&reference_queue_mutex);\n\n\tMONO_GC_REGISTER_ROOT_FIXED (gc_handles [HANDLE_NORMAL].entries);\n\tMONO_GC_REGISTER_ROOT_FIXED (gc_handles [HANDLE_PINNED].entries);\n\n\tmono_gc_base_init ();\n\n\tif (mono_gc_is_disabled ()) {\n\t\tgc_disabled = TRUE;\n\t\treturn;\n\t}\n\t\n\tfinalizer_event = CreateEvent (NULL, FALSE, FALSE, NULL);\n\tpending_done_event = CreateEvent (NULL, TRUE, FALSE, NULL);\n\tshutdown_event = CreateEvent (NULL, TRUE, FALSE, NULL);\n\tif (finalizer_event == NULL || pending_done_event == NULL || shutdown_event == NULL) {\n\t\tg_assert_not_reached ();\n\t}\n#ifdef MONO_HAS_SEMAPHORES\n\tMONO_SEM_INIT (&finalizer_sem, 0);\n#endif\n\n\tgc_thread = mono_thread_create_internal (mono_domain_get (), finalizer_thread, NULL, FALSE);\n\tves_icall_System_Threading_Thread_SetName_internal (gc_thread, mono_string_new (mono_domain_get (), \"Finalizer\"));\n}",
        "output": "0",
        "idx": 4705
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline ut32 r_read_at_le32(const void *src, size_t offset) {\n\tif (!src) {\n\t\treturn UT32_MAX;\n\t}\n\tconst ut8 *s = (const ut8*)src + offset;\n\treturn r_read_le32 (s);\n}",
        "output": "0",
        "idx": 8601
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_ppp_discon_cc_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\tND_PRINT((ndo, \"%04x, \", EXTRACT_16BITS(ptr))); ptr++;\t\n\tND_PRINT((ndo, \"%04x \",  EXTRACT_16BITS(ptr))); ptr++;\t\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_cc_direction2str,\n\t\t\t     \"Direction-#%u\", *((const u_char *)ptr++))));\n\n\tif (length > 5) {\n\t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, (const u_char *)ptr, length-5);\n\t}\n}",
        "output": "1",
        "idx": 4754
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "find_by_thp(struct tang_keys_info* tki, const char* target)\n{\n    if (!tki) {\n        return NULL;\n    }\n\n    json_auto_t* keys = json_deep_copy(tki->m_keys);\n    json_array_extend(keys, tki->m_rotated_keys);\n\n    size_t idx;\n    json_t* jwk;\n    const char** hashes = supported_hashes();\n    json_array_foreach(keys, idx, jwk) {\n        for (int i = 0; hashes[i]; i++) {\n            __attribute__ ((__cleanup__(cleanup_str))) char* thumbprint = jwk_thumbprint(jwk, hashes[i]);\n            if (!thumbprint || strcmp(thumbprint, target) != 0) {\n                continue;\n            }\n\n            if (jwk_valid_for_deriving_keys(jwk)) {\n                return json_incref(jwk);\n            } else if (jwk_valid_for_signing(jwk)) {\n                json_auto_t* sign = json_deep_copy(tki->m_sign);\n                if (json_array_append(sign, jwk) == -1) {\n                    return NULL;\n                }\n                json_auto_t* jws = jwk_sign(tki->m_payload, sign);\n                if (!jws) {\n                    return NULL;\n                }\n                return json_incref(jws);\n            }\n        }\n    }\n    return NULL;\n}",
        "output": "1",
        "idx": 8798
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void svhandler_flash_erase_sector(void) {\n  uint32_t sector = _param_1;\n\n  if ((sector == FLASH_BOOTSTRAP_SECTOR) ||\n      (sector >= FLASH_BOOT_SECTOR_FIRST && sector <= FLASH_BOOT_SECTOR_LAST)) {\n    return;\n  }\n\n  flash_clear_status_flags();\n  flash_unlock();\n\n  flash_erase_sector(sector, FLASH_CR_PROGRAM_X32);\n\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n\n  flash_wait_for_last_operation();\n\n  FLASH_CR &= ~FLASH_CR_PG;\n\n  FLASH_CR |= FLASH_CR_LOCK;\n}",
        "output": "1",
        "idx": 7564
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sas_probe_devices(struct asd_sas_port *port)\n{\n\tstruct domain_device *dev, *n;\n\n\tlist_for_each_entry(dev, &port->disco_list, disco_list_node) {\n\t\tspin_lock_irq(&port->dev_list_lock);\n\t\tlist_add_tail(&dev->dev_list_node, &port->dev_list);\n\t\tspin_unlock_irq(&port->dev_list_lock);\n\t}\n\n\tsas_probe_sata(port);\n\n\tlist_for_each_entry_safe(dev, n, &port->disco_list, disco_list_node) {\n\t\tint err;\n\n\t\terr = sas_rphy_add(dev->rphy);\n\t\tif (err)\n\t\t\tsas_fail_probe(dev, __func__, err);\n\t\telse\n\t\t\tlist_del_init(&dev->disco_list_node);\n\t}\n}",
        "output": "0",
        "idx": 2643
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct tcp_sock_t *tcp_open(uint16_t port)\n{\n\tstruct tcp_sock_t *this = calloc(1, sizeof *this);\n\tif (this == NULL) {\n\t\tERR(\"callocing this failed\");\n\t\tgoto error;\n\t}\n\n\tthis->sd = -1;\n\tthis->sd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (this->sd < 0) {\n\t\tERR(\"sockect open failed\");\n\t\tgoto error;\n\t}\n\n\tstruct sockaddr_in6 addr;\n\tmemset(&addr, 0, sizeof addr);\n\taddr.sin6_family = AF_INET6;\n\taddr.sin6_port = htons(port);\n\taddr.sin6_addr = in6addr_any;\n\n\tif (bind(this->sd,\n\t        (struct sockaddr *)&addr,\n\t        sizeof addr) < 0) {\n\t\tif (g_options.only_desired_port == 1)\n\t\t\tERR(\"Bind on port failed. \"\n\t\t\t    \"Requested port may be taken or require root permissions.\");\n\t\tgoto error;\n\t}\n\n\tif (listen(this->sd, HTTP_MAX_PENDING_CONNS) < 0) {\n\t\tERR(\"listen failed on socket\");\n\t\tgoto error;\n\t}\n\n\treturn this;\n\nerror:\n\tif (this != NULL) {\n\t\tif (this->sd != -1) {\n\t\t\tclose(this->sd);\n\t\t}\n\t\tfree(this);\n\t}\n\treturn NULL;\n}",
        "output": "1",
        "idx": 5456
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION( locale_get_script )\n{\n\tget_icu_value_src_php( LOC_SCRIPT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}",
        "output": "0",
        "idx": 5397
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fp_setreadl(struct tok_state *tok, const char* enc)\n{\n    PyObject *readline, *io, *stream;\n    _Py_IDENTIFIER(open);\n    _Py_IDENTIFIER(readline);\n    int fd;\n    long pos;\n\n    fd = fileno(tok->fp);\n    pos = ftell(tok->fp);\n    if (pos == -1 ||\n        lseek(fd, (off_t)(pos > 0 ? pos - 1 : pos), SEEK_SET) == (off_t)-1) {\n        PyErr_SetFromErrnoWithFilename(PyExc_OSError, NULL);\n        return 0;\n    }\n\n    io = PyImport_ImportModuleNoBlock(\"io\");\n    if (io == NULL)\n        return 0;\n\n    stream = _PyObject_CallMethodId(io, &PyId_open, \"isisOOO\",\n                    fd, \"r\", -1, enc, Py_None, Py_None, Py_False);\n    Py_DECREF(io);\n    if (stream == NULL)\n        return 0;\n\n    readline = _PyObject_GetAttrId(stream, &PyId_readline);\n    Py_DECREF(stream);\n    if (readline == NULL)\n        return 0;\n    Py_XSETREF(tok->decoding_readline, readline);\n\n    if (pos > 0) {\n        PyObject *bufobj = PyObject_CallObject(readline, NULL);\n        if (bufobj == NULL)\n            return 0;\n        Py_DECREF(bufobj);\n    }\n\n    return 1;\n}",
        "output": "1",
        "idx": 7668
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "snmp_ber_decode_length(unsigned char *buff, uint32_t *buff_len, uint8_t *length)\n{\n  if(*buff_len == 0) {\n    return NULL;\n  }\n\n  *length = *buff++;\n  (*buff_len)--;\n\n  return buff;\n}",
        "output": "1",
        "idx": 7964
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)\n{\n\tint x, y, pos;\n\tWbmp *wbmp;\n\n\tif ((wbmp = createwbmp (gdImageSX (image), gdImageSY (image), WBMP_WHITE)) == NULL) {\n\t\tgd_error(\"Could not create WBMP\");\n\t\treturn 1;\n\t}\n\n\tpos = 0;\n\tfor (y = 0; y < gdImageSY(image); y++) {\n\t\tfor (x = 0; x < gdImageSX(image); x++) {\n\t\t\tif (gdImageGetPixel (image, x, y) == fg) {\n\t\t\t\twbmp->bitmap[pos] = WBMP_BLACK;\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t}\n\n\tif (writewbmp (wbmp, &gd_putout, out)) {\n\t\tfreewbmp(wbmp);\n\t\tgd_error(\"Could not save WBMP\");\n\t\treturn 1;\n\t}\n\tfreewbmp(wbmp);\n}",
        "output": "0",
        "idx": 5699
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n\t{\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tsqr_add_c(a,0,c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tsqr_add_c2(a,1,0,c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tsqr_add_c(a,1,c3,c1,c2);\n\tsqr_add_c2(a,2,0,c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tsqr_add_c2(a,3,0,c1,c2,c3);\n\tsqr_add_c2(a,2,1,c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tsqr_add_c(a,2,c2,c3,c1);\n\tsqr_add_c2(a,3,1,c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tsqr_add_c2(a,3,2,c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tsqr_add_c(a,3,c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}",
        "output": "1",
        "idx": 4540
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint16_t dm9000ReadPhyReg(uint8_t address)\n{\n   dm9000WriteReg(DM9000_REG_EPAR, 0x40 | address);\n\n   dm9000WriteReg(DM9000_REG_EPCR, EPCR_EPOS | EPCR_ERPRR);\n   while((dm9000ReadReg(DM9000_REG_EPCR) & EPCR_ERRE) != 0)\n   {\n   }\n\n   dm9000WriteReg(DM9000_REG_EPCR, EPCR_EPOS);\n   usleep(5);\n\n   return (dm9000ReadReg(DM9000_REG_EPDRH) << 8) | dm9000ReadReg(DM9000_REG_EPDRL);\n}",
        "output": "1",
        "idx": 8530
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int flush_completed_IO(struct inode *inode)\n{\n\text4_io_end_t *io;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tunsigned long flags;\n\tint ret = 0;\n\tint ret2 = 0;\n\n\tif (list_empty(&ei->i_completed_io_list))\n\t\treturn ret;\n\n\tdump_completed_IO(inode);\n\tspin_lock_irqsave(&ei->i_completed_io_lock, flags);\n\twhile (!list_empty(&ei->i_completed_io_list)){\n\t\tio = list_entry(ei->i_completed_io_list.next,\n\t\t\t\text4_io_end_t, list);\n\t\tspin_unlock_irqrestore(&ei->i_completed_io_lock, flags);\n\t\tret = ext4_end_io_nolock(io);\n\t\tspin_lock_irqsave(&ei->i_completed_io_lock, flags);\n\t\tif (ret < 0)\n\t\t\tret2 = ret;\n\t\telse\n\t\t\tlist_del_init(&io->list);\n\t}\n\tspin_unlock_irqrestore(&ei->i_completed_io_lock, flags);\n\treturn (ret2 < 0) ? ret2 : 0;\n}",
        "output": "0",
        "idx": 3173
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseServerAccount(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    cchar       *value;\n\n    if ((value = mprReadJson(prop, \"user\")) != 0) {\n        if (!smatch(value, \"_unchanged_\") && !mprGetDebugMode()) {\n            httpSetGroupAccount(value);\n        }\n    }\n    if ((value = mprReadJson(prop, \"user\")) != 0) {\n        if (!smatch(value, \"_unchanged_\") && !mprGetDebugMode()) {\n            httpSetUserAccount(value);\n        }\n    }\n}",
        "output": "0",
        "idx": 6987
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "netscreen_seek_read(wtap *wth, gint64 seek_off,\n\tstruct wtap_pkthdr *phdr, Buffer *buf,\n\tint *err, gchar **err_info)\n{\n\tchar\t\tline[NETSCREEN_LINE_LENGTH];\n\n\tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {\n\t\treturn FALSE;\n\t}\n\n\tif (file_gets(line, NETSCREEN_LINE_LENGTH, wth->random_fh) == NULL) {\n\t\t*err = file_error(wth->random_fh, err_info);\n\t\tif (*err == 0) {\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\treturn parse_netscreen_packet(wth->random_fh, phdr, buf, line,\n\t    err, err_info);\n}",
        "output": "0",
        "idx": 8367
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline item* limited_get(char *key, size_t nkey, conn *c) {\n    item *it = item_get(key, nkey, c, DO_UPDATE);\n    if (it && it->refcount > IT_REFCOUNT_LIMIT) {\n        item_remove(it);\n        it = NULL;\n    }\n    return it;\n}",
        "output": "0",
        "idx": 4653
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sf_open_fd\t(int fd, int mode, SF_INFO *sfinfo, int close_desc)\n{\tSF_PRIVATE \t*psf ;\n\n\tif ((SF_CONTAINER (sfinfo->format)) == SF_FORMAT_SD2)\n\t{\tsf_errno = SFE_SD2_FD_DISALLOWED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tif ((psf = psf_allocate ()) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;\n\tcopy_filename (psf, \"\") ;\n\n\tpsf->file.mode = mode ;\n\tpsf_set_file (psf, fd) ;\n\tpsf->is_pipe = psf_is_pipe (psf) ;\n\tpsf->fileoffset = psf_ftell (psf) ;\n\n\tif (! close_desc)\n\t\tpsf->file.do_not_close_descriptor = SF_TRUE ;\n\n\treturn psf_open_file (psf, sfinfo) ;\n} ",
        "output": "0",
        "idx": 6915
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cil_reset_classperms_set(struct cil_classperms_set *cp_set)\n{\n\tcil_reset_classpermission(cp_set->set);\n}",
        "output": "1",
        "idx": 6048
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ftrace_filter_lseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t ret;\n\n\tif (file->f_mode & FMODE_READ)\n\t\tret = seq_lseek(file, offset, whence);\n\telse\n\t\tfile->f_pos = ret = 1;\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 1309
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n{\n  size_t i;\n  size_t e;\n\n  if (c->stack == NULL) return;\n  e = c->stack - c->stbase;\n  if (c->ci) e += c->ci->nregs;\n  if (c->stbase + e > c->stend) e = c->stend - c->stbase;\n  for (i=0; i<e; i++) {\n    mrb_value v = c->stbase[i];\n\n    if (!mrb_immediate_p(v)) {\n      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {\n        c->stbase[i] = mrb_nil_value();\n      }\n      else {\n        mrb_gc_mark(mrb, mrb_basic_ptr(v));\n      }\n    }\n  }\n}",
        "output": "1",
        "idx": 6708
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n{\n\treturn usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t       RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,\n\t\t\t       indx, 0, data, size, 500);\n}",
        "output": "1",
        "idx": 1460
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset, int maxoffset) {\n\tbloc = *offset;\n\tsend(huff->loc[ch], NULL, fout, maxoffset);\n\t*offset = bloc;\n}",
        "output": "0",
        "idx": 8753
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BOOL autodetect_recv_bandwidth_measure_results(rdpRdp* rdp, wStream* s,\n                                                      AUTODETECT_RSP_PDU* autodetectRspPdu)\n{\n\tBOOL success = TRUE;\n\n\tif (autodetectRspPdu->headerLength != 0x0E)\n\t\treturn FALSE;\n\n\tWLog_VRB(AUTODETECT_TAG, \"received Bandwidth Measure Results PDU\");\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureTimeDelta); \n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureByteCount); \n\n\tif (rdp->autodetect->bandwidthMeasureTimeDelta > 0)\n\t\trdp->autodetect->netCharBandwidth = rdp->autodetect->bandwidthMeasureByteCount * 8 /\n\t\t                                    rdp->autodetect->bandwidthMeasureTimeDelta;\n\telse\n\t\trdp->autodetect->netCharBandwidth = 0;\n\n\tIFCALLRET(rdp->autodetect->BandwidthMeasureResults, success, rdp->context,\n\t          autodetectRspPdu->sequenceNumber);\n\treturn success;\n}",
        "output": "0",
        "idx": 5715
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *oidc_cache_get_hashed_key(request_rec *r, const char *passphrase,\n\t\tconst char *key) {\n\tchar *input = apr_psprintf(r->pool, \"%s:%s\", passphrase, key);\n\tchar *output = NULL;\n\tif (oidc_util_hash_string_and_base64url_encode(r, OIDC_JOSE_ALG_SHA256,\n\t\t\tinput, &output) == FALSE) {\n\t\toidc_error(r,\n\t\t\t\t\"oidc_util_hash_string_and_base64url_encode returned an error\");\n\t\treturn NULL;\n\t}\n\treturn output;\n}",
        "output": "1",
        "idx": 7340
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n\n\tif (flags & MSG_CMSG_COMPAT)\n\t\treturn -EINVAL;\n\n\tif (timeout == NULL)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n\n\tif (compat_get_timespec(&ktspec, timeout))\n\t\treturn -EFAULT;\n\n\tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && compat_put_timespec(&ktspec, timeout))\n\t\tdatagrams = -EFAULT;\n\n\treturn datagrams;\n}",
        "output": "0",
        "idx": 3463
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "build_config(char *prefix, struct server *server)\n{\n    char *path    = NULL;\n    int path_size = strlen(prefix) + strlen(server->port) + 20;\n\n    path = ss_malloc(path_size);\n    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n    FILE *f = fopen(path, \"w+\");\n    if (f == NULL) {\n        if (verbose) {\n            LOGE(\"unable to open config file\");\n        }\n        ss_free(path);\n        return;\n    }\n    fprintf(f, \"{\\n\");\n    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n    fprintf(f, \"\\n}\\n\");\n    fclose(f);\n    ss_free(path);\n}",
        "output": "1",
        "idx": 6300
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)\n{\n    PadContext *s = inlink->dst->priv;\n\n    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],\n                                         w + (s->w - s->in_w),\n                                         h + (s->h - s->in_h));\n    int plane;\n\n    if (!frame)\n        return NULL;\n\n    frame->width  = w;\n    frame->height = h;\n\n    for (plane = 0; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++) {\n        int hsub = s->draw.hsub[plane];\n        int vsub = s->draw.vsub[plane];\n        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +\n                              (s->y >> vsub) * frame->linesize[plane];\n    }\n\n    return frame;\n}",
        "output": "0",
        "idx": 4937
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_mkdir(const char *path)\n{\n\tsize_t len = strlen(path) + 30;\n\tchar *tmpname = alloca(len);\n\tsnprintf(tmpname, len, \"%s/%d\", path, (int)getpid());\n\n\tif (mkdir(path, 0755) == 0) {\n\t\tfprintf(stderr, \"leak at mkdir of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at mkdir of %s, errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n\tif (mkdir(tmpname, 0755) == 0) {\n\t\tfprintf(stderr, \"leak at mkdir of %s\\n\", tmpname);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at mkdir of %s, errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}",
        "output": "0",
        "idx": 7307
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static enum hrtimer_restart posix_timer_fn(struct hrtimer *timer)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\tint si_private = 0;\n\tenum hrtimer_restart ret = HRTIMER_NORESTART;\n\n\ttimr = container_of(timer, struct k_itimer, it.real.timer);\n\tspin_lock_irqsave(&timr->it_lock, flags);\n\n\ttimr->it_active = 0;\n\tif (timr->it_interval != 0)\n\t\tsi_private = ++timr->it_requeue_pending;\n\n\tif (posix_timer_event(timr, si_private)) {\n\t\tif (timr->it_interval != 0) {\n\t\t\tktime_t now = hrtimer_cb_get_time(timer);\n\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t\t\t{\n\t\t\t\tktime_t kj = NSEC_PER_SEC / HZ;\n\n\t\t\t\tif (timr->it_interval < kj)\n\t\t\t\t\tnow = ktime_add(now, kj);\n\t\t\t}\n#endif\n\t\t\ttimr->it_overrun += (unsigned int)\n\t\t\t\thrtimer_forward(timer, now,\n\t\t\t\t\t\ttimr->it_interval);\n\t\t\tret = HRTIMER_RESTART;\n\t\t\t++timr->it_requeue_pending;\n\t\t\ttimr->it_active = 1;\n\t\t}\n\t}\n\n\tunlock_timer(timr, flags);\n\treturn ret;\n}",
        "output": "1",
        "idx": 2990
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void trustedBlsSignMessageAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,\n                              uint32_t enc_len, char *_hashX,\n                              char *_hashY, char *signature) {\n    LOG_DEBUG(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encryptedPrivateKey);\n    CHECK_STATE(_hashX);\n    CHECK_STATE(_hashY);\n    CHECK_STATE(signature);\n\n    SAFE_CHAR_BUF(key, BUF_LEN);SAFE_CHAR_BUF(sig, BUF_LEN);\n\n    int status = AES_decrypt(encryptedPrivateKey, enc_len, key, BUF_LEN);\n\n    CHECK_STATUS(\"AES decrypt failed\")\n\n    if (!enclave_sign(key, _hashX, _hashY, sig)) {\n        strncpy(errString, \"Enclave failed to create bls signature\", BUF_LEN);\n        LOG_ERROR(errString);\n        *errStatus = -1;\n        goto clean;\n    }\n\n    strncpy(signature, sig, BUF_LEN);\n\n    if (strnlen(signature, BUF_LEN) < 10) {\n        strncpy(errString, \"Signature too short\", BUF_LEN);\n        LOG_ERROR(errString);\n        *errStatus = -1;\n        goto clean;\n    }\n\n    SET_SUCCESS\n\n    LOG_DEBUG(\"SGX call completed\");\n\n    clean:\n    ;\n    LOG_DEBUG(\"SGX call completed\");\n}",
        "output": "1",
        "idx": 8732
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateNull(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}",
        "output": "0",
        "idx": 8315
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "x86_reg X86_insn_reg_intel(unsigned int id, enum cs_ac_type *access)\n{\n\tunsigned int first = 0;\n\tunsigned int last = ARR_SIZE(insn_regs_intel) - 1;\n\tunsigned int mid = ARR_SIZE(insn_regs_intel) / 2;\n\n\tif (!intel_regs_sorted) {\n\t\tmemcpy(insn_regs_intel_sorted, insn_regs_intel,\n\t\t\t\tsizeof(insn_regs_intel_sorted));\n\t\tqsort(insn_regs_intel_sorted,\n\t\t\t\tARR_SIZE(insn_regs_intel_sorted),\n\t\t\t\tsizeof(struct insn_reg), regs_cmp);\n\t\tintel_regs_sorted = true;\n\t}\n\n\twhile (first <= last) {\n\t\tif (insn_regs_intel_sorted[mid].insn < id) {\n\t\t\tfirst = mid + 1;\n\t\t} else if (insn_regs_intel_sorted[mid].insn == id) {\n\t\t\tif (access) {\n\t\t\t\t*access = insn_regs_intel_sorted[mid].access;\n\t\t\t}\n\t\t\treturn insn_regs_intel_sorted[mid].reg;\n\t\t} else {\n\t\t\tif (mid == 0)\n\t\t\t\tbreak;\n\t\t\tlast = mid - 1;\n\t\t}\n\t\tmid = (first + last) / 2;\n\t}\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 6040
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parse_memory(VALUE klass, VALUE data)\n{\n  xmlParserCtxtPtr ctxt;\n\n  if (NIL_P(data)) {\n    rb_raise(rb_eArgError, \"data cannot be nil\");\n  }\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n\n  ctxt = xmlCreateMemoryParserCtxt(StringValuePtr(data),\n                                   (int)RSTRING_LEN(data));\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}",
        "output": "1",
        "idx": 8256
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t available_instances_show(struct mdev_type *mtype,\n\t\t\t\t\tstruct mdev_type_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mtype_get_type_group_id(mtype)];\n\tint count = atomic_read(&mbochs_avail_mbytes) / type->mbytes;\n\n\treturn sprintf(buf, \"%d\\n\", count);\n}",
        "output": "0",
        "idx": 2841
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "init_ccline(int firstc, int indent)\n{\n    ccline.overstrike = FALSE;\t\t    \n\n    ccline.cmdfirstc = (firstc == '@' ? 0 : firstc);\n    ccline.cmdindent = (firstc > 0 ? indent : 0);\n\n    alloc_cmdbuff(indent + 50);\n    if (ccline.cmdbuff == NULL)\n\treturn FAIL;\n    ccline.cmdlen = ccline.cmdpos = 0;\n    ccline.cmdbuff[0] = NUL;\n    sb_text_start_cmdline();\n\n    if (firstc <= 0)\n    {\n\tvim_memset(ccline.cmdbuff, ' ', indent);\n\tccline.cmdbuff[indent] = NUL;\n\tccline.cmdpos = indent;\n\tccline.cmdspos = indent;\n\tccline.cmdlen = indent;\n    }\n\n    return OK;\n}",
        "output": "0",
        "idx": 7965
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IW_IMPL(unsigned int) iw_get_ui32le(const iw_byte *b)\n{\n\treturn b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24);\n}",
        "output": "1",
        "idx": 6644
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "create_pty_only(term_T *term, jobopt_T *opt)\n{\n    create_vterm(term, term->tl_rows, term->tl_cols);\n\n    term->tl_job = job_alloc();\n    if (term->tl_job == NULL)\n\treturn FAIL;\n    ++term->tl_job->jv_refcount;\n\n    term->tl_job->jv_status = JOB_FINISHED;\n\n    return mch_create_pty_channel(term->tl_job, opt);\n}",
        "output": "1",
        "idx": 5842
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void do_free_upto(BIO *f, BIO *upto)\n\t{\n\tif (upto)\n\t\t{\n\t\tBIO *tbio;\n\t\tdo \n\t\t\t{\n\t\t\ttbio = BIO_pop(f);\n\t\t\tBIO_free(f);\n\t\t\tf = tbio;\n\t\t\t}\n\t\twhile (f && f != upto);\n\t\t}\n\telse\n\t\tBIO_free_all(f);\n\t}",
        "output": "0",
        "idx": 6345
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hb_set_subtract (hb_set_t       *set,\n\t\t const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n\n  set->subtract (*other);\n}",
        "output": "1",
        "idx": 5552
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void sctp_copy_descendant(struct sock *sk_to,\n\t\t\t\t\tconst struct sock *sk_from)\n{\n\tint ancestor_size = sizeof(struct inet_sock) +\n\t\t\t    sizeof(struct sctp_sock) -\n\t\t\t    offsetof(struct sctp_sock, auto_asconf_list);\n\n\tif (sk_from->sk_family == PF_INET6)\n\t\tancestor_size += sizeof(struct ipv6_pinfo);\n\n\t__inet_sk_copy_descendant(sk_to, sk_from, ancestor_size);\n}",
        "output": "0",
        "idx": 3969
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_wrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tint conf_req_flag,\n\t\tgss_qop_t qop_req,\n\t\tgss_buffer_t input_message_buffer,\n\t\tint *conf_state,\n\t\tgss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_NO_CONTEXT);\n\n\tret = gss_wrap(minor_status,\n\t\t    sc->ctx_handle,\n\t\t    conf_req_flag,\n\t\t    qop_req,\n\t\t    input_message_buffer,\n\t\t    conf_state,\n\t\t    output_message_buffer);\n\n\treturn (ret);\n}",
        "output": "0",
        "idx": 123
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void labeljumps(JF, js_JumpList *jump, int baddr, int caddr)\n{\n\twhile (jump) {\n\t\tif (jump->type == STM_BREAK)\n\t\t\tlabelto(J, F, jump->inst, baddr);\n\t\tif (jump->type == STM_CONTINUE)\n\t\t\tlabelto(J, F, jump->inst, caddr);\n\t\tjump = jump->next;\n\t}\n}",
        "output": "1",
        "idx": 7426
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int mk_vhost_fdt_close(struct session_request *sr)\n{\n    int id;\n    unsigned int hash;\n    struct vhost_fdt_hash_table *ht = NULL;\n    struct vhost_fdt_hash_chain *hc;\n\n    if (config->fdt == MK_FALSE) {\n        return close(sr->fd_file);\n    }\n\n    id   = sr->vhost_fdt_id;\n    hash = sr->vhost_fdt_hash;\n\n    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);\n    if (mk_unlikely(!ht)) {\n        return close(sr->fd_file);\n    }\n\n    hc = mk_vhost_fdt_chain_lookup(hash, ht);\n    if (hc) {\n        hc->readers--;\n        if (hc->readers == 0) {\n            hc->fd   = -1;\n            hc->hash = 0;\n            ht->av_slots++;\n            return close(sr->fd_file);\n        }\n        else {\n            return 0;\n        }\n    }\n\n    return close(sr->fd_file);\n}",
        "output": "1",
        "idx": 3814
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_seq_device_dev_free(struct snd_device *device)\n{\n\tstruct snd_seq_device *dev = device->device_data;\n\n\tcancel_autoload_drivers();\n\tput_device(&dev->dev);\n\treturn 0;\n}",
        "output": "0",
        "idx": 2387
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateArray( void )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item )\n\t\titem->type = cJSON_Array;\n\treturn item;\n}",
        "output": "1",
        "idx": 5956
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseCertFields(MprBuf *buf, char *prefix, char *prefix2, char *info)\n{\n    char    c, *cp, *term, *key, *value;\n\n    term = cp = info;\n    do {\n        c = *cp;\n        if (c == '/' || c == '\\0') {\n            *cp = '\\0';\n            key = stok(term, \"=\", &value);\n            if (smatch(key, \"emailAddress\")) {\n                key = \"EMAIL\";\n            }\n            mprPutToBuf(buf, \"%s%s%s=%s,\", prefix, prefix2, key, value);\n            term = &cp[1];\n            *cp = c;\n        }\n    } while (*cp++ != '\\0');\n}",
        "output": "1",
        "idx": 5112
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ptrace_triggered(struct perf_event *bp,\n\t\t\t     struct perf_sample_data *data,\n\t\t\t     struct pt_regs *regs)\n{\n\tint i;\n\tstruct thread_struct *thread = &(current->thread);\n\n\tfor (i = 0; i < HBP_NUM; i++) {\n\t\tif (thread->ptrace_bps[i] == bp)\n\t\t\tbreak;\n\t}\n\n\tthread->debugreg6 |= (DR_TRAP0 << i);\n}",
        "output": "0",
        "idx": 667
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t aio_setup_single_vector(struct kiocb *kiocb,\n\t\t\t\t       int rw, char __user *buf,\n\t\t\t\t       unsigned long *nr_segs,\n\t\t\t\t       size_t len,\n\t\t\t\t       struct iovec *iovec)\n{\n\tif (unlikely(!access_ok(!rw, buf, len)))\n\t\treturn -EFAULT;\n\n\tiovec->iov_base = buf;\n\tiovec->iov_len = len;\n\t*nr_segs = 1;\n\treturn 0;\n}",
        "output": "1",
        "idx": 2828
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sunkbd_enable(struct sunkbd *sunkbd, bool enable)\n{\n\tserio_pause_rx(sunkbd->serio);\n\tsunkbd->enabled = enable;\n\tserio_continue_rx(sunkbd->serio);\n\n\tif (!enable) {\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tcancel_work_sync(&sunkbd->tq);\n\t}\n}",
        "output": "0",
        "idx": 2757
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_entry *l2e)\n{\n\tint\terror = 0;\n\tstruct cxio_rdev *rdev;\n\n\trdev = (struct cxio_rdev *)tdev->ulp;\n\tif (cxio_fatal_error(rdev)) {\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\terror = l2t_send(tdev, skb, l2e);\n\tif (error < 0)\n\t\tkfree_skb(skb);\n\treturn error < 0 ? error : 0;\n}",
        "output": "0",
        "idx": 1485
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static pj_status_t STATUS_FROM_SSL_ERR2(char *action, pj_ssl_sock_t *ssock,\n\t\t\t\t\tint ret, int err, int len)\n{\n    unsigned long ssl_err = err;\n\n    if (err == SSL_ERROR_SSL) {\n\tssl_err = ERR_peek_error();\n    }\n\n    SSLLogErrors(action, ret, err, len, ssock);\n\n    ssock->last_err = ssl_err;\n    return GET_STATUS_FROM_SSL_ERR(ssl_err);\n}",
        "output": "1",
        "idx": 8032
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int getnum (const char **fmt, int df) {\n  if (!isdigit(**fmt))  \n    return df;  \n  else {\n    int a = 0;\n    do {\n      a = a*10 + *((*fmt)++) - '0';\n    } while (isdigit(**fmt));\n    return a;\n  }\n}",
        "output": "0",
        "idx": 5097
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int btrfs_scrub_progress(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t struct btrfs_scrub_progress *progress)\n{\n\tstruct btrfs_device *dev;\n\tstruct scrub_ctx *sctx = NULL;\n\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL);\n\tif (dev)\n\t\tsctx = dev->scrub_ctx;\n\tif (sctx)\n\t\tmemcpy(progress, &sctx->stat, sizeof(*progress));\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\n\treturn dev ? (sctx ? 0 : -ENOTCONN) : -ENODEV;\n}",
        "output": "1",
        "idx": 3090
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC void mprDefaultLogHandler(cchar *tags, int level, cchar *msg)\n{\n    MprFile     *file;\n    char        tbuf[128];\n    static int  check = 0;\n\n    if ((file = MPR->logFile) == 0) {\n        return;\n    }\n    if (MPR->logBackup && MPR->logSize && (check++ % 1000) == 0) {\n        backupLog();\n    }\n    if (tags && *tags) {\n        if (MPR->flags & MPR_LOG_DETAILED) {\n            fmt(tbuf, sizeof(tbuf), \"%s %d %s, \", mprGetDate(MPR_LOG_DATE), level, tags);\n            mprWriteFileString(file, tbuf);\n        } else if (MPR->flags & MPR_LOG_TAGGED) {\n            if (schr(tags, ' ')) {\n                tags = ssplit(sclone(tags), \" \", NULL);\n            }\n            if (!isupper((uchar) *tags)) {\n                tags = stitle(tags);\n            }\n            mprWriteFileFmt(file, \"%12s \", sfmt(\"[%s]\", tags));\n        }\n    }\n    mprWriteFileString(file, msg);\n    mprWriteFileString(file, \"\\n\");\n#if ME_MPR_OSLOG\n    if (level == 0) {\n        mprWriteToOsLog(sfmt(\"%s: %d %s: %s\", MPR->name, level, tags, msg), level);\n    }\n#endif\n}",
        "output": "0",
        "idx": 7073
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cxusb_ctrl_msg(struct dvb_usb_device *d,\n\t\t\t  u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)\n{\n\tstruct cxusb_state *st = d->priv;\n\tint ret, wo;\n\n\tif (1 + wlen > MAX_XFER_SIZE) {\n\t\twarn(\"i2c wr: len=%d is too big!\\n\", wlen);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\two = (rbuf == NULL || rlen == 0); \n\n\tmutex_lock(&d->data_mutex);\n\tst->data[0] = cmd;\n\tmemcpy(&st->data[1], wbuf, wlen);\n\tif (wo)\n\t\tret = dvb_usb_generic_write(d, st->data, 1 + wlen);\n\telse\n\t\tret = dvb_usb_generic_rw(d, st->data, 1 + wlen,\n\t\t\t\t\t rbuf, rlen, 0);\n\n\tmutex_unlock(&d->data_mutex);\n\treturn ret;\n}",
        "output": "1",
        "idx": 1470
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u64 __skb_get_nlattr_nest(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\tstruct nlattr *nla;\n\n\tif (skb_is_nonlinear(skb))\n\t\treturn 0;\n\n\tif (skb->len < sizeof(struct nlattr))\n\t\treturn 0;\n\n\tif (A > skb->len - sizeof(struct nlattr))\n\t\treturn 0;\n\n\tnla = (struct nlattr *) &skb->data[A];\n\tif (nla->nla_len > skb->len - A)\n\t\treturn 0;\n\n\tnla = nla_find_nested(nla, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 3505
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_msgtype_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\tif (length < 2) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_msgtype2str, \"MSGTYPE-#%u\",\n\t    EXTRACT_16BITS(ptr))));\n}",
        "output": "0",
        "idx": 6653
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vhost_scsi_send_evt(struct vhost_scsi *vs,\n\t\t   struct vhost_scsi_tpg *tpg,\n\t\t   struct se_lun *lun,\n\t\t   u32 event,\n\t\t   u32 reason)\n{\n\tstruct vhost_scsi_evt *evt;\n\n\tevt = vhost_scsi_allocate_evt(vs, event, reason);\n\tif (!evt)\n\t\treturn;\n\n\tif (tpg && lun) {\n\t\tevt->event.lun[0] = 0x01;\n\t\tevt->event.lun[1] = tpg->tport_tpgt;\n\t\tif (lun->unpacked_lun >= 256)\n\t\t\tevt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;\n\t\tevt->event.lun[3] = lun->unpacked_lun & 0xFF;\n\t}\n\n\tllist_add(&evt->list, &vs->vs_event_list);\n\tvhost_work_queue(&vs->dev, &vs->vs_event_work);\n}",
        "output": "0",
        "idx": 3861
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "exit_ext2_xattr(void)\n{\n}",
        "output": "1",
        "idx": 1126
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long madvise_willneed(struct vm_area_struct *vma,\n\t\t\t     struct vm_area_struct **prev,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tstruct file *file = vma->vm_file;\n\n#ifdef CONFIG_SWAP\n\tif (!file) {\n\t\t*prev = vma;\n\t\tforce_swapin_readahead(vma, start, end);\n\t\treturn 0;\n\t}\n\n\tif (shmem_mapping(file->f_mapping)) {\n\t\t*prev = vma;\n\t\tforce_shm_swapin_readahead(vma, start, end,\n\t\t\t\t\tfile->f_mapping);\n\t\treturn 0;\n\t}\n#else\n\tif (!file)\n\t\treturn -EBADF;\n#endif\n\n\tif (IS_DAX(file_inode(file))) {\n\t\treturn 0;\n\t}\n\n\t*prev = vma;\n\tstart = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tif (end > vma->vm_end)\n\t\tend = vma->vm_end;\n\tend = ((end - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\n\tforce_page_cache_readahead(file->f_mapping, file, start, end - start);\n\treturn 0;\n}",
        "output": "1",
        "idx": 1784
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void f2fs_swap_deactivate(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\n\tclear_inode_flag(inode, FI_PIN_FILE);\n}",
        "output": "0",
        "idx": 4425
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void clear_evtchn_to_irq_row(unsigned row)\n{\n\tunsigned col;\n\n\tfor (col = 0; col < EVTCHN_PER_ROW; col++)\n\t\tevtchn_to_irq[row][col] = -1;\n}",
        "output": "1",
        "idx": 1884
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)\n{\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tunsigned char *p;\n\tint ok = 0;\n\tint r;\n\tsize_t len;\n\n\tsc_format_path(str_path, &path);\n\tif (SC_SUCCESS != sc_select_file(card, &path, &file)) {\n\t\tgoto err;\n\t}\n\n\tlen = file ? file->size : 4096;\n\tp = realloc(*data, len);\n\tif (!p) {\n\t\tgoto err;\n\t}\n\t*data = p;\n\t*data_len = len;\n\n\tr = sc_read_binary(card, 0, p, len, 0);\n\tif (r < 0)\n\t\tgoto err;\n\n\t*data_len = r;\n\tok = 1;\n\nerr:\n\tsc_file_free(file);\n\n\treturn ok;\n}",
        "output": "1",
        "idx": 7032
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __u8 *sp_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 107 && rdesc[104] == 0x26 && rdesc[105] == 0x80 &&\n\t\t\trdesc[106] == 0x03) {\n\t\thid_info(hdev, \"fixing up Sunplus Wireless Desktop report descriptor\\n\");\n\t\trdesc[105] = rdesc[110] = 0x03;\n\t\trdesc[106] = rdesc[111] = 0x21;\n\t}\n\treturn rdesc;\n}",
        "output": "1",
        "idx": 2654
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ast2obj_alias(void* _o)\n{\n    alias_ty o = (alias_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n\n    result = PyType_GenericNew(alias_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_identifier(o->name);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_name, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_identifier(o->asname);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_asname, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    return result;\nfailed:\n    Py_XDECREF(value);\n    Py_XDECREF(result);\n    return NULL;\n}",
        "output": "1",
        "idx": 7726
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool HHVM_FUNCTION(mb_parse_str,\n                   const String& encoded_string,\n                   VRefParam result ) {\n  php_mb_encoding_handler_info_t info;\n  info.data_type              = PARSE_STRING;\n  info.separator              = \";&\";\n  info.force_register_globals = false;\n  info.report_errors          = 1;\n  info.to_encoding            = MBSTRG(current_internal_encoding);\n  info.to_language            = MBSTRG(current_language);\n  info.from_encodings         = MBSTRG(http_input_list);\n  info.num_from_encodings     = MBSTRG(http_input_list_size);\n  info.from_language          = MBSTRG(current_language);\n\n  char *encstr = req::strndup(encoded_string.data(), encoded_string.size());\n  Array resultArr = Array::Create();\n  mbfl_encoding *detected =\n    _php_mb_encoding_handler_ex(&info, resultArr, encstr);\n  req::free(encstr);\n  result.assignIfRef(resultArr);\n\n  MBSTRG(http_input_identify) = detected;\n  return detected != nullptr;\n}",
        "output": "0",
        "idx": 6333
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "asmlinkage long compat_sys_ptrace(compat_long_t request, compat_long_t pid,\n\t\t\t\t  compat_long_t addr, compat_long_t data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tgoto out;\n\t}\n\n\tchild = ptrace_get_task_struct(pid);\n\tif (IS_ERR(child)) {\n\t\tret = PTR_ERR(child);\n\t\tgoto out;\n\t}\n\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(child);\n\t\tgoto out_put_task_struct;\n\t}\n\n\tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n\t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (!ret)\n\t\tret = compat_arch_ptrace(child, request, addr, data);\n\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}",
        "output": "1",
        "idx": 818
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void finish_object(struct object *obj, const char *name, void *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tif (obj->type == OBJ_BLOB && !has_object_file(&obj->oid))\n\t\tdie(\"missing blob object '%s'\", oid_to_hex(&obj->oid));\n\tif (info->revs->verify_objects && !obj->parsed && obj->type != OBJ_COMMIT)\n\t\tparse_object(obj->oid.hash);\n}",
        "output": "0",
        "idx": 7225
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool can_skip_alu_sanitation(const struct bpf_verifier_env *env,\n\t\t\t\t    const struct bpf_insn *insn)\n{\n\treturn env->allow_ptr_leaks || BPF_SRC(insn->code) == BPF_K;\n}",
        "output": "0",
        "idx": 4221
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bt_for_each(struct blk_mq_hw_ctx *hctx,\n\t\tstruct blk_mq_bitmap_tags *bt, unsigned int off,\n\t\tbusy_iter_fn *fn, void *data, bool reserved)\n{\n\tstruct request *rq;\n\tint bit, i;\n\n\tfor (i = 0; i < bt->map_nr; i++) {\n\t\tstruct blk_align_bitmap *bm = &bt->map[i];\n\n\t\tfor (bit = find_first_bit(&bm->word, bm->depth);\n\t\t     bit < bm->depth;\n\t\t     bit = find_next_bit(&bm->word, bm->depth, bit + 1)) {\n\t\t\trq = hctx->tags->rqs[off + bit];\n\t\t\tif (rq->q == hctx->queue)\n\t\t\t\tfn(hctx, rq, data, reserved);\n\t\t}\n\n\t\toff += (1 << bt->bits_per_word);\n\t}\n}",
        "output": "0",
        "idx": 3991
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\t#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS\n\tif (cpu_feature_enabled(X86_FEATURE_OSPKE)) {\n\t\tmm->context.pkey_allocation_map = 0x1;\n\t\tmm->context.execute_only_pkey = -1;\n\t}\n\t#endif\n\treturn init_new_context_ldt(tsk, mm);\n}",
        "output": "0",
        "idx": 2381
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xen_free_irq(unsigned irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\tunsigned long flags;\n\n\tif (WARN_ON(!info))\n\t\treturn;\n\n\twrite_lock_irqsave(&evtchn_rwlock, flags);\n\n\tif (!list_empty(&info->eoi_list))\n\t\tlateeoi_list_del(info);\n\n\tlist_del(&info->list);\n\n\tset_info_for_irq(irq, NULL);\n\n\tWARN_ON(info->refcnt > 0);\n\n\twrite_unlock_irqrestore(&evtchn_rwlock, flags);\n\n\tkfree(info);\n\n\tif (irq < nr_legacy_irqs())\n\t\treturn;\n\n\tirq_free_desc(irq);\n}",
        "output": "0",
        "idx": 2735
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_marker (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} ",
        "output": "1",
        "idx": 4930
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jas_iccgetuint(jas_stream_t *in, int n, jas_ulonglong *val)\n{\n\tint i;\n\tint c;\n\tjas_ulonglong v;\n\tv = 0;\n\tfor (i = n; i > 0; --i) {\n\t\tif ((c = jas_stream_getc(in)) == EOF)\n\t\t\treturn -1;\n\t\tv = (v << 8) | c;\n\t}\n\t*val = v;\n\treturn 0;\n}",
        "output": "0",
        "idx": 7545
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *ndev)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(ndev);\n\n\tassert(skb->queue_mapping < ndev->ae_handle->q_num);\n\n\treturn hns_nic_net_xmit_hw(ndev, skb,\n\t\t\t\t   &tx_ring_data(priv, skb->queue_mapping));\n}",
        "output": "0",
        "idx": 2357
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool_t enc28j60IrqHandler(NetInterface *interface)\n{\n   bool_t flag;\n   uint8_t status;\n\n   flag = FALSE;\n\n   enc28j60ClearBit(interface, ENC28J60_REG_EIE, EIE_INTIE);\n\n   status = enc28j60ReadReg(interface, ENC28J60_REG_EIR);\n\n   if((status & EIR_LINKIF) != 0)\n   {\n      enc28j60ClearBit(interface, ENC28J60_REG_EIE, EIE_LINKIE);\n\n      interface->nicEvent = TRUE;\n      flag |= osSetEventFromIsr(&netEvent);\n   }\n\n   if((status & EIR_PKTIF) != 0)\n   {\n      enc28j60ClearBit(interface, ENC28J60_REG_EIE, EIE_PKTIE);\n\n      interface->nicEvent = TRUE;\n      flag |= osSetEventFromIsr(&netEvent);\n   }\n\n   if((status & (EIR_TXIF | EIE_TXERIE)) != 0)\n   {\n      enc28j60ClearBit(interface, ENC28J60_REG_EIR, EIR_TXIF | EIE_TXERIE);\n\n      flag |= osSetEventFromIsr(&interface->nicTxEvent);\n   }\n\n   enc28j60SetBit(interface, ENC28J60_REG_EIE, EIE_INTIE);\n\n   return flag;\n}",
        "output": "1",
        "idx": 8540
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Map1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,\n        SDL_PixelFormat * dst)\n{\n    Uint8 *map;\n    int i;\n    int bpp;\n    SDL_Palette *pal = src->palette;\n\n    bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);\n    map = (Uint8 *) SDL_malloc(pal->ncolors * bpp);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n\n    for (i = 0; i < pal->ncolors; ++i) {\n        Uint8 R = (Uint8) ((pal->colors[i].r * Rmod) / 255);\n        Uint8 G = (Uint8) ((pal->colors[i].g * Gmod) / 255);\n        Uint8 B = (Uint8) ((pal->colors[i].b * Bmod) / 255);\n        Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255);\n        ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A);\n    }\n    return (map);\n}",
        "output": "1",
        "idx": 8692
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fixExec2Error(int action,\n             u_char * var_val,\n             u_char var_val_type,\n             size_t var_val_len,\n             u_char * statP, oid * name, size_t name_len)\n{\n    netsnmp_old_extend *exten = NULL;\n    unsigned int idx;\n\n    idx = name[name_len-1] -1;\n    exten = &compatability_entries[ idx ];\n\n#ifndef NETSNMP_NO_WRITE_SUPPORT\n    switch (action) {\n    case MODE_SET_RESERVE1:\n        if (var_val_type != ASN_INTEGER) {\n            snmp_log(LOG_ERR, \"Wrong type != int\\n\");\n            return SNMP_ERR_WRONGTYPE;\n        }\n        idx = *((long *) var_val);\n        if (idx != 1) {\n            snmp_log(LOG_ERR, \"Wrong value != 1\\n\");\n            return SNMP_ERR_WRONGVALUE;\n        }\n        if (!exten || !exten->efix_entry) {\n            snmp_log(LOG_ERR, \"No command to run\\n\");\n            return SNMP_ERR_GENERR;\n        }\n        return SNMP_ERR_NOERROR;\n\n    case MODE_SET_COMMIT:\n        netsnmp_cache_check_and_reload( exten->efix_entry->cache );\n    }\n#endif \n    return SNMP_ERR_NOERROR;\n}",
        "output": "1",
        "idx": 7822
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ext4_io_end_t *ext4_init_io_end (struct inode *inode)\n{\n\text4_io_end_t *io = NULL;\n\n\tio = kmalloc(sizeof(*io), GFP_NOFS);\n\n\tif (io) {\n\t\tigrab(inode);\n\t\tio->inode = inode;\n\t\tio->flag = 0;\n\t\tio->offset = 0;\n\t\tio->size = 0;\n\t\tio->error = 0;\n\t\tINIT_WORK(&io->work, ext4_end_io_work);\n\t\tINIT_LIST_HEAD(&io->list);\n\t}\n\n\treturn io;\n}",
        "output": "1",
        "idx": 2228
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ntlm_populate_message_header(NTLM_MESSAGE_HEADER* header, UINT32 MessageType)\n{\n\tCopyMemory(header->Signature, NTLM_SIGNATURE, sizeof(NTLM_SIGNATURE));\n\theader->MessageType = MessageType;\n}",
        "output": "1",
        "idx": 4198
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hybiPayloadStart(ws_ctx_t *wsctx)\n{\n  return wsctx->codeBufDecode + wsctx->header.headerLen;\n}",
        "output": "0",
        "idx": 8899
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void controloptions (lua_State *L, int opt, const char **fmt,\n                            Header *h) {\n  switch (opt) {\n    case  ' ': return;  \n    case '>': h->endian = BIG; return;\n    case '<': h->endian = LITTLE; return;\n    case '!': {\n      int a = getnum(fmt, MAXALIGN);\n      if (!isp2(a))\n        luaL_error(L, \"alignment %d is not a power of 2\", a);\n      h->align = a;\n      return;\n    }\n    default: {\n      const char *msg = lua_pushfstring(L, \"invalid format option '%c'\", opt);\n      luaL_argerror(L, 1, msg);\n    }\n  }\n}",
        "output": "0",
        "idx": 5101
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool check_underflow(const struct ipt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\n\tif (!unconditional(e))\n\t\treturn false;\n\tt = ipt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}",
        "output": "0",
        "idx": 1759
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int do_set_thread_area(struct task_struct *p, int idx,\n\t\t       struct user_desc __user *u_info,\n\t\t       int can_allocate)\n{\n\tstruct user_desc info;\n\n\tif (copy_from_user(&info, u_info, sizeof(info)))\n\t\treturn -EFAULT;\n\n\tif (!tls_desc_okay(&info))\n\t\treturn -EINVAL;\n\n\tif (idx == -1)\n\t\tidx = info.entry_number;\n\n\tif (idx == -1 && can_allocate) {\n\t\tidx = get_free_idx();\n\t\tif (idx < 0)\n\t\t\treturn idx;\n\t\tif (put_user(idx, &u_info->entry_number))\n\t\t\treturn -EFAULT;\n\t}\n\n\tif (idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX)\n\t\treturn -EINVAL;\n\n\tset_tls_desc(p, idx, &info, 1);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 3775
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "isakmp_rfc3948_print(netdissect_options *ndo,\n\t\t     const u_char *bp, u_int length,\n\t\t     const u_char *bp2)\n{\n\n\tif(length == 1 && bp[0]==0xff) {\n\t\tND_PRINT((ndo, \"isakmp-nat-keep-alive\"));\n\t\treturn;\n\t}\n\n\tif(length < 4) {\n\t\tgoto trunc;\n\t}\n\n\tif(bp[0]==0 && bp[1]==0 && bp[2]==0 && bp[3]==0) {\n\t\tND_PRINT((ndo, \"NONESP-encap: \"));\n\t\tisakmp_print(ndo, bp+4, length-4, bp2);\n\t\treturn;\n\t}\n\n\t{\n\t\tint nh, enh, padlen;\n\t\tint advance;\n\n\t\tND_PRINT((ndo, \"UDP-encap: \"));\n\n\t\tadvance = esp_print(ndo, bp, length, bp2, &enh, &padlen);\n\t\tif(advance <= 0)\n\t\t\treturn;\n\n\t\tbp += advance;\n\t\tlength -= advance + padlen;\n\t\tnh = enh & 0xff;\n\n\t\tip_print_inner(ndo, bp, length, nh, bp2);\n\t\treturn;\n\t}\n\ntrunc:\n\tND_PRINT((ndo,\"[|isakmp]\"));\n\treturn;\n}",
        "output": "1",
        "idx": 4668
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)\n{\n\tirda_queue_t* queue;\n\tunsigned long flags = 0;\n\tint i;\n\n\tIRDA_ASSERT(hashbin != NULL, return -1;);\n\tIRDA_ASSERT(hashbin->magic == HB_MAGIC, return -1;);\n\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_lock_irqsave_nested(&hashbin->hb_spinlock, flags,\n\t\t\t\t\t hashbin_lock_depth++);\n\t}\n\n\tfor (i = 0; i < HASHBIN_SIZE; i ++ ) {\n\t\tqueue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);\n\t\twhile (queue ) {\n\t\t\tif (free_func)\n\t\t\t\t(*free_func)(queue);\n\t\t\tqueue = dequeue_first(\n\t\t\t\t(irda_queue_t**) &hashbin->hb_queue[i]);\n\t\t}\n\t}\n\n\thashbin->hb_current = NULL;\n\thashbin->magic = ~HB_MAGIC;\n\n\tif ( hashbin->hb_type & HB_LOCK) {\n\t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n#ifdef CONFIG_LOCKDEP\n\t\thashbin_lock_depth--;\n#endif\n\t}\n\n\tkfree(hashbin);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1484
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_event_mmap_output(struct perf_event *event,\n\t\t\t\t     struct perf_mmap_event *mmap_event)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint size = mmap_event->event_id.header.size;\n\tint ret;\n\n\tperf_event_header__init_id(&mmap_event->event_id.header, &sample, event);\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tmmap_event->event_id.header.size, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tmmap_event->event_id.pid = perf_event_pid(event, current);\n\tmmap_event->event_id.tid = perf_event_tid(event, current);\n\n\tperf_output_put(&handle, mmap_event->event_id);\n\t__output_copy(&handle, mmap_event->file_name,\n\t\t\t\t   mmap_event->file_size);\n\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\nout:\n\tmmap_event->event_id.header.size = size;\n}",
        "output": "0",
        "idx": 693
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int rm_rf_child(int fd, const char *name, RemoveFlags flags) {\n\n\n        if (fd < 0)\n                return -EBADF;\n\n        if (!filename_is_valid(name))\n                return -EINVAL;\n\n        if ((flags & (REMOVE_ROOT|REMOVE_MISSING_OK)) != 0) \n                return -EINVAL;\n\n        if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))\n                return -EINVAL;\n\n        return rm_rf_children_inner(fd, name, -1, flags, NULL);\n}",
        "output": "1",
        "idx": 5498
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __net_exit sctp_net_exit(struct net *net)\n{\n\tsctp_free_addr_wq(net);\n\tsctp_free_local_addr_list(net);\n\n\tinet_ctl_sock_destroy(net->sctp.ctl_sock);\n\n\tsctp_dbg_objcnt_exit(net);\n\n\tsctp_proc_exit(net);\n\tcleanup_sctp_mibs(net);\n\tsctp_sysctl_net_unregister(net);\n}",
        "output": "1",
        "idx": 2908
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int perf_trace_event_perm(struct ftrace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tif (ftrace_event_is_function(tp_event) &&\n\t    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))\n\t\treturn 0;\n\n\tif (p_event->attach_state == PERF_ATTACH_TASK) {\n\t\tif (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)\n\t\t\treturn 0;\n\t}\n\n\tif (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 2366
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void send(node_t *node, node_t *child, byte *fout, int maxoffset) {\n\tif (node->parent) {\n\t\tsend(node->parent, node, fout, maxoffset);\n\t}\n\tif (child) {\n\t\tif (bloc >= maxoffset) {\n\t\t\tbloc = maxoffset + 1;\n\t\t\treturn;\n\t\t}\n\t\tif (node->right == child) {\n\t\t\tadd_bit(1, fout);\n\t\t} else {\n\t\t\tadd_bit(0, fout);\n\t\t}\n\t}\n}",
        "output": "0",
        "idx": 8749
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vhost_net_ubuf_put_and_wait(struct vhost_net_ubuf_ref *ubufs)\n{\n\tkref_put(&ubufs->kref, vhost_net_zerocopy_done_signal);\n\twait_event(ubufs->wait, !atomic_read(&ubufs->kref.refcount));\n}",
        "output": "0",
        "idx": 3287
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct siginfo info;\n\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_TKILL;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\treturn do_send_specific(tgid, pid, sig, &info);\n}",
        "output": "1",
        "idx": 908
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,\n                           const uint8_t *name, uint8_t *dst, int dst_size)\n{\n    GetByteContext gb;\n\n    if (data >= data_end)\n        return -1;\n\n    bytestream2_init(&gb, data, data_end - data);\n\n    return amf_get_field_value2(&gb, name, dst, dst_size);\n}",
        "output": "0",
        "idx": 4885
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char *cJSON_GetErrorPtr( void )\n{\n\treturn ep;\n}",
        "output": "1",
        "idx": 5882
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned int seedsize(struct crypto_alg *alg)\n{\n\tstruct rng_alg *ralg = container_of(alg, struct rng_alg, base);\n\n\treturn alg->cra_rng.rng_make_random ?\n\t       alg->cra_rng.seedsize : ralg->seedsize;\n}",
        "output": "1",
        "idx": 2842
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int uas_find_uas_alt_setting(struct usb_interface *intf)\n{\n\tint i;\n\n\tfor (i = 0; i < intf->num_altsetting; i++) {\n\t\tstruct usb_host_interface *alt = &intf->altsetting[i];\n\n\t\tif (uas_is_interface(alt))\n\t\t\treturn alt->desc.bAlternateSetting;\n\t}\n\n\treturn -ENODEV;\n}",
        "output": "1",
        "idx": 1670
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void pjsua_init_tpselector(pjsua_transport_id tp_id,\n\t\t\t   pjsip_tpselector *sel)\n{\n    pjsua_transport_data *tpdata;\n    unsigned flag;\n\n    pj_bzero(sel, sizeof(*sel));\n    if (tp_id == PJSUA_INVALID_ID)\n\treturn;\n\n    pj_assert(tp_id >= 0 && tp_id < (int)PJ_ARRAY_SIZE(pjsua_var.tpdata));\n    tpdata = &pjsua_var.tpdata[tp_id];\n\n    flag = pjsip_transport_get_flag_from_type(tpdata->type);\n\n    if (flag & PJSIP_TRANSPORT_DATAGRAM) {\n\tsel->type = PJSIP_TPSELECTOR_TRANSPORT;\n\tsel->u.transport = tpdata->data.tp;\n    } else {\n\tsel->type = PJSIP_TPSELECTOR_LISTENER;\n\tsel->u.listener = tpdata->data.factory;\n    }\n}",
        "output": "1",
        "idx": 8060
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_result_code_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\tif (length < 2) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tND_PRINT((ndo, \"%u\", EXTRACT_16BITS(ptr)));\n\tptr++;\n\tlength -= 2;\n\n\tif (length == 0)\n\t\treturn;\n\tif (length < 2) {\n\t\tND_PRINT((ndo, \" AVP too short\"));\n\t\treturn;\n\t}\n\tND_PRINT((ndo, \"/%u\", EXTRACT_16BITS(ptr)));\n\tptr++;\n\tlength -= 2;\n\n\tif (length == 0)\n\t\treturn;\n\tND_PRINT((ndo, \" \"));\n\tprint_string(ndo, (const u_char *)ptr, length);\n}",
        "output": "0",
        "idx": 6661
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PyMemoTable_Copy(PyMemoTable *self)\n{\n    Py_ssize_t i;\n    PyMemoTable *new = PyMemoTable_New();\n    if (new == NULL)\n        return NULL;\n\n    new->mt_used = self->mt_used;\n    new->mt_allocated = self->mt_allocated;\n    new->mt_mask = self->mt_mask;\n    PyMem_FREE(new->mt_table);\n    new->mt_table = PyMem_NEW(PyMemoEntry, self->mt_allocated);\n    if (new->mt_table == NULL) {\n        PyMem_FREE(new);\n        PyErr_NoMemory();\n        return NULL;\n    }\n    for (i = 0; i < self->mt_allocated; i++) {\n        Py_XINCREF(self->mt_table[i].me_key);\n    }\n    memcpy(new->mt_table, self->mt_table,\n           sizeof(PyMemoEntry) * self->mt_allocated);\n\n    return new;\n}",
        "output": "1",
        "idx": 7150
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_set_sec_context_option(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t *context_handle,\n\t\tconst gss_OID desired_object,\n\t\tconst gss_buffer_t value)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)*context_handle;\n\n\tif (sc == NULL || sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_UNAVAILABLE);\n\n\tret = gss_set_sec_context_option(minor_status,\n\t\t\t    &sc->ctx_handle,\n\t\t\t    desired_object,\n\t\t\t    value);\n\treturn (ret);\n}",
        "output": "0",
        "idx": 111
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "arg(identifier arg, expr_ty annotation, int lineno, int col_offset, int\n    end_lineno, int end_col_offset, PyArena *arena)\n{\n    arg_ty p;\n    if (!arg) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field arg is required for arg\");\n        return NULL;\n    }\n    p = (arg_ty)PyArena_Malloc(arena, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->arg = arg;\n    p->annotation = annotation;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    p->end_lineno = end_lineno;\n    p->end_col_offset = end_col_offset;\n    return p;\n}",
        "output": "1",
        "idx": 7170
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_restricted(void)\n{\n    if (restricted)\n    {\n\temsg(_(\"E145: Shell commands not allowed in rvim\"));\n\treturn TRUE;\n    }\n    return FALSE;\n}",
        "output": "1",
        "idx": 5854
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mm_zfree(struct mm_master *mm, void *address)\n{\n\tmm_free(mm, address);\n}",
        "output": "1",
        "idx": 5568
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n{\n\t_gdImageGifCtx(im, out);\n}",
        "output": "0",
        "idx": 5691
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dump_completed_IO(struct inode * inode)\n{\n#ifdef\tEXT4_DEBUG\n\tstruct list_head *cur, *before, *after;\n\text4_io_end_t *io, *io0, *io1;\n\tunsigned long flags;\n\n\tif (list_empty(&EXT4_I(inode)->i_completed_io_list)){\n\t\text4_debug(\"inode %lu completed_io list is empty\\n\", inode->i_ino);\n\t\treturn;\n\t}\n\n\text4_debug(\"Dump inode %lu completed_io list \\n\", inode->i_ino);\n\tspin_lock_irqsave(&EXT4_I(inode)->i_completed_io_lock, flags);\n\tlist_for_each_entry(io, &EXT4_I(inode)->i_completed_io_list, list){\n\t\tcur = &io->list;\n\t\tbefore = cur->prev;\n\t\tio0 = container_of(before, ext4_io_end_t, list);\n\t\tafter = cur->next;\n\t\tio1 = container_of(after, ext4_io_end_t, list);\n\n\t\text4_debug(\"io 0x%p from inode %lu,prev 0x%p,next 0x%p\\n\",\n\t\t\t    io, inode->i_ino, io0, io1);\n\t}\n\tspin_unlock_irqrestore(&EXT4_I(inode)->i_completed_io_lock, flags);\n#endif\n}",
        "output": "0",
        "idx": 3159
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xen_free_irq(unsigned irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\tunsigned long flags;\n\n\tif (WARN_ON(!info))\n\t\treturn;\n\n\twrite_lock_irqsave(&evtchn_rwlock, flags);\n\n\tlist_del(&info->list);\n\n\tset_info_for_irq(irq, NULL);\n\n\tWARN_ON(info->refcnt > 0);\n\n\twrite_unlock_irqrestore(&evtchn_rwlock, flags);\n\n\tkfree(info);\n\n\tif (irq < nr_legacy_irqs())\n\t\treturn;\n\n\tirq_free_desc(irq);\n}",
        "output": "0",
        "idx": 2709
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC void httpSetParam(HttpConn *conn, cchar *var, cchar *value) \n{\n    mprWriteJson(httpGetParams(conn), var, value);\n}",
        "output": "0",
        "idx": 7051
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void setup_test_dir(char *tmp_dir, const char *files, ...) {\n        va_list ap;\n\n        assert_se(mkdtemp(tmp_dir) != NULL);\n\n        va_start(ap, files);\n        while (files != NULL) {\n                _cleanup_free_ char *path = strappend(tmp_dir, files);\n                assert_se(touch_file(path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0) == 0);\n                files = va_arg(ap, const char *);\n        }\n        va_end(ap);\n}",
        "output": "1",
        "idx": 5484
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb)\n{\n\n    s->avctx->profile = get_bits(gb, 4);\n    s->avctx->level   = get_bits(gb, 4);\n\n    if (s->avctx->profile == 0 && s->avctx->level == 8) {\n        s->avctx->level = 0;\n    }\n\n    return 0;\n}",
        "output": "1",
        "idx": 3406
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *ndev)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(ndev);\n\tint ret;\n\n\tassert(skb->queue_mapping < ndev->ae_handle->q_num);\n\tret = hns_nic_net_xmit_hw(ndev, skb,\n\t\t\t\t  &tx_ring_data(priv, skb->queue_mapping));\n\tif (ret == NETDEV_TX_OK) {\n\t\tnetif_trans_update(ndev);\n\t\tndev->stats.tx_bytes += skb->len;\n\t\tndev->stats.tx_packets++;\n\t}\n\treturn (netdev_tx_t)ret;\n}",
        "output": "1",
        "idx": 1628
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, eof)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_BOOL(php_stream_eof(intern->u.file.stream));\n} ",
        "output": "1",
        "idx": 3948
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool check_underflow(const struct arpt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\n\tif (!unconditional(e))\n\t\treturn false;\n\tt = arpt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}",
        "output": "0",
        "idx": 1749
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)\n{\n\tconst char *end=0,**ep=return_parse_end?return_parse_end:&global_ep;\n\tcJSON *c=cJSON_New_Item();\n\t*ep=0;\n\tif (!c) return 0;       \n\n\tend=parse_value(c,skip(value),ep);\n\tif (!end)\t{cJSON_Delete(c);return 0;}\t\n\n\tif (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);*ep=end;return 0;}}\n\tif (return_parse_end) *return_parse_end=end;\n\treturn c;\n}",
        "output": "0",
        "idx": 8253
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ParseNameValue(const char * buffer, int bufsize,\n               struct NameValueParserData * data)\n{\n\tstruct xmlparser parser;\n\tdata->l_head = NULL;\n\tdata->portListing = NULL;\n\tdata->portListingLength = 0;\n\tparser.xmlstart = buffer;\n\tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}",
        "output": "1",
        "idx": 4576
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rose_stop_idletimer(struct sock *sk)\n{\n\tsk_stop_timer(sk, &rose_sk(sk)->idletimer);\n}",
        "output": "0",
        "idx": 2965
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ast_for_async_funcdef(struct compiling *c, const node *n, asdl_seq *decorator_seq)\n{\n    REQ(n, async_funcdef);\n    REQ(CHILD(n, 0), ASYNC);\n    REQ(CHILD(n, 1), funcdef);\n\n    return ast_for_funcdef_impl(c, CHILD(n, 1), decorator_seq,\n                                1 );\n}",
        "output": "1",
        "idx": 7752
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,\n\t\t\tint len)\n{\n\tint r;\n\tunsigned long addr;\n\n\taddr = gfn_to_hva(kvm, gfn);\n\tif (kvm_is_error_hva(addr))\n\t\treturn -EFAULT;\n\tr = copy_from_user(data, (void __user *)addr + offset, len);\n\tif (r)\n\t\treturn -EFAULT;\n\treturn 0;\n}",
        "output": "1",
        "idx": 396
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void xmlrpc_char_encode(char *outbuffer, const char *s1)\n{\n\tlong unsigned int i;\n\tunsigned char c;\n\tchar buf2[15];\n\tmowgli_string_t *s = mowgli_string_create();\n\t*buf2 = '\\0';\n\t*outbuffer = '\\0';\n\n\tif ((!(s1) || (*(s1) == '\\0')))\n\t{\n\t\treturn;\n\t}\n\n\tfor (i = 0; s1[i] != '\\0'; i++)\n\t{\n\t\tc = s1[i];\n\t\tif (c > 127)\n\t\t{\n\t\t\tsnprintf(buf2, sizeof buf2, \"&#%d;\", c);\n\t\t\ts->append(s, buf2, strlen(buf2));\n\t\t}\n\t\telse if (c == '&')\n\t\t{\n\t\t\ts->append(s, \"&amp;\", 5);\n\t\t}\n\t\telse if (c == '<')\n\t\t{\n\t\t\ts->append(s, \"&lt;\", 4);\n\t\t}\n\t\telse if (c == '>')\n\t\t{\n\t\t\ts->append(s, \"&gt;\", 4);\n\t\t}\n\t\telse if (c == '\"')\n\t\t{\n\t\t\ts->append(s, \"&quot;\", 6);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts->append_char(s, c);\n\t\t}\n\t}\n\n\tmemcpy(outbuffer, s->str, XMLRPC_BUFSIZE);\n}",
        "output": "1",
        "idx": 5142
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void save_client_addr(struct ip_addr *client_ip, uint8_t *hwaddr)\n{\n\tuint8_t d = (uint8_t)ip4_addr4(client_ip);\n\t\n\txSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);\n\tmemcpy(ip_table.client_mac[d], hwaddr, 6); \n#if (debug_dhcps)\t\n\tprintf(\"\\r\\n%s: ip %d.%d.%d.%d, hwaddr %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\\n\", __func__,\n\t\tip4_addr1(client_ip), ip4_addr2(client_ip), ip4_addr3(client_ip), ip4_addr4(client_ip),\n\t\thwaddr[0], hwaddr[1], hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]);\n#endif\t\n\txSemaphoreGive(dhcps_ip_table_semaphore);\n}",
        "output": "1",
        "idx": 8410
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE read_memory(VALUE klass, VALUE content)\n{\n  xmlRelaxNGParserCtxtPtr ctx = xmlRelaxNGNewMemParserCtxt(\n      (const char *)StringValuePtr(content),\n      (int)RSTRING_LEN(content)\n  );\n  xmlRelaxNGPtr schema;\n  VALUE errors = rb_ary_new();\n  VALUE rb_schema;\n\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  schema = xmlRelaxNGParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n\n  return rb_schema;\n}",
        "output": "1",
        "idx": 8248
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "read_old_length(cdk_stream_t inp, int ctb, size_t * r_len, size_t * r_size)\n{\n\tint llen = ctb & 0x03;\n\n\tif (llen == 0) {\n\t\t*r_len = cdk_stream_getc(inp);\n\t\t(*r_size)++;\n\t} else if (llen == 1) {\n\t\t*r_len = read_16(inp);\n\t\t(*r_size) += 2;\n\t} else if (llen == 2) {\n\t\t*r_len = read_32(inp);\n\t\t(*r_size) += 4;\n\t} else {\n\t\t*r_len = 0;\n\t\t*r_size = 0;\n\t}\n}",
        "output": "1",
        "idx": 4630
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned long perf_instruction_pointer(struct pt_regs *regs)\n{\n\tbool use_siar = regs_use_siar(regs);\n\tunsigned long siar = mfspr(SPRN_SIAR);\n\n\tif (ppmu && (ppmu->flags & PPMU_P10_DD1)) {\n\t\tif (siar)\n\t\t\treturn siar;\n\t\telse\n\t\t\treturn regs->nip;\n\t} else if (use_siar && siar_valid(regs))\n\t\treturn mfspr(SPRN_SIAR) + perf_ip_adjust(regs);\n\telse if (use_siar)\n\t\treturn 0;\t\t\n\telse\n\t\treturn regs->nip;\n}",
        "output": "0",
        "idx": 2811
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb)\n{\n\tstruct xfrm_algo *algo;\n\tstruct nlattr *nla;\n\n\tnla = nla_reserve(skb, XFRMA_ALG_AUTH,\n\t\t\t  sizeof(*algo) + (auth->alg_key_len + 7) / 8);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\talgo = nla_data(nla);\n\tstrncpy(algo->alg_name, auth->alg_name, sizeof(algo->alg_name));\n\tmemcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8);\n\talgo->alg_key_len = auth->alg_key_len;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1051
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void frag_kfree_skb(struct netns_frags *nf, struct sk_buff *skb)\n{\n\tatomic_sub(skb->truesize, &nf->mem);\n\tkfree_skb(skb);\n}",
        "output": "1",
        "idx": 226
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_emul_add_msicap(struct pci_vdev *dev, int msgnum)\n{\n\tstruct msicap msicap;\n\n\tpci_populate_msicap(&msicap, msgnum, 0);\n\n\treturn pci_emul_add_capability(dev, (u_char *)&msicap, sizeof(msicap));\n}",
        "output": "1",
        "idx": 7594
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int handle_invvpid(struct kvm_vcpu *vcpu)\n{\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn 1;\n}",
        "output": "0",
        "idx": 3739
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "linkaddr_string(netdissect_options *ndo, const u_char *ep,\n\t\tconst unsigned int type, const unsigned int len)\n{\n\tregister u_int i;\n\tregister char *cp;\n\tregister struct enamemem *tp;\n\n\tif (len == 0)\n\t\treturn (\"<empty>\");\n\n\tif (type == LINKADDR_ETHER && len == ETHER_ADDR_LEN)\n\t\treturn (etheraddr_string(ndo, ep));\n\n\tif (type == LINKADDR_FRELAY)\n\t\treturn (q922_string(ndo, ep, len));\n\n\ttp = lookup_bytestring(ndo, ep, len);\n\tif (tp->e_name)\n\t\treturn (tp->e_name);\n\n\ttp->e_name = cp = (char *)malloc(len*3);\n\tif (tp->e_name == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"linkaddr_string: malloc\");\n\t*cp++ = hex[*ep >> 4];\n\t*cp++ = hex[*ep++ & 0xf];\n\tfor (i = len-1; i > 0 ; --i) {\n\t\t*cp++ = ':';\n\t\t*cp++ = hex[*ep >> 4];\n\t\t*cp++ = hex[*ep++ & 0xf];\n\t}\n\t*cp = '\\0';\n\treturn (tp->e_name);\n}",
        "output": "1",
        "idx": 4704
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ip6_append_data_mtu(unsigned int *mtu,\n\t\t\t\tint *maxfraglen,\n\t\t\t\tunsigned int fragheaderlen,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct rt6_info *rt,\n\t\t\t\tbool pmtuprobe)\n{\n\tif (!(rt->dst.flags & DST_XFRM_TUNNEL)) {\n\t\tif (skb == NULL) {\n\t\t\t*mtu = *mtu - rt->dst.header_len;\n\n\t\t} else {\n\t\t\t*mtu = min(*mtu, pmtuprobe ?\n\t\t\t\t   rt->dst.dev->mtu :\n\t\t\t\t   dst_mtu(rt->dst.path));\n\t\t}\n\t\t*maxfraglen = ((*mtu - fragheaderlen) & ~7)\n\t\t\t      + fragheaderlen - sizeof(struct frag_hdr);\n\t}\n}",
        "output": "0",
        "idx": 3275
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int crypto_reportstat(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t      struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto drop_alg;\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = crypto_reportstat_alg(alg, &info);\n\ndrop_alg:\n\tcrypto_mod_put(alg);\n\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}",
        "output": "0",
        "idx": 4553
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xcalloc (size_t num, size_t size)\n{\n    void *ptr = malloc(num * size);\n    if (ptr)\n    {\n        memset (ptr, '\\0', (num * size));\n    }\n    return ptr;\n}",
        "output": "1",
        "idx": 6398
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct vfsmount *clone_private_mount(const struct path *path)\n{\n\tstruct mount *old_mnt = real_mount(path->mnt);\n\tstruct mount *new_mnt;\n\n\tdown_read(&namespace_sem);\n\tif (IS_MNT_UNBINDABLE(old_mnt))\n\t\tgoto invalid;\n\n\tif (!check_mnt(old_mnt))\n\t\tgoto invalid;\n\n\tif (has_locked_children(old_mnt, path->dentry))\n\t\tgoto invalid;\n\n\tnew_mnt = clone_mnt(old_mnt, path->dentry, CL_PRIVATE);\n\tup_read(&namespace_sem);\n\n\tif (IS_ERR(new_mnt))\n\t\treturn ERR_CAST(new_mnt);\n\n\tnew_mnt->mnt_ns = MNT_NS_INTERNAL;\n\n\treturn &new_mnt->mnt;\n\ninvalid:\n\tup_read(&namespace_sem);\n\treturn ERR_PTR(-EINVAL);\n}",
        "output": "0",
        "idx": 2837
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool check_underflow(const struct ip6t_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\n\tif (!unconditional(&e->ipv6))\n\t\treturn false;\n\tt = ip6t_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}",
        "output": "1",
        "idx": 1196
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bt_tags_for_each(struct blk_mq_tags *tags,\n\t\tstruct blk_mq_bitmap_tags *bt, unsigned int off,\n\t\tbusy_tag_iter_fn *fn, void *data, bool reserved)\n{\n\tstruct request *rq;\n\tint bit, i;\n\n\tif (!tags->rqs)\n\t\treturn;\n\tfor (i = 0; i < bt->map_nr; i++) {\n\t\tstruct blk_align_bitmap *bm = &bt->map[i];\n\n\t\tfor (bit = find_first_bit(&bm->word, bm->depth);\n\t\t     bit < bm->depth;\n\t\t     bit = find_next_bit(&bm->word, bm->depth, bit + 1)) {\n\t\t\trq = tags->rqs[off + bit];\n\t\t\tfn(rq, data, reserved);\n\t\t}\n\n\t\toff += (1 << bt->bits_per_word);\n\t}\n}",
        "output": "0",
        "idx": 3993
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE cState_space_set(VALUE self, VALUE space)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(space, T_STRING);\n    len = RSTRING_LEN(space);\n    if (len == 0) {\n        if (state->space) {\n            ruby_xfree(state->space);\n            state->space = NULL;\n            state->space_len = 0;\n        }\n    } else {\n        if (state->space) ruby_xfree(state->space);\n        state->space = strdup(RSTRING_PTR(space));\n        state->space_len = len;\n    }\n    return Qnil;\n}",
        "output": "1",
        "idx": 6274
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void lzxd_free(struct lzxd_stream *lzx) {\n  struct mspack_system *sys;\n  if (lzx) {\n    sys = lzx->sys;\n    if(lzx->inbuf)\n        sys->free(lzx->inbuf);\n    if(lzx->window)\n        sys->free(lzx->window);\n    sys->free(lzx);\n  }\n}",
        "output": "0",
        "idx": 5335
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int sas_ex_revalidate_domain(struct domain_device *port_dev)\n{\n\tint res;\n\tstruct domain_device *dev = NULL;\n\n\tres = sas_find_bcast_dev(port_dev, &dev);\n\tif (res == 0 && dev) {\n\t\tstruct expander_device *ex = &dev->ex_dev;\n\t\tint i = 0, phy_id;\n\n\t\tdo {\n\t\t\tphy_id = -1;\n\t\t\tres = sas_find_bcast_phy(dev, &phy_id, i, true);\n\t\t\tif (phy_id == -1)\n\t\t\t\tbreak;\n\t\t\tres = sas_rediscover(dev, phy_id);\n\t\t\ti = phy_id + 1;\n\t\t} while (i < ex->num_phys);\n\t}\n\treturn res;\n}",
        "output": "0",
        "idx": 2653
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init pf_init(void)\n{\t\t\t\t\n\tstruct pf_unit *pf;\n\tint unit;\n\n\tif (disable)\n\t\treturn -EINVAL;\n\n\tpf_init_units();\n\n\tif (pf_detect())\n\t\treturn -ENODEV;\n\tpf_busy = 0;\n\n\tif (register_blkdev(major, name)) {\n\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)\n\t\t\tput_disk(pf->disk);\n\t\treturn -EBUSY;\n\t}\n\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tstruct gendisk *disk = pf->disk;\n\n\t\tif (!pf->present)\n\t\t\tcontinue;\n\t\tdisk->private_data = pf;\n\t\tadd_disk(disk);\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 3138
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "accept_ice_connection (GIOChannel           *source,\n                       GIOCondition          condition,\n                       GsmIceConnectionData *data)\n{\n        IceListenObj    listener;\n        IceConn         ice_conn;\n        IceAcceptStatus status;\n        GsmClient      *client;\n        GsmXsmpServer  *server;\n\n        listener = data->listener;\n        server = data->server;\n\n        g_debug (\"GsmXsmpServer: accept_ice_connection()\");\n\n        ice_conn = IceAcceptConnection (listener, &status);\n        if (status != IceAcceptSuccess) {\n                g_debug (\"GsmXsmpServer: IceAcceptConnection returned %d\", status);\n                return TRUE;\n        }\n\n        client = gsm_xsmp_client_new (ice_conn);\n        ice_conn->context = client;\n\n        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n        g_object_unref (client);\n\n        return TRUE;\n}",
        "output": "1",
        "idx": 6220
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int handle_wrmsr(struct kvm_vcpu *vcpu)\n{\n\tstruct msr_data msr;\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 data = (vcpu->arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(vcpu->arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\tif (vmx_set_msr(vcpu, &msr) != 0) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\ttrace_kvm_msr_write(ecx, data);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}",
        "output": "1",
        "idx": 2702
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void put_filp(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tsecurity_file_free(file);\n\t\tfile_sb_list_del(file);\n\t\tfile_free(file);\n\t}\n}",
        "output": "1",
        "idx": 2380
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_simple()\n{\n    json_set_alloc_funcs(my_malloc, my_free);\n    create_and_free_complex_object();\n\n    if(malloc_called != 1 || free_called != 1)\n        fail(\"Custom allocation failed\");\n}",
        "output": "0",
        "idx": 6007
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ipmi_si_port_setup(struct si_sm_io *io)\n{\n\tunsigned int addr = io->addr_data;\n\tint          idx;\n\n\tif (!addr)\n\t\treturn -ENODEV;\n\n\tio->io_cleanup = port_cleanup;\n\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = port_inb;\n\t\tio->outputb = port_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = port_inw;\n\t\tio->outputb = port_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = port_inl;\n\t\tio->outputb = port_outl;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_region(addr + idx * io->regspacing,\n\t\t\t\t   io->regsize, DEVICE_NAME) == NULL) {\n\t\t\twhile (idx--)\n\t\t\t\trelease_region(addr + idx * io->regspacing,\n\t\t\t\t\t       io->regsize);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 3076
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void iov_fault_in_pages_read(struct iovec *iov, unsigned long len)\n{\n\twhile (!iov->iov_len)\n\t\tiov++;\n\n\twhile (len > 0) {\n\t\tunsigned long this_len;\n\n\t\tthis_len = min_t(unsigned long, len, iov->iov_len);\n\t\tfault_in_pages_readable(iov->iov_base, this_len);\n\t\tlen -= this_len;\n\t\tiov++;\n\t}\n}",
        "output": "1",
        "idx": 2562
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ikev1_sub_print(netdissect_options *ndo,\n\t\tu_char np, const struct isakmp_gen *ext, const u_char *ep,\n\t\tuint32_t phase, uint32_t doi, uint32_t proto, int depth)\n{\n\tconst u_char *cp;\n\tint i;\n\tstruct isakmp_gen e;\n\n\tcp = (const u_char *)ext;\n\n\twhile (np) {\n\t\tND_TCHECK(*ext);\n\n\t\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\n\t\tND_TCHECK2(*ext, ntohs(e.len));\n\n\t\tdepth++;\n\t\tND_PRINT((ndo,\"\\n\"));\n\t\tfor (i = 0; i < depth; i++)\n\t\t\tND_PRINT((ndo,\"    \"));\n\t\tND_PRINT((ndo,\"(\"));\n\t\tcp = ike_sub0_print(ndo, np, ext, ep, phase, doi, proto, depth);\n\t\tND_PRINT((ndo,\")\"));\n\t\tdepth--;\n\n\t\tif (cp == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tnp = e.np;\n\t\text = (const struct isakmp_gen *)cp;\n\t}\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(np)));\n\treturn NULL;\n}",
        "output": "1",
        "idx": 4866
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int insn_get_code_seg_params(struct pt_regs *regs)\n{\n\tstruct desc_struct *desc;\n\tshort sel;\n\n\tif (v8086_mode(regs))\n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\n\tsel = get_segment_selector(regs, INAT_SEG_REG_CS);\n\tif (sel < 0)\n\t\treturn sel;\n\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (!(desc->type & BIT(3)))\n\t\treturn -EINVAL;\n\n\tswitch ((desc->l << 1) | desc->d) {\n\tcase 0: \n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\tcase 1: \n\t\treturn INSN_CODE_SEG_PARAMS(4, 4);\n\tcase 2: \n\t\treturn INSN_CODE_SEG_PARAMS(4, 8);\n\tcase 3: \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
        "output": "1",
        "idx": 3192
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,\n\t\t\tstruct rq_map_data *map_data,\n\t\t\tconst struct iov_iter *iter, gfp_t gfp_mask)\n{\n\tbool copy = false;\n\tunsigned long align = q->dma_pad_mask | queue_dma_alignment(q);\n\tstruct bio *bio = NULL;\n\tstruct iov_iter i;\n\tint ret;\n\n\tif (!iter_is_iovec(iter))\n\t\tgoto fail;\n\n\tif (map_data)\n\t\tcopy = true;\n\telse if (iov_iter_alignment(iter) & align)\n\t\tcopy = true;\n\telse if (queue_virt_boundary(q))\n\t\tcopy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);\n\n\ti = *iter;\n\tdo {\n\t\tret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);\n\t\tif (ret)\n\t\t\tgoto unmap_rq;\n\t\tif (!bio)\n\t\t\tbio = rq->bio;\n\t} while (iov_iter_count(&i));\n\n\tif (!bio_flagged(bio, BIO_USER_MAPPED))\n\t\trq->cmd_flags |= REQ_COPY_USER;\n\treturn 0;\n\nunmap_rq:\n\t__blk_rq_unmap_user(bio);\nfail:\n\trq->bio = NULL;\n\treturn -EINVAL;\n}",
        "output": "0",
        "idx": 2043
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "zend_object_iterator *spl_filesystem_tree_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator;\n\tspl_filesystem_object *dir_object;\n\n\tif (by_ref) {\n\t\tzend_error(E_ERROR, \"An iterator cannot be used with foreach by reference\");\n\t}\n\tdir_object = (spl_filesystem_object*)zend_object_store_get_object(object TSRMLS_CC);\n\titerator   = spl_filesystem_object_to_iterator(dir_object);\n\n\tif (iterator->intern.data == NULL) {\n\t\titerator->intern.data = object;\n\t\titerator->intern.funcs = &spl_filesystem_tree_it_funcs;\n\t}\n\tzval_add_ref(&object);\n\n\treturn (zend_object_iterator*)iterator;\n}",
        "output": "0",
        "idx": 5533
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvaser_usb_leaf_simple_cmd_async(struct kvaser_usb_net_priv *priv,\n\t\t\t\t\t    u8 cmd_id)\n{\n\tstruct kvaser_cmd *cmd;\n\tint err;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_ATOMIC);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_simple);\n\tcmd->id = cmd_id;\n\tcmd->u.simple.channel = priv->channel;\n\n\terr = kvaser_usb_send_cmd_async(priv, cmd, cmd->len);\n\tif (err)\n\t\tkfree(cmd);\n\n\treturn err;\n}",
        "output": "0",
        "idx": 4587
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int clie_5_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *port;\n\tunsigned int pipe;\n\tint j;\n\n\n\tif (serial->num_bulk_out < 2) {\n\t\tdev_err(&serial->interface->dev, \"missing bulk out endpoints\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tport = serial->port[0];\n\tport->bulk_out_endpointAddress =\n\t\t\t\tserial->port[1]->bulk_out_endpointAddress;\n\n\tpipe = usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress);\n\tfor (j = 0; j < ARRAY_SIZE(port->write_urbs); ++j)\n\t\tport->write_urbs[j]->pipe = pipe;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1569
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void xenvif_disconnect(struct xenvif *vif)\n{\n\tif (netif_carrier_ok(vif->dev))\n\t\txenvif_carrier_off(vif);\n\n\tatomic_dec(&vif->refcnt);\n\twait_event(vif->waiting_to_free, atomic_read(&vif->refcnt) == 0);\n\n\tdel_timer_sync(&vif->credit_timeout);\n\n\tif (vif->irq)\n\t\tunbind_from_irqhandler(vif->irq, vif);\n\n\tunregister_netdev(vif->dev);\n\n\txen_netbk_unmap_frontend_rings(vif);\n\n\tfree_netdev(vif->dev);\n}",
        "output": "0",
        "idx": 1145
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseTarget(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    cchar   *name, *args;\n\n    if (prop->type & MPR_JSON_OBJ) {\n        name = mprReadJson(prop, \"operation\");\n        args = mprReadJson(prop, \"args\");\n    } else {\n        name = \"run\";\n        args = prop->value;\n    }\n    httpSetRouteTarget(route, name, args);\n}",
        "output": "0",
        "idx": 7033
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct ttusbdecfe_state* state = (struct ttusbdecfe_state*) fe->demodulator_priv;\n\tu8 b[] = { 0x00, 0xff, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00 };\n\n\tif (cmd->msg_len > sizeof(b) - 4)\n\t\treturn -EINVAL;\n\n\tmemcpy(&b[4], cmd->msg, cmd->msg_len);\n\n\tstate->config->send_command(fe, 0x72,\n\t\t\t\t    sizeof(b) - (6 - cmd->msg_len), b,\n\t\t\t\t    NULL, NULL);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 3693
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "init_ext2_xattr(void)\n{\n\text2_xattr_cache = mb_cache_create(\"ext2_xattr\", 6);\n\tif (!ext2_xattr_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
        "output": "1",
        "idx": 1110
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "u32 GetHintFormat(GF_TrackBox *trak)\n{\n\tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\tif (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)\n\t\treturn 0;\n\t\t\n\tif (!hmhd || !hmhd->subType) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (!hmhd) return a ? a->type : 0;\n\t\tif (a) hmhd->subType = a->type;\n\t\treturn hmhd->subType;\n\t}\n\treturn hmhd->subType;\n}",
        "output": "1",
        "idx": 6906
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void xmlrpc_char_encode(char *outbuffer, const char *s1)\n{\n\tlong unsigned int i;\n\tunsigned char c;\n\tchar buf2[15];\n\tmowgli_string_t *s = mowgli_string_create();\n\t*buf2 = '\\0';\n\t*outbuffer = '\\0';\n\n\tif ((!(s1) || (*(s1) == '\\0')))\n\t{\n\t\treturn;\n\t}\n\n\tfor (i = 0; s1[i] != '\\0'; i++)\n\t{\n\t\tc = s1[i];\n\t\tif (c > 127)\n\t\t{\n\t\t\tsnprintf(buf2, sizeof buf2, \"&#%d;\", c);\n\t\t\ts->append(s, buf2, strlen(buf2));\n\t\t}\n\t\telse if (c == '&')\n\t\t{\n\t\t\ts->append(s, \"&amp;\", 5);\n\t\t}\n\t\telse if (c == '<')\n\t\t{\n\t\t\ts->append(s, \"&lt;\", 4);\n\t\t}\n\t\telse if (c == '>')\n\t\t{\n\t\t\ts->append(s, \"&gt;\", 4);\n\t\t}\n\t\telse if (c == '\"')\n\t\t{\n\t\t\ts->append(s, \"&quot;\", 6);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts->append_char(s, c);\n\t\t}\n\t}\n\ts->append_char(s, 0);\n\n\tstrncpy(outbuffer, s->str, XMLRPC_BUFSIZE);\n}",
        "output": "0",
        "idx": 7139
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "wb_prep(netdissect_options *ndo,\n        const struct pkt_prep *prep, u_int len)\n{\n\tint n;\n\tconst struct pgstate *ps;\n\tconst u_char *ep = ndo->ndo_snapend;\n\n\tND_PRINT((ndo, \" wb-prep:\"));\n\tif (len < sizeof(*prep)) {\n\t\treturn (-1);\n\t}\n\tn = EXTRACT_32BITS(&prep->pp_n);\n\tps = (const struct pgstate *)(prep + 1);\n\twhile (--n >= 0 && !ND_TTEST(*ps)) {\n\t\tconst struct id_off *io, *ie;\n\t\tchar c = '<';\n\n\t\tND_PRINT((ndo, \" %u/%s:%u\",\n\t\t    EXTRACT_32BITS(&ps->slot),\n\t\t    ipaddr_string(ndo, &ps->page.p_sid),\n\t\t    EXTRACT_32BITS(&ps->page.p_uid)));\n\t\tio = (struct id_off *)(ps + 1);\n\t\tfor (ie = io + ps->nid; io < ie && !ND_TTEST(*io); ++io) {\n\t\t\tND_PRINT((ndo, \"%c%s:%u\", c, ipaddr_string(ndo, &io->id),\n\t\t\t    EXTRACT_32BITS(&io->off)));\n\t\t\tc = ',';\n\t\t}\n\t\tND_PRINT((ndo, \">\"));\n\t\tps = (struct pgstate *)io;\n\t}\n\treturn ((u_char *)ps <= ep? 0 : -1);\n}",
        "output": "1",
        "idx": 4664
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_wrap_size_limit(\n\tOM_uint32\t*minor_status,\n\tconst gss_ctx_id_t context_handle,\n\tint\t\tconf_req_flag,\n\tgss_qop_t\tqop_req,\n\tOM_uint32\treq_output_size,\n\tOM_uint32\t*max_input_size)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_NO_CONTEXT);\n\n\tret = gss_wrap_size_limit(minor_status,\n\t\t\t\tsc->ctx_handle,\n\t\t\t\tconf_req_flag,\n\t\t\t\tqop_req,\n\t\t\t\treq_output_size,\n\t\t\t\tmax_input_size);\n\treturn (ret);\n}",
        "output": "0",
        "idx": 121
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "reference_queue_proccess_all (void)\n{\n\tMonoReferenceQueue **iter;\n\tMonoReferenceQueue *queue = ref_queues;\n\tfor (; queue; queue = queue->next)\n\t\treference_queue_proccess (queue);\n\nrestart:\n\tEnterCriticalSection (&reference_queue_mutex);\n\tfor (iter = &ref_queues; *iter;) {\n\t\tqueue = *iter;\n\t\tif (!queue->should_be_deleted) {\n\t\t\titer = &queue->next;\n\t\t\tcontinue;\n\t\t}\n\t\tif (queue->queue) {\n\t\t\tLeaveCriticalSection (&reference_queue_mutex);\n\t\t\treference_queue_proccess (queue);\n\t\t\tgoto restart;\n\t\t}\n\t\t*iter = queue->next;\n\t\tg_free (queue);\n\t}\n\tLeaveCriticalSection (&reference_queue_mutex);\n}",
        "output": "0",
        "idx": 4693
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE cState_space_set(VALUE self, VALUE space)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(space, T_STRING);\n    len = RSTRING_LEN(space);\n    if (len == 0) {\n        if (state->space) {\n            ruby_xfree(state->space);\n            state->space = NULL;\n            state->space_len = 0;\n        }\n    } else {\n        if (state->space) ruby_xfree(state->space);\n        state->space = fstrndup(RSTRING_PTR(space), len);\n        state->space_len = len;\n    }\n    return Qnil;\n}",
        "output": "0",
        "idx": 8809
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mem_log_init(const char* prog_name, const char *banner)\n{\n\tsize_t log_name_len;\n\tchar *log_name;\n\n\tif (__test_bit(LOG_CONSOLE_BIT, &debug)) {\n\t\tlog_op = stderr;\n\t\treturn;\n\t}\n\n\tif (log_op)\n\t\tfclose(log_op);\n\n\tlog_name_len = 5 + strlen(prog_name) + 5 + 7 + 4 + 1;\t\n\tlog_name = malloc(log_name_len);\n\tif (!log_name) {\n\t\tlog_message(LOG_INFO, \"Unable to malloc log file name\");\n\t\tlog_op = stderr;\n\t\treturn;\n\t}\n\n\tsnprintf(log_name, log_name_len, \"/tmp/%s_mem.%d.log\", prog_name, getpid());\n\tlog_op = fopen(log_name, \"a\");\n\tif (log_op == NULL) {\n\t\tlog_message(LOG_INFO, \"Unable to open %s for appending\", log_name);\n\t\tlog_op = stderr;\n\t}\n\telse {\n\t\tint fd = fileno(log_op);\n\n\t\tfcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);\n\n\t\tsetlinebuf(log_op);\n\n\t\tfprintf(log_op, \"\\n\");\n\t}\n\n\tfree(log_name);\n\n\tterminate_banner = banner;\n}",
        "output": "1",
        "idx": 7100
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ntlm_write_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->Len > 0)\n\t{\n\t\tStream_SetPosition(s, fields->BufferOffset);\n\t\tStream_Write(s, fields->Buffer, fields->Len);\n\t}\n}",
        "output": "1",
        "idx": 4190
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int socket_accept(int fd, uint16_t port)\n{\n#ifdef WIN32\n\tint addr_len;\n#else\n\tsocklen_t addr_len;\n#endif\n\tint result;\n\tstruct sockaddr_in addr;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(port);\n\n\taddr_len = sizeof(addr);\n\tresult = accept(fd, (struct sockaddr*)&addr, &addr_len);\n\n\treturn result;\n}",
        "output": "1",
        "idx": 5974
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rose_idletimer_expiry(struct timer_list *t)\n{\n\tstruct rose_sock *rose = from_timer(rose, t, idletimer);\n\tstruct sock *sk = &rose->sock;\n\n\tbh_lock_sock(sk);\n\trose_clear_queues(sk);\n\n\trose_write_internal(sk, ROSE_CLEAR_REQUEST);\n\trose_sk(sk)->state = ROSE_STATE_2;\n\n\trose_start_t3timer(sk);\n\n\tsk->sk_state     = TCP_CLOSE;\n\tsk->sk_err       = 0;\n\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\t\tsock_set_flag(sk, SOCK_DEAD);\n\t}\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}",
        "output": "0",
        "idx": 2947
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tWARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING &&\n\t\t\t!(task_thread_info(p)->preempt_count & PREEMPT_ACTIVE));\n\n#ifdef CONFIG_LOCKDEP\n\tWARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||\n\t\t\t\t      lockdep_is_held(&task_rq(p)->lock)));\n#endif\n#endif\n\n\ttrace_sched_migrate_task(p, new_cpu);\n\n\tif (task_cpu(p) != new_cpu) {\n\t\tp->se.nr_migrations++;\n\t\tperf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, 1, NULL, 0);\n\t}\n\n\t__set_task_cpu(p, new_cpu);\n}",
        "output": "1",
        "idx": 552
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "shutdown_mib(void)\n{\n    unload_all_mibs();\n    if (tree_top) {\n        if (tree_top->label)\n            SNMP_FREE(tree_top->label);\n        SNMP_FREE(tree_top);\n    }\n    tree_head = NULL;\n    Mib = NULL;\n    if (_mibindexes) {\n        int i;\n        for (i = 0; i < _mibindex; ++i)\n            SNMP_FREE(_mibindexes[i]);\n        free(_mibindexes);\n        _mibindex = 0;\n        _mibindex_max = 0;\n        _mibindexes = NULL;\n    }\n    if (Prefix != NULL && Prefix != &Standard_Prefix[0])\n        SNMP_FREE(Prefix);\n    if (Prefix)\n        Prefix = NULL;\n    SNMP_FREE(confmibs);\n    SNMP_FREE(confmibdir);\n}",
        "output": "1",
        "idx": 7802
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parse_user_name(char *user_input, char **ret_username)\n{\n\tregister char *ptr;\n\tregister int index = 0;\n\tchar username[PAM_MAX_RESP_SIZE];\n\n\t*ret_username = NULL;\n\n\tbzero((void *)username, PAM_MAX_RESP_SIZE);\n\n\tptr = user_input;\n\n\twhile ((*ptr == ' ') || (*ptr == '\\t'))\n\t\tptr++;\n\n\tif (*ptr == '\\0') {\n\t\treturn (PAM_BUF_ERR);\n\t}\n\n\twhile (*ptr != '\\0') {\n\t\tif ((*ptr == ' ') || (*ptr == '\\t'))\n\t\t\tbreak;\n\t\telse {\n\t\t\tusername[index] = *ptr;\n\t\t\tindex++;\n\t\t\tptr++;\n\t\t}\n\t}\n\n\tif ((*ret_username = malloc(index + 1)) == NULL)\n\t\treturn (PAM_BUF_ERR);\n\t(void) strcpy(*ret_username, username);\n\treturn (PAM_SUCCESS);\n}",
        "output": "1",
        "idx": 4902
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(DirectoryIterator, getBasename)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar *suffix = 0, *fname;\n\tint slen = 0;\n\tsize_t flen;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|s\", &suffix, &slen) == FAILURE) {\n\t\treturn;\n\t}\n\n\tphp_basename(intern->u.dir.entry.d_name, strlen(intern->u.dir.entry.d_name), suffix, slen, &fname, &flen TSRMLS_CC);\n\n\tRETURN_STRINGL(fname, flen, 0);\n}",
        "output": "0",
        "idx": 5459
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs4_return_incompatible_delegation(struct inode *inode, mode_t open_flags)\n{\n\tstruct nfs_delegation *delegation;\n\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation == NULL || (delegation->type & open_flags) == open_flags) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\tnfs_inode_return_delegation(inode);\n}",
        "output": "1",
        "idx": 2130
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_test(&ucounts->count)) {\n\t\tspin_lock_irqsave(&ucounts_lock, flags);\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\n\t\tkfree(ucounts);\n\t}\n}",
        "output": "1",
        "idx": 1514
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int restore_fpu_checking(struct task_struct *tsk)\n{\n\talternative_input(\n\t\tASM_NOP8 ASM_NOP2,\n\t\t\"emms\\n\\t\"\t\t\n\t\t\"fildl %P[addr]\",\t\n\t\tX86_FEATURE_FXSAVE_LEAK,\n\t\t[addr] \"m\" (tsk->thread.fpu.has_fpu));\n\n\treturn fpu_restore_checking(&tsk->thread.fpu);\n}",
        "output": "1",
        "idx": 2508
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int gdTransformAffineGetImage(gdImagePtr *dst,\n\t\t  const gdImagePtr src,\n\t\t  gdRectPtr src_area,\n\t\t  const double affine[6])\n{\n\tint res;\n\tdouble m[6];\n\tgdRect bbox;\n\tgdRect area_full;\n\n\tif (src_area == NULL) {\n\t\tarea_full.x = 0;\n\t\tarea_full.y = 0;\n\t\tarea_full.width  = gdImageSX(src);\n\t\tarea_full.height = gdImageSY(src);\n\t\tsrc_area = &area_full;\n\t}\n\n\tgdTransformAffineBoundingBox(src_area, affine, &bbox);\n\n\t*dst = gdImageCreateTrueColor(bbox.width, bbox.height);\n\tif (*dst == NULL) {\n\t\treturn GD_FALSE;\n\t}\n\t(*dst)->saveAlphaFlag = 1;\n\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\t\n\tgdAffineTranslate(m, -bbox.x, -bbox.y);\n\tgdAffineConcat(m, affine, m);\n\n\tgdImageAlphaBlending(*dst, 0);\n\n\tres = gdTransformAffineCopy(*dst,\n\t\t  0,0,\n\t\t  src,\n\t\t  src_area,\n\t\t  m);\n\n\tif (res != GD_TRUE) {\n\t\tgdImageDestroy(*dst);\n\t\tdst = NULL;\n\t\treturn GD_FALSE;\n\t} else {\n\t\treturn GD_TRUE;\n\t}\n}",
        "output": "1",
        "idx": 3908
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static cJSON *create_reference( cJSON *item )\n{\n\tcJSON *ref;\n\tif ( ! ( ref = cJSON_New_Item() ) )\n\t\treturn 0;\n\tmemcpy( ref, item, sizeof(cJSON) );\n\tref->string = 0;\n\tref->type |= cJSON_IsReference;\n\tref->next = ref->prev = 0;\n\treturn ref;\n}",
        "output": "1",
        "idx": 5922
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj)\n{\n    char obj_txt[128];\n\n    OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);\n    BIO_printf(bio, \"%s\\n\", obj_txt);\n\n    return 1;\n}",
        "output": "0",
        "idx": 6341
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tnew->count = 0;\n\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tucounts = new;\n\t\t}\n\t}\n\tif (ucounts->count == INT_MAX)\n\t\tucounts = NULL;\n\telse\n\t\tucounts->count += 1;\n\tspin_unlock_irq(&ucounts_lock);\n\treturn ucounts;\n}",
        "output": "0",
        "idx": 2199
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mt_init(mtrand *mt, uint32_t seed) {\n  int i;\n  mt->mt_buffer_[0] = seed;\n  mt->mt_index_ = MT_LEN;\n  for (i = 1; i < MT_LEN; i++) {\n    mt->mt_buffer_[i] =\n\t(1812433253UL * (mt->mt_buffer_[i-1] ^ \n\t\t\t (mt->mt_buffer_[i-1] >> 30)) + i);\n  }\n}",
        "output": "1",
        "idx": 5122
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int key_update(key_ref_t key_ref, const void *payload, size_t plen)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\n\tkey_check(key);\n\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!key->type->update)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tdown_write(&key->sem);\n\n\tret = key->type->update(key, &prep);\n\tif (ret == 0)\n\t\tmark_key_instantiated(key, 0);\n\n\tup_write(&key->sem);\n\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}",
        "output": "0",
        "idx": 2497
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseServerMonitors(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprJson     *child;\n    MprTicks    period;\n    cchar       *counter, *expression, *limit, *relation, *defenses;\n    int         ji;\n\n    for (ITERATE_CONFIG(route, prop, child, ji)) {\n        defenses = mprGetJson(child, \"defenses\");\n        expression = mprGetJson(child, \"expression\");\n        period = httpGetTicks(mprGetJson(child, \"period\"));\n\n        if (!httpTokenize(route, expression, \"%S %S %S\", &counter, &relation, &limit)) {\n            httpParseError(route, \"Cannot add monitor: %s\", prop->name);\n            break;\n        }\n        if (httpAddMonitor(counter, relation, getint(limit), period, defenses) < 0) {\n            httpParseError(route, \"Cannot add monitor: %s\", prop->name);\n            break;\n        }\n    }\n}",
        "output": "1",
        "idx": 5018
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_get_cfgdata16(struct pci_vdev *dev, int offset)\n{\n\tassert(offset <= (PCI_REGMAX - 1) && (offset & 1) == 0);\n\treturn (*(uint16_t *)(dev->cfgdata + offset));\n}",
        "output": "1",
        "idx": 7618
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dump_keywords(vector_t *keydump, int level, FILE *fp)\n{\n\tunsigned int i;\n\tkeyword_t *keyword_vec;\n\tchar file_name[21];\n\n\tif (!level) {\n\t\tsnprintf(file_name, sizeof(file_name), \"/tmp/keywords.%d\", getpid());\n\t\tfp = fopen(file_name, \"w\");\n\t\tif (!fp)\n\t\t\treturn;\n\t}\n\n\tfor (i = 0; i < vector_size(keydump); i++) {\n\t\tkeyword_vec = vector_slot(keydump, i);\n\t\tfprintf(fp, \"%*sKeyword : %s (%s)\\n\", level * 2, \"\", keyword_vec->string, keyword_vec->active ? \"active\": \"disabled\");\n\t\tif (keyword_vec->sub)\n\t\t\tdump_keywords(keyword_vec->sub, level + 1, fp);\n\t}\n\n\tif (!level)\n\t\tfclose(fp);\n}",
        "output": "1",
        "idx": 7104
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int handle_emulation_failure(struct kvm_vcpu *vcpu)\n{\n\tint r = EMULATE_DONE;\n\n\t++vcpu->stat.insn_emulation_fail;\n\ttrace_kvm_emulate_insn_failed(vcpu);\n\tif (!is_guest_mode(vcpu)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\tr = EMULATE_FAIL;\n\t}\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\n\treturn r;\n}",
        "output": "0",
        "idx": 359
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool rt6_qualify_for_ecmp(struct rt6_info *rt)\n{\n\treturn (rt->rt6i_flags & (RTF_GATEWAY|RTF_ADDRCONF|RTF_DYNAMIC)) ==\n\t       RTF_GATEWAY;\n}",
        "output": "0",
        "idx": 3291
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ikev1_vid_print(netdissect_options *ndo, u_char tpay _U_,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_VID)));\n\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_VID)));\n\treturn NULL;\n}",
        "output": "0",
        "idx": 6807
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void xen_evtchn_handle_events(unsigned cpu,\n\t\t\t\t\t    struct evtchn_loop_ctrl *ctrl)\n{\n\treturn evtchn_ops->handle_events(cpu, ctrl);\n}",
        "output": "0",
        "idx": 2753
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ovl_remove_upper(struct dentry *dentry, bool is_dir)\n{\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *dir = upperdir->d_inode;\n\tstruct dentry *upper = ovl_dentry_upper(dentry);\n\tint err;\n\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\terr = -ESTALE;\n\tif (upper->d_parent == upperdir) {\n\t\tdget(upper);\n\t\tif (is_dir)\n\t\t\terr = vfs_rmdir(dir, upper);\n\t\telse\n\t\t\terr = vfs_unlink(dir, upper, NULL);\n\t\tdput(upper);\n\t\tovl_dentry_version_inc(dentry->d_parent);\n\t}\n\n\tif (!err)\n\t\td_drop(dentry);\n\tinode_unlock(dir);\n\n\treturn err;\n}",
        "output": "1",
        "idx": 1162
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "finalizer_thread (gpointer unused)\n{\n\twhile (!finished) {\n\n\t\tg_assert (mono_domain_get () == mono_get_root_domain ());\n\n#ifdef MONO_HAS_SEMAPHORES\n\t\tMONO_SEM_WAIT (&finalizer_sem);\n#else\n\t\tWaitForSingleObjectEx (finalizer_event, INFINITE, FALSE);\n#endif\n\n\t\tmono_console_handle_async_ops ();\n\n#ifndef DISABLE_ATTACH\n\t\tmono_attach_maybe_start ();\n#endif\n\n\t\treference_queue_proccess_all ();\n\n\t\tif (domains_to_finalize) {\n\t\t\tmono_finalizer_lock ();\n\t\t\tif (domains_to_finalize) {\n\t\t\t\tDomainFinalizationReq *req = domains_to_finalize->data;\n\t\t\t\tdomains_to_finalize = g_slist_remove (domains_to_finalize, req);\n\t\t\t\tmono_finalizer_unlock ();\n\n\t\t\t\tfinalize_domain_objects (req);\n\t\t\t} else {\n\t\t\t\tmono_finalizer_unlock ();\n\t\t\t}\n\t\t}\t\t\t\t\n\n\t\tmono_gc_invoke_finalizers ();\n\n\n\t\tSetEvent (pending_done_event);\n\t}\n\n\tSetEvent (shutdown_event);\n\treturn 0;\n}",
        "output": "0",
        "idx": 4697
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int common_timer_set(struct k_itimer *timr, int flags,\n\t\t     struct itimerspec64 *new_setting,\n\t\t     struct itimerspec64 *old_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tbool sigev_none;\n\tktime_t expires;\n\n\tif (old_setting)\n\t\tcommon_timer_get(timr, old_setting);\n\n\ttimr->it_interval = 0;\n\tif (kc->timer_try_to_cancel(timr) < 0)\n\t\treturn TIMER_RETRY;\n\n\ttimr->it_active = 0;\n\ttimr->it_requeue_pending = (timr->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimr->it_overrun_last = 0;\n\n\tif (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)\n\t\treturn 0;\n\n\ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n\texpires = timespec64_to_ktime(new_setting->it_value);\n\tsigev_none = timr->it_sigev_notify == SIGEV_NONE;\n\n\tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n\ttimr->it_active = !sigev_none;\n\treturn 0;\n}",
        "output": "0",
        "idx": 2593
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int inet6_csk_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl_unused)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint res;\n\n\tdst = inet6_csk_route_socket(sk, &fl6);\n\tif (IS_ERR(dst)) {\n\t\tsk->sk_err_soft = -PTR_ERR(dst);\n\t\tsk->sk_route_caps = 0;\n\t\tkfree_skb(skb);\n\t\treturn PTR_ERR(dst);\n\t}\n\n\trcu_read_lock();\n\tskb_dst_set_noref(skb, dst);\n\n\tfl6.daddr = sk->sk_v6_daddr;\n\n\tres = ip6_xmit(sk, skb, &fl6, rcu_dereference(np->opt),\n\t\t       np->tclass);\n\trcu_read_unlock();\n\treturn res;\n}",
        "output": "0",
        "idx": 1407
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PredictorEncodeTile(TIFF* tif, uint8* bp0, tmsize_t cc0, uint16 s)\n{\n\tstatic const char module[] = \"PredictorEncodeTile\";\n\tTIFFPredictorState *sp = PredictorState(tif);\n        uint8 *working_copy;\n\ttmsize_t cc = cc0, rowsize;\n\tunsigned char* bp;\n        int result_code;\n\n\tassert(sp != NULL);\n\tassert(sp->encodepfunc != NULL);\n\tassert(sp->encodetile != NULL);\n\n         * the callers buffer. http:\n        working_copy = (uint8*) _TIFFmalloc(cc0);\n        if( working_copy == NULL )\n        {\n            TIFFErrorExt(tif->tif_clientdata, module, \n                         \"Out of memory allocating \" TIFF_SSIZE_FORMAT \" byte temp buffer.\",\n                         cc0 );\n            return 0;\n        }\n        memcpy( working_copy, bp0, cc0 );\n        bp = working_copy;\n\n\trowsize = sp->rowsize;\n\tassert(rowsize > 0);\n\tassert((cc0%rowsize)==0);\n\twhile (cc > 0) {\n\t\t(*sp->encodepfunc)(tif, bp, rowsize);\n\t\tcc -= rowsize;\n\t\tbp += rowsize;\n\t}\n\tresult_code = (*sp->encodetile)(tif, working_copy, cc0, s);\n\n        _TIFFfree( working_copy );\n\n        return result_code;\n}",
        "output": "1",
        "idx": 4274
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,\n\t\t    u8 *dst, unsigned int dlen)\n{\n\treturn crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);\n}",
        "output": "1",
        "idx": 2844
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct sk_buff **ipip_gro_receive(struct sk_buff **head,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tif (NAPI_GRO_CB(skb)->encap_mark) {\n\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\treturn NULL;\n\t}\n\n\tNAPI_GRO_CB(skb)->encap_mark = 1;\n\n\treturn inet_gro_receive(head, skb);\n}",
        "output": "0",
        "idx": 1717
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IW_IMPL(unsigned int) iw_get_ui16be(const iw_byte *b)\n{\n\treturn (b[0]<<8) | b[1];\n}",
        "output": "1",
        "idx": 6650
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool mmget_still_valid(struct mm_struct *mm)\n{\n\treturn likely(!mm->core_state);\n}",
        "output": "0",
        "idx": 4385
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void free_huge_page(struct page *page)\n{\n\tstruct hstate *h = page_hstate(page);\n\tint nid = page_to_nid(page);\n\tstruct address_space *mapping;\n\n\tmapping = (struct address_space *) page_private(page);\n\tset_page_private(page, 0);\n\tpage->mapping = NULL;\n\tBUG_ON(page_count(page));\n\tBUG_ON(page_mapcount(page));\n\tINIT_LIST_HEAD(&page->lru);\n\n\tspin_lock(&hugetlb_lock);\n\tif (h->surplus_huge_pages_node[nid] && huge_page_order(h) < MAX_ORDER) {\n\t\tupdate_and_free_page(h, page);\n\t\th->surplus_huge_pages--;\n\t\th->surplus_huge_pages_node[nid]--;\n\t} else {\n\t\tenqueue_huge_page(h, page);\n\t}\n\tspin_unlock(&hugetlb_lock);\n\tif (mapping)\n\t\thugetlb_put_quota(mapping, 1);\n}",
        "output": "1",
        "idx": 690
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void log_flush(LOG_MODE new_mode) {\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_LOG_MODE]);\n\n    if(log_mode!=LOG_MODE_CONFIGURED || new_mode!=LOG_MODE_ERROR)\n        log_mode=new_mode;\n\n    if(new_mode!=LOG_MODE_BUFFER) {\n        CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_LOG_BUFFER]);\n        while(head) {\n            struct LIST *tmp=head;\n            head=head->next;\n            log_raw(tmp->opt, tmp->level, tmp->stamp, tmp->id, tmp->text);\n            str_free(tmp);\n        }\n        head=tail=NULL;\n        CRYPTO_THREAD_unlock(stunnel_locks[LOCK_LOG_BUFFER]);\n    }\n\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_LOG_MODE]);\n}",
        "output": "1",
        "idx": 8442
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *bpf_any_get(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\traw = bpf_prog_inc(raw);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\traw = bpf_map_inc(raw, true);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn raw;\n}",
        "output": "0",
        "idx": 1831
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void enc28j60SelectBank(NetInterface *interface, uint16_t address)\n{\n   uint16_t bank;\n   Enc28j60Context *context;\n\n   context = (Enc28j60Context *) interface->nicContext;\n\n   bank = address & REG_BANK_MASK;\n\n   if(bank != context->currentBank)\n   {\n      switch(bank)\n      {\n      case BANK_0:\n         enc28j60ClearBit(interface, ENC28J60_REG_ECON1, ECON1_BSEL1 | ECON1_BSEL0);\n         break;\n      case BANK_1:\n         enc28j60SetBit(interface, ENC28J60_REG_ECON1, ECON1_BSEL0);\n         enc28j60ClearBit(interface, ENC28J60_REG_ECON1, ECON1_BSEL1);\n         break;\n      case BANK_2:\n         enc28j60ClearBit(interface, ENC28J60_REG_ECON1, ECON1_BSEL0);\n         enc28j60SetBit(interface, ENC28J60_REG_ECON1, ECON1_BSEL1);\n         break;\n      case BANK_3:\n         enc28j60SetBit(interface, ENC28J60_REG_ECON1, ECON1_BSEL1 | ECON1_BSEL0);\n         break;\n      default:\n         break;\n      }\n\n      context->currentBank = bank;\n   }\n}",
        "output": "1",
        "idx": 8536
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "term_and_job_init(\n\tterm_T\t    *term,\n\ttypval_T    *argvar,\n\tchar\t    **argv,\n\tjobopt_T    *opt,\n\tjobopt_T    *orig_opt UNUSED)\n{\n    create_vterm(term, term->tl_rows, term->tl_cols);\n\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\n    if (opt->jo_set2 & JO2_ANSI_COLORS)\n\tset_vterm_palette(term->tl_vterm, opt->jo_ansi_colors);\n    else\n\tinit_vterm_ansi_colors(term->tl_vterm);\n#endif\n\n    term->tl_job = job_start(argvar, argv, opt, TRUE);\n    if (term->tl_job != NULL)\n\t++term->tl_job->jv_refcount;\n\n    return term->tl_job != NULL\n\t&& term->tl_job->jv_channel != NULL\n\t&& term->tl_job->jv_status != JOB_FAILED ? OK : FAIL;\n}",
        "output": "1",
        "idx": 5838
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void sem_getref_and_unlock(struct sem_array *sma)\n{\n\tipc_rcu_getref(sma);\n\tipc_unlock(&(sma)->sem_perm);\n}",
        "output": "1",
        "idx": 2268
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static mongo_message *mongo_message_create( int len , int id , int responseTo , int op ) {\n    mongo_message *mm = ( mongo_message * )bson_malloc( len );\n\n    if ( !id )\n        id = rand();\n\n    mm->head.len = len;\n    mm->head.id = id;\n    mm->head.responseTo = responseTo;\n    mm->head.op = op;\n\n    return mm;\n}",
        "output": "1",
        "idx": 7918
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,\n\t\t\t\tstruct bpf_reg_state *src_reg)\n{\n\tbool src_known = tnum_subreg_is_const(src_reg->var_off);\n\tbool dst_known = tnum_subreg_is_const(dst_reg->var_off);\n\tstruct tnum var32_off = tnum_subreg(dst_reg->var_off);\n\ts32 smin_val = src_reg->smin_value;\n\tu32 umin_val = src_reg->umin_value;\n\n\tif (src_known && dst_known)\n\t\treturn;\n\n\tdst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);\n\tdst_reg->u32_max_value = var32_off.value | var32_off.mask;\n\tif (dst_reg->s32_min_value < 0 || smin_val < 0) {\n\t\tdst_reg->s32_min_value = S32_MIN;\n\t\tdst_reg->s32_max_value = S32_MAX;\n\t} else {\n\t\tdst_reg->s32_min_value = dst_reg->umin_value;\n\t\tdst_reg->s32_max_value = dst_reg->umax_value;\n\t}\n}",
        "output": "1",
        "idx": 1882
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool blk_kick_flush(struct request_queue *q, struct blk_flush_queue *fq)\n{\n\tstruct list_head *pending = &fq->flush_queue[fq->flush_pending_idx];\n\tstruct request *first_rq =\n\t\tlist_first_entry(pending, struct request, flush.list);\n\tstruct request *flush_rq = fq->flush_rq;\n\n\tif (fq->flush_pending_idx != fq->flush_running_idx || list_empty(pending))\n\t\treturn false;\n\n\tif (!list_empty(&fq->flush_data_in_flight) &&\n\t    time_before(jiffies,\n\t\t\tfq->flush_pending_since + FLUSH_PENDING_TIMEOUT))\n\t\treturn false;\n\n\tfq->flush_pending_idx ^= 1;\n\n\tblk_rq_init(q, flush_rq);\n\n\tif (q->mq_ops) {\n\t\tflush_rq->mq_ctx = first_rq->mq_ctx;\n\t\tflush_rq->tag = first_rq->tag;\n\t}\n\n\tflush_rq->cmd_type = REQ_TYPE_FS;\n\tflush_rq->cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ;\n\tflush_rq->rq_disk = first_rq->rq_disk;\n\tflush_rq->end_io = flush_end_io;\n\n\treturn blk_flush_queue_rq(flush_rq, false);\n}",
        "output": "1",
        "idx": 2888
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ext4_convert_unwritten_extents_endio(handle_t *handle,\n\t\t\t\t\t      struct inode *inode,\n\t\t\t\t\t      struct ext4_ext_path *path)\n{\n\tstruct ext4_extent *ex;\n\tint depth;\n\tint err = 0;\n\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\n\text_debug(\"ext4_convert_unwritten_extents_endio: inode %lu, logical\"\n\t\t\"block %llu, max_blocks %u\\n\", inode->i_ino,\n\t\t(unsigned long long)le32_to_cpu(ex->ee_block),\n\t\text4_ext_get_actual_len(ex));\n\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto out;\n\text4_ext_mark_initialized(ex);\n\n\text4_ext_try_to_merge(handle, inode, path, ex);\n\n\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\nout:\n\text4_ext_show_leaf(inode, path);\n\treturn err;\n}",
        "output": "1",
        "idx": 786
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hash_new_from_values(mrb_state *mrb, mrb_int argc, mrb_value *regs)\n{\n  mrb_value hash = mrb_hash_new_capa(mrb, argc);\n  while (argc--) {\n    mrb_hash_set(mrb, hash, regs[0], regs[1]);\n    regs += 2;\n  }\n  return hash;\n}",
        "output": "1",
        "idx": 6706
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void print_cfs_stats(struct seq_file *m, int cpu)\n{\n\tstruct cfs_rq *cfs_rq;\n\n\trcu_read_lock();\n\tfor_each_leaf_cfs_rq(cpu_rq(cpu), cfs_rq)\n\t\tprint_cfs_rq(m, cpu, cfs_rq);\n\trcu_read_unlock();\n}",
        "output": "0",
        "idx": 4195
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\tgss_qop_t qop_req, gss_iov_buffer_desc *iov, int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n\n    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,\n\t\t\t       iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_get_mic_iov == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_get_mic_iov(minor_status, ctx->internal_ctx_id, qop_req,\n\t\t\t\t   iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}",
        "output": "0",
        "idx": 279
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ngx_mail_core_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)\n{\n    ngx_mail_core_srv_conf_t *prev = parent;\n    ngx_mail_core_srv_conf_t *conf = child;\n\n    ngx_conf_merge_msec_value(conf->timeout, prev->timeout, 60000);\n    ngx_conf_merge_msec_value(conf->resolver_timeout, prev->resolver_timeout,\n                              30000);\n\n    ngx_conf_merge_uint_value(conf->max_errors, prev->max_errors, 5);\n\n    ngx_conf_merge_str_value(conf->server_name, prev->server_name, \"\");\n\n    if (conf->server_name.len == 0) {\n        conf->server_name = cf->cycle->hostname;\n    }\n\n    if (conf->protocol == NULL) {\n        ngx_log_error(NGX_LOG_EMERG, cf->log, 0,\n                      \"unknown mail protocol for server in %s:%ui\",\n                      conf->file_name, conf->line);\n        return NGX_CONF_ERROR;\n    }\n\n    if (conf->error_log == NULL) {\n        if (prev->error_log) {\n            conf->error_log = prev->error_log;\n        } else {\n            conf->error_log = &cf->cycle->new_log;\n        }\n    }\n\n    ngx_conf_merge_ptr_value(conf->resolver, prev->resolver, NULL);\n\n    return NGX_CONF_OK;\n}",
        "output": "0",
        "idx": 8951
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int gup_huge_pmd(pmd_t orig, pmd_t *pmdp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\n\tif (!pmd_access_permitted(orig, write))\n\t\treturn 0;\n\n\tif (pmd_devmap(orig))\n\t\treturn __gup_device_huge_pmd(orig, pmdp, addr, end, pages, nr);\n\n\trefs = 0;\n\tpage = pmd_page(orig) + ((addr & ~PMD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\thead = compound_head(pmd_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(pmd_val(orig) != pmd_val(*pmdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\n\tSetPageReferenced(head);\n\treturn 1;\n}",
        "output": "1",
        "idx": 3158
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static UINT parallel_process_irp_create(PARALLEL_DEVICE* parallel, IRP* irp)\n{\n\tchar* path = NULL;\n\tint status;\n\tUINT32 PathLength;\n\tStream_Seek(irp->input, 28);\n\tStream_Read_UINT32(irp->input, PathLength);\n\tstatus = ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(irp->input), PathLength / 2,\n\t                            &path, 0, NULL, NULL);\n\n\tif (status < 1)\n\t\tif (!(path = (char*)calloc(1, 1)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\n\tparallel->id = irp->devman->id_sequence++;\n\tparallel->file = open(parallel->path, O_RDWR);\n\n\tif (parallel->file < 0)\n\t{\n\t\tirp->IoStatus = STATUS_ACCESS_DENIED;\n\t\tparallel->id = 0;\n\t}\n\telse\n\t{\n\t\tif (fcntl(parallel->file, F_SETFL, O_NONBLOCK) == -1)\n\t\t{\n\t\t}\n\t}\n\n\tStream_Write_UINT32(irp->output, parallel->id);\n\tStream_Write_UINT8(irp->output, 0);\n\tfree(path);\n\treturn irp->Complete(irp);\n}",
        "output": "1",
        "idx": 4148
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rtnl_fill_link_ifmap(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct rtnl_link_ifmap map = {\n\t\t.mem_start   = dev->mem_start,\n\t\t.mem_end     = dev->mem_end,\n\t\t.base_addr   = dev->base_addr,\n\t\t.irq         = dev->irq,\n\t\t.dma         = dev->dma,\n\t\t.port        = dev->if_port,\n\t};\n\tif (nla_put(skb, IFLA_MAP, sizeof(map), &map))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1256
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void adjust_branches(struct bpf_prog *prog, int pos, int delta)\n{\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint insn_cnt = prog->len;\n\tint i;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) != BPF_JMP ||\n\t\t    BPF_OP(insn->code) == BPF_CALL ||\n\t\t    BPF_OP(insn->code) == BPF_EXIT)\n\t\t\tcontinue;\n\n\t\tif (i < pos && i + insn->off + 1 > pos)\n\t\t\tinsn->off += delta;\n\t\telse if (i > pos + delta && i + insn->off + 1 <= pos + delta)\n\t\t\tinsn->off -= delta;\n\t}\n}",
        "output": "0",
        "idx": 1593
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct btrfs_device *btrfs_find_device(struct btrfs_fs_devices *fs_devices,\n\t\t\t\t       u64 devid, u8 *uuid, u8 *fsid,\n\t\t\t\t       bool seed)\n{\n\tstruct btrfs_device *device;\n\n\twhile (fs_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(fs_devices->metadata_uuid, fsid, BTRFS_FSID_SIZE)) {\n\t\t\tlist_for_each_entry(device, &fs_devices->devices,\n\t\t\t\t\t    dev_list) {\n\t\t\t\tif (device->devid == devid &&\n\t\t\t\t    (!uuid || memcmp(device->uuid, uuid,\n\t\t\t\t\t\t     BTRFS_UUID_SIZE) == 0))\n\t\t\t\t\treturn device;\n\t\t\t}\n\t\t}\n\t\tif (seed)\n\t\t\tfs_devices = fs_devices->seed;\n\t\telse\n\t\t\treturn NULL;\n\t}\n\treturn NULL;\n}",
        "output": "0",
        "idx": 4269
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int htc_config_pipe_credits(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_config_pipe_msg *cp_msg;\n\tint ret;\n\tunsigned long time_left;\n\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\n\tcp_msg = skb_put(skb, sizeof(struct htc_config_pipe_msg));\n\n\tcp_msg->message_id = cpu_to_be16(HTC_MSG_CONFIG_PIPE_ID);\n\tcp_msg->pipe_id = USB_WLAN_TX_PIPE;\n\tcp_msg->credits = target->credits;\n\n\ttarget->htc_flags |= HTC_OP_CONFIG_PIPE_CREDITS;\n\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC credit config timeout\\n\");\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}",
        "output": "0",
        "idx": 4463
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cJSON_DeleteItemFromArray( cJSON *array, int which )\n{\n\tcJSON_Delete( cJSON_DetachItemFromArray( array, which ) );\n}",
        "output": "1",
        "idx": 5910
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int swevent_hlist_get_cpu(struct perf_event *event, int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tint err = 0;\n\n\tmutex_lock(&swhash->hlist_mutex);\n\n\tif (!swevent_hlist_deref(swhash) && cpu_online(cpu)) {\n\t\tstruct swevent_hlist *hlist;\n\n\t\thlist = kzalloc(sizeof(*hlist), GFP_KERNEL);\n\t\tif (!hlist) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tswhash->hlist_refcount++;\nexit:\n\tmutex_unlock(&swhash->hlist_mutex);\n\n\treturn err;\n}",
        "output": "1",
        "idx": 1020
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_le_int (SF_PRIVATE *psf, int x)\n{\tpsf->header.ptr [psf->header.indx++] = x ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 24) ;\n} ",
        "output": "0",
        "idx": 6883
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseServerMonitors(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprJson     *child;\n    MprTicks    period;\n    cchar       *counter, *expression, *limit, *relation, *defenses;\n    int         ji;\n\n    for (ITERATE_CONFIG(route, prop, child, ji)) {\n        defenses = mprReadJson(child, \"defenses\");\n        expression = mprReadJson(child, \"expression\");\n        period = httpGetTicks(mprReadJson(child, \"period\"));\n\n        if (!httpTokenize(route, expression, \"%S %S %S\", &counter, &relation, &limit)) {\n            httpParseError(route, \"Cannot add monitor: %s\", prop->name);\n            break;\n        }\n        if (httpAddMonitor(counter, relation, getint(limit), period, defenses) < 0) {\n            httpParseError(route, \"Cannot add monitor: %s\", prop->name);\n            break;\n        }\n    }\n}",
        "output": "0",
        "idx": 7005
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "do_decrypt (const RIJNDAEL_context *ctx, unsigned char *bx,\n            const unsigned char *ax)\n{\n#ifdef USE_AMD64_ASM\n  return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n\t\t\t\t       &dec_tables);\n#elif defined(USE_ARM_ASM)\n  return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n\t\t\t\t     &dec_tables);\n#else\n  return do_decrypt_fn (ctx, bx, ax);\n#endif \n}",
        "output": "1",
        "idx": 7446
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cg_opendir(const char *path, struct fuse_file_info *fi)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tconst char *cgroup;\n\tstruct file_info *dir_info;\n\tchar *controller = NULL;\n\n\tif (!fc)\n\t\treturn -EIO;\n\n\tif (strcmp(path, \"/cgroup\") == 0) {\n\t\tcgroup = NULL;\n\t\tcontroller = NULL;\n\t} else {\n\t\tcontroller = pick_controller_from_path(fc, path);\n\t\tif (!controller)\n\t\t\treturn -EIO;\n\n\t\tcgroup = find_cgroup_in_path(path);\n\t\tif (!cgroup) {\n\t\t\tcgroup = \"/\";\n\t\t}\n\t}\n\n\tif (cgroup && !fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {\n\t\treturn -EACCES;\n\t}\n\n\tdir_info = malloc(sizeof(*dir_info));\n\tif (!dir_info)\n\t\treturn -ENOMEM;\n\tdir_info->controller = must_copy_string(controller);\n\tdir_info->cgroup = must_copy_string(cgroup);\n\tdir_info->type = LXC_TYPE_CGDIR;\n\tdir_info->buf = NULL;\n\tdir_info->file = NULL;\n\tdir_info->buflen = 0;\n\n\tfi->fh = (unsigned long)dir_info;\n\treturn 0;\n}",
        "output": "1",
        "idx": 5220
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "term_and_job_init(\n\tterm_T\t    *term,\n\ttypval_T    *argvar,\n\tchar\t    **argv,\n\tjobopt_T    *opt,\n\tjobopt_T    *orig_opt UNUSED)\n{\n    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)\n\treturn FAIL;\n\n#if defined(FEAT_GUI) || defined(FEAT_TERMGUICOLORS)\n    if (opt->jo_set2 & JO2_ANSI_COLORS)\n\tset_vterm_palette(term->tl_vterm, opt->jo_ansi_colors);\n    else\n\tinit_vterm_ansi_colors(term->tl_vterm);\n#endif\n\n    term->tl_job = job_start(argvar, argv, opt, TRUE);\n    if (term->tl_job != NULL)\n\t++term->tl_job->jv_refcount;\n\n    return term->tl_job != NULL\n\t&& term->tl_job->jv_channel != NULL\n\t&& term->tl_job->jv_status != JOB_FAILED ? OK : FAIL;\n}",
        "output": "0",
        "idx": 8155
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u32 gasp_version(__be32 *p)\n{\n\treturn be32_to_cpu(p[1]) & 0xffffff;\n}",
        "output": "0",
        "idx": 1999
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_timer_user_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tint err;\n\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->ioctl_lock);\n\ttu->ticks = 1;\n\ttu->queue_size = 128;\n\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;\n}",
        "output": "0",
        "idx": 1523
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void mcryptd_check_internal(struct rtattr **tb, u32 *type,\n\t\t\t\t\t  u32 *mask)\n{\n\tstruct crypto_attr_type *algt;\n\n\talgt = crypto_get_attr_type(tb);\n\tif (IS_ERR(algt))\n\t\treturn;\n\tif ((algt->type & CRYPTO_ALG_INTERNAL))\n\t\t*type |= CRYPTO_ALG_INTERNAL;\n\tif ((algt->mask & CRYPTO_ALG_INTERNAL))\n\t\t*mask |= CRYPTO_ALG_INTERNAL;\n}",
        "output": "1",
        "idx": 1396
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct snd_timer_user *tu = file->private_data;\n\tlong ret;\n\n\tmutex_lock(&tu->ioctl_lock);\n\tret = __snd_timer_user_ioctl(file, cmd, arg);\n\tmutex_unlock(&tu->ioctl_lock);\n\treturn ret;\n}",
        "output": "0",
        "idx": 1525
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool unconditional(const struct arpt_entry *e)\n{\n\tstatic const struct arpt_arp uncond;\n\n\treturn e->target_offset == sizeof(struct arpt_entry) &&\n\t       memcmp(&e->arp, &uncond, sizeof(uncond)) == 0;\n}",
        "output": "0",
        "idx": 1747
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, char *file_name, size_t file_size)\n{\n\tbee_t *bee = ic->bee;\n\tbee_user_t *bu = bee_user_by_handle(bee, ic, handle);\n\n\tif (bee->ui->ft_in_start) {\n\t\treturn bee->ui->ft_in_start(bee, bu, file_name, file_size);\n\t} else {\n\t\treturn NULL;\n\t}\n}",
        "output": "1",
        "idx": 5648
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_user_commands(expand_T *xp UNUSED, int idx)\n{\n    buf_T *buf = prevwin_curwin()->w_buffer;\n\n    if (idx < buf->b_ucmds.ga_len)\n\treturn USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;\n    idx -= buf->b_ucmds.ga_len;\n    if (idx < ucmds.ga_len)\n\treturn USER_CMD(idx)->uc_name;\n    return NULL;\n}",
        "output": "0",
        "idx": 8003
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tjp2_cmapent_t *ent;\n\tunsigned int i;\n\tcmap->ents = 0;\n\n\tcmap->numchans = (box->datalen) / 4;\n\tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tif (jp2_getuint16(in, &ent->cmptno) ||\n\t\t  jp2_getuint8(in, &ent->map) ||\n\t\t  jp2_getuint8(in, &ent->pcol)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\treturn 0;\n}",
        "output": "0",
        "idx": 7619
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Jsi_RC jsi_ArrayPushCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Obj *obj;\n    \n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    obj = _this->d.obj;\n    \n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = Jsi_ObjGetLength(interp, obj);\n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    \n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);\n        if (!ov) { Jsi_LogBug(\"Arguments Error\"); ov = Jsi_ValueNew(interp); }\n        Jsi_ValueInsertArray(interp, _this, curlen + i, ov, 0);\n    }\n    \n    Jsi_ValueMakeNumber(interp, ret, Jsi_ObjGetLength(interp, obj));\n    return JSI_OK;\n}",
        "output": "1",
        "idx": 8146
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline void update_rq_clock(struct rq *rq)\n{\n\tif (!rq->skip_clock_update) {\n\t\tint cpu = cpu_of(rq);\n\t\tu64 irq_time;\n\n\t\trq->clock = sched_clock_cpu(cpu);\n\t\tirq_time = irq_time_cpu(cpu);\n\t\tif (rq->clock - irq_time > rq->clock_task)\n\t\t\trq->clock_task = rq->clock - irq_time;\n\n\t\tsched_irq_time_avg_update(rq, irq_time);\n\t}\n}",
        "output": "1",
        "idx": 238
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ut64 MACH0_(get_baddr)(struct MACH0_(obj_t)* bin) {\n\tint i;\n\n\tif (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < bin->nsegs; ++i) {\n\t\tif (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0) {\n\t\t\treturn bin->segs[i].vmaddr;\n\t\t}\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 8633
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct resource_pool *dce100_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc  *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "output": "0",
        "idx": 4477
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "u64 secure_dccp_sequence_number(__be32 saddr, __be32 daddr,\n\t\t\t\t__be16 sport, __be16 dport)\n{\n\tu64 seq;\n\t__u32 hash[4];\n\tstruct keydata *keyptr = get_keyptr();\n\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n\thash[3] = keyptr->secret[11];\n\n\tseq = half_md4_transform(hash, keyptr->secret);\n\tseq |= ((u64)keyptr->count) << (32 - HASH_BITS);\n\n\tseq += ktime_to_ns(ktime_get_real());\n\tseq &= (1ull << 48) - 1;\n\n\treturn seq;\n}",
        "output": "1",
        "idx": 606
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n                OnigCompileInfo* ci, OnigErrorInfo* einfo)\n{\n  int r;\n  UChar *cpat, *cpat_end;\n\n  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n\n  if (ci->pattern_enc != ci->target_enc) {\n    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,\n                      &cpat, &cpat_end);\n    if (r != 0) return r;\n  }\n  else {\n    cpat     = (UChar* )pattern;\n    cpat_end = (UChar* )pattern_end;\n  }\n\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) {\n    r = ONIGERR_MEMORY;\n    goto err2;\n  }\n\n  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,\n                    ci->syntax);\n  if (r != 0) goto err;\n\n  r = onig_compile(*reg, cpat, cpat_end, einfo);\n  if (r != 0) {\n  err:\n    onig_free(*reg);\n    *reg = NULL;\n  }\n\n err2:\n  if (cpat != pattern) xfree(cpat);\n\n  return r;\n}",
        "output": "1",
        "idx": 6672
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\t_gdImageWebpCtx(im, out, quality);\n\tout->gd_free(out);\n}",
        "output": "0",
        "idx": 6197
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int fit_image_verify(const void *fit, int image_noffset)\n{\n\tconst void\t*data;\n\tsize_t\t\tsize;\n\tint\t\tnoffset = 0;\n\tchar\t\t*err_msg = \"\";\n\n\tif (fit_image_get_data_and_size(fit, image_noffset, &data, &size)) {\n\t\terr_msg = \"Can't get image data/size\";\n\t\tprintf(\"error!\\n%s for '%s' hash node in '%s' image node\\n\",\n\t\t       err_msg, fit_get_name(fit, noffset, NULL),\n\t\t       fit_get_name(fit, image_noffset, NULL));\n\t\treturn 0;\n\t}\n\n\treturn fit_image_verify_with_data(fit, image_noffset, data, size);\n}",
        "output": "1",
        "idx": 7386
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)\n{\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\n\tif (info->si_code >= 0)\n\t\treturn -EPERM;\n\tinfo->si_signo = sig;\n\n\treturn do_send_specific(tgid, pid, sig, info);\n}",
        "output": "1",
        "idx": 262
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static size_t hash_str(const void *ptr)\n{\n    const char *str = (const char *)ptr;\n\n    size_t hash = 5381;\n    size_t c;\n\n    while((c = (size_t)*str))\n    {\n        hash = ((hash << 5) + hash) + c;\n        str++;\n    }\n\n    return hash;\n}",
        "output": "1",
        "idx": 4306
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_utimes(const char *path)\n{\n\tstruct utimbuf times;\n\ttimes.actime = 0;\n\ttimes.modtime = 0;\n\n\tif (utime(path, &times) == 0) {\n\t\tfprintf(stderr, \"leak at utime of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at utime of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}",
        "output": "0",
        "idx": 7273
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\t__must_hold(&ctx->completion_lock)\n{\n\tu32 seq = ctx->cached_cq_tail - atomic_read(&ctx->cq_timeouts);\n\tstruct io_kiocb *req, *tmp;\n\n\tspin_lock_irq(&ctx->timeout_lock);\n\tlist_for_each_entry_safe(req, tmp, &ctx->timeout_list, timeout.list) {\n\t\tu32 events_needed, events_got;\n\n\t\tif (io_is_timeout_noseq(req))\n\t\t\tbreak;\n\n\t\tevents_needed = req->timeout.target_seq - ctx->cq_last_tm_flush;\n\t\tevents_got = seq - ctx->cq_last_tm_flush;\n\t\tif (events_got < events_needed)\n\t\t\tbreak;\n\n\t\tio_kill_timeout(req, 0);\n\t}\n\tctx->cq_last_tm_flush = seq;\n\tspin_unlock_irq(&ctx->timeout_lock);\n}",
        "output": "0",
        "idx": 2923
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API int r_socket_block_time(RSocket *s, int block, int sec, int usec) {\n#if __UNIX__\n\tint ret, flags;\n#endif\n\tif (!s) {\n\t\treturn false;\n\t}\n#if __UNIX__\n\tflags = fcntl (s->fd, F_GETFL, 0);\n\tif (flags < 0) {\n\t\treturn false;\n\t}\n\tret = fcntl (s->fd, F_SETFL, block?\n\t\t\t(flags & ~O_NONBLOCK):\n\t\t\t(flags | O_NONBLOCK));\n\tif (ret < 0) {\n\t\treturn false;\n\t}\n#elif __WINDOWS__\n\tioctlsocket (s->fd, FIONBIO, (u_long FAR*)&block);\n#endif\n\tif (sec > 0 || usec > 0) {\n\t\tstruct timeval tv = {0};\n\t\ttv.tv_sec = sec;\n\t\ttv.tv_usec = usec;\n\t\tif (setsockopt (s->fd, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof (tv)) < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}",
        "output": "1",
        "idx": 6410
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void CLASS foveon_dp_load_raw()\n{\n  unsigned c, roff[4], row, col, diff;\n  ushort huff[512], vpred[2][2], hpred[2];\n\n  fseek (ifp, 8, SEEK_CUR);\n  foveon_huff (huff);\n  roff[0] = 48;\n  FORC3 roff[c+1] = -(-(roff[c] + get4()) & -16);\n  FORC3 {\n    fseek (ifp, data_offset+roff[c], SEEK_SET);\n    getbits(-1);\n    vpred[0][0] = vpred[0][1] = vpred[1][0] = vpred[1][1] = 512;\n    for (row=0; row < height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n      for (col=0; col < width; col++) {\n\tdiff = ljpeg_diff(huff);\n\tif (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n\telse hpred[col & 1] += diff;\n\timage[row*width+col][c] = hpred[col & 1];\n      }\n    }\n  }\n}",
        "output": "1",
        "idx": 6568
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hybiRemaining(ws_ctx_t *wsctx)\n{\n  return wsctx->nToRead - wsctx->nReadRaw;\n}",
        "output": "0",
        "idx": 8905
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct dentry *aio_mount(struct file_system_type *fs_type,\n\t\t\t\tint flags, const char *dev_name, void *data)\n{\n\tstatic const struct dentry_operations ops = {\n\t\t.d_dname\t= simple_dname,\n\t};\n\treturn mount_pseudo(fs_type, \"aio:\", NULL, &ops, AIO_RING_MAGIC);\n}",
        "output": "1",
        "idx": 1310
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_syscall_enter(void *ignore, struct pt_regs *regs, long id)\n{\n\tstruct syscall_metadata *sys_data;\n\tstruct syscall_trace_enter *rec;\n\tstruct hlist_head *head;\n\tint syscall_nr;\n\tint rctx;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0)\n\t\treturn;\n\tif (!test_bit(syscall_nr, enabled_perf_enter_syscalls))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\thead = this_cpu_ptr(sys_data->enter_event->perf_events);\n\tif (hlist_empty(head))\n\t\treturn;\n\n\tsize = sizeof(unsigned long) * sys_data->nb_args + sizeof(*rec);\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\trec = (struct syscall_trace_enter *)perf_trace_buf_prepare(size,\n\t\t\t\tsys_data->enter_event->event.type, regs, &rctx);\n\tif (!rec)\n\t\treturn;\n\n\trec->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, 0, sys_data->nb_args,\n\t\t\t       (unsigned long *)&rec->args);\n\tperf_trace_buf_submit(rec, size, rctx, 0, 1, regs, head, NULL);\n}",
        "output": "1",
        "idx": 2710
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr)\n{\n\tsiginfo_t info;\n\tvoid __user *pc = (void __user *)instruction_pointer(regs);\n\tconsole_verbose();\n\n\tpr_crit(\"Bad mode in %s handler detected, code 0x%08x\\n\",\n\t\thandler[reason], esr);\n\t__show_regs(regs);\n\n\tinfo.si_signo = SIGILL;\n\tinfo.si_errno = 0;\n\tinfo.si_code  = ILL_ILLOPC;\n\tinfo.si_addr  = pc;\n\n\tarm64_notify_die(\"Oops - bad mode\", regs, &info, 0);\n}",
        "output": "0",
        "idx": 3241
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_own_dir(const char *argv0) {\n\tsize_t l = strlen(argv0);\n\twhile(l && argv0[l - 1] != '/')\n\t\tl--;\n\tif(l == 0)\n#ifdef SUPER_SECURE\n\t\tmemcpy(own_dir, \"/dev/null/\", 2);\n#else\n\t\tmemcpy(own_dir, \".\", 2);\n#endif\n\telse {\n\t\tmemcpy(own_dir, argv0, l - 1);\n\t\town_dir[l] = 0;\n\t}\n}",
        "output": "0",
        "idx": 7397
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NOEXPORT char *base64(int encode, const char *in, int len) {\n    BIO *bio, *b64;\n    char *out;\n    int n;\n\n    b64=BIO_new(BIO_f_base64());\n    if(!b64)\n        return NULL;\n    BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);\n    bio=BIO_new(BIO_s_mem());\n    if(!bio) {\n        str_free(b64);\n        return NULL;\n    }\n    if(encode)\n        bio=BIO_push(b64, bio);\n    BIO_write(bio, in, len);\n    (void)BIO_flush(bio); \n    if(encode) {\n        bio=BIO_pop(bio);\n        BIO_free(b64);\n    } else {\n        bio=BIO_push(b64, bio);\n    }\n    n=BIO_pending(bio);\n    out=str_alloc(n<32?32:(size_t)n+1);\n    n=BIO_read(bio, out, n);\n    if(n<0) {\n        BIO_free_all(bio);\n        str_free(out);\n        return NULL;\n    }\n    BIO_free_all(bio);\n    return out;\n}",
        "output": "1",
        "idx": 8456
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ext4_free_io_end(ext4_io_end_t *io)\n{\n\tBUG_ON(!io);\n\tiput(io->inode);\n\tkfree(io);\n}",
        "output": "1",
        "idx": 2240
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nautilus_file_mark_desktop_file_executable (GFile              *file,\n                                            GtkWindow          *parent_window,\n                                            gboolean            interactive,\n                                            NautilusOpCallback  done_callback,\n                                            gpointer            done_callback_data)\n{\n    GTask *task;\n    MarkTrustedJob *job;\n\n    job = op_job_new (MarkTrustedJob, parent_window);\n    job->file = g_object_ref (file);\n    job->interactive = interactive;\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n\n    task = g_task_new (NULL, NULL, mark_desktop_file_executable_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, mark_desktop_file_executable_task_thread_func);\n    g_object_unref (task);\n}",
        "output": "0",
        "idx": 8813
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int msg_cache_check (const char *id, body_cache_t *bcache, void *data)\n{\n  CONTEXT *ctx;\n  POP_DATA *pop_data;\n  int i;\n\n  if (!(ctx = (CONTEXT *)data))\n    return -1;\n  if (!(pop_data = (POP_DATA *)ctx->data))\n    return -1;\n\n#ifdef USE_HCACHE\n  if (strcmp (HC_FNAME \".\" HC_FEXT, id) == 0)\n    return 0;\n#endif\n\n  for (i = 0; i < ctx->msgcount; i++)\n    if (ctx->hdrs[i]->data && mutt_strcmp (ctx->hdrs[i]->data, id) == 0)\n      return 0;\n\n  return mutt_bcache_del (bcache, id);\n}",
        "output": "1",
        "idx": 6948
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "write_stacktrace(const char *file_name, const char *str)\n{\n\tint fd;\n\tvoid *buffer[100];\n\tint nptrs;\n\tint i;\n\tchar **strs;\n\n\tnptrs = backtrace(buffer, 100);\n\tif (file_name) {\n\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n\t\tif (str)\n\t\t\tdprintf(fd, \"%s\\n\", str);\n\t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n\t\tif (write(fd, \"\\n\", 1) != 1) {\n\t\t}\n\t\tclose(fd);\n\t} else {\n\t\tif (str)\n\t\t\tlog_message(LOG_INFO, \"%s\", str);\n\t\tstrs = backtrace_symbols(buffer, nptrs);\n\t\tif (strs == NULL) {\n\t\t\tlog_message(LOG_INFO, \"Unable to get stack backtrace\");\n\t\t\treturn;\n\t\t}\n\n\t\tfor (i = 1; i < nptrs - 2; i++)\n\t\t\tlog_message(LOG_INFO, \"  %s\", strs[i]);\n\t\tfree(strs);\n\t}\n}",
        "output": "1",
        "idx": 7106
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jas_iccgetuint64(jas_stream_t *in, jas_iccuint64_t *val)\n{\n\tulonglong tmp;\n\tif (jas_iccgetuint(in, 8, &tmp))\n\t\treturn -1;\n\t*val = tmp;\n\treturn 0;\n}",
        "output": "1",
        "idx": 5388
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nlmsg_populate_mdb_fill(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   struct br_mdb_entry *entry, u32 pid,\n\t\t\t\t   u32 seq, int type, unsigned int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct br_port_msg *bpm;\n\tstruct nlattr *nest, *nest2;\n\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*bpm), NLM_F_MULTI);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tbpm = nlmsg_data(nlh);\n\tmemset(bpm, 0, sizeof(*bpm));\n\tbpm->family  = AF_BRIDGE;\n\tbpm->ifindex = dev->ifindex;\n\tnest = nla_nest_start(skb, MDBA_MDB);\n\tif (nest == NULL)\n\t\tgoto cancel;\n\tnest2 = nla_nest_start(skb, MDBA_MDB_ENTRY);\n\tif (nest2 == NULL)\n\t\tgoto end;\n\n\tif (nla_put(skb, MDBA_MDB_ENTRY_INFO, sizeof(*entry), entry))\n\t\tgoto end;\n\n\tnla_nest_end(skb, nest2);\n\tnla_nest_end(skb, nest);\n\treturn nlmsg_end(skb, nlh);\n\nend:\n\tnla_nest_end(skb, nest);\ncancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}",
        "output": "0",
        "idx": 1205
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void utee_param_to_param(struct tee_ta_param *p, struct utee_params *up)\n{\n\tsize_t n;\n\tuint32_t types = up->types;\n\n\tp->types = types;\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\t\tuintptr_t a = up->vals[n * 2];\n\t\tsize_t b = up->vals[n * 2 + 1];\n\n\t\tswitch (TEE_PARAM_TYPE_GET(types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tp->u[n].mem.mobj = &mobj_virt;\n\t\t\tp->u[n].mem.offs = a;\n\t\t\tp->u[n].mem.size = b;\n\t\t\tbreak;\n\t\tcase TEE_PARAM_TYPE_VALUE_INPUT:\n\t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tp->u[n].val.a = a;\n\t\t\tp->u[n].val.b = b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemset(&p->u[n], 0, sizeof(p->u[n]));\n\t\t\tbreak;\n\t\t}\n\t}\n}",
        "output": "1",
        "idx": 7376
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)\n{\n\tstruct cred *cred;\n\tint err = -ENOMEM;\n\n\tif (!(unshare_flags & CLONE_NEWUSER))\n\t\treturn 0;\n\n\tcred = prepare_creds();\n\tif (cred) {\n\t\terr = create_user_ns(cred);\n\t\tif (err)\n\t\t\tput_cred(cred);\n\t\telse\n\t\t\t*new_cred = cred;\n\t}\n\n\treturn err;\n}",
        "output": "0",
        "idx": 3293
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedpcalloc(nedpool *p, size_t no, size_t size) THROWSPEC\r\n{\r\n\tsize_t bytes=no*size;\r\n\tif(size && no!=bytes/size)\r\n\t\treturn 0;\r\n\tunsigned flags=NEDMALLOC_FORCERESERVE(p, 0, bytes);\r\n\treturn nedpmalloc2(p, bytes, 0, M2_ZERO_MEMORY|flags);\r\n}\r",
        "output": "0",
        "idx": 5077
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void jiffies_to_timeval(const unsigned long jiffies, struct timeval *value)\n{\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tlong tv_usec;\n\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tv_usec);\n\ttv_usec /= NSEC_PER_USEC;\n\tvalue->tv_usec = tv_usec;\n}",
        "output": "1",
        "idx": 2102
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void sock_release(struct socket *sock)\n{\n\tif (sock->ops) {\n\t\tstruct module *owner = sock->ops->owner;\n\n\t\tsock->ops->release(sock);\n\t\tsock->ops = NULL;\n\t\tmodule_put(owner);\n\t}\n\n\tif (rcu_dereference_protected(sock->wq, 1)->fasync_list)\n\t\tpr_err(\"%s: fasync list not empty!\\n\", __func__);\n\n\tif (!sock->file) {\n\t\tiput(SOCK_INODE(sock));\n\t\treturn;\n\t}\n\tsock->file = NULL;\n}",
        "output": "1",
        "idx": 2968
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static LUA_FUNCTION(openssl_x509_check_ip_asc)\n{\n  X509 * cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (lua_isstring(L, 2))\n  {\n    const char *ip_asc = lua_tostring(L, 2);\n    lua_pushboolean(L, X509_check_ip_asc(cert, ip_asc, 0));\n  }\n  else\n  {\n    lua_pushboolean(L, 0);\n  }\n  return 1;\n}",
        "output": "1",
        "idx": 8428
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void fput(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\n\t\tfile_sb_list_del(file);\n\t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n\t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n\t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n\t\t\t\treturn;\n\t\t}\n\n\t\tif (llist_add(&file->f_u.fu_llist, &delayed_fput_list))\n\t\t\tschedule_work(&delayed_fput_work);\n\t}\n}",
        "output": "1",
        "idx": 2376
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int threaded_has_dirs_only_path(struct cache_def *cache, const char *name, int len, int prefix_len)\n{\n\treturn lstat_cache(cache, name, len,\n\t\t\t   FL_DIR|FL_FULLPATH, prefix_len) &\n\t\tFL_DIR;\n}",
        "output": "0",
        "idx": 7211
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "service_info *FindServiceControlURLPath(\n\tservice_table *table, const char *controlURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\n\tif (table && parse_uri(controlURLPath,\n\t\t\t     strlen(controlURLPath),\n\t\t\t     &parsed_url_in) == HTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->controlURL) {\n\t\t\t\tif (parse_uri(finger->controlURL,\n\t\t\t\t\t    strlen(finger->controlURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
        "output": "1",
        "idx": 7994
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION( locale_get_region ) \n{\n\tget_icu_value_src_php( LOC_REGION_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}",
        "output": "1",
        "idx": 3892
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool mcryptd_check_internal(struct rtattr **tb, u32 *type,\n\t\t\t\t\t  u32 *mask)\n{\n\tstruct crypto_attr_type *algt;\n\n\talgt = crypto_get_attr_type(tb);\n\tif (IS_ERR(algt))\n\t\treturn false;\n\n\t*type |= algt->type & CRYPTO_ALG_INTERNAL;\n\t*mask |= algt->mask & CRYPTO_ALG_INTERNAL;\n\n\tif (*type & *mask & CRYPTO_ALG_INTERNAL)\n\t\treturn true;\n\telse\n\t\treturn false;\n}",
        "output": "0",
        "idx": 2039
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct ion_handle *ion_handle_get_by_id_nolock(struct ion_client *client,\n\t\t\t\t\t\tint id)\n{\n\tstruct ion_handle *handle;\n\n\thandle = idr_find(&client->idr, id);\n\tif (handle)\n\t\tion_handle_get(handle);\n\n\treturn handle ? handle : ERR_PTR(-EINVAL);\n}",
        "output": "0",
        "idx": 1689
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool check_underflow(const struct arpt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\n\tif (!unconditional(&e->arp))\n\t\treturn false;\n\tt = arpt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}",
        "output": "1",
        "idx": 1186
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned decode_digit(int cp)\n{\n  return (unsigned) (cp - 48 < 10 ? cp - 22 :  cp - 65 < 26 ? cp - 65 :\n         cp - 97 < 26 ? cp - 97 :  base);\n}",
        "output": "0",
        "idx": 8785
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool skb_is_err_queue(const struct sk_buff *skb)\n{\n\treturn skb->pkt_type == PACKET_OUTGOING;\n}",
        "output": "0",
        "idx": 2215
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ip_options_get(struct net *net, struct ip_options **optp,\n\t\t   unsigned char *data, int optlen)\n{\n\tstruct ip_options *opt = ip_options_get_alloc(optlen);\n\n\tif (!opt)\n\t\treturn -ENOMEM;\n\tif (optlen)\n\t\tmemcpy(opt->__data, data, optlen);\n\treturn ip_options_get_finish(net, optp, opt, optlen);\n}",
        "output": "1",
        "idx": 348
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int virtio_gpu_object_create(struct virtio_gpu_device *vgdev,\n\t\t\t     unsigned long size, bool kernel, bool pinned,\n\t\t\t     struct virtio_gpu_object **bo_ptr)\n{\n\tstruct virtio_gpu_object *bo;\n\tenum ttm_bo_type type;\n\tsize_t acc_size;\n\tint ret;\n\n\tif (kernel)\n\t\ttype = ttm_bo_type_kernel;\n\telse\n\t\ttype = ttm_bo_type_device;\n\t*bo_ptr = NULL;\n\n\tacc_size = ttm_bo_dma_acc_size(&vgdev->mman.bdev, size,\n\t\t\t\t       sizeof(struct virtio_gpu_object));\n\n\tbo = kzalloc(sizeof(struct virtio_gpu_object), GFP_KERNEL);\n\tif (bo == NULL)\n\t\treturn -ENOMEM;\n\tsize = roundup(size, PAGE_SIZE);\n\tret = drm_gem_object_init(vgdev->ddev, &bo->gem_base, size);\n\tif (ret != 0)\n\t\treturn ret;\n\tbo->dumb = false;\n\tvirtio_gpu_init_ttm_placement(bo, pinned);\n\n\tret = ttm_bo_init(&vgdev->mman.bdev, &bo->tbo, size, type,\n\t\t\t  &bo->placement, 0, !kernel, NULL, acc_size,\n\t\t\t  NULL, NULL, &virtio_gpu_ttm_bo_destroy);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t*bo_ptr = bo;\n\treturn 0;\n}",
        "output": "1",
        "idx": 1542
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int _server_handle_vCont(libgdbr_t *g, int (*cmd_cb) (void*, const char*, char*, size_t), void *core_ptr) {\n\tchar *action = NULL;\n\tif (send_ack (g) < 0) {\n\t\treturn -1;\n\t}\n\tg->data[g->data_len] = '\\0';\n\tif (g->data[5] == '?') {\n\t\treturn send_msg (g, \"vCont;c;s\");\n\t}\n\tif (!(action = strtok (g->data, \";\"))) {\n\t\treturn send_msg (g, \"E01\");\n\t}\n\twhile (action = strtok (NULL, \";\")) {\n\t\teprintf (\"action: %s\\n\", action);\n\t\tswitch (action[0]) {\n\t\tcase 's':\n\t\t\tif (cmd_cb (core_ptr, \"ds\", NULL, 0) < 0) {\n\t\t\t\tsend_msg (g, \"E01\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn send_msg (g, \"OK\");\n\t\tcase 'c':\n\t\t\tif (cmd_cb (core_ptr, \"dc\", NULL, 0) < 0) {\n\t\t\t\tsend_msg (g, \"E01\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn send_msg (g, \"OK\");\n\t\tdefault:\n\t\t\treturn send_msg (g, \"E01\");\n\t\t}\n\t}\n\treturn -1;\n}",
        "output": "0",
        "idx": 8639
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK;\n  if (goodsize > LUAI_MAXSTACK)\n    goodsize = LUAI_MAXSTACK;  \n  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) &&\n      goodsize < L->stacksize)\n    luaD_reallocstack(L, goodsize, 0);  \n  else  \n    condmovestack(L,{},{});  \n  luaE_shrinkCI(L);  \n}",
        "output": "1",
        "idx": 8090
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dhcps_deinit(void)\n{\n\tif (dhcps_pcb != NULL) {\n\t\tudp_remove(dhcps_pcb);\n\t\tdhcps_pcb = NULL;\t\n\t}\n\tif (dhcps_ip_table_semaphore != NULL) {\t\n\t\tvSemaphoreDelete(dhcps_ip_table_semaphore);\n\t\tdhcps_ip_table_semaphore = NULL;\n\t}\t\t\n}",
        "output": "1",
        "idx": 8406
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {\n    Sfdouble_t d;\n    char *last;\n\n    if (*str == 0) {\n        if (ptr) *ptr = (char *)str;\n        return 0;\n    }\n    errno = 0;\n    d = number(str, &last, shp->inarith ? 0 : 10, NULL);\n    if (*last) {\n        if (*last != '.' || last[1] != '.') {\n            d = strval(shp, str, &last, arith, mode);\n            Varsubscript = true;\n        }\n        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);\n    } else if (!d && *str == '-') {\n        d = -0.0;\n    }\n    if (ptr) *ptr = last;\n    return d;\n}",
        "output": "1",
        "idx": 7492
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void __file_sb_list_add(struct file *file, struct super_block *sb)\n{\n\tstruct list_head *list;\n#ifdef CONFIG_SMP\n\tint cpu;\n\tcpu = smp_processor_id();\n\tfile->f_sb_list_cpu = cpu;\n\tlist = per_cpu_ptr(sb->s_files, cpu);\n#else\n\tlist = &sb->s_files;\n#endif\n\tlist_add(&file->f_u.fu_list, list);\n}",
        "output": "1",
        "idx": 2382
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n\t\t\t  int iov_count)\n{\n    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t    return (GSS_S_NO_CONTEXT);\n\n    return gss_verify_mic_iov(minor_status, sc->ctx_handle, qop_state, iov,\n\t\t\t      iov_count);\n}",
        "output": "0",
        "idx": 69
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPU_ID);\n}",
        "output": "0",
        "idx": 2019
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sas_destruct_devices(struct work_struct *work)\n{\n\tstruct domain_device *dev, *n;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\n\tclear_bit(DISCE_DESTRUCT, &port->disc.pending);\n\n\tlist_for_each_entry_safe(dev, n, &port->destroy_list, disco_list_node) {\n\t\tlist_del_init(&dev->disco_list_node);\n\n\t\tsas_remove_children(&dev->rphy->dev);\n\t\tsas_rphy_delete(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t}\n}",
        "output": "1",
        "idx": 1830
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ikev1_attr_print(netdissect_options *ndo, const u_char *p, const u_char *ep)\n{\n\tint totlen;\n\tuint32_t t;\n\n\tif (p[0] & 0x80)\n\t\ttotlen = 4;\n\telse\n\t\ttotlen = 4 + EXTRACT_16BITS(&p[2]);\n\tif (ep < p + totlen) {\n\t\tND_PRINT((ndo,\"[|attr]\"));\n\t\treturn ep + 1;\n\t}\n\n\tND_PRINT((ndo,\"(\"));\n\tt = EXTRACT_16BITS(&p[0]) & 0x7fff;\n\tND_PRINT((ndo,\"type=#%d \", t));\n\tif (p[0] & 0x80) {\n\t\tND_PRINT((ndo,\"value=\"));\n\t\tt = p[2];\n\t\trawprint(ndo, (const uint8_t *)&p[2], 2);\n\t} else {\n\t\tND_PRINT((ndo,\"len=%d value=\", EXTRACT_16BITS(&p[2])));\n\t\trawprint(ndo, (const uint8_t *)&p[4], EXTRACT_16BITS(&p[2]));\n\t}\n\tND_PRINT((ndo,\")\"));\n\treturn p + totlen;\n}",
        "output": "1",
        "idx": 4828
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "init_connection_options(MYSQL *mysql)\n{\n  SSL_SET_OPTIONS(mysql);\n\n  if (opt_protocol)\n    mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);\n\n#ifdef HAVE_SMEM\n  if (shared_memory_base_name)\n    mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME, shared_memory_base_name);\n#endif\n}",
        "output": "0",
        "idx": 7369
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iakerb_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                          gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n                          int iov_count)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_verify_mic_iov(minor_status, ctx->gssc, qop_state, iov,\n                                   iov_count);\n}",
        "output": "0",
        "idx": 153
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iakerb_gss_inquire_sec_context_by_oid(OM_uint32 *minor_status,\n                                      const gss_ctx_id_t context_handle,\n                                      const gss_OID desired_object,\n                                      gss_buffer_set_t *data_set)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_UNAVAILABLE;\n\n    return krb5_gss_inquire_sec_context_by_oid(minor_status, ctx->gssc,\n                                               desired_object, data_set);\n}",
        "output": "0",
        "idx": 129
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)\n{\n\tint *fdp = (int*)CMSG_DATA(cmsg);\n\tstruct scm_fp_list *fpl = *fplp;\n\tstruct file **fpp;\n\tint i, num;\n\n\tnum = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr)))/sizeof(int);\n\n\tif (num <= 0)\n\t\treturn 0;\n\n\tif (num > SCM_MAX_FD)\n\t\treturn -EINVAL;\n\n\tif (!fpl)\n\t{\n\t\tfpl = kmalloc(sizeof(struct scm_fp_list), GFP_KERNEL);\n\t\tif (!fpl)\n\t\t\treturn -ENOMEM;\n\t\t*fplp = fpl;\n\t\tfpl->count = 0;\n\t\tfpl->max = SCM_MAX_FD;\n\t\tfpl->user = NULL;\n\t}\n\tfpp = &fpl->fp[fpl->count];\n\n\tif (fpl->count + num > fpl->max)\n\t\treturn -EINVAL;\n\n\n\tfor (i=0; i< num; i++)\n\t{\n\t\tint fd = fdp[i];\n\t\tstruct file *file;\n\n\t\tif (fd < 0 || !(file = fget_raw(fd)))\n\t\t\treturn -EBADF;\n\t\t*fpp++ = file;\n\t\tfpl->count++;\n\t}\n\n\tif (!fpl->user)\n\t\tfpl->user = get_uid(current_user());\n\n\treturn num;\n}",
        "output": "0",
        "idx": 1579
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void inet_sock_destruct(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_error_queue);\n\n\tsk_mem_reclaim(sk);\n\n\tif (sk->sk_type == SOCK_STREAM && sk->sk_state != TCP_CLOSE) {\n\t\tpr_err(\"Attempt to release TCP socket in state %d %p\\n\",\n\t\t       sk->sk_state, sk);\n\t\treturn;\n\t}\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive inet socket %p\\n\", sk);\n\t\treturn;\n\t}\n\n\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n\tWARN_ON(sk->sk_wmem_queued);\n\tWARN_ON(sk->sk_forward_alloc);\n\n\tkfree(inet->opt);\n\tdst_release(rcu_dereference_check(sk->sk_dst_cache, 1));\n\tsk_refcnt_debug_dec(sk);\n}",
        "output": "1",
        "idx": 322
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __exit acpi_custom_method_exit(void)\n{\n\tif (cm_dentry)\n\t\tdebugfs_remove(cm_dentry);\n }",
        "output": "0",
        "idx": 541
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rs_filter_graph(RSFilter *filter)\n{\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\tgchar *dot_filename;\n\tgchar *png_filename;\n\tgchar *command_line;\n\tGString *str = g_string_new(\"digraph G {\\n\");\n\n\trs_filter_graph_helper(str, filter);\n\n\tg_string_append_printf(str, \"}\\n\");\n\n\tdot_filename = g_strdup_printf(\"/tmp/rs-filter-graph.%u\", g_random_int());\n\tpng_filename = g_strdup_printf(\"%s.%u.png\", dot_filename, g_random_int());\n\n\tg_file_set_contents(dot_filename, str->str, str->len, NULL);\n\n\tcommand_line = g_strdup_printf(\"dot -Tpng >%s <%s\", png_filename, dot_filename);\n\tif (0 != system(command_line))\n\t\tg_warning(\"Calling dot failed\");\n\tg_free(command_line);\n\n\tcommand_line = g_strdup_printf(\"gnome-open %s\", png_filename);\n\tif (0 != system(command_line))\n\t\tg_warning(\"Calling gnome-open failed.\");\n\tg_free(command_line);\n\n\tg_free(dot_filename);\n\tg_free(png_filename);\n\tg_string_free(str, TRUE);\n}",
        "output": "0",
        "idx": 6437
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dns_resolver_match_preparse(struct key_match_data *match_data)\n{\n\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n\tmatch_data->cmp = dns_resolver_cmp;\n\treturn 0;\n}",
        "output": "0",
        "idx": 3681
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool too_many_pipe_buffers_hard(struct user_struct *user)\n{\n\treturn pipe_user_pages_hard &&\n\t       atomic_long_read(&user->pipe_bufs) >= pipe_user_pages_hard;\n}",
        "output": "0",
        "idx": 1561
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ptrace_setoptions(struct task_struct *child, unsigned long data)\n{\n\tunsigned flags;\n\tint ret;\n\n\tret = check_ptrace_options(data);\n\tif (ret)\n\t\treturn ret;\n\n\tflags = child->ptrace;\n\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);\n\tflags |= (data << PT_OPT_FLAG_SHIFT);\n\tchild->ptrace = flags;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2909
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_ctl_elem_write(struct snd_card *card, struct snd_ctl_file *file,\n\t\t\t      struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint result;\n\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\t\tvd = &kctl->vd[index_offset];\n\t\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_WRITE) ||\n\t\t    kctl->put == NULL ||\n\t\t    (file && vd->owner && vd->owner != file)) {\n\t\t\tresult = -EPERM;\n\t\t} else {\n\t\t\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n\t\t\tresult = kctl->put(kctl, control);\n\t\t}\n\t\tif (result > 0) {\n\t\t\tup_read(&card->controls_rwsem);\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t       &control->id);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tup_read(&card->controls_rwsem);\n\treturn result;\n}",
        "output": "1",
        "idx": 2602
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dbcs_ptr2len(char_u *p)\n{\n    int\t\tlen;\n\n    if (*p == NUL)\n\treturn 0;\n\n    len = MB_BYTE2LEN(*p);\n    if (len == 2 && p[1] == NUL)\n\tlen = 1;\n    return len;\n}",
        "output": "0",
        "idx": 8121
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct nfs_client *nfs4_alloc_client(const struct nfs_client_initdata *cl_init)\n{\n\tint err;\n\tstruct nfs_client *clp = nfs_alloc_client(cl_init);\n\tif (IS_ERR(clp))\n\t\treturn clp;\n\n\terr = nfs_get_cb_ident_idr(clp, cl_init->minorversion);\n\tif (err)\n\t\tgoto error;\n\n\tif (cl_init->minorversion > NFS4_MAX_MINOR_VERSION) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tspin_lock_init(&clp->cl_lock);\n\tINIT_DELAYED_WORK(&clp->cl_renewd, nfs4_renew_state);\n\tINIT_LIST_HEAD(&clp->cl_ds_clients);\n\trpc_init_wait_queue(&clp->cl_rpcwaitq, \"NFS client\");\n\tclp->cl_state = 1 << NFS4CLNT_LEASE_EXPIRED;\n\tclp->cl_mvops = nfs_v4_minor_ops[cl_init->minorversion];\n\tclp->cl_mig_gen = 1;\n#if IS_ENABLED(CONFIG_NFS_V4_1)\n\tinit_waitqueue_head(&clp->cl_lock_waitq);\n#endif\n\tINIT_LIST_HEAD(&clp->pending_cb_stateids);\n\treturn clp;\n\nerror:\n\tnfs_free_client(clp);\n\treturn ERR_PTR(err);\n}",
        "output": "1",
        "idx": 1942
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int pmd_large(pmd_t pte)\n{\n\treturn pmd_flags(pte) & _PAGE_PSE;\n}",
        "output": "0",
        "idx": 1067
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool states_equal(struct bpf_verifier_env *env,\n\t\t\t struct bpf_verifier_state *old,\n\t\t\t struct bpf_verifier_state *cur)\n{\n\tint i;\n\n\tif (old->curframe != cur->curframe)\n\t\treturn false;\n\n\tif (old->speculative && !cur->speculative)\n\t\treturn false;\n\n\tfor (i = 0; i <= old->curframe; i++) {\n\t\tif (old->frame[i]->callsite != cur->frame[i]->callsite)\n\t\t\treturn false;\n\t\tif (!func_states_equal(old->frame[i], cur->frame[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
        "output": "0",
        "idx": 4207
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __exit pf_exit(void)\n{\n\tstruct pf_unit *pf;\n\tint unit;\n\tunregister_blkdev(major, name);\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tif (!pf->disk)\n\t\t\tcontinue;\n\n\t\tif (pf->present)\n\t\t\tdel_gendisk(pf->disk);\n\n\t\tblk_cleanup_queue(pf->disk->queue);\n\t\tblk_mq_free_tag_set(&pf->tag_set);\n\t\tput_disk(pf->disk);\n\n\t\tif (pf->present)\n\t\t\tpi_release(pf->pi);\n\t}\n}",
        "output": "0",
        "idx": 4317
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int string_rfind(const char *input, int len, const char *s, int s_len,\n                 int pos, bool case_sensitive) {\n  assertx(input);\n  assertx(s);\n  if (!s_len || pos < -len || pos > len) {\n    return -1;\n  }\n  void *ptr;\n  if (case_sensitive) {\n    if (pos >= 0) {\n      ptr = bstrrstr(input + pos, len - pos, s, s_len);\n    } else {\n      ptr = bstrrstr(input, len + pos + s_len, s, s_len);\n    }\n  } else {\n    if (pos >= 0) {\n      ptr = bstrrcasestr(input + pos, len - pos, s, s_len);\n    } else {\n      ptr = bstrrcasestr(input, len + pos + s_len, s, s_len);\n    }\n  }\n  if (ptr != nullptr) {\n    return (int)((const char *)ptr - input);\n  }\n  return -1;\n}",
        "output": "1",
        "idx": 4506
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_mknod(const char *path)\n{\n\tif (mknod(path, 0755, makedev(0, 0)) == 0) {\n\t\tfprintf(stderr, \"leak at mknod of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at mknod of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}",
        "output": "0",
        "idx": 7263
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void unix_dgram_peer_wake_disconnect_wakeup(struct sock *sk,\n\t\t\t\t\t\t   struct sock *other)\n{\n\tunix_dgram_peer_wake_disconnect(sk, other);\n\twake_up_interruptible_poll(sk_sleep(sk),\n\t\t\t\t   POLLOUT |\n\t\t\t\t   POLLWRNORM |\n\t\t\t\t   POLLWRBAND);\n}",
        "output": "0",
        "idx": 1363
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void lpc546xxEthEventHandler(NetInterface *interface)\n{\n   error_t error;\n\n   if((ENET->DMA_CH[0].DMA_CHX_STAT & ENET_DMA_CH_DMA_CHX_STAT_RI_MASK) != 0)\n   {\n      ENET->DMA_CH[0].DMA_CHX_STAT = ENET_DMA_CH_DMA_CHX_STAT_RI_MASK;\n\n      do\n      {\n         error = lpc546xxEthReceivePacket(interface);\n\n      } while(error != ERROR_BUFFER_EMPTY);\n   }\n\n   ENET->DMA_CH[0].DMA_CHX_INT_EN = ENET_DMA_CH_DMA_CHX_INT_EN_NIE_MASK |\n      ENET_DMA_CH_DMA_CHX_INT_EN_RIE_MASK | ENET_DMA_CH_DMA_CHX_INT_EN_TIE_MASK;\n}",
        "output": "1",
        "idx": 8608
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs_set_open_stateid(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\twrite_seqlock(&state->seqlock);\n\tnfs_set_open_stateid_locked(state, stateid, open_flags);\n\twrite_sequnlock(&state->seqlock);\n}",
        "output": "1",
        "idx": 2134
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int pgpPrtParams(const uint8_t * pkts, size_t pktlen, unsigned int pkttype,\n\t\t pgpDigParams * ret)\n{\n    const uint8_t *p = pkts;\n    const uint8_t *pend = pkts + pktlen;\n    pgpDigParams digp = NULL;\n    struct pgpPkt pkt;\n    int rc = -1; \n\n    while (p < pend) {\n\tif (decodePkt(p, (pend - p), &pkt))\n\t    break;\n\n\tif (digp == NULL) {\n\t    if (pkttype && pkt.tag != pkttype) {\n\t\tbreak;\n\t    } else {\n\t\tdigp = pgpDigParamsNew(pkt.tag);\n\t    }\n\t}\n\n\tif (pgpPrtPkt(&pkt, digp))\n\t    break;\n\n\tp += (pkt.body - pkt.head) + pkt.blen;\n\tif (pkttype == PGPTAG_SIGNATURE)\n\t    break;\n    }\n\n    rc = (digp && (p == pend)) ? 0 : -1;\n\n    if (ret && rc == 0) {\n\t*ret = digp;\n    } else {\n\tpgpDigParamsFree(digp);\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 6628
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ast2obj_type_ignore(void* _o)\n{\n    type_ignore_ty o = (type_ignore_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n\n    switch (o->kind) {\n    case TypeIgnore_kind:\n        result = PyType_GenericNew(TypeIgnore_type, NULL, NULL);\n        if (!result) goto failed;\n        value = ast2obj_int(o->v.TypeIgnore.lineno);\n        if (!value) goto failed;\n        if (_PyObject_SetAttrId(result, &PyId_lineno, value) == -1)\n            goto failed;\n        Py_DECREF(value);\n        break;\n    }\n    return result;\nfailed:\n    Py_XDECREF(value);\n    Py_XDECREF(result);\n    return NULL;\n}",
        "output": "1",
        "idx": 7678
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_be_short (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 2)\n\t{\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} ",
        "output": "1",
        "idx": 4922
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void receive_tcppacket(connection_t *c, const char *buffer, int len) {\n\tvpn_packet_t outpkt;\n\n\tif(len > sizeof outpkt.data)\n\t\treturn;\n\n\toutpkt.len = len;\n\tif(c->options & OPTION_TCPONLY)\n\t\toutpkt.priority = 0;\n\telse\n\t\toutpkt.priority = -1;\n\tmemcpy(outpkt.data, buffer, len);\n\n\treceive_packet(c->node, &outpkt);\n}",
        "output": "0",
        "idx": 5273
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pthread_mutex_unlock(pthread_mutex_t *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}",
        "output": "1",
        "idx": 7840
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void generateScaffold(int argc, char **argv)\n{\n    char    *plural;\n\n    if (argc < 1) {\n        usageError();\n        return;\n    }\n    if (getConfigValue(\"app.esp.generate.controller\", 0) == 0) {\n        fail(\"No suitable package installed to generate scaffolds\");\n        return;\n    }\n    app->controller = sclone(argv[0]);\n    if (!identifier(app->controller)) {\n        fail(\"Cannot generate scaffold. Controller name must be a valid C identifier\");\n        return;\n    }\n    ssplit(sclone(app->controller), \"-\", &plural);\n    if (plural) {\n        app->table = sjoin(app->controller, plural, NULL);\n    } else {\n        app->table = app->table ? app->table : app->controller;\n    }\n    generateScaffoldController(argc, argv);\n    generateClientController(argc, argv);\n    generateScaffoldViews(argc, argv);\n    generateClientModel(argc, argv);\n    generateScaffoldMigration(argc, argv);\n    migrate(0, 0);\n}",
        "output": "0",
        "idx": 6945
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(DirectoryIterator, valid)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_BOOL(intern->u.dir.entry.d_name[0] != '\\0');\n}",
        "output": "1",
        "idx": 3970
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline FILE *xfmkstemp(char **tmpname, char *dir)\n{\n\tint fd;\n\tFILE *ret;\n\n\tfd = xmkstemp(tmpname, dir);\n\tif (fd == -1)\n\t\treturn NULL;\n\n\tif (!(ret = fdopen(fd, \"w+\" UL_CLOEXECSTR))) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
        "output": "1",
        "idx": 4646
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int xsave_state(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\n\talternative_input_2(\n\t\t\"1:\"XSAVE,\n\t\t\"1:\"XSAVEOPT,\n\t\tX86_FEATURE_XSAVEOPT,\n\t\t\"1:\"XSAVES,\n\t\tX86_FEATURE_XSAVES,\n\t\t[fx] \"D\" (fx), \"a\" (lmask), \"d\" (hmask) :\n\t\t\"memory\");\n\tasm volatile(\"2:\\n\\t\"\n\t\t     xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\n\treturn err;\n}",
        "output": "1",
        "idx": 2796
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_compress_check_input(struct snd_compr_params *params)\n{\n\tif (params->buffer.fragment_size == 0 ||\n\t\t\tparams->buffer.fragments > SIZE_MAX / params->buffer.fragment_size)\n\t\treturn -EINVAL;\n\n\tif (params->codec.id == 0 || params->codec.id > SND_AUDIOCODEC_MAX)\n\t\treturn -EINVAL;\n\n\tif (params->codec.ch_in == 0 || params->codec.ch_out == 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 2620
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void auth_client_request_abort(struct auth_client_request **_request)\n{\n\tstruct auth_client_request *request = *_request;\n\n\t*_request = NULL;\n\n\tauth_client_send_cancel(request->conn->client, request->id);\n\tcall_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);\n\tpool_unref(&request->pool);\n}",
        "output": "0",
        "idx": 8831
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned parse_hex4(const char *str)\n{\n\tunsigned h=0;\n\tif (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;\n\th=h<<4;str++;\n\tif (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;\n\th=h<<4;str++;\n\tif (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;\n\th=h<<4;str++;\n\tif (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;\n\treturn h;\n}",
        "output": "0",
        "idx": 8279
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_ppp_discon_cc_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\tif (length < 5) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tND_PRINT((ndo, \"%04x, \", EXTRACT_16BITS(dat)));\n\tdat += 2;\n\tlength -= 2;\n\tND_PRINT((ndo, \"%04x \",  EXTRACT_16BITS(dat)));\n\tdat += 2;\n\tlength -= 2;\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_cc_direction2str,\n\t\t\t     \"Direction-#%u\", EXTRACT_8BITS(ptr))));\n\tptr++;\n\tlength--;\n\n\tif (length != 0) {\n\t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, (const u_char *)ptr, length);\n\t}\n}",
        "output": "0",
        "idx": 6669
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item)\t{if (!item) return; if (!(item->type&cJSON_StringIsConst) && item->string) cJSON_free(item->string);item->string=(char*)string;item->type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}",
        "output": "0",
        "idx": 8309
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "diff_buf_delete(buf_T *buf)\n{\n    int\t\ti;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\ti = diff_buf_idx_tp(buf, tp);\n\tif (i != DB_COUNT)\n\t{\n\t    tp->tp_diffbuf[i] = NULL;\n\t    tp->tp_diff_invalid = TRUE;\n\t    if (tp == curtab)\n\t\tdiff_redraw(TRUE);\n\t}\n    }\n}",
        "output": "1",
        "idx": 5778
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int copy_to_user_tmpl(struct xfrm_policy *xp, struct sk_buff *skb)\n{\n\tstruct xfrm_user_tmpl vec[XFRM_MAX_DEPTH];\n\tint i;\n\n\tif (xp->xfrm_nr == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < xp->xfrm_nr; i++) {\n\t\tstruct xfrm_user_tmpl *up = &vec[i];\n\t\tstruct xfrm_tmpl *kp = &xp->xfrm_vec[i];\n\n\t\tmemset(up, 0, sizeof(*up));\n\t\tmemcpy(&up->id, &kp->id, sizeof(up->id));\n\t\tup->family = kp->encap_family;\n\t\tmemcpy(&up->saddr, &kp->saddr, sizeof(up->saddr));\n\t\tup->reqid = kp->reqid;\n\t\tup->mode = kp->mode;\n\t\tup->share = kp->share;\n\t\tup->optional = kp->optional;\n\t\tup->aalgos = kp->aalgos;\n\t\tup->ealgos = kp->ealgos;\n\t\tup->calgos = kp->calgos;\n\t}\n\n\treturn nla_put(skb, XFRMA_TMPL,\n\t\t       sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr, vec);\n}",
        "output": "0",
        "idx": 1057
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "LogLuvClose(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\n\ttd->td_samplesperpixel =\n\t    (td->td_photometric == PHOTOMETRIC_LOGL) ? 1 : 3;\n\ttd->td_bitspersample = 16;\n\ttd->td_sampleformat = SAMPLEFORMAT_INT;\n}",
        "output": "1",
        "idx": 4294
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int userns_install(struct nsproxy *nsproxy, void *ns)\n{\n\tstruct user_namespace *user_ns = ns;\n\tstruct cred *cred;\n\n\tif (user_ns == current_user_ns())\n\t\treturn -EINVAL;\n\n\tif (atomic_read(&current->mm->mm_users) > 1)\n\t\treturn -EINVAL;\n\n\tif (current->fs->users != 1)\n\t\treturn -EINVAL;\n\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tcred = prepare_creds();\n\tif (!cred)\n\t\treturn -ENOMEM;\n\n\tput_user_ns(cred->user_ns);\n\tset_cred_user_ns(cred, get_user_ns(user_ns));\n\n\treturn commit_creds(cred);\n}",
        "output": "0",
        "idx": 1235
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int bad_format_axis(char *fmt){\n    return bad_format_check(\"^\" SAFE_STRING FLOAT_STRING SAFE_STRING \"$\",fmt);\n}",
        "output": "0",
        "idx": 6447
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ocfs2_lock_get_block(struct inode *inode, sector_t iblock,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\tdown_read(&oi->ip_alloc_sem);\n\tret = ocfs2_get_block(inode, iblock, bh_result, create);\n\tup_read(&oi->ip_alloc_sem);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 2549
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main()\r\n{\r\n    gdImagePtr im;\r\n\r\n    im = gdImageCreate(64970, 65111);\r\n    gdTestAssert(im == NULL);\r\n\r\n    return gdNumFailures();\r\n}\r",
        "output": "0",
        "idx": 6213
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mono_gc_cleanup (void)\n{\n#ifdef DEBUG\n\tg_message (\"%s: cleaning up finalizer\", __func__);\n#endif\n\n\tif (!gc_disabled) {\n\t\tResetEvent (shutdown_event);\n\t\tfinished = TRUE;\n\t\tif (mono_thread_internal_current () != gc_thread) {\n\t\t\tmono_gc_finalize_notify ();\n\t\t\tif (WaitForSingleObjectEx (shutdown_event, 2000, FALSE) == WAIT_TIMEOUT) {\n\t\t\t\tint ret;\n\n\t\t\t\tsuspend_finalizers = TRUE;\n\n\t\t\t\tmono_thread_internal_stop (gc_thread);\n\n\t\t\t\tret = WaitForSingleObjectEx (gc_thread->handle, 100, TRUE);\n\n\t\t\t\tif (ret == WAIT_TIMEOUT) {\n\t\t\t\t\tg_warning (\"Shutting down finalizer thread timed out.\");\n\t\t\t\t} else {\n\t\t\t\t\tSleep (100);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tgc_thread = NULL;\n#ifdef HAVE_BOEHM_GC\n\t\tGC_finalizer_notifier = NULL;\n#endif\n\t}\n\n\tDeleteCriticalSection (&handle_section);\n\tDeleteCriticalSection (&allocator_section);\n\tDeleteCriticalSection (&finalizer_mutex);\n\tDeleteCriticalSection (&reference_queue_mutex);\n}",
        "output": "0",
        "idx": 4689
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ast_for_async_stmt(struct compiling *c, const node *n)\n{\n    REQ(n, async_stmt);\n    REQ(CHILD(n, 0), ASYNC);\n\n    switch (TYPE(CHILD(n, 1))) {\n        case funcdef:\n            return ast_for_funcdef_impl(c, CHILD(n, 1), NULL,\n                                        1 );\n        case with_stmt:\n            return ast_for_with_stmt(c, CHILD(n, 1),\n                                     1 );\n\n        case for_stmt:\n            return ast_for_for_stmt(c, CHILD(n, 1),\n                                    1 );\n\n        default:\n            PyErr_Format(PyExc_SystemError,\n                         \"invalid async stament: %s\",\n                         STR(CHILD(n, 1)));\n            return NULL;\n    }\n}",
        "output": "1",
        "idx": 7744
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int xt_compat_check_entry_offsets(const void *base, const char *elems,\n\t\t\t\t  unsigned int target_offset,\n\t\t\t\t  unsigned int next_offset)\n{\n\tlong size_of_base_struct = elems - (const char *)base;\n\tconst struct compat_xt_entry_target *t;\n\tconst char *e = base;\n\n\tif (target_offset < size_of_base_struct)\n\t\treturn -EINVAL;\n\n\tif (target_offset + sizeof(*t) > next_offset)\n\t\treturn -EINVAL;\n\n\tt = (void *)(e + target_offset);\n\tif (t->u.target_size < sizeof(*t))\n\t\treturn -EINVAL;\n\n\tif (target_offset + t->u.target_size > next_offset)\n\t\treturn -EINVAL;\n\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&\n\t    target_offset + sizeof(struct compat_xt_standard_target) != next_offset)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1803
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bump_cpu_timer(struct k_itimer *timer, u64 now)\n{\n\tint i;\n\tu64 delta, incr;\n\n\tif (timer->it.cpu.incr == 0)\n\t\treturn;\n\n\tif (now < timer->it.cpu.expires)\n\t\treturn;\n\n\tincr = timer->it.cpu.incr;\n\tdelta = now + incr - timer->it.cpu.expires;\n\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\n\t\ttimer->it.cpu.expires += incr;\n\t\ttimer->it_overrun += 1LL << i;\n\t\tdelta -= incr;\n\t}\n}",
        "output": "0",
        "idx": 4121
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHPAPI char *php_unescape_html_entities(unsigned char *old, size_t oldlen, size_t *newlen, int all, int flags, char *hint_charset TSRMLS_DC)\n{\n\tsize_t retlen;\n\tchar *ret;\n\tenum entity_charset charset;\n\tconst entity_ht *inverse_map = NULL;\n\tsize_t new_size = TRAVERSE_FOR_ENTITIES_EXPAND_SIZE(oldlen);\n\n\tif (all) {\n\t\tcharset = determine_charset(hint_charset TSRMLS_CC);\n\t} else {\n\t\tcharset = cs_8859_1; \n\t}\n\n\n\tif (oldlen > new_size) {\n\t\tret = estrndup((char*)old, oldlen);\n\t\tretlen = oldlen;\n\t\tgoto empty_source;\n\t}\n\tret = emalloc(new_size);\n\t*ret = '\\0';\n\tretlen = oldlen;\n\tif (retlen == 0) {\n\t\tgoto empty_source;\n\t}\n\n\tinverse_map = unescape_inverse_map(all, flags);\n\n\ttraverse_for_entities(old, oldlen, ret, &retlen, all, flags, inverse_map, charset);\n\nempty_source:\n\t*newlen = retlen;\n\treturn ret;\n}",
        "output": "0",
        "idx": 5381
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n  int bufsize)\n{\n\tassert(!stream->bufbase_);\n\n\tif (bufmode != JAS_STREAM_UNBUF) {\n\t\tif (!buf) {\n\t\t\tif ((stream->bufbase_ = jas_malloc(JAS_STREAM_BUFSIZE +\n\t\t\t  JAS_STREAM_MAXPUTBACK))) {\n\t\t\t\tstream->bufmode_ |= JAS_STREAM_FREEBUF;\n\t\t\t\tstream->bufsize_ = JAS_STREAM_BUFSIZE;\n\t\t\t} else {\n\t\t\t\tstream->bufbase_ = stream->tinybuf_;\n\t\t\t\tstream->bufsize_ = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tassert(bufsize > JAS_STREAM_MAXPUTBACK);\n\t\t\tstream->bufbase_ = JAS_CAST(uchar *, buf);\n\t\t\tstream->bufsize_ = bufsize - JAS_STREAM_MAXPUTBACK;\n\t\t}\n\t} else {\n\t\tassert(!buf);\n\t\tstream->bufbase_ = stream->tinybuf_;\n\t\tstream->bufsize_ = 1;\n\t}\n\tstream->bufstart_ = &stream->bufbase_[JAS_STREAM_MAXPUTBACK];\n\tstream->ptr_ = stream->bufstart_;\n\tstream->cnt_ = 0;\n\tstream->bufmode_ |= bufmode & JAS_STREAM_BUFMODEMASK;\n}",
        "output": "1",
        "idx": 5394
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *print_number( cJSON *item )\n{\n\tchar *str;\n\tdouble f, f2;\n\tint64_t i;\n\n\tstr = (char*) cJSON_malloc( 64 );\n\tif ( str ) {\n\t\tf = item->valuefloat;\n\t\ti = f;\n\t\tf2 = i;\n\t\tif ( f2 == f && item->valueint >= LLONG_MIN && item->valueint <= LLONG_MAX )\n\t\t\tsprintf( str, \"%lld\", (long long) item->valueint );\n\t\telse\n\t\t\tsprintf( str, \"%g\", item->valuefloat );\n\t}\n\treturn str;\n}",
        "output": "1",
        "idx": 5914
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dev_get_valid_name(struct net *net,\n\t\t\t      struct net_device *dev,\n\t\t\t      const char *name)\n{\n\tBUG_ON(!net);\n\n\tif (!dev_valid_name(name))\n\t\treturn -EINVAL;\n\n\tif (strchr(name, '%'))\n\t\treturn dev_alloc_name_ns(net, dev, name);\n\telse if (__dev_get_by_name(net, name))\n\t\treturn -EEXIST;\n\telse if (dev->name != name)\n\t\tstrlcpy(dev->name, name, IFNAMSIZ);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1708
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_19current_buffer_size___get__(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"__get__\", 0);\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_self->current_buffer_size); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_r = __pyx_t_1;\n  __pyx_t_1 = 0;\n  goto __pyx_L0;\n\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedReader.current_buffer_size.__get__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}",
        "output": "1",
        "idx": 8314
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jiffies_to_compat_timeval(unsigned long jiffies, struct compat_timeval *value)\n{\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tlong rem;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n\tvalue->tv_usec = rem / NSEC_PER_USEC;\n}",
        "output": "1",
        "idx": 2086
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int logi_dj_ll_raw_request(struct hid_device *hid,\n\t\t\t\t  unsigned char reportnum, __u8 *buf,\n\t\t\t\t  size_t count, unsigned char report_type,\n\t\t\t\t  int reqtype)\n{\n\tstruct dj_device *djdev = hid->driver_data;\n\tstruct dj_receiver_dev *djrcv_dev = djdev->dj_receiver_dev;\n\tu8 *out_buf;\n\tint ret;\n\n\tif (buf[0] != REPORT_TYPE_LEDS)\n\t\treturn -EINVAL;\n\n\tout_buf = kzalloc(DJREPORT_SHORT_LENGTH, GFP_ATOMIC);\n\tif (!out_buf)\n\t\treturn -ENOMEM;\n\n\tif (count < DJREPORT_SHORT_LENGTH - 2)\n\t\tcount = DJREPORT_SHORT_LENGTH - 2;\n\n\tout_buf[0] = REPORT_ID_DJ_SHORT;\n\tout_buf[1] = djdev->device_index;\n\tmemcpy(out_buf + 2, buf, count);\n\n\tret = hid_hw_raw_request(djrcv_dev->hdev, out_buf[0], out_buf,\n\t\tDJREPORT_SHORT_LENGTH, report_type, reqtype);\n\n\tkfree(out_buf);\n\treturn ret;\n}",
        "output": "1",
        "idx": 2642
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int ccid_hc_rx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid->ccid_ops->ccid_hc_rx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_rx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}",
        "output": "1",
        "idx": 748
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n\trcu_read_lock();\n\t__ptrace_link(child, new_parent, __task_cred(new_parent));\n\trcu_read_unlock();\n}",
        "output": "1",
        "idx": 3214
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,\n\t\t\t\t\t struct nlattr *rp)\n{\n\tstruct xfrm_replay_state_esn *up;\n\n\tif (!replay_esn || !rp)\n\t\treturn 0;\n\n\tup = nla_data(rp);\n\n\tif (xfrm_replay_state_esn_len(replay_esn) !=\n\t\t\txfrm_replay_state_esn_len(up))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 776
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ScreenCell *realloc_buffer(VTermScreen *screen, ScreenCell *buffer, int new_rows, int new_cols)\n{\n  ScreenCell *new_buffer = vterm_allocator_malloc(screen->vt, sizeof(ScreenCell) * new_rows * new_cols);\n  int row, col;\n\n  for(row = 0; row < new_rows; row++) {\n    for(col = 0; col < new_cols; col++) {\n      ScreenCell *new_cell = new_buffer + row*new_cols + col;\n\n      if(buffer && row < screen->rows && col < screen->cols)\n        *new_cell = buffer[row * screen->cols + col];\n      else {\n        new_cell->chars[0] = 0;\n        new_cell->pen = screen->pen;\n      }\n    }\n  }\n\n  if(buffer)\n    vterm_allocator_free(screen->vt, buffer);\n\n  return new_buffer;\n}",
        "output": "1",
        "idx": 5828
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iakerb_gss_wrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                int conf_req_flag, gss_qop_t qop_req,\n                gss_buffer_t input_message_buffer, int *conf_state,\n                gss_buffer_t output_message_buffer)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_wrap(minor_status, ctx->gssc, conf_req_flag, qop_req,\n                         input_message_buffer, conf_state,\n                         output_message_buffer);\n}",
        "output": "0",
        "idx": 157
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int parse_exports_table(long long *table_start)\n{\n\tint res;\n\tint indexes = SQUASHFS_LOOKUP_BLOCKS(sBlk.s.inodes);\n\tlong long export_index_table[indexes];\n\n\tres = read_fs_bytes(fd, sBlk.s.lookup_table_start,\n\t\tSQUASHFS_LOOKUP_BLOCK_BYTES(sBlk.s.inodes), export_index_table);\n\tif(res == FALSE) {\n\t\tERROR(\"parse_exports_table: failed to read export index table\\n\");\n\t\treturn FALSE;\n\t}\n\tSQUASHFS_INSWAP_LOOKUP_BLOCKS(export_index_table, indexes);\n\n\t*table_start = export_index_table[0];\n\n\treturn TRUE;\n}",
        "output": "1",
        "idx": 5332
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int count_leading_dotdots(const char *url, const char **out)\n{\n\tint result = 0;\n\twhile (1) {\n\t\tif (starts_with_dot_dot_slash(url)) {\n\t\t\tresult++;\n\t\t\turl += strlen(\"../\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (starts_with_dot_slash(url)) {\n\t\t\turl += strlen(\"./\");\n\t\t\tcontinue;\n\t\t}\n\t\t*out = url;\n\t\treturn result;\n\t}\n}",
        "output": "0",
        "idx": 7203
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ext4_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\treturn dax_mkwrite(vma, vmf, ext4_get_block_dax,\n\t\t\t\text4_end_io_unwritten);\n}",
        "output": "1",
        "idx": 992
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)\n{\n  char q_user[SHORT_STRING], q_pass[SHORT_STRING];\n  char buf[STRING];\n  int rc;\n\n  if (mutt_bit_isset(idata->capabilities, LOGINDISABLED))\n  {\n    mutt_message(_(\"LOGIN disabled on this server.\"));\n    return IMAP_AUTH_UNAVAIL;\n  }\n\n  if (mutt_account_getuser(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n\n  mutt_message(_(\"Logging in...\"));\n\n  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);\n  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);\n\n\n  if (DebugLevel < IMAP_LOG_PASS)\n    mutt_debug(2, \"Sending LOGIN command for %s...\\n\", idata->conn->account.user);\n\n  snprintf(buf, sizeof(buf), \"LOGIN %s %s\", q_user, q_pass);\n  rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);\n\n  if (!rc)\n  {\n    mutt_clear_error(); \n    return IMAP_AUTH_SUCCESS;\n  }\n\n  mutt_error(_(\"Login failed.\"));\n  return IMAP_AUTH_FAILURE;\n}",
        "output": "1",
        "idx": 6972
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void youngcollection (lua_State *L, global_State *g) {\n  GCObject **psurvival;  \n  lua_assert(g->gcstate == GCSpropagate);\n  markold(g, g->survival, g->reallyold);\n  markold(g, g->finobj, g->finobjrold);\n  atomic(L);\n\n  psurvival = sweepgen(L, g, &g->allgc, g->survival);\n  sweepgen(L, g, psurvival, g->reallyold);\n  g->reallyold = g->old;\n  g->old = *psurvival;  \n  g->survival = g->allgc;  \n\n  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);\n  sweepgen(L, g, psurvival, g->finobjrold);\n  g->finobjrold = g->finobjold;\n  g->finobjold = *psurvival;  \n  g->finobjsur = g->finobj;  \n\n  sweepgen(L, g, &g->tobefnz, NULL);\n\n  finishgencycle(L, g);\n}",
        "output": "1",
        "idx": 8098
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static plist_t parse_string_node(const char **bnode, uint64_t size)\n{\n    plist_data_t data = plist_new_plist_data();\n\n    data->type = PLIST_STRING;\n    data->strval = (char *) malloc(sizeof(char) * (size + 1));\n    if (!data->strval) {\n        plist_free_data(data);\n        PLIST_BIN_ERR(\"%s: Could not allocate %\" PRIu64 \" bytes\\n\", __func__, sizeof(char) * (size + 1));\n        return NULL;\n    }\n    memcpy(data->strval, *bnode, size);\n    data->strval[size] = '\\0';\n    data->length = strlen(data->strval);\n\n    return node_create(NULL, data);\n}",
        "output": "0",
        "idx": 8965
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void put_prev_task(struct rq *rq, struct task_struct *prev)\n{\n\tif (prev->se.on_rq)\n\t\tupdate_rq_clock(rq);\n\trq->skip_clock_update = 0;\n\tprev->sched_class->put_prev_task(rq, prev);\n}",
        "output": "1",
        "idx": 240
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC int httpAddDefense(cchar *name, cchar *remedy, cchar *remedyArgs)\n{\n    Http        *http;\n    MprHash     *args;\n    MprList     *list;\n    char        *arg, *key, *value;\n    int         next;\n\n    assert(name && *name);\n\n    http = HTTP;\n    args = mprCreateHash(0, MPR_HASH_STABLE);\n    list = stolist(remedyArgs);\n    for (ITERATE_ITEMS(list, arg, next)) {\n        key = stok(arg, \"=\", &value);\n        mprAddKey(args, key, strim(value, \"\\\"'\", 0));\n    }\n    if (!remedy) {\n        remedy = mprLookupKey(args, \"REMEDY\");\n    }\n    mprAddKey(http->defenses, name, createDefense(name, remedy, args));\n    return 0;\n}",
        "output": "1",
        "idx": 5060
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DU_getStringDOElement(DcmItem *obj, DcmTagKey t, char *s, size_t bufsize)\n{\n    DcmByteString *elem;\n    DcmStack stack;\n    OFCondition ec = EC_Normal;\n    char* aString;\n\n    ec = obj->search(t, stack);\n    elem = (DcmByteString*) stack.top();\n    if (ec == EC_Normal && elem != NULL) {\n        if (elem->getLength() == 0) {\n            s[0] = '\\0';\n        } else {\n            ec =  elem->getString(aString);\n            OFStandard::strlcpy(s, aString, bufsize);\n        }\n    }\n    return (ec == EC_Normal);\n}",
        "output": "1",
        "idx": 8832
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int skcipher_setkey_unaligned(struct crypto_skcipher *tfm,\n\t\t\t\t     const u8 *key, unsigned int keylen)\n{\n\tunsigned long alignmask = crypto_skcipher_alignmask(tfm);\n\tstruct skcipher_alg *cipher = crypto_skcipher_alg(tfm);\n\tu8 *buffer, *alignbuffer;\n\tunsigned long absize;\n\tint ret;\n\n\tabsize = keylen + alignmask;\n\tbuffer = kmalloc(absize, GFP_ATOMIC);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\talignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);\n\tmemcpy(alignbuffer, key, keylen);\n\tret = cipher->setkey(tfm, alignbuffer, keylen);\n\tkzfree(buffer);\n\treturn ret;\n}",
        "output": "0",
        "idx": 2309
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(GlobIterator, count)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (php_stream_is(intern->u.dir.dirp ,&php_glob_stream_ops)) {\n\t\tRETURN_LONG(php_glob_stream_get_count(intern->u.dir.dirp, NULL));\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"GlobIterator lost glob state\");\n\t}\n}",
        "output": "0",
        "idx": 5479
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, current)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!intern->u.file.current_line && !intern->u.file.current_zval) {\n\t\tspl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC);\n\t}\n\tif (intern->u.file.current_line && (!SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV) || !intern->u.file.current_zval)) {\n\t\tRETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);\n\t} else if (intern->u.file.current_zval) {\n\t\tRETURN_ZVAL(intern->u.file.current_zval, 1, 0);\n\t}\n\tRETURN_FALSE;\n} ",
        "output": "0",
        "idx": 5465
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "validate_commit_metadata (GVariant   *commit_data,\n                          const char *ref,\n                          const char *required_metadata,\n                          gboolean   require_xa_metadata,\n                          GError   **error)\n{\n  g_autoptr(GVariant) commit_metadata = NULL;\n  const char *xa_metadata = NULL;\n\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n\n  if (commit_metadata != NULL)\n    g_variant_lookup (commit_metadata, \"xa.metadata\", \"&s\", &xa_metadata);\n\n  if ((xa_metadata == NULL && require_xa_metadata) ||\n      (xa_metadata != NULL && g_strcmp0 (required_metadata, xa_metadata) != 0))\n    {\n      g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                   _(\"Commit metadata for %s not matching expected metadata\"), ref);\n      return FALSE;\n    }\n\n  return TRUE;\n}",
        "output": "1",
        "idx": 7268
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cancel_att_send_op(struct att_send_op *op)\n{\n\tif (op->destroy)\n\t\top->destroy(op->user_data);\n\n\top->user_data = NULL;\n\top->callback = NULL;\n\top->destroy = NULL;\n}",
        "output": "1",
        "idx": 8342
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct fsnotify_group *inotify_new_group(unsigned int max_events)\n{\n\tstruct fsnotify_group *group;\n\n\tgroup = fsnotify_alloc_group(&inotify_fsnotify_ops);\n\tif (IS_ERR(group))\n\t\treturn group;\n\n\tgroup->max_events = max_events;\n\n\tspin_lock_init(&group->inotify_data.idr_lock);\n\tidr_init(&group->inotify_data.idr);\n\tgroup->inotify_data.last_wd = 0;\n\tgroup->inotify_data.fa = NULL;\n\tgroup->inotify_data.user = get_current_user();\n\n\tif (atomic_inc_return(&group->inotify_data.user->inotify_devs) >\n\t    inotify_max_user_instances) {\n\t\tfsnotify_put_group(group);\n\t\treturn ERR_PTR(-EMFILE);\n\t}\n\n\treturn group;\n}",
        "output": "0",
        "idx": 429
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE cState_space_before_set(VALUE self, VALUE space_before)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(space_before, T_STRING);\n    len = RSTRING_LEN(space_before);\n    if (len == 0) {\n        if (state->space_before) {\n            ruby_xfree(state->space_before);\n            state->space_before = NULL;\n            state->space_before_len = 0;\n        }\n    } else {\n        if (state->space_before) ruby_xfree(state->space_before);\n        state->space_before = fstrndup(RSTRING_PTR(space_before), len);\n        state->space_before_len = len;\n    }\n    return Qnil;\n}",
        "output": "0",
        "idx": 8805
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(void *) gdImageJpegPtr(gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tif (!_gdImageJpegCtx(im, out, quality)) {\n\t\trv = gdDPExtractData(out, size);\n\t} else {\n\t\trv = NULL;\n\t}\n\tout->gd_free(out);\n\treturn rv;\n}",
        "output": "0",
        "idx": 6225
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void macvlan_common_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\n\tdev->priv_flags\t       &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n\tdev->netdev_ops\t\t= &macvlan_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\tdev->header_ops\t\t= &macvlan_hard_header_ops,\n\tdev->ethtool_ops\t= &macvlan_ethtool_ops;\n}",
        "output": "0",
        "idx": 747
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static StkId rethook (lua_State *L, CallInfo *ci, StkId firstres, int nres) {\n  ptrdiff_t oldtop = savestack(L, L->top);  \n  int delta = 0;\n  if (isLuacode(ci)) {\n    Proto *p = clLvalue(s2v(ci->func))->p;\n    if (p->is_vararg)\n      delta = ci->u.l.nextraargs + p->numparams + 1;\n    if (L->top < ci->top)\n      L->top = ci->top;  \n  }\n  if (L->hookmask & LUA_MASKRET) {  \n    int ftransfer;\n    ci->func += delta;  \n    ftransfer = cast(unsigned short, firstres - ci->func);\n    luaD_hook(L, LUA_HOOKRET, -1, ftransfer, nres);  \n    ci->func -= delta;\n  }\n  if (isLua(ci->previous))\n    L->oldpc = ci->previous->u.l.savedpc;  \n  return restorestack(L, oldtop);\n}",
        "output": "1",
        "idx": 8104
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void postParse(HttpRoute *route)\n{\n    Http        *http;\n    HttpHost    *host;\n    HttpRoute   *rp;\n    MprJson     *mappings, *client;\n    int         nextHost, nextRoute;\n\n    if (route->error) {\n        return;\n    }\n    http = route->http;\n    route->mode = mprGetJson(route->config, \"app.mode\");\n\n    if ((mappings = mprGetJsonObj(route->config, \"app.client.mappings\")) != 0) {\n        client = mprCreateJson(MPR_JSON_OBJ);\n        clientCopy(route, client, mappings);\n        mprSetJson(client, \"prefix\", route->prefix);\n        route->client = mprJsonToString(client, MPR_JSON_QUOTES);\n    }\n    httpAddHostToEndpoints(route->host);\n\n    for (nextHost = 0; (host = mprGetNextItem(http->hosts, &nextHost)) != 0; ) {\n        for (nextRoute = 0; (rp = mprGetNextItem(host->routes, &nextRoute)) != 0; ) {\n            if (!mprLookupKey(rp->extensions, \"\")) {\n                if (!rp->handler) {\n                    httpAddRouteHandler(rp, \"fileHandler\", \"\");\n                    httpAddRouteIndex(rp, \"index.html\");\n                }\n            }\n            if (rp->parent == route) {\n                rp->client = route->client;\n            }\n        }\n    }\n}",
        "output": "1",
        "idx": 5066
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int wcall_i_answer(struct wcall *wcall,\n\t\t   int call_type, int audio_cbr)\n{\n\tint err = 0;\n\tbool cbr = audio_cbr != 0;\n\n\tif (!wcall) {\n\t\twarning(\"wcall; answer: no wcall\\n\");\n\t\treturn EINVAL;\n\t}\n\n\tcall_type = (call_type == WCALL_CALL_TYPE_FORCED_AUDIO) ?\n\t\t    WCALL_CALL_TYPE_NORMAL : call_type;\n\n\tinfo(APITAG \"wcall(%p): answer calltype=%s\\n\",\n\t     wcall, wcall_call_type_name(call_type));\n\n\tif (wcall->disable_audio)\n\t\twcall->disable_audio = false;\n\t\n\tif (!wcall->icall) {\n\t\twarning(\"wcall(%p): answer: no call object found\\n\", wcall);\n\t\treturn ENOTSUP;\n\t}\n\tset_state(wcall, WCALL_STATE_ANSWERED);\n\n\tif (call_type == WCALL_CALL_TYPE_VIDEO) {\n\t\tICALL_CALL(wcall->icall,\n\t\t\t   set_video_send_state,\n\t\t\t   ICALL_VIDEO_STATE_STARTED);\n\t}\n\telse {\n\t\tICALL_CALL(wcall->icall,\n\t\t\t   set_video_send_state,\n\t\t\t   ICALL_VIDEO_STATE_STOPPED);\n\t}\n\t\n\terr = ICALL_CALLE(wcall->icall, answer,\n\t\t\t  call_type, cbr);\n\n\treturn err;\n}",
        "output": "1",
        "idx": 8824
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static enum led_brightness k90_backlight_get(struct led_classdev *led_cdev)\n{\n\tint ret;\n\tstruct k90_led *led = container_of(led_cdev, struct k90_led, cdev);\n\tstruct device *dev = led->cdev.dev->parent;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint brightness;\n\tchar *data;\n\n\tdata = kmalloc(8, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tbrightness = data[4];\n\tif (brightness < 0 || brightness > 3) {\n\t\tdev_warn(dev,\n\t\t\t \"Read invalid backlight brightness: %02hhx.\\n\",\n\t\t\t data[4]);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tret = brightness;\nout:\n\tkfree(data);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 2083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct lib_t* MACH0_(get_libs)(struct MACH0_(obj_t)* bin) {\n\tstruct lib_t *libs;\n\tint i;\n\n\tif (!bin->nlibs)\n\t\treturn NULL;\n\tif (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t))))\n\t\treturn NULL;\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tstrncpy (libs[i].name, bin->libs[i], R_BIN_MACH0_STRING_LENGTH);\n\t\tlibs[i].name[R_BIN_MACH0_STRING_LENGTH-1] = '\\0';\n\t\tlibs[i].last = 0;\n\t}\n\tlibs[i].last = 1;\n\treturn libs;\n}",
        "output": "1",
        "idx": 6148
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}",
        "output": "0",
        "idx": 8245
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void setup_test_dir(char *tmp_dir, const char *files, ...) {\n        va_list ap;\n\n        assert_se(mkdtemp(tmp_dir) != NULL);\n\n        va_start(ap, files);\n        while (files != NULL) {\n                _cleanup_free_ char *path = strappend(tmp_dir, files);\n                assert_se(touch_file(path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, MODE_INVALID) == 0);\n                files = va_arg(ap, const char *);\n        }\n        va_end(ap);\n}",
        "output": "0",
        "idx": 7683
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void update_open_stateflags(struct nfs4_state *state, fmode_t fmode)\n{\n\tswitch (fmode) {\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr++;\n\t}\n\tnfs4_state_set_mode_locked(state, state->state | fmode);\n}",
        "output": "0",
        "idx": 3033
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "file_extension(const char *s)\t\n{\n  const char\t*extension;\t\n  static char\tbuf[1024];\t\n\n\n  if (s == NULL)\n    return (NULL);\n  else if (!strncmp(s, \"data:image/bmp;\", 15))\n    return (\"bmp\");\n  else if (!strncmp(s, \"data:image/gif;\", 15))\n    return (\"gif\");\n  else if (!strncmp(s, \"data:image/jpeg;\", 16))\n    return (\"jpg\");\n  else if (!strncmp(s, \"data:image/png;\", 15))\n    return (\"png\");\n  else if ((extension = strrchr(s, '/')) != NULL)\n    extension ++;\n  else if ((extension = strrchr(s, '\\\\')) != NULL)\n    extension ++;\n  else\n    extension = s;\n\n  if ((extension = strrchr(extension, '.')) == NULL)\n    return (\"\");\n  else\n    extension ++;\n\n  if (strchr(extension, '#') == NULL)\n    return (extension);\n\n  strlcpy(buf, extension, sizeof(buf));\n\n  *(char *)strchr(buf, '#') = '\\0';\n\n  return (buf);\n}",
        "output": "1",
        "idx": 8484
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct inode *vfs_select_inode(struct dentry *dentry,\n\t\t\t\t\t     unsigned open_flags)\n{\n\tstruct inode *inode = d_inode(dentry);\n\n\tif (inode && unlikely(dentry->d_flags & DCACHE_OP_SELECT_INODE))\n\t\tinode = dentry->d_op->d_select_inode(dentry, open_flags);\n\n\treturn inode;\n}",
        "output": "0",
        "idx": 1869
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ghash_update(struct shash_desc *desc,\n\t\t\t const u8 *src, unsigned int srclen)\n{\n\tstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);\n\tstruct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);\n\tu8 *dst = dctx->buffer;\n\n\tif (!ctx->gf128)\n\t\treturn -ENOKEY;\n\n\tif (dctx->bytes) {\n\t\tint n = min(srclen, dctx->bytes);\n\t\tu8 *pos = dst + (GHASH_BLOCK_SIZE - dctx->bytes);\n\n\t\tdctx->bytes -= n;\n\t\tsrclen -= n;\n\n\t\twhile (n--)\n\t\t\t*pos++ ^= *src++;\n\n\t\tif (!dctx->bytes)\n\t\t\tgf128mul_4k_lle((be128 *)dst, ctx->gf128);\n\t}\n\n\twhile (srclen >= GHASH_BLOCK_SIZE) {\n\t\tcrypto_xor(dst, src, GHASH_BLOCK_SIZE);\n\t\tgf128mul_4k_lle((be128 *)dst, ctx->gf128);\n\t\tsrc += GHASH_BLOCK_SIZE;\n\t\tsrclen -= GHASH_BLOCK_SIZE;\n\t}\n\n\tif (srclen) {\n\t\tdctx->bytes = GHASH_BLOCK_SIZE - srclen;\n\t\twhile (srclen--)\n\t\t\t*dst++ ^= *src++;\n\t}\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 811
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void perf_tp_event(u64 addr, u64 count, void *record, int entry_size,\n\t\t   struct pt_regs *regs, struct hlist_head *head, int rctx)\n{\n\tstruct perf_sample_data data;\n\tstruct perf_event *event;\n\tstruct hlist_node *node;\n\n\tstruct perf_raw_record raw = {\n\t\t.size = entry_size,\n\t\t.data = record,\n\t};\n\n\tperf_sample_data_init(&data, addr);\n\tdata.raw = &raw;\n\n\thlist_for_each_entry_rcu(event, node, head, hlist_entry) {\n\t\tif (perf_tp_event_match(event, &data, regs))\n\t\t\tperf_swevent_event(event, count, 1, &data, regs);\n\t}\n\n\tperf_swevent_put_recursion_context(rctx);\n}",
        "output": "1",
        "idx": 534
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "horDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\tTIFFPredictorState* sp = PredictorState(tif);\n\ttmsize_t stride = sp->stride;\n\tuint32 *wp = (uint32*) cp0;\n\ttmsize_t wc = cc/4;\n\n    if((cc%(4*stride))!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"horDiff32\",\n                     \"%s\", \"(cc%(4*stride))!=0\");\n        return 0;\n    }\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\twp += wc - 1;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] -= wp[0]; wp--)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n\treturn 1;\n}",
        "output": "0",
        "idx": 5895
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __evtchn_fifo_handle_events(unsigned cpu, bool drop)\n{\n\tstruct evtchn_fifo_control_block *control_block;\n\tunsigned long ready;\n\tunsigned q;\n\n\tcontrol_block = per_cpu(cpu_control_block, cpu);\n\n\tready = xchg(&control_block->ready, 0);\n\n\twhile (ready) {\n\t\tq = find_first_bit(&ready, EVTCHN_FIFO_MAX_QUEUES);\n\t\tconsume_one_event(cpu, control_block, q, &ready, drop);\n\t\tready |= xchg(&control_block->ready, 0);\n\t}\n}",
        "output": "1",
        "idx": 1900
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mm_answer_pam_free_ctx(int sock, Buffer *m)\n{\n\tint r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;\n\n\tdebug3(\"%s\", __func__);\n\t(sshpam_device.free_ctx)(sshpam_ctxt);\n\tsshpam_ctxt = sshpam_authok = NULL;\n\tbuffer_clear(m);\n\tmm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);\n\tauth_method = \"keyboard-interactive\";\n\tauth_submethod = \"pam\";\n\treturn r;\n}",
        "output": "0",
        "idx": 7653
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void arch_pick_mmap_layout(struct mm_struct *mm)\n{\n\tunsigned long random_factor = 0UL;\n\n\tif (current->flags & PF_RANDOMIZE)\n\t\trandom_factor = arch_mmap_rnd();\n\n\tmm->mmap_legacy_base = TASK_UNMAPPED_BASE + random_factor;\n\n\tif (mmap_is_legacy()) {\n\t\tmm->mmap_base = mm->mmap_legacy_base;\n\t\tmm->get_unmapped_area = arch_get_unmapped_area;\n\t} else {\n\t\tmm->mmap_base = mmap_base(random_factor);\n\t\tmm->get_unmapped_area = arch_get_unmapped_area_topdown;\n\t}\n}",
        "output": "0",
        "idx": 1683
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ext4_end_io_nolock(ext4_io_end_t *io)\n{\n\tstruct inode *inode = io->inode;\n\tloff_t offset = io->offset;\n\tssize_t size = io->size;\n\tint ret = 0;\n\n\text4_debug(\"ext4_end_io_nolock: io 0x%p from inode %lu,list->next 0x%p,\"\n\t\t   \"list->prev 0x%p\\n\",\n\t           io, inode->i_ino, io->list.next, io->list.prev);\n\n\tif (list_empty(&io->list))\n\t\treturn ret;\n\n\tif (io->flag != EXT4_IO_UNWRITTEN)\n\t\treturn ret;\n\n\tret = ext4_convert_unwritten_extents(inode, offset, size);\n\tif (ret < 0) {\n\t\tprintk(KERN_EMERG \"%s: failed to convert unwritten\"\n\t\t\t\"extents to written extents, error is %d\"\n\t\t\t\" io is still on inode %lu aio dio list\\n\",\n                       __func__, ret, inode->i_ino);\n\t\treturn ret;\n\t}\n\n\tio->flag = 0;\n\treturn ret;\n}",
        "output": "0",
        "idx": 3189
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int evtchn_fifo_percpu_deinit(unsigned int cpu)\n{\n\t__evtchn_fifo_handle_events(cpu, NULL);\n\treturn 0;\n}",
        "output": "0",
        "idx": 2745
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "atol8(const char *p, size_t char_cnt)\n{\n\tint64_t l;\n\tint digit;\n\n\tif (char_cnt == 0)\n\t\treturn (0);\n\n\tl = 0;\n\twhile (char_cnt-- > 0) {\n\t\tif (*p >= '0' && *p <= '7')\n\t\t\tdigit = *p - '0';\n\t\telse\n\t\t\tbreak;\n\t\tp++;\n\t\tl <<= 3;\n\t\tl |= digit;\n\t}\n\treturn (l);\n}",
        "output": "0",
        "idx": 5135
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Ta3AST_FromNode(const node *n, PyCompilerFlags *flags, const char *filename_str,\n               int feature_version, PyArena *arena)\n{\n    mod_ty mod;\n    PyObject *filename;\n    filename = PyUnicode_DecodeFSDefault(filename_str);\n    if (filename == NULL)\n        return NULL;\n    mod = Ta3AST_FromNodeObject(n, flags, filename, feature_version, arena);\n    Py_DECREF(filename);\n    return mod;\n\n}",
        "output": "1",
        "idx": 7748
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_byte (SF_PRIVATE *psf, char x)\n{\tpsf->header.ptr [psf->header.indx++] = x ;\n} ",
        "output": "0",
        "idx": 6881
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tunsigned long *msr_bitmap;\n\n\tif (is_guest_mode(vcpu))\n\t\tmsr_bitmap = vmx_msr_bitmap_nested;\n\telse if (cpu_has_secondary_exec_ctrls() &&\n\t\t (vmcs_read32(SECONDARY_VM_EXEC_CONTROL) &\n\t\t  SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE)) {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t} else {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy;\n\t}\n\n\tvmcs_write64(MSR_BITMAP, __pa(msr_bitmap));\n}",
        "output": "0",
        "idx": 1881
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "smtp_log_to_file(smtp_t *smtp)\n{\n\tFILE *fp = fopen(\"/tmp/smtp-alert.log\", \"a\");\n\ttime_t now;\n\tstruct tm tm;\n\tchar time_buf[25];\n\tint time_buf_len;\n\n\ttime(&now);\n\tlocaltime_r(&now, &tm);\n\ttime_buf_len = strftime(time_buf, sizeof time_buf, \"%a %b %e %X %Y\", &tm);\n\n\tfprintf(fp, \"%s: %s -> %s\\n\"\n\t\t    \"%*sSubject: %s\\n\"\n\t\t    \"%*sBody:    %s\\n\\n\",\n\t\t    time_buf, global_data->email_from, smtp->email_to,\n\t\t    time_buf_len - 7, \"\", smtp->subject,\n\t\t    time_buf_len - 7, \"\", smtp->body);\n\n\tfclose(fp);\n\n\tfree_smtp_all(smtp);\n}",
        "output": "1",
        "idx": 7084
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void prefetch_table(const void *tab, size_t len)\n{\n  const volatile byte *vtab = tab;\n  size_t i;\n\n  for (i = 0; i < len; i += 8 * 32)\n    {\n      (void)vtab[i + 0 * 32];\n      (void)vtab[i + 1 * 32];\n      (void)vtab[i + 2 * 32];\n      (void)vtab[i + 3 * 32];\n      (void)vtab[i + 4 * 32];\n      (void)vtab[i + 5 * 32];\n      (void)vtab[i + 6 * 32];\n      (void)vtab[i + 7 * 32];\n    }\n\n  (void)vtab[len - 1];\n}",
        "output": "1",
        "idx": 7450
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rose_start_t2timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tsk_stop_timer(sk, &rose->timer);\n\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t2;\n\n\tsk_reset_timer(sk, &rose->timer, rose->timer.expires);\n}",
        "output": "0",
        "idx": 2955
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void jiffies_to_timeval(const unsigned long jiffies, struct timeval *value)\n{\n\tu32 rem;\n\n\tvalue->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,\n\t\t\t\t    NSEC_PER_SEC, &rem);\n\tvalue->tv_usec = rem / NSEC_PER_USEC;\n}",
        "output": "0",
        "idx": 3013
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int handle_dots(struct nameidata *nd, int type)\n{\n\tif (type == LAST_DOTDOT) {\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\treturn follow_dotdot_rcu(nd);\n\t\t} else\n\t\t\tfollow_dotdot(nd);\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 2898
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tmscfs_t *fs = priv->fs;\n\tint x;\n\tint count = 0;\n\n\tmscfs_check_cache(priv->fs);\n\n\tfor(x = 0; x < fs->cache.size; x++) {\n\t\tu8* oid= fs->cache.array[x].objectId.id;\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\"FILE: %02X%02X%02X%02X\\n\",\n\t\t\toid[0],oid[1],oid[2],oid[3]);\n\t\tif(0 == memcmp(fs->currentPath, oid, 2)) {\n\t\t\tbuf[0] = oid[2];\n\t\t\tbuf[1] = oid[3];\n\t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; \n\t\t\tbuf += 2;\n\t\t\tcount+=2;\n\t\t}\n\t}\n\treturn count;\n}",
        "output": "1",
        "idx": 7016
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "With(asdl_seq * items, asdl_seq * body, int lineno, int col_offset, int\n     end_lineno, int end_col_offset, PyArena *arena)\n{\n    stmt_ty p;\n    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->kind = With_kind;\n    p->v.With.items = items;\n    p->v.With.body = body;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    p->end_lineno = end_lineno;\n    p->end_col_offset = end_col_offset;\n    return p;\n}",
        "output": "1",
        "idx": 7188
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jp2_box_t *jp2_box_create(int type)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tif (!(box = jp2_box_create0())) {\n\t\treturn 0;\n\t}\n\tbox->type = type;\n\tbox->len = 0;\n\tif (!(boxinfo = jp2_boxinfolookup(type))) {\n\t\treturn 0;\n\t}\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\treturn box;\n}",
        "output": "0",
        "idx": 7617
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateBool( int b )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item )\n\t\titem->type = b ? cJSON_True : cJSON_False;\n\treturn item;\n}",
        "output": "1",
        "idx": 5906
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_Parse( const char *value )\n{\n\tcJSON *c;\n\tep = 0;\n\tif ( ! ( c = cJSON_New_Item() ) )\n\t\treturn 0;\t\n\n\tif ( ! parse_value( c, skip( value ) ) ) {\n\t\tcJSON_Delete( c );\n\t\treturn 0;\n\t}\n\treturn c;\n}",
        "output": "1",
        "idx": 5920
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patlen, OnigOptionType options, OnigEncoding enc, OnigSyntaxType *syntax TSRMLS_DC)\n{\n\tint err_code = 0;\n\tint found = 0;\n\tphp_mb_regex_t *retval = NULL, **rc = NULL;\n\tOnigErrorInfo err_info;\n\tOnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];\n\n\tfound = zend_hash_find(&MBREX(ht_rc), (char *)pattern, patlen+1, (void **) &rc);\n\tif (found == FAILURE || (*rc)->options != options || (*rc)->enc != enc || (*rc)->syntax != syntax) {\n\t\tif ((err_code = onig_new(&retval, (OnigUChar *)pattern, (OnigUChar *)(pattern + patlen), options, enc, syntax, &err_info)) != ONIG_NORMAL) {\n\t\t\tonig_error_code_to_str(err_str, err_code, err_info);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"mbregex compile err: %s\", err_str);\n\t\t\tretval = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tzend_hash_update(&MBREX(ht_rc), (char *) pattern, patlen + 1, (void *) &retval, sizeof(retval), NULL);\n\t} else if (found == SUCCESS) {\n\t\tretval = *rc;\n\t}\nout:\n\treturn retval;\n}",
        "output": "0",
        "idx": 5595
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t exitcode_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tchar *end, buf[sizeof(\"nnnnn\\0\")];\n\tsize_t size;\n\tint tmp;\n\n\tsize = min(count, sizeof(buf));\n\tif (copy_from_user(buf, buffer, size))\n\t\treturn -EFAULT;\n\n\ttmp = simple_strtol(buf, &end, 0);\n\tif ((*end != '\\0') && !isspace(*end))\n\t\treturn -EINVAL;\n\n\tuml_exitcode = tmp;\n\treturn count;\n}",
        "output": "0",
        "idx": 3343
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char *skip( const char *in )\n{\n\twhile ( in && *in && (unsigned char) *in <= 32 )\n\t\tin++;\n\treturn in;\n}",
        "output": "1",
        "idx": 5918
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jas_iccgetuint16(jas_stream_t *in, jas_iccuint16_t *val)\n{\n\tulonglong tmp;\n\tif (jas_iccgetuint(in, 2, &tmp))\n\t\treturn -1;\n\t*val = tmp;\n\treturn 0;\n}",
        "output": "1",
        "idx": 5380
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rose_start_t3timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tsk_stop_timer(sk, &rose->timer);\n\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t3;\n\n\tsk_reset_timer(sk, &rose->timer, rose->timer.expires);\n}",
        "output": "0",
        "idx": 2967
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GIT_INLINE(bool) only_spaces_and_dots(const char *path)\n{\n\tconst char *c = path;\n\n\tfor (;; c++) {\n\t\tif (*c == '\\0')\n\t\t\treturn true;\n\t\tif (*c != ' ' && *c != '.')\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
        "output": "1",
        "idx": 4892
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API bool r_sys_mkdirp(const char *dir) {\n\tbool ret = true;\n\tchar slash = R_SYS_DIR[0];\n\tchar *path = strdup (dir), *ptr = path;\n\tif (!path) {\n\t\teprintf (\"r_sys_mkdirp: Unable to allocate memory\\n\");\n\t\treturn false;\n\t}\n\tif (*ptr == slash) {\n\t\tptr++;\n\t}\n#if __WINDOWS__\n\t{\n\t\tchar *p = strstr (ptr, \":\\\\\");\n\t\tif (p) {\n\t\t\tptr = p + 2;\n\t\t}\n\t}\n#endif\n\tfor (;;) {\n\t\tfor (; *ptr; ptr++) {\n\t\t\tif (*ptr == '/' || *ptr == '\\\\') {\n\t\t\t\tslash = *ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!*ptr) {\n\t\t\tbreak;\n\t\t}\n\t\t*ptr = 0;\n\t\tif (!r_sys_mkdir (path) && r_sys_mkdir_failed ()) {\n\t\t\teprintf (\"r_sys_mkdirp: fail '%s' of '%s'\\n\", path, dir);\n\t\t\tfree (path);\n\t\t\treturn false;\n\t\t}\n\t\t*ptr = slash;\n\t\tptr++;\n\t}\n\tif (!r_sys_mkdir (path) && r_sys_mkdir_failed ()) {\n\t\tret = false;\n\t}\n\tfree (path);\n\treturn ret;\n}",
        "output": "1",
        "idx": 6426
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dispatch_discard_io(struct xen_blkif *blkif,\n\t\t\t\tstruct blkif_request *req)\n{\n\tint err = 0;\n\tint status = BLKIF_RSP_OKAY;\n\tstruct block_device *bdev = blkif->vbd.bdev;\n\tunsigned long secure;\n\n\tblkif->st_ds_req++;\n\n\txen_blkif_get(blkif);\n\tsecure = (blkif->vbd.discard_secure &&\n\t\t (req->u.discard.flag & BLKIF_DISCARD_SECURE)) ?\n\t\t BLKDEV_DISCARD_SECURE : 0;\n\n\terr = blkdev_issue_discard(bdev, req->u.discard.sector_number,\n\t\t\t\t   req->u.discard.nr_sectors,\n\t\t\t\t   GFP_KERNEL, secure);\n\n\tif (err == -EOPNOTSUPP) {\n\t\tpr_debug(DRV_PFX \"discard op failed, not supported\\n\");\n\t\tstatus = BLKIF_RSP_EOPNOTSUPP;\n\t} else if (err)\n\t\tstatus = BLKIF_RSP_ERROR;\n\n\tmake_response(blkif, req->u.discard.id, req->operation, status);\n\txen_blkif_put(blkif);\n\treturn err;\n}",
        "output": "1",
        "idx": 2296
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC MprJson *mprGetJsonObj(MprJson *obj, cchar *key)\n{\n    MprJson      *result;\n\n    if (key && !strpbrk(key, \".[]*\")) {\n        return mprLookupJsonObj(obj, key);\n    }\n    if ((result = mprQueryJson(obj, key, 0, 0)) != 0 && result->children) {\n        return result->children;\n    }\n    return 0;\n}",
        "output": "1",
        "idx": 5104
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sock_close(struct inode *inode, struct file *filp)\n{\n\tsock_release(SOCKET_I(inode));\n\treturn 0;\n}",
        "output": "1",
        "idx": 2970
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHPAPI PHP_FUNCTION(fread)\n{\n\tzval *arg1;\n\tlong len;\n\tphp_stream *stream;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &arg1, &len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\n\tif (len <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (len > INT_MAX) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be no more than %d\", INT_MAX);\n\t\tRETURN_FALSE;\n\t}\n\n\tZ_STRVAL_P(return_value) = emalloc(len + 1);\n\tZ_STRLEN_P(return_value) = php_stream_read(stream, Z_STRVAL_P(return_value), len);\n\n\tZ_STRVAL_P(return_value)[Z_STRLEN_P(return_value)] = 0;\n\tZ_TYPE_P(return_value) = IS_STRING;\n}",
        "output": "0",
        "idx": 5371
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ext4_dax_pmd_fault(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\t\t\tpmd_t *pmd, unsigned int flags)\n{\n\tint result;\n\thandle_t *handle = NULL;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct super_block *sb = inode->i_sb;\n\tbool write = flags & FAULT_FLAG_WRITE;\n\n\tif (write) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\n\t\t\t\text4_chunk_trans_blocks(inode,\n\t\t\t\t\t\t\tPMD_SIZE / PAGE_SIZE));\n\t} else\n\t\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\n\tif (IS_ERR(handle))\n\t\tresult = VM_FAULT_SIGBUS;\n\telse\n\t\tresult = __dax_pmd_fault(vma, addr, pmd, flags,\n\t\t\t\text4_get_block_dax, ext4_end_io_unwritten);\n\n\tif (write) {\n\t\tif (!IS_ERR(handle))\n\t\t\text4_journal_stop(handle);\n\t\tup_read(&EXT4_I(inode)->i_mmap_sem);\n\t\tsb_end_pagefault(sb);\n\t} else\n\t\tup_read(&EXT4_I(inode)->i_mmap_sem);\n\n\treturn result;\n}",
        "output": "0",
        "idx": 1441
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mwifiex_pcie_alloc_cmdrsp_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct sk_buff *skb;\n\n\tskb = dev_alloc_skb(MWIFIEX_UPLD_SIZE);\n\tif (!skb) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Unable to allocate skb for command response data.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, MWIFIEX_UPLD_SIZE);\n\tif (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE,\n\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\treturn -1;\n\n\tcard->cmdrsp_buf = skb;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 3270
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void invalidate_lstat_cache(void)\n{\n\treset_lstat_cache(&default_cache);\n}",
        "output": "0",
        "idx": 7213
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct usb_yurex *dev;\n\tint len = 0;\n\tchar in_buffer[20];\n\tunsigned long flags;\n\n\tdev = file->private_data;\n\n\tmutex_lock(&dev->io_mutex);\n\tif (!dev->interface) {\t\t\n\t\tmutex_unlock(&dev->io_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tlen = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tmutex_unlock(&dev->io_mutex);\n\n\treturn simple_read_from_buffer(buffer, count, ppos, in_buffer, len);\n}",
        "output": "0",
        "idx": 4137
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Huff_Compress(msg_t *mbuf, int offset) {\n\tint\t\t\ti, ch, size;\n\tbyte\t\tseq[65536];\n\tbyte*\t\tbuffer;\n\thuff_t\t\thuff;\n\n\tsize = mbuf->cursize - offset;\n\tbuffer = mbuf->data+ + offset;\n\n\tif (size<=0) {\n\t\treturn;\n\t}\n\n\tCom_Memset(&huff, 0, sizeof(huff_t));\n\thuff.tree = huff.lhead = huff.loc[NYT] =  &(huff.nodeList[huff.blocNode++]);\n\thuff.tree->symbol = NYT;\n\thuff.tree->weight = 0;\n\thuff.lhead->next = huff.lhead->prev = NULL;\n\thuff.tree->parent = huff.tree->left = huff.tree->right = NULL;\n\n\tseq[0] = (size>>8);\n\tseq[1] = size&0xff;\n\n\tbloc = 16;\n\n\tfor (i=0; i<size; i++ ) {\n\t\tch = buffer[i];\n\t\tHuff_transmit(&huff, ch, seq, size<<3);\t\t\t\t\t\t\n\t\tHuff_addRef(&huff, (byte)ch);\t\t\t\t\t\t\t\t\n\t}\n\n\tbloc += 8;\t\t\t\t\t\t\t\t\t\t\t\t\n\n\tmbuf->cursize = (bloc>>3) + offset;\n\tCom_Memcpy(mbuf->data+offset, seq, (bloc>>3));\n}",
        "output": "0",
        "idx": 8755
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void prefetch_table(const volatile byte *tab, size_t len)\n{\n  size_t i;\n\n  for (i = 0; i < len; i += 8 * 32)\n    {\n      (void)tab[i + 0 * 32];\n      (void)tab[i + 1 * 32];\n      (void)tab[i + 2 * 32];\n      (void)tab[i + 3 * 32];\n      (void)tab[i + 4 * 32];\n      (void)tab[i + 5 * 32];\n      (void)tab[i + 6 * 32];\n      (void)tab[i + 7 * 32];\n    }\n\n  (void)tab[len - 1];\n}",
        "output": "1",
        "idx": 7448
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int net_get(int s, void *arg, int *len)\n{\n\tstruct net_hdr nh;\n\tint plen;\n\n\tif (net_read_exact(s, &nh, sizeof(nh)) == -1)\n        {\n\t\treturn -1;\n        }\n\n\tplen = ntohl(nh.nh_len);\n\tif (!(plen <= *len))\n\t\tprintf(\"PLEN %d type %d len %d\\n\",\n\t\t\tplen, nh.nh_type, *len);\n\tassert(plen <= *len && plen > 0); \n\n\t*len = plen;\n\tif ((*len) && (net_read_exact(s, arg, *len) == -1))\n        {\n            return -1;\n        }\n\n\treturn nh.nh_type;\n}",
        "output": "0",
        "idx": 6497
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static HttpResponse create_HttpResponse(Socket_T S) {\n        HttpResponse res = NULL;\n        NEW(res);\n        res->S = S;\n        res->status = SC_OK;\n        res->outputbuffer = StringBuffer_create(256);\n        res->is_committed = false;\n        res->protocol = SERVER_PROTOCOL;\n        res->status_msg = get_status_string(SC_OK);\n        Util_getToken(res->token);\n        return res;\n}",
        "output": "0",
        "idx": 8441
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cil_reset_perm(struct cil_perm *perm)\n{\n\tcil_list_destroy(&perm->classperms, CIL_FALSE);\n}",
        "output": "0",
        "idx": 8483
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct btrfs_device *btrfs_find_device_by_path(\n\t\tstruct btrfs_fs_info *fs_info, const char *device_path)\n{\n\tint ret = 0;\n\tstruct btrfs_super_block *disk_super;\n\tu64 devid;\n\tu8 *dev_uuid;\n\tstruct block_device *bdev;\n\tstruct buffer_head *bh;\n\tstruct btrfs_device *device;\n\n\tret = btrfs_get_bdev_and_sb(device_path, FMODE_READ,\n\t\t\t\t    fs_info->bdev_holder, 0, &bdev, &bh);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\tdev_uuid = disk_super->dev_item.uuid;\n\tif (btrfs_fs_incompat(fs_info, METADATA_UUID))\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,\n\t\t\t\t\t   disk_super->metadata_uuid);\n\telse\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,\n\t\t\t\t\t   disk_super->fsid);\n\n\tbrelse(bh);\n\tif (!device)\n\t\tdevice = ERR_PTR(-ENOENT);\n\tblkdev_put(bdev, FMODE_READ);\n\treturn device;\n}",
        "output": "1",
        "idx": 3096
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t ib_ucm_write(struct file *filp, const char __user *buf,\n\t\t\t    size_t len, loff_t *pos)\n{\n\tstruct ib_ucm_file *file = filp->private_data;\n\tstruct ib_ucm_cmd_hdr hdr;\n\tssize_t result;\n\n\tif (WARN_ON_ONCE(!ib_safe_file_access(filp)))\n\t\treturn -EACCES;\n\n\tif (len < sizeof(hdr))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&hdr, buf, sizeof(hdr)))\n\t\treturn -EFAULT;\n\n\tif (hdr.cmd >= ARRAY_SIZE(ucm_cmd_table))\n\t\treturn -EINVAL;\n\n\tif (hdr.in + sizeof(hdr) > len)\n\t\treturn -EINVAL;\n\n\tresult = ucm_cmd_table[hdr.cmd](file, buf + sizeof(hdr),\n\t\t\t\t\thdr.in, hdr.out);\n\tif (!result)\n\t\tresult = len;\n\n\treturn result;\n}",
        "output": "0",
        "idx": 1819
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vfs_open(const struct path *path, struct file *file,\n\t     const struct cred *cred)\n{\n\tstruct inode *inode = vfs_select_inode(path->dentry, file->f_flags);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tfile->f_path = *path;\n\treturn do_dentry_open(file, inode, NULL, cred);\n}",
        "output": "0",
        "idx": 1867
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_bitmap_file(struct mddev *mddev, void __user * arg)\n{\n\tmdu_bitmap_file_t *file = NULL; \n\tchar *ptr;\n\tint err;\n\n\tfile = kzalloc(sizeof(*file), GFP_NOIO);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\terr = 0;\n\tspin_lock(&mddev->lock);\n\tif (!mddev->bitmap_info.file)\n\t\tfile->pathname[0] = '\\0';\n\telse if ((ptr = file_path(mddev->bitmap_info.file,\n\t\t\t       file->pathname, sizeof(file->pathname))),\n\t\t IS_ERR(ptr))\n\t\terr = PTR_ERR(ptr);\n\telse\n\t\tmemmove(file->pathname, ptr,\n\t\t\tsizeof(file->pathname)-(ptr-file->pathname));\n\tspin_unlock(&mddev->lock);\n\n\tif (err == 0 &&\n\t    copy_to_user(arg, file, sizeof(*file)))\n\t\terr = -EFAULT;\n\n\tkfree(file);\n\treturn err;\n}",
        "output": "0",
        "idx": 3983
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void veth_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\n\tdev->netdev_ops = &veth_netdev_ops;\n\tdev->ethtool_ops = &veth_ethtool_ops;\n\tdev->features |= NETIF_F_LLTX;\n\tdev->destructor = veth_dev_free;\n\n\tdev->hw_features = NETIF_F_NO_CSUM | NETIF_F_SG | NETIF_F_RXCSUM;\n}",
        "output": "0",
        "idx": 751
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_output_wakeup(struct perf_output_handle *handle)\n{\n\tatomic_set(&handle->rb->poll, POLL_IN);\n\n\thandle->event->pending_wakeup = 1;\n\tirq_work_queue(&handle->event->pending);\n}",
        "output": "0",
        "idx": 705
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ip_options_get_from_user(struct net *net, struct ip_options_rcu **optp,\n\t\t\t     unsigned char __user *data, int optlen)\n{\n\tstruct ip_options_rcu *opt = ip_options_get_alloc(optlen);\n\n\tif (!opt)\n\t\treturn -ENOMEM;\n\tif (optlen && copy_from_user(opt->opt.__data, data, optlen)) {\n\t\tkfree(opt);\n\t\treturn -EFAULT;\n\t}\n\treturn ip_options_get_finish(net, optp, opt, optlen);\n}",
        "output": "0",
        "idx": 491
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_parser(void) {\n\ttest_parser_param(0);\n}",
        "output": "0",
        "idx": 8405
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void inet6_destroy_sock(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct ipv6_txoptions *opt;\n\n\n\tskb = xchg(&np->pktoptions, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\n\tskb = xchg(&np->rxpmtu, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\n\tfl6_free_socklist(sk);\n\n\n\topt = xchg((__force struct ipv6_txoptions **)&np->opt, NULL);\n\tif (opt) {\n\t\tatomic_sub(opt->tot_len, &sk->sk_omem_alloc);\n\t\ttxopt_put(opt);\n\t}\n}",
        "output": "0",
        "idx": 1397
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error_t httpCheckCharset(const char_t *s, size_t length, uint_t charset)\n{\n   error_t error;\n   size_t i;\n   uint8_t c;\n   uint_t m;\n\n   error = NO_ERROR;\n\n   for(i = 0; i < length; i++)\n   {\n      c = (uint8_t) s[i];\n\n      m = HTTP_CHARSET_OCTET;\n\n      if(iscntrl(c))\n         m |= HTTP_CHARSET_CTL;\n\n      if(isprint(c) && c <= 126)\n         m |= HTTP_CHARSET_TEXT | HTTP_CHARSET_VCHAR;\n\n      if(c == ' ' || c == '\\t')\n         m |= HTTP_CHARSET_TEXT | HTTP_CHARSET_LWS;\n\n      if(isalpha(c))\n         m |= HTTP_CHARSET_TCHAR | HTTP_CHARSET_ALPHA;\n\n      if(osIsdigit(c))\n         m |= HTTP_CHARSET_TCHAR | HTTP_CHARSET_DIGIT;\n\n      if(isxdigit(c))\n         m |= HTTP_CHARSET_HEX;\n\n      if(c >= 128)\n         m |= HTTP_CHARSET_TEXT | HTTP_CHARSET_OBS_TEXT;\n\n      if(strchr(\"!#$%&'*+-.^_`|~\", c))\n         m |= HTTP_CHARSET_TCHAR;\n\n      if((m & charset) == 0)\n         error = ERROR_INVALID_SYNTAX;\n   }\n\n   return error;\n}",
        "output": "1",
        "idx": 8646
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "checked_xcalloc (size_t num, size_t size)\n{\n    alloc_limit_assert (\"checked_xcalloc\", (num *size));\n    return xcalloc (num, size);\n}",
        "output": "1",
        "idx": 6394
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int spl_filesystem_file_read_csv(spl_filesystem_object *intern, char delimiter, char enclosure, char escape, zval *return_value TSRMLS_DC) \n{\n\tint ret = SUCCESS;\n\n\tdo {\n\t\tret = spl_filesystem_file_read(intern, 1 TSRMLS_CC);\n\t} while (ret == SUCCESS && !intern->u.file.current_line_len && SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY));\n\n\tif (ret == SUCCESS) {\n\t\tsize_t buf_len = intern->u.file.current_line_len;\n\t\tchar *buf = estrndup(intern->u.file.current_line, buf_len);\n\n\t\tif (intern->u.file.current_zval) {\n\t\t\tzval_ptr_dtor(&intern->u.file.current_zval);\n\t\t}\n\t\tALLOC_INIT_ZVAL(intern->u.file.current_zval);\n\n\t\tphp_fgetcsv(intern->u.file.stream, delimiter, enclosure, escape, buf_len, buf, intern->u.file.current_zval TSRMLS_CC);\n\t\tif (return_value) {\n\t\t\tif (Z_TYPE_P(return_value) != IS_NULL) {\n\t\t\t\tzval_dtor(return_value);\n\t\t\t\tZVAL_NULL(return_value);\n\t\t\t}\n\t\t\tZVAL_ZVAL(return_value, intern->u.file.current_zval, 1, 0);\n\t\t}\n\t}\n\treturn ret;\n}",
        "output": "0",
        "idx": 5543
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int parse_token(char **name, char **value, char **cp)\n{\n\tchar *end;\n\n\tif (!name || !value || !cp)\n\t\treturn -BLKID_ERR_PARAM;\n\n\tif (!(*value = strchr(*cp, '=')))\n\t\treturn 0;\n\n\t**value = '\\0';\n\t*name = strip_line(*cp);\n\t*value = skip_over_blank(*value + 1);\n\n\tif (**value == '\"') {\n\t\tchar *p = end = *value + 1;\n\n\t\twhile (*p) {\n\t\t\tif (*p == '\\\\') {\n\t\t\t\tp++;\n\t\t\t\t*end = *p;\n\t\t\t} else {\n\t\t\t\t*end = *p;\n\t\t\t\tif (*p == '\"')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t\tend++;\n\t\t}\n\n\t\tif (*end != '\"') {\n\t\t\tDBG(READ, ul_debug(\"unbalanced quotes at: %s\", *value));\n\t\t\t*cp = *value;\n\t\t\treturn -BLKID_ERR_CACHE;\n\t\t}\n\t\t(*value)++;\n\t\t*end = '\\0';\n\t\tend = ++p;\n\t} else {\n\t\tend = skip_over_word(*value);\n\t\tif (*end) {\n\t\t\t*end = '\\0';\n\t\t\tend++;\n\t\t}\n\t}\n\t*cp = end;\n\n\treturn 1;\n}",
        "output": "0",
        "idx": 6499
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline const unsigned char *fsnotify_oldname_init(const unsigned char *name)\n{\n\treturn kstrdup(name, GFP_KERNEL);\n}",
        "output": "1",
        "idx": 1626
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->MaxLen < 1)\n\t\tfields->MaxLen = fields->Len;\n\n\tStream_Write_UINT16(s, fields->Len); \n\tStream_Write_UINT16(s, fields->MaxLen); \n\tStream_Write_UINT32(s, fields->BufferOffset); \n}",
        "output": "1",
        "idx": 4194
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tcp_v6_send_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t      struct flowi *fl,\n\t\t\t      struct request_sock *req,\n\t\t\t      struct tcp_fastopen_cookie *foc,\n\t\t\t      bool attach_req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tstruct sk_buff *skb;\n\tint err = -ENOMEM;\n\n\tif (!dst && (dst = inet6_csk_route_req(sk, fl6, req,\n\t\t\t\t\t       IPPROTO_TCP)) == NULL)\n\t\tgoto done;\n\n\tskb = tcp_make_synack(sk, dst, req, foc, attach_req);\n\n\tif (skb) {\n\t\t__tcp_v6_send_check(skb, &ireq->ir_v6_loc_addr,\n\t\t\t\t    &ireq->ir_v6_rmt_addr);\n\n\t\tfl6->daddr = ireq->ir_v6_rmt_addr;\n\t\tif (np->repflow && ireq->pktopts)\n\t\t\tfl6->flowlabel = ip6_flowlabel(ipv6_hdr(ireq->pktopts));\n\n\t\terr = ip6_xmit(sk, skb, fl6, rcu_dereference(np->opt),\n\t\t\t       np->tclass);\n\t\terr = net_xmit_eval(err);\n\t}\n\ndone:\n\treturn err;\n}",
        "output": "0",
        "idx": 1419
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "f_settabvar(typval_T *argvars, typval_T *rettv)\n{\n    tabpage_T\t*save_curtab;\n    tabpage_T\t*tp;\n    char_u\t*varname, *tabvarname;\n    typval_T\t*varp;\n\n    rettv->vval.v_number = 0;\n\n    if (check_secure())\n\treturn;\n\n    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));\n    varname = tv_get_string_chk(&argvars[1]);\n    varp = &argvars[2];\n\n    if (varname != NULL && varp != NULL && tp != NULL)\n    {\n\tsave_curtab = curtab;\n\tgoto_tabpage_tp(tp, FALSE, FALSE);\n\n\ttabvarname = alloc((unsigned)STRLEN(varname) + 3);\n\tif (tabvarname != NULL)\n\t{\n\t    STRCPY(tabvarname, \"t:\");\n\t    STRCPY(tabvarname + 2, varname);\n\t    set_var(tabvarname, varp, TRUE);\n\t    vim_free(tabvarname);\n\t}\n\n\tif (valid_tabpage(save_curtab))\n\t    goto_tabpage_tp(save_curtab, FALSE, FALSE);\n    }\n}",
        "output": "0",
        "idx": 8179
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, rewind)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);\n} ",
        "output": "1",
        "idx": 3922
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n{\n\tunsigned char *buf;\n\n\tassert(bufsize >= 0);\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n\t  bufsize) {\n\t\treturn -1;\n\t}\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}",
        "output": "0",
        "idx": 7487
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ovl_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint err;\n\tstruct dentry *upperdentry;\n\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\n\terr = ovl_copy_up(dentry);\n\tif (!err) {\n\t\tupperdentry = ovl_dentry_upper(dentry);\n\n\t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n\t\terr = notify_change(upperdentry, attr, NULL);\n\t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n\t}\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}",
        "output": "0",
        "idx": 1429
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC void httpSetIntParam(HttpConn *conn, cchar *var, int value) \n{\n    mprWriteJson(httpGetParams(conn), var, sfmt(\"%d\", value));\n}",
        "output": "0",
        "idx": 7027
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "__be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\n{\n\tstatic u32 ip6_proxy_idents_hashrnd __read_mostly;\n\tstruct in6_addr buf[2];\n\tstruct in6_addr *addrs;\n\tu32 id;\n\n\taddrs = skb_header_pointer(skb,\n\t\t\t\t   skb_network_offset(skb) +\n\t\t\t\t   offsetof(struct ipv6hdr, saddr),\n\t\t\t\t   sizeof(buf), buf);\n\tif (!addrs)\n\t\treturn 0;\n\n\tnet_get_random_once(&ip6_proxy_idents_hashrnd,\n\t\t\t    sizeof(ip6_proxy_idents_hashrnd));\n\n\tid = __ipv6_select_ident(net, ip6_proxy_idents_hashrnd,\n\t\t\t\t &addrs[1], &addrs[0]);\n\treturn htonl(id);\n}",
        "output": "1",
        "idx": 3130
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rfbClientIteratorNext(rfbClientIteratorPtr i)\n{\n  if (!i)\n    return NULL;\n  if(i->next == 0) {\n    LOCK(rfbClientListMutex);\n    i->next = i->screen->clientHead;\n    UNLOCK(rfbClientListMutex);\n  } else {\n    rfbClientPtr cl = i->next;\n    i->next = i->next->next;\n    rfbDecrClientRef(cl);\n  }\n\n#if defined(LIBVNCSERVER_HAVE_LIBPTHREAD) || defined(LIBVNCSERVER_HAVE_WIN32THREADS)\n    if(!i->closedToo)\n      while(i->next && i->next->sock<0)\n        i->next = i->next->next;\n    if(i->next)\n      rfbIncrClientRef(i->next);\n#endif\n\n    return i->next;\n}",
        "output": "0",
        "idx": 8939
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cib_tls_close(cib_t * cib)\n{\n    cib_remote_opaque_t *private = cib->variant_opaque;\n\n    shutdown(private->command.socket, SHUT_RDWR);       \n    shutdown(private->callback.socket, SHUT_RDWR);      \n    close(private->command.socket);\n    close(private->callback.socket);\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n    if (private->command.encrypted) {\n        gnutls_bye(*(private->command.session), GNUTLS_SHUT_RDWR);\n        gnutls_deinit(*(private->command.session));\n        gnutls_free(private->command.session);\n\n        gnutls_bye(*(private->callback.session), GNUTLS_SHUT_RDWR);\n        gnutls_deinit(*(private->callback.session));\n        gnutls_free(private->callback.session);\n\n        gnutls_anon_free_client_credentials(anon_cred_c);\n        gnutls_global_deinit();\n    }\n#endif\n    return 0;\n}",
        "output": "1",
        "idx": 3726
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DefragIPv4TooLargeTest(void)\n{\n    DefragContext *dc = NULL;\n    Packet *p = NULL;\n    int ret = 0;\n\n    DefragInit();\n\n    dc = DefragContextNew();\n    if (dc == NULL)\n        goto end;\n\n    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n    if (p == NULL)\n        goto end;\n\n    if (Defrag(NULL, NULL, p, NULL) != NULL)\n        goto end;\n    if (!ENGINE_ISSET_EVENT(p, IPV4_FRAG_PKT_TOO_LARGE))\n        goto end;\n\n    if (dc->frag_pool->outstanding != 0)\n        return 0;\n\n    ret = 1;\nend:\n    if (dc != NULL)\n        DefragContextDestroy(dc);\n    if (p != NULL)\n        SCFree(p);\n\n    DefragDestroy();\n    return ret;\n}",
        "output": "1",
        "idx": 6588
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\tstruct vm_area_struct *vma, unsigned char *vec)\n{\n\tunsigned long nr = (end - addr) >> PAGE_SHIFT;\n\tint i;\n\n\tif (vma->vm_file) {\n\t\tpgoff_t pgoff;\n\n\t\tpgoff = linear_page_index(vma, addr);\n\t\tfor (i = 0; i < nr; i++, pgoff++)\n\t\t\tvec[i] = mincore_page(vma->vm_file->f_mapping, pgoff);\n\t} else {\n\t\tfor (i = 0; i < nr; i++)\n\t\t\tvec[i] = 0;\n\t}\n\treturn nr;\n}",
        "output": "1",
        "idx": 3066
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void free_clt(struct rtrs_clt_sess *clt)\n{\n\tfree_permits(clt);\n\tfree_percpu(clt->pcpu_path);\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\tdevice_unregister(&clt->dev);\n}",
        "output": "1",
        "idx": 2006
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rds_loop_xmit(struct rds_connection *conn, struct rds_message *rm,\n\t\t\t unsigned int hdr_off, unsigned int sg,\n\t\t\t unsigned int off)\n{\n\tif (rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\treturn sizeof(struct rds_header) + RDS_CONG_MAP_BYTES;\n\t}\n\n\tBUG_ON(hdr_off || sg || off);\n\n\trds_inc_init(&rm->m_inc, conn, conn->c_laddr);\n\trds_message_addref(rm);\n\n\trds_recv_incoming(conn, conn->c_laddr, conn->c_faddr, &rm->m_inc,\n\t\t\t  GFP_KERNEL, KM_USER0);\n\n\trds_send_drop_acked(conn, be64_to_cpu(rm->m_inc.i_hdr.h_sequence),\n\t\t\t    NULL);\n\n\trds_inc_put(&rm->m_inc);\n\n\treturn sizeof(struct rds_header) + be32_to_cpu(rm->m_inc.i_hdr.h_len);\n}",
        "output": "1",
        "idx": 254
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseContentKeep(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    if (mprReadJson(prop, \"[@=c]\")) {\n        route->keepSource = 1;\n    }\n}",
        "output": "0",
        "idx": 7013
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void unbind_ports(void) {\n    SERVICE_OPTIONS *opt;\n\n    s_poll_init(fds, 1);\n\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_SECTIONS]);\n\n    opt=service_options.next;\n    service_options.next=NULL;\n    service_free(&service_options);\n\n    while(opt) {\n        unsigned i;\n        s_log(LOG_DEBUG, \"Unbinding service [%s]\", opt->servname);\n        for(i=0; i<opt->local_addr.num; ++i)\n            unbind_port(opt, i);\n        if(opt->exec_name && opt->connect_addr.names) {\n            opt->option.retry=0;\n        }\n        if(opt->ctx)\n            SSL_CTX_flush_sessions(opt->ctx,\n                (long)time(NULL)+opt->session_timeout+1);\n        s_log(LOG_DEBUG, \"Service [%s] closed\", opt->servname);\n\n        {\n            SERVICE_OPTIONS *garbage=opt;\n            opt=opt->next;\n            garbage->next=NULL;\n            service_free(garbage);\n        }\n    }\n\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);\n}",
        "output": "1",
        "idx": 8468
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int asf_read_marker(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int i, count, name_len, ret;\n    char name[1024];\n\n    avio_rl64(pb);            \n    avio_rl64(pb);            \n    count = avio_rl32(pb);    \n    avio_rl16(pb);            \n    name_len = avio_rl16(pb); \n    for (i = 0; i < name_len; i++)\n        avio_r8(pb); \n\n    for (i = 0; i < count; i++) {\n        int64_t pres_time;\n        int name_len;\n\n        avio_rl64(pb);             \n        pres_time = avio_rl64(pb); \n        pres_time -= asf->hdr.preroll * 10000;\n        avio_rl16(pb);             \n        avio_rl32(pb);             \n        avio_rl32(pb);             \n        name_len = avio_rl32(pb);  \n        if ((ret = avio_get_str16le(pb, name_len * 2, name,\n                                    sizeof(name))) < name_len)\n            avio_skip(pb, name_len - ret);\n        avpriv_new_chapter(s, i, (AVRational) { 1, 10000000 }, pres_time,\n                           AV_NOPTS_VALUE, name);\n    }\n\n    return 0;\n}",
        "output": "1",
        "idx": 3502
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "horAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint16* wp = (uint16*) cp0;\n\ttmsize_t wc = cc / 2;\n\n\tassert((cc%(2*stride))==0);\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] + (unsigned int)wp[0]) & 0xffff); wp++)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n}",
        "output": "1",
        "idx": 4280
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nfs4_intent_set_file(struct nameidata *nd, struct path *path, struct nfs4_state *state, fmode_t fmode)\n{\n\tstruct file *filp;\n\tint ret;\n\n\tif (fmode & FMODE_EXEC) {\n\t\tret = nfs_may_open(state->inode,\n\t\t\t\tstate->owner->so_cred,\n\t\t\t\tnd->intent.open.flags);\n\t\tif (ret < 0)\n\t\t\tgoto out_close;\n\t}\n\tfilp = lookup_instantiate_filp(nd, path->dentry, NULL);\n\tif (!IS_ERR(filp)) {\n\t\tstruct nfs_open_context *ctx;\n\t\tctx = nfs_file_open_context(filp);\n\t\tctx->state = state;\n\t\treturn 0;\n\t}\n\tret = PTR_ERR(filp);\nout_close:\n\tnfs4_close_sync(path, state, fmode & (FMODE_READ|FMODE_WRITE));\n\treturn ret;\n}",
        "output": "0",
        "idx": 3079
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_msix_table_init(struct pci_vdev *dev, int table_entries)\n{\n\tint i, table_size;\n\n\tassert(table_entries > 0);\n\tassert(table_entries <= MAX_MSIX_TABLE_ENTRIES);\n\n\ttable_size = table_entries * MSIX_TABLE_ENTRY_SIZE;\n\tdev->msix.table = calloc(1, table_size);\n\n\tassert(dev->msix.table != NULL);\n\n\tfor (i = 0; i < table_entries; i++)\n\t\tdev->msix.table[i].vector_control |= PCIM_MSIX_VCTRL_MASK;\n}",
        "output": "1",
        "idx": 7570
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_8position___get__(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannySetupContext(\"__get__\", 0);\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_self->position); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 11, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_r = __pyx_t_1;\n  __pyx_t_1 = 0;\n  goto __pyx_L0;\n\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedReader.position.__get__\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __pyx_L0:;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}",
        "output": "1",
        "idx": 8312
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t ucma_write(struct file *filp, const char __user *buf,\n\t\t\t  size_t len, loff_t *pos)\n{\n\tstruct ucma_file *file = filp->private_data;\n\tstruct rdma_ucm_cmd_hdr hdr;\n\tssize_t ret;\n\n\tif (WARN_ON_ONCE(!ib_safe_file_access(filp)))\n\t\treturn -EACCES;\n\n\tif (len < sizeof(hdr))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&hdr, buf, sizeof(hdr)))\n\t\treturn -EFAULT;\n\n\tif (hdr.cmd >= ARRAY_SIZE(ucma_cmd_table))\n\t\treturn -EINVAL;\n\n\tif (hdr.in + sizeof(hdr) > len)\n\t\treturn -EINVAL;\n\n\tif (!ucma_cmd_table[hdr.cmd])\n\t\treturn -ENOSYS;\n\n\tret = ucma_cmd_table[hdr.cmd](file, buf + sizeof(hdr), hdr.in, hdr.out);\n\tif (!ret)\n\t\tret = len;\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 1821
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int au1100fb_fb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)\n{\n\tstruct au1100fb_device *fbdev;\n\tunsigned int len;\n\tunsigned long start=0, off;\n\n\tfbdev = to_au1100fb_device(fbi);\n\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\n\t\treturn -EINVAL;\n\t}\n\n\tstart = fbdev->fb_phys & PAGE_MASK;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\n\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\n\tif ((vma->vm_end - vma->vm_start + off) > len) {\n\t\treturn -EINVAL;\n\t}\n\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tpgprot_val(vma->vm_page_prot) |= (6 << 9); \n\n\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t\tvma->vm_end - vma->vm_start,\n\t\t\t\tvma->vm_page_prot)) {\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 2352
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void free_todo_entries(TodoEntry **todos) {\n        for (TodoEntry *x = *todos; x && x->dir; x++) {\n                closedir(x->dir);\n                free(x->dirname);\n        }\n\n        freep(todos);\n}",
        "output": "0",
        "idx": 7711
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_chown(const char *path)\n{\n\tif (chown(path, 0, 0) == 0) {\n\t\tfprintf(stderr, \"leak at chown of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at chown of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}",
        "output": "0",
        "idx": 7269
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    GradFunContext *s = inlink->dst->priv;\n    AVFilterLink *outlink = inlink->dst->outputs[0];\n    AVFrame *out;\n    int p, direct;\n\n    if (av_frame_is_writable(in)) {\n        direct = 1;\n        out = in;\n    } else {\n        direct = 0;\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n\n    for (p = 0; p < 4 && in->data[p]; p++) {\n        int w = inlink->w;\n        int h = inlink->h;\n        int r = s->radius;\n        if (p) {\n            w = s->chroma_w;\n            h = s->chroma_h;\n            r = s->chroma_r;\n        }\n\n        if (FFMIN(w, h) > 2 * r)\n            filter(s, out->data[p], in->data[p], w, h, out->linesize[p], in->linesize[p], r);\n        else if (out->data[p] != in->data[p])\n            av_image_copy_plane(out->data[p], out->linesize[p], in->data[p], in->linesize[p], w, h);\n    }\n\n    if (!direct)\n        av_frame_free(&in);\n\n    return ff_filter_frame(outlink, out);\n}",
        "output": "1",
        "idx": 3524
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)\t\t\t{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;\n\tif (c->prev) c->prev->next=c->next;if (c->next) c->next->prev=c->prev;if (c==array->child) array->child=c->next;c->prev=c->next=0;return c;}",
        "output": "0",
        "idx": 8271
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tiny_dispatch(const MessagesMap_t *entry, uint8_t *msg, uint32_t msg_size)\n{\n    if (!pb_parse(entry, msg, msg_size, msg_tiny)) {\n        call_msg_failure_handler(FailureType_Failure_UnexpectedMessage,\n                                 \"Could not parse tiny protocol buffer message\");\n        return;\n    }\n\n    msg_tiny_id = entry->msg_id;\n}",
        "output": "1",
        "idx": 7550
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int command_read(struct pci_dev *dev, int offset, u16 *value, void *data)\n{\n\tint i;\n\tint ret;\n\n\tret = xen_pcibk_read_config_word(dev, offset, value, data);\n\tif (!pci_is_enabled(dev))\n\t\treturn ret;\n\n\tfor (i = 0; i < PCI_ROM_RESOURCE; i++) {\n\t\tif (dev->resource[i].flags & IORESOURCE_IO)\n\t\t\t*value |= PCI_COMMAND_IO;\n\t\tif (dev->resource[i].flags & IORESOURCE_MEM)\n\t\t\t*value |= PCI_COMMAND_MEMORY;\n\t}\n\n\treturn ret;\n}",
        "output": "1",
        "idx": 2802
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int au1200fb_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n\n{\n\tunsigned int len;\n\tunsigned long start=0, off;\n\tstruct au1200fb_device *fbdev = info->par;\n\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\n\t\treturn -EINVAL;\n\t}\n\n\tstart = fbdev->fb_phys & PAGE_MASK;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\n\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\n\tif ((vma->vm_end - vma->vm_start + off) > len) {\n\t\treturn -EINVAL;\n\t}\n\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tpgprot_val(vma->vm_page_prot) |= _CACHE_MASK; \n\n\treturn io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t\t  vma->vm_end - vma->vm_start,\n\t\t\t\t  vma->vm_page_prot);\n}",
        "output": "1",
        "idx": 2354
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tshort sel;\n\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn -1L;\n\n\tif (v8086_mode(regs))\n\t\treturn (unsigned long)(sel << 4);\n\n\tif (user_64bit_mode(regs)) {\n\t\tunsigned long base;\n\n\t\tif (seg_reg_idx == INAT_SEG_REG_FS)\n\t\t\trdmsrl(MSR_FS_BASE, base);\n\t\telse if (seg_reg_idx == INAT_SEG_REG_GS)\n\t\t\trdmsrl(MSR_KERNEL_GS_BASE, base);\n\t\telse\n\t\t\tbase = 0;\n\t\treturn base;\n\t}\n\n\tif (!sel)\n\t\treturn -1L;\n\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn -1L;\n\n\treturn get_desc_base(desc);\n}",
        "output": "1",
        "idx": 3194
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n\tGC_REFCOUNT(ht) = 1;\n\tGC_TYPE_INFO(ht) = IS_ARRAY;\n\tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\tht->nTableMask = HT_MIN_MASK;\n\tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n\tht->nNextFreeElement = 0;\n\tht->pDestructor = pDestructor;\n\tht->nTableSize = zend_hash_check_size(nSize);\n}",
        "output": "0",
        "idx": 5663
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main()\n{\n    gdImagePtr src, dst;\n    int size;\n\n    src = gdImageCreateTrueColor(1, 10);\n    gdTestAssert(src != NULL);\n\n    src->sx = 0; \n\n    dst = gdImageJpegPtr(src, &size, 0);\n    gdTestAssert(dst == NULL);\n\n    gdImageDestroy(src);\n\n    return gdNumFailures();\n}",
        "output": "0",
        "idx": 6229
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ga_add_string(garray_T *gap, char_u *p)\n{\n    if (ga_grow(gap, 1) == FAIL)\n\treturn FAIL;\n    ((char_u **)(gap->ga_data))[gap->ga_len++] = p;\n    return OK;\n}",
        "output": "0",
        "idx": 7941
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(locale_get_display_name)\n{\n    get_icu_disp_value_src_php( DISP_NAME , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}",
        "output": "0",
        "idx": 5407
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "copy_thread(unsigned long clone_flags, unsigned long stack_start,\n\t    unsigned long stk_sz, struct task_struct *p)\n{\n\tstruct thread_info *thread = task_thread_info(p);\n\tstruct pt_regs *childregs = task_pt_regs(p);\n\n\tmemset(&thread->cpu_context, 0, sizeof(struct cpu_context_save));\n\n\tif (likely(!(p->flags & PF_KTHREAD))) {\n\t\t*childregs = *current_pt_regs();\n\t\tchildregs->ARM_r0 = 0;\n\t\tif (stack_start)\n\t\t\tchildregs->ARM_sp = stack_start;\n\t} else {\n\t\tmemset(childregs, 0, sizeof(struct pt_regs));\n\t\tthread->cpu_context.r4 = stk_sz;\n\t\tthread->cpu_context.r5 = stack_start;\n\t\tchildregs->ARM_cpsr = SVC_MODE;\n\t}\n\tthread->cpu_context.pc = (unsigned long)ret_from_fork;\n\tthread->cpu_context.sp = (unsigned long)childregs;\n\n\tclear_ptrace_hw_breakpoint(p);\n\n\tif (clone_flags & CLONE_SETTLS)\n\t\tthread->tp_value[0] = childregs->ARM_r3;\n\tthread->tp_value[1] = get_tpuser();\n\n\tthread_notify(THREAD_NOTIFY_COPY, thread);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 3257
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct bpf_map *bpf_map_inc(struct bpf_map *map, bool uref)\n{\n\tif (atomic_inc_return(&map->refcnt) > BPF_MAX_REFCNT) {\n\t\tatomic_dec(&map->refcnt);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\tif (uref)\n\t\tatomic_inc(&map->usercnt);\n\treturn map;\n}",
        "output": "0",
        "idx": 1839
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int reverseSortFiles(MprDirEntry **d1, MprDirEntry **d2)\n{\n    char    *base1, *base2, *b1, *b2, *p1, *p2;\n    int     rc;\n\n    base1 = mprGetPathBase((*d1)->name);\n    base2 = mprGetPathBase((*d2)->name);\n\n    if (smatch(base1, base2)) {\n        return 0;\n    }\n    b1 = ssplit(base1, \"-\", &p1);\n    b2 = ssplit(base2, \"-\", &p2);\n    rc = scmp(b1, b2);\n    if (rc == 0) {\n        if (!p1) {\n            rc = 1;\n        } else if (!p2) {\n            rc = -1;\n        } else {\n            rc = scmp(p1, p2);\n        }\n    }\n    return -rc;\n}",
        "output": "0",
        "idx": 6961
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}",
        "output": "0",
        "idx": 8343
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GIT_INLINE(bool) only_spaces_and_dots(const char *path)\n{\n\tconst char *c = path;\n\n\tfor (;; c++) {\n\t\tif (*c == '\\0' || *c == ':')\n\t\t\treturn true;\n\t\tif (*c != ' ' && *c != '.')\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
        "output": "0",
        "idx": 6851
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int touch(const char *path) {\n        return touch_file(path, false, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);\n}",
        "output": "1",
        "idx": 5476
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nfs4_state_set_mode_locked(struct nfs4_state *state, mode_t mode)\n{\n\tif (state->state == mode)\n\t\treturn;\n\tif ((mode & FMODE_WRITE) != (state->state & FMODE_WRITE)) {\n\t\tif (mode & FMODE_WRITE)\n\t\t\tlist_move(&state->open_states, &state->owner->so_states);\n\t\telse\n\t\t\tlist_move_tail(&state->open_states, &state->owner->so_states);\n\t}\n\tstate->state = mode;\n}",
        "output": "1",
        "idx": 2172
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n\n\tobject->u.dir.index = 0;\n\tif (object->u.dir.dirp) {\n\t\tphp_stream_rewinddir(object->u.dir.dirp);\n\t}\n\tspl_filesystem_dir_read(object TSRMLS_CC);\n}",
        "output": "0",
        "idx": 5497
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ga_init2(garray_T *gap, int itemsize, int growsize)\n{\n    ga_init(gap);\n    gap->ga_itemsize = itemsize;\n    gap->ga_growsize = growsize;\n}",
        "output": "1",
        "idx": 5704
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool nf_generic_should_process(u8 proto)\n{\n\tswitch (proto) {\n#ifdef CONFIG_NF_CT_PROTO_SCTP_MODULE\n\tcase IPPROTO_SCTP:\n\t\treturn false;\n#endif\n#ifdef CONFIG_NF_CT_PROTO_DCCP_MODULE\n\tcase IPPROTO_DCCP:\n\t\treturn false;\n#endif\n#ifdef CONFIG_NF_CT_PROTO_GRE_MODULE\n\tcase IPPROTO_GRE:\n\t\treturn false;\n#endif\n#ifdef CONFIG_NF_CT_PROTO_UDPLITE_MODULE\n\tcase IPPROTO_UDPLITE:\n\t\treturn false;\n#endif\n\tdefault:\n\t\treturn true;\n\t}\n}",
        "output": "0",
        "idx": 3697
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "table_regex_match(const char *string, const char *pattern)\n{\n\tregex_t preg;\n\tint\tcflags = REG_EXTENDED|REG_NOSUB;\n\n\tif (strncmp(pattern, \"(?i)\", 4) == 0) {\n\t\tcflags |= REG_ICASE;\n\t\tpattern += 4;\n\t}\n\n\tif (regcomp(&preg, pattern, cflags) != 0)\n\t\treturn (0);\n\n\tif (regexec(&preg, string, 0, NULL, 0) != 0)\n\t\treturn (0);\n\n\treturn (1);\n}",
        "output": "1",
        "idx": 5626
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "destroyUserInformationLists(DUL_USERINFO * userInfo)\n{\n    PRV_SCUSCPROLE\n    * role;\n\n    role = (PRV_SCUSCPROLE*)LST_Dequeue(&userInfo->SCUSCPRoleList);\n    while (role != NULL) {\n        free(role);\n        role = (PRV_SCUSCPROLE*)LST_Dequeue(&userInfo->SCUSCPRoleList);\n    }\n    LST_Destroy(&userInfo->SCUSCPRoleList);\n\n    delete userInfo->extNegList; userInfo->extNegList = NULL;\n\n    delete userInfo->usrIdent; userInfo->usrIdent = NULL;\n}",
        "output": "1",
        "idx": 8840
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mark_desktop_file_executable_task_thread_func (GTask        *task,\n                                               gpointer      source_object,\n                                               gpointer      task_data,\n                                               GCancellable *cancellable)\n{\n    MarkTrustedJob *job = task_data;\n    CommonJob *common;\n\n    common = (CommonJob *) job;\n\n    nautilus_progress_info_start (job->common.progress);\n\n    mark_desktop_file_executable (common,\n                                  cancellable,\n                                  job->file,\n                                  job->interactive);\n}",
        "output": "0",
        "idx": 8821
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int assign_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct task_group *tg = cfs_rq->tg;\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(tg);\n\tu64 amount = 0, min_amount, expires;\n\tint expires_seq;\n\n\tmin_amount = sched_cfs_bandwidth_slice() - cfs_rq->runtime_remaining;\n\n\traw_spin_lock(&cfs_b->lock);\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\tamount = min_amount;\n\telse {\n\t\tstart_cfs_bandwidth(cfs_b);\n\n\t\tif (cfs_b->runtime > 0) {\n\t\t\tamount = min(cfs_b->runtime, min_amount);\n\t\t\tcfs_b->runtime -= amount;\n\t\t\tcfs_b->idle = 0;\n\t\t}\n\t}\n\texpires_seq = cfs_b->expires_seq;\n\texpires = cfs_b->runtime_expires;\n\traw_spin_unlock(&cfs_b->lock);\n\n\tcfs_rq->runtime_remaining += amount;\n\tif (cfs_rq->expires_seq != expires_seq) {\n\t\tcfs_rq->expires_seq = expires_seq;\n\t\tcfs_rq->runtime_expires = expires;\n\t}\n\n\treturn cfs_rq->runtime_remaining > 0;\n}",
        "output": "1",
        "idx": 3218
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,\n\t\tunsigned int, flags, struct sockaddr __user *, addr,\n\t\tint __user *, addr_len)\n{\n\tstruct socket *sock;\n\tstruct iovec iov;\n\tstruct msghdr msg;\n\tstruct sockaddr_storage address;\n\tint err, err2;\n\tint fput_needed;\n\n\tif (size > INT_MAX)\n\t\tsize = INT_MAX;\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_iov = &iov;\n\tiov.iov_len = size;\n\tiov.iov_base = ubuf;\n\tmsg.msg_name = (struct sockaddr *)&address;\n\tmsg.msg_namelen = sizeof(address);\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\terr = sock_recvmsg(sock, &msg, size, flags);\n\n\tif (err >= 0 && addr != NULL) {\n\t\terr2 = move_addr_to_user(&address,\n\t\t\t\t\t msg.msg_namelen, addr, addr_len);\n\t\tif (err2 < 0)\n\t\t\terr = err2;\n\t}\n\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}",
        "output": "1",
        "idx": 2464
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mct_u232_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct mct_u232_private *priv;\n\n\tif (!serial->port[1] || !serial->port[1]->interrupt_in_urb) {\n\t\tdev_err(&port->dev, \"expected endpoint missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->read_urb = serial->port[1]->interrupt_in_urb;\n\tpriv->read_urb->context = port;\n\n\tspin_lock_init(&priv->lock);\n\n\tusb_set_serial_port_data(port, priv);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1777
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void fsnotify_oldname_free(const unsigned char *old_name)\n{\n\tkfree(old_name);\n}",
        "output": "1",
        "idx": 1624
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hb_set_symmetric_difference (hb_set_t       *set,\n\t\t\t     const hb_set_t *other)\n{\n  set->symmetric_difference (*other);\n}",
        "output": "0",
        "idx": 7775
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int prepareForShutdown() {\n    redisLog(REDIS_WARNING,\"User requested shutdown, saving DB...\");\n    if (server.bgsavechildpid != -1) {\n        redisLog(REDIS_WARNING,\"There is a live saving child. Killing it!\");\n        kill(server.bgsavechildpid,SIGKILL);\n        rdbRemoveTempFile(server.bgsavechildpid);\n    }\n    if (server.appendonly) {\n        aof_fsync(server.appendfd);\n        if (server.vm_enabled) unlink(server.vm_swap_file);\n    } else if (server.saveparamslen > 0) {\n        if (rdbSave(server.dbfilename) != REDIS_OK) {\n            redisLog(REDIS_WARNING,\"Error trying to save the DB, can't exit\");\n            return REDIS_ERR;\n        }\n    } else {\n        redisLog(REDIS_WARNING,\"Not saving DB.\");\n    }\n    if (server.daemonize) unlink(server.pidfile);\n    redisLog(REDIS_WARNING,\"Server exit now, bye bye...\");\n    return REDIS_OK;\n}",
        "output": "1",
        "idx": 3666
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ipv6_select_ident(struct frag_hdr *fhdr, struct rt6_info *rt)\n{\n\tstatic atomic_t ipv6_fragmentation_id;\n\tint old, new;\n\n\tif (rt) {\n\t\tstruct inet_peer *peer;\n\n\t\tif (!rt->rt6i_peer)\n\t\t\trt6_bind_peer(rt, 1);\n\t\tpeer = rt->rt6i_peer;\n\t\tif (peer) {\n\t\t\tfhdr->identification = htonl(inet_getid(peer, 0));\n\t\t\treturn;\n\t\t}\n\t}\n\tdo {\n\t\told = atomic_read(&ipv6_fragmentation_id);\n\t\tnew = old + 1;\n\t\tif (!new)\n\t\t\tnew = 1;\n\t} while (atomic_cmpxchg(&ipv6_fragmentation_id, old, new) != old);\n\tfhdr->identification = htonl(new);\n}",
        "output": "0",
        "idx": 723
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload, *zap;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\tgoto error;\n\n\tret = -ENOMEM;\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\tgoto error;\n\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\n\tzap = upayload;\n\n\tret = key_payload_reserve(key, datalen);\n\n\tif (ret == 0) {\n\t\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\t\tzap = key->payload.data[0];\n\t\telse\n\t\t\tzap = NULL;\n\t\trcu_assign_keypointer(key, upayload);\n\t\tkey->expiry = 0;\n\t}\n\n\tif (zap)\n\t\tkfree_rcu(zap, rcu);\n\nerror:\n\treturn ret;\n}",
        "output": "0",
        "idx": 1381
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rpc_init_task(struct rpc_task *task, const struct rpc_task_setup *task_setup_data)\n{\n\tmemset(task, 0, sizeof(*task));\n\tatomic_set(&task->tk_count, 1);\n\ttask->tk_flags  = task_setup_data->flags;\n\ttask->tk_ops = task_setup_data->callback_ops;\n\ttask->tk_calldata = task_setup_data->callback_data;\n\tINIT_LIST_HEAD(&task->tk_task);\n\n\ttask->tk_garb_retry = 2;\n\ttask->tk_cred_retry = 2;\n\ttask->tk_rebind_retry = 2;\n\n\ttask->tk_priority = task_setup_data->priority - RPC_PRIORITY_LOW;\n\ttask->tk_owner = current->tgid;\n\n\ttask->tk_workqueue = task_setup_data->workqueue;\n\n\tif (task->tk_ops->rpc_call_prepare != NULL)\n\t\ttask->tk_action = rpc_prepare_task;\n\n\ttask->tk_start = ktime_get();\n\n\tdprintk(\"RPC:       new task initialized, procpid %u\\n\",\n\t\t\t\ttask_pid_nr(current));\n}",
        "output": "0",
        "idx": 557
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt)\n{\n\tprintbuffer p;\n\tp.buffer=(char*)cJSON_malloc(prebuffer);\n\tp.length=prebuffer;\n\tp.offset=0;\n\treturn print_value(item,0,fmt,&p);\n}",
        "output": "0",
        "idx": 8337
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int is_integer(char *string)\n{\n  if (isdigit(string[0]) || string[0] == '-' || string[0] == '+') {\n    while (*++string && isdigit(*string))\n      ;                                           \n    if (!*string)\n      return 1;\n  }\n  return 0;\n}",
        "output": "1",
        "idx": 5298
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_creat(const char *path)\n{\n\tif (creat(path, 0755) >= 0) {\n\t\tfprintf(stderr, \"leak at creat of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at creat of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}",
        "output": "0",
        "idx": 7279
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint16_t enc28j60ReadPhyReg(NetInterface *interface, uint16_t address)\n{\n   uint16_t data;\n\n   enc28j60WriteReg(interface, ENC28J60_REG_MIREGADR, address & REG_ADDR_MASK);\n\n   enc28j60WriteReg(interface, ENC28J60_REG_MICMD, MICMD_MIIRD);\n   while((enc28j60ReadReg(interface, ENC28J60_REG_MISTAT) & MISTAT_BUSY) != 0)\n   {\n   }\n\n   enc28j60WriteReg(interface, ENC28J60_REG_MICMD, 0);\n\n   data = enc28j60ReadReg(interface, ENC28J60_REG_MIRDL);\n   data |= enc28j60ReadReg(interface, ENC28J60_REG_MIRDH) << 8;\n\n   return data;\n}",
        "output": "1",
        "idx": 8538
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "crm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted)\n{\n    int rc = -1;\n    char *xml_text = NULL;\n    int len = 0;\n\n    xml_text = dump_xml_unformatted(msg);\n    if (xml_text) {\n        len = strlen(xml_text);\n    } else {\n        crm_err(\"Invalid XML, can not send msg\");\n        return -1;\n    }\n\n    rc = crm_send_remote_msg_raw(session, xml_text, len, encrypted);\n    if (rc < 0) {\n        goto done;\n    }\n    rc = crm_send_remote_msg_raw(session, REMOTE_MSG_TERMINATOR, strlen(REMOTE_MSG_TERMINATOR), encrypted);\n\ndone:\n    if (rc < 0) {\n        crm_err(\"Failed to send remote msg, rc = %d\", rc);\n    }\n\n    free(xml_text);\n    return rc;\n}",
        "output": "0",
        "idx": 5259
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "atmarp_spaddr_print(netdissect_options *ndo,\n\t\t    const struct atmarp_pkthdr *ap, u_short pro)\n{\n\tif (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)\n\t\tND_PRINT((ndo, \"<wrong proto type>\"));\n\telse if (ATMSPROTO_LEN(ap) != 4)\n\t\tND_PRINT((ndo, \"<wrong splen>\"));\n\telse\n\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, ATMSPA(ap))));\n}",
        "output": "0",
        "idx": 6693
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void skcipher_release(void *private)\n{\n\tstruct skcipher_tfm *tfm = private;\n\n\tcrypto_free_skcipher(tfm->skcipher);\n\tkfree(tfm);\n}",
        "output": "0",
        "idx": 1543
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned long perf_instruction_pointer(struct pt_regs *regs)\n{\n\tbool use_siar = regs_use_siar(regs);\n\tunsigned long siar = mfspr(SPRN_SIAR);\n\n\tif (ppmu->flags & PPMU_P10_DD1) {\n\t\tif (siar)\n\t\t\treturn siar;\n\t\telse\n\t\t\treturn regs->nip;\n\t} else if (use_siar && siar_valid(regs))\n\t\treturn mfspr(SPRN_SIAR) + perf_ip_adjust(regs);\n\telse if (use_siar)\n\t\treturn 0;\t\t\n\telse\n\t\treturn regs->nip;\n}",
        "output": "1",
        "idx": 1952
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sanitize_val_alu(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_insn *insn)\n{\n\tstruct bpf_insn_aux_data *aux = cur_aux(env);\n\n\tif (can_skip_alu_sanitation(env, insn))\n\t\treturn 0;\n\n\treturn update_alu_sanitation_state(aux, BPF_ALU_NON_POINTER, 0);\n}",
        "output": "0",
        "idx": 4217
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 0);\n\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tucounts = new;\n\t\t}\n\t}\n\tif (!atomic_add_unless(&ucounts->count, 1, INT_MAX))\n\t\tucounts = NULL;\n\tspin_unlock_irq(&ucounts_lock);\n\treturn ucounts;\n}",
        "output": "1",
        "idx": 1516
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileInfo, getRealPath)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar buff[MAXPATHLEN];\n\tchar *filename;\n\tzend_error_handling error_handling;\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n\tif (intern->type == SPL_FS_DIR && !intern->file_name && intern->u.dir.entry.d_name[0]) {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t}\n\t\n\tif (intern->orig_path) {\n\t\tfilename = intern->orig_path;\n\t} else { \n\t\tfilename = intern->file_name;\n\t}\n\n\n\tif (filename && VCWD_REALPATH(filename, buff)) {\n#ifdef ZTS\n\t\tif (VCWD_ACCESS(buff, F_OK)) {\n\t\t\tRETVAL_FALSE;\n\t\t} else\n#endif\n\t\tRETVAL_STRING(buff, 1);\n\t} else {\n\t\tRETVAL_FALSE;\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}",
        "output": "1",
        "idx": 4014
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u64 __skb_get_nlattr_nest(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\tstruct nlattr *nla;\n\n\tif (skb_is_nonlinear(skb))\n\t\treturn 0;\n\n\tif (A > skb->len - sizeof(struct nlattr))\n\t\treturn 0;\n\n\tnla = (struct nlattr *) &skb->data[A];\n\tif (nla->nla_len > A - skb->len)\n\t\treturn 0;\n\n\tnla = nla_find_nested(nla, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 2542
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *my_malloc(size_t size)\n{\n    malloc_called += 1;\n    return malloc(size);\n}",
        "output": "1",
        "idx": 4330
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC int httpTestParam(HttpConn *conn, cchar *var)\n{\n    return mprReadJsonObj(httpGetParams(conn), var) != 0;\n}",
        "output": "0",
        "idx": 7055
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,\n\t\t\t\t\t struct nlattr *rp)\n{\n\tstruct xfrm_replay_state_esn *up;\n\tint ulen;\n\n\tif (!replay_esn || !rp)\n\t\treturn 0;\n\n\tup = nla_data(rp);\n\tulen = xfrm_replay_state_esn_len(up);\n\n\tif (nla_len(rp) < ulen || xfrm_replay_state_esn_len(replay_esn) != ulen)\n\t\treturn -EINVAL;\n\n\tif (up->replay_window > up->bmp_len * sizeof(__u32) * 8)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2223
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int spl_filesystem_file_read_line(zval * this_ptr, spl_filesystem_object *intern, int silent TSRMLS_DC) \n{\n\tint ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);\n\n\twhile (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY) && ret == SUCCESS && spl_filesystem_file_is_empty_line(intern TSRMLS_CC)) {\n\t\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\t\tret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);\n\t}\n\t\n\treturn ret;\n}",
        "output": "1",
        "idx": 4022
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static GCObject **correctgraylist (GCObject **p) {\n  GCObject *curr;\n  while ((curr = *p) != NULL) {\n    switch (curr->tt) {\n      case LUA_VTABLE: case LUA_VUSERDATA: {\n        GCObject **next = getgclist(curr);\n        if (getage(curr) == G_TOUCHED1) {  \n          lua_assert(isgray(curr));\n          gray2black(curr);  \n          changeage(curr, G_TOUCHED1, G_TOUCHED2);\n          p = next;  \n        }\n        else {  \n          if (!iswhite(curr)) {  \n            lua_assert(isold(curr));\n            if (getage(curr) == G_TOUCHED2)  \n              changeage(curr, G_TOUCHED2, G_OLD);  \n            gray2black(curr);  \n          }\n          *p = *next;  \n        }\n        break;\n      }\n      case LUA_VTHREAD: {\n        lua_State *th = gco2th(curr);\n        lua_assert(!isblack(th));\n        if (iswhite(th))  \n          *p = th->gclist;  \n        else  \n          p = &th->gclist;  \n        break;\n      }\n      default: lua_assert(0);  \n    }\n  }\n  return p;\n}",
        "output": "1",
        "idx": 8108
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "test_save_copy (const char *origname)\n{\n  return test_copy_to(origname, TEST_COPY_FILE);\n}",
        "output": "0",
        "idx": 7105
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void lo_release(struct gendisk *disk, fmode_t mode)\n{\n\tmutex_lock(&loop_index_mutex);\n\t__lo_release(disk->private_data);\n\tmutex_unlock(&loop_index_mutex);\n}",
        "output": "0",
        "idx": 2639
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\n\ncan_read_key:\n\tret = -EOPNOTSUPP;\n\tif (key->type->read) {\n\t\tdown_read(&key->sem);\n\t\tret = key_validate(key);\n\t\tif (ret == 0)\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\tup_read(&key->sem);\n\t}\n\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}",
        "output": "0",
        "idx": 1477
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct keydata *get_keyptr(void)\n{\n\tstruct keydata *keyptr = &ip_keydata[ip_cnt & 1];\n\n\tsmp_rmb();\n\n\treturn keyptr;\n}",
        "output": "1",
        "idx": 602
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int update_write_order_info(rdpContext* context, wStream* s, ORDER_INFO* orderInfo,\n                                   size_t offset)\n{\n\tsize_t position;\n\tWINPR_UNUSED(context);\n\tposition = Stream_GetPosition(s);\n\tStream_SetPosition(s, offset);\n\tStream_Write_UINT8(s, orderInfo->controlFlags); \n\n\tif (orderInfo->controlFlags & ORDER_TYPE_CHANGE)\n\t\tStream_Write_UINT8(s, orderInfo->orderType); \n\n\tupdate_write_field_flags(s, orderInfo->fieldFlags, orderInfo->controlFlags,\n\t                         PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]);\n\tupdate_write_bounds(s, orderInfo);\n\tStream_SetPosition(s, position);\n\treturn 0;\n}",
        "output": "1",
        "idx": 4164
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_access(const char *path)\n{\n\tif (access(path, O_RDONLY) >= 0) {\n\t\tfprintf(stderr, \"leak at access of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at access of %s: errno was %d\\n\", path, errno);\n\t\texit(1);\n\t}\n}",
        "output": "0",
        "idx": 7305
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tlong newpos;\n\n\tJAS_DBGLOG(100, (\"mem_seek(%p, %ld, %d)\\n\", obj, offset, origin));\n\tswitch (origin) {\n\tcase SEEK_SET:\n\t\tnewpos = offset;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tnewpos = m->len_ - offset;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tnewpos = m->pos_ + offset;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\tif (newpos < 0) {\n\t\treturn -1;\n\t}\n\tm->pos_ = newpos;\n\n\treturn m->pos_;\n}",
        "output": "1",
        "idx": 5372
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int wvlan_set_station_nickname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tsize_t len;\n\tint         ret = 0;\n\n\n\tDBG_FUNC(\"wvlan_set_station_nickname\");\n\tDBG_ENTER(DbgInfo);\n\n\twl_lock(lp, &flags);\n\n\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\tlen = min_t(size_t, wrqu->data.length, sizeof(lp->StationName));\n\tstrlcpy(lp->StationName, extra, len);\n\n\twl_apply(lp);\n\twl_unlock(lp, &flags);\n\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} ",
        "output": "0",
        "idx": 3351
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jpc_ppm_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\n\tcstate = 0;\n\n\tppm->data = 0;\n\n\tif (ms->len < 1) {\n\t\tgoto error;\n\t}\n\tif (jpc_getuint8(in, &ppm->ind)) {\n\t\tgoto error;\n\t}\n\n\tppm->len = ms->len - 1;\n\tif (ppm->len > 0) {\n\t\tif (!(ppm->data = jas_malloc(ppm->len))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (JAS_CAST(jas_uint, jas_stream_read(in, ppm->data, ppm->len)) != ppm->len) {\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tppm->data = 0;\n\t}\n\treturn 0;\n\nerror:\n\tjpc_ppm_destroyparms(ms);\n\treturn -1;\n}",
        "output": "0",
        "idx": 7569
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void asmlinkage smm_do_relocation(void *arg)\n{\n\tconst struct smm_module_params *p;\n\tconst struct smm_runtime *runtime;\n\tint cpu;\n\tuintptr_t curr_smbase;\n\tuintptr_t perm_smbase;\n\n\tp = arg;\n\truntime = p->runtime;\n\tcpu = p->cpu;\n\tcurr_smbase = runtime->smbase;\n\n\tif (cpu >= CONFIG_MAX_CPUS) {\n\t\tprintk(BIOS_CRIT,\n\t\t       \"Invalid CPU number assigned in SMM stub: %d\\n\", cpu);\n\t\treturn;\n\t}\n\n\tperm_smbase = mp_state.perm_smbase;\n\tperm_smbase -= cpu * runtime->save_state_size;\n\n\tprintk(BIOS_DEBUG, \"New SMBASE 0x%08lx\\n\", perm_smbase);\n\n\tmp_state.ops.relocation_handler(cpu, curr_smbase, perm_smbase);\n\n\tif (CONFIG(STM)) {\n\t\tuintptr_t mseg;\n\n\t\tmseg = mp_state.perm_smbase +\n\t\t\t(mp_state.perm_smsize - CONFIG_MSEG_SIZE);\n\n\t\tstm_setup(mseg, p->cpu,\n\t\t\t\tperm_smbase,\n\t\t\t\tmp_state.perm_smbase,\n\t\t\t\truntime->start32_offset);\n\t}\n}",
        "output": "1",
        "idx": 8930
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __net_exit sctp_defaults_exit(struct net *net)\n{\n\tsctp_free_addr_wq(net);\n\tsctp_free_local_addr_list(net);\n\n\tsctp_dbg_objcnt_exit(net);\n\n\tsctp_proc_exit(net);\n\tcleanup_sctp_mibs(net);\n\tsctp_sysctl_net_unregister(net);\n}",
        "output": "0",
        "idx": 4023
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rtnl_fill_link_ifmap(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct rtnl_link_ifmap map;\n\n\tmemset(&map, 0, sizeof(map));\n\tmap.mem_start   = dev->mem_start;\n\tmap.mem_end     = dev->mem_end;\n\tmap.base_addr   = dev->base_addr;\n\tmap.irq         = dev->irq;\n\tmap.dma         = dev->dma;\n\tmap.port        = dev->if_port;\n\n\tif (nla_put(skb, IFLA_MAP, sizeof(map), &map))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1849
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Curl_ssl_associate_conn(struct Curl_easy *data,\n                             struct connectdata *conn)\n{\n  if(Curl_ssl->associate_connection) {\n    Curl_ssl->associate_connection(data, conn, FIRSTSOCKET);\n    if(conn->sock[SECONDARYSOCKET] && conn->bits.sock_accepted)\n      Curl_ssl->associate_connection(data, conn, SECONDARYSOCKET);\n  }\n}",
        "output": "0",
        "idx": 8461
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int CLASS parse_jpeg(int offset)\n{\n  int len, save, hlen, mark;\n  fseek(ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n    return 0;\n\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda)\n  {\n    order = 0x4d4d;\n    len = get2() - 2;\n    save = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9)\n    {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width = get2();\n    }\n    order = get2();\n    hlen = get4();\n    if (get4() == 0x48454150) \n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff(save + hlen, len - hlen, 0);\n    }\n    if (parse_tiff(save + 6))\n      apply_tiff();\n    fseek(ifp, save + len, SEEK_SET);\n  }\n  return 1;\n}",
        "output": "1",
        "idx": 3754
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void httpClientParseQopParam(const HttpParam *param,\n   HttpWwwAuthenticateHeader *authHeader)\n{\n#if (HTTP_CLIENT_DIGEST_AUTH_SUPPORT == ENABLED)\n   size_t i;\n   size_t n;\n\n   authHeader->qop = HTTP_AUTH_QOP_NONE;\n\n   for(i = 0; i < param->valueLen; i += (n + 1))\n   {\n      for(n = 0; (i + n) < param->valueLen; n++)\n      {\n         if(strchr(\", \\t\", param->value[i + n]))\n            break;\n      }\n\n      if(n == 4 && !osStrncasecmp(param->value + i, \"auth\", 4))\n      {\n         authHeader->qop = HTTP_AUTH_QOP_AUTH;\n      }\n   }\n\n   if(authHeader->qop == HTTP_AUTH_QOP_NONE)\n   {\n      authHeader->mode = HTTP_AUTH_MODE_NONE;\n   }\n#endif\n}",
        "output": "1",
        "idx": 8640
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline ut8 r_read_ble8(const void *src) {\n\tif (!src) {\n\t\treturn UT8_MAX;\n\t}\n\treturn *(ut8 *)src;\n}",
        "output": "0",
        "idx": 8597
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\n\tif (prepare && skb_rtable(skb)) {\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\tif (unlikely(IPCB(skb)->opt.optlen))\n\t\tskb_dst_force(skb);\n\telse\n\t\tskb_dst_drop(skb);\n}",
        "output": "0",
        "idx": 2123
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void * gdImageGifPtr (gdImagePtr im, int *size)\n{\n  void *rv;\n  gdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n\tif (!_gdImageGifCtx(im, out)) {\n\t\trv = gdDPExtractData(out, size);\n\t} else {\n\t\trv = NULL;\n\t}\n  out->gd_free (out);\n  return rv;\n}",
        "output": "0",
        "idx": 5689
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void process_blob(struct rev_info *revs,\n\t\t\t struct blob *blob,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *path,\n\t\t\t const char *name,\n\t\t\t void *cb_data)\n{\n\tstruct object *obj = &blob->object;\n\n\tif (!revs->blob_objects)\n\t\treturn;\n\tif (!obj)\n\t\tdie(\"bad blob object\");\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn;\n\tobj->flags |= SEEN;\n\tshow(obj, path, name, cb_data);\n}",
        "output": "1",
        "idx": 5194
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "addMultiArrayContentJSON(CtxJson *ctx, void* array, const UA_DataType *type, \n                         size_t *index, UA_UInt32 *arrayDimensions, size_t dimensionIndex, \n                         size_t dimensionSize) {\n    if(ctx->depth > UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    \n    status ret;\n    if(dimensionIndex == (dimensionSize - 1)) {\n        ret = encodeJsonArray(ctx, ((u8*)array) + (type->memSize * *index),\n                              arrayDimensions[dimensionIndex], type);\n        (*index) += arrayDimensions[dimensionIndex];\n        return ret;\n    }\n\n    ret = writeJsonArrStart(ctx);\n    for(size_t i = 0; i < arrayDimensions[dimensionIndex]; i++) {\n        ret |= writeJsonCommaIfNeeded(ctx);\n        ret |= addMultiArrayContentJSON(ctx, array, type, index, arrayDimensions,\n                                        dimensionIndex + 1, dimensionSize);\n        ctx->commaNeeded[ctx->depth] = true;\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n    ret |= writeJsonArrEnd(ctx);\n    return ret;\n}",
        "output": "1",
        "idx": 8388
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size,\n\t\t\t const void *data)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmemdup(data, size, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,\n\t\t\t      indx, buf, size, 100);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\tkfree(buf);\n\treturn ret;\n}",
        "output": "0",
        "idx": 2129
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sco_sock_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t int addr_len)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->sco_bdaddr);\n\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tif (addr_len < sizeof(struct sockaddr_sco))\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tbacpy(&sco_pi(sk)->src, &sa->sco_bdaddr);\n\n\tsk->sk_state = BT_BOUND;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}",
        "output": "0",
        "idx": 1473
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateFloatArray( double *numbers, int count )\n{\n\tint i;\n\tcJSON *n = 0, *p = 0, *a = cJSON_CreateArray();\n\tfor ( i = 0; a && i < count; ++i ) {\n\t\tn = cJSON_CreateFloat( numbers[i] );\n\t\tif ( ! i )\n\t\t\ta->child = n;\n\t\telse\n\t\t\tsuffix_object( p, n );\n\t\tp = n;\n\t}\n\treturn a;\n}",
        "output": "1",
        "idx": 5874
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\tpmd_t pmdval = *pmd;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tif (!pmd_trans_huge(pmdval))\n\t\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 718
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "horAcc32(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint32* wp = (uint32*) cp0;\n\ttmsize_t wc = cc / 4;\n\n\tassert((cc%(4*stride))==0);\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] += wp[0]; wp++)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n}",
        "output": "1",
        "idx": 4278
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PJ_DEF(void) pjmedia_rtcp_rx_rtcp( pjmedia_rtcp_session *sess,\n\t\t\t\t   const void *pkt,\n\t\t\t\t   pj_size_t size)\n{\n    pj_uint8_t *p, *p_end;\n\n    p = (pj_uint8_t*)pkt;\n    p_end = p + size;\n    while (p < p_end) {\n\tpjmedia_rtcp_common *common = (pjmedia_rtcp_common*)p;\n\tunsigned len;\n\n\tlen = (pj_ntohs((pj_uint16_t)common->length)+1) * 4;\n\tif (p + len > p_end)\n\t    break;\n\n\tswitch(common->pt) {\n\tcase RTCP_SR:\n\tcase RTCP_RR:\n\tcase RTCP_XR:\n\t    parse_rtcp_report(sess, p, len);\n\t    break;\n\tcase RTCP_SDES:\n\t    parse_rtcp_sdes(sess, p, len);\n\t    break;\n\tcase RTCP_BYE:\n\t    parse_rtcp_bye(sess, p, len);\n\t    break;\n\tcase RTCP_RTPFB:\n\tcase RTCP_PSFB:\n\t    parse_rtcp_fb(sess, p, len);\n\t    break;\n\tdefault:\n\t    TRACE_((sess->name, \"Received unknown RTCP packet type=%d\",\n\t\t    common->pt));\n\t    break;\n\t}\n\n\tp += len;\n    }\n}",
        "output": "1",
        "idx": 8040
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int socket_accept(int fd, uint16_t port)\n{\n#ifdef WIN32\n\tint addr_len;\n#else\n\tsocklen_t addr_len;\n#endif\n\tint result;\n\tstruct sockaddr_in addr;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\taddr.sin_port = htons(port);\n\n\taddr_len = sizeof(addr);\n\tresult = accept(fd, (struct sockaddr*)&addr, &addr_len);\n\n\treturn result;\n}",
        "output": "0",
        "idx": 8363
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int crypto_rng_generate(struct crypto_rng *tfm,\n\t\t\t\t      const u8 *src, unsigned int slen,\n\t\t\t\t      u8 *dst, unsigned int dlen)\n{\n\treturn tfm->generate(tfm, src, slen, dst, dlen);\n}",
        "output": "1",
        "idx": 2846
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *curl_easy_unescape(CURL *handle, const char *string, int length,\n                         int *olen)\n{\n  int alloc = (length?length:(int)strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  int strindex=0;\n  unsigned long hex;\n  CURLcode res;\n\n  if(!ns)\n    return NULL;\n\n  while(--alloc > 0) {\n    in = *string;\n    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n      char hexstr[3];\n      char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n\n      hex = strtoul(hexstr, &ptr, 16);\n\n      in = curlx_ultouc(hex); \n\n      res = Curl_convert_from_network(handle, &in, 1);\n      if(res) {\n        free(ns);\n        return NULL;\n      }\n\n      string+=2;\n      alloc-=2;\n    }\n\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; \n\n  if(olen)\n    *olen = strindex;\n  return ns;\n}",
        "output": "1",
        "idx": 3586
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bpf_adj_branches(struct bpf_prog *prog, u32 pos, u32 delta)\n{\n\tstruct bpf_insn *insn = prog->insnsi;\n\tu32 i, insn_cnt = prog->len;\n\tbool pseudo_call;\n\tu8 code;\n\tint off;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tcode = insn->code;\n\t\tif (BPF_CLASS(code) != BPF_JMP)\n\t\t\tcontinue;\n\t\tif (BPF_OP(code) == BPF_EXIT)\n\t\t\tcontinue;\n\t\tif (BPF_OP(code) == BPF_CALL) {\n\t\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\t\tpseudo_call = true;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tpseudo_call = false;\n\t\t}\n\t\toff = pseudo_call ? insn->imm : insn->off;\n\n\t\tif (i < pos && i + off + 1 > pos)\n\t\t\toff += delta;\n\t\telse if (i > pos + delta && i + off + 1 <= pos + delta)\n\t\t\toff -= delta;\n\n\t\tif (pseudo_call)\n\t\t\tinsn->imm = off;\n\t\telse\n\t\t\tinsn->off = off;\n\t}\n}",
        "output": "1",
        "idx": 2954
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fb_mmap(struct file *file, struct vm_area_struct * vma)\n{\n\tstruct fb_info *info = file_fb_info(file);\n\tstruct fb_ops *fb;\n\tunsigned long mmio_pgoff;\n\tunsigned long start;\n\tu32 len;\n\n\tif (!info)\n\t\treturn -ENODEV;\n\tfb = info->fbops;\n\tif (!fb)\n\t\treturn -ENODEV;\n\tmutex_lock(&info->mm_lock);\n\tif (fb->fb_mmap) {\n\t\tint res;\n\t\tres = fb->fb_mmap(info, vma);\n\t\tmutex_unlock(&info->mm_lock);\n\t\treturn res;\n\t}\n\n\tstart = info->fix.smem_start;\n\tlen = info->fix.smem_len;\n\tmmio_pgoff = PAGE_ALIGN((start & ~PAGE_MASK) + len) >> PAGE_SHIFT;\n\tif (vma->vm_pgoff >= mmio_pgoff) {\n\t\tvma->vm_pgoff -= mmio_pgoff;\n\t\tstart = info->fix.mmio_start;\n\t\tlen = info->fix.mmio_len;\n\t}\n\tmutex_unlock(&info->mm_lock);\n\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\tfb_pgprotect(file, vma, start);\n\n\treturn vm_iomap_memory(vma, start, len);\n}",
        "output": "0",
        "idx": 1325
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_remove_from_owner(struct perf_event *event)\n{\n\tstruct task_struct *owner;\n\n\trcu_read_lock();\n\towner = ACCESS_ONCE(event->owner);\n\tsmp_read_barrier_depends();\n\tif (owner) {\n\t\tget_task_struct(owner);\n\t}\n\trcu_read_unlock();\n\n\tif (owner) {\n\t\tmutex_lock_nested(&owner->perf_event_mutex, SINGLE_DEPTH_NESTING);\n\n\t\tif (event->owner)\n\t\t\tlist_del_init(&event->owner_entry);\n\t\tmutex_unlock(&owner->perf_event_mutex);\n\t\tput_task_struct(owner);\n\t}\n}",
        "output": "0",
        "idx": 3827
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int jas_stream_gobble(jas_stream_t *stream, int n)\n{\n\tint m;\n\tif (n < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_gobble\");\n\t}\n\tm = n;\n\tfor (m = n; m > 0; --m) {\n\t\tif (jas_stream_getc(stream) == EOF) {\n\t\t\treturn n - m;\n\t\t}\n\t}\n\treturn n;\n}",
        "output": "0",
        "idx": 7525
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void   cJSON_AddItemToArray(cJSON *array, cJSON *item)\t\t\t\t\t\t{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}",
        "output": "0",
        "idx": 8305
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ocall_malloc(size_t size, uint8_t **ret) {\n  *ret = static_cast<uint8_t *>(malloc(size));\n}",
        "output": "1",
        "idx": 7236
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "LUA_API void lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {\n  if (func == NULL || mask == 0) {  \n    mask = 0;\n    func = NULL;\n  }\n  if (isLua(L->ci))\n    L->oldpc = L->ci->u.l.savedpc;\n  L->hook = func;\n  L->basehookcount = count;\n  resethookcount(L);\n  L->hookmask = cast_byte(mask);\n  if (mask)\n    settraps(L->ci);  \n}",
        "output": "1",
        "idx": 8102
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ceph_x_verify_authorizer_reply(struct ceph_auth_client *ac,\n\t\t\t\t\t  struct ceph_authorizer *a, size_t len)\n{\n\tstruct ceph_x_authorizer *au = (void *)a;\n\tstruct ceph_x_ticket_handler *th;\n\tint ret = 0;\n\tstruct ceph_x_authorize_reply reply;\n\tvoid *p = au->reply_buf;\n\tvoid *end = p + sizeof(au->reply_buf);\n\n\tth = get_ticket_handler(ac, au->service);\n\tif (IS_ERR(th))\n\t\treturn PTR_ERR(th);\n\tret = ceph_x_decrypt(&th->session_key, &p, end, &reply, sizeof(reply));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != sizeof(reply))\n\t\treturn -EPERM;\n\n\tif (au->nonce + 1 != le64_to_cpu(reply.nonce_plus_one))\n\t\tret = -EPERM;\n\telse\n\t\tret = 0;\n\tdout(\"verify_authorizer_reply nonce %llx got %llx ret %d\\n\",\n\t     au->nonce, le64_to_cpu(reply.nonce_plus_one), ret);\n\treturn ret;\n}",
        "output": "1",
        "idx": 2662
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool check_client_passwd(PgSocket *client, const char *passwd)\n{\n\tchar md5[MD5_PASSWD_LEN + 1];\n\tconst char *correct;\n\tPgUser *user = client->auth_user;\n\n\tif (!user) {\n\t\tslog_error(client, \"Password packet before auth packet?\");\n\t\treturn false;\n\t}\n\n\tif (!*passwd || !*user->passwd)\n\t\treturn false;\n\n\tswitch (cf_auth_type) {\n\tcase AUTH_PLAIN:\n\t\treturn strcmp(user->passwd, passwd) == 0;\n\tcase AUTH_CRYPT:\n\t\tcorrect = crypt(user->passwd, (char *)client->tmp_login_salt);\n\t\treturn correct && strcmp(correct, passwd) == 0;\n\tcase AUTH_MD5:\n\t\tif (strlen(passwd) != MD5_PASSWD_LEN)\n\t\t\treturn false;\n\t\tif (!isMD5(user->passwd))\n\t\t\tpg_md5_encrypt(user->passwd, user->name, strlen(user->name), user->passwd);\n\t\tpg_md5_encrypt(user->passwd + 3, (char *)client->tmp_login_salt, 4, md5);\n\t\treturn strcmp(md5, passwd) == 0;\n\t}\n\treturn false;\n}",
        "output": "0",
        "idx": 7413
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void perf_event_task_sched_out(struct task_struct *task, struct task_struct *next)\n{\n\tperf_sw_event(PERF_COUNT_SW_CONTEXT_SWITCHES, 1, 1, NULL, 0);\n\n\t__perf_event_task_sched_out(task, next);\n}",
        "output": "1",
        "idx": 516
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __init(RBuffer *buf, r_bin_ne_obj_t *bin) {\n\tbin->header_offset = r_buf_read_le16_at (buf, 0x3c);\n\tbin->ne_header = R_NEW0 (NE_image_header);\n\tif (!bin->ne_header) {\n\t\treturn;\n\t}\n\tbin->buf = buf;\n\tr_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header));\n\tbin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;\n\tif (!bin->alignment) {\n\t\tbin->alignment = 1 << 9;\n\t}\n\tbin->os = __get_target_os (bin);\n\n\tut16 offset = bin->ne_header->SegTableOffset + bin->header_offset;\n\tut16 size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);\n\tbin->segment_entries = calloc (1, size);\n\tif (!bin->segment_entries) {\n\t\treturn;\n\t}\n\tr_buf_read_at (buf, offset, (ut8 *)bin->segment_entries, size);\n\tbin->entry_table = calloc (1, bin->ne_header->EntryTableLength);\n\tr_buf_read_at (buf, (ut64)bin->header_offset + bin->ne_header->EntryTableOffset, bin->entry_table, bin->ne_header->EntryTableLength);\n\tbin->imports = r_bin_ne_get_imports (bin);\n\t__ne_get_resources (bin);\n}",
        "output": "1",
        "idx": 6510
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_event_output(struct perf_event *event,\n\t\t\t\tstruct perf_sample_data *data,\n\t\t\t\tstruct pt_regs *regs)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_event_header header;\n\n\trcu_read_lock();\n\n\tperf_prepare_sample(&header, data, event, regs);\n\n\tif (perf_output_begin(&handle, event, header.size, 1))\n\t\tgoto exit;\n\n\tperf_output_sample(&handle, &header, data, event);\n\n\tperf_output_end(&handle);\n\nexit:\n\trcu_read_unlock();\n}",
        "output": "0",
        "idx": 699
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "add_mibfile(const char* tmpstr, const char* d_name, FILE *ip )\n{\n    FILE           *fp;\n    char            token[MAXTOKEN], token2[MAXTOKEN];\n\n    if ((fp = fopen(tmpstr, \"r\")) == NULL) {\n        snmp_log_perror(tmpstr);\n        return 1;\n    }\n    DEBUGMSGTL((\"parse-mibs\", \"Checking file: %s...\\n\",\n                tmpstr));\n    mibLine = 1;\n    File = tmpstr;\n    if (get_token(fp, token, MAXTOKEN) != LABEL) {\n\t    fclose(fp);\n\t    return 1;\n    }\n    if (get_token(fp, token2, MAXTOKEN) == DEFINITIONS) {\n        new_module(token, tmpstr);\n        if (ip)\n            fprintf(ip, \"%s %s\\n\", token, d_name);\n        fclose(fp);\n        return 0;\n    } else {\n        fclose(fp);\n        return 1;\n    }\n}",
        "output": "1",
        "idx": 7812
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void switch_to_bitmap(unsigned long tifp)\n{\n\tif (tifp & _TIF_IO_BITMAP)\n\t\ttss_invalidate_io_bitmap();\n}",
        "output": "0",
        "idx": 2695
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,\n\t\t\t\t    void *insn, int insn_len)\n{\n\tint r = EMULATION_OK;\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tif (!(emulation_type & EMULTYPE_SKIP) &&\n\t    kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\treturn r;\n\n\tr = x86_decode_insn(ctxt, insn, insn_len, emulation_type);\n\n\ttrace_kvm_emulate_insn_start(vcpu);\n\t++vcpu->stat.insn_emulation;\n\n\treturn r;\n}",
        "output": "1",
        "idx": 2038
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int read_probe(const AVProbeData *p)\n{\n    int cnt = 0;\n\n    for (int i = 0; i < p->buf_size; i++)\n        cnt += !!isansicode(p->buf[i]);\n\n    return (cnt * 100LL / p->buf_size) * (cnt > 400) *\n        !!av_match_ext(p->filename, tty_extensions);\n}",
        "output": "0",
        "idx": 4799
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "perf_sw_event(u32 event_id, u64 nr, int nmi, struct pt_regs *regs, u64 addr)\n{\n\tstruct pt_regs hot_regs;\n\n\tif (static_branch(&perf_swevent_enabled[event_id])) {\n\t\tif (!regs) {\n\t\t\tperf_fetch_caller_regs(&hot_regs);\n\t\t\tregs = &hot_regs;\n\t\t}\n\t\t__perf_sw_event(event_id, nr, nmi, regs, addr);\n\t}\n}",
        "output": "1",
        "idx": 514
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "perf_event_read_event(struct perf_event *event,\n\t\t\tstruct task_struct *task)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tstruct perf_read_event read_event = {\n\t\t.header = {\n\t\t\t.type = PERF_RECORD_READ,\n\t\t\t.misc = 0,\n\t\t\t.size = sizeof(read_event) + event->read_size,\n\t\t},\n\t\t.pid = perf_event_pid(event, task),\n\t\t.tid = perf_event_tid(event, task),\n\t};\n\tint ret;\n\n\tperf_event_header__init_id(&read_event.header, &sample, event);\n\tret = perf_output_begin(&handle, event, read_event.header.size, 0);\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, read_event);\n\tperf_output_read(&handle, event);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\n}",
        "output": "0",
        "idx": 701
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jas_iccgetuint(jas_stream_t *in, int n, ulonglong *val)\n{\n\tint i;\n\tint c;\n\tulonglong v;\n\tv = 0;\n\tfor (i = n; i > 0; --i) {\n\t\tif ((c = jas_stream_getc(in)) == EOF)\n\t\t\treturn -1;\n\t\tv = (v << 8) | c;\n\t}\n\t*val = v;\n\treturn 0;\n}",
        "output": "1",
        "idx": 5386
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cg_opendir(const char *path, struct fuse_file_info *fi)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tconst char *cgroup;\n\tstruct file_info *dir_info;\n\tchar *controller = NULL;\n\n\tif (!fc)\n\t\treturn -EIO;\n\n\tif (strcmp(path, \"/cgroup\") == 0) {\n\t\tcgroup = NULL;\n\t\tcontroller = NULL;\n\t} else {\n\t\tcontroller = pick_controller_from_path(fc, path);\n\t\tif (!controller)\n\t\t\treturn -EIO;\n\n\t\tcgroup = find_cgroup_in_path(path);\n\t\tif (!cgroup) {\n\t\t\tcgroup = \"/\";\n\t\t}\n\t}\n\n\tif (cgroup) {\n\t\tif (!caller_may_see_dir(fc->pid, controller, cgroup))\n\t\t\treturn -ENOENT;\n\t\tif (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))\n\t\t\treturn -EACCES;\n\t}\n\n\tdir_info = malloc(sizeof(*dir_info));\n\tif (!dir_info)\n\t\treturn -ENOMEM;\n\tdir_info->controller = must_copy_string(controller);\n\tdir_info->cgroup = must_copy_string(cgroup);\n\tdir_info->type = LXC_TYPE_CGDIR;\n\tdir_info->buf = NULL;\n\tdir_info->file = NULL;\n\tdir_info->buflen = 0;\n\n\tfi->fh = (unsigned long)dir_info;\n\treturn 0;\n}",
        "output": "0",
        "idx": 7253
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n{\n    VirtQueueElement elem;\n    VirtQueue *vq;\n\n    vq = vser->c_ivq;\n    if (!virtio_queue_ready(vq)) {\n        return 0;\n    }\n    if (!virtqueue_pop(vq, &elem)) {\n        return 0;\n    }\n\n    memcpy(elem.in_sg[0].iov_base, buf, len);\n\n    virtqueue_push(vq, &elem, len);\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n    return len;\n}",
        "output": "1",
        "idx": 3788
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gss_delete_sec_context (minor_status,\n                        context_handle,\n                        output_token)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_buffer_t\t\toutput_token;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n\n    status = val_del_sec_ctx_args(minor_status, context_handle, output_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n\n    ctx = (gss_union_ctx_id_t) *context_handle;\n    if (GSSINT_CHK_LOOP(ctx))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n\tstatus = gssint_delete_internal_sec_context(minor_status,\n\t\t\t\t\t\t    ctx->mech_type,\n\t\t\t\t\t\t    &ctx->internal_ctx_id,\n\t\t\t\t\t\t    output_token);\n\tif (status)\n\t    return status;\n    }\n\n    free(ctx->mech_type->elements);\n    free(ctx->mech_type);\n    free(*context_handle);\n    *context_handle = GSS_C_NO_CONTEXT;\n\n    return (GSS_S_COMPLETE);\n}",
        "output": "0",
        "idx": 249
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int multipath_ioctl(struct dm_target *ti, unsigned int cmd,\n\t\t\t   unsigned long arg)\n{\n\tstruct multipath *m = (struct multipath *) ti->private;\n\tstruct block_device *bdev = NULL;\n\tfmode_t mode = 0;\n\tunsigned long flags;\n\tint r = 0;\n\n\tspin_lock_irqsave(&m->lock, flags);\n\n\tif (!m->current_pgpath)\n\t\t__choose_pgpath(m, 0);\n\n\tif (m->current_pgpath) {\n\t\tbdev = m->current_pgpath->path.dev->bdev;\n\t\tmode = m->current_pgpath->path.dev->mode;\n\t}\n\n\tif (m->queue_io)\n\t\tr = -EAGAIN;\n\telse if (!bdev)\n\t\tr = -EIO;\n\n\tspin_unlock_irqrestore(&m->lock, flags);\n\n\tif (!r && ti->len != i_size_read(bdev->bd_inode) >> SECTOR_SHIFT)\n\t\tr = scsi_verify_blk_ioctl(NULL, cmd);\n\n\treturn r ? : __blkdev_driver_ioctl(bdev, mode, cmd, arg);\n}",
        "output": "0",
        "idx": 869
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void lpc546xxEthDisableIrq(NetInterface *interface)\n{\n   NVIC_DisableIRQ(ETHERNET_IRQn);\n\n   if(interface->phyDriver != NULL)\n   {\n      interface->phyDriver->disableIrq(interface);\n   }\n   else if(interface->switchDriver != NULL)\n   {\n      interface->switchDriver->disableIrq(interface);\n   }\n   else\n   {\n   }\n}",
        "output": "1",
        "idx": 8590
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool get_desc(struct desc_struct *out, unsigned short sel)\n{\n\tstruct desc_ptr gdt_desc = {0, 0};\n\tunsigned long desc_base;\n\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\tif ((sel & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tbool success = false;\n\t\tstruct ldt_struct *ldt;\n\n\t\tsel >>= 3;\n\n\t\tmutex_lock(&current->active_mm->context.lock);\n\t\tldt = current->active_mm->context.ldt;\n\t\tif (ldt && sel < ldt->nr_entries) {\n\t\t\t*out = ldt->entries[sel];\n\t\t\tsuccess = true;\n\t\t}\n\n\t\tmutex_unlock(&current->active_mm->context.lock);\n\n\t\treturn success;\n\t}\n#endif\n\tnative_store_gdt(&gdt_desc);\n\n\tdesc_base = sel & ~(SEGMENT_RPL_MASK | SEGMENT_TI_MASK);\n\n\tif (desc_base > gdt_desc.size)\n\t\treturn false;\n\n\t*out = *(struct desc_struct *)(gdt_desc.address + desc_base);\n\treturn true;\n}",
        "output": "0",
        "idx": 4403
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rawsock_create(struct net *net, struct socket *sock,\n\t\t\t  const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\n\tpr_debug(\"sock=%p\\n\", sock);\n\n\tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &rawsock_raw_ops;\n\telse\n\t\tsock->ops = &rawsock_ops;\n\n\tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsk->sk_protocol = nfc_proto->id;\n\tsk->sk_destruct = rawsock_destruct;\n\tsock->state = SS_UNCONNECTED;\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_sock_link(&raw_sk_list, sk);\n\telse {\n\t\tINIT_WORK(&nfc_rawsock(sk)->tx_work, rawsock_tx_work);\n\t\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\t}\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1858
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void request_key_auth_describe(const struct key *key,\n\t\t\t\t      struct seq_file *m)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\n\tseq_puts(m, \"key:\");\n\tseq_puts(m, key->description);\n\tif (key_is_positive(key))\n\t\tseq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);\n}",
        "output": "0",
        "idx": 2513
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static CURLcode imap_parse_url_path(struct connectdata *conn)\n{\n  struct imap_conn *imapc = &conn->proto.imapc;\n  struct SessionHandle *data = conn->data;\n  const char *path = data->state.path;\n\n  if(!*path)\n    path = \"INBOX\";\n\n  return Curl_urldecode(data, path, 0, &imapc->mailbox, NULL, TRUE);\n}",
        "output": "0",
        "idx": 5019
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)\n{\n\tmemset(p, 0, sizeof(*p));\n\tmemcpy(&p->id, &x->id, sizeof(p->id));\n\tmemcpy(&p->sel, &x->sel, sizeof(p->sel));\n\tmemcpy(&p->lft, &x->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &x->curlft, sizeof(p->curlft));\n\tmemcpy(&p->stats, &x->stats, sizeof(p->stats));\n\tmemcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr));\n\tp->mode = x->props.mode;\n\tp->replay_window = x->props.replay_window;\n\tp->reqid = x->props.reqid;\n\tp->family = x->props.family;\n\tp->flags = x->props.flags;\n\tp->seq = x->km.seq;\n}",
        "output": "0",
        "idx": 1053
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,\n\t\t\t  __be32 saddr, __be32 daddr, struct ip_options_rcu *opt)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct iphdr *iph;\n\n\tskb_push(skb, sizeof(struct iphdr) + (opt ? opt->opt.optlen : 0));\n\tskb_reset_network_header(skb);\n\tiph = ip_hdr(skb);\n\tiph->version  = 4;\n\tiph->ihl      = 5;\n\tiph->tos      = inet->tos;\n\tif (ip_dont_fragment(sk, &rt->dst))\n\t\tiph->frag_off = htons(IP_DF);\n\telse\n\t\tiph->frag_off = 0;\n\tiph->ttl      = ip_select_ttl(inet, &rt->dst);\n\tiph->daddr    = rt->rt_dst;\n\tiph->saddr    = rt->rt_src;\n\tiph->protocol = sk->sk_protocol;\n\tip_select_ident(iph, &rt->dst, sk);\n\n\tif (opt && opt->opt.optlen) {\n\t\tiph->ihl += opt->opt.optlen>>2;\n\t\tip_options_build(skb, &opt->opt, daddr, rt, 0);\n\t}\n\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\n\treturn ip_local_out(skb);\n}",
        "output": "0",
        "idx": 497
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "linkaddr_string(netdissect_options *ndo, const u_char *ep,\n\t\tconst unsigned int type, const unsigned int len)\n{\n\tregister u_int i;\n\tregister char *cp;\n\tregister struct bsnamemem *tp;\n\n\tif (len == 0)\n\t\treturn (\"<empty>\");\n\n\tif (type == LINKADDR_ETHER && len == ETHER_ADDR_LEN)\n\t\treturn (etheraddr_string(ndo, ep));\n\n\tif (type == LINKADDR_FRELAY)\n\t\treturn (q922_string(ndo, ep, len));\n\n\ttp = lookup_bytestring(ndo, ep, len);\n\tif (tp->bs_name)\n\t\treturn (tp->bs_name);\n\n\ttp->bs_name = cp = (char *)malloc(len*3);\n\tif (tp->bs_name == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"linkaddr_string: malloc\");\n\t*cp++ = hex[*ep >> 4];\n\t*cp++ = hex[*ep++ & 0xf];\n\tfor (i = len-1; i > 0 ; --i) {\n\t\t*cp++ = ':';\n\t\t*cp++ = hex[*ep >> 4];\n\t\t*cp++ = hex[*ep++ & 0xf];\n\t}\n\t*cp = '\\0';\n\treturn (tp->bs_name);\n}",
        "output": "0",
        "idx": 6581
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    if (mxf->local_tags)\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple primer packs\\n\");\n    av_free(mxf->local_tags);\n    mxf->local_tags_count = 0;\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}",
        "output": "1",
        "idx": 3512
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xar_hash_check(int hash, const void * result, const void * expected)\n{\n    int len;\n\n    if (!result || !expected)\n        return 1;\n    switch (hash) {\n    case XAR_CKSUM_SHA1:\n        len = SHA1_HASH_SIZE;\n        break;\n    case XAR_CKSUM_MD5:\n        len = CLI_HASH_MD5;\n        break;\n    case XAR_CKSUM_OTHER:\n    case XAR_CKSUM_NONE:\n    default:\n        return 1;\n    }\n    return memcmp(result, expected, len);\n}",
        "output": "1",
        "idx": 6730
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC MprKey *mprAddKey(MprHash *hash, cvoid *key, cvoid *ptr)\n{\n    MprKey      *sp, *prevSp;\n    int         index;\n\n    if (hash == 0) {\n        assert(hash);\n        return 0;\n    }\n    lock(hash);\n    if ((sp = lookupHash(&index, &prevSp, hash, key)) != 0) {\n        if (hash->flags & MPR_HASH_UNIQUE) {\n            unlock(hash);\n            return 0;\n        }\n        sp->data = ptr;\n        unlock(hash);\n        return sp;\n    }\n    if ((sp = mprAllocStructNoZero(MprKey)) == 0) {\n        unlock(hash);\n        return 0;\n    }\n    sp->data = ptr;\n    if (!(hash->flags & MPR_HASH_STATIC_KEYS)) {\n        sp->key = dupKey(hash, key);\n    } else {\n        sp->key = (void*) key;\n    }\n    sp->type = 0;\n    sp->bucket = index;\n    sp->next = hash->buckets[index];\n    hash->buckets[index] = sp;\n    hash->length++;\n    unlock(hash);\n    return sp;\n}",
        "output": "1",
        "idx": 5096
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {\n\tRASN1Object *object;\n\tRCMS *container;\n\tif (!buffer || !length) {\n\t\treturn NULL;\n\t}\n\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n\t\treturn NULL;\n\t}\n\tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {\n\t\tr_asn1_free_object (object);\n\t\tfree (container);\n\t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tr_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);\n\tr_asn1_free_object (object);\n\treturn container;\n}",
        "output": "1",
        "idx": 6134
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int inet_sk_rebuild_header(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = (struct rtable *)__sk_dst_check(sk, 0);\n\t__be32 daddr;\n\tint err;\n\n\tif (rt)\n\t\treturn 0;\n\n\tdaddr = inet->inet_daddr;\n\tif (inet->opt && inet->opt->srr)\n\t\tdaddr = inet->opt->faddr;\n\trt = ip_route_output_ports(sock_net(sk), sk, daddr, inet->inet_saddr,\n\t\t\t\t   inet->inet_dport, inet->inet_sport,\n\t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t   sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt)) {\n\t\terr = 0;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t} else {\n\t\terr = PTR_ERR(rt);\n\n\t\tsk->sk_route_caps = 0;\n\t\tif (!sysctl_ip_dynaddr ||\n\t\t    sk->sk_state != TCP_SYN_SENT ||\n\t\t    (sk->sk_userlocks & SOCK_BINDADDR_LOCK) ||\n\t\t    (err = inet_sk_reselect_saddr(sk)) != 0)\n\t\t\tsk->sk_err_soft = -err;\n\t}\n\n\treturn err;\n}",
        "output": "1",
        "idx": 324
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "f_pyxeval(typval_T *argvars, typval_T *rettv)\n{\n    if (check_restricted() || check_secure())\n\treturn;\n\n# if defined(FEAT_PYTHON) && defined(FEAT_PYTHON3)\n    init_pyxversion();\n    if (p_pyx == 2)\n\tf_pyeval(argvars, rettv);\n    else\n\tf_py3eval(argvars, rettv);\n# elif defined(FEAT_PYTHON)\n    f_pyeval(argvars, rettv);\n# elif defined(FEAT_PYTHON3)\n    f_py3eval(argvars, rettv);\n# endif\n}",
        "output": "0",
        "idx": 8167
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\n\tStream_Read_UINT16(s, fields->Len); \n\tStream_Read_UINT16(s, fields->MaxLen); \n\tStream_Read_UINT32(s, fields->BufferOffset); \n\treturn 1;\n}",
        "output": "1",
        "idx": 4206
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,\n\t\t\t     char *args, int lsm_rule, int audit_type)\n{\n\tint result;\n\n\tif (entry->lsm[lsm_rule].rule)\n\t\treturn -EINVAL;\n\n\tentry->lsm[lsm_rule].type = audit_type;\n\tresult = security_filter_rule_init(entry->lsm[lsm_rule].type,\n\t\t\t\t\t   Audit_equal, args,\n\t\t\t\t\t   &entry->lsm[lsm_rule].rule);\n\tif (!entry->lsm[lsm_rule].rule)\n\t\treturn -EINVAL;\n\treturn result;\n}",
        "output": "0",
        "idx": 357
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ras_validate(jas_stream_t *in)\n{\n\tjas_uchar buf[RAS_MAGICLEN];\n\tint i;\n\tint n;\n\tuint_fast32_t magic;\n\n\tassert(JAS_STREAM_MAXPUTBACK >= RAS_MAGICLEN);\n\n\tif ((n = jas_stream_read(in, buf, RAS_MAGICLEN)) < 0) {\n\t\treturn -1;\n\t}\n\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (n < RAS_MAGICLEN) {\n\t\treturn -1;\n\t}\n\n\tmagic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |\n\t  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |\n\t  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |\n\t  buf[3];\n\n\tif (magic != RAS_MAGIC) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 7589
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "evtchn_port_t evtchn_from_irq(unsigned irq)\n{\n\tif (WARN(irq >= nr_irqs, \"Invalid irq %d!\\n\", irq))\n\t\treturn 0;\n\n\treturn info_for_irq(irq)->evtchn;\n}",
        "output": "1",
        "idx": 1886
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *enl_ipc_get(const char *msg_data)\n{\n\n\tstatic char *message = NULL;\n\tstatic unsigned short len = 0;\n\tchar buff[13], *ret_msg = NULL;\n\tregister unsigned char i;\n\tunsigned char blen;\n\n\tif (msg_data == IPC_TIMEOUT) {\n\t\treturn(IPC_TIMEOUT);\n\t}\n\tfor (i = 0; i < 12; i++) {\n\t\tbuff[i] = msg_data[i];\n\t}\n\tbuff[12] = 0;\n\tblen = strlen(buff);\n\tif (message != NULL) {\n\t\tlen += blen;\n\t\tmessage = (char *) erealloc(message, len + 1);\n\t\tstrcat(message, buff);\n\t} else {\n\t\tlen = blen;\n\t\tmessage = (char *) emalloc(len + 1);\n\t\tstrcpy(message, buff);\n\t}\n\tif (blen < 12) {\n\t\tret_msg = message;\n\t\tmessage = NULL;\n\t\tD((\"Received complete reply:  \\\"%s\\\"\\n\", ret_msg));\n\t}\n\treturn(ret_msg);\n}",
        "output": "1",
        "idx": 6638
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "read_old_length(cdk_stream_t inp, int ctb, size_t * r_len, size_t * r_size)\n{\n\tint llen = ctb & 0x03;\n\tint c;\n\n\tif (llen == 0) {\n\t\tc = cdk_stream_getc(inp);\n\t\tif (c == EOF)\n\t\t\tgoto fail;\n\n\t\t*r_len = c;\n\t\t(*r_size)++;\n\t} else if (llen == 1) {\n\t\t*r_len = read_16(inp);\n\t\tif (*r_len == (u16)-1)\n\t\t\tgoto fail;\n\t\t(*r_size) += 2;\n\t} else if (llen == 2) {\n\t\t*r_len = read_32(inp);\n\t\tif (*r_len == (u32)-1) {\n\t\t\tgoto fail;\n\t\t}\n\n\t\t(*r_size) += 4;\n\t} else {\n fail:\n\t\t*r_len = 0;\n\t\t*r_size = 0;\n\t}\n}",
        "output": "0",
        "idx": 6487
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *hashtable_get(hashtable_t *hashtable, const char *key)\n{\n    pair_t *pair;\n    size_t hash;\n    bucket_t *bucket;\n\n    hash = hash_str(key);\n    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return NULL;\n\n    return pair->value;\n}",
        "output": "1",
        "idx": 4314
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\tuint8_t *buffer;\n\tuint8_t value;\n\n\tbuffer = kmalloc(1, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t0, reg, buffer, 1, 1000);\n\n\tif (ret >= 0) {\n\t\tvalue = buffer[0];\n\t\tkfree(buffer);\n\t\treturn value;\n\t} else {\n\t\tkfree(buffer);\n\t\treturn ret;\n\t}\n}",
        "output": "0",
        "idx": 2075
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iakerb_gss_wrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                    int conf_req_flag, gss_qop_t qop_req, int *conf_state,\n                    gss_iov_buffer_desc *iov, int iov_count)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_wrap_iov(minor_status, ctx->gssc, conf_req_flag, qop_req,\n                             conf_state, iov, iov_count);\n}",
        "output": "0",
        "idx": 169
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vgacon_switch(struct vc_data *c)\n{\n\tint x = c->vc_cols * VGA_FONTWIDTH;\n\tint y = c->vc_rows * c->vc_font.height;\n\tint rows = screen_info.orig_video_lines * vga_default_font_height/\n\t\tc->vc_font.height;\n\tvga_video_num_columns = c->vc_cols;\n\tvga_video_num_lines = c->vc_rows;\n\n\n\tif (!vga_is_gfx) {\n\t\tscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ?\n\t\t\t\tvga_vram_size : c->vc_screenbuf_size);\n\n\t\tif ((vgacon_xres != x || vgacon_yres != y) &&\n\t\t    (!(vga_video_num_columns % 2) &&\n\t\t     vga_video_num_columns <= screen_info.orig_video_cols &&\n\t\t     vga_video_num_lines <= rows))\n\t\t\tvgacon_doresize(c, c->vc_cols, c->vc_rows);\n\t}\n\n\tvgacon_scrollback_switch(c->vc_num);\n\treturn 0;\t\t\n}",
        "output": "1",
        "idx": 1868
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned long mb2_cache_count(struct shrinker *shrink,\n\t\t\t\t     struct shrink_control *sc)\n{\n\tstruct mb2_cache *cache = container_of(shrink, struct mb2_cache,\n\t\t\t\t\t       c_shrink);\n\n\treturn cache->c_entry_count;\n}",
        "output": "0",
        "idx": 1603
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_timer_user_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tint err;\n\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->tread_sem);\n\ttu->ticks = 1;\n\ttu->queue_size = 128;\n\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;\n}",
        "output": "1",
        "idx": 1040
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  \n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    if (name != NULL)\n    {\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}",
        "output": "1",
        "idx": 5756
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_jpeg2000_cleanup(Jpeg2000Component *comp, Jpeg2000CodingStyle *codsty)\n{\n    int reslevelno, bandno, precno;\n    for (reslevelno = 0;\n         comp->reslevel && reslevelno < codsty->nreslevels;\n         reslevelno++) {\n        Jpeg2000ResLevel *reslevel = comp->reslevel + reslevelno;\n\n        for (bandno = 0; bandno < reslevel->nbands; bandno++) {\n            Jpeg2000Band *band = reslevel->band + bandno;\n            for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++) {\n                if (band->prec) {\n                    Jpeg2000Prec *prec = band->prec + precno;\n                    av_freep(&prec->zerobits);\n                    av_freep(&prec->cblkincl);\n                    av_freep(&prec->cblk);\n                }\n            }\n\n            av_freep(&band->prec);\n        }\n        av_freep(&reslevel->band);\n    }\n\n    ff_dwt_destroy(&comp->dwt);\n    av_freep(&comp->reslevel);\n    av_freep(&comp->i_data);\n    av_freep(&comp->f_data);\n}",
        "output": "0",
        "idx": 4955
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "usm_free_usmStateReference(void *old)\n{\n    struct usmStateReference *old_ref = (struct usmStateReference *) old;\n\n    if (old_ref) {\n\n        if (old_ref->usr_name_length)\n            SNMP_FREE(old_ref->usr_name);\n        if (old_ref->usr_engine_id_length)\n            SNMP_FREE(old_ref->usr_engine_id);\n        if (old_ref->usr_auth_protocol_length)\n            SNMP_FREE(old_ref->usr_auth_protocol);\n        if (old_ref->usr_priv_protocol_length)\n            SNMP_FREE(old_ref->usr_priv_protocol);\n\n        if (old_ref->usr_auth_key_length && old_ref->usr_auth_key) {\n            SNMP_ZERO(old_ref->usr_auth_key, old_ref->usr_auth_key_length);\n            SNMP_FREE(old_ref->usr_auth_key);\n        }\n        if (old_ref->usr_priv_key_length && old_ref->usr_priv_key) {\n            SNMP_ZERO(old_ref->usr_priv_key, old_ref->usr_priv_key_length);\n            SNMP_FREE(old_ref->usr_priv_key);\n        }\n\n        SNMP_ZERO(old_ref, sizeof(*old_ref));\n        SNMP_FREE(old_ref);\n\n    }\n\n}                               ",
        "output": "1",
        "idx": 7816
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void array_cleanup( char* arr[] , int arr_size)\n{\n\tint i=0;\n\tfor( i=0; i< arr_size; i++ ){ \n\t\tif( arr[i*2] ){\n\t\t\tefree( arr[i*2]);\n\t\t}\n\t}\n\tefree(arr);\n}",
        "output": "1",
        "idx": 3856
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n\t\t\t   gss_ctx_id_t context_handle,\n\t\t\t   int conf_req_flag,\n\t\t\t   gss_qop_t qop_req,\n\t\t\t   int *conf_state,\n\t\t\t   gss_iov_buffer_desc *iov,\n\t\t\t   int iov_count)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_NO_CONTEXT);\n\n\tret = gss_wrap_iov_length(minor_status,\n\t\t\t\t  sc->ctx_handle,\n\t\t\t\t  conf_req_flag,\n\t\t\t\t  qop_req,\n\t\t\t\t  conf_state,\n\t\t\t\t  iov,\n\t\t\t\t  iov_count);\n\treturn (ret);\n}",
        "output": "0",
        "idx": 77
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "win_alloc_lines(win_T *wp)\n{\n    wp->w_lines_valid = 0;\n    wp->w_lines = ALLOC_CLEAR_MULT(wline_T, Rows);\n    if (wp->w_lines == NULL)\n\treturn FAIL;\n    return OK;\n}",
        "output": "0",
        "idx": 7963
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "videobuf_vm_close(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tstruct videobuf_queue *q = map->q;\n\tint i;\n\n\tdprintk(2,\"vm_close %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\n\tmap->count--;\n\tif (0 == map->count) {\n\t\tdprintk(1,\"munmap %p q=%p\\n\",map,q);\n\t\tmutex_lock(&q->lock);\n\t\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\t\tif (NULL == q->bufs[i])\n\t\t\t\tcontinue;\n\n\t\t\tif (q->bufs[i]->map != map)\n\t\t\t\tcontinue;\n\n\t\t\tq->ops->buf_release(q,q->bufs[i]);\n\n\t\t\tq->bufs[i]->map   = NULL;\n\t\t\tq->bufs[i]->baddr = 0;\n\t\t}\n\t\tmutex_unlock(&q->lock);\n\t\tkfree(map);\n\t}\n\treturn;\n}",
        "output": "1",
        "idx": 2076
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tiocgetd(struct tty_struct *tty, int __user *p)\n{\n\tstruct tty_ldisc *ld;\n\tint ret;\n\n\tld = tty_ldisc_ref_wait(tty);\n\tret = put_user(ld->ops->num, p);\n\ttty_ldisc_deref(ld);\n\treturn ret;\n}",
        "output": "0",
        "idx": 1571
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ram_block_add(struct uc_struct *uc, RAMBlock *new_block)\n{\n    RAMBlock *block;\n    RAMBlock *last_block = NULL;\n\n    new_block->offset = find_ram_offset(uc, new_block->max_length);\n\n    if (!new_block->host) {\n        new_block->host = phys_mem_alloc(uc, new_block->max_length,\n                &new_block->mr->align);\n        if (!new_block->host) {\n            return;\n        }\n    }\n\n    RAMBLOCK_FOREACH(block) {\n        last_block = block;\n        if (block->max_length < new_block->max_length) {\n            break;\n        }\n    }\n    if (block) {\n        QLIST_INSERT_BEFORE(block, new_block, next);\n    } else if (last_block) {\n        QLIST_INSERT_AFTER(last_block, new_block, next);\n    } else { \n        QLIST_INSERT_HEAD(&uc->ram_list.blocks, new_block, next);\n    }\n    uc->ram_list.mru_block = NULL;\n\n\n    cpu_physical_memory_set_dirty_range(new_block->offset,\n                                        new_block->used_length,\n                                        DIRTY_CLIENTS_ALL);\n\n}",
        "output": "1",
        "idx": 8746
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init big_key_crypto_init(void)\n{\n\tint ret = -EINVAL;\n\n\tbig_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);\n\tif (IS_ERR(big_key_rng)) {\n\t\tbig_key_rng = NULL;\n\t\treturn -EFAULT;\n\t}\n\n\tret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));\n\tif (ret)\n\t\tgoto error;\n\n\tbig_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,\n\t\t\t\t\t\t 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(big_key_skcipher)) {\n\t\tbig_key_skcipher = NULL;\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tcrypto_free_rng(big_key_rng);\n\tbig_key_rng = NULL;\n\treturn ret;\n}",
        "output": "1",
        "idx": 1354
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv)\n{\n\tstruct nci_dev *ndev = priv->ndev;\n\n\tnci_unregister_device(ndev);\n\tif (priv->ndev->nfc_dev->fw_download_in_progress)\n\t\tnfcmrvl_fw_dnld_abort(priv);\n\n\tnfcmrvl_fw_dnld_deinit(priv);\n\n\tif (gpio_is_valid(priv->config.reset_n_io))\n\t\tgpio_free(priv->config.reset_n_io);\n\n\tnci_free_device(ndev);\n\tkfree(priv);\n}",
        "output": "0",
        "idx": 2935
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "flac_read_loop (SF_PRIVATE *psf, unsigned len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\n\tpflac->pos = 0 ;\n\tpflac->len = len ;\n\tpflac->remain = len ;\n\n\tif (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)\n\t\tflac_buffer_copy (psf) ;\n\n\twhile (pflac->pos < pflac->len)\n\t{\tif (FLAC__stream_decoder_process_single (pflac->fsd) == 0)\n\t\t\tbreak ;\n\t\tif (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)\n\t\t\tbreak ;\n\t\t} ;\n\n\tpflac->ptr = NULL ;\n\n\treturn pflac->pos ;\n} ",
        "output": "1",
        "idx": 4908
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned paravirt_patch_call(void *insnbuf,\n\t\t\t     const void *target, u16 tgt_clobbers,\n\t\t\t     unsigned long addr, u16 site_clobbers,\n\t\t\t     unsigned len)\n{\n\tstruct branch *b = insnbuf;\n\tunsigned long delta = (unsigned long)target - (addr+5);\n\n\tif (len < 5) {\n#ifdef CONFIG_RETPOLINE\n\t\tWARN_ONCE(\"Failing to patch indirect CALL in %ps\\n\", (void *)addr);\n#endif\n\t\treturn len;\t\n\t}\n\n\tb->opcode = 0xe8; \n\tb->delta = delta;\n\tBUILD_BUG_ON(sizeof(*b) != 5);\n\n\treturn 5;\n}",
        "output": "0",
        "idx": 4143
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void buf_to_pages(const void *buf, size_t buflen,\n\t\tstruct page **pages, unsigned int *pgbase)\n{\n\tconst void *p = buf;\n\n\t*pgbase = offset_in_page(buf);\n\tp -= *pgbase;\n\twhile (p < buf + buflen) {\n\t\t*(pages++) = virt_to_page(p);\n\t\tp += PAGE_CACHE_SIZE;\n\t}\n}",
        "output": "1",
        "idx": 654
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool r_bin_mdmp_init_directory(struct r_bin_mdmp_obj *obj) {\n\tint i;\n\tut8 *directory_base;\n\tstruct minidump_directory *entry;\n\n\tdirectory_base = obj->b->buf + obj->hdr->stream_directory_rva;\n\n\tsdb_num_set (obj->kv, \"mdmp_directory.offset\",\n\t\t\tobj->hdr->stream_directory_rva, 0);\n\tsdb_set (obj->kv, \"mdmp_directory.format\", \"[4]E? \"\n\t\t\t\"(mdmp_stream_type)StreamType \"\n\t\t\t\"(mdmp_location_descriptor)Location\", 0);\n\n\tfor (i = 0; i < (int)obj->hdr->number_of_streams; i++) {\n\t\tentry = (struct minidump_directory *)(directory_base + (i * sizeof (struct minidump_directory)));\n\t\tr_bin_mdmp_init_directory_entry (obj, entry);\n\t}\n\n\treturn true;\n}",
        "output": "1",
        "idx": 6556
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void async_polkit_query_free(AsyncPolkitQuery *q) {\n        if (!q)\n                return;\n\n        sd_bus_slot_unref(q->slot);\n\n        if (q->registry && q->request)\n                hashmap_remove(q->registry, q->request);\n\n        sd_bus_message_unref(q->request);\n        sd_bus_message_unref(q->reply);\n\n        free(q->action);\n        strv_free(q->details);\n\n        sd_event_source_disable_unref(q->defer_event_source);\n        free(q);\n}",
        "output": "0",
        "idx": 7699
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tktime_t now, remaining, iv;\n\tstruct timespec64 ts64;\n\tbool sig_none;\n\n\tsig_none = timr->it_sigev_notify == SIGEV_NONE;\n\tiv = timr->it_interval;\n\n\tif (iv) {\n\t\tcur_setting->it_interval = ktime_to_timespec64(iv);\n\t} else if (!timr->it_active) {\n\t\tif (!sig_none)\n\t\t\treturn;\n\t}\n\n\tkc->clock_get(timr->it_clock, &ts64);\n\tnow = timespec64_to_ktime(ts64);\n\n\tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))\n\t\ttimr->it_overrun += kc->timer_forward(timr, now);\n\n\tremaining = kc->timer_remaining(timr, now);\n\tif (remaining <= 0) {\n\t\tif (!sig_none)\n\t\t\tcur_setting->it_value.tv_nsec = 1;\n\t} else {\n\t\tcur_setting->it_value = ktime_to_timespec64(remaining);\n\t}\n}",
        "output": "0",
        "idx": 2595
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int perf_swevent_init(struct perf_event *event)\n{\n\tint event_id = event->attr.config;\n\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (event_id) {\n\tcase PERF_COUNT_SW_CPU_CLOCK:\n\tcase PERF_COUNT_SW_TASK_CLOCK:\n\t\treturn -ENOENT;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (event_id >= PERF_COUNT_SW_MAX)\n\t\treturn -ENOENT;\n\n\tif (!event->parent) {\n\t\tint err;\n\n\t\terr = swevent_hlist_get(event);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tstatic_key_slow_inc(&perf_swevent_enabled[event_id]);\n\t\tevent->destroy = sw_perf_event_destroy;\n\t}\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 904
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_log_throttle(struct perf_event *event, int enable)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint ret;\n\n\tstruct {\n\t\tstruct perf_event_header\theader;\n\t\tu64\t\t\t\ttime;\n\t\tu64\t\t\t\tid;\n\t\tu64\t\t\t\tstream_id;\n\t} throttle_event = {\n\t\t.header = {\n\t\t\t.type = PERF_RECORD_THROTTLE,\n\t\t\t.misc = 0,\n\t\t\t.size = sizeof(throttle_event),\n\t\t},\n\t\t.time\t\t= perf_clock(),\n\t\t.id\t\t= primary_event_id(event),\n\t\t.stream_id\t= event->id,\n\t};\n\n\tif (enable)\n\t\tthrottle_event.header.type = PERF_RECORD_UNTHROTTLE;\n\n\tperf_event_header__init_id(&throttle_event.header, &sample, event);\n\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tthrottle_event.header.size, 0);\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, throttle_event);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\tperf_output_end(&handle);\n}",
        "output": "0",
        "idx": 683
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_compress_check_input(struct snd_compr_params *params)\n{\n\tif (params->buffer.fragment_size == 0 ||\n\t    params->buffer.fragments > INT_MAX / params->buffer.fragment_size)\n\t\treturn -EINVAL;\n\n\tif (params->codec.id == 0 || params->codec.id > SND_AUDIOCODEC_MAX)\n\t\treturn -EINVAL;\n\n\tif (params->codec.ch_in == 0 || params->codec.ch_out == 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 3611
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nv_gotofile(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    linenr_T\tlnum = -1;\n\n    if (text_locked())\n    {\n\tclearopbeep(cap->oap);\n\ttext_locked_msg();\n\treturn;\n    }\n    if (curbuf_locked())\n    {\n\tclearop(cap->oap);\n\treturn;\n    }\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n\n    ptr = grab_file_name(cap->count1, &lnum);\n\n    if (ptr != NULL)\n    {\n\tif (curbufIsChanged() && curbuf->b_nwindows <= 1 && !buf_hide(curbuf))\n\t    (void)autowrite(curbuf, FALSE);\n\tsetpcmark();\n\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LAST,\n\t\t\t\tbuf_hide(curbuf) ? ECMD_HIDE : 0, curwin) == OK\n\t\t&& cap->nchar == 'F' && lnum >= 0)\n\t{\n\t    curwin->w_cursor.lnum = lnum;\n\t    check_cursor_lnum();\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n\tvim_free(ptr);\n    }\n    else\n\tclearop(cap->oap);\n}",
        "output": "1",
        "idx": 5764
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "t1mac_output_ascii(char *s, int len)\n{\n  if (blocktyp == POST_BINARY) {\n    output_current_post();\n    blocktyp = POST_ASCII;\n  }\n  if (len > 0 && s[len-1] == '\\n')\n    s[len-1] = '\\r';\n  t1mac_output_data((byte *)s, len);\n  if (strncmp(s, \"/FontName\", 9) == 0) {\n    for (s += 9; isspace((unsigned char) *s); s++)\n        ;\n    if (*s == '/') {\n      const char *t = ++s;\n      while (*t && !isspace((unsigned char) *t)) t++;\n      free(font_name);\n      font_name = (char *)malloc(t - s + 1);\n      memcpy(font_name, s, t - s);\n      font_name[t - s] = 0;\n    }\n  }\n}",
        "output": "0",
        "idx": 7411
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n    const void *p, size_t tail, int line)\n{\n\tconst char *b = (const char *)sst->sst_tab;\n\tconst char *e = ((const char *)p) + tail;\n\tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?\n\t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);\n\t(void)&line;\n\tif (e >= b && (size_t)(e - b) <= ss * sst->sst_len)\n\t\treturn 0;\n\tDPRINTF((\"%d: offset begin %p < end %p || %\" SIZE_T_FORMAT \"u\"\n\t    \" > %\" SIZE_T_FORMAT \"u [%\" SIZE_T_FORMAT \"u %\"\n\t    SIZE_T_FORMAT \"u]\\n\", line, b, e, (size_t)(e - b),\n\t    ss * sst->sst_len, ss, sst->sst_len));\n\terrno = EFTYPE;\n\treturn -1;\n}",
        "output": "0",
        "idx": 6095
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void free_huge_page(struct page *page)\n{\n\tstruct hstate *h = page_hstate(page);\n\tint nid = page_to_nid(page);\n\tstruct hugepage_subpool *spool =\n\t\t(struct hugepage_subpool *)page_private(page);\n\n\tset_page_private(page, 0);\n\tpage->mapping = NULL;\n\tBUG_ON(page_count(page));\n\tBUG_ON(page_mapcount(page));\n\tINIT_LIST_HEAD(&page->lru);\n\n\tspin_lock(&hugetlb_lock);\n\tif (h->surplus_huge_pages_node[nid] && huge_page_order(h) < MAX_ORDER) {\n\t\tupdate_and_free_page(h, page);\n\t\th->surplus_huge_pages--;\n\t\th->surplus_huge_pages_node[nid]--;\n\t} else {\n\t\tenqueue_huge_page(h, page);\n\t}\n\tspin_unlock(&hugetlb_lock);\n\thugepage_subpool_put_pages(spool, 1);\n}",
        "output": "0",
        "idx": 899
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ext2_put_super (struct super_block * sb)\n{\n\tint db_count;\n\tint i;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\n\tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\n\text2_xattr_put_super(sb);\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tstruct ext2_super_block *es = sbi->s_es;\n\n\t\tspin_lock(&sbi->s_lock);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\tdb_count = sbi->s_gdb_count;\n\tfor (i = 0; i < db_count; i++)\n\t\tif (sbi->s_group_desc[i])\n\t\t\tbrelse (sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\n\tkfree(sbi->s_debts);\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tbrelse (sbi->s_sbh);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n}",
        "output": "1",
        "idx": 1096
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool check_underflow(const struct ipt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\n\tif (!unconditional(&e->ip))\n\t\treturn false;\n\tt = ipt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}",
        "output": "1",
        "idx": 1188
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "n_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n    trigger_modechanged();\n\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n\n    setmouse();\n#ifdef FEAT_CONCEAL\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t\n#ifdef FEAT_CLIPBOARD\n    clip_star.vmode = NUL;\n#endif\n\n    if (curwin->w_redr_type < INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}",
        "output": "1",
        "idx": 5692
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rose_start_hbtimer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tdel_timer(&rose->timer);\n\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->hb;\n\n\tadd_timer(&rose->timer);\n}",
        "output": "1",
        "idx": 2044
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ga_concat_shorten_esc(garray_T *gap, char_u *str)\n{\n    char_u  *p;\n    char_u  *s;\n    int\t    c;\n    int\t    clen;\n    char_u  buf[NUMBUFLEN];\n    int\t    same_len;\n\n    if (str == NULL)\n    {\n\tga_concat(gap, (char_u *)\"NULL\");\n\treturn;\n    }\n\n    for (p = str; *p != NUL; ++p)\n    {\n\tsame_len = 1;\n\ts = p;\n\tc = mb_ptr2char_adv(&s);\n\tclen = s - p;\n\twhile (*s != NUL && c == mb_ptr2char(s))\n\t{\n\t    ++same_len;\n\t    s += clen;\n\t}\n\tif (same_len > 20)\n\t{\n\t    ga_concat(gap, (char_u *)\"\\\\[\");\n\t    ga_concat_esc(gap, p, clen);\n\t    ga_concat(gap, (char_u *)\" occurs \");\n\t    vim_snprintf((char *)buf, NUMBUFLEN, \"%d\", same_len);\n\t    ga_concat(gap, buf);\n\t    ga_concat(gap, (char_u *)\" times]\");\n\t    p = s - 1;\n\t}\n\telse\n\t    ga_concat_esc(gap, p, clen);\n    }\n}",
        "output": "1",
        "idx": 5742
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len,\n\t\t\t    int flags)\n{\n\tint err;\n\tstruct sk_buff *skb;\n\tstruct sock *sk = sock->sk;\n\n\terr = -EIO;\n\tif (sk->sk_state & PPPOX_BOUND)\n\t\tgoto end;\n\n\tmsg->msg_namelen = 0;\n\n\terr = 0;\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto end;\n\n\tif (len > skb->len)\n\t\tlen = skb->len;\n\telse if (len < skb->len)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, len);\n\tif (likely(err == 0))\n\t\terr = len;\n\n\tkfree_skb(skb);\nend:\n\treturn err;\n}",
        "output": "1",
        "idx": 2452
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n{\n\tunsigned char *buf;\n\n\tassert(bufsize >= 0);\n\n\tJAS_DBGLOG(100, (\"mem_resize(%p, %d)\\n\", m, bufsize));\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n\t  bufsize) {\n\t\tJAS_DBGLOG(100, (\"mem_resize realloc failed\\n\"));\n\t\treturn -1;\n\t}\n\tJAS_DBGLOG(100, (\"mem_resize realloc succeeded\\n\"));\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}",
        "output": "1",
        "idx": 5368
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_Unpickler_MemoPut(UnpicklerObject *self, Py_ssize_t idx, PyObject *value)\n{\n    PyObject *old_item;\n\n    if (idx >= self->memo_size) {\n        if (_Unpickler_ResizeMemoList(self, idx * 2) < 0)\n            return -1;\n        assert(idx < self->memo_size);\n    }\n    Py_INCREF(value);\n    old_item = self->memo[idx];\n    self->memo[idx] = value;\n    if (old_item != NULL) {\n        Py_DECREF(old_item);\n    }\n    else {\n        self->memo_len++;\n    }\n    return 0;\n}",
        "output": "1",
        "idx": 7142
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int f2fs_set_data_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\n\ttrace_f2fs_set_page_dirty(page, DATA);\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\n\tif (f2fs_is_atomic_file(inode) && !f2fs_is_commit_atomic_write(inode)) {\n\t\tif (!IS_ATOMIC_WRITTEN_PAGE(page)) {\n\t\t\tf2fs_register_inmem_page(inode, page);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (!PageDirty(page)) {\n\t\t__set_page_dirty_nobuffers(page);\n\t\tf2fs_update_dirty_page(inode, page);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 3206
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "beep_print(netdissect_options *ndo, const u_char *bp, u_int length)\n{\n\n\tif (l_strnstart(ndo, \"MSG\", 4, (const char *)bp, length)) \n\t\tND_PRINT((ndo, \" BEEP MSG\"));\n\telse if (l_strnstart(ndo, \"RPY \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP RPY\"));\n\telse if (l_strnstart(ndo, \"ERR \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP ERR\"));\n\telse if (l_strnstart(ndo, \"ANS \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP ANS\"));\n\telse if (l_strnstart(ndo, \"NUL \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP NUL\"));\n\telse if (l_strnstart(ndo, \"SEQ \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP SEQ\"));\n\telse if (l_strnstart(ndo, \"END\", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP END\"));\n\telse\n\t\tND_PRINT((ndo, \" BEEP (payload or undecoded)\"));\n}",
        "output": "0",
        "idx": 6685
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sraSpanInsertBefore(sraSpan *newspan, sraSpan *before) {\n  newspan->_next = before;\n  newspan->_prev = before->_prev;\n  before->_prev->_next = newspan;\n  before->_prev = newspan;\n}",
        "output": "1",
        "idx": 6356
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void lpc546xxEthEnableIrq(NetInterface *interface)\n{\n   NVIC_EnableIRQ(ETHERNET_IRQn);\n\n   if(interface->phyDriver != NULL)\n   {\n      interface->phyDriver->enableIrq(interface);\n   }\n   else if(interface->switchDriver != NULL)\n   {\n      interface->switchDriver->enableIrq(interface);\n   }\n   else\n   {\n   }\n}",
        "output": "1",
        "idx": 8600
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\tsecurity_key_free(key);\n\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\n\t\tif (key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\n\t\tkey_user_put(key->user);\n\n\t\tkfree(key->description);\n\n#ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}",
        "output": "0",
        "idx": 3803
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vfs_open(const struct path *path, struct file *file,\n\t     const struct cred *cred)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = dentry->d_inode;\n\n\tfile->f_path = *path;\n\tif (dentry->d_flags & DCACHE_OP_SELECT_INODE) {\n\t\tinode = dentry->d_op->d_select_inode(dentry, file->f_flags);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\t}\n\n\treturn do_dentry_open(file, inode, NULL, cred);\n}",
        "output": "1",
        "idx": 1264
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void * CAPSTONE_API cs_winkernel_malloc(size_t size)\n{\n\tNT_ASSERT(size);\n\n#pragma prefast(suppress : 30030)\t\t\n\tCS_WINKERNEL_MEMBLOCK *block = (CS_WINKERNEL_MEMBLOCK *)ExAllocatePoolWithTag(\n\t\t\tNonPagedPool, size + sizeof(CS_WINKERNEL_MEMBLOCK), CS_WINKERNEL_POOL_TAG);\n\tif (!block) {\n\t\treturn NULL;\n\t}\n\tblock->size = size;\n\n\treturn block->data;\n}",
        "output": "1",
        "idx": 6042
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_be_3byte (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 3)\n\t{\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} ",
        "output": "1",
        "idx": 4926
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error_t httpClientSetUri(HttpClientContext *context, const char_t *uri)\n{\n   size_t m;\n   size_t n;\n   char_t *p;\n   char_t *q;\n\n   if(context == NULL || uri == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   if(uri[0] == '\\0')\n      return ERROR_INVALID_PARAMETER;\n\n   if(context->requestState != HTTP_REQ_STATE_FORMAT_HEADER)\n      return ERROR_WRONG_STATE;\n\n   if(context->bufferLen > HTTP_CLIENT_BUFFER_SIZE)\n      return ERROR_INVALID_SYNTAX;\n\n   context->buffer[context->bufferLen] = '\\0';\n\n   p = strchr(context->buffer, ' ');\n   if(p == NULL)\n      return ERROR_INVALID_SYNTAX;\n\n   p++;\n\n   q = strpbrk(p, \" ?\");\n   if(q == NULL)\n      return ERROR_INVALID_SYNTAX;\n\n   m = q - p;\n   n = osStrlen(uri);\n\n   if((context->bufferLen + n - m) > HTTP_CLIENT_BUFFER_SIZE)\n      return ERROR_BUFFER_OVERFLOW;\n\n   osMemmove(p + n, q, context->buffer + context->bufferLen + 1 - q);\n   osStrncpy(p, uri, n);\n\n   context->bufferLen = context->bufferLen + n - m;\n\n   return NO_ERROR;\n}",
        "output": "1",
        "idx": 8632
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,\n\t\t\t    int *addr_len, int peer)\n{\n\tstruct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct hci_dev *hdev = hci_pi(sk)->hdev;\n\n\tBT_DBG(\"sock %p sk %p\", sock, sk);\n\n\tif (!hdev)\n\t\treturn -EBADFD;\n\n\tlock_sock(sk);\n\n\t*addr_len = sizeof(*haddr);\n\thaddr->hci_family = AF_BLUETOOTH;\n\thaddr->hci_dev    = hdev->id;\n\thaddr->hci_channel= 0;\n\n\trelease_sock(sk);\n\treturn 0;\n}",
        "output": "0",
        "idx": 1001
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *get_header(FILE *fp)\n{\n    long start;\n\n    char *header;\n\n    header = calloc(1, 1024);\n    \n    start = ftell(fp);\n    fseek(fp, 0, SEEK_SET);\n    SAFE_E(fread(header, 1, 1023, fp), 1023, \"Failed to load PDF header.\\n\");\n    fseek(fp, start, SEEK_SET);\n    \n    return header;\n}",
        "output": "1",
        "idx": 7472
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct hugepage_subpool *subpool_inode(struct inode *inode)\n{\n\treturn HUGETLBFS_SB(inode->i_sb)->spool;\n}",
        "output": "0",
        "idx": 897
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CURLcode Curl_auth_create_plain_message(struct Curl_easy *data,\n                                        const char *userp,\n                                        const char *passwdp,\n                                        char **outptr, size_t *outlen)\n{\n  CURLcode result;\n  char *plainauth;\n  size_t ulen;\n  size_t plen;\n  size_t plainlen;\n\n  *outlen = 0;\n  *outptr = NULL;\n  ulen = strlen(userp);\n  plen = strlen(passwdp);\n\n  if((ulen > SIZE_T_MAX/4) || (plen > (SIZE_T_MAX/2 - 2)))\n    return CURLE_OUT_OF_MEMORY;\n  plainlen = 2 * ulen + plen + 2;\n\n  plainauth = malloc(plainlen);\n  if(!plainauth)\n    return CURLE_OUT_OF_MEMORY;\n\n  memcpy(plainauth, userp, ulen);\n  plainauth[ulen] = '\\0';\n  memcpy(plainauth + ulen + 1, userp, ulen);\n  plainauth[2 * ulen + 1] = '\\0';\n  memcpy(plainauth + 2 * ulen + 2, passwdp, plen);\n\n  result = Curl_base64_encode(data, plainauth, plainlen, outptr, outlen);\n  free(plainauth);\n\n  return result;\n}",
        "output": "0",
        "idx": 8467
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool can_follow_write_pte(pte_t pte, unsigned int flags)\n{\n\treturn pte_write(pte) ||\n\t\t((flags & FOLL_FORCE) && (flags & FOLL_COW) && pte_dirty(pte));\n}",
        "output": "0",
        "idx": 1979
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_read (SF_PRIVATE *psf, void *ptr, int bytes)\n{\tint count = 0 ;\n\n\tif (psf->header.indx + bytes >= psf->header.len && psf_bump_header_allocation (psf, bytes))\n\t\treturn count ;\n\n\tif (psf->header.indx + bytes > psf->header.end)\n\t{\tcount = psf_fread (psf->header.ptr + psf->header.end, 1, bytes - (psf->header.end - psf->header.indx), psf) ;\n\t\tif (count != bytes - (int) (psf->header.end - psf->header.indx))\n\t\t{\tpsf_log_printf (psf, \"Error : psf_fread returned short count.\\n\") ;\n\t\t\treturn count ;\n\t\t\t} ;\n\t\tpsf->header.end += count ;\n\t\t} ;\n\n\tmemcpy (ptr, psf->header.ptr + psf->header.indx, bytes) ;\n\tpsf->header.indx += bytes ;\n\n\treturn bytes ;\n} ",
        "output": "0",
        "idx": 6879
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseServerAccount(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    cchar       *value;\n\n    if ((value = mprGetJson(prop, \"user\")) != 0) {\n        if (!smatch(value, \"_unchanged_\") && !mprGetDebugMode()) {\n            httpSetGroupAccount(value);\n        }\n    }\n    if ((value = mprGetJson(prop, \"user\")) != 0) {\n        if (!smatch(value, \"_unchanged_\") && !mprGetDebugMode()) {\n            httpSetUserAccount(value);\n        }\n    }\n}",
        "output": "1",
        "idx": 5036
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Jsi_RC jsi_ArraySizeOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    int i = Jsi_ObjGetLength(interp, _this->d.obj);\n    Jsi_ValueMakeNumber(interp, ret, i);\n    return JSI_OK;\n}",
        "output": "1",
        "idx": 8152
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct ip_options *ip_options_get_alloc(const int optlen)\n{\n\treturn kzalloc(sizeof(struct ip_options) + ((optlen + 3) & ~3),\n\t\t       GFP_KERNEL);\n}",
        "output": "1",
        "idx": 352
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)\n{\n    FD_t wfd = NULL;\n    int rc = 0;\n\n    {\n\tmode_t old_umask = umask(0577);\n\twfd = Fopen(dest, \"w.ufdio\");\n\tumask(old_umask);\n    }\n    if (Ferror(wfd)) {\n\trc = RPMERR_OPEN_FAILED;\n\tgoto exit;\n    }\n\n    if (!nocontent)\n\trc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm);\nexit:\n    if (wfd) {\n\tint myerrno = errno;\n\tFclose(wfd);\n\terrno = myerrno;\n    }\n    return rc;\n}",
        "output": "1",
        "idx": 6616
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xen_cpu_init_eoi(unsigned int cpu)\n{\n\tstruct lateeoi_work *eoi = &per_cpu(lateeoi, cpu);\n\n\tINIT_DELAYED_WORK(&eoi->delayed, xen_irq_lateeoi_worker);\n\tspin_lock_init(&eoi->eoi_list_lock);\n\tINIT_LIST_HEAD(&eoi->eoi_list);\n}",
        "output": "0",
        "idx": 2733
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "next_line(struct archive_read *a,\n    const char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl)\n{\n\tssize_t len;\n\tint quit;\n\t\n\tquit = 0;\n\tif (*avail == 0) {\n\t\t*nl = 0;\n\t\tlen = 0;\n\t} else\n\t\tlen = get_line_size(*b, *avail, nl);\n\twhile (*nl == 0 && len == *avail && !quit) {\n\t\tssize_t diff = *ravail - *avail;\n\t\tsize_t nbytes_req = (*ravail+1023) & ~1023U;\n\t\tssize_t tested;\n\n\t\tif (nbytes_req < (size_t)*ravail + 160)\n\t\t\tnbytes_req <<= 1;\n\n\t\t*b = __archive_read_ahead(a, nbytes_req, avail);\n\t\tif (*b == NULL) {\n\t\t\tif (*ravail >= *avail)\n\t\t\t\treturn (0);\n\t\t\t*b = __archive_read_ahead(a, *avail, avail);\n\t\t\tquit = 1;\n\t\t}\n\t\t*ravail = *avail;\n\t\t*b += diff;\n\t\t*avail -= diff;\n\t\ttested = len;\n\t\tlen = get_line_size(*b + len, *avail - len, nl);\n\t\tif (len >= 0)\n\t\t\tlen += tested;\n\t}\n\treturn (len);\n}",
        "output": "0",
        "idx": 5201
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int set_evtchn_to_irq(evtchn_port_t evtchn, unsigned int irq)\n{\n\tunsigned row;\n\tunsigned col;\n\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -EINVAL;\n\n\trow = EVTCHN_ROW(evtchn);\n\tcol = EVTCHN_COL(evtchn);\n\n\tif (evtchn_to_irq[row] == NULL) {\n\t\tif (irq == -1)\n\t\t\treturn 0;\n\n\t\tevtchn_to_irq[row] = (int *)get_zeroed_page(GFP_KERNEL);\n\t\tif (evtchn_to_irq[row] == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tclear_evtchn_to_irq_row(row);\n\t}\n\n\tevtchn_to_irq[row][col] = irq;\n\treturn 0;\n}",
        "output": "1",
        "idx": 1888
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_wrap_aead(OM_uint32 *minor_status,\n\t\t     gss_ctx_id_t context_handle,\n\t\t     int conf_req_flag,\n\t\t     gss_qop_t qop_req,\n\t\t     gss_buffer_t input_assoc_buffer,\n\t\t     gss_buffer_t input_payload_buffer,\n\t\t     int *conf_state,\n\t\t     gss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_aead(minor_status,\n\t\t\t    context_handle,\n\t\t\t    conf_req_flag,\n\t\t\t    qop_req,\n\t\t\t    input_assoc_buffer,\n\t\t\t    input_payload_buffer,\n\t\t\t    conf_state,\n\t\t\t    output_message_buffer);\n\n\treturn (ret);\n}",
        "output": "1",
        "idx": 54
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mcs_recv_connect_response(STREAM mcs_data)\n{\n\tUNUSED(mcs_data);\n\tuint8 result;\n\tint length;\n\tSTREAM s;\n\tRD_BOOL is_fastpath;\n\tuint8 fastpath_hdr;\n\n\tlogger(Protocol, Debug, \"%s()\", __func__);\n\ts = iso_recv(&is_fastpath, &fastpath_hdr);\n\n\tif (s == NULL)\n\t\treturn False;\n\n\tber_parse_header(s, MCS_CONNECT_RESPONSE, &length);\n\n\tber_parse_header(s, BER_TAG_RESULT, &length);\n\tin_uint8(s, result);\n\tif (result != 0)\n\t{\n\t\tlogger(Protocol, Error, \"mcs_recv_connect_response(), result=%d\", result);\n\t\treturn False;\n\t}\n\n\tber_parse_header(s, BER_TAG_INTEGER, &length);\n\tin_uint8s(s, length);\t\n\tmcs_parse_domain_params(s);\n\n\tber_parse_header(s, BER_TAG_OCTET_STRING, &length);\n\n\tsec_process_mcs_data(s);\n\treturn s_check_end(s);\n}",
        "output": "1",
        "idx": 7136
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void set_content_type(HttpResponse res, const char *mime) {\n        set_header(res, \"Content-Type\", \"%s\", mime);\n}",
        "output": "0",
        "idx": 8439
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "swabHorDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n    uint16* wp = (uint16*) cp0;\n    tmsize_t wc = cc / 2;\n\n    if( !horDiff16(tif, cp0, cc) )\n        return 0;\n\n    TIFFSwabArrayOfShort(wp, wc);\n    return 1;\n}",
        "output": "0",
        "idx": 5915
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(void *) gdImageJpegPtr(gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageJpegCtx(im, out, quality);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}",
        "output": "1",
        "idx": 4462
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ip_printroute(netdissect_options *ndo,\n              register const u_char *cp, u_int length)\n{\n\tregister u_int ptr;\n\tregister u_int len;\n\n\tif (length < 3) {\n\t\tND_PRINT((ndo, \" [bad length %u]\", length));\n\t\treturn;\n\t}\n\tif ((length + 1) & 3)\n\t\tND_PRINT((ndo, \" [bad length %u]\", length));\n\tptr = cp[2] - 1;\n\tif (ptr < 3 || ((ptr + 1) & 3) || ptr > length + 1)\n\t\tND_PRINT((ndo, \" [bad ptr %u]\", cp[2]));\n\n\tfor (len = 3; len < length; len += 4) {\n\t\tND_PRINT((ndo, \" %s\", ipaddr_string(ndo, &cp[len])));\n\t\tif (ptr > len)\n\t\t\tND_PRINT((ndo, \",\"));\n\t}\n}",
        "output": "1",
        "idx": 4794
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "perf_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct perf_event *event = file->private_data;\n\tstruct perf_event_context *ctx;\n\tint ret;\n\n\tctx = perf_event_ctx_lock(event);\n\tret = perf_read_hw(event, buf, count);\n\tperf_event_ctx_unlock(event, ctx);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 3833
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "latin_ptr2len(char_u *p)\n{\n    return *p == NUL ? 0 : 1;\n}",
        "output": "0",
        "idx": 8123
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void clientCopy(HttpRoute *route, MprJson *dest, MprJson *obj)\n{\n    MprJson     *child, *job, *jvalue;\n    cchar       *key, *value;\n    int         ji;\n\n    for (ITERATE_CONFIG(route, obj, child, ji)) {\n        if (child->type & MPR_JSON_OBJ) {\n            job = mprCreateJson(MPR_JSON_OBJ);\n            clientCopy(route, job, child);\n            mprWriteJsonObj(dest, child->name, job);\n        } else {\n            key = child->value;\n            if (sends(key, \"|time\")) {\n                key = ssplit(sclone(key), \" \\t|\", NULL);\n                if ((value = mprReadJson(route->config, key)) != 0) {\n                    mprWriteJson(dest, child->name, itos(httpGetTicks(value)));\n                }\n            } else {\n                if ((jvalue = mprReadJsonObj(route->config, key)) != 0) {\n                    mprWriteJsonObj(dest, child->name, mprCloneJson(jvalue));\n                }\n            }\n        }\n    }\n}",
        "output": "0",
        "idx": 7043
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init init_ext2_fs(void)\n{\n\tint err = init_ext2_xattr();\n\tif (err)\n\t\treturn err;\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n        err = register_filesystem(&ext2_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\texit_ext2_xattr();\n\treturn err;\n}",
        "output": "1",
        "idx": 1098
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jas_iccgetuint32(jas_stream_t *in, jas_iccuint32_t *val)\n{\n\tjas_ulonglong tmp;\n\tif (jas_iccgetuint(in, 4, &tmp))\n\t\treturn -1;\n\t*val = tmp;\n\treturn 0;\n}",
        "output": "0",
        "idx": 7555
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload, *zap;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\tgoto error;\n\n\tret = -ENOMEM;\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\tgoto error;\n\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\n\tzap = upayload;\n\n\tret = key_payload_reserve(key, datalen);\n\n\tif (ret == 0) {\n\t\tzap = key->payload.data[0];\n\t\trcu_assign_keypointer(key, upayload);\n\t\tkey->expiry = 0;\n\t}\n\n\tif (zap)\n\t\tkfree_rcu(zap, rcu);\n\nerror:\n\treturn ret;\n}",
        "output": "1",
        "idx": 940
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static size_t optsize (lua_State *L, char opt, const char **fmt) {\n  switch (opt) {\n    case 'B': case 'b': return sizeof(char);\n    case 'H': case 'h': return sizeof(short);\n    case 'L': case 'l': return sizeof(long);\n    case 'T': return sizeof(size_t);\n    case 'f':  return sizeof(float);\n    case 'd':  return sizeof(double);\n    case 'x': return 1;\n    case 'c': return getnum(fmt, 1);\n    case 'i': case 'I': {\n      int sz = getnum(fmt, sizeof(int));\n      if (sz > MAXINTSIZE)\n        luaL_error(L, \"integral size %d is larger than limit of %d\",\n                       sz, MAXINTSIZE);\n      return sz;\n    }\n    default: return 0;  \n  }\n}",
        "output": "0",
        "idx": 5099
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int perf_event_task_disable(void)\n{\n\tstruct perf_event_context *ctx;\n\tstruct perf_event *event;\n\n\tmutex_lock(&current->perf_event_mutex);\n\tlist_for_each_entry(event, &current->perf_event_list, owner_entry) {\n\t\tctx = perf_event_ctx_lock(event);\n\t\tperf_event_for_each_child(event, _perf_event_disable);\n\t\tperf_event_ctx_unlock(event, ctx);\n\t}\n\tmutex_unlock(&current->perf_event_mutex);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 3857
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tif (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM)\n\t\treturn -ENODEV;\n\n\treturn cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);\n}",
        "output": "0",
        "idx": 1675
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int perf_swevent_init(struct perf_event *event)\n{\n\tu64 event_id = event->attr.config;\n\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (event_id) {\n\tcase PERF_COUNT_SW_CPU_CLOCK:\n\tcase PERF_COUNT_SW_TASK_CLOCK:\n\t\treturn -ENOENT;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (event_id >= PERF_COUNT_SW_MAX)\n\t\treturn -ENOENT;\n\n\tif (!event->parent) {\n\t\tint err;\n\n\t\terr = swevent_hlist_get(event);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tstatic_key_slow_inc(&perf_swevent_enabled[event_id]);\n\t\tevent->destroy = sw_perf_event_destroy;\n\t}\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1317
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static irqreturn_t armv7pmu_handle_irq(int irq_num, void *dev)\n{\n\tunsigned long pmnc;\n\tstruct perf_sample_data data;\n\tstruct cpu_hw_events *cpuc;\n\tstruct pt_regs *regs;\n\tint idx;\n\n\tpmnc = armv7_pmnc_getreset_flags();\n\n\tif (!armv7_pmnc_has_overflowed(pmnc))\n\t\treturn IRQ_NONE;\n\n\tregs = get_irq_regs();\n\n\tperf_sample_data_init(&data, 0);\n\n\tcpuc = &__get_cpu_var(cpu_hw_events);\n\tfor (idx = 0; idx <= armpmu->num_events; ++idx) {\n\t\tstruct perf_event *event = cpuc->events[idx];\n\t\tstruct hw_perf_event *hwc;\n\n\t\tif (!test_bit(idx, cpuc->active_mask))\n\t\t\tcontinue;\n\n\t\tif (!armv7_pmnc_counter_has_overflowed(pmnc, idx))\n\t\t\tcontinue;\n\n\t\thwc = &event->hw;\n\t\tarmpmu_event_update(event, hwc, idx, 1);\n\t\tdata.period = event->hw.last_period;\n\t\tif (!armpmu_event_set_period(event, hwc, idx))\n\t\t\tcontinue;\n\n\t\tif (perf_event_overflow(event, &data, regs))\n\t\t\tarmpmu->disable(hwc, idx);\n\t}\n\n\tirq_work_run();\n\n\treturn IRQ_HANDLED;\n}",
        "output": "0",
        "idx": 573
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u32 __ipv6_select_ident(struct net *net, u32 hashrnd,\n\t\t\t       const struct in6_addr *dst,\n\t\t\t       const struct in6_addr *src)\n{\n\tu32 hash, id;\n\n\thash = __ipv6_addr_jhash(dst, hashrnd);\n\thash = __ipv6_addr_jhash(src, hash);\n\thash ^= net_hash_mix(net);\n\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\n\treturn id;\n}",
        "output": "1",
        "idx": 3126
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xen_irq_lateeoi_worker(struct work_struct *work)\n{\n\tstruct lateeoi_work *eoi;\n\tstruct irq_info *info;\n\tu64 now = get_jiffies_64();\n\tunsigned long flags;\n\n\teoi = container_of(to_delayed_work(work), struct lateeoi_work, delayed);\n\n\tread_lock_irqsave(&evtchn_rwlock, flags);\n\n\twhile (true) {\n\t\tspin_lock(&eoi->eoi_list_lock);\n\n\t\tinfo = list_first_entry_or_null(&eoi->eoi_list, struct irq_info,\n\t\t\t\t\t\teoi_list);\n\n\t\tif (info == NULL || now < info->eoi_time) {\n\t\t\tspin_unlock(&eoi->eoi_list_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_del_init(&info->eoi_list);\n\n\t\tspin_unlock(&eoi->eoi_list_lock);\n\n\t\tinfo->eoi_time = 0;\n\n\t\txen_irq_lateeoi_locked(info);\n\t}\n\n\tif (info)\n\t\tmod_delayed_work_on(info->eoi_cpu, system_wq,\n\t\t\t\t    &eoi->delayed, info->eoi_time - now);\n\n\tread_unlock_irqrestore(&evtchn_rwlock, flags);\n}",
        "output": "0",
        "idx": 2723
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ber_parse_header(STREAM s, int tagval, int *length)\n{\n\tint tag, len;\n\n\tif (tagval > 0xff)\n\t{\n\t\tin_uint16_be(s, tag);\n\t}\n\telse\n\t{\n\t\tin_uint8(s, tag);\n\t}\n\n\tif (tag != tagval)\n\t{\n\t\tlogger(Core, Error, \"ber_parse_header(), expected tag %d, got %d\", tagval, tag);\n\t\treturn False;\n\t}\n\n\tin_uint8(s, len);\n\n\tif (len & 0x80)\n\t{\n\t\tlen &= ~0x80;\n\t\t*length = 0;\n\t\twhile (len--)\n\t\t\tnext_be(s, *length);\n\t}\n\telse\n\t\t*length = len;\n\n\treturn s_check(s);\n}",
        "output": "1",
        "idx": 7130
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ext4_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tint err;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\n\tsb_start_pagefault(inode->i_sb);\n\tfile_update_time(vma->vm_file);\n\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\terr = __dax_mkwrite(vma, vmf, ext4_get_block_dax,\n\t\t\t    ext4_end_io_unwritten);\n\tup_read(&EXT4_I(inode)->i_mmap_sem);\n\tsb_end_pagefault(inode->i_sb);\n\n\treturn err;\n}",
        "output": "0",
        "idx": 1443
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int DSA_verify(int type, const unsigned char *dgst, int dgst_len,\n\t     const unsigned char *sigbuf, int siglen, DSA *dsa)\n\t{\n\tDSA_SIG *s;\n\tint ret=-1;\n\n\ts = DSA_SIG_new();\n\tif (s == NULL) return(ret);\n\tif (d2i_DSA_SIG(&s,&sigbuf,siglen) == NULL) goto err;\n\tret=DSA_do_verify(dgst,dgst_len,s,dsa);\nerr:\n\tDSA_SIG_free(s);\n\treturn(ret);\n\t}",
        "output": "1",
        "idx": 4530
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline u32 net_hash_mix(const struct net *net)\n{\n#ifdef CONFIG_NET_NS\n\treturn (u32)(((unsigned long)net) >> ilog2(sizeof(*net)));\n#else\n\treturn 0;\n#endif\n}",
        "output": "1",
        "idx": 3132
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vapic_enter(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct page *page;\n\n\tif (!apic || !apic->vapic_addr)\n\t\treturn 0;\n\n\tpage = gfn_to_page(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn -EFAULT;\n\n\tvcpu->arch.apic->vapic_page = page;\n\treturn 0;\n}",
        "output": "1",
        "idx": 2488
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tstruct nat_entry *ne;\n\tint err;\n\n\tif (unlikely(nid == 0))\n\t\treturn false;\n\n\tif (build) {\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne && (!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\treturn false;\n\t}\n\n\ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n\ti->nid = nid;\n\ti->state = NID_NEW;\n\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\n\tspin_lock(&nm_i->nid_list_lock);\n\terr = __insert_nid_to_list(sbi, i, FREE_NID_LIST, true);\n\tspin_unlock(&nm_i->nid_list_lock);\n\tradix_tree_preload_end();\n\tif (err) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\treturn true;\n}",
        "output": "1",
        "idx": 1538
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct bpf_verifier_state *push_stack(struct bpf_verifier_env *env,\n\t\t\t\t\t     int insn_idx, int prev_insn_idx)\n{\n\tstruct bpf_verifier_state *cur = env->cur_state;\n\tstruct bpf_verifier_stack_elem *elem;\n\tint err;\n\n\telem = kzalloc(sizeof(struct bpf_verifier_stack_elem), GFP_KERNEL);\n\tif (!elem)\n\t\tgoto err;\n\n\telem->insn_idx = insn_idx;\n\telem->prev_insn_idx = prev_insn_idx;\n\telem->next = env->head;\n\tenv->head = elem;\n\tenv->stack_size++;\n\terr = copy_verifier_state(&elem->st, cur);\n\tif (err)\n\t\tgoto err;\n\tif (env->stack_size > BPF_COMPLEXITY_LIMIT_STACK) {\n\t\tverbose(env, \"BPF program is too complex\\n\");\n\t\tgoto err;\n\t}\n\treturn &elem->st;\nerr:\n\tfree_verifier_state(env->cur_state, true);\n\tenv->cur_state = NULL;\n\twhile (!pop_stack(env, NULL, NULL));\n\treturn NULL;\n}",
        "output": "1",
        "idx": 3062
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_truncate(const char *path)\n{\n\tif (truncate(path, 0) == 0) {\n\t\tfprintf(stderr, \"leak at truncate of %s\\n\", path);\n\t\texit(1);\n\t}\n}",
        "output": "0",
        "idx": 7277
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cuse_channel_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_dev *fud = file->private_data;\n\tstruct cuse_conn *cc = fc_to_cc(fud->fc);\n\tint rc;\n\n\tmutex_lock(&cuse_lock);\n\tlist_del_init(&cc->list);\n\tmutex_unlock(&cuse_lock);\n\n\tif (cc->dev)\n\t\tdevice_unregister(cc->dev);\n\tif (cc->cdev) {\n\t\tunregister_chrdev_region(cc->cdev->dev, 1);\n\t\tcdev_del(cc->cdev);\n\t}\n\tfuse_conn_put(&cc->fc);\n\n\trc = fuse_dev_release(inode, file);\t\n\n\treturn rc;\n}",
        "output": "0",
        "idx": 1333
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileInfo, setInfoClass)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_class_entry *ce = spl_ce_SplFileInfo;\n\tzend_error_handling error_handling;\n\t\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling  TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n\t\tintern->info_class = ce;\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}",
        "output": "1",
        "idx": 3986
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct request *blk_mq_tag_to_rq(struct blk_mq_tags *tags, unsigned int tag)\n{\n\tstruct request *rq = tags->rqs[tag];\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(rq->q, rq->mq_ctx);\n\n\tif (!is_flush_request(rq, fq, tag))\n\t\treturn rq;\n\n\treturn fq->flush_rq;\n}",
        "output": "1",
        "idx": 2894
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\n\tif (!ext4_handle_valid(handle)) {\n\t\text4_put_nojournal(handle);\n\t\treturn 0;\n\t}\n\n\tif (!handle->h_transaction) {\n\t\terr = jbd2_journal_stop(handle);\n\t\treturn handle->h_err ? handle->h_err : err;\n\t}\n\n\tsb = handle->h_transaction->t_journal->j_private;\n\terr = handle->h_err;\n\trc = jbd2_journal_stop(handle);\n\n\tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext4_std_error(sb, where, line, err);\n\treturn err;\n}",
        "output": "1",
        "idx": 2932
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseCertFields(MprBuf *buf, char *prefix, char *prefix2, char *info)\n{\n    char    c, *cp, *term, *key, *value;\n\n    term = cp = info;\n    do {\n        c = *cp;\n        if (c == '/' || c == '\\0') {\n            *cp = '\\0';\n            key = ssplit(term, \"=\", &value);\n            if (smatch(key, \"emailAddress\")) {\n                key = \"EMAIL\";\n            }\n            mprPutToBuf(buf, \"%s%s%s=%s,\", prefix, prefix2, key, value);\n            term = &cp[1];\n            *cp = c;\n        }\n    } while (*cp++ != '\\0');\n}",
        "output": "0",
        "idx": 7095
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MprJson *queryCore(MprJson *obj, cchar *key, MprJson *value, int flags)\n{\n    MprJson     *result, *child;\n    char        *property, *rest;\n    int         termType;\n\n    if (obj == 0 || key == 0 || *key == '\\0' || obj->type & MPR_JSON_VALUE) {\n        return 0;\n    }\n    result = 0;\n    for (property = getNextTerm(obj, value, sclone(key), &rest, &termType); property; ) {\n        if (termType & JSON_PROP_COMPOUND) {\n            result = queryCompound(obj, property, rest, value, flags, termType);\n            break;\n\n        } else if (rest == 0) {\n            if (!result && !value) {\n                result = mprCreateJson(MPR_JSON_ARRAY);\n            }\n            appendItem(result, queryLeaf(obj, property, value, flags));\n            break;\n\n        } else if ((child = mprLookupJsonObj(obj, property)) == 0) {\n            if (value) {\n                child = mprCreateJson(termType & JSON_PROP_ARRAY ? MPR_JSON_ARRAY : MPR_JSON_OBJ);\n                setProperty(obj, sclone(property), child);\n                obj = (MprJson*) child;\n            } else {\n                break;\n            }\n        }\n        obj = (MprJson*) child;\n        property = getNextTerm(obj, value, 0, &rest, &termType);\n    }\n    return result ? result : mprCreateJson(MPR_JSON_ARRAY);\n}",
        "output": "1",
        "idx": 5102
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int translate_desc(struct vhost_dev *dev, u64 addr, u32 len,\n\t\t\t  struct iovec iov[], int iov_size)\n{\n\tconst struct vhost_memory_region *reg;\n\tstruct vhost_memory *mem;\n\tstruct iovec *_iov;\n\tu64 s = 0;\n\tint ret = 0;\n\n\trcu_read_lock();\n\n\tmem = rcu_dereference(dev->memory);\n\twhile ((u64)len > s) {\n\t\tu64 size;\n\t\tif (unlikely(ret >= iov_size)) {\n\t\t\tret = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\treg = find_region(mem, addr, len);\n\t\tif (unlikely(!reg)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\t_iov = iov + ret;\n\t\tsize = reg->memory_size - addr + reg->guest_phys_addr;\n\t\t_iov->iov_len = min((u64)len - s, size);\n\t\t_iov->iov_base = (void __user *)(unsigned long)\n\t\t\t(reg->userspace_addr + addr - reg->guest_phys_addr);\n\t\ts += size;\n\t\taddr += size;\n\t\t++ret;\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}",
        "output": "0",
        "idx": 1089
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "init_ctx_new(OM_uint32 *minor_status,\n\t     spnego_gss_cred_id_t spcred,\n\t     gss_ctx_id_t *ctx,\n\t     send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\tsc = create_spnego_ctx(1);\n\tif (sc == NULL)\n\t\treturn GSS_S_FAILURE;\n\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_INITIATE,\n\t\t\t\t   &sc->mech_set);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tsc->internal_mech = &sc->mech_set->elements[0];\n\n\tif (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\n\tsc->ctx_handle = GSS_C_NO_CONTEXT;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\t*tokflag = INIT_TOKEN_SEND;\n\tret = GSS_S_CONTINUE_NEEDED;\n\ncleanup:\n\trelease_spnego_ctx(&sc);\n\treturn ret;\n}",
        "output": "0",
        "idx": 101
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_emul_add_msixcap(struct pci_vdev *dev, int msgnum, int barnum)\n{\n\tuint32_t tab_size;\n\tstruct msixcap msixcap;\n\n\tassert(msgnum >= 1 && msgnum <= MAX_MSIX_TABLE_ENTRIES);\n\tassert(barnum >= 0 && barnum <= PCIR_MAX_BAR_0);\n\n\ttab_size = msgnum * MSIX_TABLE_ENTRY_SIZE;\n\n\ttab_size = roundup2(tab_size, 4096);\n\n\tdev->msix.table_bar = barnum;\n\tdev->msix.pba_bar   = barnum;\n\tdev->msix.table_offset = 0;\n\tdev->msix.table_count = msgnum;\n\tdev->msix.pba_offset = tab_size;\n\tdev->msix.pba_size = PBA_SIZE(msgnum);\n\n\tpci_msix_table_init(dev, msgnum);\n\n\tpci_populate_msixcap(&msixcap, msgnum, barnum, tab_size);\n\n\tpci_emul_alloc_bar(dev, barnum, PCIBAR_MEM32,\n\t\t\t\ttab_size + dev->msix.pba_size);\n\n\treturn (pci_emul_add_capability(dev, (u_char *)&msixcap,\n\t\t\t\t\tsizeof(msixcap)));\n}",
        "output": "1",
        "idx": 7582
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int process_numeric_entity(const char **buf, unsigned *code_point)\n{\n\tlong code_l;\n\tint hexadecimal = (**buf == 'x' || **buf == 'X'); \n\tchar *endptr;\n\n\tif (hexadecimal && (**buf != '\\0'))\n\t\t(*buf)++;\n\n\tif ((hexadecimal && !isxdigit(**buf)) ||\n\t\t\t(!hexadecimal && !isdigit(**buf))) {\n\t\treturn FAILURE;\n\t}\n\n\tcode_l = strtol(*buf, &endptr, hexadecimal ? 16 : 10);\n\t*buf = endptr;\n\n\tif (**buf != ';')\n\t\treturn FAILURE;\n\n\tif (code_l > 0x10FFFFL)\n\t\treturn FAILURE;\n\n\tif (code_point != NULL)\n\t\t*code_point = (unsigned)code_l;\n\n\treturn SUCCESS;\n}",
        "output": "0",
        "idx": 5375
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init xfrm6_tunnel_init(void)\n{\n\tint rv;\n\n\trv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);\n\tif (rv < 0)\n\t\tgoto err;\n\trv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);\n\tif (rv < 0)\n\t\tgoto unreg;\n\trv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);\n\tif (rv < 0)\n\t\tgoto dereg6;\n\trv = xfrm6_tunnel_spi_init();\n\tif (rv < 0)\n\t\tgoto dereg46;\n\trv = register_pernet_subsys(&xfrm6_tunnel_net_ops);\n\tif (rv < 0)\n\t\tgoto deregspi;\n\treturn 0;\n\nderegspi:\n\txfrm6_tunnel_spi_fini();\ndereg46:\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\ndereg6:\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\nunreg:\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\nerr:\n\treturn rv;\n}",
        "output": "1",
        "idx": 2212
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xcopy_pt_undepend_remotedev(struct xcopy_op *xop)\n{\n\tif (xop->op_origin == XCOL_SOURCE_RECV_OP)\n\t\tpr_debug(\"putting dst lun_ref for %p\\n\", xop->dst_dev);\n\telse\n\t\tpr_debug(\"putting src lun_ref for %p\\n\", xop->src_dev);\n\n\tpercpu_ref_put(xop->remote_lun_ref);\n}",
        "output": "0",
        "idx": 2771
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nfs4_xdr_dec_getacl(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t    struct nfs_getaclres *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getacl(xdr, rqstp, &res->acl_len);\n\nout:\n\treturn status;\n}",
        "output": "1",
        "idx": 656
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void handle_ld_nf(u32 insn, struct pt_regs *regs)\n{\n\tint rd = ((insn >> 25) & 0x1f);\n\tint from_kernel = (regs->tstate & TSTATE_PRIV) != 0;\n\tunsigned long *reg;\n\t                        \n\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);\n\n\tmaybe_flush_windows(0, 0, rd, from_kernel);\n\treg = fetch_reg_addr(rd, regs);\n\tif (from_kernel || rd < 16) {\n\t\treg[0] = 0;\n\t\tif ((insn & 0x780000) == 0x180000)\n\t\t\treg[1] = 0;\n\t} else if (test_thread_flag(TIF_32BIT)) {\n\t\tput_user(0, (int __user *) reg);\n\t\tif ((insn & 0x780000) == 0x180000)\n\t\t\tput_user(0, ((int __user *) reg) + 1);\n\t} else {\n\t\tput_user(0, (unsigned long __user *) reg);\n\t\tif ((insn & 0x780000) == 0x180000)\n\t\t\tput_user(0, (unsigned long __user *) reg + 1);\n\t}\n\tadvance(regs);\n}",
        "output": "0",
        "idx": 645
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(FilesystemIterator, key)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (SPL_FILE_DIR_KEY(intern, SPL_FILE_DIR_KEY_AS_FILENAME)) {\n\t\tRETURN_STRING(intern->u.dir.entry.d_name, 1);\n\t} else {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t\tRETURN_STRINGL(intern->file_name, intern->file_name_len, 1);\n\t}\n}",
        "output": "1",
        "idx": 3964
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void sem_getref_and_unlock(struct sem_array *sma)\n{\n\tWARN_ON_ONCE(!ipc_rcu_getref(sma));\n\tsem_unlock(sma, -1);\n}",
        "output": "0",
        "idx": 3201
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __u8 *nci_extract_rf_params_nfca_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfca_poll *nfca_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfca_poll->sens_res = __le16_to_cpu(*((__u16 *)data));\n\tdata += 2;\n\n\tnfca_poll->nfcid1_len = *data++;\n\n\tpr_debug(\"sens_res 0x%x, nfcid1_len %d\\n\",\n\t\t nfca_poll->sens_res, nfca_poll->nfcid1_len);\n\n\tmemcpy(nfca_poll->nfcid1, data, nfca_poll->nfcid1_len);\n\tdata += nfca_poll->nfcid1_len;\n\n\tnfca_poll->sel_res_len = *data++;\n\n\tif (nfca_poll->sel_res_len != 0)\n\t\tnfca_poll->sel_res = *data++;\n\n\tpr_debug(\"sel_res_len %d, sel_res 0x%x\\n\",\n\t\t nfca_poll->sel_res_len,\n\t\t nfca_poll->sel_res);\n\n\treturn data;\n}",
        "output": "1",
        "idx": 728
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void virtio_config_writeb(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val = data;\n\n    if (addr > (vdev->config_len - sizeof(val)))\n        return;\n\n    stb_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}",
        "output": "1",
        "idx": 3770
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void my_free(void *ptr)\n{\n    free_called += 1;\n    free(ptr);\n}",
        "output": "1",
        "idx": 4326
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseCache(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprJson     *child;\n    MprTicks    clientLifespan, serverLifespan;\n    cchar       *methods, *extensions, *uris, *mimeTypes, *client, *server;\n    int         flags, ji;\n\n    clientLifespan = serverLifespan = 0;\n    for (ITERATE_CONFIG(route, prop, child, ji)) {\n        flags = 0;\n        if ((client = mprGetJson(child, \"client\")) != 0) {\n            flags |= HTTP_CACHE_CLIENT;\n            clientLifespan = httpGetTicks(client);\n        }\n        if ((server = mprGetJson(child, \"server\")) != 0) {\n            flags |= HTTP_CACHE_SERVER;\n            serverLifespan = httpGetTicks(server);\n        }\n        methods = getList(mprGetJsonObj(child, \"methods\"));\n        extensions = getList(mprGetJsonObj(child, \"extensions\"));\n        uris = getList(mprGetJsonObj(child, \"uris\"));\n        mimeTypes = getList(mprGetJsonObj(child, \"mime\"));\n\n        if (smatch(mprGetJson(child, \"unique\"), \"true\")) {\n            flags |= HTTP_CACHE_UNIQUE;\n        }\n        if (smatch(mprGetJson(child, \"manual\"), \"true\")) {\n            flags |= HTTP_CACHE_MANUAL;\n        }\n        httpAddCache(route, methods, uris, extensions, mimeTypes, clientLifespan, serverLifespan, flags);\n    }\n}",
        "output": "1",
        "idx": 5032
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_hash rhash;\n\n\tstrncpy(rhash.type, \"ahash\", sizeof(rhash.type));\n\n\trhash.blocksize = alg->cra_blocksize;\n\trhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_HASH,\n\t\t    sizeof(struct crypto_report_hash), &rhash))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "0",
        "idx": 1177
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cJSON_InitHooks(cJSON_Hooks* hooks)\n{\n    if (!hooks) { \n        cJSON_malloc = malloc;\n        cJSON_free = free;\n        return;\n    }\n\n\tcJSON_malloc = (hooks->malloc_fn)?hooks->malloc_fn:malloc;\n\tcJSON_free\t = (hooks->free_fn)?hooks->free_fn:free;\n}",
        "output": "0",
        "idx": 8267
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "set_interface_var(const char *iface,\n\t\t  const char *var, const char *name,\n\t\t  uint32_t val)\n{\n\tFILE *fp;\n\tchar spath[64+IFNAMSIZ];\t\n\tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n\t\treturn -1;\n\n\tif (strstr(name, \"..\") || strchr(name, '/'))\n\t\treturn -1;\n\n\tif (access(spath, F_OK) != 0)\n\t\treturn -1;\n\n\tfp = fopen(spath, \"w\");\n\tif (!fp) {\n\t\tif (name)\n\t\t\tflog(LOG_ERR, \"failed to set %s (%u) for %s: %s\",\n\t\t\t     name, val, iface, strerror(errno));\n\t\treturn -1;\n\t}\n\tfprintf(fp, \"%u\", val);\n\tfclose(fp);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 5011
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *fstrndup(const char *ptr, unsigned long len) {\n  char *result;\n  if (len <= 0) return NULL;\n  result = ALLOC_N(char, len);\n  memcpy(result, ptr, len);\n  return result;\n}",
        "output": "0",
        "idx": 8801
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int insn_get_code_seg_params(struct pt_regs *regs)\n{\n\tstruct desc_struct desc;\n\tshort sel;\n\n\tif (v8086_mode(regs))\n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\n\tsel = get_segment_selector(regs, INAT_SEG_REG_CS);\n\tif (sel < 0)\n\t\treturn sel;\n\n\tif (!get_desc(&desc, sel))\n\t\treturn -EINVAL;\n\n\tif (!(desc.type & BIT(3)))\n\t\treturn -EINVAL;\n\n\tswitch ((desc.l << 1) | desc.d) {\n\tcase 0: \n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\tcase 1: \n\t\treturn INSN_CODE_SEG_PARAMS(4, 4);\n\tcase 2: \n\t\treturn INSN_CODE_SEG_PARAMS(4, 8);\n\tcase 3: \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}",
        "output": "0",
        "idx": 4405
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static cJSON *cJSON_New_Item( void )\n{\n\tcJSON* node = (cJSON*) cJSON_malloc( sizeof(cJSON) );\n\tif ( node )\n\t\tmemset( node, 0, sizeof(cJSON) );\n\treturn node;\n}",
        "output": "1",
        "idx": 5948
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\n{\n\tns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tshm_rmid(ns, shp);\n\tshm_unlock(shp);\n\tif (!is_file_hugepages(shp->shm_file))\n\t\tshmem_lock(shp->shm_file, 0, shp->mlock_user);\n\telse if (shp->mlock_user)\n\t\tuser_shm_unlock(file_inode(shp->shm_file)->i_size,\n\t\t\t\t\t\tshp->mlock_user);\n\tfput (shp->shm_file);\n\tipc_rcu_putref(shp, shm_rcu_free);\n}",
        "output": "1",
        "idx": 2476
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_rng_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_rng *rng = __crypto_rng_cast(tfm);\n\tstruct rng_alg *alg = crypto_rng_alg(rng);\n\tstruct old_rng_alg *oalg = crypto_old_rng_alg(rng);\n\n\tif (oalg->rng_make_random) {\n\t\trng->generate = generate;\n\t\trng->seed = rngapi_reset;\n\t\trng->seedsize = oalg->seedsize;\n\t\treturn 0;\n\t}\n\n\trng->generate = alg->generate;\n\trng->seed = alg->seed;\n\trng->seedsize = alg->seedsize;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 2840
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n\n\tpayload = NULL;\n\tif (plen) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\tret = key_update(key_ref, payload, plen);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkfree(payload);\nerror:\n\treturn ret;\n}",
        "output": "0",
        "idx": 2333
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t driver_override_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tchar *driver_override, *old = pdev->driver_override, *cp;\n\n\tif (count > PATH_MAX)\n\t\treturn -EINVAL;\n\n\tdriver_override = kstrndup(buf, count, GFP_KERNEL);\n\tif (!driver_override)\n\t\treturn -ENOMEM;\n\n\tcp = strchr(driver_override, '\\n');\n\tif (cp)\n\t\t*cp = '\\0';\n\n\tif (strlen(driver_override)) {\n\t\tpdev->driver_override = driver_override;\n\t} else {\n\t\tkfree(driver_override);\n\t\tpdev->driver_override = NULL;\n\t}\n\n\tkfree(old);\n\n\treturn count;\n}",
        "output": "1",
        "idx": 1598
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void watchdog_overflow_callback(struct perf_event *event, int nmi,\n\t\t struct perf_sample_data *data,\n\t\t struct pt_regs *regs)\n{\n\tevent->hw.interrupts = 0;\n\n\tif (__this_cpu_read(watchdog_nmi_touch) == true) {\n\t\t__this_cpu_write(watchdog_nmi_touch, false);\n\t\treturn;\n\t}\n\n\tif (is_hardlockup()) {\n\t\tint this_cpu = smp_processor_id();\n\n\t\tif (__this_cpu_read(hard_watchdog_warn) == true)\n\t\t\treturn;\n\n\t\tif (hardlockup_panic)\n\t\t\tpanic(\"Watchdog detected hard LOCKUP on cpu %d\", this_cpu);\n\t\telse\n\t\t\tWARN(1, \"Watchdog detected hard LOCKUP on cpu %d\", this_cpu);\n\n\t\t__this_cpu_write(hard_watchdog_warn, true);\n\t\treturn;\n\t}\n\n\t__this_cpu_write(hard_watchdog_warn, false);\n\treturn;\n}",
        "output": "1",
        "idx": 554
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int install_process_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->process_keyring)\n\t\treturn 0;\n\n\tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->process_keyring = keyring;\n\treturn 0;\n}",
        "output": "0",
        "idx": 2247
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct mb2_cache_entry *mb2_cache_entry_find_next(struct mb2_cache *cache,\n\t\t\t\t\t\t  struct mb2_cache_entry *entry)\n{\n\treturn __entry_find(cache, entry, entry->e_key);\n}",
        "output": "0",
        "idx": 1619
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) \n{\n\tzend_hash_destroy(&pglobals->ht_rc);\n}",
        "output": "1",
        "idx": 4052
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ex_function(exarg_T *eap)\n{\n    char_u *line_to_free = NULL;\n\n    (void)define_function(eap, NULL, &line_to_free);\n    vim_free(line_to_free);\n}",
        "output": "0",
        "idx": 7929
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tput_user_ns(ucounts->ns);\n\t\tkfree(ucounts);\n\t}\n}",
        "output": "0",
        "idx": 2883
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_accm_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tuint16_t val_h, val_l;\n\n\tptr++;\t\t\n\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"send=%08x \", (val_h<<16) + val_l));\n\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"recv=%08x \", (val_h<<16) + val_l));\n}",
        "output": "1",
        "idx": 4762
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t k90_show_current_profile(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint current_profile;\n\tchar data[8];\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tcurrent_profile = data[7];\n\tif (current_profile < 1 || current_profile > 3) {\n\t\tdev_warn(dev, \"Read invalid current profile: %02hhx.\\n\",\n\t\t\t data[7]);\n\t\treturn -EIO;\n\t}\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\n}",
        "output": "1",
        "idx": 1422
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int DefragTrackerReuseTest(void)\n{\n    int ret = 0;\n    int id = 1;\n    Packet *p1 = NULL;\n    DefragTracker *tracker1 = NULL, *tracker2 = NULL;\n\n    DefragInit();\n\n    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n    if (p1 == NULL) {\n        goto end;\n    }\n\n    tracker1 = DefragGetTracker(NULL, NULL, p1);\n    if (tracker1 == NULL) {\n        goto end;\n    }\n    if (tracker1->seen_last) {\n        goto end;\n    }\n    if (tracker1->remove) {\n        goto end;\n    }\n    DefragTrackerRelease(tracker1);\n\n    tracker2 = DefragGetTracker(NULL, NULL, p1);\n    if (tracker2 == NULL) {\n        goto end;\n    }\n    if (tracker2 != tracker1) {\n        goto end;\n    }\n    DefragTrackerRelease(tracker1);\n\n    tracker1->remove = 1;\n\n    tracker2 = DefragGetTracker(NULL, NULL, p1);\n    if (tracker2 == NULL) {\n        goto end;\n    }\n    if (tracker2 == tracker1) {\n        goto end;\n    }\n    if (tracker2->remove) {\n        goto end;\n    }\n\n    ret = 1;\nend:\n    if (p1 != NULL) {\n        SCFree(p1);\n    }\n    DefragDestroy();\n    return ret;\n}",
        "output": "1",
        "idx": 6580
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mp_capable_print(netdissect_options *ndo,\n                 const u_char *opt, u_int opt_len, u_char flags)\n{\n        const struct mp_capable *mpc = (const struct mp_capable *) opt;\n\n        if (!(opt_len == 12 && (flags & TH_SYN)) &&\n            !(opt_len == 20 && (flags & (TH_SYN | TH_ACK)) == TH_ACK))\n                return 0;\n\n        if (MP_CAPABLE_OPT_VERSION(mpc->sub_ver) != 0) {\n                ND_PRINT((ndo, \" Unknown Version (%d)\", MP_CAPABLE_OPT_VERSION(mpc->sub_ver)));\n                return 1;\n        }\n\n        if (mpc->flags & MP_CAPABLE_C)\n                ND_PRINT((ndo, \" csum\"));\n        ND_PRINT((ndo, \" {0x%\" PRIx64, EXTRACT_64BITS(mpc->sender_key)));\n        if (opt_len == 20) \n                ND_PRINT((ndo, \",0x%\" PRIx64, EXTRACT_64BITS(mpc->receiver_key)));\n        ND_PRINT((ndo, \"}\"));\n        return 1;\n}",
        "output": "0",
        "idx": 6771
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseContentCompress(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprJson     *child;\n    int         ji;\n\n    for (ITERATE_CONFIG(route, prop, child, ji)) {\n        if (mprGetJson(route->config, sfmt(\"app.http.content.minify[@ = '%s']\", child->value))) {\n            httpAddRouteMapping(route, child->value, \"${1}.gz, min.${1}.gz, min.${1}\");\n        } else {\n            httpAddRouteMapping(route, child->value, \"${1}.gz\");\n        }\n    }\n}",
        "output": "1",
        "idx": 5030
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tipc_nl_compat_link_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t    struct nlattr **attrs)\n{\n\tstruct nlattr *link[TIPC_NLA_LINK_MAX + 1];\n\tstruct tipc_link_info link_info;\n\tint err;\n\n\tif (!attrs[TIPC_NLA_LINK])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested(link, TIPC_NLA_LINK_MAX, attrs[TIPC_NLA_LINK],\n\t\t\t       NULL);\n\tif (err)\n\t\treturn err;\n\n\tlink_info.dest = nla_get_flag(link[TIPC_NLA_LINK_DEST]);\n\tlink_info.up = htonl(nla_get_flag(link[TIPC_NLA_LINK_UP]));\n\tstrcpy(link_info.str, nla_data(link[TIPC_NLA_LINK_NAME]));\n\n\treturn tipc_add_tlv(msg->rep, TIPC_TLV_LINK_INFO,\n\t\t\t    &link_info, sizeof(link_info));\n}",
        "output": "1",
        "idx": 1280
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tcp_illinois_info(struct sock *sk, u32 ext,\n\t\t\t      struct sk_buff *skb)\n{\n\tconst struct illinois *ca = inet_csk_ca(sk);\n\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tstruct tcpvegas_info info = {\n\t\t\t.tcpv_enabled = 1,\n\t\t\t.tcpv_rttcnt = ca->cnt_rtt,\n\t\t\t.tcpv_minrtt = ca->base_rtt,\n\t\t};\n\n\t\tif (info.tcpv_rttcnt > 0) {\n\t\t\tu64 t = ca->sum_rtt;\n\n\t\t\tdo_div(t, info.tcpv_rttcnt);\n\t\t\tinfo.tcpv_rtt = t;\n\t\t}\n\t\tnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n\t}\n}",
        "output": "0",
        "idx": 1085
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int htc_setup_complete(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_comp_msg *comp_msg;\n\tint ret = 0;\n\tunsigned long time_left;\n\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\n\tcomp_msg = skb_put(skb, sizeof(struct htc_comp_msg));\n\tcomp_msg->msg_id = cpu_to_be16(HTC_MSG_SETUP_COMPLETE_ID);\n\n\ttarget->htc_flags |= HTC_OP_START_WAIT;\n\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC start timeout\\n\");\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}",
        "output": "0",
        "idx": 4465
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ast_for_funcdef(struct compiling *c, const node *n, asdl_seq *decorator_seq)\n{\n    return ast_for_funcdef_impl(c, n, decorator_seq,\n                                0 );\n}",
        "output": "1",
        "idx": 7732
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ssh_packet_set_postauth(struct ssh *ssh)\n{\n\tstruct sshcomp *comp;\n\tint r, mode;\n\n\tdebug(\"%s: called\", __func__);\n\tssh->state->after_authentication = 1;\n\tssh->state->rekeying = 0;\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tif (ssh->state->newkeys[mode] == NULL)\n\t\t\tcontinue;\n\t\tcomp = &ssh->state->newkeys[mode]->comp;\n\t\tif (comp && comp->enabled &&\n\t\t    (r = ssh_packet_init_compression(ssh)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 5586
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Box *encs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_ENCS);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}",
        "output": "1",
        "idx": 6846
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ip_setup_cork(struct sock *sk, struct inet_cork *cork,\n\t\t\t struct ipcm_cookie *ipc, struct rtable **rtp)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options_rcu *opt;\n\tstruct rtable *rt;\n\n\topt = ipc->opt;\n\tif (opt) {\n\t\tif (cork->opt == NULL) {\n\t\t\tcork->opt = kmalloc(sizeof(struct ip_options) + 40,\n\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (unlikely(cork->opt == NULL))\n\t\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tmemcpy(cork->opt, &opt->opt, sizeof(struct ip_options) + opt->opt.optlen);\n\t\tcork->flags |= IPCORK_OPT;\n\t\tcork->addr = ipc->addr;\n\t}\n\trt = *rtp;\n\tif (unlikely(!rt))\n\t\treturn -EFAULT;\n\t*rtp = NULL;\n\tcork->fragsize = inet->pmtudisc == IP_PMTUDISC_PROBE ?\n\t\t\t rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\tcork->dst = &rt->dst;\n\tcork->length = 0;\n\tcork->tx_flags = ipc->tx_flags;\n\tcork->page = NULL;\n\tcork->off = 0;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 501
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long madvise_willneed(struct vm_area_struct *vma,\n\t\t\t     struct vm_area_struct **prev,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tstruct file *file = vma->vm_file;\n\n\t*prev = vma;\n#ifdef CONFIG_SWAP\n\tif (!file) {\n\t\tforce_swapin_readahead(vma, start, end);\n\t\treturn 0;\n\t}\n\n\tif (shmem_mapping(file->f_mapping)) {\n\t\tforce_shm_swapin_readahead(vma, start, end,\n\t\t\t\t\tfile->f_mapping);\n\t\treturn 0;\n\t}\n#else\n\tif (!file)\n\t\treturn -EBADF;\n#endif\n\n\tif (IS_DAX(file_inode(file))) {\n\t\treturn 0;\n\t}\n\n\tstart = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tif (end > vma->vm_end)\n\t\tend = vma->vm_end;\n\tend = ((end - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\n\tforce_page_cache_readahead(file->f_mapping, file, start, end - start);\n\treturn 0;\n}",
        "output": "0",
        "idx": 2581
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct bpf_prog *bpf_prog_get(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\n\tprog = __bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\n\tprog = bpf_prog_inc(prog);\n\tfdput(f);\n\n\treturn prog;\n}",
        "output": "0",
        "idx": 1835
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int getnum (lua_State *L, const char **fmt, int df) {\n  if (!isdigit(**fmt))  \n    return df;  \n  else {\n    int a = 0;\n    do {\n      if (a > (INT_MAX / 10) || a * 10 > (INT_MAX - (**fmt - '0')))\n        luaL_error(L, \"integral size overflow\");\n      a = a*10 + *((*fmt)++) - '0';\n    } while (isdigit(**fmt));\n    return a;\n  }\n}",
        "output": "1",
        "idx": 3646
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parseuid(const char *s, uid_t *uid)\n{\n\tstruct passwd *pw;\n\tconst char *errstr;\n\n\tif ((pw = getpwnam(s)) != NULL) {\n\t\t*uid = pw->pw_uid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*uid = strtonum(s, 0, UID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", uid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}",
        "output": "1",
        "idx": 7520
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void svhandler_flash_pgm_word(void) {\n  uint32_t dst = _param_1;\n  uint32_t src = _param_2;\n\n  if ((dst >= BSTRP_FLASH_SECT_START) &&\n      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {\n    return;\n  }\n\n  if ((dst >= BLDR_FLASH_SECT_START) &&\n      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {\n    return;\n  }\n\n  flash_clear_status_flags();\n  flash_unlock();\n\n  flash_program_word(dst, src);\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n\n  flash_wait_for_last_operation();\n\n  FLASH_CR &= ~FLASH_CR_PG;\n\n  FLASH_CR |= FLASH_CR_LOCK;\n}",
        "output": "1",
        "idx": 7562
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned long mmap_legacy_base(unsigned long rnd)\n{\n\tif (mmap_is_ia32())\n\t\treturn TASK_UNMAPPED_BASE;\n\telse\n\t\treturn TASK_UNMAPPED_BASE + rnd;\n}",
        "output": "1",
        "idx": 1146
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "reference_queue_proccess (MonoReferenceQueue *queue)\n{\n\tRefQueueEntry **iter = &queue->queue;\n\tRefQueueEntry *entry;\n\twhile ((entry = *iter)) {\n\t\tif (queue->should_be_deleted || !mono_gc_weak_link_get (&entry->dis_link)) {\n\t\t\tref_list_remove_element (iter, entry);\n\t\t\tmono_gc_weak_link_remove (&entry->dis_link);\n\t\t\tqueue->callback (entry->user_data);\n\t\t\tg_free (entry);\n\t\t} else {\n\t\t\titer = &entry->next;\n\t\t}\n\t}\n}",
        "output": "0",
        "idx": 4701
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "valid_diff(diff_T *diff)\n{\n    diff_T\t*dp;\n\n    for (dp = curtab->tp_first_diff; dp != NULL; dp = dp->df_next)\n\tif (dp == diff)\n\t    return TRUE;\n    return FALSE;\n}",
        "output": "0",
        "idx": 8085
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)\n{\n    return primes[hashtable->num_buckets];\n}",
        "output": "1",
        "idx": 4310
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC MprJson *mprReadJsonValue(MprJson *obj, cchar *value)\n{\n    MprJson     *child;\n    int         i;\n\n    if (!obj || !value) {\n        return 0;\n    }\n    for (ITERATE_JSON(obj, child, i)) {\n        if (smatch(child->value, value)) {\n            return child;\n        }\n    }\n    return 0;\n}",
        "output": "0",
        "idx": 7087
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int walk_hugetlb_range(unsigned long addr, unsigned long end,\n\t\t\t      struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long next;\n\tunsigned long hmask = huge_page_mask(h);\n\tunsigned long sz = huge_page_size(h);\n\tpte_t *pte;\n\tint err = 0;\n\n\tdo {\n\t\tnext = hugetlb_entry_end(h, addr, end);\n\t\tpte = huge_pte_offset(walk->mm, addr & hmask, sz);\n\n\t\tif (pte)\n\t\t\terr = walk->hugetlb_entry(pte, hmask, addr, next, walk);\n\t\telse if (walk->pte_hole)\n\t\t\terr = walk->pte_hole(addr, next, walk);\n\n\t\tif (err)\n\t\t\tbreak;\n\t} while (addr = next, addr != end);\n\n\treturn err;\n}",
        "output": "0",
        "idx": 2543
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rawsock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t   struct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied;\n\tint rc;\n\n\tpr_debug(\"sock=%p sk=%p len=%zu flags=%d\\n\", sock, sk, len, flags);\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &rc);\n\tif (!skb)\n\t\treturn rc;\n\n\tmsg->msg_namelen = 0;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\trc = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\n\tskb_free_datagram(sk, skb);\n\n\treturn rc ? : copied;\n}",
        "output": "1",
        "idx": 2456
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "idn2_to_ascii_4i (const uint32_t * input, size_t inlen, char * output, int flags)\n{\n  uint32_t *input_u32;\n  uint8_t *input_u8, *output_u8;\n  size_t length;\n  int rc;\n\n  if (!input)\n    {\n      if (output)\n\t*output = 0;\n      return IDN2_OK;\n    }\n\n  input_u32 = (uint32_t *) malloc ((inlen + 1) * sizeof(uint32_t));\n  if (!input_u32)\n    return IDN2_MALLOC;\n\n  u32_cpy (input_u32, input, inlen);\n  input_u32[inlen] = 0;\n\n  input_u8 = u32_to_u8 (input_u32, inlen + 1, NULL, &length);\n  free (input_u32);\n  if (!input_u8)\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ENCODING_ERROR;\n    }\n\n  rc = idn2_lookup_u8 (input_u8, &output_u8, flags);\n  free (input_u8);\n\n  if (rc == IDN2_OK)\n    {\n      if (output)\n\tstrcpy (output, (const char *) output_u8);\n\n      free(output_u8);\n    }\n\n  return rc;\n}",
        "output": "1",
        "idx": 7542
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC cchar *mprReadJson(MprJson *obj, cchar *name)\n{\n    MprJson     *item;\n\n    if ((item = mprReadJsonObj(obj, name)) != 0 && item->type & MPR_JSON_VALUE) {\n        return item->value;\n    }\n    return 0;\n}",
        "output": "0",
        "idx": 7093
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void sas_destruct_devices(struct asd_sas_port *port)\n{\n\tstruct domain_device *dev, *n;\n\n\tlist_for_each_entry_safe(dev, n, &port->destroy_list, disco_list_node) {\n\t\tlist_del_init(&dev->disco_list_node);\n\n\t\tsas_remove_children(&dev->rphy->dev);\n\t\tsas_rphy_delete(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t}\n}",
        "output": "0",
        "idx": 2645
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,\n\t\t\t\t __be16 sport, __be16 dport)\n{\n\tu32 hash[MD5_DIGEST_WORDS];\n\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n\thash[3] = net_secret[15];\n\n\tmd5_transform(hash, net_secret);\n\n\treturn seq_scale(hash[0]);\n}",
        "output": "0",
        "idx": 775
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void* ipc_alloc(int size)\n{\n\tvoid* out;\n\tif(size > PAGE_SIZE)\n\t\tout = vmalloc(size);\n\telse\n\t\tout = kmalloc(size, GFP_KERNEL);\n\treturn out;\n}",
        "output": "1",
        "idx": 2282
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_lintr_release(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tint pin;\n\n\tbi = pci_businfo[dev->bus];\n\tassert(bi != NULL);\n\n\tsi = &bi->slotinfo[dev->slot];\n\n\tfor (pin = 1; pin < 4; pin++) {\n\t\tsi->si_intpins[pin].ii_count = 0;\n\t\tsi->si_intpins[pin].ii_pirq_pin = 0;\n\t\tsi->si_intpins[pin].ii_ioapic_irq = 0;\n\t}\n}",
        "output": "1",
        "idx": 7584
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t _epoll_readv(\n    oe_fd_t* desc,\n    const struct oe_iovec* iov,\n    int iovcnt)\n{\n    ssize_t ret = -1;\n    epoll_t* file = _cast_epoll(desc);\n    void* buf = NULL;\n    size_t buf_size = 0;\n\n    if (!file || (iovcnt && !iov) || iovcnt < 0 || iovcnt > OE_IOV_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_iov_pack(iov, iovcnt, &buf, &buf_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    if (oe_syscall_readv_ocall(&ret, file->host_fd, buf, iovcnt, buf_size) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    if (oe_iov_sync(iov, iovcnt, buf, buf_size) != 0)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}",
        "output": "1",
        "idx": 8010
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(DirectoryIterator, key)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (intern->u.dir.dirp) {\n\t\tRETURN_LONG(intern->u.dir.index);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}",
        "output": "0",
        "idx": 5571
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int set_evtchn_to_irq(evtchn_port_t evtchn, unsigned int irq)\n{\n\tunsigned row;\n\tunsigned col;\n\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -EINVAL;\n\n\trow = EVTCHN_ROW(evtchn);\n\tcol = EVTCHN_COL(evtchn);\n\n\tif (evtchn_to_irq[row] == NULL) {\n\t\tif (irq == -1)\n\t\t\treturn 0;\n\n\t\tevtchn_to_irq[row] = (int *)get_zeroed_page(GFP_KERNEL);\n\t\tif (evtchn_to_irq[row] == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tclear_evtchn_to_irq_row(row);\n\t}\n\n\tWRITE_ONCE(evtchn_to_irq[row][col], irq);\n\treturn 0;\n}",
        "output": "0",
        "idx": 2717
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void usb_serial_console_disconnect(struct usb_serial *serial)\n{\n\tif (serial->port[0] == usbcons_info.port) {\n\t\tusb_serial_console_exit();\n\t\tusb_serial_put(serial);\n\t}\n}",
        "output": "1",
        "idx": 1694
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct socket *sock;\n\tint err = 0;\n\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\tif (waitqueue_active(&asoc->wait))\n\t\treturn -EBUSY;\n\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\n\t*sockp = sock;\n\n\treturn err;\n}",
        "output": "0",
        "idx": 2171
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static RList* sections(RBinFile* bf) {\n\tRList* ret = NULL;\n\tRBinSection* sect = NULL;\n\tpsxexe_header psxheader = {0};\n\tut64 sz = 0;\n\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\n\tif (!(sect = R_NEW0 (RBinSection))) {\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, \"8c17i\", 1) < sizeof (psxexe_header)) {\n\t\teprintf (\"Truncated Header\\n\");\n\t\tfree (sect);\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\n\tsz = r_buf_size (bf->buf);\n\n\tsect->name = strdup (\"TEXT\");\n\tsect->paddr = PSXEXE_TEXTSECTION_OFFSET;\n\tsect->size = sz - PSXEXE_TEXTSECTION_OFFSET;\n\tsect->vaddr = psxheader.t_addr;\n\tsect->vsize = psxheader.t_size;\n\tsect->perm = R_PERM_RX;\n\tsect->add = true;\n\tsect->has_strings = true;\n\n\tr_list_append (ret, sect);\n\treturn ret;\n}",
        "output": "1",
        "idx": 6478
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pdf_t *pdf_new(const char *name)\n{\n    const char *n;\n    pdf_t      *pdf;\n   \n    pdf = calloc(1, sizeof(pdf_t));\n\n    if (name)\n    {\n        if ((n = strrchr(name, '/')))\n          ++n;\n        else\n          n = name;\n\n        pdf->name = malloc(strlen(n) + 1);\n        strcpy(pdf->name, n);\n    }\n    else \n    {\n        pdf->name = malloc(strlen(\"Unknown\") + 1);\n        strcpy(pdf->name, \"Unknown\");\n    }\n\n    return pdf;\n}",
        "output": "1",
        "idx": 7474
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void stellaris_enet_save(QEMUFile *f, void *opaque)\n{\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n    int i;\n\n    qemu_put_be32(f, s->ris);\n    qemu_put_be32(f, s->im);\n    qemu_put_be32(f, s->rctl);\n    qemu_put_be32(f, s->tctl);\n    qemu_put_be32(f, s->thr);\n    qemu_put_be32(f, s->mctl);\n    qemu_put_be32(f, s->mdv);\n    qemu_put_be32(f, s->mtxd);\n    qemu_put_be32(f, s->mrxd);\n    qemu_put_be32(f, s->np);\n    qemu_put_be32(f, s->tx_fifo_len);\n    qemu_put_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n    for (i = 0; i < 31; i++) {\n        qemu_put_be32(f, s->rx[i].len);\n        qemu_put_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n\n    }\n    qemu_put_be32(f, s->next_packet);\n    qemu_put_be32(f, s->rx_fifo_offset);\n}",
        "output": "1",
        "idx": 3784
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool cgm_bind_dir(const char *root, const char *dirname)\n{\n\tnih_local char *cgpath = NULL;\n\n\tcgpath = NIH_MUST( nih_strdup(NULL, root) );\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/sys/fs/cgroup\") );\n\n\tif (!dir_exists(cgpath)) {\n\t\tERROR(\"%s does not exist\", cgpath);\n\t\treturn false;\n\t}\n\n\tif (safe_mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\", root)) {\n\t\tSYSERROR(\"Failed to mount tmpfs at %s\", cgpath);\n\t\treturn false;\n\t}\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/cgmanager\") );\n\n\tif (mkdir(cgpath, 0755) < 0) {\n\t\tSYSERROR(\"Failed to create %s\", cgpath);\n\t\treturn false;\n\t}\n\n\tif (safe_mount(dirname, cgpath, \"none\", MS_BIND, 0, root)) {\n\t\tSYSERROR(\"Failed to bind mount %s to %s\", dirname, cgpath);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
        "output": "0",
        "idx": 6029
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\tif (sk_hashed(sk)) {\n\t\twrite_lock_bh(&ping_table.lock);\n\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsk_nulls_node_init(&sk->sk_nulls_node);\n\t\tsock_put(sk);\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t\twrite_unlock_bh(&ping_table.lock);\n\t}\n}",
        "output": "1",
        "idx": 1540
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\n\tscm->fp = UNIXCB(skb).fp;\n\tUNIXCB(skb).fp = NULL;\n\n\tfor (i = scm->fp->count-1; i >= 0; i--)\n\t\tunix_notinflight(scm->fp->user, scm->fp->fp[i]);\n}",
        "output": "0",
        "idx": 1585
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init fm10k_init_module(void)\n{\n\tpr_info(\"%s - version %s\\n\", fm10k_driver_string, fm10k_driver_version);\n\tpr_info(\"%s\\n\", fm10k_copyright);\n\n\tfm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0,\n\t\t\t\t\t  fm10k_driver_name);\n\tif (!fm10k_workqueue)\n\t\treturn -ENOMEM;\n\n\tfm10k_dbg_init();\n\n\treturn fm10k_register_pci_driver();\n}",
        "output": "0",
        "idx": 4295
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned int get_random_int(void)\n{\n\tstruct keydata *keyptr;\n\t__u32 *hash = get_cpu_var(get_random_int_hash);\n\tint ret;\n\n\tkeyptr = get_keyptr();\n\thash[0] += current->pid + jiffies + get_cycles();\n\n\tret = half_md4_transform(hash, keyptr->secret);\n\tput_cpu_var(get_random_int_hash);\n\n\treturn ret;\n}",
        "output": "1",
        "idx": 610
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(locale_get_display_script) \n{\n    get_icu_disp_value_src_php( LOC_SCRIPT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}",
        "output": "1",
        "idx": 3896
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void clientCopy(HttpRoute *route, MprJson *dest, MprJson *obj)\n{\n    MprJson     *child, *job, *jvalue;\n    cchar       *key, *value;\n    int         ji;\n\n    for (ITERATE_CONFIG(route, obj, child, ji)) {\n        if (child->type & MPR_JSON_OBJ) {\n            job = mprCreateJson(MPR_JSON_OBJ);\n            clientCopy(route, job, child);\n            mprSetJsonObj(dest, child->name, job);\n        } else {\n            key = child->value;\n            if (sends(key, \"|time\")) {\n                key = stok(sclone(key), \" \\t|\", NULL);\n                if ((value = mprGetJson(route->config, key)) != 0) {\n                    mprSetJson(dest, child->name, itos(httpGetTicks(value)));\n                }\n            } else {\n                if ((jvalue = mprGetJsonObj(route->config, key)) != 0) {\n                    mprSetJsonObj(dest, child->name, mprCloneJson(jvalue));\n                }\n            }\n        }\n    }\n}",
        "output": "1",
        "idx": 5026
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\n\tif (submodule_url_is_relative(url)) {\n\t\tchar *decoded;\n\t\tconst char *next;\n\t\tint has_nl;\n\n\t\tdecoded = url_decode(url);\n\t\thas_nl = !!strchr(decoded, '\\n');\n\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\n\t\tif (count_leading_dotdots(url, &next) > 0 &&\n\t\t    *next == ':')\n\t\t\treturn -1;\n\t}\n\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 7205
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "njs_async_function_frame_invoke(njs_vm_t *vm, njs_value_t *retval)\n{\n    njs_int_t                 ret;\n    njs_value_t               ctor;\n    njs_native_frame_t        *frame;\n    njs_promise_capability_t  *capability;\n\n    frame = vm->top_frame;\n    frame->retval = retval;\n\n    njs_set_function(&ctor, &vm->constructors[NJS_OBJ_TYPE_PROMISE]);\n\n    capability = njs_promise_new_capability(vm, &ctor);\n    if (njs_slow_path(capability == NULL)) {\n        return NJS_ERROR;\n    }\n\n    frame->function->context = capability;\n\n    ret = njs_function_lambda_call(vm);\n\n    if (ret == NJS_OK) {\n        ret = njs_function_call(vm, njs_function(&capability->resolve),\n                                &njs_value_undefined, retval, 1, &vm->retval);\n\n    } else if (ret == NJS_AGAIN) {\n        ret = NJS_OK;\n\n    } else if (ret == NJS_ERROR) {\n        if (njs_is_memory_error(vm, &vm->retval)) {\n            return NJS_ERROR;\n        }\n\n        ret = njs_function_call(vm, njs_function(&capability->reject),\n                                &njs_value_undefined, &vm->retval, 1,\n                                &vm->retval);\n    }\n\n    *retval = capability->promise;\n\n    return ret;\n}",
        "output": "1",
        "idx": 8874
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error = 0;\n\n\tif (!acl)\n\t\tgoto set_acl;\n\n\terror = -E2BIG;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\n\t\treturn error;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\n\t\tif (error <= 0) {\n\t\t\tacl = NULL;\n\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\terror = xfs_set_mode(inode, mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n set_acl:\n\treturn __xfs_set_acl(inode, type, acl);\n}",
        "output": "1",
        "idx": 1340
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rose_start_heartbeat(struct sock *sk)\n{\n\tsk_stop_timer(sk, &sk->sk_timer);\n\n\tsk->sk_timer.function = rose_heartbeat_expiry;\n\tsk->sk_timer.expires  = jiffies + 5 * HZ;\n\n\tsk_reset_timer(sk, &sk->sk_timer, sk->sk_timer.expires);\n}",
        "output": "0",
        "idx": 2951
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int pgx_validate(jas_stream_t *in)\n{\n\tuchar buf[PGX_MAGICLEN];\n\tuint_fast32_t magic;\n\tint i;\n\tint n;\n\n\tassert(JAS_STREAM_MAXPUTBACK >= PGX_MAGICLEN);\n\n\tif ((n = jas_stream_read(in, buf, PGX_MAGICLEN)) < 0) {\n\t\treturn -1;\n\t}\n\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (n < PGX_MAGICLEN) {\n\t\treturn -1;\n\t}\n\n\tmagic = (buf[0] << 8) | buf[1];\n\n\tif (magic != PGX_MAGIC) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 5416
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,\n\t\t\tint len)\n{\n\tint r;\n\tunsigned long addr;\n\n\taddr = gfn_to_hva(kvm, gfn);\n\tif (kvm_is_error_hva(addr))\n\t\treturn -EFAULT;\n\tr = __copy_from_user(data, (void __user *)addr + offset, len);\n\tif (r)\n\t\treturn -EFAULT;\n\treturn 0;\n}",
        "output": "0",
        "idx": 537
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC bool updateFields(cchar *tableName, MprJson *params)\n{\n    EdiRec  *rec;\n    cchar   *key;\n\n    key = mprReadJson(params, \"id\");\n    if ((rec = ediSetFields(ediReadRec(getDatabase(), tableName, key), params)) == 0) {\n        return 0;\n    }\n    return updateRec(rec);\n}",
        "output": "0",
        "idx": 6977
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int check_ptr_alignment(struct bpf_verifier_env *env,\n\t\t\t       const struct bpf_reg_state *reg,\n\t\t\t       int off, int size)\n{\n\tbool strict = env->strict_alignment;\n\tconst char *pointer_desc = \"\";\n\n\tswitch (reg->type) {\n\tcase PTR_TO_PACKET:\n\tcase PTR_TO_PACKET_META:\n\t\treturn check_pkt_ptr_alignment(env, reg, off, size, strict);\n\tcase PTR_TO_MAP_VALUE:\n\t\tpointer_desc = \"value \";\n\t\tbreak;\n\tcase PTR_TO_CTX:\n\t\tpointer_desc = \"context \";\n\t\tbreak;\n\tcase PTR_TO_STACK:\n\t\tpointer_desc = \"stack \";\n\t\tstrict = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn check_generic_ptr_alignment(env, reg, pointer_desc, off, size,\n\t\t\t\t\t   strict);\n}",
        "output": "0",
        "idx": 2615
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void lo_release(struct gendisk *disk, fmode_t mode)\n{\n\tstruct loop_device *lo = disk->private_data;\n\tint err;\n\n\tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\n\tmutex_unlock(&lo->lo_ctl_mutex);\n}",
        "output": "1",
        "idx": 1818
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n\n    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,\n\t\t\t       iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_get_mic_iov_length == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_get_mic_iov_length(minor_status, ctx->internal_ctx_id,\n\t\t\t\t\t  qop_req, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}",
        "output": "0",
        "idx": 281
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateString( const char *string )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item ) {\n\t\titem->type = cJSON_String;\n\t\titem->valuestring = cJSON_strdup( string );\n\t}\n\treturn item;\n}",
        "output": "1",
        "idx": 5902
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "toomany(struct magic_set *ms, const char *name, uint16_t num)\n{\n\tif (file_printf(ms, \", too many %s (%u)\", name, num\n\t    ) == -1)\n\t\treturn -1;\n\treturn 0;\n}",
        "output": "0",
        "idx": 6139
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cpStripToTile(uint8* out, uint8* in,\n    uint32 rows, uint32 cols, int outskew, int inskew)\n{\n\twhile (rows-- > 0) {\n\t\tuint32 j = cols;\n\t\twhile (j-- > 0)\n\t\t\t*out++ = *in++;\n\t\tout += outskew;\n\t\tin += inskew;\n\t}\n}",
        "output": "1",
        "idx": 4298
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "asmlinkage void do_ade(struct pt_regs *regs)\n{\n\tunsigned int __user *pc;\n\tmm_segment_t seg;\n\n\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS,\n\t\t\t1, regs, regs->cp0_badvaddr);\n\tif ((regs->cp0_badvaddr == regs->cp0_epc) || (regs->cp0_epc & 0x1))\n\t\tgoto sigbus;\n\n\tpc = (unsigned int __user *) exception_epc(regs);\n\tif (user_mode(regs) && !test_thread_flag(TIF_FIXADE))\n\t\tgoto sigbus;\n\tif (unaligned_action == UNALIGNED_ACTION_SIGNAL)\n\t\tgoto sigbus;\n\telse if (unaligned_action == UNALIGNED_ACTION_SHOW)\n\t\tshow_registers(regs);\n\n\tseg = get_fs();\n\tif (!user_mode(regs))\n\t\tset_fs(KERNEL_DS);\n\temulate_load_store_insn(regs, (void __user *)regs->cp0_badvaddr, pc);\n\tset_fs(seg);\n\n\treturn;\n\nsigbus:\n\tdie_if_kernel(\"Kernel unaligned instruction access\", regs);\n\tforce_sig(SIGBUS, current);\n\n}",
        "output": "0",
        "idx": 591
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n{\n  size_t alloc = (inlength?(size_t)inlength:strlen(string))+1;\n  char *ns;\n  char *testing_ptr = NULL;\n  unsigned char in; \n  size_t newlen = alloc;\n  int strindex=0;\n  size_t length;\n  CURLcode res;\n\n  ns = malloc(alloc);\n  if(!ns)\n    return NULL;\n\n  length = alloc-1;\n  while(length--) {\n    in = *string;\n\n    if(Curl_isunreserved(in))\n      ns[strindex++]=in;\n    else {\n      newlen += 2; \n      if(newlen > alloc) {\n        alloc *= 2;\n        testing_ptr = realloc(ns, alloc);\n        if(!testing_ptr) {\n          free( ns );\n          return NULL;\n        }\n        else {\n          ns = testing_ptr;\n        }\n      }\n\n      res = Curl_convert_to_network(handle, &in, 1);\n      if(res) {\n        free(ns);\n        return NULL;\n      }\n\n      snprintf(&ns[strindex], 4, \"%%%02X\", in);\n\n      strindex+=3;\n    }\n    string++;\n  }\n  ns[strindex]=0; \n  return ns;\n}",
        "output": "1",
        "idx": 3588
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_hrtimer_stop(struct snd_timer *t)\n{\n\tstruct snd_hrtimer *stime = t->private_data;\n\tatomic_set(&stime->running, 0);\n\thrtimer_try_to_cancel(&stime->hrt);\n\treturn 0;\n}",
        "output": "0",
        "idx": 1547
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "INTERNAL void vterm_screen_free(VTermScreen *screen)\n{\n  vterm_allocator_free(screen->vt, screen->buffers[0]);\n  vterm_allocator_free(screen->vt, screen->buffers[1]);\n  vterm_allocator_free(screen->vt, screen->sb_buffer);\n  vterm_allocator_free(screen->vt, screen);\n}",
        "output": "0",
        "idx": 8143
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int n_tty_ioctl(struct tty_struct *tty, struct file *file,\n\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint retval;\n\n\tswitch (cmd) {\n\tcase TIOCOUTQ:\n\t\treturn put_user(tty_chars_in_buffer(tty), (int __user *) arg);\n\tcase TIOCINQ:\n\t\tdown_write(&tty->termios_rwsem);\n\t\tif (L_ICANON(tty) && !L_EXTPROC(tty))\n\t\t\tretval = inq_canon(ldata);\n\t\telse\n\t\t\tretval = read_cnt(ldata);\n\t\tup_write(&tty->termios_rwsem);\n\t\treturn put_user(retval, (unsigned int __user *) arg);\n\tdefault:\n\t\treturn n_tty_ioctl_helper(tty, file, cmd, arg);\n\t}\n}",
        "output": "0",
        "idx": 2627
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int isansicode(int x)\n{\n    return x == 0x1B || x == 0x0A || x == 0x0D || (x >= 0x20 && x < 0x7f);\n}",
        "output": "0",
        "idx": 4801
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void* ipc_rcu_alloc(int size)\n{\n\tvoid* out;\n\tif (rcu_use_vmalloc(size)) {\n\t\tout = vmalloc(HDRLEN_VMALLOC + size);\n\t\tif (out) {\n\t\t\tout += HDRLEN_VMALLOC;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 1;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->refcount = 1;\n\t\t}\n\t} else {\n\t\tout = kmalloc(HDRLEN_KMALLOC + size, GFP_KERNEL);\n\t\tif (out) {\n\t\t\tout += HDRLEN_KMALLOC;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 0;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->refcount = 1;\n\t\t}\n\t}\n\n\treturn out;\n}",
        "output": "1",
        "idx": 2284
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int __cil_build_ast_first_child_helper(__attribute__((unused)) struct cil_tree_node *parse_current, void *extra_args)\n{\n\tstruct cil_args_build *args = extra_args;\n\tstruct cil_tree_node *ast = args->ast;\n\n\tif (ast->flavor == CIL_TUNABLEIF) {\n\t\targs->tunif = ast;\n\t}\n\n\tif (ast->flavor == CIL_IN) {\n\t\targs->in = ast;\n\t}\n\n\tif (ast->flavor == CIL_MACRO) {\n\t\targs->macro = ast;\n\t}\n\n\tif (ast->flavor == CIL_OPTIONAL) {\n\t\targs->optional = ast;\n\t}\n\n\tif (ast->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = ast;\n\t}\n\n\treturn SEPOL_OK;\n}",
        "output": "0",
        "idx": 8491
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static cache_accel_t *read_cache_accel(RBuffer *cache_buf, cache_hdr_t *hdr, cache_map_t *maps) {\n\tif (!cache_buf || !hdr || !hdr->accelerateInfoSize || !hdr->accelerateInfoAddr) {\n\t\treturn NULL;\n\t}\n\n\tut64 offset = va2pa (hdr->accelerateInfoAddr, hdr->mappingCount, maps, cache_buf, 0, NULL, NULL);\n\tif (!offset) {\n\t\treturn NULL;\n\t}\n\n\tut64 size = sizeof (cache_accel_t);\n\tcache_accel_t *accel = R_NEW0 (cache_accel_t);\n\tif (!accel) {\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_fread_at (cache_buf, offset, (ut8*) accel, \"16il\", 1) != size) {\n\t\tR_FREE (accel);\n\t\treturn NULL;\n\t}\n\n\taccel->imagesExtrasOffset += offset;\n\taccel->bottomUpListOffset += offset;\n\taccel->dylibTrieOffset += offset;\n\taccel->initializersOffset += offset;\n\taccel->dofSectionsOffset += offset;\n\taccel->reExportListOffset += offset;\n\taccel->depListOffset += offset;\n\taccel->rangeTableOffset += offset;\n\n\treturn accel;\n}",
        "output": "1",
        "idx": 6456
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void br_multicast_del_pg(struct net_bridge *br,\n\t\t\t\tstruct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\n\tmp = br_mdb_ip_get(mdb, &pg->addr);\n\tif (WARN_ON(!mp))\n\t\treturn;\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p != pg)\n\t\t\tcontinue;\n\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\n\t\tif (!mp->ports && !mp->mglist &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\n\t\treturn;\n\t}\n\n\tWARN_ON(1);\n}",
        "output": "1",
        "idx": 2318
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int cil_build_ast(struct cil_db *db, struct cil_tree_node *parse_tree, struct cil_tree_node *ast)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_build extra_args;\n\n\tif (db == NULL || parse_tree == NULL || ast == NULL) {\n\t\tgoto exit;\n\t}\n\n\textra_args.ast = ast;\n\textra_args.db = db;\n\textra_args.tunif = NULL;\n\textra_args.in = NULL;\n\textra_args.macro = NULL;\n\textra_args.optional = NULL;\n\textra_args.boolif = NULL;\n\n\trc = cil_tree_walk(parse_tree, __cil_build_ast_node_helper, __cil_build_ast_first_child_helper, __cil_build_ast_last_child_helper, &extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\n\treturn SEPOL_OK;\n\nexit:\n\treturn rc;\n}",
        "output": "0",
        "idx": 8489
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "videobuf_vm_open(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\n\tdprintk(2,\"vm_open %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\n\tmap->count++;\n}",
        "output": "1",
        "idx": 2078
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline unsigned long get_tpuser(void)\n{\n\tunsigned long reg = 0;\n\n\tif (has_tls_reg && !tls_emu)\n\t\t__asm__(\"mrc p15, 0, %0, c13, c0, 2\" : \"=r\" (reg));\n\n\treturn reg;\n}",
        "output": "0",
        "idx": 3255
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int target_xcopy_locate_se_dev_e4(const unsigned char *dev_wwn,\n\t\t\t\t\tstruct se_device **found_dev)\n{\n\tstruct xcopy_dev_search_info info;\n\tint ret;\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.dev_wwn = dev_wwn;\n\n\tret = target_for_each_device(target_xcopy_locate_se_dev_e4_iter, &info);\n\tif (ret == 1) {\n\t\t*found_dev = info.found_dev;\n\t\treturn 0;\n\t} else {\n\t\tpr_debug_ratelimited(\"Unable to locate 0xe4 descriptor for EXTENDED_COPY\\n\");\n\t\treturn -EINVAL;\n\t}\n}",
        "output": "1",
        "idx": 1918
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spl_filesystem_dir_it_move_forward(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n\n\tobject->u.dir.index++;\n\tspl_filesystem_dir_read(object TSRMLS_CC);\n\tif (object->file_name) {\n\t\tefree(object->file_name);\n\t\tobject->file_name = NULL;\n\t}\n}",
        "output": "0",
        "idx": 5519
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\n\tif ((!cpu_has_feature(CPU_FTR_TM)) || (tsk != current))\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&(tsk->thread));\n\t}\n}",
        "output": "0",
        "idx": 2403
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nsc_encode_sse2(NSC_CONTEXT* context, const BYTE* data,\n                            UINT32 scanline)\n{\n\tnsc_encode_argb_to_aycocg_sse2(context, data, scanline);\n\n\tif (context->ChromaSubsamplingLevel > 0)\n\t{\n\t\tnsc_encode_subsampling_sse2(context);\n\t}\n}",
        "output": "1",
        "idx": 4230
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline Quantum GetPixelChannel(const Image *magick_restrict image,\n  const PixelChannel channel,const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[channel].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[channel].offset]);\n}",
        "output": "1",
        "idx": 5178
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static cchar *setHeadersFromCache(HttpConn *conn, cchar *content)\n{\n    cchar   *data;\n    char    *header, *headers, *key, *value, *tok;\n\n    if ((data = strstr(content, \"\\n\\n\")) == 0) {\n        data = content;\n    } else {\n        headers = snclone(content, data - content);\n        data += 2;\n        for (header = stok(headers, \"\\n\", &tok); header; header = stok(NULL, \"\\n\", &tok)) {\n            key = ssplit(header, \": \", &value);\n            if (smatch(key, \"X-Status\")) {\n                conn->tx->status = (int) stoi(value);\n            } else {\n                httpAddHeaderString(conn, key, value);\n            }\n        }\n    }\n    return data;\n}",
        "output": "0",
        "idx": 7053
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "juniper_services_print(netdissect_options *ndo,\n                       const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        struct juniper_services_header {\n            uint8_t svc_id;\n            uint8_t flags_len;\n            uint8_t svc_set_id[2];\n            uint8_t dir_iif[4];\n        };\n        const struct juniper_services_header *sh;\n\n        l2info.pictype = DLT_JUNIPER_SERVICES;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n\n        p+=l2info.header_len;\n        sh = (const struct juniper_services_header *)p;\n\n        ND_TCHECK(*sh);\n        if (ndo->ndo_eflag)\n            ND_PRINT((ndo, \"service-id %u flags 0x%02x service-set-id 0x%04x iif %u: \",\n                   sh->svc_id,\n                   sh->flags_len,\n                   EXTRACT_16BITS(&sh->svc_set_id),\n                   EXTRACT_24BITS(&sh->dir_iif[1])));\n\n        ip_heuristic_guess (ndo, p, l2info.length);\n\n        return l2info.header_len;\n\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_services]\"));\n\treturn l2info.header_len;\n}",
        "output": "0",
        "idx": 6613
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void virtio_config_writel(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val = data;\n\n    if (addr > (vdev->config_len - sizeof(val)))\n        return;\n\n    stl_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}",
        "output": "1",
        "idx": 3768
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *arm_coherent_dma_alloc(struct device *dev, size_t size,\n\tdma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)\n{\n\tpgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);\n\tvoid *memory;\n\n\tif (dma_alloc_from_coherent(dev, size, handle, &memory))\n\t\treturn memory;\n\n\treturn __dma_alloc(dev, size, handle, gfp, prot, true,\n\t\t\t   __builtin_return_address(0));\n}",
        "output": "1",
        "idx": 2346
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rs_filter_graph(RSFilter *filter)\n{\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\tGString *str = g_string_new(\"digraph G {\\n\");\n\n\trs_filter_graph_helper(str, filter);\n\n\tg_string_append_printf(str, \"}\\n\");\n\tg_file_set_contents(\"/tmp/rs-filter-graph\", str->str, str->len, NULL);\n\n\tif (0 != system(\"dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph\"))\n\t\tg_warning(\"Calling dot failed\");\n\tif (0 != system(\"gnome-open /tmp/rs-filter-graph.png\"))\n\t\tg_warning(\"Calling gnome-open failed.\");\n\n\tg_string_free(str, TRUE);\n}",
        "output": "1",
        "idx": 4598
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Expr *sqlite3CreateColumnExpr(sqlite3 *db, SrcList *pSrc, int iSrc, int iCol){\n  Expr *p = sqlite3ExprAlloc(db, TK_COLUMN, 0, 0);\n  if( p ){\n    struct SrcList_item *pItem = &pSrc->a[iSrc];\n    p->y.pTab = pItem->pTab;\n    p->iTable = pItem->iCursor;\n    if( p->y.pTab->iPKey==iCol ){\n      p->iColumn = -1;\n    }else{\n      p->iColumn = (ynVar)iCol;\n      testcase( iCol==BMS );\n      testcase( iCol==BMS-1 );\n      pItem->colUsed |= ((Bitmask)1)<<(iCol>=BMS ? BMS-1 : iCol);\n    }\n  }\n  return p;\n}",
        "output": "1",
        "idx": 7640
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static  RFlagsAtOffset* r_flag_get_nearest_list(RFlag *f, ut64 off, int dir) {\n\tRFlagsAtOffset *flags = NULL;\n\tRFlagsAtOffset key;\n\tkey.off = off;\n\tif (dir >= 0) {\n\t\tflags = r_skiplist_get_geq (f->by_off, &key);\n\t} else {\n\t\tflags = r_skiplist_get_leq (f->by_off, &key);\n\t}\n\tif (dir == 0 && flags && flags->off != off) {\n\t\treturn NULL;\n\t}\n\treturn flags;\n}",
        "output": "1",
        "idx": 6176
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n{\n\tunsigned char *buf;\n\n\tassert(m->buf_);\n\tassert(bufsize >= 0);\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) {\n\t\treturn -1;\n\t}\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}",
        "output": "1",
        "idx": 5348
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void flush_tlb_page(struct vm_area_struct *vma, unsigned long start)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tpreempt_disable();\n\n\tif (current->active_mm == mm) {\n\t\tif (current->mm)\n\t\t\t__flush_tlb_one(start);\n\t\telse\n\t\t\tleave_mm(smp_processor_id());\n\t}\n\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, start, 0UL);\n\n\tpreempt_enable();\n}",
        "output": "1",
        "idx": 1032
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&\n\t\t    key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\n\t\tsecurity_key_free(key);\n\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\n\t\tkey_user_put(key->user);\n\n\t\tkfree(key->description);\n\n#ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}",
        "output": "0",
        "idx": 4043
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\n\t*data = &iterator->current;\n}",
        "output": "0",
        "idx": 5471
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tut8 op_MSB,op_LSB;\n\tint ret;\n\tif (!data)\n\t\treturn 0;\n\tmemset (op, '\\0', sizeof (RAnalOp));\n\top->addr = addr;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->jump = op->fail = -1;\n\top->ptr = op->val = -1;\n\n\top->size = 2;\n\n\top_MSB = anal->big_endian? data[0]: data[1];\n\top_LSB = anal->big_endian? data[1]: data[0];\n\tret =  first_nibble_decode[(op_MSB>>4) & 0x0F](anal, op, (ut16)(op_MSB<<8 | op_LSB));\n\treturn ret;\n}",
        "output": "1",
        "idx": 6188
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_gets (SF_PRIVATE *psf, char *ptr, int bufsize)\n{\tint\t\tk ;\n\n\tif (psf->header.indx + bufsize >= psf->header.len && psf_bump_header_allocation (psf, bufsize))\n\t\treturn 0 ;\n\n\tfor (k = 0 ; k < bufsize - 1 ; k++)\n\t{\tif (psf->header.indx < psf->header.end)\n\t\t{\tptr [k] = psf->header.ptr [psf->header.indx] ;\n\t\t\tpsf->header.indx ++ ;\n\t\t\t}\n\t\telse\n\t\t{\tpsf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, 1, psf) ;\n\t\t\tptr [k] = psf->header.ptr [psf->header.indx] ;\n\t\t\tpsf->header.indx = psf->header.end ;\n\t\t\t} ;\n\n\t\tif (ptr [k] == '\\n')\n\t\t\tbreak ;\n\t\t} ;\n\n\tptr [k] = 0 ;\n\n\treturn k ;\n} ",
        "output": "0",
        "idx": 6877
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline ut32 r_read_le32(const void *src) {\n\tif (!src) {\n\t\treturn UT32_MAX;\n\t}\n\tconst ut8 *s = (const ut8*)src;\n\treturn (((ut32)s[3]) << 24) | (((ut32)s[2]) << 16) |\n\t\t(((ut32)s[1]) << 8) | (((ut32)s[0]) << 0);\n}",
        "output": "0",
        "idx": 8607
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Jsi_RC DebugRemoveCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, int op)\n{\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    if (interp->breakpointHash)\n    {\n        int num;\n        char nbuf[100];\n        if (Jsi_GetIntFromValue(interp, val, &num) != JSI_OK) \n            return Jsi_LogError(\"bad number\");\n        \n        snprintf(nbuf, sizeof(nbuf), \"%d\", num);\n        Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->breakpointHash, nbuf);\n        jsi_BreakPoint* bptr;\n        if (hPtr && (bptr = (jsi_BreakPoint*)Jsi_HashValueGet(hPtr))) {\n            switch (op) {\n                case 1: bptr->enabled = 0; break;\n                case 2: bptr->enabled = 1; break;\n                default:\n                    Jsi_HashEntryDelete(hPtr);\n            }\n            return JSI_OK;\n        }\n    }\n    return Jsi_LogError(\"unknown breakpoint\");\n}",
        "output": "1",
        "idx": 8172
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "new_identifier(const char *n, struct compiling *c)\n{\n    PyObject *id = PyUnicode_DecodeUTF8(n, strlen(n), NULL);\n    if (!id)\n        return NULL;\n    assert(PyUnicode_IS_READY(id));\n    if (!PyUnicode_IS_ASCII(id)) {\n        PyObject *id2;\n        if (!c->c_normalize && !init_normalization(c)) {\n            Py_DECREF(id);\n            return NULL;\n        }\n        PyTuple_SET_ITEM(c->c_normalize_args, 1, id);\n        id2 = PyObject_Call(c->c_normalize, c->c_normalize_args, NULL);\n        Py_DECREF(id);\n        if (!id2)\n            return NULL;\n        id = id2;\n    }\n    PyUnicode_InternInPlace(&id);\n    if (PyArena_AddPyObject(c->c_arena, id) < 0) {\n        Py_DECREF(id);\n        return NULL;\n    }\n    return id;\n}",
        "output": "1",
        "idx": 7778
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_show_object(struct object *object,\n\t\t\t     struct strbuf *path,\n\t\t\t     const char *last, void *data)\n{\n\tstruct bitmap_test_data *tdata = data;\n\tint bitmap_pos;\n\n\tbitmap_pos = bitmap_position(object->oid.hash);\n\tif (bitmap_pos < 0)\n\t\tdie(\"Object not in bitmap: %s\\n\", oid_to_hex(&object->oid));\n\n\tbitmap_set(tdata->base, bitmap_pos);\n\tdisplay_progress(tdata->prg, ++tdata->seen);\n}",
        "output": "1",
        "idx": 5202
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct pid *good_sigevent(sigevent_t * event)\n{\n\tstruct task_struct *rtn = current->group_leader;\n\n\tif ((event->sigev_notify & SIGEV_THREAD_ID ) &&\n\t\t(!(rtn = find_task_by_vpid(event->sigev_notify_thread_id)) ||\n\t\t !same_thread_group(rtn, current) ||\n\t\t (event->sigev_notify & ~SIGEV_THREAD_ID) != SIGEV_SIGNAL))\n\t\treturn NULL;\n\n\tif (((event->sigev_notify & ~SIGEV_THREAD_ID) != SIGEV_NONE) &&\n\t    ((event->sigev_signo <= 0) || (event->sigev_signo > SIGRTMAX)))\n\t\treturn NULL;\n\n\treturn task_pid(rtn);\n}",
        "output": "1",
        "idx": 1794
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void\tcJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)\t\t\t\t\t\t{cJSON_AddItemToArray(array,create_reference(item));}",
        "output": "0",
        "idx": 8285
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n{\n\tif (file->f_flags & O_DSYNC)\n\t\treturn 0;\n\tif (!nfs_write_pageuptodate(page, inode))\n\t\treturn 0;\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n\t\treturn 1;\n\tif (inode->i_flock == NULL || (inode->i_flock->fl_start == 0 &&\n\t\t\tinode->i_flock->fl_end == OFFSET_MAX &&\n\t\t\tinode->i_flock->fl_type != F_RDLCK))\n\t\treturn 1;\n\treturn 0;\n}",
        "output": "0",
        "idx": 3453
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void sctp_generate_proto_unreach_event(unsigned long data)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) data;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\n\t\tif (!mod_timer(&transport->proto_unreach_timer,\n\t\t\t\tjiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\n\tsctp_do_sm(net, SCTP_EVENT_T_OTHER,\n\t\t   SCTP_ST_OTHER(SCTP_EVENT_ICMP_PROTO_UNREACH),\n\t\t   asoc->state, asoc->ep, asoc, transport, GFP_ATOMIC);\n\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_association_put(asoc);\n}",
        "output": "1",
        "idx": 2914
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateString(const char *string)\t{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);if(!item->valuestring){cJSON_Delete(item);return 0;}}return item;}",
        "output": "0",
        "idx": 8263
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void vma_adjust_trans_huge(struct vm_area_struct *vma,\n\t\t\t\t\t unsigned long start,\n\t\t\t\t\t unsigned long end,\n\t\t\t\t\t long adjust_next)\n{\n\tif (!vma->anon_vma || vma->vm_ops)\n\t\treturn;\n\t__vma_adjust_trans_huge(vma, start, end, adjust_next);\n}",
        "output": "0",
        "idx": 441
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void flush_cmd(void)\n{\n    scanned = readnbd = (size_t) 0U;\n}",
        "output": "0",
        "idx": 4737
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BOOL license_read_scope_list(wStream* s, SCOPE_LIST* scopeList)\n{\n\tUINT32 i;\n\tUINT32 scopeCount;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT32(s, scopeCount); \n\n        if (Stream_GetRemainingLength(s) / sizeof(LICENSE_BLOB) < scopeCount)\n                return FALSE;  \n\n\tscopeList->count = scopeCount;\n\tscopeList->array = (LICENSE_BLOB*) malloc(sizeof(LICENSE_BLOB) * scopeCount);\n\n\tfor (i = 0; i < scopeCount; i++)\n\t{\n\t\tscopeList->array[i].type = BB_SCOPE_BLOB;\n\n\t\tif (!license_read_binary_blob(s, &scopeList->array[i]))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
        "output": "0",
        "idx": 6317
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void esp32EthEnableIrq(NetInterface *interface)\n{\n\n   if(interface->phyDriver != NULL)\n   {\n      interface->phyDriver->enableIrq(interface);\n   }\n   else if(interface->switchDriver != NULL)\n   {\n      interface->switchDriver->enableIrq(interface);\n   }\n   else\n   {\n   }\n}",
        "output": "1",
        "idx": 8584
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void x86_assign_hw_event(struct perf_event *event,\n\t\t\t\tstruct cpu_hw_events *cpuc, int i)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\thwc->idx = cpuc->assign[i];\n\thwc->last_cpu = smp_processor_id();\n\thwc->last_tag = ++cpuc->tags[i];\n\n\tif (hwc->idx == X86_PMC_IDX_FIXED_BTS) {\n\t\thwc->config_base = 0;\n\t\thwc->event_base\t= 0;\n\t} else if (hwc->idx >= X86_PMC_IDX_FIXED) {\n\t\thwc->config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL;\n\t\thwc->event_base = MSR_ARCH_PERFMON_FIXED_CTR0 + (hwc->idx - X86_PMC_IDX_FIXED);\n\t} else {\n\t\thwc->config_base = x86_pmu_config_addr(hwc->idx);\n\t\thwc->event_base  = x86_pmu_event_addr(hwc->idx);\n\t}\n}",
        "output": "0",
        "idx": 379
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseAuthUsers(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprJson     *child;\n    cchar       *roles, *password;\n    int         ji;\n\n    for (ITERATE_CONFIG(route, prop, child, ji)) {\n        password = mprReadJson(child, \"password\");\n        roles = getList(mprReadJsonObj(child, \"roles\"));\n        if (httpAddUser(route->auth, child->name, password, roles) < 0) {\n            httpParseError(route, \"Cannot add user %s\", child->name);\n            break;\n        }\n        if (!route->auth->store) {\n            httpSetAuthStore(route->auth, \"config\");\n        }\n    }\n}",
        "output": "0",
        "idx": 7015
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void doPost(HttpRequest req, HttpResponse res) {\n        set_content_type(res, \"text/html\");\n        if (ACTION(RUNTIME))\n                handle_runtime_action(req, res);\n        else if (ACTION(VIEWLOG))\n                do_viewlog(req, res);\n        else if (ACTION(STATUS))\n                print_status(req, res, 1);\n        else if (ACTION(STATUS2))\n                print_status(req, res, 2);\n        else if (ACTION(SUMMARY))\n                print_summary(req, res);\n        else if (ACTION(REPORT))\n                _printReport(req, res);\n        else if (ACTION(DOACTION))\n                handle_doaction(req, res);\n        else\n                handle_service_action(req, res);\n}",
        "output": "0",
        "idx": 8425
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int _mkp_stage_30(struct plugin *p,\n        struct client_session *cs,\n        struct session_request *sr)\n{\n    mk_ptr_t referer;\n    (void) p;\n    (void) cs;\n\n    PLUGIN_TRACE(\"[FD %i] Mandril validating URL\", cs->socket);\n    if (mk_security_check_url(sr->uri) < 0) {\n        PLUGIN_TRACE(\"[FD %i] Close connection, blocked URL\", cs->socket);\n        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n\n    PLUGIN_TRACE(\"[FD %d] Mandril validating hotlinking\", cs->socket);\n    referer = mk_api->header_get(&sr->headers_toc, \"Referer\", strlen(\"Referer\"));\n    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {\n        PLUGIN_TRACE(\"[FD %i] Close connection, deny hotlinking.\", cs->socket);\n        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n\n    return MK_PLUGIN_RET_NOT_ME;\n}",
        "output": "1",
        "idx": 3808
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo *hdr;\n    int err;\n\n    if (!*phdr)\n        *phdr = av_mallocz(sizeof(AC3HeaderInfo));\n    if (!*phdr)\n        return AVERROR(ENOMEM);\n    hdr = *phdr;\n\n    err = init_get_bits8(&gb, buf, size);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n    err = ff_ac3_parse_header(&gb, hdr);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n\n    return get_bits_count(&gb);\n}",
        "output": "0",
        "idx": 4751
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_delete_sec_context(\n\t\t\t    OM_uint32 *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t output_token)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\tspnego_gss_ctx_id_t *ctx =\n\t\t    (spnego_gss_ctx_id_t *)context_handle;\n\n\t*minor_status = 0;\n\n\tif (context_handle == NULL)\n\t\treturn (GSS_S_FAILURE);\n\n\tif (*ctx == NULL)\n\t\treturn (GSS_S_COMPLETE);\n\n\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n\t\t(void) gss_delete_sec_context(minor_status,\n\t\t\t\t    &(*ctx)->ctx_handle,\n\t\t\t\t    output_token);\n\t\t(void) release_spnego_ctx(ctx);\n\t} else {\n\t\tret = gss_delete_sec_context(minor_status,\n\t\t\t\t    context_handle,\n\t\t\t\t    output_token);\n\t}\n\n\treturn (ret);\n}",
        "output": "1",
        "idx": 110
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "entry_guard_obeys_restriction(const entry_guard_t *guard,\n                              const entry_guard_restriction_t *rst)\n{\n  tor_assert(guard);\n  if (! rst)\n    return 1; \n\n  return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN);\n}",
        "output": "1",
        "idx": 6070
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static entity_table_opt determine_entity_table(int all, int doctype)\n{\n\tentity_table_opt retval = {NULL};\n\n\tassert(!(doctype == ENT_HTML_DOC_XML1 && all));\n\t\n\tif (all) {\n\t\tretval.ms_table = (doctype == ENT_HTML_DOC_HTML5) ?\n\t\t\tentity_ms_table_html5 : entity_ms_table_html4;\n\t} else {\n\t\tretval.table = (doctype == ENT_HTML_DOC_HTML401) ?\n\t\t\tstage3_table_be_noapos_00000 : stage3_table_be_apos_00000;\n\t}\n\treturn retval;\n}",
        "output": "1",
        "idx": 3850
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void suffix_object( cJSON *prev, cJSON *item )\n{\n\tprev->next = item;\n\titem->prev = prev;\n}",
        "output": "1",
        "idx": 5908
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "__be32 ipv6_select_ident(struct net *net,\n\t\t\t const struct in6_addr *daddr,\n\t\t\t const struct in6_addr *saddr)\n{\n\tstatic u32 ip6_idents_hashrnd __read_mostly;\n\tu32 id;\n\n\tnet_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));\n\n\tid = __ipv6_select_ident(net, ip6_idents_hashrnd, daddr, saddr);\n\treturn htonl(id);\n}",
        "output": "1",
        "idx": 3128
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "le64addr_string(netdissect_options *ndo, const u_char *ep)\n{\n\tconst unsigned int len = 8;\n\tregister u_int i;\n\tregister char *cp;\n\tregister struct bsnamemem *tp;\n\tchar buf[BUFSIZE];\n\n\ttp = lookup_bytestring(ndo, ep, len);\n\tif (tp->bs_name)\n\t\treturn (tp->bs_name);\n\n\tcp = buf;\n\tfor (i = len; i > 0 ; --i) {\n\t\t*cp++ = hex[*(ep + i - 1) >> 4];\n\t\t*cp++ = hex[*(ep + i - 1) & 0xf];\n\t\t*cp++ = ':';\n\t}\n\tcp --;\n\n\t*cp = '\\0';\n\n\ttp->bs_name = strdup(buf);\n\tif (tp->bs_name == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"le64addr_string: strdup(buf)\");\n\n\treturn (tp->bs_name);\n}",
        "output": "0",
        "idx": 6579
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char* get_private_subtags(const char* loc_name)\n{\n\tchar* \tresult =NULL;\n\tint \tsingletonPos = 0;\n\tint \tlen =0; \n\tconst char* \tmod_loc_name =NULL;\n\n\tif( loc_name && (len = strlen(loc_name)>0 ) ){\n\t\tmod_loc_name = loc_name ; \n\t\tlen   = strlen(mod_loc_name);\n\t\twhile( (singletonPos = getSingletonPos(mod_loc_name))!= -1){\n\n\t\t\tif( singletonPos!=-1){ \n\t\t\t\tif( (*(mod_loc_name+singletonPos)=='x') || (*(mod_loc_name+singletonPos)=='X') ){\t\t\n\t\t\t\t\tif( singletonPos + 2 ==  len){\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tresult = estrndup(mod_loc_name + singletonPos+2  , (len -( singletonPos +2) ) );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif( singletonPos + 1 >=  len){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmod_loc_name = mod_loc_name + singletonPos +1;\n\t\t\t\t\t\tlen = strlen(mod_loc_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} \n\t}\n\t\n\treturn result;\n}",
        "output": "1",
        "idx": 3886
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int async_polkit_defer(sd_event_source *s, void *userdata) {\n        AsyncPolkitQuery *q = userdata;\n\n        assert(s);\n\n\n        async_polkit_query_free(q);\n        return 0;\n}",
        "output": "0",
        "idx": 7693
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void gdImageJpegCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\t_gdImageJpegCtx(im, outfile, quality);\n}",
        "output": "0",
        "idx": 5697
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "validate_xargs(krb5_context context,\n               krb5_ldap_server_handle *ldap_server_handle,\n               const xargs_t *xargs, const char *standalone_dn,\n               char *const *subtrees, unsigned int ntrees)\n{\n    krb5_error_code st;\n\n    if (xargs->dn != NULL) {\n        st = check_dn_in_container(context, xargs->dn, subtrees, ntrees);\n        if (st)\n            return st;\n        st = check_dn_exists(context, ldap_server_handle, xargs->dn, TRUE);\n        if (st)\n            return st;\n    }\n\n    if (xargs->linkdn != NULL) {\n        st = check_dn_in_container(context, xargs->linkdn, subtrees, ntrees);\n        if (st)\n            return st;\n        st = check_dn_exists(context, ldap_server_handle, xargs->linkdn,\n                             FALSE);\n        if (st)\n            return st;\n    }\n\n    if (xargs->containerdn != NULL && standalone_dn != NULL) {\n        st = check_dn_in_container(context, standalone_dn, subtrees, ntrees);\n        if (st)\n            return st;\n    }\n\n    return 0;\n}",
        "output": "0",
        "idx": 297
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iakerb_gss_set_sec_context_option(OM_uint32 *minor_status,\n                                  gss_ctx_id_t *context_handle,\n                                  const gss_OID desired_object,\n                                  const gss_buffer_t value)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;\n\n    if (ctx == NULL || ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_UNAVAILABLE;\n\n    return krb5_gss_set_sec_context_option(minor_status, &ctx->gssc,\n                                           desired_object, value);\n}",
        "output": "0",
        "idx": 131
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jas_stream_t *jas_stream_memopen(char *buf, int bufsize)\n{\n\tchar *new_buf;\n\tsize_t new_bufsize;\n\n\tJAS_DBGLOG(100, (\"jas_stream_memopen(%p, %d)\\n\", buf, bufsize));\n\tif (bufsize < 0) {\n\t\tjas_deprecated(\"negative buffer size for jas_stream_memopen\");\n\t}\n\tif (buf && bufsize <= 0) {\n\t\tjas_eprintf(\"Invalid use of jas_stream_memopen detected.\\n\");\n\t\tjas_deprecated(\"A user-provided buffer for \"\n\t\t  \"jas_stream_memopen cannot be growable.\\n\");\n\t}\n\tif (bufsize <= 0) {\n\t\tnew_bufsize = 0;\n\t\tnew_buf = 0;\n\t} else {\n\t\tnew_bufsize = bufsize;\n\t\tnew_buf = buf;\n\t}\n\treturn jas_stream_memopen2(new_buf, new_bufsize);\n}",
        "output": "0",
        "idx": 7533
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int handle_emulation_failure(struct kvm_vcpu *vcpu)\n{\n\tint r = EMULATE_DONE;\n\n\t++vcpu->stat.insn_emulation_fail;\n\ttrace_kvm_emulate_insn_failed(vcpu);\n\tif (!is_guest_mode(vcpu) && kvm_x86_ops->get_cpl(vcpu) == 0) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\tr = EMULATE_FAIL;\n\t}\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\n\treturn r;\n}",
        "output": "0",
        "idx": 3695
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void luaT_getvarargs (lua_State *L, CallInfo *ci, StkId where, int wanted) {\n  int i;\n  int nextra = ci->u.l.nextraargs;\n  if (wanted < 0) {\n    wanted = nextra;  \n    checkstackp(L, nextra, where);  \n    L->top = where + nextra;  \n  }\n  for (i = 0; i < wanted && i < nextra; i++)\n    setobjs2s(L, where + i, ci->func - nextra + i);\n  for (; i < wanted; i++)   \n    setnilvalue(s2v(where + i));\n}",
        "output": "1",
        "idx": 8094
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int exists_not_none(PyObject *obj, _Py_Identifier *id)\n{\n    int isnone;\n    PyObject *attr = _PyObject_GetAttrId(obj, id);\n    if (!attr) {\n        PyErr_Clear();\n        return 0;\n    }\n    isnone = attr == Py_None;\n    Py_DECREF(attr);\n    return !isnone;\n}",
        "output": "1",
        "idx": 7676
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "batchInit(batch_t *pBatch, int maxElem) {\n\tDEFiRet;\n\tpBatch->iDoneUpTo = 0;\n\tpBatch->maxElem = maxElem;\n\tCHKmalloc(pBatch->pElem = calloc((size_t)maxElem, sizeof(batch_obj_t)));\nfinalize_it:\n\tRETiRet;\n}",
        "output": "0",
        "idx": 4725
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ngx_http_lua_copy_request_headers(ngx_http_request_t *sr, ngx_http_request_t *r)\n{\n    ngx_table_elt_t                 *header;\n    ngx_list_part_t                 *part;\n    ngx_uint_t                       i;\n\n    if (ngx_list_init(&sr->headers_in.headers, sr->pool, 20,\n                      sizeof(ngx_table_elt_t)) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    dd(\"before: parent req headers count: %d\",\n       (int) r->headers_in.headers.part.nelts);\n\n    part = &r->headers_in.headers.part;\n    header = part->elts;\n\n    for (i = 0; ; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n\n        dd(\"setting request header %.*s: %.*s\", (int) header[i].key.len,\n           header[i].key.data, (int) header[i].value.len,\n           header[i].value.data);\n\n        if (ngx_http_lua_set_input_header(sr, header[i].key,\n                                          header[i].value, 0) == NGX_ERROR)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n    dd(\"after: parent req headers count: %d\",\n       (int) r->headers_in.headers.part.nelts);\n\n    return NGX_OK;\n}",
        "output": "1",
        "idx": 7870
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_ctl_elem_user_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tint change;\n\tstruct user_element *ue = kcontrol->private_data;\n\n\tmutex_lock(&ue->card->user_ctl_lock);\n\tchange = memcmp(&ucontrol->value, ue->elem_data, ue->elem_data_size) != 0;\n\tif (change)\n\t\tmemcpy(ue->elem_data, &ucontrol->value, ue->elem_data_size);\n\tmutex_unlock(&ue->card->user_ctl_lock);\n\treturn change;\n}",
        "output": "0",
        "idx": 3575
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch(type) {\n\t\tcase ACL_TYPE_ACCESS:\n\t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\t\tif (acl) {\n\t\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\t\tmark_inode_dirty(inode);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase ACL_TYPE_DEFAULT:\n\t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\treturn acl ? -EACCES : 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n \tif (acl) {\n\t\tvalue = ext2_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = ext2_xattr_set(inode, name_index, \"\", value, size, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}",
        "output": "0",
        "idx": 1939
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static enum count_type __read_io_type(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\n\tif (mapping) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\t\tif (inode->i_ino == F2FS_META_INO(sbi))\n\t\t\treturn F2FS_RD_META;\n\n\t\tif (inode->i_ino == F2FS_NODE_INO(sbi))\n\t\t\treturn F2FS_RD_NODE;\n\t}\n\treturn F2FS_RD_DATA;\n}",
        "output": "1",
        "idx": 3200
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sas_scsi_clear_queue_lu(struct list_head *error_q, struct scsi_cmnd *my_cmd)\n{\n\tstruct scsi_cmnd *cmd, *n;\n\n\tlist_for_each_entry_safe(cmd, n, error_q, eh_entry) {\n\t\tif (cmd->device->sdev_target == my_cmd->device->sdev_target &&\n\t\t    cmd->device->lun == my_cmd->device->lun)\n\t\t\tsas_eh_defer_cmd(cmd);\n\t}\n}",
        "output": "1",
        "idx": 1844
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ga_copy_string(garray_T *gap, char_u *p)\n{\n    char_u *cp = vim_strsave(p);\n\n    if (cp == NULL)\n\treturn FAIL;\n\n    if (ga_grow(gap, 1) == FAIL)\n    {\n\tvim_free(cp);\n\treturn FAIL;\n    }\n    ((char_u **)(gap->ga_data))[gap->ga_len++] = cp;\n    return OK;\n}",
        "output": "0",
        "idx": 7937
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool unconditional(const struct ipt_ip *ip)\n{\n\tstatic const struct ipt_ip uncond;\n\n\treturn memcmp(ip, &uncond, sizeof(uncond)) == 0;\n#undef FWINV\n}",
        "output": "1",
        "idx": 1192
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_process_context_token(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\t\tconst gss_buffer_t token_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_process_context_token(minor_status,\n\t\t\t\t\tcontext_handle,\n\t\t\t\t\ttoken_buffer);\n\n\treturn (ret);\n}",
        "output": "1",
        "idx": 72
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void start_auth_request(PgSocket *client, const char *username)\n{\n\tint res;\n\tPktBuf *buf;\n\n\tclient->auth_user = client->db->auth_user;\n\tclient->pool = get_pool(client->db, client->db->auth_user);\n\tif (!find_server(client)) {\n\t\tclient->wait_for_user_conn = true;\n\t\treturn;\n\t}\n\tslog_noise(client, \"Doing auth_conn query\");\n\tclient->wait_for_user_conn = false;\n\tclient->wait_for_user = true;\n\tif (!sbuf_pause(&client->sbuf)) {\n\t\trelease_server(client->link);\n\t\tdisconnect_client(client, true, \"pause failed\");\n\t\treturn;\n\t}\n\tclient->link->ready = 0;\n\n\tres = 0;\n\tbuf = pktbuf_dynamic(512);\n\tif (buf) {\n\t\tpktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);\n\t\tres = pktbuf_send_immediate(buf, client->link);\n\t\tpktbuf_free(buf);\n\t}\n\tif (!res)\n\t\tdisconnect_server(client->link, false, \"unable to send login query\");\n}",
        "output": "1",
        "idx": 5310
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_pli(\n\t\t\t\t\tpjmedia_rtcp_session *session, \n\t\t\t\t\tvoid *buf,\n\t\t\t\t\tpj_size_t *length)\n{\n    pjmedia_rtcp_common *hdr;\n    unsigned len;\n\n    PJ_ASSERT_RETURN(session && buf && length, PJ_EINVAL);\n\n    len = 12;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_PSFB;\n    hdr->count = 1; \n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    *length = len;\n\n    return PJ_SUCCESS;\n}",
        "output": "1",
        "idx": 8068
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,\n                        const AVFrame *src, int field)\n{\n    int plane;\n    for (plane = 0; plane < 4 && src->data[plane]; plane++)\n        av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,\n                            src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,\n                            get_width(fm, src, plane), get_height(fm, src, plane) / 2);\n}",
        "output": "1",
        "idx": 3520
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void hashtable_clear(hashtable_t *hashtable)\n{\n    size_t i;\n\n    hashtable_do_clear(hashtable);\n\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n\n    list_init(&hashtable->list);\n    hashtable->size = 0;\n}",
        "output": "1",
        "idx": 4320
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sockfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tint err = simple_setattr(dentry, iattr);\n\n\tif (!err && (iattr->ia_valid & ATTR_UID)) {\n\t\tstruct socket *sock = SOCKET_I(d_inode(dentry));\n\n\t\tsock->sk->sk_uid = iattr->ia_uid;\n\t}\n\n\treturn err;\n}",
        "output": "1",
        "idx": 2972
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseServerLog(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprTicks    timestamp;\n    cchar       *location;\n    ssize       size;\n    int         level, anew, backup;\n\n    if (mprGetCmdlineLogging()) {\n        mprLog(\"warn http config\", 4, \"Already logging. Ignoring log configuration\");\n        return;\n    }\n    location = mprReadJson(prop, \"location\");\n    level = (int) stoi(mprReadJson(prop, \"level\"));\n    backup = (int) stoi(mprReadJson(prop, \"backup\"));\n    anew = smatch(mprReadJson(prop, \"anew\"), \"true\");\n    size = (ssize) httpGetNumber(mprReadJson(prop, \"size\"));\n    timestamp = httpGetNumber(mprReadJson(prop, \"timestamp\"));\n\n    if (size < HTTP_TRACE_MIN_LOG_SIZE) {\n        size = HTTP_TRACE_MIN_LOG_SIZE;\n    }\n    if (location == 0) {\n        httpParseError(route, \"Missing location\");\n        return;\n    }\n    if (!smatch(location, \"stdout\") && !smatch(location, \"stderr\")) {\n        location = httpMakePath(route, 0, location);\n    }\n    mprSetLogBackup(size, backup, anew ? MPR_LOG_ANEW : 0);\n\n    if (mprStartLogging(location, 0) < 0) {\n        httpParseError(route, \"Cannot write to error log: %s\", location);\n        return;\n    }\n    mprSetLogLevel(level);\n    mprLogConfig();\n    if (timestamp) {\n        httpSetTimestamp(timestamp);\n    }\n}",
        "output": "0",
        "idx": 7047
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tshort state = key->state;\n\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\tif (state == KEY_IS_POSITIVE && key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\n\t\tsecurity_key_free(key);\n\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (state != KEY_IS_UNINSTANTIATED)\n\t\t\tatomic_dec(&key->user->nikeys);\n\n\t\tkey_user_put(key->user);\n\n\t\tkfree(key->description);\n\n\t\tmemzero_explicit(key, sizeof(*key));\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}",
        "output": "0",
        "idx": 2487
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)\n{\n\tzend_hash_destroy(&pglobals->ht_rc);\n}",
        "output": "0",
        "idx": 5601
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void exit_io_context(struct task_struct *task)\n{\n\tstruct io_context *ioc;\n\n\ttask_lock(task);\n\tioc = task->io_context;\n\ttask->io_context = NULL;\n\ttask_unlock(task);\n\n\tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n\t\tif (ioc->aic && ioc->aic->exit)\n\t\t\tioc->aic->exit(ioc->aic);\n\t\tcfq_exit(ioc);\n\n\t}\n\tput_io_context(ioc);\n}",
        "output": "0",
        "idx": 3119
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ia64_patch_rse (unsigned long start, unsigned long end)\n{\n\ts32 *offp = (s32 *) start;\n\tu64 ip, *b;\n\n\twhile (offp < (s32 *) end) {\n\t\tip = (u64) offp + *offp;\n\n\t\tb = (u64 *)(ip & -16);\n\t\tb[1] &= ~0xf800000L;\n\t\tia64_fc((void *) ip);\n\t\t++offp;\n\t}\n\tia64_sync_i();\n\tia64_srlz_i();\n}",
        "output": "0",
        "idx": 3021
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int set_registers(rtl8150_t * dev, u16 indx, u16 size, const void *data)\n{\n\tvoid *buf;\n\tint ret;\n\n\tbuf = kmemdup(data, size, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\n\t\t\t      RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,\n\t\t\t      indx, 0, buf, size, 500);\n\tkfree(buf);\n\treturn ret;\n}",
        "output": "0",
        "idx": 2133
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static irqreturn_t snd_msnd_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_msnd *chip = dev_id;\n\tvoid *pwDSPQData = chip->mappedbase + DSPQ_DATA_BUFF;\n\tu16 head, tail, size;\n\n\n\thead = readw(chip->DSPQ + JQS_wHead);\n\ttail = readw(chip->DSPQ + JQS_wTail);\n\tsize = readw(chip->DSPQ + JQS_wSize);\n\tif (head > size || tail > size)\n\t\tgoto out;\n\twhile (head != tail) {\n\t\tsnd_msnd_eval_dsp_msg(chip, readw(pwDSPQData + 2 * head));\n\t\tif (++head > size)\n\t\t\thead = 0;\n\t\twritew(head, chip->DSPQ + JQS_wHead);\n\t}\n out:\n\tinb(chip->io + HP_RXL);\n\treturn IRQ_HANDLED;\n}",
        "output": "0",
        "idx": 2343
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct dst_entry *inet6_csk_route_socket(struct sock *sk,\n\t\t\t\t\t\tstruct flowi6 *fl6)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *final_p, final;\n\tstruct dst_entry *dst;\n\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_proto = sk->sk_protocol;\n\tfl6->daddr = sk->sk_v6_daddr;\n\tfl6->saddr = np->saddr;\n\tfl6->flowlabel = np->flow_label;\n\tIP6_ECN_flow_xmit(sk, fl6->flowlabel);\n\tfl6->flowi6_oif = sk->sk_bound_dev_if;\n\tfl6->flowi6_mark = sk->sk_mark;\n\tfl6->fl6_sport = inet->inet_sport;\n\tfl6->fl6_dport = inet->inet_dport;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(fl6));\n\n\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n\n\tdst = __inet6_csk_dst_check(sk, np->dst_cookie);\n\tif (!dst) {\n\t\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\n\t\tif (!IS_ERR(dst))\n\t\t\t__inet6_csk_dst_store(sk, dst, NULL, NULL);\n\t}\n\treturn dst;\n}",
        "output": "1",
        "idx": 956
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int xml_init(modsec_rec *msr, char **error_msg) {\n    xmlParserInputBufferCreateFilenameFunc entity;\n\n    if (error_msg == NULL) return -1;\n    *error_msg = NULL;\n\n    msr->xml = apr_pcalloc(msr->mp, sizeof(xml_data));\n    if (msr->xml == NULL) return -1;\n\n    if(msr->txcfg->xml_external_entity == 0)    {\n        entity = xmlParserInputBufferCreateFilenameDefault(xml_unload_external_entity);\n    }\n\n    return 1;\n}",
        "output": "0",
        "idx": 5291
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ext2_xattr_cache_insert(struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext2_xattr_cache, GFP_NOFS);\n\tif (!ce)\n\t\treturn -ENOMEM;\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache (%d cache entries)\",\n\t\t\t\tatomic_read(&ext2_xattr_cache->c_entry_count));\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x] (%d cache entries)\", (int)hash,\n\t\t\t  atomic_read(&ext2_xattr_cache->c_entry_count));\n\t\tmb_cache_entry_release(ce);\n\t}\n\treturn error;\n}",
        "output": "1",
        "idx": 1118
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BOOL glyph_cache_put(rdpGlyphCache* glyphCache, UINT32 id, UINT32 index, rdpGlyph* glyph)\n{\n\trdpGlyph* prevGlyph;\n\n\tif (id > 9)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache id: %\" PRIu32 \"\", id);\n\t\treturn FALSE;\n\t}\n\n\tif (index >= glyphCache->glyphCache[id].number)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache index: %\" PRIu32 \" in cache id: %\" PRIu32 \"\", index, id);\n\t\treturn FALSE;\n\t}\n\n\tWLog_Print(glyphCache->log, WLOG_DEBUG, \"GlyphCachePut: id: %\" PRIu32 \" index: %\" PRIu32 \"\", id,\n\t           index);\n\tprevGlyph = glyphCache->glyphCache[id].entries[index];\n\n\tif (prevGlyph)\n\t\tprevGlyph->Free(glyphCache->context, prevGlyph);\n\n\tglyphCache->glyphCache[id].entries[index] = glyph;\n\treturn TRUE;\n}",
        "output": "0",
        "idx": 5747
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hci_uart_set_proto(struct hci_uart *hu, int id)\n{\n\tconst struct hci_uart_proto *p;\n\tint err;\n\n\tp = hci_uart_get_proto(id);\n\tif (!p)\n\t\treturn -EPROTONOSUPPORT;\n\n\thu->proto = p;\n\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n\n\terr = hci_uart_register_dev(hu);\n\tif (err) {\n\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 3112
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ceph_x_decrypt(struct ceph_crypto_key *secret,\n\t\t\t  void **p, void *end, void *obuf, size_t olen)\n{\n\tstruct ceph_x_encrypt_header head;\n\tsize_t head_len = sizeof(head);\n\tint len, ret;\n\n\tlen = ceph_decode_32(p);\n\tif (*p + len > end)\n\t\treturn -EINVAL;\n\n\tdout(\"ceph_x_decrypt len %d\\n\", len);\n\tret = ceph_decrypt2(secret, &head, &head_len, obuf, &olen,\n\t\t\t    *p, len);\n\tif (ret)\n\t\treturn ret;\n\tif (head.struct_v != 1 || le64_to_cpu(head.magic) != CEPHX_ENC_MAGIC)\n\t\treturn -EPERM;\n\t*p += len;\n\treturn olen;\n}",
        "output": "1",
        "idx": 2664
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void trustedGetPublicSharesAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t enc_len,\n                               char *public_shares,\n                               unsigned _t, unsigned _n) {\n    LOG_INFO(__FUNCTION__);\n\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_dkg_secret);\n    CHECK_STATE(public_shares);\n    CHECK_STATE(_t <= _n && _n > 0)\n\n    SAFE_CHAR_BUF(decrypted_dkg_secret, DKG_MAX_SEALED_LEN);\n\n    int status = AES_decrypt(encrypted_dkg_secret, enc_len, decrypted_dkg_secret,\n                             DKG_MAX_SEALED_LEN);\n\n    CHECK_STATUS2(\"aes decrypt data - encrypted_dkg_secret failed with status %d\");\n\n    status = calc_public_shares(decrypted_dkg_secret, public_shares, _t) != 0;\n    CHECK_STATUS(\"t does not match polynomial in db\");\n\n    SET_SUCCESS\n\n    clean:\n    ;\n    LOG_INFO(\"SGX call completed\");\n}",
        "output": "1",
        "idx": 8718
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void x86_assign_hw_event(struct perf_event *event,\n\t\t\t\tstruct cpu_hw_events *cpuc, int i)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\thwc->idx = cpuc->assign[i];\n\thwc->last_cpu = smp_processor_id();\n\thwc->last_tag = ++cpuc->tags[i];\n\n\tif (hwc->idx == X86_PMC_IDX_FIXED_BTS) {\n\t\thwc->config_base = 0;\n\t\thwc->event_base\t= 0;\n\t} else if (hwc->idx >= X86_PMC_IDX_FIXED) {\n\t\thwc->config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL;\n\t\thwc->event_base = MSR_ARCH_PERFMON_FIXED_CTR0;\n\t} else {\n\t\thwc->config_base = x86_pmu_config_addr(hwc->idx);\n\t\thwc->event_base  = x86_pmu_event_addr(hwc->idx);\n\t}\n}",
        "output": "1",
        "idx": 260
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void perf_event_enable(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx;\n\n\tctx = perf_event_ctx_lock(event);\n\t_perf_event_enable(event);\n\tperf_event_ctx_unlock(event, ctx);\n}",
        "output": "0",
        "idx": 3853
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int netbk_set_skb_gso(struct xenvif *vif,\n\t\t\t     struct sk_buff *skb,\n\t\t\t     struct xen_netif_extra_info *gso)\n{\n\tif (!gso->u.gso.size) {\n\t\tnetdev_dbg(vif->dev, \"GSO size must not be zero.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (gso->u.gso.type != XEN_NETIF_GSO_TYPE_TCPV4) {\n\t\tnetdev_dbg(vif->dev, \"Bad GSO type %d.\\n\", gso->u.gso.type);\n\t\treturn -EINVAL;\n\t}\n\n\tskb_shinfo(skb)->gso_size = gso->u.gso.size;\n\tskb_shinfo(skb)->gso_type = SKB_GSO_TCPV4;\n\n\tskb_shinfo(skb)->gso_type |= SKB_GSO_DODGY;\n\tskb_shinfo(skb)->gso_segs = 0;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 822
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {\n    int ret;\n    if (input == NULL) return(-1);\n\n    if (xmlParserDebugEntities) {\n\tif ((ctxt->input != NULL) && (ctxt->input->filename))\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"%s(%d): \", ctxt->input->filename,\n\t\t    ctxt->input->line);\n\txmlGenericError(xmlGenericErrorContext,\n\t\t\"Pushing input %d : %.30s\\n\", ctxt->inputNr+1, input->cur);\n    }\n    if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||\n        (ctxt->inputNr > 1024)) {\n        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n        while (ctxt->inputNr > 1)\n            xmlFreeInputStream(inputPop(ctxt));\n\treturn(-1);\n    }\n    ret = inputPush(ctxt, input);\n    if (ctxt->instate == XML_PARSER_EOF)\n        return(-1);\n    GROW;\n    return(ret);\n}",
        "output": "0",
        "idx": 8843
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "accept_ice_connection (GIOChannel           *source,\n                       GIOCondition          condition,\n                       GsmIceConnectionData *data)\n{\n        IceConn         ice_conn;\n        IceAcceptStatus status;\n\n        g_debug (\"GsmXsmpServer: accept_ice_connection()\");\n\n        ice_conn = IceAcceptConnection (data->listener, &status);\n        if (status != IceAcceptSuccess) {\n                g_debug (\"GsmXsmpServer: IceAcceptConnection returned %d\", status);\n                return TRUE;\n        }\n\n        auth_ice_connection (ice_conn);\n\n        return TRUE;\n}",
        "output": "0",
        "idx": 8723
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)\n{\n\tstruct mnt_namespace *new_ns = alloc_mnt_ns(&init_user_ns);\n\tif (!IS_ERR(new_ns)) {\n\t\tstruct mount *mnt = real_mount(m);\n\t\tmnt->mnt_ns = new_ns;\n\t\tnew_ns->root = mnt;\n\t\tnew_ns->mounts++;\n\t\tlist_add(&mnt->mnt_list, &new_ns->list);\n\t} else {\n\t\tmntput(m);\n\t}\n\treturn new_ns;\n}",
        "output": "0",
        "idx": 1965
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tint start = 0;\n\tint i;\n\tu32 prev_legacy, cur_legacy;\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tprev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tcur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tif (!prev_legacy && cur_legacy)\n\t\tstart = 1;\n\tmemcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,\n\t       sizeof(kvm->arch.vpit->pit_state.channels));\n\tkvm->arch.vpit->pit_state.flags = ps->flags;\n\tfor (i = 0; i < 3; i++)\n\t\tkvm_pit_load_count(kvm, i, kvm->arch.vpit->pit_state.channels[i].count, start);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn 0;\n}",
        "output": "0",
        "idx": 1479
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static cchar *findAcceptableVersion(cchar *name, cchar *originalCriteria)\n{\n    MprDirEntry     *dp;\n    MprList         *files;\n    cchar           *criteria;\n    int             next;\n\n    criteria = originalCriteria;\n    if (!criteria || smatch(criteria, \"*\")) {\n        criteria = \"x\";\n    }\n    if (schr(name, '#')) {\n        name = stok(sclone(name), \"#\", (char**) &criteria);\n    }\n    files = mprGetPathFiles(mprJoinPath(app->paksCacheDir, name), MPR_PATH_RELATIVE);\n    mprSortList(files, (MprSortProc) reverseSortFiles, 0);\n    for (ITERATE_ITEMS(files, dp, next)) {\n        if (acceptableVersion(criteria, dp->name)) {\n            return dp->name;\n        }\n    }\n    if (originalCriteria) {\n        fail(\"Cannot find acceptable version for: \\\"%s\\\" with version criteria \\\"%s\\\" in %s\", \n            name, originalCriteria, app->paksCacheDir);\n    } else {\n        fail(\"Cannot find pak: \\\"%s\\\" in %s\", name, app->paksCacheDir);\n    }\n    mprLog(\"\", 0, \"Use \\\"pak install %s\\\" to install\", name);\n    return 0;\n}",
        "output": "1",
        "idx": 4992
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void setAppDefaults()\n{\n    app->company = stok(slower(ME_COMPANY), \" \", NULL);\n    app->serviceProgram = sclone(SERVICE_PROGRAM);\n    app->serviceName = sclone(SERVICE_NAME);\n    app->serviceHome = mprGetNativePath(SERVICE_HOME);\n    app->retries = RESTART_MAX;\n    app->signal = SIGTERM;\n    app->logSpec = sclone(\"stderr:1\");\n\n    if (mprPathExists(\"/var/run\", X_OK) && getuid() == 0) {\n        app->pidDir = sclone(\"/var/run\");\n    } else if (mprPathExists(\"/tmp\", X_OK)) {\n        app->pidDir = sclone(\"/tmp\");\n    } else if (mprPathExists(\"/Temp\", X_OK)) {\n        app->pidDir = sclone(\"/Temp\");\n    } else {\n        app->pidDir = sclone(\".\");\n    }\n}",
        "output": "1",
        "idx": 5084
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src)\n{\n  char *buf = mutt_str_strdup(src);\n  imap_utf_encode(idata, &buf);\n\n  imap_quote_string(dest, dlen, buf);\n\n  FREE(&buf);\n}",
        "output": "1",
        "idx": 6978
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PixarLogClose(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\n\ttd->td_bitspersample = 8;\n\ttd->td_sampleformat = SAMPLEFORMAT_UINT;\n}",
        "output": "1",
        "idx": 4296
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void hashtable_clear(hashtable_t *hashtable)\n{\n    size_t i;\n\n    hashtable_do_clear(hashtable);\n\n    for(i = 0; i < hashsize(hashtable->order); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n\n    list_init(&hashtable->list);\n    hashtable->size = 0;\n}",
        "output": "0",
        "idx": 5973
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void send_fd(int sockfd, int fd)\n{\n\tint bytes_written;\n\tstruct msghdr msg = { };\n\tstruct cmsghdr *cmsg;\n\tstruct iovec iov[1] = { };\n\tchar null_byte = '\\0';\n\n\tiov[0].iov_base = &null_byte;\n\tiov[0].iov_len = 1;\n\n\tmsg.msg_iov = iov;\n\tmsg.msg_iovlen = 1;\n\n\tmsg.msg_controllen = CMSG_SPACE(sizeof(int));\n\tmsg.msg_control = malloc(msg.msg_controllen);\n\tif (msg.msg_control == NULL) {\n\t\tbail(\"Can't allocate memory to send fd.\");\n\t}\n\n\tmemset(msg.msg_control, 0, msg.msg_controllen);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\tmemcpy(CMSG_DATA(cmsg), &fd, sizeof(int));\n\n\tbytes_written = sendmsg(sockfd, &msg, 0);\n\n\tfree(msg.msg_control);\n\n\tif (bytes_written != 1)\n\t\tbail(\"failed to send fd %d via unix socket %d\", fd, sockfd);\n}",
        "output": "0",
        "idx": 8223
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "free_eval_tofree_later(evalarg_T *evalarg)\n{\n    if (evalarg->eval_tofree != NULL)\n    {\n\tif (ga_grow(&evalarg->eval_tofree_ga, 1) == OK)\n\t    ((char_u **)evalarg->eval_tofree_ga.ga_data)\n\t\t[evalarg->eval_tofree_ga.ga_len++]\n\t\t= evalarg->eval_tofree;\n\telse\n\t    vim_free(evalarg->eval_tofree);\n    }\n}",
        "output": "0",
        "idx": 8129
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rose_timer_expiry(struct timer_list *t)\n{\n\tstruct rose_sock *rose = from_timer(rose, t, timer);\n\tstruct sock *sk = &rose->sock;\n\n\tbh_lock_sock(sk);\n\tswitch (rose->state) {\n\tcase ROSE_STATE_1:\t\n\tcase ROSE_STATE_4:\t\n\t\trose_write_internal(sk, ROSE_CLEAR_REQUEST);\n\t\trose->state = ROSE_STATE_2;\n\t\trose_start_t3timer(sk);\n\t\tbreak;\n\n\tcase ROSE_STATE_2:\t\n\t\trose->neighbour->use--;\n\t\trose_disconnect(sk, ETIMEDOUT, -1, -1);\n\t\tbreak;\n\n\tcase ROSE_STATE_3:\t\n\t\tif (rose->condition & ROSE_COND_ACK_PENDING) {\n\t\t\trose->condition &= ~ROSE_COND_ACK_PENDING;\n\t\t\trose_enquiry_response(sk);\n\t\t}\n\t\tbreak;\n\t}\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}",
        "output": "0",
        "idx": 2957
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_checkout_nasty__dotgit_alternate_data_stream(void)\n{\n\ttest_checkout_fails(\"refs/heads/dotgit_alternate_data_stream\", \".git/dummy-file\");\n\ttest_checkout_fails(\"refs/heads/dotgit_alternate_data_stream\", \".git::$INDEX_ALLOCATION/dummy-file\");\n}",
        "output": "0",
        "idx": 6849
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int perf_config(config_fn_t fn, void *data)\n{\n\tint ret = 0, found = 0;\n\tchar *repo_config = NULL;\n\tconst char *home = NULL;\n\n\tif (config_exclusive_filename)\n\t\treturn perf_config_from_file(fn, config_exclusive_filename, data);\n\tif (perf_config_system() && !access(perf_etc_perfconfig(), R_OK)) {\n\t\tret += perf_config_from_file(fn, perf_etc_perfconfig(),\n\t\t\t\t\t    data);\n\t\tfound += 1;\n\t}\n\n\thome = getenv(\"HOME\");\n\tif (perf_config_global() && home) {\n\t\tchar *user_config = strdup(mkpath(\"%s/.perfconfig\", home));\n\t\tif (!access(user_config, R_OK)) {\n\t\t\tret += perf_config_from_file(fn, user_config, data);\n\t\t\tfound += 1;\n\t\t}\n\t\tfree(user_config);\n\t}\n\n\trepo_config = perf_pathdup(\"config\");\n\tif (!access(repo_config, R_OK)) {\n\t\tret += perf_config_from_file(fn, repo_config, data);\n\t\tfound += 1;\n\t}\n\tfree(repo_config);\n\tif (found == 0)\n\t\treturn -1;\n\treturn ret;\n}",
        "output": "1",
        "idx": 618
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rds_tcp_kill_sock(struct net *net)\n{\n\tstruct rds_tcp_connection *tc, *_tc;\n\tLIST_HEAD(tmp_list);\n\tstruct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);\n\tstruct socket *lsock = rtn->rds_tcp_listen_sock;\n\n\trtn->rds_tcp_listen_sock = NULL;\n\trds_tcp_listen_stop(lsock, &rtn->rds_tcp_accept_w);\n\tspin_lock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) {\n\t\tstruct net *c_net = read_pnet(&tc->t_cpath->cp_conn->c_net);\n\n\t\tif (net != c_net || !tc->t_sock)\n\t\t\tcontinue;\n\t\tif (!list_has_conn(&tmp_list, tc->t_cpath->cp_conn)) {\n\t\t\tlist_move_tail(&tc->t_tcp_node, &tmp_list);\n\t\t} else {\n\t\t\tlist_del(&tc->t_tcp_node);\n\t\t\ttc->t_tcp_node_detached = true;\n\t\t}\n\t}\n\tspin_unlock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &tmp_list, t_tcp_node)\n\t\trds_conn_destroy(tc->t_cpath->cp_conn);\n}",
        "output": "1",
        "idx": 3134
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "efind(name)\nchar *name;\n{\n\tstatic char efbuf[100];\n\tmy_regex_t re;\n\n\tsprintf(efbuf, \"REG_%s\", name);\n\tassert(strlen(efbuf) < sizeof(efbuf));\n\tre.re_endp = efbuf;\n\t(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));\n\treturn(atoi(efbuf));\n}",
        "output": "1",
        "idx": 5250
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct ucounts *alloc_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\tbool wrapped;\n\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 1);\n\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tget_user_ns(new->ns);\n\t\t\tspin_unlock_irq(&ucounts_lock);\n\t\t\treturn new;\n\t\t}\n\t}\n\twrapped = !get_ucounts_or_wrap(ucounts);\n\tspin_unlock_irq(&ucounts_lock);\n\tif (wrapped) {\n\t\tput_ucounts(ucounts);\n\t\treturn NULL;\n\t}\n\treturn ucounts;\n}",
        "output": "0",
        "idx": 2885
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ast_type_reduce(PyObject *self, PyObject *unused)\n{\n    PyObject *res;\n    _Py_IDENTIFIER(__dict__);\n    PyObject *dict = _PyObject_GetAttrId(self, &PyId___dict__);\n    if (dict == NULL) {\n        if (PyErr_ExceptionMatches(PyExc_AttributeError))\n            PyErr_Clear();\n        else\n            return NULL;\n    }\n    if (dict) {\n        res = Py_BuildValue(\"O()O\", Py_TYPE(self), dict);\n        Py_DECREF(dict);\n        return res;\n    }\n    return Py_BuildValue(\"O()\", Py_TYPE(self));\n}",
        "output": "1",
        "idx": 7700
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_event_output(struct perf_event *event, int nmi,\n\t\t\t\tstruct perf_sample_data *data,\n\t\t\t\tstruct pt_regs *regs)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_event_header header;\n\n\trcu_read_lock();\n\n\tperf_prepare_sample(&header, data, event, regs);\n\n\tif (perf_output_begin(&handle, event, header.size, nmi, 1))\n\t\tgoto exit;\n\n\tperf_output_sample(&handle, &header, data, event);\n\n\tperf_output_end(&handle);\n\nexit:\n\trcu_read_unlock();\n}",
        "output": "1",
        "idx": 530
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "poly_path(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tPATH\t   *path;\n\tint\t\t\tsize;\n\tint\t\t\ti;\n\n\tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * poly->npts;\n\tpath = (PATH *) palloc(size);\n\n\tSET_VARSIZE(path, size);\n\tpath->npts = poly->npts;\n\tpath->closed = TRUE;\n\tpath->dummy = 0;\n\n\tfor (i = 0; i < poly->npts; i++)\n\t{\n\t\tpath->p[i].x = poly->p[i].x;\n\t\tpath->p[i].y = poly->p[i].y;\n\t}\n\n\tPG_RETURN_PATH_P(path);\n}",
        "output": "0",
        "idx": 6291
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateIntArray( int64_t *numbers, int count )\n{\n\tint i;\n\tcJSON *n = 0, *p = 0, *a = cJSON_CreateArray();\n\tfor ( i = 0; a && i < count; ++i ) {\n\t\tn = cJSON_CreateInt( numbers[i] );\n\t\tif ( ! i )\n\t\t\ta->child = n;\n\t\telse\n\t\t\tsuffix_object( p, n );\n\t\tp = n;\n\t}\n\treturn a;\n}",
        "output": "1",
        "idx": 5924
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void skcipher_release(void *private)\n{\n\tcrypto_free_skcipher(private);\n}",
        "output": "1",
        "idx": 1048
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "VTermState *vterm_obtain_state(VTerm *vt)\n{\n  VTermState *state;\n  if(vt->state)\n    return vt->state;\n\n  state = vterm_state_new(vt);\n  if (state == NULL)\n    return NULL;\n  vt->state = state;\n\n  state->combine_chars_size = 16;\n  state->combine_chars = vterm_allocator_malloc(state->vt, state->combine_chars_size * sizeof(state->combine_chars[0]));\n\n  state->tabstops = vterm_allocator_malloc(state->vt, (state->cols + 7) / 8);\n\n  state->lineinfo = vterm_allocator_malloc(state->vt, state->rows * sizeof(VTermLineInfo));\n\n  state->encoding_utf8.enc = vterm_lookup_encoding(ENC_UTF8, 'u');\n  if(*state->encoding_utf8.enc->init != NULL)\n    (*state->encoding_utf8.enc->init)(state->encoding_utf8.enc, state->encoding_utf8.data);\n\n  vterm_parser_set_callbacks(vt, &parser_callbacks, state);\n\n  return state;\n}",
        "output": "0",
        "idx": 8137
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ZEND_API void zend_object_store_ctor_failed(zval *zobject TSRMLS_DC)\n{\n\tzend_object_handle handle = Z_OBJ_HANDLE_P(zobject);\n\tzend_object_store_bucket *obj_bucket = &EG(objects_store).object_buckets[handle];\n\t\n\tobj_bucket->bucket.obj.handlers = Z_OBJ_HT_P(zobject);;\n\tobj_bucket->destructor_called = 1;\n}",
        "output": "1",
        "idx": 4086
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "smb_com_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t\t*file;\n\tsmb_llist_t\t*flist;\n\tint\t\trc;\n\n\tif (smb_flush_required == 0) {\n\t\trc = smbsr_encode_empty_result(sr);\n\t\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n\t}\n\n\tif (sr->smb_fid != 0xffff) {\n\t\tsmbsr_lookup_file(sr);\n\t\tif (sr->fid_ofile == NULL) {\n\t\t\tsmbsr_error(sr, NT_STATUS_INVALID_HANDLE,\n\t\t\t    ERRDOS, ERRbadfid);\n\t\t\treturn (SDRC_ERROR);\n\t\t}\n\n\t\tsmb_flush_file(sr, sr->fid_ofile);\n\t} else {\n\t\tflist = &sr->tid_tree->t_ofile_list;\n\t\tsmb_llist_enter(flist, RW_READER);\n\t\tfile = smb_llist_head(flist);\n\t\twhile (file) {\n\t\t\tmutex_enter(&file->f_mutex);\n\t\t\tsmb_flush_file(sr, file);\n\t\t\tmutex_exit(&file->f_mutex);\n\t\t\tfile = smb_llist_next(flist, file);\n\t\t}\n\t\tsmb_llist_exit(flist);\n\t}\n\n\trc = smbsr_encode_empty_result(sr);\n\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n}",
        "output": "1",
        "idx": 4900
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileInfo, getPathInfo)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_class_entry *ce = intern->info_class;\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n\t\tint path_len;\n\t\tchar *path = spl_filesystem_object_get_pathname(intern, &path_len TSRMLS_CC);\n\t\tif (path) {\n\t\t\tchar *dpath = estrndup(path, path_len);\n\t\t\tpath_len = php_dirname(dpath, path_len);\n\t\t\tspl_filesystem_object_create_info(intern, dpath, path_len, 1, ce, return_value TSRMLS_CC);\n\t\t\tefree(dpath);\n\t\t}\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}",
        "output": "0",
        "idx": 5527
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_bearer_type_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_TYPE_ANALOG_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_TYPE_DIGITAL_MASK) {\n\t\tND_PRINT((ndo, \"D\"));\n\t}\n}",
        "output": "1",
        "idx": 4764
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "isakmp_rfc3948_print(netdissect_options *ndo,\n\t\t     const u_char *bp, u_int length,\n\t\t     const u_char *bp2)\n{\n\tND_TCHECK(bp[0]);\n\tif(length == 1 && bp[0]==0xff) {\n\t\tND_PRINT((ndo, \"isakmp-nat-keep-alive\"));\n\t\treturn;\n\t}\n\n\tif(length < 4) {\n\t\tgoto trunc;\n\t}\n\tND_TCHECK(bp[3]);\n\n\tif(bp[0]==0 && bp[1]==0 && bp[2]==0 && bp[3]==0) {\n\t\tND_PRINT((ndo, \"NONESP-encap: \"));\n\t\tisakmp_print(ndo, bp+4, length-4, bp2);\n\t\treturn;\n\t}\n\n\t{\n\t\tint nh, enh, padlen;\n\t\tint advance;\n\n\t\tND_PRINT((ndo, \"UDP-encap: \"));\n\n\t\tadvance = esp_print(ndo, bp, length, bp2, &enh, &padlen);\n\t\tif(advance <= 0)\n\t\t\treturn;\n\n\t\tbp += advance;\n\t\tlength -= advance + padlen;\n\t\tnh = enh & 0xff;\n\n\t\tip_print_inner(ndo, bp, length, nh, bp2);\n\t\treturn;\n\t}\n\ntrunc:\n\tND_PRINT((ndo,\"[|isakmp]\"));\n\treturn;\n}",
        "output": "0",
        "idx": 6531
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct l2tp_packet_t *l2tp_packet_alloc(int ver, int msg_type,\n\t\t\t\t\tconst struct sockaddr_in *addr, int H,\n\t\t\t\t\tconst char *secret, size_t secret_len)\n{\n\tstruct l2tp_packet_t *pack = mempool_alloc(pack_pool);\n\tif (!pack)\n\t\treturn NULL;\n\n\tmemset(pack, 0, sizeof(*pack));\n\tINIT_LIST_HEAD(&pack->attrs);\n\tpack->hdr.ver = ver;\n\tpack->hdr.T = 1;\n\tpack->hdr.L = 1;\n\tpack->hdr.S = 1;\n\tmemcpy(&pack->addr, addr, sizeof(*addr));\n\tpack->hide_avps = H;\n\tpack->secret = secret;\n\tpack->secret_len = secret_len;\n\n\tif (msg_type) {\n\t\tif (l2tp_packet_add_int16(pack, Message_Type, msg_type, 1)) {\n\t\t\tmempool_free(pack);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn pack;\n}",
        "output": "1",
        "idx": 8006
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool unconditional(const struct ipt_entry *e)\n{\n\tstatic const struct ipt_ip uncond;\n\n\treturn e->target_offset == sizeof(struct ipt_entry) &&\n\t       memcmp(&e->ip, &uncond, sizeof(uncond)) == 0;\n#undef FWINV\n}",
        "output": "0",
        "idx": 1763
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ScreenCell *realloc_buffer(VTermScreen *screen, ScreenCell *buffer, int new_rows, int new_cols)\n{\n  ScreenCell *new_buffer = vterm_allocator_malloc(screen->vt, sizeof(ScreenCell) * new_rows * new_cols);\n  int row, col;\n\n  for(row = 0; row < new_rows; row++) {\n    for(col = 0; col < new_cols; col++) {\n      ScreenCell *new_cell = new_buffer + row*new_cols + col;\n\n      if(buffer && row < screen->rows && col < screen->cols)\n        *new_cell = buffer[row * screen->cols + col];\n      else {\n        new_cell->chars[0] = 0;\n        new_cell->pen = screen->pen;\n      }\n    }\n  }\n\n  vterm_allocator_free(screen->vt, buffer);\n\n  return new_buffer;\n}",
        "output": "0",
        "idx": 8145
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void show_object(struct object *obj,\n\t\t\tstruct strbuf *path, const char *last,\n\t\t\tvoid *data)\n{\n\tchar *name = path_name(path, last);\n\n\tadd_preferred_base_object(name);\n\tadd_object_entry(obj->oid.hash, obj->type, name, 0);\n\tobj->flags |= OBJECT_ADDED;\n\n\tfree((char *)name);\n}",
        "output": "1",
        "idx": 5188
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "evtchn_port_t evtchn_from_irq(unsigned irq)\n{\n\tconst struct irq_info *info = NULL;\n\n\tif (likely(irq < nr_irqs))\n\t\tinfo = info_for_irq(irq);\n\tif (!info)\n\t\treturn 0;\n\n\treturn info->evtchn;\n}",
        "output": "0",
        "idx": 2713
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC int httpTestParam(HttpConn *conn, cchar *var)\n{\n    return mprLookupJsonObj(httpGetParams(conn), var) != 0;\n}",
        "output": "1",
        "idx": 5064
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint32_t virtio_config_readl(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return (uint32_t)-1;\n    }\n\n    k->get_config(vdev, vdev->config);\n\n    val = ldl_p(vdev->config + addr);\n    return val;\n}",
        "output": "0",
        "idx": 5301
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pppoe_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t  struct msghdr *m, size_t total_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint error = 0;\n\n\tif (sk->sk_state & PPPOX_BOUND) {\n\t\terror = -EIO;\n\t\tgoto end;\n\t}\n\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &error);\n\tif (error < 0)\n\t\tgoto end;\n\n\tm->msg_namelen = 0;\n\n\tif (skb) {\n\t\ttotal_len = min_t(size_t, total_len, skb->len);\n\t\terror = skb_copy_datagram_iovec(skb, 0, m->msg_iov, total_len);\n\t\tif (error == 0) {\n\t\t\tconsume_skb(skb);\n\t\t\treturn total_len;\n\t\t}\n\t}\n\n\tkfree_skb(skb);\nend:\n\treturn error;\n}",
        "output": "1",
        "idx": 2424
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,\n\t\t\t\t  int tlen, int offset)\n{\n\t__wsum csum = skb->csum;\n\n\tif (skb->ip_summed != CHECKSUM_COMPLETE)\n\t\treturn;\n\n\tif (offset != 0) {\n\t\tint tend_off = skb_transport_offset(skb) + tlen;\n\t\tcsum = csum_sub(csum, skb_checksum(skb, tend_off, offset, 0));\n\t}\n\n\tput_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &csum);\n}",
        "output": "0",
        "idx": 2165
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "__u32 secure_tcpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t   __be16 sport, __be16 dport)\n{\n\t__u32 seq;\n\t__u32 hash[12];\n\tstruct keydata *keyptr = get_keyptr();\n\n\n\tmemcpy(hash, saddr, 16);\n\thash[4] = ((__force u16)sport << 16) + (__force u16)dport;\n\tmemcpy(&hash[5], keyptr->secret, sizeof(__u32) * 7);\n\n\tseq = twothirdsMD4Transform((const __u32 *)daddr, hash) & HASH_MASK;\n\tseq += keyptr->count;\n\n\tseq += ktime_to_ns(ktime_get_real());\n\n\treturn seq;\n}",
        "output": "1",
        "idx": 608
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void queue_delete(struct snd_seq_queue *q)\n{\n\tmutex_lock(&q->timer_mutex);\n\tsnd_seq_timer_stop(q->timer);\n\tsnd_seq_timer_close(q);\n\tmutex_unlock(&q->timer_mutex);\n\tsnd_use_lock_sync(&q->use_lock);\n\tsnd_seq_prioq_delete(&q->tickq);\n\tsnd_seq_prioq_delete(&q->timeq);\n\tsnd_seq_timer_delete(&q->timer);\n\n\tkfree(q);\n}",
        "output": "0",
        "idx": 1517
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int elo_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct elo_priv *priv;\n\tint ret;\n\tstruct usb_device *udev;\n\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tINIT_DELAYED_WORK(&priv->work, elo_work);\n\tudev = interface_to_usbdev(to_usb_interface(hdev->dev.parent));\n\tpriv->usbdev = usb_get_dev(udev);\n\n\thid_set_drvdata(hdev, priv);\n\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\tif (elo_broken_firmware(priv->usbdev)) {\n\t\thid_info(hdev, \"broken firmware found, installing workaround\\n\");\n\t\tqueue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);\n\t}\n\n\treturn 0;\nerr_free:\n\tusb_put_dev(udev);\n\tkfree(priv);\n\treturn ret;\n}",
        "output": "0",
        "idx": 2879
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct addr_t* MACH0_(get_entrypoint)(struct MACH0_(obj_t)* bin) {\n\tstruct addr_t *entry;\n\tint i;\n\n\tif (!bin->entry && !bin->sects) {\n\t\treturn NULL;\n\t}\n\tif (!(entry = calloc (1, sizeof (struct addr_t)))) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->entry) {\n\t\tentry->addr = entry_to_vaddr (bin);\n\t\tentry->offset = addr_to_offset (bin, entry->addr);\n\t\tentry->haddr = sdb_num_get (bin->kv, \"mach0.entry.offset\", 0);\n\t}\n\n\tif (!bin->entry || entry->offset == 0) {\n\t\tfor (i = 0; i < bin->nsects; i++) {\n\t\t\tif (!strncmp (bin->sects[i].sectname, \"__text\", 6)) {\n\t\t\t\tentry->offset = (ut64)bin->sects[i].offset;\n\t\t\t\tsdb_num_set (bin->kv, \"mach0.entry\", entry->offset, 0);\n\t\t\t\tentry->addr = (ut64)bin->sects[i].addr;\n\t\t\t\tif (!entry->addr) { \n\t\t\t\t\tentry->addr = entry->offset;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbin->entry = entry->addr;\n\t}\n\n\treturn entry;\n}",
        "output": "1",
        "idx": 6146
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sysObjectID_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  OID(sysObjectID_oid, 1, 3, 6, 1, 4, 1, 54352);\n  snmp_api_set_oid(varbind, oid, sysObjectID_oid);\n}",
        "output": "1",
        "idx": 7926
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void opl3_setup_voice(int dev, int voice, int chn)\n{\n\tstruct channel_info *info;\n\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tif (chn < 0 || chn > 15)\n\t\treturn;\n\n\tinfo = &synth_devs[dev]->chn_info[chn];\n\n\topl3_set_instr(dev, voice, info->pgm_num);\n\n\tdevc->voc[voice].bender = 0;\n\tdevc->voc[voice].bender_range = info->bender_range;\n\tdevc->voc[voice].volume = info->controllers[CTL_MAIN_VOLUME];\n\tdevc->voc[voice].panning = (info->controllers[CTL_PAN] * 2) - 128;\n}",
        "output": "0",
        "idx": 397
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "LIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)\n{\n\tconst char* str;\n\tunsigned int retval;\n\tsize_t tmpretval;\n\tif(!file) return 0;\n\tstr = openmpt_module_get_sample_name(file->mod,qual-1);\n\tif(!str){\n\t\tif(buff){\n\t\t\t*buff = '\\0';\n\t\t}\n\t\treturn 0;\n\t}\n\ttmpretval = strlen(str);\n\tif(tmpretval>=INT_MAX){\n\t\ttmpretval = INT_MAX-1;\n\t}\n\tretval = (int)tmpretval;\n\tif(buff){\n\t\tmemcpy(buff,str,retval+1);\n\t\tbuff[retval] = '\\0';\n\t}\n\topenmpt_free_string(str);\n\treturn retval;\n}",
        "output": "1",
        "idx": 6738
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int reverseSortFiles(MprDirEntry **d1, MprDirEntry **d2)\n{\n    char    *base1, *base2, *b1, *b2, *p1, *p2;\n    int     rc;\n\n    base1 = mprGetPathBase((*d1)->name);\n    base2 = mprGetPathBase((*d2)->name);\n\n    if (smatch(base1, base2)) {\n        return 0;\n    }\n    b1 = stok(base1, \"-\", &p1);\n    b2 = stok(base2, \"-\", &p2);\n    rc = scmp(b1, b2);\n    if (rc == 0) {\n        if (!p1) {\n            rc = 1;\n        } else if (!p2) {\n            rc = -1;\n        } else {\n            rc = scmp(p1, p2);\n        }\n    }\n    return -rc;\n}",
        "output": "1",
        "idx": 4976
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "list_table_status(MYSQL *mysql,const char *db,const char *wild)\n{\n  char query[NAME_LEN + 100];\n  int len;\n  MYSQL_RES *result;\n  MYSQL_ROW row;\n\n  len= sizeof(query);\n  len-= my_snprintf(query, len, \"show table status from `%s`\", db);\n  if (wild && wild[0] && len)\n    strxnmov(query + strlen(query), len, \" like '\", wild, \"'\", NullS);\n  if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n  {\n    fprintf(stderr,\"%s: Cannot get status for db: %s, table: %s: %s\\n\",\n\t    my_progname,db,wild ? wild : \"\",mysql_error(mysql));\n    if (mysql_errno(mysql) == ER_PARSE_ERROR)\n      fprintf(stderr,\"This error probably means that your MySQL server doesn't support the\\n\\'show table status' command.\\n\");\n    return 1;\n  }\n\n  printf(\"Database: %s\",db);\n  if (wild)\n    printf(\"  Wildcard: %s\",wild);\n  putchar('\\n');\n\n  print_res_header(result);\n  while ((row=mysql_fetch_row(result)))\n    print_res_row(result,row);\n  print_res_top(result);\n  mysql_free_result(result);\n  return 0;\n}",
        "output": "0",
        "idx": 7339
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int __usb_get_extra_descriptor(char *buffer, unsigned size,\n\t\t\t       unsigned char type, void **ptr, size_t minsize)\n{\n\tstruct usb_descriptor_header *header;\n\n\twhile (size >= sizeof(struct usb_descriptor_header)) {\n\t\theader = (struct usb_descriptor_header *)buffer;\n\n\t\tif (header->bLength < 2 || header->bLength > size) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"%s: bogus descriptor, type %d length %d\\n\",\n\t\t\t\tusbcore_name,\n\t\t\t\theader->bDescriptorType,\n\t\t\t\theader->bLength);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (header->bDescriptorType == type && header->bLength >= minsize) {\n\t\t\t*ptr = header;\n\t\t\treturn 0;\n\t\t}\n\n\t\tbuffer += header->bLength;\n\t\tsize -= header->bLength;\n\t}\n\treturn -1;\n}",
        "output": "0",
        "idx": 4189
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void disk_seqf_stop(struct seq_file *seqf, void *v)\n{\n\tstruct class_dev_iter *iter = seqf->private;\n\n\tif (iter) {\n\t\tclass_dev_iter_exit(iter);\n\t\tkfree(iter);\n\t\tseqf->private = NULL;\n\t}\n}",
        "output": "0",
        "idx": 1919
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int test_sqr(BIO *bp, BN_CTX *ctx)\n\t{\n\tBIGNUM a,c,d,e;\n\tint i;\n\n\tBN_init(&a);\n\tBN_init(&c);\n\tBN_init(&d);\n\tBN_init(&e);\n\n\tfor (i=0; i<num0; i++)\n\t\t{\n\t\tBN_bntest_rand(&a,40+i*10,0,0);\n\t\ta.neg=rand_neg();\n\t\tBN_sqr(&c,&a,ctx);\n\t\tif (bp != NULL)\n\t\t\t{\n\t\t\tif (!results)\n\t\t\t\t{\n\t\t\t\tBN_print(bp,&a);\n\t\t\t\tBIO_puts(bp,\" * \");\n\t\t\t\tBN_print(bp,&a);\n\t\t\t\tBIO_puts(bp,\" - \");\n\t\t\t\t}\n\t\t\tBN_print(bp,&c);\n\t\t\tBIO_puts(bp,\"\\n\");\n\t\t\t}\n\t\tBN_div(&d,&e,&c,&a,ctx);\n\t\tBN_sub(&d,&d,&a);\n\t\tif(!BN_is_zero(&d) || !BN_is_zero(&e))\n\t\t    {\n\t\t    fprintf(stderr,\"Square test failed!\\n\");\n\t\t    return 0;\n\t\t    }\n\t\t}\n\tBN_free(&a);\n\tBN_free(&c);\n\tBN_free(&d);\n\tBN_free(&e);\n\treturn(1);\n\t}",
        "output": "1",
        "idx": 4546
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvm_vcpu_initialized(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.target >= 0;\n}",
        "output": "0",
        "idx": 3247
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\tmsg->msg_namelen = 0;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err == 0)\n\t\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tskb_free_datagram(sk, skb);\n\n\treturn err ? : copied;\n}",
        "output": "1",
        "idx": 894
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "eval_next_line(char_u *arg, evalarg_T *evalarg)\n{\n    garray_T\t*gap = &evalarg->eval_ga;\n    char_u\t*line;\n\n    if (arg != NULL)\n    {\n\tif (*arg == NL)\n\t    return newline_skip_comments(arg);\n\tif (*skipwhite(arg) == '#')\n\t    *arg = NUL;\n    }\n\n    if (evalarg->eval_cookie != NULL)\n\tline = evalarg->eval_getline(0, evalarg->eval_cookie, 0,\n\t\t\t\t\t\t\t   GETLINE_CONCAT_ALL);\n    else\n\tline = next_line_from_context(evalarg->eval_cctx, TRUE);\n    if (line == NULL)\n\treturn NULL;\n\n    ++evalarg->eval_break_count;\n    if (gap->ga_itemsize > 0 && ga_grow(gap, 1) == OK)\n    {\n\tchar_u *p = skipwhite(line);\n\n\tif (*p == NUL || vim9_comment_start(p))\n\t{\n\t    vim_free(line);\n\t    line = vim_strsave((char_u *)\"\");\n\t}\n\n\t((char_u **)gap->ga_data)[gap->ga_len] = line;\n\t++gap->ga_len;\n    }\n    else if (evalarg->eval_cookie != NULL)\n    {\n\tvim_free(evalarg->eval_tofree);\n\tevalarg->eval_tofree = line;\n    }\n\n    evalarg->eval_using_cmdline = FALSE;\n    return skipwhite(line);\n}",
        "output": "1",
        "idx": 5822
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hb_set_invert (hb_set_t *set)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n\n  set->invert ();\n}",
        "output": "1",
        "idx": 5556
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dwc3_gadget_giveback(struct dwc3_ep *dep, struct dwc3_request *req,\n\t\tint status)\n{\n\tstruct dwc3\t\t\t*dwc = dep->dwc;\n\n\treq->started = false;\n\tlist_del(&req->list);\n\treq->remaining = 0;\n\n\tif (req->request.status == -EINPROGRESS)\n\t\treq->request.status = status;\n\n\tif (req->trb)\n\t\tusb_gadget_unmap_request_by_dev(dwc->sysdev,\n\t\t\t\t\t\t&req->request, req->direction);\n\n\treq->trb = NULL;\n\n\ttrace_dwc3_gadget_giveback(req);\n\n\tspin_unlock(&dwc->lock);\n\tusb_gadget_giveback_request(&dep->endpoint, &req->request);\n\tspin_lock(&dwc->lock);\n\n\tif (dep->number > 1)\n\t\tpm_runtime_put(dwc->dev);\n}",
        "output": "1",
        "idx": 2944
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,\n\t\t\t  __be32 saddr, __be32 daddr, struct ip_options *opt)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct iphdr *iph;\n\n\tskb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));\n\tskb_reset_network_header(skb);\n\tiph = ip_hdr(skb);\n\tiph->version  = 4;\n\tiph->ihl      = 5;\n\tiph->tos      = inet->tos;\n\tif (ip_dont_fragment(sk, &rt->dst))\n\t\tiph->frag_off = htons(IP_DF);\n\telse\n\t\tiph->frag_off = 0;\n\tiph->ttl      = ip_select_ttl(inet, &rt->dst);\n\tiph->daddr    = rt->rt_dst;\n\tiph->saddr    = rt->rt_src;\n\tiph->protocol = sk->sk_protocol;\n\tip_select_ident(iph, &rt->dst, sk);\n\n\tif (opt && opt->optlen) {\n\t\tiph->ihl += opt->optlen>>2;\n\t\tip_options_build(skb, opt, daddr, rt, 0);\n\t}\n\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\n\treturn ip_local_out(skb);\n}",
        "output": "1",
        "idx": 360
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void do_service(Socket_T s) {\n        volatile HttpResponse res = create_HttpResponse(s);\n        volatile HttpRequest req = create_HttpRequest(s);\n        if (res && req) {\n                if (Run.httpd.flags & Httpd_Ssl)\n                        set_header(res, \"Strict-Transport-Security\", \"max-age=63072000; includeSubdomains; preload\");\n                if (is_authenticated(req, res)) {\n                        set_header(res, \"Set-Cookie\", \"securitytoken=%s; Max-Age=600; HttpOnly; SameSite=strict%s\", res->token, Run.httpd.flags & Httpd_Ssl ? \"; Secure\" : \"\");\n                        if (IS(req->method, METHOD_GET))\n                                Impl.doGet(req, res);\n                        else if (IS(req->method, METHOD_POST))\n                                Impl.doPost(req, res);\n                        else\n                                send_error(req, res, SC_NOT_IMPLEMENTED, \"Method not implemented\");\n                }\n                send_response(req, res);\n        }\n        done(req, res);\n}",
        "output": "0",
        "idx": 8443
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void copyIPv6IfDifferent(void * dest, const void * src)\n{\n\tif(dest != src) {\n\t\tmemcpy(dest, src, sizeof(struct in6_addr));\n\t}\n}",
        "output": "1",
        "idx": 4580
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool matchExpression(MprJson *obj, int operator, char *value)\n{\n    if (!(obj->type & MPR_JSON_VALUE)) {\n        return 0;\n    }\n    if ((value = stok(value, \"'\\\"\", NULL)) == 0) {\n        return 0;\n    }\n    switch (operator) {\n    case JSON_OP_EQ:\n        return smatch(obj->value, value);\n    case JSON_OP_NE:\n        return !smatch(obj->value, value);\n    case JSON_OP_LT:\n        return scmp(obj->value, value) < 0;\n    case JSON_OP_LE:\n        return scmp(obj->value, value) <= 0;\n    case JSON_OP_GT:\n        return scmp(obj->value, value) > 0;\n    case JSON_OP_GE:\n        return scmp(obj->value, value) >= 0;\n    case JSON_OP_MATCH:\n        return scontains(obj->value, value) != 0;\n    case JSON_OP_NMATCH:\n        return scontains(obj->value, value) == 0;\n    default:\n        return 0;\n    }\n}",
        "output": "0",
        "idx": 7075
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n{\n        uint8* bufp = buf;\n        int32  bytes_read = 0;\n        uint32 strip, nstrips   = TIFFNumberOfStrips(in);\n        uint32 stripsize = TIFFStripSize(in);\n        uint32 rows = 0;\n        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n\n        for (strip = 0; strip < nstrips; strip++) {\n                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);\n                rows = bytes_read / scanline_size;\n                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))\n                        TIFFError(\"\", \"Strip %d: read %lu bytes, strip size %lu\",\n                                  (int)strip + 1, (unsigned long) bytes_read,\n                                  (unsigned long)stripsize);\n\n                if (bytes_read < 0 && !ignore) {\n                        TIFFError(\"\", \"Error reading strip %lu after %lu rows\",\n                                  (unsigned long) strip, (unsigned long)rows);\n                        return 0;\n                }\n                bufp += bytes_read;\n        }\n\n        return 1;\n} ",
        "output": "0",
        "idx": 5881
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)\n{\n    int i, length;\n\n    segment->nb_index_entries = avio_rb32(pb);\n\n    length = avio_rb32(pb);\n    if(segment->nb_index_entries && length < 11)\n        return AVERROR_INVALIDDATA;\n\n    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||\n        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||\n        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries)))) {\n        av_freep(&segment->temporal_offset_entries);\n        av_freep(&segment->flag_entries);\n        return AVERROR(ENOMEM);\n    }\n\n    for (i = 0; i < segment->nb_index_entries; i++) {\n        if(avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n        segment->temporal_offset_entries[i] = avio_r8(pb);\n        avio_r8(pb);                                        \n        segment->flag_entries[i] = avio_r8(pb);\n        segment->stream_offset_entries[i] = avio_rb64(pb);\n        avio_skip(pb, length - 11);\n    }\n    return 0;\n}",
        "output": "0",
        "idx": 4909
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(skcipher);\n\n\tif (tfm->__crt_alg->cra_type == &crypto_blkcipher_type)\n\t\treturn crypto_init_skcipher_ops_blkcipher(tfm);\n\n\tif (tfm->__crt_alg->cra_type == &crypto_ablkcipher_type ||\n\t    tfm->__crt_alg->cra_type == &crypto_givcipher_type)\n\t\treturn crypto_init_skcipher_ops_ablkcipher(tfm);\n\n\tskcipher->setkey = alg->setkey;\n\tskcipher->encrypt = alg->encrypt;\n\tskcipher->decrypt = alg->decrypt;\n\tskcipher->ivsize = alg->ivsize;\n\tskcipher->keysize = alg->max_keysize;\n\n\tif (alg->exit)\n\t\tskcipher->base.exit = crypto_skcipher_exit_tfm;\n\n\tif (alg->init)\n\t\treturn alg->init(skcipher);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1590
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_lchown(const char *path)\n{\n\tif (lchown(path, 0, 0) == 0) {\n\t\tfprintf(stderr, \"leak at lchown of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at lchown of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}",
        "output": "0",
        "idx": 7303
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __return_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\ts64 slack_runtime = cfs_rq->runtime_remaining - min_cfs_rq_runtime;\n\n\tif (slack_runtime <= 0)\n\t\treturn;\n\n\traw_spin_lock(&cfs_b->lock);\n\tif (cfs_b->quota != RUNTIME_INF) {\n\t\tcfs_b->runtime += slack_runtime;\n\n\t\tif (cfs_b->runtime > sched_cfs_bandwidth_slice() &&\n\t\t    !list_empty(&cfs_b->throttled_cfs_rq))\n\t\t\tstart_cfs_slack_bandwidth(cfs_b);\n\t}\n\traw_spin_unlock(&cfs_b->lock);\n\n\tcfs_rq->runtime_remaining -= slack_runtime;\n}",
        "output": "0",
        "idx": 4443
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *ipc_alloc(int size)\n{\n\tvoid *out;\n\tif(size > PAGE_SIZE)\n\t\tout = vmalloc(size);\n\telse\n\t\tout = kmalloc(size, GFP_KERNEL);\n\treturn out;\n}",
        "output": "0",
        "idx": 3237
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rsi_send_beacon(struct rsi_common *common)\n{\n\tstruct sk_buff *skb = NULL;\n\tu8 dword_align_bytes = 0;\n\n\tskb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemset(skb->data, 0, MAX_MGMT_PKT_SIZE);\n\n\tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n\tif (dword_align_bytes)\n\t\tskb_pull(skb, (64 - dword_align_bytes));\n\tif (rsi_prepare_beacon(common, skb)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to prepare beacon\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\tskb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);\n\trsi_set_event(&common->tx_thread.event);\n\trsi_dbg(DATA_TX_ZONE, \"%s: Added to beacon queue\\n\", __func__);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 4501
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC MprKey *mprAddKey(MprHash *hash, cvoid *key, cvoid *ptr)\n{\n    MprKey      *sp, *prevSp;\n    int         index;\n\n    if (hash == 0 || key == 0) {\n        assert(hash && key);\n        return 0;\n    }\n    lock(hash);\n    if ((sp = lookupHash(&index, &prevSp, hash, key)) != 0) {\n        if (hash->flags & MPR_HASH_UNIQUE) {\n            unlock(hash);\n            return 0;\n        }\n        sp->data = ptr;\n        unlock(hash);\n        return sp;\n    }\n    if ((sp = mprAllocStructNoZero(MprKey)) == 0) {\n        unlock(hash);\n        return 0;\n    }\n    sp->data = ptr;\n    if (!(hash->flags & MPR_HASH_STATIC_KEYS)) {\n        sp->key = dupKey(hash, key);\n    } else {\n        sp->key = (void*) key;\n    }\n    sp->type = 0;\n    sp->bucket = index;\n    sp->next = hash->buckets[index];\n    hash->buckets[index] = sp;\n    hash->length++;\n    unlock(hash);\n    return sp;\n}",
        "output": "0",
        "idx": 7071
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void hugetlb_unreserve_pages(struct inode *inode, long offset, long freed)\n{\n\tstruct hstate *h = hstate_inode(inode);\n\tlong chg = region_truncate(&inode->i_mapping->private_list, offset);\n\n\tspin_lock(&inode->i_lock);\n\tinode->i_blocks -= (blocks_per_huge_page(h) * freed);\n\tspin_unlock(&inode->i_lock);\n\n\thugetlb_put_quota(inode->i_mapping, (chg - freed));\n\thugetlb_acct_memory(h, -(chg - freed));\n}",
        "output": "1",
        "idx": 696
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_cmd (xd3_stream *stream, const char *buf)\n{\n  int ret;\n  if ((ret = system (buf)) != 0)\n    {\n      if (WIFEXITED (ret))\n\t{\n\t  stream->msg = \"command exited non-zero\";\n\t  IF_DEBUG1 (XPR(NT \"command was: %s\\n\", buf));\n\t}\n      else\n\t{\n\t  stream->msg = \"abnormal command termination\";\n\t}\n      return XD3_INTERNAL;\n    }\n  return 0;\n}",
        "output": "1",
        "idx": 5124
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void macvlan_common_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\n\tdev->priv_flags\t       &= ~IFF_XMIT_DST_RELEASE;\n\tdev->netdev_ops\t\t= &macvlan_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\tdev->header_ops\t\t= &macvlan_hard_header_ops,\n\tdev->ethtool_ops\t= &macvlan_ethtool_ops;\n}",
        "output": "1",
        "idx": 582
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ossl_cipher_set_key(VALUE self, VALUE key)\n{\n    EVP_CIPHER_CTX *ctx;\n    int key_len;\n\n    StringValue(key);\n    GetCipher(self, ctx);\n\n    key_len = EVP_CIPHER_CTX_key_length(ctx);\n    if (RSTRING_LEN(key) != key_len)\n\tossl_raise(rb_eArgError, \"key must be %d bytes\", key_len);\n\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n\n    rb_ivar_set(self, id_key_set, Qtrue);\n\n    return key;\n}",
        "output": "0",
        "idx": 8499
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int64 asNumber(cchar *version)\n{\n    char    *tok;\n    int64   major, minor, patch;\n\n    major = stoi(stok(sclone(version), \".\", &tok));\n    minor = stoi(stok(tok, \".\", &tok));\n    patch = stoi(stok(tok, \".\", &tok));\n    return (((major * VER_FACTOR) + minor) * VER_FACTOR) + patch;\n}",
        "output": "1",
        "idx": 4978
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mark_files_ro(struct super_block *sb)\n{\n\tstruct file *f;\n\n\tlg_global_lock(&files_lglock);\n\tdo_file_list_for_each_entry(sb, f) {\n\t\tif (!file_count(f))\n\t\t\tcontinue;\n\t\tif (!(f->f_mode & FMODE_WRITE))\n\t\t\tcontinue;\n\t\tspin_lock(&f->f_lock);\n\t\tf->f_mode &= ~FMODE_WRITE;\n\t\tspin_unlock(&f->f_lock);\n\t\tif (file_check_writeable(f) != 0)\n\t\t\tcontinue;\n\t\t__mnt_drop_write(f->f_path.mnt);\n\t\tfile_release_write(f);\n\t} while_file_list_for_each_entry;\n\tlg_global_unlock(&files_lglock);\n}",
        "output": "1",
        "idx": 2372
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error_t ipStringToAddr(const char_t *str, IpAddr *ipAddr)\n{\n   error_t error;\n\n#if (IPV6_SUPPORT == ENABLED)\n   if(strchr(str, ':'))\n   {\n      ipAddr->length = sizeof(Ipv6Addr);\n      error = ipv6StringToAddr(str, &ipAddr->ipv6Addr);\n   }\n   else\n#endif\n#if (IPV4_SUPPORT == ENABLED)\n   if(strchr(str, '.'))\n   {\n      ipAddr->length = sizeof(Ipv4Addr);\n      error = ipv4StringToAddr(str, &ipAddr->ipv4Addr);\n   }\n   else\n#endif\n   {\n      error = ERROR_FAILURE;\n   }\n\n   return error;\n}",
        "output": "1",
        "idx": 8512
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int    cJSON_GetArraySize(cJSON *array)\t\t\t\t\t\t\t{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}",
        "output": "0",
        "idx": 8327
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= type->match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\n\tif (!ctx.match_data.cmp)\n\t\treturn ERR_PTR(-ENOKEY);\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tkey = keyring_search_aux(keyring, &ctx);\n\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}",
        "output": "1",
        "idx": 2676
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char *cmd_hash_engine(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"on\") == 0)  {\n        dcfg->hash_is_enabled = HASH_ENABLED;\n        dcfg->hash_enforcement = HASH_ENABLED;\n    }\n    else if (strcasecmp(p1, \"off\") == 0)    {\n        dcfg->hash_is_enabled = HASH_DISABLED;\n        dcfg->hash_enforcement = HASH_DISABLED;\n    }\n    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SexHashEngine: %s\", p1);\n\n    return NULL;\n}",
        "output": "0",
        "idx": 5287
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dn_create(struct net *net, struct socket *sock, int protocol,\n\t\t     int kern)\n{\n\tstruct sock *sk;\n\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\n\tswitch (sock->type) {\n\tcase SOCK_SEQPACKET:\n\t\tif (protocol != DNPROTO_NSP)\n\t\t\treturn -EPROTONOSUPPORT;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\n\n\tif ((sk = dn_alloc_sock(net, sock, GFP_KERNEL, kern)) == NULL)\n\t\treturn -ENOBUFS;\n\n\tsk->sk_protocol = protocol;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1461
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "krb5_gss_process_context_token(minor_status, context_handle,\n                               token_buffer)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t token_buffer;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 majerr;\n\n    ctx = (krb5_gss_ctx_id_t) context_handle;\n\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n\n    if (GSS_ERROR(majerr = kg_unseal(minor_status, context_handle,\n                                     token_buffer,\n                                     GSS_C_NO_BUFFER, NULL, NULL,\n                                     KG_TOK_DEL_CTX)))\n        return(majerr);\n\n\n    return(krb5_gss_delete_sec_context(minor_status, &context_handle,\n                                       GSS_C_NO_BUFFER));\n}",
        "output": "1",
        "idx": 34
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int stellaris_enet_post_load(void *opaque, int version_id)\n{\n    stellaris_enet_state *s = opaque;\n    int i;\n\n    if (s->next_packet >= ARRAY_SIZE(s->rx)) {\n        return -1;\n    }\n\n    if (s->np > ARRAY_SIZE(s->rx)) {\n        return -1;\n    }\n\n    for (i = 0; i < ARRAY_SIZE(s->rx); i++) {\n        if (s->rx[i].len > ARRAY_SIZE(s->rx[i].data)) {\n            return -1;\n        }\n    }\n\n    if (s->rx_fifo_offset > ARRAY_SIZE(s->rx[0].data) - 4) {\n        return -1;\n    }\n\n    if (s->tx_fifo_len > ARRAY_SIZE(s->tx_fifo)) {\n        return -1;\n    }\n\n    return 0;\n}",
        "output": "0",
        "idx": 5321
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "buffer_add_range(int fd, struct evbuffer *evb, struct range *range)\n{\n\tchar\tbuf[BUFSIZ];\n\tsize_t\tn, range_sz;\n\tssize_t\tnread;\n\n\tif (lseek(fd, range->start, SEEK_SET) == -1)\n\t\treturn (0);\n\n\trange_sz = range->end - range->start + 1;\n\twhile (range_sz) {\n\t\tn = MINIMUM(range_sz, sizeof(buf));\n\t\tif ((nread = read(fd, buf, n)) == -1)\n\t\t\treturn (0);\n\n\t\tevbuffer_add(evb, buf, nread);\n\t\trange_sz -= nread;\n\t}\n\n\treturn (1);\n}",
        "output": "1",
        "idx": 5612
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, const char* hostname, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify)\n{\n\tGIOChannel *handle, *ssl_handle;\n\n\thandle = net_connect_ip(ip, port, my_ip);\n\tif (handle == NULL)\n\t\treturn NULL;\n\tssl_handle  = irssi_ssl_get_iochannel(handle, hostname, cert, pkey, cafile, capath, verify);\n\tif (ssl_handle == NULL)\n\t\tg_io_channel_unref(handle);\n\treturn ssl_handle;\n}",
        "output": "0",
        "idx": 4673
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rad_get_vendor_attr(u_int32_t *vendor, const void **data, size_t *len)\n{\n\tstruct vendor_attribute *attr;\n\n\tattr = (struct vendor_attribute *)*data;\n\t*vendor = ntohl(attr->vendor_value);\n\t*data = attr->attrib_data;\n\t*len = attr->attrib_len - 2;\n\n\treturn (attr->attrib_type);\n}",
        "output": "1",
        "idx": 3818
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ossl_associate_connection(struct Curl_easy *data,\n                                      struct connectdata *conn,\n                                      int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n\n  if(!backend->handle)\n    return;\n\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    int data_idx = ossl_get_ssl_data_index();\n    int connectdata_idx = ossl_get_ssl_conn_index();\n    int sockindex_idx = ossl_get_ssl_sockindex_index();\n    int proxy_idx = ossl_get_proxy_index();\n\n    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&\n       proxy_idx >= 0) {\n      SSL_set_ex_data(backend->handle, data_idx, data);\n      SSL_set_ex_data(backend->handle, connectdata_idx, conn);\n      SSL_set_ex_data(backend->handle, sockindex_idx, conn->sock + sockindex);\n#ifndef CURL_DISABLE_PROXY\n      SSL_set_ex_data(backend->handle, proxy_idx, SSL_IS_PROXY() ? (void *) 1:\n                      NULL);\n#else\n      SSL_set_ex_data(backend->handle, proxy_idx, NULL);\n#endif\n    }\n  }\n}",
        "output": "0",
        "idx": 8455
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vgacon_restore_screen(struct vc_data *c)\n{\n\tc->vc_origin = c->vc_visible_origin;\n\tvgacon_scrollback_cur->save = 0;\n\n\tif (!vga_is_gfx && !vgacon_scrollback_cur->restore) {\n\t\tscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ?\n\t\t\t    vga_vram_size : c->vc_screenbuf_size);\n\t\tvgacon_scrollback_cur->restore = 1;\n\t\tvgacon_scrollback_cur->cur = vgacon_scrollback_cur->cnt;\n\t}\n}",
        "output": "1",
        "idx": 1862
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int opl3_load_patch(int dev, int format, const char __user *addr,\n\t\tint offs, int count, int pmgr_flag)\n{\n\tstruct sbi_instrument ins;\n\n\tif (count <sizeof(ins))\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Patch record too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif(copy_from_user(&((char *) &ins)[offs], addr + offs, sizeof(ins) - offs))\n\t\treturn -EFAULT;\n\n\tif (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR)\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Invalid instrument number %d\\n\", ins.channel);\n\t\treturn -EINVAL;\n\t}\n\tins.key = format;\n\n\treturn store_instr(ins.channel, &ins);\n}",
        "output": "1",
        "idx": 272
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void enc624j600UpdateMacConfig(NetInterface *interface)\n{\n   uint16_t duplexMode;\n\n   duplexMode = enc624j600ReadReg(interface, ENC624J600_REG_ESTAT) & ESTAT_PHYDPX;\n\n   if(duplexMode)\n   {\n      enc624j600WriteReg(interface, ENC624J600_REG_MACON2, MACON2_DEFER |\n         MACON2_PADCFG2 | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1 | MACON2_FULDPX);\n      enc624j600WriteReg(interface, ENC624J600_REG_MABBIPG, 0x15);\n   }\n   else\n   {\n      enc624j600WriteReg(interface, ENC624J600_REG_MACON2, MACON2_DEFER |\n         MACON2_PADCFG2 | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1);\n      enc624j600WriteReg(interface, ENC624J600_REG_MABBIPG, 0x12);\n   }\n}",
        "output": "1",
        "idx": 8550
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int mount_entry_on_systemfs(struct mntent *mntent)\n{\n  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);\n}",
        "output": "0",
        "idx": 6043
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "initpyfribidi (void)\n{\n\tPyObject *module;\n\n\n\tmodule = Py_InitModule3 (\"pyfribidi\", PyfribidiMethods,\n\t\t\t\t _pyfribidi__doc__);\n\n\tPyModule_AddIntConstant (module, \"RTL\", (long) FRIBIDI_TYPE_RTL);\n\tPyModule_AddIntConstant (module, \"LTR\", (long) FRIBIDI_TYPE_LTR);\n\tPyModule_AddIntConstant (module, \"ON\", (long) FRIBIDI_TYPE_ON);\n\n\tPyModule_AddStringConstant (module, \"__author__\",\n\t\t\t\t    \"Yaacov Zamir and Nir Soffer\");\n}",
        "output": "1",
        "idx": 3614
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "u64 secure_dccpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t  __be16 sport, __be16 dport)\n{\n\tu32 secret[MD5_MESSAGE_BYTES / 4];\n\tu32 hash[MD5_DIGEST_WORDS];\n\tu64 seq;\n\tu32 i;\n\n\tmemcpy(hash, saddr, 16);\n\tfor (i = 0; i < 4; i++)\n\t\tsecret[i] = net_secret[i] + daddr[i];\n\tsecret[4] = net_secret[4] +\n\t\t(((__force u16)sport << 16) + (__force u16)dport);\n\tfor (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)\n\t\tsecret[i] = net_secret[i];\n\n\tmd5_transform(hash, secret);\n\n\tseq = hash[0] | (((u64)hash[1]) << 32);\n\tseq += ktime_to_ns(ktime_get_real());\n\tseq &= (1ull << 48) - 1;\n\n\treturn seq;\n}",
        "output": "0",
        "idx": 791
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int addrconf_sysctl_mtu(struct ctl_table *ctl, int write,\n\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct inet6_dev *idev = ctl->extra1;\n\tint min_mtu = IPV6_MIN_MTU;\n\tstruct ctl_table lctl;\n\n\tlctl = *ctl;\n\tlctl.extra1 = &min_mtu;\n\tlctl.extra2 = idev ? &idev->dev->mtu : NULL;\n\n\treturn proc_dointvec_minmax(&lctl, write, buffer, lenp, ppos);\n}",
        "output": "0",
        "idx": 3869
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n        struct ipddp_route __user *rt = ifr->ifr_data;\n        struct ipddp_route rcp, rcp2, *rp;\n\n        if(!capable(CAP_NET_ADMIN))\n                return -EPERM;\n\n\tif(copy_from_user(&rcp, rt, sizeof(rcp)))\n\t\treturn -EFAULT;\n\n        switch(cmd)\n        {\n\t\tcase SIOCADDIPDDPRT:\n                        return ipddp_create(&rcp);\n\n                case SIOCFINDIPDDPRT:\n\t\t\tspin_lock_bh(&ipddp_route_lock);\n\t\t\trp = __ipddp_find_route(&rcp);\n\t\t\tif (rp)\n\t\t\t\tmemcpy(&rcp2, rp, sizeof(rcp2));\n\t\t\tspin_unlock_bh(&ipddp_route_lock);\n\n\t\t\tif (rp) {\n\t\t\t\tif (copy_to_user(rt, &rcp2,\n\t\t\t\t\t\t sizeof(struct ipddp_route)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -ENOENT;\n\n                case SIOCDELIPDDPRT:\n                        return ipddp_delete(&rcp);\n\n                default:\n                        return -EINVAL;\n        }\n}",
        "output": "1",
        "idx": 3008
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t\telse if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&\n\t\t\t !in_group_p(inode->i_gid) &&\n\t\t\t !capable_wrt_inode_uidgid(dir, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}",
        "output": "0",
        "idx": 4135
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dtls1_process_buffered_records(SSL *s)\n    {\n    pitem *item;\n    \n    item = pqueue_peek(s->d1->unprocessed_rcds.q);\n    if (item)\n        {\n        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)\n            return(1);  \n        \n        while (pqueue_peek(s->d1->unprocessed_rcds.q))\n            {\n            dtls1_get_unprocessed_record(s);\n            if ( ! dtls1_process_record(s))\n                return(0);\n            if(dtls1_buffer_record(s, &(s->d1->processed_rcds),\n                s->s3->rrec.seq_num)<0)\n                return -1;\n            }\n        }\n\n    s->d1->processed_rcds.epoch = s->d1->r_epoch;\n    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;\n\n    return(1);\n    }",
        "output": "0",
        "idx": 6373
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rfbReleaseClientIterator(rfbClientIteratorPtr iterator)\n{\n  if(iterator->next) rfbDecrClientRef(iterator->next);\n  free(iterator);\n}",
        "output": "1",
        "idx": 6362
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sraSpanInsertAfter(sraSpan *newspan, sraSpan *after) {\n  newspan->_next = after->_next;\n  newspan->_prev = after;\n  after->_next->_prev = newspan;\n  after->_next = newspan;\n}",
        "output": "1",
        "idx": 6358
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void unix_inflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tspin_lock(&unix_gc_lock);\n\n\t\tif (atomic_long_inc_return(&u->inflight) == 1) {\n\t\t\tBUG_ON(!list_empty(&u->link));\n\t\t\tlist_add_tail(&u->link, &gc_inflight_list);\n\t\t} else {\n\t\t\tBUG_ON(list_empty(&u->link));\n\t\t}\n\t\tunix_tot_inflight++;\n\t\tspin_unlock(&unix_gc_lock);\n\t}\n}",
        "output": "1",
        "idx": 1026
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "init_evalarg(evalarg_T *evalarg)\n{\n    CLEAR_POINTER(evalarg);\n    ga_init2(&evalarg->eval_tofree_ga, sizeof(char_u *), 20);\n}",
        "output": "1",
        "idx": 5824
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void show_object_with_name(FILE *out, struct object *obj,\n\t\t\t   struct strbuf *path, const char *component)\n{\n\tchar *name = path_name(path, component);\n\tchar *p;\n\n\tfprintf(out, \"%s \", oid_to_hex(&obj->oid));\n\tfor (p = name; *p && *p != '\\n'; p++)\n\t\tfputc(*p, out);\n\tfputc('\\n', out);\n\n\tfree(name);\n}",
        "output": "1",
        "idx": 5212
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static irqreturn_t snd_msnd_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_msnd *chip = dev_id;\n\tvoid *pwDSPQData = chip->mappedbase + DSPQ_DATA_BUFF;\n\n\n\twhile (readw(chip->DSPQ + JQS_wTail) != readw(chip->DSPQ + JQS_wHead)) {\n\t\tu16 wTmp;\n\n\t\tsnd_msnd_eval_dsp_msg(chip,\n\t\t\treadw(pwDSPQData + 2 * readw(chip->DSPQ + JQS_wHead)));\n\n\t\twTmp = readw(chip->DSPQ + JQS_wHead) + 1;\n\t\tif (wTmp > readw(chip->DSPQ + JQS_wSize))\n\t\t\twritew(0, chip->DSPQ + JQS_wHead);\n\t\telse\n\t\t\twritew(wTmp, chip->DSPQ + JQS_wHead);\n\t}\n\tinb(chip->io + HP_RXL);\n\treturn IRQ_HANDLED;\n}",
        "output": "1",
        "idx": 1616
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "compile_get_env(char_u **arg, cctx_T *cctx)\n{\n    char_u\t*start = *arg;\n    int\t\tlen;\n    int\t\tret;\n    char_u\t*name;\n\n    ++*arg;\n    len = get_env_len(arg);\n    if (len == 0)\n    {\n\tsemsg(_(e_syntax_error_at_str), start - 1);\n\treturn FAIL;\n    }\n\n    name = vim_strnsave(start, len + 1);\n    ret = generate_LOAD(cctx, ISN_LOADENV, 0, name, &t_string);\n    vim_free(name);\n    return ret;\n}",
        "output": "1",
        "idx": 5714
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool_t xdr_nullstring(XDR *xdrs, char **objp)\n{\n     u_int size;\n\n     if (xdrs->x_op == XDR_ENCODE) {\n\t  if (*objp == NULL)\n\t       size = 0;\n\t  else\n\t       size = strlen(*objp) + 1;\n     }\n     if (! xdr_u_int(xdrs, &size)) {\n\t  return FALSE;\n\t}\n     switch (xdrs->x_op) {\n     case XDR_DECODE:\n\t  if (size == 0) {\n\t       *objp = NULL;\n\t       return TRUE;\n\t  } else if (*objp == NULL) {\n\t       *objp = (char *) mem_alloc(size);\n\t       if (*objp == NULL) {\n\t\t    errno = ENOMEM;\n\t\t    return FALSE;\n\t       }\n\t  }\n\t  if (!xdr_opaque(xdrs, *objp, size))\n\t\t  return FALSE;\n\t  if ((*objp)[size - 1] != '\\0')\n\t\t  return FALSE;\n\t  if (memchr(*objp, '\\0', size - 1) != NULL)\n\t\t  return FALSE;\n\t  return TRUE;\n\n     case XDR_ENCODE:\n\t  if (size != 0)\n\t       return (xdr_opaque(xdrs, *objp, size));\n\t  return TRUE;\n\n     case XDR_FREE:\n\t  if (*objp != NULL)\n\t       mem_free(*objp, size);\n\t  *objp = NULL;\n\t  return TRUE;\n     }\n\n     return FALSE;\n}",
        "output": "0",
        "idx": 177
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static pj_status_t STATUS_FROM_SSL_ERR(char *action, pj_ssl_sock_t *ssock,\n\t\t\t\t       unsigned long err)\n{\n    int level = 0;\n    int len = 0; \n\n    ERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);\n    level++;\n\n    if (err == SSL_ERROR_SSL) {\n\terr = ERR_get_error();\n\tERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);\n    }\n\n    ssock->last_err = err;\n    return GET_STATUS_FROM_SSL_ERR(err);\n}",
        "output": "1",
        "idx": 8028
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ptrace_setxregs(struct task_struct *child, void __user *uregs)\n{\n\tstruct thread_info *ti = task_thread_info(child);\n\tstruct pt_regs *regs = task_pt_regs(child);\n\telf_xtregs_t *xtregs = uregs;\n\tint ret = 0;\n\n\tif (!access_ok(VERIFY_READ, uregs, sizeof(elf_xtregs_t)))\n\t\treturn -EFAULT;\n\n#if XTENSA_HAVE_COPROCESSORS\n\tcoprocessor_flush_all(ti);\n\tcoprocessor_release_all(ti);\n\n\tret |= __copy_from_user(&ti->xtregs_cp, &xtregs->cp0, \n\t\t\t\tsizeof(xtregs_coprocessor_t));\n#endif\n\tret |= __copy_from_user(&regs->xtregs_opt, &xtregs->opt,\n\t\t\t\tsizeof(xtregs->opt));\n\tret |= __copy_from_user(&ti->xtregs_user, &xtregs->user,\n\t\t\t\tsizeof(xtregs->user));\n\n\treturn ret ? -EFAULT : 0;\n}",
        "output": "0",
        "idx": 735
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PredictorEncodeRow(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)\n{\n\tTIFFPredictorState *sp = PredictorState(tif);\n\n\tassert(sp != NULL);\n\tassert(sp->encodepfunc != NULL);\n\tassert(sp->encoderow != NULL);\n\n\tif( !(*sp->encodepfunc)(tif, bp, cc) )\n        return 0;\n\treturn (*sp->encoderow)(tif, bp, cc, s);\n}",
        "output": "0",
        "idx": 5897
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tif (vapic_addr) {\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t\t\t\t&vcpu->arch.apic->vapic_cache,\n\t\t\t\t\tvapic_addr, sizeof(u32)))\n\t\t\treturn -EINVAL;\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t} else {\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t}\n\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\treturn 0;\n}",
        "output": "0",
        "idx": 3425
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n        p_code_block)\n{\n    OPJ_UINT32 l_data_size;\n\n    l_data_size = (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n                               (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n\n    if (l_data_size > p_code_block->data_size) {\n        if (p_code_block->data) {\n            opj_free(p_code_block->data - 1);\n        }\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1);\n        if (! p_code_block->data) {\n            p_code_block->data_size = 0U;\n            return OPJ_FALSE;\n        }\n        p_code_block->data_size = l_data_size;\n\n        p_code_block->data[0] = 0;\n        p_code_block->data += 1; \n    }\n    return OPJ_TRUE;\n}",
        "output": "1",
        "idx": 5532
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int sas_smp_get_phy_events(struct sas_phy *phy)\n{\n\tint res;\n\tu8 *req;\n\tu8 *resp;\n\tstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\n\tstruct domain_device *dev = sas_find_dev_by_rphy(rphy);\n\n\treq = alloc_smp_req(RPEL_REQ_SIZE);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tresp = alloc_smp_resp(RPEL_RESP_SIZE);\n\tif (!resp) {\n\t\tkfree(req);\n\t\treturn -ENOMEM;\n\t}\n\n\treq[1] = SMP_REPORT_PHY_ERR_LOG;\n\treq[9] = phy->number;\n\n\tres = smp_execute_task(dev, req, RPEL_REQ_SIZE,\n\t\t\t            resp, RPEL_RESP_SIZE);\n\n\tif (!res)\n\t\tgoto out;\n\n\tphy->invalid_dword_count = scsi_to_u32(&resp[12]);\n\tphy->running_disparity_error_count = scsi_to_u32(&resp[16]);\n\tphy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);\n\tphy->phy_reset_problem_count = scsi_to_u32(&resp[24]);\n\n out:\n\tkfree(req);\n\tkfree(resp);\n\treturn res;\n\n}",
        "output": "0",
        "idx": 2641
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "horDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\tTIFFPredictorState* sp = PredictorState(tif);\n\ttmsize_t stride = sp->stride;\n\tuint16 *wp = (uint16*) cp0;\n\ttmsize_t wc = cc/2;\n\n    if((cc%(2*stride))!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"horDiff8\",\n                     \"%s\", \"(cc%(2*stride))!=0\");\n        return 0;\n    }\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\twp += wc - 1;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] - (unsigned int)wp[0]) & 0xffff); wp--)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n\treturn 1;\n}",
        "output": "0",
        "idx": 5891
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_inquire_sec_context_by_oid(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_OID desired_object,\n\t\tgss_buffer_set_t *data_set)\n{\n\tOM_uint32 ret;\n\tret = gss_inquire_sec_context_by_oid(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    data_set);\n\treturn (ret);\n}",
        "output": "1",
        "idx": 74
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_siocgstamp(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timeval ktv;\n\tint err;\n\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);\n\tset_fs(old_fs);\n\tif (!err)\n\t\terr = compat_put_timeval(&ktv, up);\n\n\treturn err;\n}",
        "output": "0",
        "idx": 1037
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cdf_read_sector(const cdf_info_t *info, void *buf, size_t offs, size_t len,\n    const cdf_header_t *h, cdf_secid_t id)\n{\n\tsize_t ss = CDF_SEC_SIZE(h);\n\tsize_t pos = CDF_SEC_POS(h, id);\n\tassert(ss == len);\n\treturn cdf_read(info, (off_t)pos, ((char *)buf) + offs, len);\n}",
        "output": "0",
        "idx": 5053
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pptp_bind(struct socket *sock, struct sockaddr *uservaddr,\n\tint sockaddr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tstruct pptp_opt *opt = &po->proto.pptp;\n\tint error = 0;\n\n\tif (sockaddr_len < sizeof(struct sockaddr_pppox))\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\topt->src_addr = sp->sa_addr.pptp;\n\tif (add_chan(po))\n\t\terror = -EBUSY;\n\n\trelease_sock(sk);\n\treturn error;\n}",
        "output": "0",
        "idx": 1471
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_be_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tpsf->header.ptr [psf->header.indx++] = (x >> 56) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 48) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 40) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 32) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 24) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n\tpsf->header.ptr [psf->header.indx++] = x ;\n} ",
        "output": "0",
        "idx": 6901
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC void espAddPak(HttpRoute *route, cchar *name, cchar *version)\n{\n    if (!version || !*version || smatch(version, \"0.0.0\")) {\n        version = \"*\";\n    }\n    mprWriteJson(route->config, sfmt(\"dependencies.%s\", name), version);\n}",
        "output": "0",
        "idx": 6983
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tint n;\n\tassert(cnt >= 0);\n\tassert(buf);\n\n\tJAS_DBGLOG(100, (\"mem_read(%p, %p, %d)\\n\", obj, buf, cnt));\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tn = m->len_ - m->pos_;\n\tcnt = JAS_MIN(n, cnt);\n\tmemcpy(buf, &m->buf_[m->pos_], cnt);\n\tm->pos_ += cnt;\n\treturn cnt;\n}",
        "output": "1",
        "idx": 5374
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void m_stop(struct seq_file *m, void *v)\n{\n\tstruct proc_maps_private *priv = m->private;\n\tstruct vm_area_struct *vma = v;\n\n\tvma_stop(priv, vma);\n\tif (priv->task)\n\t\tput_task_struct(priv->task);\n}",
        "output": "1",
        "idx": 288
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool is_subdir(const char *subdir, const char *dir, size_t len)\n{\n\tsize_t subdirlen = strlen(subdir);\n\n\tif (subdirlen < len)\n\t\treturn false;\n\tif (strncmp(subdir, dir, len) != 0)\n\t\treturn false;\n\tif (dir[len-1] == '/')\n\t\treturn true;\n\tif (subdir[len] == '/' || subdirlen == len)\n\t\treturn true;\n\treturn false;\n}",
        "output": "0",
        "idx": 6053
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sockfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tint err = simple_setattr(dentry, iattr);\n\n\tif (!err && (iattr->ia_valid & ATTR_UID)) {\n\t\tstruct socket *sock = SOCKET_I(d_inode(dentry));\n\n\t\tif (sock->sk)\n\t\t\tsock->sk->sk_uid = iattr->ia_uid;\n\t\telse\n\t\t\terr = -ENOENT;\n\t}\n\n\treturn err;\n}",
        "output": "0",
        "idx": 4109
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void sem_getref(struct sem_array *sma)\n{\n\tsem_lock(sma, NULL, -1);\n\tWARN_ON_ONCE(!ipc_rcu_getref(sma));\n\tsem_unlock(sma, -1);\n}",
        "output": "0",
        "idx": 3227
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vips_malloc( VipsObject *object, size_t size )\n{\n\tvoid *buf;\n\n\tbuf = g_malloc( size );\n\n        if( object ) {\n\t\tg_signal_connect( object, \"postclose\", \n\t\t\tG_CALLBACK( vips_malloc_cb ), buf );\n\t\tobject->local_memory += size;\n\t}\n\n\treturn( buf );\n}",
        "output": "1",
        "idx": 7538
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(FilesystemIterator, getFlags)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_LONG(intern->flags & (SPL_FILE_DIR_KEY_MODE_MASK | SPL_FILE_DIR_CURRENT_MODE_MASK | SPL_FILE_DIR_OTHERS_MASK));\n} ",
        "output": "1",
        "idx": 3998
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vgacon_scrollback_init(int vc_num)\n{\n\tint pitch = vga_video_num_columns * 2;\n\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\tint rows = size / pitch;\n\tvoid *data;\n\n\tdata = kmalloc_array(CONFIG_VGACON_SOFT_SCROLLBACK_SIZE, 1024,\n\t\t\t     GFP_NOWAIT);\n\n\tvgacon_scrollbacks[vc_num].data = data;\n\tvgacon_scrollback_cur = &vgacon_scrollbacks[vc_num];\n\n\tvgacon_scrollback_cur->rows = rows - 1;\n\tvgacon_scrollback_cur->size = rows * pitch;\n\n\tvgacon_scrollback_reset(vc_num, size);\n}",
        "output": "1",
        "idx": 1864
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BYTE get_bpp_bmf(UINT32 bpp, BOOL* pValid)\n{\n\tif (pValid)\n\t\t*pValid = TRUE;\n\tswitch (bpp)\n\t{\n\t\tcase 1:\n\t\t\treturn 1;\n\t\tcase 8:\n\t\t\treturn 3;\n\t\tcase 16:\n\t\t\treturn 4;\n\t\tcase 24:\n\t\t\treturn 5;\n\t\tcase 32:\n\t\t\treturn 6;\n\t\tdefault:\n\t\t\tWLog_WARN(TAG, \"Invalid color depth %\" PRIu32, bpp);\n\t\t\tif (pValid)\n\t\t\t\t*pValid = FALSE;\n\t\t\treturn 0;\n\t}\n}",
        "output": "0",
        "idx": 5767
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void evtchn_fifo_handle_events(unsigned cpu)\n{\n\t__evtchn_fifo_handle_events(cpu, false);\n}",
        "output": "1",
        "idx": 1898
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "delete_buff_tail(buffheader_T *buf, int slen)\n{\n    int len = (int)STRLEN(buf->bh_curr->b_str);\n\n    if (len >= slen)\n    {\n\tbuf->bh_curr->b_str[len - slen] = NUL;\n\tbuf->bh_space += slen;\n    }\n}",
        "output": "1",
        "idx": 5728
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "INST_HANDLER (sbrx) {\t\n\tint b = buf[0] & 0x7;\n\tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);\n\tRAnalOp next_op = {0};\n\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\n\top->cycles = 1;\t\n\tESIL_A (\"%d,1,<<,r%d,&,\", b, r);\t\t\t\n\tESIL_A ((buf[1] & 0xe) == 0xc\n\t\t\t? \"!,\"\t\t\n\t\t\t: \"!,!,\");\t\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t\n}",
        "output": "0",
        "idx": 8689
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t   gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n\t\t   int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n\n    status = val_unwrap_iov_args(minor_status, context_handle, NULL,\n\t\t\t\t qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_verify_mic_iov == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_verify_mic_iov(minor_status, ctx->internal_ctx_id,\n\t\t\t\t      qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}",
        "output": "0",
        "idx": 273
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sock_close(struct inode *inode, struct file *filp)\n{\n\t__sock_release(SOCKET_I(inode), inode);\n\treturn 0;\n}",
        "output": "0",
        "idx": 4105
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int spl_filesystem_file_read_csv(spl_filesystem_object *intern, char delimiter, char enclosure, char escape, zval *return_value TSRMLS_DC) \n{\n\tint ret = SUCCESS;\n\t\n\tdo {\n\t\tret = spl_filesystem_file_read(intern, 1 TSRMLS_CC);\n\t} while (ret == SUCCESS && !intern->u.file.current_line_len && SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY));\n\t\n\tif (ret == SUCCESS) {\n\t\tsize_t buf_len = intern->u.file.current_line_len;\n\t\tchar *buf = estrndup(intern->u.file.current_line, buf_len);\n\n\t\tif (intern->u.file.current_zval) {\n\t\t\tzval_ptr_dtor(&intern->u.file.current_zval);\n\t\t}\n\t\tALLOC_INIT_ZVAL(intern->u.file.current_zval);\n\n\t\tphp_fgetcsv(intern->u.file.stream, delimiter, enclosure, escape, buf_len, buf, intern->u.file.current_zval TSRMLS_CC);\n\t\tif (return_value) {\n\t\t\tif (Z_TYPE_P(return_value) != IS_NULL) {\n\t\t\t\tzval_dtor(return_value);\n\t\t\t\tZVAL_NULL(return_value);\n\t\t\t}\n\t\t\tZVAL_ZVAL(return_value, intern->u.file.current_zval, 1, 0);\n\t\t}\n\t}\n\treturn ret;\n}",
        "output": "1",
        "idx": 3958
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct inode *isofs_iget(struct super_block *sb,\n\t\t\t\t       unsigned long block,\n\t\t\t\t       unsigned long offset)\n{\n\treturn __isofs_iget(sb, block, offset, 0);\n}",
        "output": "0",
        "idx": 3637
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ip_printroute(netdissect_options *ndo,\n              register const u_char *cp, u_int length)\n{\n\tregister u_int ptr;\n\tregister u_int len;\n\n\tif (length < 3) {\n\t\tND_PRINT((ndo, \" [bad length %u]\", length));\n\t\treturn (0);\n\t}\n\tif ((length + 1) & 3)\n\t\tND_PRINT((ndo, \" [bad length %u]\", length));\n\tND_TCHECK(cp[2]);\n\tptr = cp[2] - 1;\n\tif (ptr < 3 || ((ptr + 1) & 3) || ptr > length + 1)\n\t\tND_PRINT((ndo, \" [bad ptr %u]\", cp[2]));\n\n\tfor (len = 3; len < length; len += 4) {\n\t\tND_TCHECK2(cp[len], 4);\n\t\tND_PRINT((ndo, \" %s\", ipaddr_string(ndo, &cp[len])));\n\t\tif (ptr > len)\n\t\t\tND_PRINT((ndo, \",\"));\n\t}\n\treturn (0);\n\ntrunc:\n\treturn (-1);\n}",
        "output": "0",
        "idx": 6717
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t scsi_init_iovec(SCSIDiskReq *r)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    if (!r->iov.iov_base) {\n        r->buflen = SCSI_DMA_BUF_SIZE;\n        r->iov.iov_base = qemu_blockalign(s->bs, r->buflen);\n    }\n    r->iov.iov_len = MIN(r->sector_count * 512, r->buflen);\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n    return r->qiov.size / 512;\n}",
        "output": "0",
        "idx": 5003
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void release_dentry_name_snapshot(struct name_snapshot *name)\n{\n\tif (unlikely(name->name != name->inline_name)) {\n\t\tstruct external_name *p;\n\t\tp = container_of(name->name, struct external_name, name[0]);\n\t\tif (unlikely(atomic_dec_and_test(&p->u.count)))\n\t\t\tkfree_rcu(p, u.head);\n\t}\n}",
        "output": "0",
        "idx": 2347
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void native_tss_update_io_bitmap(void)\n{\n\tstruct tss_struct *tss = this_cpu_ptr(&cpu_tss_rw);\n\tstruct thread_struct *t = &current->thread;\n\tu16 *base = &tss->x86_tss.io_bitmap_base;\n\n\tif (!test_thread_flag(TIF_IO_BITMAP)) {\n\t\ttss_invalidate_io_bitmap(tss);\n\t\treturn;\n\t}\n\n\tif (IS_ENABLED(CONFIG_X86_IOPL_IOPERM) && t->iopl_emul == 3) {\n\t\t*base = IO_BITMAP_OFFSET_VALID_ALL;\n\t} else {\n\t\tstruct io_bitmap *iobm = t->io_bitmap;\n\n\t\tif (tss->io_bitmap.prev_sequence != iobm->sequence)\n\t\t\ttss_copy_io_bitmap(tss, iobm);\n\n\t\t*base = IO_BITMAP_OFFSET_VALID_MAP;\n\t}\n\n\trefresh_tss_limit();\n}",
        "output": "1",
        "idx": 1852
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void finish_object(struct object *obj,\n\t\t\t  struct strbuf *path, const char *name,\n\t\t\t  void *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tif (obj->type == OBJ_BLOB && !has_object_file(&obj->oid))\n\t\tdie(\"missing blob object '%s'\", oid_to_hex(&obj->oid));\n\tif (info->revs->verify_objects && !obj->parsed && obj->type != OBJ_COMMIT)\n\t\tparse_object(obj->oid.hash);\n}",
        "output": "1",
        "idx": 5192
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "INST_HANDLER (cpse) {\t\n\tint r = (buf[0] & 0xf) | ((buf[1] & 0x2) << 3);\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tRAnalOp next_op = {0};\n\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\n\top->cycles = 1;\t\n\tESIL_A (\"r%d,r%d,^,!,\", r, d);\t\t\t\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t\n}",
        "output": "0",
        "idx": 8705
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int hugepage_madvise(struct vm_area_struct *vma,\n\t\t     unsigned long *vm_flags, int advice)\n{\n\tswitch (advice) {\n\tcase MADV_HUGEPAGE:\n\t\tif (*vm_flags & (VM_HUGEPAGE |\n\t\t\t\t VM_SHARED   | VM_MAYSHARE   |\n\t\t\t\t VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |\n\t\t\t\t VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |\n\t\t\t\t VM_MIXEDMAP | VM_SAO))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_NOHUGEPAGE;\n\t\t*vm_flags |= VM_HUGEPAGE;\n\t\tif (unlikely(khugepaged_enter_vma_merge(vma)))\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\tcase MADV_NOHUGEPAGE:\n\t\tif (*vm_flags & (VM_NOHUGEPAGE |\n\t\t\t\t VM_SHARED   | VM_MAYSHARE   |\n\t\t\t\t VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |\n\t\t\t\t VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |\n\t\t\t\t VM_MIXEDMAP | VM_SAO))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_HUGEPAGE;\n\t\t*vm_flags |= VM_NOHUGEPAGE;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 312
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void tss_invalidate_io_bitmap(struct tss_struct *tss)\n{\n\ttss->x86_tss.io_bitmap_base = IO_BITMAP_OFFSET_INVALID;\n}",
        "output": "1",
        "idx": 1854
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\n\treturn try_get_page(buf->page);\n}",
        "output": "0",
        "idx": 4357
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_unlink(const char *path)\n{\n\tif (unlink(path) == 0) {\n\t\tfprintf(stderr, \"leak at unlink of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at unlink of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}",
        "output": "0",
        "idx": 7289
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_event_for_each(struct perf_event *event,\n\t\t\t\t  void (*func)(struct perf_event *))\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct perf_event *sibling;\n\n\tWARN_ON_ONCE(ctx->parent_ctx);\n\tmutex_lock(&ctx->mutex);\n\tevent = event->group_leader;\n\n\tperf_event_for_each_child(event, func);\n\tlist_for_each_entry(sibling, &event->sibling_list, group_entry)\n\t\tperf_event_for_each_child(sibling, func);\n\tmutex_unlock(&ctx->mutex);\n}",
        "output": "1",
        "idx": 2776
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sg_fill_request_table(Sg_fd *sfp, sg_req_info_t *rinfo)\n{\n\tSg_request *srp;\n\tint val;\n\tunsigned int ms;\n\n\tval = 0;\n\tlist_for_each_entry(srp, &sfp->rq_list, entry) {\n\t\tif (val > SG_MAX_QUEUE)\n\t\t\tbreak;\n\t\tmemset(&rinfo[val], 0, SZ_SG_REQ_INFO);\n\t\trinfo[val].req_state = srp->done + 1;\n\t\trinfo[val].problem =\n\t\t\tsrp->header.masked_status &\n\t\t\tsrp->header.host_status &\n\t\t\tsrp->header.driver_status;\n\t\tif (srp->done)\n\t\t\trinfo[val].duration =\n\t\t\t\tsrp->header.duration;\n\t\telse {\n\t\t\tms = jiffies_to_msecs(jiffies);\n\t\t\trinfo[val].duration =\n\t\t\t\t(ms > srp->header.duration) ?\n\t\t\t\t(ms - srp->header.duration) : 0;\n\t\t}\n\t\trinfo[val].orphan = srp->orphan;\n\t\trinfo[val].sg_io_owned = srp->sg_io_owned;\n\t\trinfo[val].pack_id = srp->header.pack_id;\n\t\trinfo[val].usr_ptr = srp->header.usr_ptr;\n\t\tval++;\n\t}\n}",
        "output": "1",
        "idx": 1656
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "aiff_read_chanmap (SF_PRIVATE * psf, unsigned dword)\n{\tconst AIFF_CAF_CHANNEL_MAP * map_info ;\n\tunsigned channel_bitmap, channel_decriptions, bytesread ;\n\tint layout_tag ;\n\n\tbytesread = psf_binheader_readf (psf, \"444\", &layout_tag, &channel_bitmap, &channel_decriptions) ;\n\n\tif ((map_info = aiff_caf_of_channel_layout_tag (layout_tag)) == NULL)\n\t\treturn 0 ;\n\n\tpsf_log_printf (psf, \"  Tag    : %x\\n\", layout_tag) ;\n\tif (map_info)\n\t\tpsf_log_printf (psf, \"  Layout : %s\\n\", map_info->name) ;\n\n\tif (bytesread < dword)\n\t\tpsf_binheader_readf (psf, \"j\", dword - bytesread) ;\n\n\tif (map_info->channel_map != NULL)\n\t{\tsize_t chanmap_size = SF_MIN (psf->sf.channels, layout_tag & 0xffff) * sizeof (psf->channel_map [0]) ;\n\n\t\tfree (psf->channel_map) ;\n\n\t\tif ((psf->channel_map = malloc (chanmap_size)) == NULL)\n\t\t\treturn SFE_MALLOC_FAILED ;\n\n\t\tmemcpy (psf->channel_map, map_info->channel_map, chanmap_size) ;\n\t\t} ;\n\n\treturn 0 ;\n} ",
        "output": "0",
        "idx": 6871
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int handle_wrmsr(struct kvm_vcpu *vcpu)\n{\n\tstruct msr_data msr;\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 data = (vcpu->arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(vcpu->arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\tif (kvm_set_msr(vcpu, &msr) != 0) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\ttrace_kvm_msr_write(ecx, data);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}",
        "output": "0",
        "idx": 3731
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_import_sec_context(\n\tOM_uint32\t\t*minor_status,\n\tconst gss_buffer_t\tinterprocess_token,\n\tgss_ctx_id_t\t\t*context_handle)\n{\n\tOM_uint32 ret;\n\tret = gss_import_sec_context(minor_status,\n\t\t\t\t    interprocess_token,\n\t\t\t\t    context_handle);\n\treturn (ret);\n}",
        "output": "1",
        "idx": 56
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "accept_xsmp_connection (SmsConn        sms_conn,\n                        GsmXsmpServer *server,\n                        unsigned long *mask_ret,\n                        SmsCallbacks  *callbacks_ret,\n                        char         **failure_reason_ret)\n{\n        IceConn                ice_conn;\n        GsmClient             *client;\n        GsmIceConnectionWatch *data;\n\n        if (server->priv->xsmp_sockets == NULL) {\n                g_debug (\"GsmXsmpServer: In shutdown, rejecting new client\");\n\n                *failure_reason_ret = strdup (_(\"Refusing new client connection because the session is currently being shut down\\n\"));\n                return FALSE;\n        }\n\n        ice_conn = SmsGetIceConnection (sms_conn);\n        data = ice_conn->context;\n\n        free_ice_connection_watch (data);\n\n        client = gsm_xsmp_client_new (ice_conn);\n\n        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n        g_object_unref (client);\n\n        gsm_xsmp_client_connect (GSM_XSMP_CLIENT (client), sms_conn, mask_ret, callbacks_ret);\n\n        return TRUE;\n}",
        "output": "0",
        "idx": 8721
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase F_OFD_GETLK:\n\tcase F_OFD_SETLK:\n\tcase F_OFD_SETLKW:\n\tcase F_GETLK64:\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\t\treturn do_locks(fd, cmd, arg);\n\n\tdefault:\n\t\treturn sys_fcntl64(fd, cmd, arg);\n\t}\n}",
        "output": "0",
        "idx": 1487
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_rng rrng;\n\n\tsnprintf(rrng.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"rng\");\n\n\trrng.seedsize = alg->cra_rng.seedsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_RNG,\n\t\t    sizeof(struct crypto_report_rng), &rrng))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "1",
        "idx": 860
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)\n{\n\tstruct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\treturn aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);\n}",
        "output": "0",
        "idx": 3347
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void update_read_synchronize(rdpUpdate* update, wStream* s)\n{\n\tWINPR_UNUSED(update);\n\tStream_Seek_UINT16(s); \n}",
        "output": "1",
        "idx": 4136
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void fslib_copy_libs(const char *full_path) {\n\tassert(full_path);\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    fslib_copy_libs %s\\n\", full_path);\n\n\tif (access(full_path, R_OK)) {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"cannot find %s for private-lib, skipping...\\n\", full_path);\n\t\treturn;\n\t}\n\n\tunlink(RUN_LIB_FILE);\t\t\t  \n\tcreate_empty_file_as_root(RUN_LIB_FILE, 0644);\n\tif (chown(RUN_LIB_FILE, getuid(), getgid()))\n\t\terrExit(\"chown\");\n\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    running fldd %s\\n\", full_path);\n\tsbox_run(SBOX_USER | SBOX_SECCOMP | SBOX_CAPS_NONE, 3, PATH_FLDD, full_path, RUN_LIB_FILE);\n\n\tFILE *fp = fopen(RUN_LIB_FILE, \"r\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\t\tfslib_duplicate(buf);\n\t}\n\tfclose(fp);\n\tunlink(RUN_LIB_FILE);\n}",
        "output": "0",
        "idx": 8959
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void unqueue_me_pi(struct futex_q *q)\n{\n\tWARN_ON(plist_node_empty(&q->list));\n\tplist_del(&q->list, &q->list.plist);\n\n\tBUG_ON(!q->pi_state);\n\tfree_pi_state(q->pi_state);\n\tq->pi_state = NULL;\n\n\tspin_unlock(q->lock_ptr);\n\n\tdrop_futex_key_refs(&q->key);\n}",
        "output": "1",
        "idx": 236
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vivid_fb_ioctl(struct fb_info *info, unsigned cmd, unsigned long arg)\n{\n\tstruct vivid_dev *dev = (struct vivid_dev *)info->par;\n\n\tswitch (cmd) {\n\tcase FBIOGET_VBLANK: {\n\t\tstruct fb_vblank vblank;\n\n\t\tmemset(&vblank, 0, sizeof(vblank));\n\t\tvblank.flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT |\n\t\t\tFB_VBLANK_HAVE_VSYNC;\n\t\tvblank.count = 0;\n\t\tvblank.vcount = 0;\n\t\tvblank.hcount = 0;\n\t\tif (copy_to_user((void __user *)arg, &vblank, sizeof(vblank)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tdefault:\n\t\tdprintk(dev, 1, \"Unknown ioctl %08x\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 4053
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "init_ccline(int firstc, int indent)\n{\n    ccline.overstrike = FALSE;\t\t    \n\n    ccline.cmdfirstc = (firstc == '@' ? 0 : firstc);\n    ccline.cmdindent = (firstc > 0 ? indent : 0);\n\n    alloc_cmdbuff(exmode_active ? 250 : indent + 1);\n    if (ccline.cmdbuff == NULL)\n\treturn FAIL;\n    ccline.cmdlen = ccline.cmdpos = 0;\n    ccline.cmdbuff[0] = NUL;\n    sb_text_start_cmdline();\n\n    if (firstc <= 0)\n    {\n\tvim_memset(ccline.cmdbuff, ' ', indent);\n\tccline.cmdbuff[indent] = NUL;\n\tccline.cmdpos = indent;\n\tccline.cmdspos = indent;\n\tccline.cmdlen = indent;\n    }\n\n    return OK;\n}",
        "output": "1",
        "idx": 5722
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void unix_dgram_peer_wake_disconnect(struct sock *sk,\n\t\t\t\t\t    struct sock *other)\n{\n\tstruct unix_sock *u, *u_other;\n\n\tu = unix_sk(sk);\n\tu_other = unix_sk(other);\n\tspin_lock(&u_other->peer_wait.lock);\n\n\tif (u->peer_wake.private == other) {\n\t\t__remove_wait_queue(&u_other->peer_wait, &u->peer_wake);\n\t\tu->peer_wake.private = NULL;\n\t}\n\n\tspin_unlock(&u_other->peer_wait.lock);\n}",
        "output": "0",
        "idx": 1355
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,\n\t\t\tunsigned int slen)\n{\n\tu8 *buf = NULL;\n\tu8 *src = (u8 *)seed;\n\tint err;\n\n\tif (slen) {\n\t\tbuf = kmalloc(slen, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(buf, seed, slen);\n\t\tsrc = buf;\n\t}\n\n\terr = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);\n\n\tkzfree(buf);\n\treturn err;\n}",
        "output": "1",
        "idx": 2834
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n\t__ptrace_link(child, new_parent, current_cred());\n}",
        "output": "0",
        "idx": 4433
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error_t enc624j600SoftReset(NetInterface *interface)\n{\n   do\n   {\n      enc624j600WriteReg(interface, ENC624J600_REG_EUDAST, 0x1234);\n   } while(enc624j600ReadReg(interface, ENC624J600_REG_EUDAST) != 0x1234);\n\n   while((enc624j600ReadReg(interface, ENC624J600_REG_ESTAT) & ESTAT_CLKRDY) == 0)\n   {\n   }\n\n   enc624j600SetBit(interface, ENC624J600_REG_ECON2, ECON2_ETHRST);\n   sleep(1);\n\n   if(enc624j600ReadReg(interface, ENC624J600_REG_EUDAST) != 0x0000)\n   {\n      return ERROR_FAILURE;\n   }\n\n   sleep(1);\n\n   return NO_ERROR;\n}",
        "output": "1",
        "idx": 8560
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mrb_proc_copy(struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    return;\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n    mrb_irep_incref(NULL, (mrb_irep*)a->body.irep);\n  }\n  a->upper = b->upper;\n  a->e.env = b->e.env;\n}",
        "output": "1",
        "idx": 6688
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int http_read_header(URLContext *h, int *new_location)\n{\n    HTTPContext *s = h->priv_data;\n    char line[MAX_URL_SIZE];\n    int err = 0;\n\n    s->chunksize = -1;\n\n    for (;;) {\n        if ((err = http_get_line(s, line, sizeof(line))) < 0)\n            return err;\n\n        av_log(h, AV_LOG_TRACE, \"header='%s'\\n\", line);\n\n        err = process_line(h, line, s->line_count, new_location);\n        if (err < 0)\n            return err;\n        if (err == 0)\n            break;\n        s->line_count++;\n    }\n\n    if (s->seekable == -1 && s->is_mediagateway && s->filesize == 2000000000)\n        h->is_streamed = 1; \n\n    cookie_string(s->cookie_dict, &s->cookies);\n    av_dict_free(&s->cookie_dict);\n\n    return err;\n}",
        "output": "1",
        "idx": 3460
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Jsi_RC ObjListifyCallback(Jsi_Tree *tree, Jsi_TreeEntry *hPtr, void *data)\n{\n    Jsi_Interp *interp = tree->opts.interp;\n    Jsi_Obj *obj = (Jsi_Obj*)data;\n    int n;\n    if (!hPtr->f.bits.dontenum) {\n        char *ep = NULL, *cp = (char*)Jsi_TreeKeyGet(hPtr);\n        if (!cp || !isdigit(*cp))\n            return JSI_OK;\n        n = (int)strtol(cp, &ep, 0);\n        if (n<0 || n >= interp->maxArrayList)\n            return JSI_OK;\n        hPtr->f.bits.isarrlist = 1;\n        if (Jsi_ObjArraySizer(interp, obj, n) <= 0) \n            return Jsi_LogError(\"too long\");\n        obj->arr[n] = (Jsi_Value*)Jsi_TreeValueGet(hPtr);\n    }\n    return JSI_OK;\n}",
        "output": "1",
        "idx": 8232
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "create_pty_only(term_T *term, jobopt_T *opt)\n{\n    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)\n\treturn FAIL;\n\n    term->tl_job = job_alloc();\n    if (term->tl_job == NULL)\n\treturn FAIL;\n    ++term->tl_job->jv_refcount;\n\n    term->tl_job->jv_status = JOB_FINISHED;\n\n    return mch_create_pty_channel(term->tl_job, opt);\n}",
        "output": "0",
        "idx": 8161
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vlan_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\n\tdev->priv_flags\t\t|= IFF_802_1Q_VLAN;\n\tdev->priv_flags\t\t&= ~IFF_XMIT_DST_RELEASE;\n\tdev->tx_queue_len\t= 0;\n\n\tdev->netdev_ops\t\t= &vlan_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\tdev->ethtool_ops\t= &vlan_ethtool_ops;\n\n\tmemset(dev->broadcast, 0, ETH_ALEN);\n}",
        "output": "1",
        "idx": 586
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jiffies_to_timespec(const unsigned long jiffies, struct timespec *value)\n{\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &value->tv_nsec);\n}",
        "output": "1",
        "idx": 2104
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_wrap_iov(OM_uint32 *minor_status,\n\t\t    gss_ctx_id_t context_handle,\n\t\t    int conf_req_flag,\n\t\t    gss_qop_t qop_req,\n\t\t    int *conf_state,\n\t\t    gss_iov_buffer_desc *iov,\n\t\t    int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov(minor_status,\n\t\t\t   context_handle,\n\t\t\t   conf_req_flag,\n\t\t\t   qop_req,\n\t\t\t   conf_state,\n\t\t\t   iov,\n\t\t\t   iov_count);\n\treturn (ret);\n}",
        "output": "1",
        "idx": 94
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loaddr, Sdb *sdb) {\n\tif (!buf || !sz || sz == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tRBuffer *tbuf = r_buf_new ();\n\tif (!tbuf) {\n\t\treturn NULL;\n\t}\n\tr_buf_set_bytes (tbuf, buf, sz);\n\tstruct r_bin_bflt_obj *res = r_bin_bflt_new_buf (tbuf);\n\tr_buf_free (tbuf);\n\treturn res ? res : NULL;\n}",
        "output": "0",
        "idx": 8613
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init init_ext2_fs(void)\n{\n\tint err;\n\n\terr = init_inodecache();\n\tif (err)\n\t\treturn err;\n        err = register_filesystem(&ext2_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\n\treturn err;\n}",
        "output": "0",
        "idx": 1643
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int _nfs4_do_open_reclaim(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs4_opendata *opendata;\n\tint delegation_type = 0;\n\tint status;\n\n\topendata = nfs4_open_recoverdata_alloc(ctx, state);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\topendata->o_arg.claim = NFS4_OPEN_CLAIM_PREVIOUS;\n\topendata->o_arg.fh = NFS_FH(state->inode);\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(state->inode)->delegation);\n\tif (delegation != NULL && test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) != 0)\n\t\tdelegation_type = delegation->type;\n\trcu_read_unlock();\n\topendata->o_arg.u.delegation_type = delegation_type;\n\tstatus = nfs4_open_recover(opendata, state);\n\tnfs4_opendata_put(opendata);\n\treturn status;\n}",
        "output": "1",
        "idx": 2128
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_fdc(int drive)\n{\n\tunsigned int new_fdc = fdc;\n\n\tif (drive >= 0 && drive < N_DRIVE) {\n\t\tnew_fdc = FDC(drive);\n\t\tcurrent_drive = drive;\n\t}\n\tif (new_fdc >= N_FDC) {\n\t\tpr_info(\"bad fdc value\\n\");\n\t\treturn;\n\t}\n\tfdc = new_fdc;\n\tset_dor(fdc, ~0, 8);\n#if N_FDC > 1\n\tset_dor(1 - fdc, ~8, 0);\n#endif\n\tif (FDCS->rawcmd == 2)\n\t\treset_fdc_info(1);\n\tif (fd_inb(FD_STATUS) != STATUS_READY)\n\t\tFDCS->reset = 1;\n}",
        "output": "0",
        "idx": 4605
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __u8 *cp_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tunsigned long quirks = (unsigned long)hid_get_drvdata(hdev);\n\tunsigned int i;\n\n\tif (!(quirks & CP_RDESC_SWAPPED_MIN_MAX))\n\t\treturn rdesc;\n\n\tif (*rsize < 4)\n\t\treturn rdesc;\n\n\tfor (i = 0; i < *rsize - 4; i++)\n\t\tif (rdesc[i] == 0x29 && rdesc[i + 2] == 0x19) {\n\t\t\trdesc[i] = 0x19;\n\t\t\trdesc[i + 2] = 0x29;\n\t\t\tswap(rdesc[i + 3], rdesc[i + 1]);\n\t\t}\n\treturn rdesc;\n}",
        "output": "0",
        "idx": 2063
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "swabHorAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\tuint16* wp = (uint16*) cp0;\n\ttmsize_t wc = cc / 2;\n\n        TIFFSwabArrayOfShort(wp, wc);\n        return horAcc16(tif, cp0, cc);\n}",
        "output": "0",
        "idx": 5899
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlValidNormalizeString(xmlChar *str) {\n    xmlChar *dst;\n    const xmlChar *src;\n\n    if (str == NULL)\n        return;\n    src = str;\n    dst = str;\n\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n}",
        "output": "0",
        "idx": 8851
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _perf_event_reset(struct perf_event *event)\n{\n\t(void)perf_event_read(event);\n\tlocal64_set(&event->count, 0);\n\tperf_event_update_userpage(event);\n}",
        "output": "0",
        "idx": 3835
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "setup_connection (GsmXSMPClient *client)\n{\n        GIOChannel    *channel;\n        int            fd;\n\n        g_debug (\"GsmXSMPClient: Setting up new connection\");\n\n        fd = IceConnectionNumber (client->priv->ice_connection);\n        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n        channel = g_io_channel_unix_new (fd);\n        client->priv->watch_id = g_io_add_watch (channel,\n                                                 G_IO_IN | G_IO_ERR,\n                                                 (GIOFunc)client_iochannel_watch,\n                                                 client);\n        g_io_channel_unref (channel);\n\n        client->priv->protocol_timeout = g_timeout_add_seconds (5,\n                                                                (GSourceFunc)_client_protocol_timeout,\n                                                                client);\n\n        set_description (client);\n\n        g_debug (\"GsmXSMPClient: New client '%s'\", client->priv->description);\n}",
        "output": "1",
        "idx": 6216
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool unconditional(const struct ip6t_entry *e)\n{\n\tstatic const struct ip6t_ip6 uncond;\n\n\treturn e->target_offset == sizeof(struct ip6t_entry) &&\n\t       memcmp(&e->ipv6, &uncond, sizeof(uncond)) == 0;\n}",
        "output": "0",
        "idx": 1765
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseContentMinify(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprJson     *child;\n    int         ji;\n\n    for (ITERATE_CONFIG(route, prop, child, ji)) {\n        if (mprReadJson(route->config, sfmt(\"app.http.content.compress[@ = '%s']\", child->value)) == 0) {\n            httpAddRouteMapping(route, child->value, \"min.${1}\");\n        }\n    }\n}",
        "output": "0",
        "idx": 6997
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n{\n\treturn usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\n\t\t\t       RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,\n\t\t\t       indx, 0, data, size, 500);\n}",
        "output": "1",
        "idx": 1462
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void l2tp_eth_dev_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->netdev_ops\t\t= &l2tp_eth_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n}",
        "output": "0",
        "idx": 765
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size) \n{\n\tif (ms)\n\t{\n\t\tint32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];\n\t\tif (nestsize == 0 && ms->nest_level == 0)\n\t\t\tnestsize = ms->buffer_size_longs;\n\n\t\tif (size + 2 <= nestsize) return GPMF_OK;\n\t}\n\treturn GPMF_ERROR_BAD_STRUCTURE;\n}",
        "output": "1",
        "idx": 7494
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void pin_remove(struct fs_pin *pin)\n{\n\tspin_lock(&pin_lock);\n\thlist_del(&pin->m_list);\n\thlist_del(&pin->s_list);\n\tspin_unlock(&pin_lock);\n\tspin_lock_irq(&pin->wait.lock);\n\tpin->done = 1;\n\twake_up_locked(&pin->wait);\n\tspin_unlock_irq(&pin->wait.lock);\n}",
        "output": "1",
        "idx": 2816
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct r_bin_dyldcache_obj_t* r_bin_dyldcache_from_bytes_new(const ut8* buf, ut64 size) {\n\tstruct r_bin_dyldcache_obj_t *bin;\n\tif (!(bin = malloc (sizeof (struct r_bin_dyldcache_obj_t)))) {\n\t\treturn NULL;\n\t}\n\tmemset (bin, 0, sizeof (struct r_bin_dyldcache_obj_t));\n\tif (!buf) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tbin->b = r_buf_new();\n\tif (!r_buf_set_bytes (bin->b, buf, size)) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tif (!r_bin_dyldcache_init (bin)) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tbin->size = size;\n\treturn bin;\n}",
        "output": "1",
        "idx": 6540
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long ec_device_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)\n{\n\tlong ret;\n\tstruct cros_ec_command u_cmd;\n\tstruct cros_ec_command *s_cmd;\n\n\tif (copy_from_user(&u_cmd, arg, sizeof(u_cmd)))\n\t\treturn -EFAULT;\n\n\tif ((u_cmd.outsize > EC_MAX_MSG_BYTES) ||\n\t    (u_cmd.insize > EC_MAX_MSG_BYTES))\n\t\treturn -EINVAL;\n\n\ts_cmd = kmalloc(sizeof(*s_cmd) + max(u_cmd.outsize, u_cmd.insize),\n\t\t\tGFP_KERNEL);\n\tif (!s_cmd)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(s_cmd, arg, sizeof(*s_cmd) + u_cmd.outsize)) {\n\t\tret = -EFAULT;\n\t\tgoto exit;\n\t}\n\n\tif (u_cmd.outsize != s_cmd->outsize ||\n\t    u_cmd.insize != s_cmd->insize) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\ts_cmd->command += ec->cmd_offset;\n\tret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + s_cmd->insize))\n\t\tret = -EFAULT;\nexit:\n\tkfree(s_cmd);\n\treturn ret;\n}",
        "output": "0",
        "idx": 1905
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gplotMakeOutput(GPLOT  *gplot)\n{\nchar     buf[L_BUF_SIZE];\nchar    *cmdname;\nl_int32  ignore;\n\n    PROCNAME(\"gplotMakeOutput\");\n\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n\n    gplotGenCommandFile(gplot);\n    gplotGenDataFiles(gplot);\n    cmdname = genPathname(gplot->cmdname, NULL);\n\n#ifndef _WIN32\n    snprintf(buf, L_BUF_SIZE, \"gnuplot %s\", cmdname);\n#else\n    snprintf(buf, L_BUF_SIZE, \"wgnuplot %s\", cmdname);\n#endif  \n\n#ifndef OS_IOS \n    ignore = system(buf);  \n#endif \n\n    LEPT_FREE(cmdname);\n    return 0;\n}",
        "output": "1",
        "idx": 7300
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_event_reset(struct perf_event *event)\n{\n\t(void)perf_event_read(event);\n\tlocal64_set(&event->count, 0);\n\tperf_event_update_userpage(event);\n}",
        "output": "1",
        "idx": 2780
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\n    size_t aoffset = (size_t) abs(offset);\n    unsigned char *source = buf->data + buf->offset;\n    if (offset >= 0) {\n        if (buf->offset + aoffset + len > buf->maxlen) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source += aoffset;\n    } else {\n        if (buf->offset < aoffset) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source -= aoffset;\n    }\n    memmove(buf->data + buf->offset, source, len);\n    buf->offset += len;\n}",
        "output": "1",
        "idx": 8768
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,\n\t\t\t\t __be16 sport, __be16 dport)\n{\n\t__u32 seq;\n\t__u32 hash[4];\n\tstruct keydata *keyptr = get_keyptr();\n\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n\thash[3] = keyptr->secret[11];\n\n\tseq = half_md4_transform(hash, keyptr->secret) & HASH_MASK;\n\tseq += keyptr->count;\n\tseq += ktime_to_ns(ktime_get_real()) >> 6;\n\n\treturn seq;\n}",
        "output": "1",
        "idx": 594
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void options_defaults() {\n    SERVICE_OPTIONS *service;\n\n    memset(&new_global_options, 0, sizeof(GLOBAL_OPTIONS));\n    memset(&new_service_options, 0, sizeof(SERVICE_OPTIONS));\n    new_service_options.next=NULL;\n\n    parse_global_option(CMD_SET_DEFAULTS, NULL, NULL);\n    service=&new_service_options;\n    parse_service_option(CMD_SET_DEFAULTS, &service, NULL, NULL);\n}",
        "output": "1",
        "idx": 8444
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct inode *isofs_iget(struct super_block *sb,\n\t\t\t unsigned long block,\n\t\t\t unsigned long offset)\n{\n\tunsigned long hashval;\n\tstruct inode *inode;\n\tstruct isofs_iget5_callback_data data;\n\tlong ret;\n\n\tif (offset >= 1ul << sb->s_blocksize_bits)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdata.block = block;\n\tdata.offset = offset;\n\n\thashval = (block << sb->s_blocksize_bits) | offset;\n\n\tinode = iget5_locked(sb, hashval, &isofs_iget5_test,\n\t\t\t\t&isofs_iget5_set, &data);\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tret = isofs_read_inode(inode);\n\t\tif (ret < 0) {\n\t\t\tiget_failed(inode);\n\t\t\tinode = ERR_PTR(ret);\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t}\n\t}\n\n\treturn inode;\n}",
        "output": "1",
        "idx": 2636
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,\n\t\t\t\t\t  unsigned long addr,\n\t\t\t\t\t  unsigned long length)\n{\n\tunsigned long result = 0;\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\tresult = ((((IOAPIC_NUM_PINS - 1) & 0xff) << 16)\n\t\t\t  | (IOAPIC_VERSION_ID & 0xff));\n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\tcase IOAPIC_REG_ARB_ID:\n\t\tresult = ((ioapic->id & 0xf) << 24);\n\t\tbreak;\n\n\tdefault:\n\t\t{\n\t\t\tu32 redir_index = (ioapic->ioregsel - 0x10) >> 1;\n\t\t\tu64 redir_content;\n\n\t\t\tASSERT(redir_index < IOAPIC_NUM_PINS);\n\n\t\t\tredir_content = ioapic->redirtbl[redir_index].bits;\n\t\t\tresult = (ioapic->ioregsel & 0x1) ?\n\t\t\t    (redir_content >> 32) & 0xffffffff :\n\t\t\t    redir_content & 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}",
        "output": "1",
        "idx": 888
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedpcalloc(nedpool *p, size_t no, size_t size) THROWSPEC\r\n{\r\n\tunsigned flags=NEDMALLOC_FORCERESERVE(p, 0, no*size);\r\n\treturn nedpmalloc2(p, size*no, 0, M2_ZERO_MEMORY|flags);\r\n}\r",
        "output": "1",
        "idx": 3628
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hashtable_do_del(hashtable_t *hashtable,\n                            const char *key, size_t hash)\n{\n    pair_t *pair;\n    bucket_t *bucket;\n    size_t index;\n\n    index = hash % num_buckets(hashtable);\n    bucket = &hashtable->buckets[index];\n\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return -1;\n\n    if(&pair->list == bucket->first && &pair->list == bucket->last)\n        bucket->first = bucket->last = &hashtable->list;\n\n    else if(&pair->list == bucket->first)\n        bucket->first = pair->list.next;\n\n    else if(&pair->list == bucket->last)\n        bucket->last = pair->list.prev;\n\n    list_remove(&pair->list);\n    json_decref(pair->value);\n\n    jsonp_free(pair);\n    hashtable->size--;\n\n    return 0;\n}",
        "output": "1",
        "idx": 4318
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "buflist_match(\n    regmatch_T\t*rmp,\n    buf_T\t*buf,\n    int\t\tignore_case)  \n{\n    char_u\t*match;\n\n    match = fname_match(rmp, buf->b_sfname, ignore_case);\n    if (match == NULL)\n\tmatch = fname_match(rmp, buf->b_ffname, ignore_case);\n\n    return match;\n}",
        "output": "1",
        "idx": 5758
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_time_seed()\n{\n    DEBUG_SEED(\"get_time_seed\");\n    \n    return (int)time(NULL) * 433494437;\n}",
        "output": "0",
        "idx": 5959
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int http_buf_read(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int len;\n    len = s->buf_end - s->buf_ptr;\n    if (len > 0) {\n        if (len > size)\n            len = size;\n        memcpy(buf, s->buf_ptr, len);\n        s->buf_ptr += len;\n    } else {\n        uint64_t target_end = s->end_off ? s->end_off : s->filesize;\n        if ((!s->willclose || s->chunksize == UINT64_MAX) && s->off >= target_end)\n            return AVERROR_EOF;\n        len = ffurl_read(s->hd, buf, size);\n        if (!len && (!s->willclose || s->chunksize == UINT64_MAX) && s->off < target_end) {\n            av_log(h, AV_LOG_ERROR,\n                   \"Stream ends prematurely at %\"PRIu64\", should be %\"PRIu64\"\\n\",\n                   s->off, target_end\n                  );\n            return AVERROR(EIO);\n        }\n    }\n    if (len > 0) {\n        s->off += len;\n        if (s->chunksize > 0)\n            s->chunksize -= len;\n    }\n    return len;\n}",
        "output": "0",
        "idx": 4829
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_html_data (MAPI_Attr *a)\n{\n    VarLenData **body = XCALLOC(VarLenData*, a->num_values + 1);\n\n    int j;\n    for (j = 0; j < a->num_values; j++)\n    {\n\tbody[j] = XMALLOC(VarLenData, 1);\n\tbody[j]->len = a->values[j].len;\n\tbody[j]->data = CHECKED_XCALLOC(unsigned char, a->values[j].len);\n\tmemmove (body[j]->data, a->values[j].data.buf, body[j]->len);\n    }\n    return body;\n}",
        "output": "1",
        "idx": 6402
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ignore_error_for_testing(char_u *error)\n{\n    if (ignore_error_list.ga_itemsize == 0)\n\tga_init2(&ignore_error_list, sizeof(char_u *), 1);\n\n    if (STRCMP(\"RESET\", error) == 0)\n\tga_clear_strings(&ignore_error_list);\n    else\n\tga_add_string(&ignore_error_list, error);\n}",
        "output": "1",
        "idx": 5706
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ext4_end_io_buffer_write(struct buffer_head *bh, int uptodate)\n{\n\text4_io_end_t *io_end = bh->b_private;\n\tstruct workqueue_struct *wq;\n\tstruct inode *inode;\n\tunsigned long flags;\n\n\tif (!test_clear_buffer_uninit(bh) || !io_end)\n\t\tgoto out;\n\n\tif (!(io_end->inode->i_sb->s_flags & MS_ACTIVE)) {\n\t\tprintk(\"sb umounted, discard end_io request for inode %lu\\n\",\n\t\t\tio_end->inode->i_ino);\n\t\text4_free_io_end(io_end);\n\t\tgoto out;\n\t}\n\n\tio_end->flag = EXT4_IO_UNWRITTEN;\n\tinode = io_end->inode;\n\n\tspin_lock_irqsave(&EXT4_I(inode)->i_completed_io_lock, flags);\n\tlist_add_tail(&io_end->list, &EXT4_I(inode)->i_completed_io_list);\n\tspin_unlock_irqrestore(&EXT4_I(inode)->i_completed_io_lock, flags);\n\n\twq = EXT4_SB(inode->i_sb)->dio_unwritten_wq;\n\tqueue_work(wq, &io_end->work);\nout:\n\tbh->b_private = NULL;\n\tbh->b_end_io = NULL;\n\tclear_buffer_uninit(bh);\n\tend_buffer_async_write(bh, uptodate);\n}",
        "output": "0",
        "idx": 3179
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *get_nextpath(char *path, int *offsetp, int fulllen)\n{\n\tint offset = *offsetp;\n\n\tif (offset >= fulllen)\n\t\treturn NULL;\n\n\twhile (path[offset] != '\\0' && offset < fulllen)\n\t\toffset++;\n\twhile (path[offset] == '\\0' && offset < fulllen)\n\t\toffset++;\n\n\t*offsetp = offset;\n\treturn (offset < fulllen) ? &path[offset] : NULL;\n}",
        "output": "0",
        "idx": 6063
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mct_u232_port_probe(struct usb_serial_port *port)\n{\n\tstruct mct_u232_private *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->read_urb = port->serial->port[1]->interrupt_in_urb;\n\tpriv->read_urb->context = port;\n\n\tspin_lock_init(&priv->lock);\n\n\tusb_set_serial_port_data(port, priv);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1204
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void print_cfs_stats(struct seq_file *m, int cpu)\n{\n\tstruct cfs_rq *cfs_rq, *pos;\n\n\trcu_read_lock();\n\tfor_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)\n\t\tprint_cfs_rq(m, cpu, cfs_rq);\n\trcu_read_unlock();\n}",
        "output": "1",
        "idx": 3054
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pthread_mutex_lock(pthread_mutex_t *mutex)\n{\n\tEnterCriticalSection(mutex);\n\treturn 0;\n}",
        "output": "1",
        "idx": 7844
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void init_xml_schema()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"Schema\", rb_cObject);\n\n  cNokogiriXmlSchema = klass;\n\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n  rb_define_private_method(klass, \"validate_file\",     validate_file, 1);\n}",
        "output": "1",
        "idx": 8250
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "validate_group(struct perf_event *event)\n{\n\tstruct perf_event *sibling, *leader = event->group_leader;\n\tstruct pmu_hw_events fake_pmu;\n\tDECLARE_BITMAP(fake_used_mask, ARMPMU_MAX_HWEVENTS);\n\n\tmemset(fake_used_mask, 0, sizeof(fake_used_mask));\n\tfake_pmu.used_mask = fake_used_mask;\n\n\tif (!validate_event(event->pmu, &fake_pmu, leader))\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(sibling, &leader->sibling_list, group_entry) {\n\t\tif (!validate_event(event->pmu, &fake_pmu, sibling))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!validate_event(event->pmu, &fake_pmu, event))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 3889
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void device_init()\n{\n\n    hw_init(LOW_FREQUENCY);\n\n    if (! tsc_sensor_exists())\n    {\n        _NFC_status = nfc_init();\n    }\n\n    if (_NFC_status == NFC_IS_ACTIVE)\n    {\n        printf1(TAG_NFC, \"Have NFC\\r\\n\");\n        isLowFreq = 1;\n        IS_BUTTON_PRESSED = is_physical_button_pressed;\n    }\n    else\n    {\n        printf1(TAG_NFC, \"Have NO NFC\\r\\n\");\n        hw_init(HIGH_FREQUENCY);\n        isLowFreq = 0;\n        device_init_button();\n    }\n\n    usbhid_init();\n    ctaphid_init();\n    ctap_init();\n\n    device_migrate();\n\n#if BOOT_TO_DFU\n    flash_option_bytes_init(1);\n#else\n    flash_option_bytes_init(0);\n#endif\n\n\n}",
        "output": "1",
        "idx": 8352
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int getStrrtokenPos(char* str, int savedPos)\n{\n\tint result =-1;\n\tint i;\n\t\n\tfor(i=savedPos-1; i>=0; i--) {\n\t\tif(isIDSeparator(*(str+i)) ){\n\t\t\tif(i>=2 && isIDSeparator(*(str+i-2)) ){\n\t\t\t\tresult = i-2;\n\t\t\t} else {\n\t\t\t\tresult = i;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(result < 1){\n\t\tresult =-1;\n\t}\n\treturn result;\n}",
        "output": "1",
        "idx": 3878
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "swabHorAcc32(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\tuint32* wp = (uint32*) cp0;\n\ttmsize_t wc = cc / 4;\n\n        TIFFSwabArrayOfLong(wp, wc);\n\treturn horAcc32(tif, cp0, cc);\n}",
        "output": "0",
        "idx": 5893
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE read_memory(VALUE klass, VALUE content)\n{\n  xmlSchemaPtr schema;\n  xmlSchemaParserCtxtPtr ctx = xmlSchemaNewMemParserCtxt(\n      (const char *)StringValuePtr(content),\n      (int)RSTRING_LEN(content)\n  );\n  VALUE rb_schema;\n  VALUE errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n  xmlSchemaSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n   schema = xmlSchemaParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlSchemaFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n\n  return rb_schema;\n}",
        "output": "1",
        "idx": 8254
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n{\n    long i;\n    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n        long a = *(long *)(src1 + i);\n        long b = *(long *)(src2 + i);\n        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n    }\n    for (; i < w; i++)\n        dst[i] = src1[i] + src2[i];\n}",
        "output": "1",
        "idx": 3554
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "create_spnego_ctx(void)\n{\n\tspnego_gss_ctx_id_t spnego_ctx = NULL;\n\tspnego_ctx = (spnego_gss_ctx_id_t)\n\t\tmalloc(sizeof (spnego_gss_ctx_id_rec));\n\n\tif (spnego_ctx == NULL) {\n\t\treturn (NULL);\n\t}\n\n\tspnego_ctx->magic_num = SPNEGO_MAGIC_ID;\n\tspnego_ctx->ctx_handle = GSS_C_NO_CONTEXT;\n\tspnego_ctx->mech_set = NULL;\n\tspnego_ctx->internal_mech = NULL;\n\tspnego_ctx->optionStr = NULL;\n\tspnego_ctx->DER_mechTypes.length = 0;\n\tspnego_ctx->DER_mechTypes.value = NULL;\n\tspnego_ctx->default_cred = GSS_C_NO_CREDENTIAL;\n\tspnego_ctx->mic_reqd = 0;\n\tspnego_ctx->mic_sent = 0;\n\tspnego_ctx->mic_rcvd = 0;\n\tspnego_ctx->mech_complete = 0;\n\tspnego_ctx->nego_done = 0;\n\tspnego_ctx->internal_name = GSS_C_NO_NAME;\n\tspnego_ctx->actual_mech = GSS_C_NO_OID;\n\n\tcheck_spnego_options(spnego_ctx);\n\n\treturn (spnego_ctx);\n}",
        "output": "1",
        "idx": 80
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iakerb_gss_verify_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                      gss_buffer_t msg_buffer, gss_buffer_t token_buffer,\n                      gss_qop_t *qop_state)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_verify_mic(minor_status, ctx->gssc, msg_buffer,\n                               token_buffer, qop_state);\n}",
        "output": "0",
        "idx": 133
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MONGO_EXPORT int mongo_run_command( mongo *conn, const char *db, const bson *command,\n                                    bson *out ) {\n    int ret = MONGO_OK;\n    bson response = {NULL, 0};\n    bson fields;\n    int sl = strlen( db );\n    char *ns = bson_malloc( sl + 5 + 1 ); \n    int res, success = 0;\n\n    strcpy( ns, db );\n    strcpy( ns+sl, \".$cmd\" );\n\n    res = mongo_find_one( conn, ns, command, bson_empty( &fields ), &response );\n    bson_free( ns );\n\n    if( res != MONGO_OK )\n        ret = MONGO_ERROR;\n    else {\n        bson_iterator it;\n        if( bson_find( &it, &response, \"ok\" ) )\n            success = bson_iterator_bool( &it );\n\n        if( !success ) {\n            conn->err = MONGO_COMMAND_FAILED;\n            bson_destroy( &response );\n            ret = MONGO_ERROR;\n        }\n        else {\n            if( out )\n                *out = response;\n            else\n                bson_destroy( &response );\n        }\n    }\n    return ret;\n}",
        "output": "1",
        "idx": 7920
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int m88rs2000_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tu8 obuf[] = { 0x51 };\n\tu8 ibuf[] = { 0 };\n\n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\n\td->fe_adap[0].fe = dvb_attach(m88rs2000_attach, &s421_m88rs2000_config,\n\t\t\t\t\t&d->dev->i2c_adap);\n\n\tif (d->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\n\tif (dvb_attach(ts2020_attach, d->fe_adap[0].fe,\n\t\t\t\t&dw2104_ts2020_config,\n\t\t\t\t&d->dev->i2c_adap)) {\n\t\tinfo(\"Attached RS2000/TS2020!\");\n\t\treturn 0;\n\t}\n\n\tinfo(\"Failed to attach RS2000/TS2020!\");\n\treturn -EIO;\n}",
        "output": "1",
        "idx": 1510
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int pgx_validate(jas_stream_t *in)\n{\n\tjas_uchar buf[PGX_MAGICLEN];\n\tuint_fast32_t magic;\n\tint i;\n\tint n;\n\n\tassert(JAS_STREAM_MAXPUTBACK >= PGX_MAGICLEN);\n\n\tif ((n = jas_stream_read(in, buf, PGX_MAGICLEN)) < 0) {\n\t\treturn -1;\n\t}\n\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (n < PGX_MAGICLEN) {\n\t\treturn -1;\n\t}\n\n\tmagic = (buf[0] << 8) | buf[1];\n\n\tif (magic != PGX_MAGIC) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 7585
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int inotify_release(struct inode *ignored, struct file *file)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\tstruct user_struct *user = group->inotify_data.user;\n\n\tpr_debug(\"%s: group=%p\\n\", __func__, group);\n\n\tfsnotify_clear_marks_by_group(group);\n\n\tfsnotify_put_group(group);\n\n\tatomic_dec(&user->inotify_devs);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 294
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, getCsvControl)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar delimiter[2], enclosure[2];\n\n\tarray_init(return_value);\n\t\n\tdelimiter[0] = intern->u.file.delimiter;\n\tdelimiter[1] = '\\0';\n\tenclosure[0] = intern->u.file.enclosure;\n\tenclosure[1] = '\\0';\n\n\tadd_next_index_string(return_value, delimiter, 1);\n\tadd_next_index_string(return_value, enclosure, 1);\n}",
        "output": "1",
        "idx": 3944
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API void r_anal_bb_free(RAnalBlock *bb) {\n\tif (!bb) {\n\t\treturn;\n\t}\n\tr_anal_cond_free (bb->cond);\n\tR_FREE (bb->fingerprint);\n\tr_anal_diff_free (bb->diff);\n\tbb->diff = NULL;\n\tR_FREE (bb->op_bytes);\n\tr_anal_switch_op_free (bb->switch_op);\n\tbb->switch_op = NULL;\n\tbb->fingerprint = NULL;\n\tbb->cond = NULL;\n\tR_FREE (bb->label);\n\tR_FREE (bb->op_pos);\n\tR_FREE (bb->parent_reg_arena);\n\tif (bb->prev) {\n\t\tif (bb->prev->jumpbb == bb) {\n\t\t\tbb->prev->jumpbb = NULL;\n\t\t}\n\t\tif (bb->prev->failbb == bb) {\n\t\t\tbb->prev->failbb = NULL;\n\t\t}\n\t\tbb->prev = NULL;\n\t}\n\tif (bb->jumpbb) {\n\t\tbb->jumpbb->prev = NULL;\n\t\tbb->jumpbb = NULL;\n\t}\n\tif (bb->failbb) {\n\t\tbb->failbb->prev = NULL;\n\t\tbb->failbb = NULL;\n\t}\n\tif (bb->next) {\n\t\tbb->next->prev = NULL;\n\t}\n\tR_FREE (bb); \n}",
        "output": "0",
        "idx": 8717
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\tpmd_t pmdval = pmd_read_atomic(pmd);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval) || pmd_trans_huge(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 3439
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __init acpi_debugfs_init(void)\n{\n\tacpi_debugfs_dir = debugfs_create_dir(\"acpi\", NULL);\n\n\tacpi_custom_method_init();\n}",
        "output": "1",
        "idx": 400
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "log2vis_encoded_string (PyObject * string, const char *encoding,\n\t\t\tFriBidiParType base_direction, int clean, int reordernsm)\n{\n\tPyObject *logical = NULL;\t\n\tPyObject *result = NULL;\t\n\n\tlogical = PyUnicode_Decode (PyString_AS_STRING (string),\n\t\t\t\t    PyString_GET_SIZE (string),\n\t\t\t\t    encoding, \"strict\");\n\tif (logical == NULL)\n\t\treturn NULL;\n\n\tif (strcmp (encoding, \"utf-8\") == 0)\n\t\tresult = log2vis_utf8 (string,\n\t\t\t\t       PyUnicode_GET_SIZE (logical),\n\t\t\t\t       base_direction, clean, reordernsm);\n\telse\n\t{\n\n\t\tPyObject *visual = log2vis_unicode (logical, base_direction, clean, reordernsm);\n\n\t\tif (visual)\n\t\t{\n\t\t\tresult = PyUnicode_Encode (PyUnicode_AS_UNICODE\n\t\t\t\t\t\t   (visual),\n\t\t\t\t\t\t   PyUnicode_GET_SIZE (visual),\n\t\t\t\t\t\t   encoding, \"strict\");\n\t\t\tPy_DECREF (visual);\n\t\t}\n\t}\n\n\tPy_DECREF (logical);\n\n\treturn result;\n}",
        "output": "1",
        "idx": 3610
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sched_read_attr(struct sched_attr __user *uattr,\n\t\t\t   struct sched_attr *attr,\n\t\t\t   unsigned int usize)\n{\n\tint ret;\n\n\tif (!access_ok(VERIFY_WRITE, uattr, usize))\n\t\treturn -EFAULT;\n\n\tif (usize < sizeof(*attr)) {\n\t\tunsigned char *addr;\n\t\tunsigned char *end;\n\n\t\taddr = (void *)attr + usize;\n\t\tend  = (void *)attr + sizeof(*attr);\n\n\t\tfor (; addr < end; addr++) {\n\t\t\tif (*addr)\n\t\t\t\tgoto err_size;\n\t\t}\n\n\t\tattr->size = usize;\n\t}\n\n\tret = copy_to_user(uattr, attr, attr->size);\n\tif (ret)\n\t\treturn -EFAULT;\n\nout:\n\treturn ret;\n\nerr_size:\n\tret = -E2BIG;\n\tgoto out;\n}",
        "output": "0",
        "idx": 3479
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void virtio_config_writew(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint16_t val = data;\n\n    if (addr > (vdev->config_len - sizeof(val)))\n        return;\n\n    stw_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}",
        "output": "1",
        "idx": 3764
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char *findvararg (CallInfo *ci, int n, StkId *pos) {\n  if (clLvalue(s2v(ci->func))->p->is_vararg) {\n    int nextra = ci->u.l.nextraargs;\n    if (n <= nextra) {\n      *pos = ci->func - nextra + (n - 1);\n      return \"(vararg)\";  \n    }\n  }\n  return NULL;  \n}",
        "output": "1",
        "idx": 8112
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_dn_exists(krb5_context context,\n                krb5_ldap_server_handle *ldap_server_handle,\n                const char *dn, krb5_boolean nonkrb_only)\n{\n    krb5_error_code st = 0, tempst;\n    krb5_ldap_context *ldap_context = context->dal_handle->db_context;\n    LDAP *ld = ldap_server_handle->ldap_handle;\n    LDAPMessage *result = NULL, *ent;\n    char *attrs[] = { \"krbticketpolicyreference\", \"krbprincipalname\", NULL };\n    char **values;\n\n    LDAP_SEARCH_1(dn, LDAP_SCOPE_BASE, 0, attrs, IGNORE_STATUS);\n    if (st != LDAP_SUCCESS)\n        return set_ldap_error(context, st, OP_SEARCH);\n\n    ent = ldap_first_entry(ld, result);\n    CHECK_NULL(ent);\n\n    values = ldap_get_values(ld, ent, \"krbticketpolicyreference\");\n    if (values != NULL)\n        ldap_value_free(values);\n\n    values = ldap_get_values(ld, ent, \"krbprincipalname\");\n    if (values != NULL) {\n        ldap_value_free(values);\n        if (nonkrb_only) {\n            st = EINVAL;\n            k5_setmsg(context, st, _(\"ldap object is already kerberized\"));\n            goto cleanup;\n        }\n    }\n\ncleanup:\n    ldap_msgfree(result);\n    return st;\n}",
        "output": "0",
        "idx": 293
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int spl_filesystem_file_is_empty_line(spl_filesystem_object *intern TSRMLS_DC) \n{\n\tif (intern->u.file.current_line) {\n\t\treturn intern->u.file.current_line_len == 0;\n\t} else if (intern->u.file.current_zval) {\n\t\tswitch(Z_TYPE_P(intern->u.file.current_zval)) {\n\t\tcase IS_STRING:\n\t\t\treturn Z_STRLEN_P(intern->u.file.current_zval) == 0;\n\t\tcase IS_ARRAY:\n\t\t\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV)\n\t\t\t&& zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 1) {\n\t\t\t\tzval ** first = Z_ARRVAL_P(intern->u.file.current_zval)->pListHead->pData;\n\t\t\t\t\t\n\t\t\t\treturn Z_TYPE_PP(first) == IS_STRING && Z_STRLEN_PP(first) == 0;\n\t\t\t}\n\t\t\treturn zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 0;\n\t\tcase IS_NULL:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\treturn 1;\n\t}\n}",
        "output": "1",
        "idx": 3984
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rd_release_device_space(struct rd_dev *rd_dev)\n{\n\tu32 page_count;\n\n\tif (!rd_dev->sg_table_array || !rd_dev->sg_table_count)\n\t\treturn;\n\n\tpage_count = rd_release_sgl_table(rd_dev, rd_dev->sg_table_array,\n\t\t\t\t\t  rd_dev->sg_table_count);\n\n\tpr_debug(\"CORE_RD[%u] - Released device space for Ramdisk\"\n\t\t\" Device ID: %u, pages %u in %u tables total bytes %lu\\n\",\n\t\trd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count,\n\t\trd_dev->sg_table_count, (unsigned long)page_count * PAGE_SIZE);\n\n\trd_dev->sg_table_array = NULL;\n\trd_dev->sg_table_count = 0;\n}",
        "output": "0",
        "idx": 3455
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jpc_ppm_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\n\tcstate = 0;\n\n\tif (JAS_CAST(uint, jas_stream_write(out, (char *) ppm->data, ppm->len)) != ppm->len) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 5400
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t    return (GSS_S_NO_CONTEXT);\n\n    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n\t\t\t   iov_count);\n}",
        "output": "0",
        "idx": 87
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vgacon_scrollback_startup(void)\n{\n\tvgacon_scrollback_cur = &vgacon_scrollbacks[0];\n\tvgacon_scrollback_init(0);\n}",
        "output": "1",
        "idx": 1874
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mp_unpack_full(lua_State *L, int limit, int offset) {\n    size_t len;\n    const char *s;\n    mp_cur c;\n    int cnt; \n    int decode_all = (!limit && !offset);\n\n    s = luaL_checklstring(L,1,&len); \n\n    if (offset < 0 || limit < 0) \n        return luaL_error(L,\n            \"Invalid request to unpack with offset of %d and limit of %d.\",\n            offset, len);\n    else if (offset > len)\n        return luaL_error(L,\n            \"Start offset %d greater than input length %d.\", offset, len);\n\n    if (decode_all) limit = INT_MAX;\n\n    mp_cur_init(&c,(const unsigned char *)s+offset,len-offset);\n\n    for(cnt = 0; c.left > 0 && cnt < limit; cnt++) {\n        mp_decode_to_lua_type(L,&c);\n\n        if (c.err == MP_CUR_ERROR_EOF) {\n            return luaL_error(L,\"Missing bytes in input.\");\n        } else if (c.err == MP_CUR_ERROR_BADFMT) {\n            return luaL_error(L,\"Bad data format in input.\");\n        }\n    }\n\n    if (!decode_all) {\n        int offset = len - c.left;\n\n        luaL_checkstack(L, 1, \"in function mp_unpack_full\");\n\n        lua_pushinteger(L, c.left == 0 ? -1 : offset);\n        lua_insert(L, 2);\n        cnt += 1; \n    }\n\n    return cnt;\n}",
        "output": "0",
        "idx": 5109
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC MprJson *mprReadJsonObj(MprJson *obj, cchar *name)\n{\n    MprJson      *child;\n    int         i, index;\n\n    if (!obj || !name) {\n        return 0;\n    }\n    if (obj->type & MPR_JSON_OBJ) {\n        for (ITERATE_JSON(obj, child, i)) {\n            if (smatch(child->name, name)) {\n                return child;\n            }\n        }\n    } else if (obj->type & MPR_JSON_ARRAY) {\n        if (*name == '$') {\n            return 0;\n        }\n        index = (int) stoi(name);\n        for (ITERATE_JSON(obj, child, i)) {\n            if (i == index) {\n                return child;\n            }\n        }\n    }\n    return 0;\n}",
        "output": "0",
        "idx": 7069
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int get_evtchn_to_irq(evtchn_port_t evtchn)\n{\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -1;\n\tif (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)\n\t\treturn -1;\n\treturn evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)];\n}",
        "output": "1",
        "idx": 1890
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jas_iccputuint(jas_stream_t *out, int n, ulonglong val)\n{\n\tint i;\n\tint c;\n\tfor (i = n; i > 0; --i) {\n\t\tc = (val >> (8 * (i - 1))) & 0xff;\n\t\tif (jas_stream_putc(out, c) == EOF)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 5382
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "swabHorDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n    uint32* wp = (uint32*) cp0;\n    tmsize_t wc = cc / 4;\n\n    if( !horDiff32(tif, cp0, cc) )\n        return 0;\n\n    TIFFSwabArrayOfLong(wp, wc);\n    return 1;\n}",
        "output": "0",
        "idx": 5909
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "krb5_gss_context_time(minor_status, context_handle, time_rec)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    OM_uint32 *time_rec;\n{\n    krb5_error_code code;\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_timestamp now;\n    krb5_deltat lifetime;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (ctx->terminated || !ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    if ((code = krb5_timeofday(ctx->k5_context, &now))) {\n        *minor_status = code;\n        save_error_info(*minor_status, ctx->k5_context);\n        return(GSS_S_FAILURE);\n    }\n\n    if ((lifetime = ctx->krb_times.endtime - now) <= 0) {\n        *time_rec = 0;\n        *minor_status = 0;\n        return(GSS_S_CONTEXT_EXPIRED);\n    } else {\n        *time_rec = lifetime;\n        *minor_status = 0;\n        return(GSS_S_COMPLETE);\n    }\n}",
        "output": "0",
        "idx": 25
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "snmp_mib_find(uint32_t *oid)\n{\n  snmp_mib_resource_t *resource;\n\n  resource = NULL;\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource->next) {\n\n    if(!snmp_oid_cmp_oid(oid, resource->oid)) {\n      return resource;\n    }\n  }\n\n  return NULL;\n}",
        "output": "1",
        "idx": 7978
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_report_acomp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_acomp racomp;\n\n\tstrncpy(racomp.type, \"acomp\", sizeof(racomp.type));\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_ACOMP,\n\t\t    sizeof(struct crypto_report_acomp), &racomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "0",
        "idx": 4179
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tspinlock_t *ptl;\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *ptep;\n\tunsigned char *vec = walk->private;\n\tint nr = (end - addr) >> PAGE_SHIFT;\n\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (ptl) {\n\t\tmemset(vec, 1, nr);\n\t\tspin_unlock(ptl);\n\t\tgoto out;\n\t}\n\n\tif (pmd_trans_unstable(pmd)) {\n\t\tmemset(vec, 1, nr);\n\t\tgoto out;\n\t}\n\n\tptep = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tfor (; addr != end; ptep++, addr += PAGE_SIZE) {\n\t\tpte_t pte = *ptep;\n\n\t\tif (pte_none(pte))\n\t\t\t*vec = 0;\n\t\telse if (pte_present(pte))\n\t\t\t*vec = 1;\n\t\telse { \n\t\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\n\t\t\t*vec = !!non_swap_entry(entry);\n\t\t}\n\t\tvec++;\n\t}\n\tpte_unmap_unlock(ptep - 1, ptl);\nout:\n\twalk->private += nr;\n\tcond_resched();\n\treturn 0;\n}",
        "output": "0",
        "idx": 4227
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void do_perf_sw_event(enum perf_type_id type, u32 event_id,\n\t\t\t\t    u64 nr,\n\t\t\t\t    struct perf_sample_data *data,\n\t\t\t\t    struct pt_regs *regs)\n{\n\tstruct swevent_htable *swhash = &__get_cpu_var(swevent_htable);\n\tstruct perf_event *event;\n\tstruct hlist_node *node;\n\tstruct hlist_head *head;\n\n\trcu_read_lock();\n\thead = find_swevent_head_rcu(swhash, type, event_id);\n\tif (!head)\n\t\tgoto end;\n\n\thlist_for_each_entry_rcu(event, node, head, hlist_entry) {\n\t\tif (perf_swevent_match(event, type, event_id, data, regs))\n\t\t\tperf_swevent_event(event, nr, data, regs);\n\t}\nend:\n\trcu_read_unlock();\n}",
        "output": "0",
        "idx": 681
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "swabHorDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n    uint16* wp = (uint16*) cp0;\n    tmsize_t wc = cc / 2;\n\n    horDiff16(tif, cp0, cc);\n\n    TIFFSwabArrayOfShort(wp, wc);\n}",
        "output": "1",
        "idx": 4272
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "extract_header_length(uint16_t fc)\n{\n\tint len = 0;\n\n\tswitch ((fc >> 10) & 0x3) {\n\tcase 0x00:\n\t\tif (fc & (1 << 6)) \n\t\t\treturn -1;\n\t\tbreak;\n\tcase 0x01:\n\t\treturn -1;\n\tcase 0x02:\n\t\tlen += 4;\n\t\tbreak;\n\tcase 0x03:\n\t\tlen += 10;\n\t\tbreak;\n\t}\n\n\tswitch ((fc >> 14) & 0x3) {\n\tcase 0x00:\n\t\tbreak;\n\tcase 0x01:\n\t\treturn -1;\n\tcase 0x02:\n\t\tlen += 4;\n\t\tbreak;\n\tcase 0x03:\n\t\tlen += 10;\n\t\tbreak;\n\t}\n\n\tif (fc & (1 << 6)) {\n\t\tif (len < 2)\n\t\t\treturn -1;\n\t\tlen -= 2;\n\t}\n\n\treturn len;\n}",
        "output": "1",
        "idx": 4742
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void free_ep_req(struct usb_ep *ep, struct usb_request *req)\n{\n\tWARN_ON(req->buf == NULL);\n\tkfree(req->buf);\n\treq->buf = NULL;\n\tusb_ep_free_request(ep, req);\n}",
        "output": "0",
        "idx": 4065
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int fuse_verify_ioctl_iov(struct iovec *iov, size_t count)\n{\n\tsize_t n;\n\tu32 max = FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT;\n\n\tfor (n = 0; n < count; n++) {\n\t\tif (iov->iov_len > (size_t) max)\n\t\t\treturn -ENOMEM;\n\t\tmax -= iov->iov_len;\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 341
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cil_reset_classpermission(struct cil_classpermission *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\n\tcil_list_destroy(&cp->classperms, CIL_FALSE);\n}",
        "output": "0",
        "idx": 8481
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ext4_dax_pmd_fault(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\t\t\tpmd_t *pmd, unsigned int flags)\n{\n\tint result;\n\thandle_t *handle = NULL;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct super_block *sb = inode->i_sb;\n\tbool write = flags & FAULT_FLAG_WRITE;\n\n\tif (write) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\n\t\t\t\text4_chunk_trans_blocks(inode,\n\t\t\t\t\t\t\tPMD_SIZE / PAGE_SIZE));\n\t}\n\n\tif (IS_ERR(handle))\n\t\tresult = VM_FAULT_SIGBUS;\n\telse\n\t\tresult = __dax_pmd_fault(vma, addr, pmd, flags,\n\t\t\t\text4_get_block_dax, ext4_end_io_unwritten);\n\n\tif (write) {\n\t\tif (!IS_ERR(handle))\n\t\t\text4_journal_stop(handle);\n\t\tsb_end_pagefault(sb);\n\t}\n\n\treturn result;\n}",
        "output": "1",
        "idx": 988
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *gdImageJpegPtr (gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n\tgdImageJpegCtx (im, out, quality);\n\trv = gdDPExtractData (out, size);\n\tout->gd_free (out);\n\n\treturn rv;\n}",
        "output": "1",
        "idx": 4122
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\tgdImageWebpCtx(im, out, -1);\n\tout->gd_free(out);\n}",
        "output": "1",
        "idx": 4448
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void file_sb_list_del(struct file *file)\n{\n\tif (!list_empty(&file->f_u.fu_list)) {\n\t\tlg_local_lock_cpu(&files_lglock, file_list_cpu(file));\n\t\tlist_del_init(&file->f_u.fu_list);\n\t\tlg_local_unlock_cpu(&files_lglock, file_list_cpu(file));\n\t}\n}",
        "output": "1",
        "idx": 2370
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC bool httpGetStreaming(HttpHost *host, cchar *mime, cchar *uri)\n{\n    MprKey      *kp;\n\n    assert(host);\n    assert(host->streams);\n\n    if (schr(mime, ';')) {\n        mime = stok(sclone(mime), \";\", 0);\n    }\n    if ((kp = mprLookupKeyEntry(host->streams, mime)) != 0) {\n        if (kp->data == NULL || sstarts(uri, kp->data)) {\n            return kp->type;\n        }\n    }\n    return 1;\n}",
        "output": "1",
        "idx": 5050
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sgi_clock_set(clockid_t clockid, struct timespec *tp)\n{\n\n\tu64 nsec;\n\tu32 rem;\n\n\tnsec = rtc_time() * sgi_clock_period;\n\n\tsgi_clock_offset.tv_sec = tp->tv_sec - div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\n\tif (rem <= tp->tv_nsec)\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec - rem;\n\telse {\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;\n\t\tsgi_clock_offset.tv_sec--;\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 3003
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "do_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap __attribute__((__unused__)), uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags)\n{\n\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n\t    type == NT_GNU_BUILD_ID && (descsz >= 4 && descsz <= 20)) {\n\t\tuint8_t desc[20];\n\t\tconst char *btype;\n\t\tuint32_t i;\n\t\t*flags |= FLAGS_DID_BUILD_ID;\n\t\tswitch (descsz) {\n\t\tcase 8:\n\t\t    btype = \"xxHash\";\n\t\t    break;\n\t\tcase 16:\n\t\t    btype = \"md5/uuid\";\n\t\t    break;\n\t\tcase 20:\n\t\t    btype = \"sha1\";\n\t\t    break;\n\t\tdefault:\n\t\t    btype = \"unknown\";\n\t\t    break;\n\t\t}\n\t\tif (file_printf(ms, \", BuildID[%s]=\", btype) == -1)\n\t\t\treturn 1;\n\t\t(void)memcpy(desc, &nbuf[doff], descsz);\n\t\tfor (i = 0; i < descsz; i++)\n\t\t    if (file_printf(ms, \"%02x\", desc[i]) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 6073
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "read_new_length(cdk_stream_t inp,\n\t\tsize_t * r_len, size_t * r_size, size_t * r_partial)\n{\n\tint c, c1;\n\n\tc = cdk_stream_getc(inp);\n\tif (c == EOF)\n\t\treturn;\n\n\t(*r_size)++;\n\tif (c < 192)\n\t\t*r_len = c;\n\telse if (c >= 192 && c <= 223) {\n\t\tc1 = cdk_stream_getc(inp);\n\t\tif (c1 == EOF)\n\t\t\treturn;\n\n\t\t(*r_size)++;\n\t\t*r_len = ((c - 192) << 8) + c1 + 192;\n\t} else if (c == 255) {\n\t\t*r_len = read_32(inp);\n\t\tif (*r_len == (u32)-1) {\n\t\t\treturn;\n\t\t}\n\n\t\t(*r_size) += 4;\n\t} else {\n\t\t*r_len = 1 << (c & 0x1f);\n\t\t*r_partial = 1;\n\t}\n}",
        "output": "0",
        "idx": 6481
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void blk_mq_tag_set_rq(struct blk_mq_hw_ctx *hctx,\n\t\tunsigned int tag, struct request *rq)\n{\n\thctx->tags->rqs[tag] = rq;\n}",
        "output": "0",
        "idx": 3995
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t _epoll_writev(\n    oe_fd_t* desc,\n    const struct oe_iovec* iov,\n    int iovcnt)\n{\n    ssize_t ret = -1;\n    epoll_t* file = _cast_epoll(desc);\n    void* buf = NULL;\n    size_t buf_size = 0;\n\n    if (!file || (iovcnt && !iov) || iovcnt < 0 || iovcnt > OE_IOV_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_iov_pack(iov, iovcnt, &buf, &buf_size) != 0)\n        OE_RAISE_ERRNO(OE_ENOMEM);\n\n    if (oe_syscall_writev_ocall(&ret, file->host_fd, buf, iovcnt, buf_size) !=\n        OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    if (buf)\n        oe_free(buf);\n\n    return ret;\n}",
        "output": "1",
        "idx": 8016
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct clock_source *dcn10_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "output": "0",
        "idx": 4525
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)\n{\n\tstruct block_device *bdev;\n\tchar b[BDEVNAME_SIZE];\n\n\tbdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);\n\tif (IS_ERR(bdev))\n\t\tgoto fail;\n\treturn bdev;\n\nfail:\n\text3_msg(sb, KERN_ERR, \"error: failed to open journal device %s: %ld\",\n\t\t__bdevname(dev, b), PTR_ERR(bdev));\n\n\treturn NULL;\n}",
        "output": "0",
        "idx": 1217
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n{\n\tstruct sockaddr_rc sa;\n\tstruct sock *sk = sock->sk;\n\tint len, err = 0;\n\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tmemset(&sa, 0, sizeof(sa));\n\tlen = min_t(unsigned int, sizeof(sa), addr_len);\n\tmemcpy(&sa, addr, len);\n\n\tBT_DBG(\"sk %p %pMR\", sk, &sa.rc_bdaddr);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\twrite_lock(&rfcomm_sk_list.lock);\n\n\tif (sa.rc_channel &&\n\t    __rfcomm_get_listen_sock_by_addr(sa.rc_channel, &sa.rc_bdaddr)) {\n\t\terr = -EADDRINUSE;\n\t} else {\n\t\tbacpy(&rfcomm_pi(sk)->src, &sa.rc_bdaddr);\n\t\trfcomm_pi(sk)->channel = sa.rc_channel;\n\t\tsk->sk_state = BT_BOUND;\n\t}\n\n\twrite_unlock(&rfcomm_sk_list.lock);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}",
        "output": "0",
        "idx": 3961
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n\t\tinfop, int, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);\n\tint signo = 0;\n\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (!infop)\n\t\treturn err;\n\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}",
        "output": "0",
        "idx": 2433
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rfcomm_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tmemset(sa, 0, sizeof(*sa));\n\tsa->rc_family  = AF_BLUETOOTH;\n\tsa->rc_channel = rfcomm_pi(sk)->channel;\n\tif (peer)\n\t\tbacpy(&sa->rc_bdaddr, &bt_sk(sk)->dst);\n\telse\n\t\tbacpy(&sa->rc_bdaddr, &bt_sk(sk)->src);\n\n\t*len = sizeof(struct sockaddr_rc);\n\treturn 0;\n}",
        "output": "0",
        "idx": 1007
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void numtostr(js_State *J, const char *fmt, int w, double n)\n{\n\tchar buf[32], *e;\n\tsprintf(buf, fmt, w, n);\n\te = strchr(buf, 'e');\n\tif (e) {\n\t\tint exp = atoi(e+1);\n\t\tsprintf(e, \"e%+d\", exp);\n\t}\n\tjs_pushstring(J, buf);\n}",
        "output": "1",
        "idx": 7404
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev)\n{\n\tstruct virtproc_info *vrp = vdev->priv;\n\tstruct virtio_rpmsg_channel *vch;\n\tstruct rpmsg_device *rpdev_ctrl;\n\tint err = 0;\n\n\tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n\tif (!vch)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvch->vrp = vrp;\n\n\trpdev_ctrl = &vch->rpdev;\n\trpdev_ctrl->ops = &virtio_rpmsg_ops;\n\n\trpdev_ctrl->dev.parent = &vrp->vdev->dev;\n\trpdev_ctrl->dev.release = virtio_rpmsg_release_device;\n\trpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);\n\n\terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n\tif (err) {\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn rpdev_ctrl;\n}",
        "output": "0",
        "idx": 2927
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_report(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t\t struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto drop_alg;\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = crypto_report_alg(alg, &info);\n\ndrop_alg:\n\tcrypto_mod_put(alg);\n\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}",
        "output": "0",
        "idx": 4551
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "atol8(const char *p, size_t char_cnt)\n{\n\tint64_t l;\n\tint digit;\n        \n\tl = 0;\n\twhile (char_cnt-- > 0) {\n\t\tif (*p >= '0' && *p <= '7')\n\t\t\tdigit = *p - '0';\n\t\telse\n\t\t\tbreak;\n\t\tp++;\n\t\tl <<= 3;\n\t\tl |= digit;\n\t}\n\treturn (l);\n}",
        "output": "1",
        "idx": 3670
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct mb2_cache_entry *__entry_find(struct mb2_cache *cache,\n\t\t\t\t\t    struct mb2_cache_entry *entry,\n\t\t\t\t\t    u32 key)\n{\n\tstruct mb2_cache_entry *old_entry = entry;\n\tstruct hlist_bl_node *node;\n\tstruct hlist_bl_head *head;\n\n\tif (entry)\n\t\thead = entry->e_hash_list_head;\n\telse\n\t\thead = &cache->c_hash[hash_32(key, cache->c_bucket_bits)];\n\thlist_bl_lock(head);\n\tif (entry && !hlist_bl_unhashed(&entry->e_hash_list))\n\t\tnode = entry->e_hash_list.next;\n\telse\n\t\tnode = hlist_bl_first(head);\n\twhile (node) {\n\t\tentry = hlist_bl_entry(node, struct mb2_cache_entry,\n\t\t\t\t       e_hash_list);\n\t\tif (entry->e_key == key) {\n\t\t\tatomic_inc(&entry->e_refcnt);\n\t\t\tgoto out;\n\t\t}\n\t\tnode = node->next;\n\t}\n\tentry = NULL;\nout:\n\thlist_bl_unlock(head);\n\tif (old_entry)\n\t\tmb2_cache_entry_put(cache, old_entry);\n\n\treturn entry;\n}",
        "output": "0",
        "idx": 1621
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_be_int (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} ",
        "output": "1",
        "idx": 4932
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int udf_encode_fh(struct inode *inode, __u32 *fh, int *lenp,\n\t\t\t struct inode *parent)\n{\n\tint len = *lenp;\n\tstruct kernel_lb_addr location = UDF_I(inode)->i_location;\n\tstruct fid *fid = (struct fid *)fh;\n\tint type = FILEID_UDF_WITHOUT_PARENT;\n\n\tif (parent && (len < 5)) {\n\t\t*lenp = 5;\n\t\treturn 255;\n\t} else if (len < 3) {\n\t\t*lenp = 3;\n\t\treturn 255;\n\t}\n\n\t*lenp = 3;\n\tfid->udf.block = location.logicalBlockNum;\n\tfid->udf.partref = location.partitionReferenceNum;\n\tfid->udf.parent_partref = 0;\n\tfid->udf.generation = inode->i_generation;\n\n\tif (parent) {\n\t\tlocation = UDF_I(parent)->i_location;\n\t\tfid->udf.parent_block = location.logicalBlockNum;\n\t\tfid->udf.parent_partref = location.partitionReferenceNum;\n\t\tfid->udf.parent_generation = inode->i_generation;\n\t\t*lenp = 5;\n\t\ttype = FILEID_UDF_WITH_PARENT;\n\t}\n\n\treturn type;\n}",
        "output": "0",
        "idx": 983
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_parser_hvi(void) {\n\ttest_parser_param(1);\n}",
        "output": "0",
        "idx": 8401
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mm_answer_pam_init_ctx(int sock, Buffer *m)\n{\n\n\tdebug3(\"%s\", __func__);\n\tauthctxt->user = buffer_get_string(m, NULL);\n\tsshpam_ctxt = (sshpam_device.init_ctx)(authctxt);\n\tsshpam_authok = NULL;\n\tbuffer_clear(m);\n\tif (sshpam_ctxt != NULL) {\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_FREE_CTX, 1);\n\t\tbuffer_put_int(m, 1);\n\t} else {\n\t\tbuffer_put_int(m, 0);\n\t}\n\tmm_request_send(sock, MONITOR_ANS_PAM_INIT_CTX, m);\n\treturn (0);\n}",
        "output": "1",
        "idx": 5462
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ptrace_triggered(struct perf_event *bp,\n\t\t      struct perf_sample_data *data, struct pt_regs *regs)\n{\n\tstruct perf_event_attr attr;\n\n\tattr = bp->attr;\n\tattr.disabled = true;\n\tmodify_user_hw_breakpoint(bp, &attr);\n}",
        "output": "0",
        "idx": 607
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MemoryRegion *memory_map(struct uc_struct *uc, hwaddr begin, size_t size, uint32_t perms)\n{\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    memory_region_init_ram(uc, ram, size, perms);\n    if (ram->addr == -1) {\n        return NULL;\n    }\n\n    memory_region_add_subregion(uc->system_memory, begin, ram);\n\n    if (uc->cpu) {\n        tlb_flush(uc->cpu);\n    }\n\n    return ram;\n}",
        "output": "1",
        "idx": 8754
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmemdup(&data, 1, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,\n\t\t\t      indx, buf, 1, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\tkfree(buf);\n\treturn ret;\n}",
        "output": "0",
        "idx": 2127
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "snmp_ber_decode_unsigned_integer(unsigned char *buf, uint32_t *buff_len, uint8_t expected_type, uint32_t *num)\n{\n  uint8_t i, len, type;\n\n  buf = snmp_ber_decode_type(buf, buff_len, &type);\n\n  if(buf == NULL || type != expected_type) {\n    return NULL;\n  }\n\n  buf = snmp_ber_decode_length(buf, buff_len, &len);\n\n  if(buf == NULL || len > 4) {\n    return NULL;\n  }\n\n  if(*buff_len < len) {\n    return NULL;\n  }\n\n  *num = (uint32_t)(*buf++ & 0xFF);\n  (*buff_len)--;\n  for(i = 1; i < len; ++i) {\n    *num <<= 8;\n    *num |= (uint8_t)(*buf++ & 0xFF);\n    (*buff_len)--;\n  }\n\n  return buf;\n}",
        "output": "1",
        "idx": 7966
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API int r_core_bin_set_env(RCore *r, RBinFile *binfile) {\n\tRBinObject *binobj = binfile ? binfile->o: NULL;\n\tRBinInfo *info = binobj ? binobj->info: NULL;\n\tif (info) {\n\t\tint va = info->has_va;\n\t\tconst char * arch = info->arch;\n\t\tut16 bits = info->bits;\n\t\tut64 baseaddr = r_bin_get_baddr (r->bin);\n\t\tr_config_set_i (r->config, \"io.va\",\n\t\t\t(binobj->info)? binobj->info->has_va: 0);\n\t\tr_config_set_i (r->config, \"bin.baddr\", baseaddr);\n\t\tr_config_set (r->config, \"asm.arch\", arch);\n\t\tr_config_set_i (r->config, \"asm.bits\", bits);\n\t\tr_config_set (r->config, \"anal.arch\", arch);\n\t\tif (info->cpu && *info->cpu) {\n\t\t\tr_config_set (r->config, \"anal.cpu\", info->cpu);\n\t\t} else {\n\t\t\tr_config_set (r->config, \"anal.cpu\", arch);\n\t\t}\n\t\tr_asm_use (r->assembler, arch);\n\t\tr_core_bin_info (r, R_CORE_BIN_ACC_ALL, R_CORE_BIN_SET, va, NULL, NULL);\n\t\tr_core_bin_set_cur (r, binfile);\n\t\treturn true;\n\t}\n\treturn false;\n}",
        "output": "1",
        "idx": 6160
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __xen_evtchn_do_upcall(void)\n{\n\tstruct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu);\n\tint cpu = smp_processor_id();\n\tstruct evtchn_loop_ctrl ctrl = { 0 };\n\n\tread_lock(&evtchn_rwlock);\n\n\tdo {\n\t\tvcpu_info->evtchn_upcall_pending = 0;\n\n\t\txen_evtchn_handle_events(cpu, &ctrl);\n\n\t\tBUG_ON(!irqs_disabled());\n\n\t\tvirt_rmb(); \n\n\t} while (vcpu_info->evtchn_upcall_pending);\n\n\tread_unlock(&evtchn_rwlock);\n\n\t__this_cpu_inc(irq_epoch);\n}",
        "output": "0",
        "idx": 2737
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sd_compat_ioctl(struct block_device *bdev, fmode_t mode,\n\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\tstruct scsi_device *sdev = scsi_disk(bdev->bd_disk)->device;\n\tint ret;\n\n\tret = scsi_verify_blk_ioctl(bdev, cmd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!scsi_block_when_processing_errors(sdev))\n\t\treturn -ENODEV;\n\t       \n\tif (sdev->host->hostt->compat_ioctl) {\n\t\tret = sdev->host->hostt->compat_ioctl(sdev, cmd, (void __user *)arg);\n\n\t\treturn ret;\n\t}\n\n\treturn -ENOIOCTLCMD; \n}",
        "output": "0",
        "idx": 861
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int f2fs_set_data_page_dirty(struct page *page)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\n\ttrace_f2fs_set_page_dirty(page, DATA);\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\tif (PageSwapCache(page))\n\t\treturn __set_page_dirty_nobuffers(page);\n\n\tif (f2fs_is_atomic_file(inode) && !f2fs_is_commit_atomic_write(inode)) {\n\t\tif (!IS_ATOMIC_WRITTEN_PAGE(page)) {\n\t\t\tf2fs_register_inmem_page(inode, page);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (!PageDirty(page)) {\n\t\t__set_page_dirty_nobuffers(page);\n\t\tf2fs_update_dirty_page(inode, page);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 4423
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t rpmsg_eptdev_write_iter(struct kiocb *iocb,\n\t\t\t\t       struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tvoid *kbuf;\n\tint ret;\n\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(kbuf, len, from))\n\t\treturn -EFAULT;\n\n\tif (mutex_lock_interruptible(&eptdev->ept_lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free_kbuf;\n\t}\n\n\tif (!eptdev->ept) {\n\t\tret = -EPIPE;\n\t\tgoto unlock_eptdev;\n\t}\n\n\tif (filp->f_flags & O_NONBLOCK)\n\t\tret = rpmsg_trysend(eptdev->ept, kbuf, len);\n\telse\n\t\tret = rpmsg_send(eptdev->ept, kbuf, len);\n\nunlock_eptdev:\n\tmutex_unlock(&eptdev->ept_lock);\n\nfree_kbuf:\n\tkfree(kbuf);\n\treturn ret < 0 ? ret : len;\n}",
        "output": "1",
        "idx": 3264
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Jsi_RC jsi_ArrayShiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_Value *v;\n    Jsi_Obj *obj = _this->d.obj;\n    Jsi_ObjListifyArray(interp, obj);\n    uint n = Jsi_ObjGetLength(interp, obj);\n    assert(n <= obj->arrCnt);\n    if (n<=0) {\n        Jsi_ValueMakeUndef(interp, ret);\n    } else {\n        n--;\n        v = obj->arr[0];\n        memmove(obj->arr, obj->arr+1, n*sizeof(Jsi_Value*));\n        obj->arr[n] = NULL;\n        Jsi_ValueDup2(interp, ret, v);\n        Jsi_DecrRefCount(interp, v);\n        Jsi_ObjSetLength(interp, obj, n);\n    }\n    return JSI_OK;\n}",
        "output": "1",
        "idx": 8168
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\tgdImageWebpCtx(im, out, quality);\n\tout->gd_free(out);\n}",
        "output": "1",
        "idx": 4444
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_AV1Config *gf_isom_av1_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex - 1);\n\tif (!entry || !entry->av1_config) return NULL;\n\treturn AV1_DuplicateConfig(entry->av1_config->config);\n}",
        "output": "1",
        "idx": 6838
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *bpf_obj_do_get(const struct filename *pathname,\n\t\t\t    enum bpf_type *type)\n{\n\tstruct inode *inode;\n\tstruct path path;\n\tvoid *raw;\n\tint ret;\n\n\tret = kern_path(pathname->name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tinode = d_backing_inode(path.dentry);\n\tret = inode_permission(inode, MAY_WRITE);\n\tif (ret)\n\t\tgoto out;\n\n\tret = bpf_inode_type(inode, type);\n\tif (ret)\n\t\tgoto out;\n\n\traw = bpf_any_get(inode->i_private, *type);\n\tif (!IS_ERR(raw))\n\t\ttouch_atime(&path);\n\n\tpath_put(&path);\n\treturn raw;\nout:\n\tpath_put(&path);\n\treturn ERR_PTR(ret);\n}",
        "output": "0",
        "idx": 1833
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "crm_create_anon_tls_session(int csock, int type , void *credentials)\n{\n    gnutls_session *session = gnutls_malloc(sizeof(gnutls_session));\n\n    gnutls_init(session, type);\n#  ifdef HAVE_GNUTLS_PRIORITY_SET_DIRECT\n/*      http:\n    gnutls_priority_set_direct(*session, \"NORMAL:+ANON-DH\", NULL);\n#  else\n    gnutls_set_default_priority(*session);\n    gnutls_kx_set_priority(*session, anon_tls_kx_order);\n#  endif\n    gnutls_transport_set_ptr(*session, (gnutls_transport_ptr) GINT_TO_POINTER(csock));\n    switch (type) {\n    case GNUTLS_SERVER:\n        gnutls_credentials_set(*session, GNUTLS_CRD_ANON, (gnutls_anon_server_credentials_t) credentials);\n        break;\n    case GNUTLS_CLIENT:\n        gnutls_credentials_set(*session, GNUTLS_CRD_ANON, (gnutls_anon_client_credentials_t) credentials);\n        break;\n    }\n\n    return session;\n}",
        "output": "0",
        "idx": 5255
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BIO *cms_get_text_bio(BIO *out, unsigned int flags)\n\t{\n\tBIO *rbio;\n\tif (out == NULL)\n\t\trbio = BIO_new(BIO_s_null());\n\telse if (flags & CMS_TEXT)\n\t\t{\n\t\trbio = BIO_new(BIO_s_mem());\n\t\tBIO_set_mem_eof_return(rbio, 0);\n\t\t}\n\telse\n\t\trbio = out;\n\treturn rbio;\n\t}",
        "output": "0",
        "idx": 6343
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BITMAP_UPDATE* update_read_bitmap_update(rdpUpdate* update, wStream* s)\n{\n\tUINT32 i;\n\tBITMAP_UPDATE* bitmapUpdate = calloc(1, sizeof(BITMAP_UPDATE));\n\n\tif (!bitmapUpdate)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, bitmapUpdate->number); \n\tWLog_Print(update->log, WLOG_TRACE, \"BitmapUpdate: %\"PRIu32\"\", bitmapUpdate->number);\n\n\tif (bitmapUpdate->number > bitmapUpdate->count)\n\t{\n\t\tUINT16 count;\n\t\tBITMAP_DATA* newdata;\n\t\tcount = bitmapUpdate->number * 2;\n\t\tnewdata = (BITMAP_DATA*) realloc(bitmapUpdate->rectangles,\n\t\t                                 sizeof(BITMAP_DATA) * count);\n\n\t\tif (!newdata)\n\t\t\tgoto fail;\n\n\t\tbitmapUpdate->rectangles = newdata;\n\t\tZeroMemory(&bitmapUpdate->rectangles[bitmapUpdate->count],\n\t\t           sizeof(BITMAP_DATA) * (count - bitmapUpdate->count));\n\t\tbitmapUpdate->count = count;\n\t}\n\n\tfor (i = 0; i < bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_read_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\tgoto fail;\n\t}\n\n\treturn bitmapUpdate;\nfail:\n\tfree_bitmap_update(update->context, bitmapUpdate);\n\treturn NULL;\n}",
        "output": "1",
        "idx": 4210
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void record_recent_object(struct object *obj,\n\t\t\t\t const char *name,\n\t\t\t\t void *data)\n{\n\tsha1_array_append(&recent_objects, obj->oid.hash);\n}",
        "output": "0",
        "idx": 7219
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int atusb_get_and_show_build(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tchar *build;\n\tint ret;\n\n\tbuild = kmalloc(ATUSB_BUILD_SIZE + 1, GFP_KERNEL);\n\tif (!build)\n\t\treturn -ENOMEM;\n\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_BUILD, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuild, ATUSB_BUILD_SIZE, 1000);\n\tif (ret >= 0) {\n\t\tbuild[ret] = 0;\n\t\tdev_info(&usb_dev->dev, \"Firmware: build %s\\n\", build);\n\t}\n\n\tkfree(build);\n\treturn ret;\n}",
        "output": "0",
        "idx": 2079
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\n\tret = mount_entry_create_dir_file(mntent, path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,\n\t\t\t  mntflags, mntdata, optional);\n\n\tfree(mntdata);\n\n\treturn ret;\n}",
        "output": "1",
        "idx": 4364
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "string_object_to_c_ast(const char *s, PyObject *filename, int start,\n                             PyCompilerFlags *flags, int feature_version,\n                             PyArena *arena)\n{\n    mod_ty mod;\n    PyCompilerFlags localflags;\n    perrdetail err;\n    int iflags = PARSER_FLAGS(flags);\n\n    node *n = Ta3Parser_ParseStringObject(s, filename,\n                                         &_Ta3Parser_Grammar, start, &err,\n                                         &iflags);\n    if (flags == NULL) {\n        localflags.cf_flags = 0;\n        flags = &localflags;\n    }\n    if (n) {\n        flags->cf_flags |= iflags & PyCF_MASK;\n        mod = Ta3AST_FromNodeObject(n, flags, filename, feature_version, arena);\n        Ta3Node_Free(n);\n    }\n    else {\n        err_input(&err);\n        mod = NULL;\n    }\n    err_free(&err);\n    return mod;\n}",
        "output": "1",
        "idx": 7656
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void get_page(struct page *page)\n{\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(page_ref_count(page) <= 0, page);\n\tpage_ref_inc(page);\n}",
        "output": "1",
        "idx": 3144
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,\n\t\t\t   unsigned int keylen)\n{\n\treturn -ENOSYS;\n}",
        "output": "1",
        "idx": 1776
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_bus_configured(int bus)\n{\n\tassert(bus >= 0 && bus < MAXBUSES);\n\treturn (pci_businfo[bus] != NULL);\n}",
        "output": "1",
        "idx": 7588
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static enum AVPixelFormat h263_get_format(AVCodecContext *avctx)\n{\n    MpegEncContext *s = avctx->priv_data;\n    if (avctx->bits_per_raw_sample > 8) {\n        av_assert1(s->studio_profile);\n        return avctx->pix_fmt;\n    }\n\n    if (avctx->codec->id == AV_CODEC_ID_MSS2)\n        return AV_PIX_FMT_YUV420P;\n\n    if (CONFIG_GRAY && (avctx->flags & AV_CODEC_FLAG_GRAY)) {\n        if (avctx->color_range == AVCOL_RANGE_UNSPECIFIED)\n            avctx->color_range = AVCOL_RANGE_MPEG;\n        return AV_PIX_FMT_GRAY8;\n    }\n\n    return avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);\n}",
        "output": "0",
        "idx": 4763
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct bpf_prog *bpf_prog_get(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\n\tprog = __bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\n\tatomic_inc(&prog->aux->refcnt);\n\tfdput(f);\n\n\treturn prog;\n}",
        "output": "1",
        "idx": 1248
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cJSON_Delete(cJSON *c)\n{\n\tcJSON *next;\n\twhile (c)\n\t{\n\t\tnext=c->next;\n\t\tif (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);\n\t\tif (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);\n\t\tif (!(c->type&cJSON_StringIsConst) && c->string) cJSON_free(c->string);\n\t\tcJSON_free(c);\n\t\tc=next;\n\t}\n}",
        "output": "0",
        "idx": 8249
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int evm_update_evmxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\tconst char *xattr_value, size_t xattr_value_len)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct evm_ima_xattr_data xattr_data;\n\tint rc = 0;\n\n\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t   xattr_value_len, xattr_data.digest);\n\tif (rc == 0) {\n\t\txattr_data.type = EVM_XATTR_HMAC;\n\t\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,\n\t\t\t\t\t   &xattr_data,\n\t\t\t\t\t   sizeof(xattr_data), 0);\n\t} else if (rc == -ENODATA && inode->i_op->removexattr) {\n\t\trc = inode->i_op->removexattr(dentry, XATTR_NAME_EVM);\n\t}\n\treturn rc;\n}",
        "output": "0",
        "idx": 1123
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE from_document(VALUE klass, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlSchemaParserCtxtPtr ctx;\n  xmlSchemaPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n\n  Data_Get_Struct(document, xmlDoc, doc);\n\n  doc = doc->doc;\n\n  if (has_blank_nodes_p(DOC_NODE_CACHE(doc))) {\n    rb_raise(rb_eArgError, \"Creating a schema from a document that has blank nodes exposed to Ruby is dangerous\");\n  }\n\n  ctx = xmlSchemaNewDocParserCtxt(doc);\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n  xmlSchemaSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n\n  schema = xmlSchemaParse(ctx);\n\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlSchemaFreeParserCtxt(ctx);\n\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n\n  return rb_schema;\n\n  return Qnil;\n}",
        "output": "1",
        "idx": 8252
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void * calloc(size_t n, size_t lb)\n{\n    if (lb && n > SIZE_MAX / lb)\n      return NULL;\n#   if defined(GC_LINUX_THREADS) \n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}",
        "output": "0",
        "idx": 5061
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static LUA_FUNCTION(openssl_x509_check_host)\n{\n  X509 * cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (lua_isstring(L, 2))\n  {\n    const char *hostname = lua_tostring(L, 2);\n    lua_pushboolean(L, X509_check_host(cert, hostname, strlen(hostname), 0, NULL));\n  }\n  else\n  {\n    lua_pushboolean(L, 0);\n  }\n  return 1;\n}",
        "output": "1",
        "idx": 8424
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void jbd2_journal_wait_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twhile (1) {\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n}",
        "output": "0",
        "idx": 2901
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "snmp_ber_encode_type(unsigned char *out, uint32_t *out_len, uint8_t type)\n{\n  *out-- = type;\n  (*out_len)++;\n  return out;\n}",
        "output": "1",
        "idx": 7958
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MemoryRegion *memory_map_ptr(struct uc_struct *uc, hwaddr begin, size_t size, uint32_t perms, void *ptr)\n{\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    memory_region_init_ram_ptr(uc, ram, size, ptr);\n    ram->perms = perms;\n    if (ram->addr == -1) {\n        return NULL;\n    }\n\n    memory_region_add_subregion(uc->system_memory, begin, ram);\n\n    if (uc->cpu) {\n        tlb_flush(uc->cpu);\n    }\n\n    return ram;\n}",
        "output": "1",
        "idx": 8752
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cifs_find_smb_ses(struct TCP_Server_Info *server, struct smb_vol *vol)\n{\n\tstruct cifsSesInfo *ses;\n\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\n\t\tswitch (server->secType) {\n\t\tcase Kerberos:\n\t\t\tif (vol->linux_uid != ses->linux_uid)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (strncmp(ses->userName, vol->username,\n\t\t\t\t    MAX_USERNAME_SIZE))\n\t\t\t\tcontinue;\n\t\t\tif (strlen(vol->username) != 0 &&\n\t\t\t    strncmp(ses->password, vol->password,\n\t\t\t\t    MAX_PASSWORD_SIZE))\n\t\t\t\tcontinue;\n\t\t}\n\t\t++ses->ses_count;\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\treturn ses;\n\t}\n\twrite_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}",
        "output": "0",
        "idx": 329
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int bson_validate_string( bson *b, const unsigned char *string,\n                                 const int length, const char check_utf8, const char check_dot,\n                                 const char check_dollar ) {\n\n    int position = 0;\n    int sequence_length = 1;\n\n    if( check_dollar && string[0] == '$' ) {\n        if( !bson_string_is_db_ref( string, length ) )\n            b->err |= BSON_FIELD_INIT_DOLLAR;\n    }\n\n    while ( position < length ) {\n        if ( check_dot && *( string + position ) == '.' ) {\n            b->err |= BSON_FIELD_HAS_DOT;\n        }\n\n        if ( check_utf8 ) {\n            sequence_length = trailingBytesForUTF8[*( string + position )] + 1;\n            if ( ( position + sequence_length ) > length ) {\n                b->err |= BSON_NOT_UTF8;\n                return BSON_ERROR;\n            }\n            if ( !isLegalUTF8( string + position, sequence_length ) ) {\n                b->err |= BSON_NOT_UTF8;\n                return BSON_ERROR;\n            }\n        }\n        position += sequence_length;\n    }\n\n    return BSON_OK;\n}",
        "output": "1",
        "idx": 7894
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IW_IMPL(int) iw_get_input_density(struct iw_context *ctx,\n   double *px, double *py, int *pcode)\n{\n\t*px = 1.0;\n\t*py = 1.0;\n\t*pcode = ctx->img1.density_code;\n\tif(ctx->img1.density_code!=IW_DENSITY_UNKNOWN) {\n\t\t*px = ctx->img1.density_x;\n\t\t*py = ctx->img1.density_y;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 6664
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
        "output": "0",
        "idx": 3555
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_event_interrupt(struct pt_regs *regs)\n{\n\tint i;\n\tstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\n\tstruct perf_event *event;\n\tunsigned long val;\n\tint found = 0;\n\tint nmi;\n\n\tnmi = perf_intr_is_nmi(regs);\n\tif (nmi)\n\t\tnmi_enter();\n\telse\n\t\tirq_enter();\n\n\tfor (i = 0; i < ppmu->n_counter; ++i) {\n\t\tevent = cpuhw->event[i];\n\n\t\tval = read_pmc(i);\n\t\tif ((int)val < 0) {\n\t\t\tif (event) {\n\t\t\t\tfound = 1;\n\t\t\t\trecord_and_restart(event, val, regs);\n\t\t\t} else {\n\t\t\t\twrite_pmc(i, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tmtmsr(mfmsr() | MSR_PMM);\n\tmtpmr(PMRN_PMGC0, PMGC0_PMIE | PMGC0_FCECE);\n\tisync();\n\n\tif (nmi)\n\t\tnmi_exit();\n\telse\n\t\tirq_exit();\n}",
        "output": "0",
        "idx": 605
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int check_line_charstring(void)\n{\n  char *p = line;\n  while (isspace((unsigned char) *p))\n    p++;\n  return (*p == '/' || (p[0] == 'd' && p[1] == 'u' && p[2] == 'p'));\n}",
        "output": "0",
        "idx": 7403
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rpcomp;\n\n\tstrncpy(rpcomp.type, \"pcomp\", sizeof(rpcomp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rpcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "0",
        "idx": 1187
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void copyIPv6IfDifferent(void * dest, const void * src)\n{\n\tif(dest != src && src != NULL) {\n\t\tmemcpy(dest, src, sizeof(struct in6_addr));\n\t}\n}",
        "output": "0",
        "idx": 6415
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ast_for_arg(struct compiling *c, const node *n)\n{\n    identifier name;\n    expr_ty annotation = NULL;\n    node *ch;\n    arg_ty ret;\n\n    assert(TYPE(n) == tfpdef || TYPE(n) == vfpdef);\n    ch = CHILD(n, 0);\n    name = NEW_IDENTIFIER(ch);\n    if (!name)\n        return NULL;\n    if (forbidden_name(c, name, ch, 0))\n        return NULL;\n\n    if (NCH(n) == 3 && TYPE(CHILD(n, 1)) == COLON) {\n        annotation = ast_for_expr(c, CHILD(n, 2));\n        if (!annotation)\n            return NULL;\n    }\n\n    ret = arg(name, annotation, LINENO(n), n->n_col_offset,\n              n->n_end_lineno, n->n_end_col_offset, c->c_arena);\n    if (!ret)\n        return NULL;\n    return ret;\n}",
        "output": "1",
        "idx": 7218
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC cchar *httpGetParam(HttpConn *conn, cchar *var, cchar *defaultValue)\n{\n    cchar       *value;\n\n    value = mprLookupJson(httpGetParams(conn), var);\n    return (value) ? value : defaultValue;\n}",
        "output": "1",
        "idx": 5046
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "do_pax_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap, uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags)\n{\n\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"PaX\") == 0 &&\n\t    type == NT_NETBSD_PAX && descsz == 4) {\n\t\tstatic const char *pax[] = {\n\t\t    \"+mprotect\",\n\t\t    \"-mprotect\",\n\t\t    \"+segvguard\",\n\t\t    \"-segvguard\",\n\t\t    \"+ASLR\",\n\t\t    \"-ASLR\",\n\t\t};\n\t\tuint32_t desc;\n\t\tsize_t i;\n\t\tint did = 0;\n\n\t\t*flags |= FLAGS_DID_NETBSD_PAX;\n\t\t(void)memcpy(&desc, &nbuf[doff], sizeof(desc));\n\t\tdesc = elf_getu32(swap, desc);\n\n\t\tif (desc && file_printf(ms, \", PaX: \") == -1)\n\t\t\treturn 1;\n\n\t\tfor (i = 0; i < __arraycount(pax); i++) {\n\t\t\tif (((1 << i) & desc) == 0)\n\t\t\t\tcontinue;\n\t\t\tif (file_printf(ms, \"%s%s\", did++ ? \",\" : \"\",\n\t\t\t    pax[i]) == -1)\n\t\t\t\treturn 1;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 6135
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct btrfs_device *btrfs_find_device_by_devspec(\n\t\tstruct btrfs_fs_info *fs_info, u64 devid,\n\t\tconst char *device_path)\n{\n\tstruct btrfs_device *device;\n\n\tif (devid) {\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, NULL,\n\t\t\t\t\t   NULL);\n\t\tif (!device)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\treturn device;\n\t}\n\n\tif (!device_path || !device_path[0])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (strcmp(device_path, \"missing\") == 0) {\n\t\tlist_for_each_entry(device, &fs_info->fs_devices->devices,\n\t\t\t\t    dev_list) {\n\t\t\tif (test_bit(BTRFS_DEV_STATE_IN_FS_METADATA,\n\t\t\t\t     &device->dev_state) && !device->bdev)\n\t\t\t\treturn device;\n\t\t}\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\treturn btrfs_find_device_by_path(fs_info, device_path);\n}",
        "output": "1",
        "idx": 3110
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct crypto_template *crypto_lookup_template(const char *name)\n{\n\treturn try_then_request_module(__crypto_lookup_template(name), \"%s\",\n\t\t\t\t       name);\n}",
        "output": "1",
        "idx": 2728
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct scatterlist *alloc_sgtable(int size)\n{\n\tint alloc_size, nents, i;\n\tstruct page *new_page;\n\tstruct scatterlist *iter;\n\tstruct scatterlist *table;\n\n\tnents = DIV_ROUND_UP(size, PAGE_SIZE);\n\ttable = kcalloc(nents, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn NULL;\n\tsg_init_table(table, nents);\n\titer = table;\n\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\tnew_page = alloc_page(GFP_KERNEL);\n\t\tif (!new_page) {\n\t\t\titer = table;\n\t\t\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\t\t\tnew_page = sg_page(iter);\n\t\t\t\tif (new_page)\n\t\t\t\t\t__free_page(new_page);\n\t\t\t}\n\t\t\tkfree(table);\n\t\t\treturn NULL;\n\t\t}\n\t\talloc_size = min_t(int, size, PAGE_SIZE);\n\t\tsize -= PAGE_SIZE;\n\t\tsg_set_page(iter, new_page, alloc_size, 0);\n\t}\n\treturn table;\n}",
        "output": "0",
        "idx": 4543
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ipv6_dup_options(struct sock *sk, struct ipv6_txoptions *opt)\n{\n\tstruct ipv6_txoptions *opt2;\n\n\topt2 = sock_kmalloc(sk, opt->tot_len, GFP_ATOMIC);\n\tif (opt2) {\n\t\tlong dif = (char *)opt2 - (char *)opt;\n\t\tmemcpy(opt2, opt, opt->tot_len);\n\t\tif (opt2->hopopt)\n\t\t\t*((char **)&opt2->hopopt) += dif;\n\t\tif (opt2->dst0opt)\n\t\t\t*((char **)&opt2->dst0opt) += dif;\n\t\tif (opt2->dst1opt)\n\t\t\t*((char **)&opt2->dst1opt) += dif;\n\t\tif (opt2->srcrt)\n\t\t\t*((char **)&opt2->srcrt) += dif;\n\t\tatomic_set(&opt2->refcnt, 1);\n\t}\n\treturn opt2;\n}",
        "output": "0",
        "idx": 1403
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int inet_getid(struct inet_peer *p, int more)\n{\n\tint old, new;\n\tmore++;\n\tinet_peer_refcheck(p);\n\tdo {\n\t\told = atomic_read(&p->ip_id_count);\n\t\tnew = old + more;\n\t\tif (!new)\n\t\t\tnew = 1;\n\t} while (atomic_cmpxchg(&p->ip_id_count, old, new) != old);\n\treturn new;\n}",
        "output": "0",
        "idx": 719
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static pyc_object *get_array_object_generic(RBuffer *buffer, ut32 size) {\n\tpyc_object *tmp = NULL;\n\tpyc_object *ret = NULL;\n\tut32 i = 0;\n\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->data = r_list_newf ((RListFree)free_object);\n\tif (!ret->data) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < size; i++) {\n\t\ttmp = get_object (buffer);\n\t\tif (!tmp) {\n\t\t\tr_list_free (ret->data);\n\t\t\tR_FREE (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!r_list_append (ret->data, tmp)) {\n\t\t\tfree_object (tmp);\n\t\t\tr_list_free (ret->data);\n\t\t\tfree (ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn ret;\n}",
        "output": "1",
        "idx": 6448
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "QTN2QT(QTNode *in)\n{\n\tTSQuery\t\tout;\n\tint\t\t\tlen;\n\tint\t\t\tsumlen = 0,\n\t\t\t\tnnode = 0;\n\tQTN2QTState state;\n\n\tcntsize(in, &sumlen, &nnode);\n\n\tif (TSQUERY_TOO_BIG(nnode, sumlen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\")));\n\tlen = COMPUTESIZE(nnode, sumlen);\n\n\tout = (TSQuery) palloc0(len);\n\tSET_VARSIZE(out, len);\n\tout->size = nnode;\n\n\tstate.curitem = GETQUERY(out);\n\tstate.operand = state.curoperand = GETOPERAND(out);\n\n\tfillQT(&state, in);\n\treturn out;\n}",
        "output": "0",
        "idx": 6299
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void control_work_handler(struct work_struct *work)\n{\n\tstruct ports_device *portdev;\n\tstruct virtqueue *vq;\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\n\tportdev = container_of(work, struct ports_device, control_work);\n\tvq = portdev->c_ivq;\n\n\tspin_lock(&portdev->c_ivq_lock);\n\twhile ((buf = virtqueue_get_buf(vq, &len))) {\n\t\tspin_unlock(&portdev->c_ivq_lock);\n\n\t\tbuf->len = len;\n\t\tbuf->offset = 0;\n\n\t\thandle_control_message(vq->vdev, portdev, buf);\n\n\t\tspin_lock(&portdev->c_ivq_lock);\n\t\tif (add_inbuf(portdev->c_ivq, buf) < 0) {\n\t\t\tdev_warn(&portdev->vdev->dev,\n\t\t\t\t \"Error adding buffer to queue\\n\");\n\t\t\tfree_buf(buf, false);\n\t\t}\n\t}\n\tspin_unlock(&portdev->c_ivq_lock);\n}",
        "output": "1",
        "idx": 1958
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int X509_verify(X509 *a, EVP_PKEY *r)\n\t{\n\tif (X509_ALGOR_cmp(a->sig_alg, a->cert_info->signature))\n\t\treturn 0;\n\treturn(ASN1_item_verify(ASN1_ITEM_rptr(X509_CINF),a->sig_alg,\n\t\ta->signature,a->cert_info,r));\n\t}",
        "output": "0",
        "idx": 6361
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "table_regex_match(const char *string, const char *pattern)\n{\n\tregex_t preg;\n\tint\tcflags = REG_EXTENDED|REG_NOSUB;\n\tint ret;\n\n\tif (strncmp(pattern, \"(?i)\", 4) == 0) {\n\t\tcflags |= REG_ICASE;\n\t\tpattern += 4;\n\t}\n\n\tif (regcomp(&preg, pattern, cflags) != 0)\n\t\treturn (0);\n\n\tret = regexec(&preg, string, 0, NULL, 0);\n\n\tregfree(&preg);\n\n\tif (ret != 0)\n\t\treturn (0);\n\n\treturn (1);\n}",
        "output": "0",
        "idx": 7819
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_text_locked(oparg_T *oap)\n{\n    if (text_locked())\n    {\n\tclearopbeep(oap);\n\ttext_locked_msg();\n\treturn TRUE;\n    }\n    return FALSE;\n}",
        "output": "0",
        "idx": 8045
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "zend_object_iterator *spl_filesystem_dir_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator;\n\tspl_filesystem_object   *dir_object;\n\n\tif (by_ref) {\n\t\tzend_error(E_ERROR, \"An iterator cannot be used with foreach by reference\");\n\t}\n\tdir_object = (spl_filesystem_object*)zend_object_store_get_object(object TSRMLS_CC);\n\titerator   = spl_filesystem_object_to_iterator(dir_object);\n\n\tif (iterator->intern.data == NULL) {\n\t\titerator->intern.data = object;\n\t\titerator->intern.funcs = &spl_filesystem_dir_it_funcs;\n\t\titerator->current = object;\n\t}\n\tzval_add_ref(&object);\n\n\treturn (zend_object_iterator*)iterator;\n}",
        "output": "0",
        "idx": 5487
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int devmem_is_allowed(unsigned long pagenr)\n{\n\tif (pagenr < 256)\n\t\treturn 1;\n\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT))\n\t\treturn 0;\n\tif (!page_is_ram(pagenr))\n\t\treturn 1;\n\treturn 0;\n}",
        "output": "1",
        "idx": 1550
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static RFlagsAtOffset* r_flag_get_nearest_list(RFlag *f, ut64 off, int dir) {\n\tRFlagsAtOffset *flags = NULL;\n\tRFlagsAtOffset key;\n\tkey.off = off;\n\tif (dir >= 0) {\n\t\tflags = r_skiplist_get_geq (f->by_off, &key);\n\t} else {\n\t\tflags = r_skiplist_get_leq (f->by_off, &key);\n\t}\n\tif (dir == 0 && flags && flags->off != off) {\n\t\treturn NULL;\n\t}\n\treturn flags;\n}",
        "output": "0",
        "idx": 8667
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "win_alloc_lines(win_T *wp)\n{\n    wp->w_lines_valid = 0;\n    wp->w_lines = ALLOC_CLEAR_MULT(wline_T, Rows );\n    if (wp->w_lines == NULL)\n\treturn FAIL;\n    return OK;\n}",
        "output": "1",
        "idx": 5720
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hash_recvmsg(struct kiocb *unused, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tunsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));\n\tint err;\n\n\tif (len > ds)\n\t\tlen = ds;\n\telse if (len < ds)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\n\tmsg->msg_namelen = 0;\n\n\tlock_sock(sk);\n\tif (ctx->more) {\n\t\tctx->more = 0;\n\t\tahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);\n\t\terr = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),\n\t\t\t\t\t\t &ctx->completion);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\terr = memcpy_toiovec(msg->msg_iov, ctx->result, len);\n\nunlock:\n\trelease_sock(sk);\n\n\treturn err ?: len;\n}",
        "output": "0",
        "idx": 1305
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long video_ioctl2(struct file *file,\n\t       unsigned int cmd, unsigned long arg)\n{\n\treturn video_usercopy(file, cmd, arg, __video_do_ioctl);\n}",
        "output": "0",
        "idx": 387
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "handle_mlppp(netdissect_options *ndo,\n             const u_char *p, int length)\n{\n    if (!ndo->ndo_eflag)\n        ND_PRINT((ndo, \"MLPPP, \"));\n\n    if (length < 2) {\n        ND_PRINT((ndo, \"[|mlppp]\"));\n        return;\n    }\n    if (!ND_TTEST_16BITS(p)) {\n        ND_PRINT((ndo, \"[|mlppp]\"));\n        return;\n    }\n\n    ND_PRINT((ndo, \"seq 0x%03x, Flags [%s], length %u\",\n           (EXTRACT_16BITS(p))&0x0fff, \n           bittok2str(ppp_ml_flag_values, \"none\", *p & 0xc0),\n           length));\n}",
        "output": "0",
        "idx": 6763
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int hns_ppe_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ETH_PPE_STATIC_NUM;\n\treturn 0;\n}",
        "output": "1",
        "idx": 1568
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool_t xdr_nullstring(XDR *xdrs, char **objp)\n{\n     u_int size;\n\n     if (xdrs->x_op == XDR_ENCODE) {\n\t  if (*objp == NULL)\n\t       size = 0;\n\t  else\n\t       size = strlen(*objp) + 1;\n     }\n     if (! xdr_u_int(xdrs, &size)) {\n\t  return FALSE;\n\t}\n     switch (xdrs->x_op) {\n     case XDR_DECODE:\n\t  if (size == 0) {\n\t       *objp = NULL;\n\t       return TRUE;\n\t  } else if (*objp == NULL) {\n\t       *objp = (char *) mem_alloc(size);\n\t       if (*objp == NULL) {\n\t\t    errno = ENOMEM;\n\t\t    return FALSE;\n\t       }\n\t  }\n\t  return (xdr_opaque(xdrs, *objp, size));\n\n     case XDR_ENCODE:\n\t  if (size != 0)\n\t       return (xdr_opaque(xdrs, *objp, size));\n\t  return TRUE;\n\n     case XDR_FREE:\n\t  if (*objp != NULL)\n\t       mem_free(*objp, size);\n\t  *objp = NULL;\n\t  return TRUE;\n     }\n\n     return FALSE;\n}",
        "output": "1",
        "idx": 124
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __intel_pmu_pebs_event(struct perf_event *event,\n\t\t\t\t   struct pt_regs *iregs, void *__pebs)\n{\n\tstruct pebs_record_core *pebs = __pebs;\n\tstruct perf_sample_data data;\n\tstruct pt_regs regs;\n\n\tif (!intel_pmu_save_and_restart(event))\n\t\treturn;\n\n\tperf_sample_data_init(&data, 0);\n\tdata.period = event->hw.last_period;\n\n\tregs = *iregs;\n\tregs.ip = pebs->ip;\n\tregs.bp = pebs->bp;\n\tregs.sp = pebs->sp;\n\n\tif (event->attr.precise_ip > 1 && intel_pmu_pebs_fixup_ip(&regs))\n\t\tregs.flags |= PERF_EFLAGS_EXACT;\n\telse\n\t\tregs.flags &= ~PERF_EFLAGS_EXACT;\n\n\tif (perf_event_overflow(event, &data, &regs))\n\t\tx86_pmu_stop(event, 0);\n}",
        "output": "0",
        "idx": 659
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void _modinit(module_t *m)\n{\n\tservice_named_bind_command(\"chanserv\", &cs_flags);\n\n\tadd_bool_conf_item(\"ANOPE_FLAGS_COMPAT\", &chansvs.me->conf_table, 0, &anope_flags_compat, true);\n\n\thook_add_event(\"nick_can_register\");\n\thook_add_nick_can_register(check_registration_keywords);\n\n\thook_add_event(\"user_can_register\");\n\thook_add_user_can_register(check_registration_keywords);\n}",
        "output": "0",
        "idx": 7133
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tssize_t n;\n\tassert(cnt >= 0);\n\tassert(buf);\n\n\tJAS_DBGLOG(100, (\"mem_read(%p, %p, %d)\\n\", obj, buf, cnt));\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tn = m->len_ - m->pos_;\n\tcnt = JAS_MIN(n, cnt);\n\tmemcpy(buf, &m->buf_[m->pos_], cnt);\n\tm->pos_ += cnt;\n\treturn cnt;\n}",
        "output": "0",
        "idx": 7539
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int msr_open(struct inode *inode, struct file *file)\n{\n\tunsigned int cpu;\n\tstruct cpuinfo_x86 *c;\n\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\n\tcpu = iminor(file->f_path.dentry->d_inode);\n\tif (cpu >= nr_cpu_ids || !cpu_online(cpu))\n\t\treturn -ENXIO;\t\n\n\tc = &cpu_data(cpu);\n\tif (!cpu_has(c, X86_FEATURE_MSR))\n\t\treturn -EIO;\t\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1141
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_orig_addr(struct msghdr *m, struct tipc_msg *msg)\n{\n\tstruct sockaddr_tipc *addr = (struct sockaddr_tipc *)m->msg_name;\n\n\tif (addr) {\n\t\taddr->family = AF_TIPC;\n\t\taddr->addrtype = TIPC_ADDR_ID;\n\t\tmemset(&addr->addr, 0, sizeof(addr->addr));\n\t\taddr->addr.id.ref = msg_origport(msg);\n\t\taddr->addr.id.node = msg_orignode(msg);\n\t\taddr->addr.name.domain = 0;\t\n\t\taddr->scope = 0;\t\t\n\t\tm->msg_namelen = sizeof(struct sockaddr_tipc);\n\t}\n}",
        "output": "0",
        "idx": 1297
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iperf_json_printf(const char *format, ...)\n{\n    cJSON* o;\n    va_list argp;\n    const char *cp;\n    char name[100];\n    char* np;\n    cJSON* j;\n\n    o = cJSON_CreateObject();\n    if (o == NULL)\n        return NULL;\n    va_start(argp, format);\n    np = name;\n    for (cp = format; *cp != '\\0'; ++cp) {\n\tswitch (*cp) {\n\t    case ' ':\n\t    break;\n\t    case ':':\n\t    *np = '\\0';\n\t    break;\n\t    case '%':\n\t    ++cp;\n\t    switch (*cp) {\n\t\tcase 'b':\n\t\tj = cJSON_CreateBool(va_arg(argp, int));\n\t\tbreak;\n\t\tcase 'd':\n\t\tj = cJSON_CreateNumber(va_arg(argp, int64_t));\n\t\tbreak;\n\t\tcase 'f':\n\t\tj = cJSON_CreateNumber(va_arg(argp, double));\n\t\tbreak;\n\t\tcase 's':\n\t\tj = cJSON_CreateString(va_arg(argp, char *));\n\t\tbreak;\n\t\tdefault:\n\t\treturn NULL;\n\t    }\n\t    if (j == NULL)\n\t\treturn NULL;\n\t    cJSON_AddItemToObject(o, name, j);\n\t    np = name;\n\t    break;\n\t    default:\n\t    *np++ = *cp;\n\t    break;\n\t}\n    }\n    va_end(argp);\n    return o;\n}",
        "output": "0",
        "idx": 8359
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int is_self_cloned(void)\n{\n\tint fd, ret, is_cloned = 0;\n\n\tfd = open(\"/proc/self/exe\", O_RDONLY|O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn -ENOTRECOVERABLE;\n\n#ifdef HAVE_MEMFD_CREATE\n\tret = fcntl(fd, F_GET_SEALS);\n\tis_cloned = (ret == RUNC_MEMFD_SEALS);\n#else\n\tstruct stat statbuf = {0};\n\tret = fstat(fd, &statbuf);\n\tif (ret >= 0)\n\t\tis_cloned = (statbuf.st_nlink == 0);\n#endif\n\tclose(fd);\n\treturn is_cloned;\n}",
        "output": "0",
        "idx": 8209
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sample_to_timespec(const clockid_t which_clock,\n\t\t\t       union cpu_time_count cpu,\n\t\t\t       struct timespec *tp)\n{\n\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\ttp->tv_sec = div_long_long_rem(cpu.sched,\n\t\t\t\t\t       NSEC_PER_SEC, &tp->tv_nsec);\n\t} else {\n\t\tcputime_to_timespec(cpu.cpu, tp);\n\t}\n}",
        "output": "1",
        "idx": 2098
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs4_close_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tstruct nfs_server *server = NFS_SERVER(calldata->inode);\n\n\tif (RPC_ASSASSINATED(task))\n\t\treturn;\n\tswitch (task->tk_status) {\n\t\tcase 0:\n\t\t\tnfs_set_open_stateid(state, &calldata->res.stateid, 0);\n\t\t\trenew_lease(server, calldata->timestamp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tif (calldata->arg.fmode == 0)\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (nfs4_async_handle_error(task, server, state) == -EAGAIN) {\n\t\t\t\trpc_restart_call(task);\n\t\t\t\treturn;\n\t\t\t}\n\t}\n\tnfs_refresh_inode(calldata->inode, calldata->res.fattr);\n}",
        "output": "0",
        "idx": 3053
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned paravirt_patch_jmp(void *insnbuf, const void *target,\n\t\t\t    unsigned long addr, unsigned len)\n{\n\tstruct branch *b = insnbuf;\n\tunsigned long delta = (unsigned long)target - (addr+5);\n\n\tif (len < 5)\n\t\treturn len;\t\n\n\tb->opcode = 0xe9;\t\n\tb->delta = delta;\n\n\treturn 5;\n}",
        "output": "1",
        "idx": 3004
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int store_icy(URLContext *h, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int remaining = s->icy_metaint - s->icy_data_read;\n\n    if (remaining < 0)\n        return AVERROR_INVALIDDATA;\n\n    if (!remaining) {\n        uint8_t ch;\n        int len = http_read_stream_all(h, &ch, 1);\n        if (len < 0)\n            return len;\n        if (ch > 0) {\n            char data[255 * 16 + 1];\n            int ret;\n            len = ch * 16;\n            ret = http_read_stream_all(h, data, len);\n            if (ret < 0)\n                return ret;\n            data[len + 1] = 0;\n            if ((ret = av_opt_set(s, \"icy_metadata_packet\", data, 0)) < 0)\n                return ret;\n            update_metadata(s, data);\n        }\n        s->icy_data_read = 0;\n        remaining        = s->icy_metaint;\n    }\n\n    return FFMIN(size, remaining);\n}",
        "output": "1",
        "idx": 3452
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init ip6_tunnel_init(void)\n{\n\tint  err;\n\n\tif (xfrm6_tunnel_register(&ip4ip6_handler, AF_INET)) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip4ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (xfrm6_tunnel_register(&ip6ip6_handler, AF_INET6)) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip6ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto unreg_ip4ip6;\n\t}\n\n\terr = register_pernet_device(&ip6_tnl_net_ops);\n\tif (err < 0)\n\t\tgoto err_pernet;\n\treturn 0;\nerr_pernet:\n\txfrm6_tunnel_deregister(&ip6ip6_handler, AF_INET6);\nunreg_ip4ip6:\n\txfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET);\nout:\n\treturn err;\n}",
        "output": "1",
        "idx": 2206
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "build_unc_path_to_root(const struct smb_vol *vol,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(full_path, vol->UNC, unc_len);\n\tpos = full_path + unc_len;\n\n\tif (pplen) {\n\t\t*pos = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos + 1, vol->prepath, pplen);\n\t\tpos += pplen;\n\t}\n\n\t*pos = '\\0'; \n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}",
        "output": "0",
        "idx": 3243
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sraSpanRemove(sraSpan *span) {\n  if(span) {\n    span->_prev->_next = span->_next;\n    span->_next->_prev = span->_prev;\n  }\n}",
        "output": "0",
        "idx": 8935
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SWTPM_NVRAM_CheckHeader(unsigned char *data, uint32_t length,\n                        uint32_t *dataoffset, uint16_t *hdrflags,\n                        uint8_t *hdrversion, bool quiet)\n{\n    blobheader *bh = (blobheader *)data;\n\n    if (length < sizeof(bh)) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"not enough bytes for header: %u\\n\", length);\n        return TPM_BAD_PARAMETER;\n    }\n\n    if (ntohl(bh->totlen) != length) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"broken header: bh->totlen %u != %u\\n\",\n                      htonl(bh->totlen), length);\n        return TPM_BAD_PARAMETER;\n    }\n\n    if (bh->min_version > BLOB_HEADER_VERSION) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"Minimum required version for the blob is %d, we \"\n                      \"only support version %d\\n\", bh->min_version,\n                      BLOB_HEADER_VERSION);\n        return TPM_BAD_VERSION;\n    }\n\n    *hdrversion = bh->version;\n    *dataoffset = ntohs(bh->hdrsize);\n    *hdrflags = ntohs(bh->flags);\n\n    return TPM_SUCCESS;\n}",
        "output": "1",
        "idx": 8902
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tif (_gdImageWebpCtx(im, out, quality)) {\n        rv = NULL;\n    } else {\n        rv = gdDPExtractData(out, size);\n    }\n\tout->gd_free(out);\n\treturn rv;\n}",
        "output": "0",
        "idx": 6195
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\tif (vapic_addr)\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\telse\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n}",
        "output": "1",
        "idx": 2480
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static RList* entries(RBinFile* bf) {\n\tRList* ret = NULL;\n\tRBinAddr* addr = NULL;\n\tpsxexe_header psxheader;\n\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\n\tif (!(addr = R_NEW0 (RBinAddr))) {\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\n\tif (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, \"8c17i\", 1) < sizeof (psxexe_header)) {\n\t\teprintf (\"PSXEXE Header truncated\\n\");\n\t\tr_list_free (ret);\n\t\tfree (addr);\n\t\treturn NULL;\n\t}\n\n\taddr->paddr = (psxheader.pc0 - psxheader.t_addr) + PSXEXE_TEXTSECTION_OFFSET;\n\taddr->vaddr = psxheader.pc0;\n\n\tr_list_append (ret, addr);\n\treturn ret;\n}",
        "output": "1",
        "idx": 6480
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "monitor_init(void)\n{\n\tstruct ssh *ssh = active_state;\t\t\t\n\tstruct monitor *mon;\n\n\tmon = xcalloc(1, sizeof(*mon));\n\n\tmonitor_openfds(mon, 1);\n\n\tif (options.compression) {\n\t\tmon->m_zback = mm_create(NULL, MM_MEMSIZE);\n\t\tmon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);\n\n\t\tssh_packet_set_compress_hooks(ssh, mon->m_zlib,\n\t\t    (ssh_packet_comp_alloc_func *)mm_zalloc,\n\t\t    (ssh_packet_comp_free_func *)mm_zfree);\n\t}\n\n\treturn mon;\n}",
        "output": "1",
        "idx": 5564
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool has_locked_children(struct mount *mnt, struct dentry *dentry)\n{\n\tstruct mount *child;\n\n\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\tif (!is_subdir(child->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\n\t\tif (child->mnt.mnt_flags & MNT_LOCKED)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
        "output": "0",
        "idx": 2835
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mbochs_remove(struct mdev_device *mdev)\n{\n\tstruct mdev_state *mdev_state = dev_get_drvdata(&mdev->dev);\n\n\tvfio_unregister_group_dev(&mdev_state->vdev);\n\tatomic_add(mdev_state->type->mbytes, &mbochs_avail_mbytes);\n\tkfree(mdev_state->pages);\n\tkfree(mdev_state->vconfig);\n\tkfree(mdev_state);\n}",
        "output": "0",
        "idx": 2845
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_types) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (layout_type >= LAYOUT_TYPE_MAX ||\n\t    !(exp->ex_layout_types & (1 << layout_type))) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\n\treturn nfsd4_layout_ops[layout_type];\n}",
        "output": "0",
        "idx": 2283
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parse_range(char *str, size_t file_sz, int *nranges)\n{\n\tstatic struct range\t ranges[MAX_RANGES];\n\tint\t\t\t i = 0;\n\tchar\t\t\t*p, *q;\n\n\tif ((p = strchr(str, '=')) == NULL)\n\t\treturn (NULL);\n\n\t*p++ = '\\0';\n\tif (strcmp(str, \"bytes\") != 0)\n\t\treturn (NULL);\n\n\twhile ((q = strchr(p, ',')) != NULL) {\n\t\t*q++ = '\\0';\n\n\t\tif (parse_range_spec(p, file_sz, &ranges[i]) == 0)\n\t\t\tcontinue;\n\n\t\ti++;\n\t\tif (i == MAX_RANGES)\n\t\t\treturn (NULL);\n\n\t\tp = q;\n\t}\n\n\tif (parse_range_spec(p, file_sz, &ranges[i]) != 0)\n\t\ti++;\n\n\t*nranges = i;\n\treturn (i ? ranges : NULL);\n}",
        "output": "1",
        "idx": 5608
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "poly_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tPOLYGON    *poly;\n\tint\t\t\tnpts;\n\tint\t\t\tsize;\n\tint\t\t\tisopen;\n\tchar\t   *s;\n\n\tif ((npts = pair_count(str, ',')) <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t  errmsg(\"invalid input syntax for type polygon: \\\"%s\\\"\", str)));\n\n\tsize = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * npts;\n\tpoly = (POLYGON *) palloc0(size);\t\n\n\tSET_VARSIZE(poly, size);\n\tpoly->npts = npts;\n\n\tif ((!path_decode(FALSE, npts, str, &isopen, &s, &(poly->p[0])))\n\t\t|| (*s != '\\0'))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t  errmsg(\"invalid input syntax for type polygon: \\\"%s\\\"\", str)));\n\n\tmake_bound_box(poly);\n\n\tPG_RETURN_POLYGON_P(poly);\n}",
        "output": "1",
        "idx": 4492
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE cState_object_nl_set(VALUE self, VALUE object_nl)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(object_nl, T_STRING);\n    len = RSTRING_LEN(object_nl);\n    if (len == 0) {\n        if (state->object_nl) {\n            ruby_xfree(state->object_nl);\n            state->object_nl = NULL;\n        }\n    } else {\n        if (state->object_nl) ruby_xfree(state->object_nl);\n        state->object_nl = strdup(RSTRING_PTR(object_nl));\n        state->object_nl_len = len;\n    }\n    return Qnil;\n}",
        "output": "1",
        "idx": 6278
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void pdf_load_pages_kids(FILE *fp, pdf_t *pdf)\n{\n    int     i, id, dummy;\n    char   *buf, *c;\n    long    start, sz;\n\n    start = ftell(fp);\n\n    for (i=0; i<pdf->n_xrefs; i++)\n    {\n        if (pdf->xrefs[i].version && (pdf->xrefs[i].end != 0))\n        {\n            fseek(fp, pdf->xrefs[i].start, SEEK_SET);\n            while (SAFE_F(fp, (fgetc(fp) != 't')))\n                ; \n\n            sz = pdf->xrefs[i].end - ftell(fp);\n            buf = malloc(sz + 1);\n            SAFE_E(fread(buf, 1, sz, fp), sz, \"Failed to load /Root.\\n\");\n            buf[sz] = '\\0';\n            if (!(c = strstr(buf, \"/Root\")))\n            {\n                free(buf);\n                continue;\n            }\n\n            id = atoi(c + strlen(\"/Root\") + 1);\n            free(buf);\n            buf = get_object(fp, id, &pdf->xrefs[i], NULL, &dummy);\n            if (!buf || !(c = strstr(buf, \"/Pages\")))\n            {\n                free(buf);\n                continue;\n            }\n\n            id = atoi(c + strlen(\"/Pages\") + 1);\n            load_kids(fp, id, &pdf->xrefs[i]);\n            free(buf); \n        }\n    }\n            \n    fseek(fp, start, SEEK_SET);\n}",
        "output": "1",
        "idx": 7476
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC cchar *mprGetJson(MprJson *obj, cchar *key)\n{\n    MprJson      *result;\n\n    if (key && !strpbrk(key, \".[]*\")) {\n        return mprReadJson(obj, key);\n    }\n    if ((result = mprQueryJson(obj, key, 0, 0)) != 0) {\n        if (result->length == 1 && result->children->type & MPR_JSON_VALUE) {\n            return result->children->value;\n        } else if (result->length > 1) {\n            return mprJsonToString(result, 0);\n        }\n    }\n    return 0;\n}",
        "output": "0",
        "idx": 7091
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_event_for_each(struct perf_event *event,\n\t\t\t\t  void (*func)(struct perf_event *))\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct perf_event *sibling;\n\n\tlockdep_assert_held(&ctx->mutex);\n\n\tevent = event->group_leader;\n\n\tperf_event_for_each_child(event, func);\n\tlist_for_each_entry(sibling, &event->sibling_list, group_entry)\n\t\tperf_event_for_each_child(sibling, func);\n}",
        "output": "0",
        "idx": 3823
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Bool rfbOptPamAuth(void)\n{\n  SecTypeData *s;\n\n  for (s = secTypes; s->name != NULL; s++) {\n    if ((!strcmp(s->name, \"unixlogin\") ||\n         !strcmp(&s->name[strlen(s->name) - 5], \"plain\")) && s->enabled)\n      return TRUE;\n  }\n\n  return FALSE;\n}",
        "output": "1",
        "idx": 7514
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static EjsObj *http_info(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)\n{\n    EjsObj  *obj;\n    char    *key, *next, *value;\n\n    if (hp->conn && hp->conn->sock) {\n        obj = ejsCreateEmptyPot(ejs);\n        for (key = stok(mprGetSocketState(hp->conn->sock), \",\", &next); key; key = stok(NULL, \",\", &next)) {\n            ssplit(key, \"=\", &value);\n            ejsSetPropertyByName(ejs, obj, EN(key), ejsCreateStringFromAsc(ejs, value));\n        }\n        return obj;\n    }\n    return ESV(null);\n}",
        "output": "0",
        "idx": 6943
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool is_flush_request(struct request *rq,\n\t\tstruct blk_flush_queue *fq, unsigned int tag)\n{\n\treturn ((rq->cmd_flags & REQ_FLUSH_SEQ) &&\n\t\t\tfq->flush_rq->tag == tag);\n}",
        "output": "1",
        "idx": 2896
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "juniper_mlfr_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n\n        l2info.pictype = DLT_JUNIPER_MLFR;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n\n        p+=l2info.header_len;\n\n        if (ndo->ndo_eflag && EXTRACT_32BITS(l2info.cookie) != 1)\n            ND_PRINT((ndo, \"Bundle-ID %u, \", l2info.bundle));\n        switch (l2info.proto) {\n        case (LLC_UI):\n        case (LLC_UI<<8):\n            isoclns_print(ndo, p, l2info.length);\n            break;\n        case (LLC_UI<<8 | NLPID_Q933):\n        case (LLC_UI<<8 | NLPID_IP):\n        case (LLC_UI<<8 | NLPID_IP6):\n            isoclns_print(ndo, p - 1, l2info.length + 1);\n            break;\n        default:\n            ND_PRINT((ndo, \"unknown protocol 0x%04x, length %u\", l2info.proto, l2info.length));\n        }\n\n        return l2info.header_len;\n}",
        "output": "0",
        "idx": 6551
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(DirectoryIterator, getFilename)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_STRING(intern->u.dir.entry.d_name, 1);\n}",
        "output": "0",
        "idx": 5565
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(locale_get_primary_language ) \n{\n\tget_icu_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}",
        "output": "1",
        "idx": 3862
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GIT_INLINE(bool) verify_dotgit_ntfs(git_repository *repo, const char *path, size_t len)\n{\n\tgit_buf *reserved = git_repository__reserved_names_win32;\n\tsize_t reserved_len = git_repository__reserved_names_win32_len;\n\tsize_t start = 0, i;\n\n\tif (repo)\n\t\tgit_repository__reserved_names(&reserved, &reserved_len, repo, true);\n\n\tfor (i = 0; i < reserved_len; i++) {\n\t\tgit_buf *r = &reserved[i];\n\n\t\tif (len >= r->size &&\n\t\t\tstrncasecmp(path, r->ptr, r->size) == 0) {\n\t\t\tstart = r->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!start)\n\t\treturn true;\n\n\tif (path[start] == '\\\\' || path[start] == ':')\n\t\treturn false;\n\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
        "output": "0",
        "idx": 6847
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,\n                                      unsigned char **p,\n                                      unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t  len;\n    ((void) ssl);\n\n    if( (*p) > end - 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n    len = (*p)[0] << 8 | (*p)[1];\n    *p += 2;\n\n    if( (*p) > end - len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n\n    *p += len;\n    ret = 0;\n\n    return( ret );\n}",
        "output": "0",
        "idx": 8781
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void audit_log_execve_info(struct audit_context *context,\n\t\t\t\t  struct audit_buffer **ab)\n{\n\tint i, len;\n\tsize_t len_sent = 0;\n\tconst char __user *p;\n\tchar *buf;\n\n\tp = (const char __user *)current->mm->arg_start;\n\n\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);\n\n\tbuf = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);\n\tif (!buf) {\n\t\taudit_panic(\"out of memory for argv string\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < context->execve.argc; i++) {\n\t\tlen = audit_log_single_execve_arg(context, ab, i,\n\t\t\t\t\t\t  &len_sent, p, buf);\n\t\tif (len <= 0)\n\t\t\tbreak;\n\t\tp += len;\n\t}\n\tkfree(buf);\n}",
        "output": "1",
        "idx": 1302
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset) {\n\tbloc = *offset;\n\tsend(huff->loc[ch], NULL, fout);\n\t*offset = bloc;\n}",
        "output": "1",
        "idx": 6238
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void perf_tp_event(u64 addr, u64 count, void *record, int entry_size,\n\t\t   struct pt_regs *regs, struct hlist_head *head, int rctx)\n{\n\tstruct perf_sample_data data;\n\tstruct perf_event *event;\n\tstruct hlist_node *node;\n\n\tstruct perf_raw_record raw = {\n\t\t.size = entry_size,\n\t\t.data = record,\n\t};\n\n\tperf_sample_data_init(&data, addr);\n\tdata.raw = &raw;\n\n\thlist_for_each_entry_rcu(event, node, head, hlist_entry) {\n\t\tif (perf_tp_event_match(event, &data, regs))\n\t\t\tperf_swevent_event(event, count, &data, regs);\n\t}\n\n\tperf_swevent_put_recursion_context(rctx);\n}",
        "output": "0",
        "idx": 703
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned int stack_maxrandom_size(void)\n{\n\tunsigned int max = 0;\n\tif ((current->flags & PF_RANDOMIZE) &&\n\t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\tmax = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;\n\t}\n\n\treturn max;\n}",
        "output": "1",
        "idx": 2788
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hgcm_call_preprocess_linaddr(\n\tconst struct vmmdev_hgcm_function_parameter *src_parm,\n\tvoid **bounce_buf_ret, size_t *extra)\n{\n\tvoid *buf, *bounce_buf;\n\tbool copy_in;\n\tu32 len;\n\tint ret;\n\n\tbuf = (void *)src_parm->u.pointer.u.linear_addr;\n\tlen = src_parm->u.pointer.size;\n\tcopy_in = src_parm->type != VMMDEV_HGCM_PARM_TYPE_LINADDR_OUT;\n\n\tif (len > VBG_MAX_HGCM_USER_PARM)\n\t\treturn -E2BIG;\n\n\tbounce_buf = kvmalloc(len, GFP_KERNEL);\n\tif (!bounce_buf)\n\t\treturn -ENOMEM;\n\n\tif (copy_in) {\n\t\tret = copy_from_user(bounce_buf, (void __user *)buf, len);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemset(bounce_buf, 0, len);\n\t}\n\n\t*bounce_buf_ret = bounce_buf;\n\thgcm_call_add_pagelist_size(bounce_buf, len, extra);\n\treturn 0;\n}",
        "output": "1",
        "idx": 3284
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void set_content_type(HttpResponse res, const char *mime) {\n        set_header(res, \"Content-Type\", mime);\n}",
        "output": "1",
        "idx": 6022
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jiffies_to_compat_timeval(unsigned long jiffies, struct compat_timeval *value)\n{\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tu32 rem;\n\tvalue->tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\tvalue->tv_usec = rem / NSEC_PER_USEC;\n}",
        "output": "0",
        "idx": 2999
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_result_code_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\tND_PRINT((ndo, \"%u\", EXTRACT_16BITS(ptr))); ptr++;\t\n\tif (length > 2) {\t\t\t\t\n\t        ND_PRINT((ndo, \"/%u\", EXTRACT_16BITS(ptr))); ptr++;\n\t}\n\tif (length > 4) {\t\t\t\t\n\t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, (const u_char *)ptr, length - 4);\n\t}\n}",
        "output": "1",
        "idx": 4770
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "netscreen_seek_read(wtap *wth, gint64 seek_off,\n\tstruct wtap_pkthdr *phdr, Buffer *buf,\n\tint *err, gchar **err_info)\n{\n\tint\t\tpkt_len;\n\tchar\t\tline[NETSCREEN_LINE_LENGTH];\n\tchar\t\tcap_int[NETSCREEN_MAX_INT_NAME_LENGTH];\n\tgboolean\tcap_dir;\n\tchar\t\tcap_dst[13];\n\n\tif (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) {\n\t\treturn FALSE;\n\t}\n\n\tif (file_gets(line, NETSCREEN_LINE_LENGTH, wth->random_fh) == NULL) {\n\t\t*err = file_error(wth->random_fh, err_info);\n\t\tif (*err == 0) {\n\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t}\n\t\treturn FALSE;\n\t}\n\n\tpkt_len = parse_netscreen_rec_hdr(phdr, line, cap_int, &cap_dir,\n\t    cap_dst, err, err_info);\n\tif (pkt_len == -1)\n\t\treturn FALSE;\n\n\tif (!parse_netscreen_hex_dump(wth->random_fh, pkt_len, cap_int,\n\t    cap_dst, phdr, buf, err, err_info))\n\t\treturn FALSE;\n\treturn TRUE;\n}",
        "output": "1",
        "idx": 5978
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void stellaris_enet_unrealize(DeviceState *dev, Error **errp)\n{\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n\n    unregister_savevm(DEVICE(s), \"stellaris_enet\", s);\n\n    memory_region_destroy(&s->mmio);\n}",
        "output": "1",
        "idx": 3780
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_aead raead;\n\tstruct aead_alg *aead = &alg->cra_aead;\n\n\tstrncpy(raead.type, \"aead\", sizeof(raead.type));\n\tstrncpy(raead.geniv, aead->geniv ?: \"<built-in>\", sizeof(raead.geniv));\n\n\traead.blocksize = alg->cra_blocksize;\n\traead.maxauthsize = aead->maxauthsize;\n\traead.ivsize = aead->ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,\n\t\t    sizeof(struct crypto_report_aead), &raead))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "0",
        "idx": 1175
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int cipso_v4_validate(const struct sk_buff *skb,\n\t\t\t\t    unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char err_offset = 0;\n\tu8 opt_len = opt[1];\n\tu8 opt_iter;\n\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto out;\n\t}\n\n\tif (get_unaligned_be32(&opt[2]) == 0) {\n\t\terr_offset = 2;\n\t\tgoto out;\n\t}\n\n\tfor (opt_iter = 6; opt_iter < opt_len;) {\n\t\tif (opt[opt_iter + 1] > (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto out;\n\t\t}\n\t\topt_iter += opt[opt_iter + 1];\n\t}\n\nout:\n\t*option = opt + err_offset;\n\treturn err_offset;\n\n}",
        "output": "1",
        "idx": 2342
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp,\n\t\tstruct nfsd3_setaclargs *argp,\n\t\tstruct nfsd3_attrstat *resp)\n{\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\t__be32 nfserr = 0;\n\tint error;\n\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n\t\tgoto out;\n\n\tinode = d_inode(fh->fh_dentry);\n\n\terror = fh_want_write(fh);\n\tif (error)\n\t\tgoto out_errno;\n\n\tfh_lock(fh);\n\n\terror = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);\n\tif (error)\n\t\tgoto out_drop_lock;\n\terror = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);\n\nout_drop_lock:\n\tfh_unlock(fh);\n\tfh_drop_write(fh);\nout_errno:\n\tnfserr = nfserrno(error);\nout:\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\tRETURN_STATUS(nfserr);\n}",
        "output": "0",
        "idx": 1899
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)\t{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}",
        "output": "0",
        "idx": 8321
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "text_or_buf_locked(void)\n{\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn TRUE;\n    }\n    return curbuf_locked();\n}",
        "output": "0",
        "idx": 8053
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void handle_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        uint8_t buf[64];\n        memcpy(buf, msg, sizeof(buf));\n\n        uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n        uint32_t msgSize = buf[8]        |\n                ((uint32_t)buf[7]) <<  8 |\n                ((uint32_t)buf[6]) << 16 |\n                ((uint32_t)buf[5]) << 24;\n\n        if (msgSize > 64 - 9) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n            return;\n        }\n\n        const MessagesMap_t *entry = message_map_entry(NORMAL_MSG, msgId, IN_MSG);\n        if (!entry) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n            return;\n        }\n\n        tiny_dispatch(entry, buf + 9, msgSize);\n    } else {\n        usb_rx_helper(msg, len, NORMAL_MSG);\n    }\n}",
        "output": "1",
        "idx": 7552
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iakerb_gss_delete_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t output_token)\n{\n    OM_uint32 major_status = GSS_S_COMPLETE;\n\n    if (output_token != GSS_C_NO_BUFFER) {\n        output_token->length = 0;\n        output_token->value = NULL;\n    }\n\n    *minor_status = 0;\n\n    if (*context_handle != GSS_C_NO_CONTEXT) {\n        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n\n        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {\n            iakerb_release_context(iakerb_ctx);\n            *context_handle = GSS_C_NO_CONTEXT;\n        } else {\n            assert(iakerb_ctx->magic == KG_CONTEXT);\n\n            major_status = krb5_gss_delete_sec_context(minor_status,\n                                                       context_handle,\n                                                       output_token);\n        }\n    }\n\n    return major_status;\n}",
        "output": "1",
        "idx": 118
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tspin_lock(&ctx->cancel_lock);\n\t__timerfd_remove_cancel(ctx);\n\tspin_unlock(&ctx->cancel_lock);\n}",
        "output": "0",
        "idx": 2149
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "webSocketsHasDataInBuffer(rfbClientPtr cl)\n{\n    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n\n    if (wsctx && wsctx->readbuflen)\n      return TRUE;\n\n    return (cl->sslctx && rfbssl_pending(cl) > 0);\n}",
        "output": "1",
        "idx": 6338
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct dst_entry *inet_csk_route_req(struct sock *sk,\n\t\t\t\t     const struct request_sock *req)\n{\n\tstruct rtable *rt;\n\tconst struct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ip_options_rcu *opt = inet_rsk(req)->opt;\n\tstruct net *net = sock_net(sk);\n\tstruct flowi4 fl4;\n\n\tflowi4_init_output(&fl4, sk->sk_bound_dev_if, sk->sk_mark,\n\t\t\t   RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE,\n\t\t\t   sk->sk_protocol, inet_sk_flowi_flags(sk),\n\t\t\t   (opt && opt->opt.srr) ? opt->opt.faddr : ireq->rmt_addr,\n\t\t\t   ireq->loc_addr, ireq->rmt_port, inet_sk(sk)->inet_sport);\n\tsecurity_req_classify_flow(req, flowi4_to_flowi(&fl4));\n\trt = ip_route_output_flow(net, &fl4, sk);\n\tif (IS_ERR(rt))\n\t\tgoto no_route;\n\tif (opt && opt->opt.is_strictroute && rt->rt_dst != rt->rt_gateway)\n\t\tgoto route_err;\n\treturn &rt->dst;\n\nroute_err:\n\tip_rt_put(rt);\nno_route:\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES);\n\treturn NULL;\n}",
        "output": "0",
        "idx": 483
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(locale_get_display_region) \n{\n    get_icu_disp_value_src_php( LOC_REGION_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}",
        "output": "1",
        "idx": 3894
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct mapped_device *dm_get_from_kobject(struct kobject *kobj)\n{\n\tstruct mapped_device *md;\n\n\tmd = container_of(kobj, struct mapped_device, kobj_holder.kobj);\n\n\tif (test_bit(DMF_FREEING, &md->flags) ||\n\t    dm_deleting_md(md))\n\t\treturn NULL;\n\n\tdm_get(md);\n\treturn md;\n}",
        "output": "1",
        "idx": 1756
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ASC_destroyAssociation(T_ASC_Association ** association)\n{\n    OFCondition cond = EC_Normal;\n\n    if (association == NULL) return EC_Normal;\n    if (*association == NULL) return EC_Normal;\n\n    if ((*association)->DULassociation != NULL) {\n        ASC_dropAssociation(*association);\n    }\n\n    if ((*association)->params != NULL) {\n        cond = ASC_destroyAssociationParameters(&(*association)->params);\n        if (cond.bad()) return cond;\n    }\n\n    if ((*association)->sendPDVBuffer != NULL)\n        free((*association)->sendPDVBuffer);\n\n    free(*association);\n    *association = NULL;\n\n    return EC_Normal;\n}",
        "output": "1",
        "idx": 8836
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int bad_format_check(const char *pattern, char *fmt) {\n    GError *gerr = NULL;\n    GRegex *re = g_regex_new(pattern, G_REGEX_EXTENDED, 0, &gerr);\n    GMatchInfo *mi;\n    if (gerr != NULL) {\n        rrd_set_error(\"cannot compile regular expression: %s (%s)\", gerr->message,pattern);\n        return 1;\n    }\n    int m = g_regex_match(re, fmt, 0, &mi);\n    g_match_info_free (mi);\n    g_regex_unref(re);\n    if (!m) {\n        rrd_set_error(\"invalid format string '%s' (should match '%s')\",fmt,pattern);\n        return 1;\n    }\n    return 0;\n}",
        "output": "0",
        "idx": 6443
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int db_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\n\tif (!(svm->vcpu.guest_debug &\n\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) &&\n\t\t!svm->nmi_singlestep) {\n\t\tkvm_queue_exception(&svm->vcpu, DB_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->nmi_singlestep) {\n\t\tsvm->nmi_singlestep = false;\n\t\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP))\n\t\t\tsvm->vmcb->save.rflags &=\n\t\t\t\t~(X86_EFLAGS_TF | X86_EFLAGS_RF);\n\t\tupdate_db_bp_intercept(&svm->vcpu);\n\t}\n\n\tif (svm->vcpu.guest_debug &\n\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.pc =\n\t\t\tsvm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
        "output": "1",
        "idx": 926
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool ib_safe_file_access(struct file *filp)\n{\n\treturn filp->f_cred == current_cred() && segment_eq(get_fs(), USER_DS);\n}",
        "output": "0",
        "idx": 1829
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC int httpAddDefense(cchar *name, cchar *remedy, cchar *remedyArgs)\n{\n    Http        *http;\n    MprHash     *args;\n    MprList     *list;\n    char        *arg, *key, *value;\n    int         next;\n\n    assert(name && *name);\n\n    http = HTTP;\n    args = mprCreateHash(0, MPR_HASH_STABLE);\n    list = stolist(remedyArgs);\n    for (ITERATE_ITEMS(list, arg, next)) {\n        key = ssplit(arg, \"=\", &value);\n        mprAddKey(args, key, strim(value, \"\\\"'\", 0));\n    }\n    if (!remedy) {\n        remedy = mprLookupKey(args, \"REMEDY\");\n    }\n    mprAddKey(http->defenses, name, createDefense(name, remedy, args));\n    return 0;\n}",
        "output": "0",
        "idx": 7041
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct sctp_chunk *sctp_assoc_lookup_asconf_ack(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__be32 serial)\n{\n\tstruct sctp_chunk *ack;\n\n\tlist_for_each_entry(ack, &asoc->asconf_ack_list, transmitted_list) {\n\t\tif (sctp_chunk_pending(ack))\n\t\t\tcontinue;\n\t\tif (ack->subh.addip_hdr->serial == serial) {\n\t\t\tsctp_chunk_hold(ack);\n\t\t\treturn ack;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
        "output": "0",
        "idx": 3711
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_remove_from_owner(struct perf_event *event)\n{\n\tstruct task_struct *owner;\n\n\trcu_read_lock();\n\towner = ACCESS_ONCE(event->owner);\n\tsmp_read_barrier_depends();\n\tif (owner) {\n\t\tget_task_struct(owner);\n\t}\n\trcu_read_unlock();\n\n\tif (owner) {\n\t\tmutex_lock(&owner->perf_event_mutex);\n\t\tif (event->owner)\n\t\t\tlist_del_init(&event->owner_entry);\n\t\tmutex_unlock(&owner->perf_event_mutex);\n\t\tput_task_struct(owner);\n\t}\n}",
        "output": "1",
        "idx": 2764
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h);\n\tsize_t pos = CDF_SHORT_SEC_POS(h, id);\n\tassert(ss == len);\n\tif (sst->sst_len < (size_t)id) {\n\t\tDPRINTF((\"bad sector id %d > %d\\n\", id, sst->sst_len));\n\t\treturn -1;\n\t}\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + pos, len);\n\treturn len;\n}",
        "output": "0",
        "idx": 5055
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_wrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tint conf_req_flag,\n\t\tgss_qop_t qop_req,\n\t\tgss_buffer_t input_message_buffer,\n\t\tint *conf_state,\n\t\tgss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap(minor_status,\n\t\t    context_handle,\n\t\t    conf_req_flag,\n\t\t    qop_req,\n\t\t    input_message_buffer,\n\t\t    conf_state,\n\t\t    output_message_buffer);\n\n\treturn (ret);\n}",
        "output": "1",
        "idx": 62
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int kvm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\tswitch (msr->index) {\n\tcase MSR_FS_BASE:\n\tcase MSR_GS_BASE:\n\tcase MSR_KERNEL_GS_BASE:\n\tcase MSR_CSTAR:\n\tcase MSR_LSTAR:\n\t\tif (is_noncanonical_address(msr->data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tmsr->data = get_canonical(msr->data);\n\t}\n\treturn kvm_x86_ops->set_msr(vcpu, msr);\n}",
        "output": "0",
        "idx": 3733
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void addFormVars(cchar *buf)\n{\n    char    *pair, *tok;\n\n    pair = stok(sclone(buf), \"&\", &tok);\n    while (pair != 0) {\n        mprAddItem(app->formData, sclone(pair));\n        pair = stok(0, \"&\", &tok);\n    }\n}",
        "output": "1",
        "idx": 5010
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int encrypt(struct blkcipher_desc *desc,\n\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t   unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, 64);\n\n\tsalsa20_ivsetup(ctx, walk.iv);\n\n\tif (likely(walk.nbytes == nbytes))\n\t{\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr, nbytes);\n\t\treturn blkcipher_walk_done(desc, &walk, 0);\n\t}\n\n\twhile (walk.nbytes >= 64) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr,\n\t\t\t\t      walk.nbytes - (walk.nbytes % 64));\n\t\terr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\n\t}\n\n\tif (walk.nbytes) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr, walk.nbytes);\n\t\terr = blkcipher_walk_done(desc, &walk, 0);\n\t}\n\n\treturn err;\n}",
        "output": "1",
        "idx": 1780
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_complete_auth_token(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_complete_auth_token(minor_status,\n\t\t\t\t      context_handle,\n\t\t\t\t      input_message_buffer);\n\treturn (ret);\n}",
        "output": "1",
        "idx": 86
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int install_process_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_process_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}",
        "output": "0",
        "idx": 2245
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NOEXPORT void reload_config() {\n    static int delay=10; \n#ifdef HAVE_CHROOT\n    struct stat sb;\n#endif \n\n    if(options_parse(CONF_RELOAD)) {\n        s_log(LOG_ERR, \"Failed to reload the configuration file\");\n        return;\n    }\n    unbind_ports();\n    log_flush(LOG_MODE_BUFFER);\n#ifdef HAVE_CHROOT\n    if(global_options.chroot_dir && stat(\"/dev/log\", &sb))\n        log_close(SINK_OUTFILE);\n    else\n#endif \n        log_close(SINK_SYSLOG|SINK_OUTFILE);\n    options_free();\n    options_apply();\n    log_open(SINK_SYSLOG|SINK_OUTFILE);\n    log_flush(LOG_MODE_CONFIGURED);\n    ui_config_reloaded();\n    if(bind_ports() | exec_connect_start()) {\n        s_poll_sleep(delay/1000, delay%1000); \n        signal_post(SIGNAL_RELOAD_CONFIG); \n        delay*=2;\n        if(delay > 10000) \n            delay=10000;\n    } else {\n        delay=10; \n    }\n}",
        "output": "1",
        "idx": 8462
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __always_inline int __do_follow_link(struct path *path, struct nameidata *nd)\n{\n\tint error;\n\tvoid *cookie;\n\tstruct dentry *dentry = path->dentry;\n\n\ttouch_atime(path->mnt, dentry);\n\tnd_set_link(nd, NULL);\n\n\tif (path->mnt != nd->path.mnt) {\n\t\tpath_to_nameidata(path, nd);\n\t\tdget(dentry);\n\t}\n\tmntget(path->mnt);\n\tnd->last_type = LAST_BIND;\n\tcookie = dentry->d_inode->i_op->follow_link(dentry, nd);\n\terror = PTR_ERR(cookie);\n\tif (!IS_ERR(cookie)) {\n\t\tchar *s = nd_get_link(nd);\n\t\terror = 0;\n\t\tif (s)\n\t\t\terror = __vfs_follow_link(nd, s);\n\t\telse if (nd->last_type == LAST_BIND) {\n\t\t\terror = force_reval_path(&nd->path, nd);\n\t\t\tif (error)\n\t\t\t\tpath_put(&nd->path);\n\t\t}\n\t\tif (dentry->d_inode->i_op->put_link)\n\t\t\tdentry->d_inode->i_op->put_link(dentry, nd, cookie);\n\t}\n\treturn error;\n}",
        "output": "0",
        "idx": 3131
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ghash_final(struct shash_desc *desc, u8 *dst)\n{\n\tstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);\n\tstruct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);\n\tu8 *buf = dctx->buffer;\n\n\tif (!ctx->gf128)\n\t\treturn -ENOKEY;\n\n\tghash_flush(ctx, dctx);\n\tmemcpy(dst, buf, GHASH_BLOCK_SIZE);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 809
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int bad_format_imginfo(char *fmt){\n    return bad_format_check(\"^\" SAFE_STRING \"%s\" SAFE_STRING \"%lu\" SAFE_STRING \"%lu\" SAFE_STRING \"$\",fmt);\n}",
        "output": "0",
        "idx": 6439
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n{\tsf_count_t total = 0 ;\n\tssize_t\tcount ;\n\n\tif (bytes == 0 || items == 0)\n\t\treturn 0 ;\n\n\tif (psf->virtual_io)\n\t\treturn psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;\n\n\titems *= bytes ;\n\n\tif (items <= 0)\n\t\treturn 0 ;\n\n\twhile (items > 0)\n\t{\t\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;\n\n\t\tcount = write (psf->file.filedes, ((const char*) ptr) + total, count) ;\n\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\n\t\tif (count == 0)\n\t\t\tbreak ;\n\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\n\tif (psf->is_pipe)\n\t\tpsf->pipeoffset += total ;\n\n\treturn total / bytes ;\n} ",
        "output": "0",
        "idx": 6873
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int iov_fault_in_pages_write(struct iovec *iov, unsigned long len)\n{\n\twhile (!iov->iov_len)\n\t\tiov++;\n\n\twhile (len > 0) {\n\t\tunsigned long this_len;\n\n\t\tthis_len = min_t(unsigned long, len, iov->iov_len);\n\t\tif (fault_in_pages_writeable(iov->iov_base, this_len))\n\t\t\tbreak;\n\n\t\tlen -= this_len;\n\t\tiov++;\n\t}\n\n\treturn len;\n}",
        "output": "1",
        "idx": 2534
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)\n{\n\tint i;\n\tint opts;\n\tResub m;\n\n\topts = 0;\n\tif (re->flags & JS_REGEXP_G) {\n\t\tif (re->last > strlen(text)) {\n\t\t\tre->last = 0;\n\t\t\tjs_pushnull(J);\n\t\t\treturn;\n\t\t}\n\t\tif (re->last > 0) {\n\t\t\ttext += re->last;\n\t\t\topts |= REG_NOTBOL;\n\t\t}\n\t}\n\n\tif (!js_regexec(re->prog, text, &m, opts)) {\n\t\tjs_newarray(J);\n\t\tjs_pushstring(J, text);\n\t\tjs_setproperty(J, -2, \"input\");\n\t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n\t\tjs_setproperty(J, -2, \"index\");\n\t\tfor (i = 0; i < m.nsub; ++i) {\n\t\t\tjs_pushlstring(J, m.sub[i].sp, m.sub[i].ep - m.sub[i].sp);\n\t\t\tjs_setindex(J, -2, i);\n\t\t}\n\t\tif (re->flags & JS_REGEXP_G)\n\t\t\tre->last = re->last + (m.sub[0].ep - text);\n\t\treturn;\n\t}\n\n\tif (re->flags & JS_REGEXP_G)\n\t\tre->last = 0;\n\n\tjs_pushnull(J);\n}",
        "output": "1",
        "idx": 7408
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VTermScreen *screen_new(VTerm *vt)\n{\n  VTermState *state = vterm_obtain_state(vt);\n  VTermScreen *screen;\n  int rows, cols;\n\n  if (state == NULL)\n    return NULL;\n  screen = vterm_allocator_malloc(vt, sizeof(VTermScreen));\n  if (screen == NULL)\n    return NULL;\n\n  vterm_get_size(vt, &rows, &cols);\n\n  screen->vt = vt;\n  screen->state = state;\n\n  screen->damage_merge = VTERM_DAMAGE_CELL;\n  screen->damaged.start_row = -1;\n  screen->pending_scrollrect.start_row = -1;\n\n  screen->rows = rows;\n  screen->cols = cols;\n\n  screen->callbacks = NULL;\n  screen->cbdata    = NULL;\n\n  screen->buffers[0] = realloc_buffer(screen, NULL, rows, cols);\n  screen->buffer = screen->buffers[0];\n  screen->sb_buffer = vterm_allocator_malloc(screen->vt, sizeof(VTermScreenCell) * cols);\n  if (screen->buffer == NULL || screen->sb_buffer == NULL)\n  {\n    vterm_screen_free(screen);\n    return NULL;\n  }\n\n  vterm_state_set_callbacks(screen->state, &state_cbs, screen);\n\n  return screen;\n}",
        "output": "0",
        "idx": 8141
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned int ipv6_defrag(void *priv,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tconst struct nf_hook_state *state)\n{\n\tint err;\n\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n\tif (skb->nfct && !nf_ct_is_template((struct nf_conn *)skb->nfct))\n\t\treturn NF_ACCEPT;\n#endif\n\n\terr = nf_ct_frag6_gather(state->net, skb,\n\t\t\t\t nf_ct6_defrag_user(state->hook, skb));\n\tif (err == -EINPROGRESS)\n\t\treturn NF_STOLEN;\n\n\treturn NF_ACCEPT;\n}",
        "output": "1",
        "idx": 1384
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct page *alloc_huge_page(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long addr, int avoid_reserve)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct page *page;\n\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tlong chg;\n\n\tchg = vma_needs_reservation(h, vma, addr);\n\tif (chg < 0)\n\t\treturn ERR_PTR(-VM_FAULT_OOM);\n\tif (chg)\n\t\tif (hugetlb_get_quota(inode->i_mapping, chg))\n\t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n\n\tspin_lock(&hugetlb_lock);\n\tpage = dequeue_huge_page_vma(h, vma, addr, avoid_reserve);\n\tspin_unlock(&hugetlb_lock);\n\n\tif (!page) {\n\t\tpage = alloc_buddy_huge_page(h, NUMA_NO_NODE);\n\t\tif (!page) {\n\t\t\thugetlb_put_quota(inode->i_mapping, chg);\n\t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n\t\t}\n\t}\n\n\tset_page_private(page, (unsigned long) mapping);\n\n\tvma_commit_reservation(h, vma, addr);\n\n\treturn page;\n}",
        "output": "1",
        "idx": 688
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t rpmsg_eptdev_write_iter(struct kiocb *iocb,\n\t\t\t\t       struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tvoid *kbuf;\n\tint ret;\n\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(kbuf, len, from)) {\n\t\tret = -EFAULT;\n\t\tgoto free_kbuf;\n\t}\n\n\tif (mutex_lock_interruptible(&eptdev->ept_lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free_kbuf;\n\t}\n\n\tif (!eptdev->ept) {\n\t\tret = -EPIPE;\n\t\tgoto unlock_eptdev;\n\t}\n\n\tif (filp->f_flags & O_NONBLOCK)\n\t\tret = rpmsg_trysend(eptdev->ept, kbuf, len);\n\telse\n\t\tret = rpmsg_send(eptdev->ept, kbuf, len);\n\nunlock_eptdev:\n\tmutex_unlock(&eptdev->ept_lock);\n\nfree_kbuf:\n\tkfree(kbuf);\n\treturn ret < 0 ? ret : len;\n}",
        "output": "0",
        "idx": 4533
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cJSON_strcasecmp( const char *s1, const char *s2 )\n{\n\tif ( ! s1 )\n\t\treturn ( s1 == s2 ) ? 0 : 1;\n\tif ( ! s2 )\n\t\treturn 1;\n\tfor ( ; tolower(*s1) == tolower(*s2); ++s1, ++s2)\n\t\tif( *s1 == 0 )\n\t\t\treturn 0;\n\treturn tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);\n}",
        "output": "1",
        "idx": 5888
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hi3660_stub_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tunsigned int i;\n\tint ret;\n\n\tstub_clk_chan.cl.dev = dev;\n\tstub_clk_chan.cl.tx_done = NULL;\n\tstub_clk_chan.cl.tx_block = false;\n\tstub_clk_chan.cl.knows_txdone = false;\n\n\tstub_clk_chan.mbox = mbox_request_channel(&stub_clk_chan.cl, 0);\n\tif (IS_ERR(stub_clk_chan.mbox))\n\t\treturn PTR_ERR(stub_clk_chan.mbox);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\tfreq_reg = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!freq_reg)\n\t\treturn -ENOMEM;\n\n\tfreq_reg += HI3660_STUB_CLOCK_DATA;\n\n\tfor (i = 0; i < HI3660_CLK_STUB_NUM; i++) {\n\t\tret = devm_clk_hw_register(&pdev->dev, &hi3660_stub_clks[i].hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn devm_of_clk_add_hw_provider(&pdev->dev, hi3660_stub_clk_hw_get,\n\t\t\t\t\t   hi3660_stub_clks);\n}",
        "output": "0",
        "idx": 2681
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\twrite_lock_bh(&ping_table.lock);\n\tif (sk_hashed(sk)) {\n\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsk_nulls_node_init(&sk->sk_nulls_node);\n\t\tsock_put(sk);\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t}\n\twrite_unlock_bh(&ping_table.lock);\n}",
        "output": "0",
        "idx": 2221
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t   unsigned long npages)\n{\n\tgfn_t end_gfn;\n\tpfn_t pfn;\n\n\tpfn     = gfn_to_pfn_memslot(slot, gfn);\n\tend_gfn = gfn + npages;\n\tgfn    += 1;\n\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn pfn;\n\n\twhile (gfn < end_gfn)\n\t\tgfn_to_pfn_memslot(slot, gfn++);\n\n\treturn pfn;\n}",
        "output": "0",
        "idx": 3741
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int __usb_get_extra_descriptor(char *buffer, unsigned size,\n\t\t\t       unsigned char type, void **ptr)\n{\n\tstruct usb_descriptor_header *header;\n\n\twhile (size >= sizeof(struct usb_descriptor_header)) {\n\t\theader = (struct usb_descriptor_header *)buffer;\n\n\t\tif (header->bLength < 2) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"%s: bogus descriptor, type %d length %d\\n\",\n\t\t\t\tusbcore_name,\n\t\t\t\theader->bDescriptorType,\n\t\t\t\theader->bLength);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (header->bDescriptorType == type) {\n\t\t\t*ptr = header;\n\t\t\treturn 0;\n\t\t}\n\n\t\tbuffer += header->bLength;\n\t\tsize -= header->bLength;\n\t}\n\treturn -1;\n}",
        "output": "1",
        "idx": 3048
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void inet6_destroy_sock(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct ipv6_txoptions *opt;\n\n\n\tskb = xchg(&np->pktoptions, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\n\tskb = xchg(&np->rxpmtu, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\n\tfl6_free_socklist(sk);\n\n\n\topt = xchg(&np->opt, NULL);\n\tif (opt)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n}",
        "output": "1",
        "idx": 948
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void show_object(struct object *object, struct strbuf *path,\n\t\t\tconst char *last, void *data)\n{\n\tstruct bitmap *base = data;\n\tbitmap_set(base, find_object_pos(object->oid.hash));\n\tmark_as_seen(object);\n}",
        "output": "1",
        "idx": 5200
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void i8042_stop(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\n\tspin_lock_irq(&i8042_lock);\n\tport->exists = false;\n\tport->serio = NULL;\n\tspin_unlock_irq(&i8042_lock);\n\n\tsynchronize_irq(I8042_AUX_IRQ);\n\tsynchronize_irq(I8042_KBD_IRQ);\n}",
        "output": "0",
        "idx": 2367
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tvoid *buf;\n\tint err;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (memcpy_from_msg(buf, msg, len)) {\n\t\tkfree(buf);\n\t\treturn -EFAULT;\n\t}\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECTED)\n\t\terr = sco_send_frame(sk, buf, len, msg->msg_flags);\n\telse\n\t\terr = -ENOTCONN;\n\n\trelease_sock(sk);\n\tkfree(buf);\n\treturn err;\n}",
        "output": "0",
        "idx": 2855
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_sched_clock_irq(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers();\n\n\tthis_cpu_add(net_rand_state.s1, rol32(jiffies, 24) + user_tick);\n}",
        "output": "0",
        "idx": 2701
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static cchar *getVxCPU(cchar *arch)\n{\n    char   *cpu, *family;\n\n    family = stok(sclone(arch), \":\", &cpu);\n    if (!cpu || *cpu == '\\0') {\n        if (smatch(family, \"i386\")) {\n            cpu = \"I80386\";\n        } else if (smatch(family, \"i486\")) {\n            cpu = \"I80486\";\n        } else if (smatch(family, \"x86\") | sends(family, \"86\")) {\n            cpu = \"PENTIUM\";\n        } else if (scaselessmatch(family, \"mips\")) {\n            cpu = \"MIPS32\";\n        } else if (scaselessmatch(family, \"arm\")) {\n            cpu = \"ARM7TDMI\";\n        } else if (scaselessmatch(family, \"ppc\")) {\n            cpu = \"PPC\";\n        } else {\n            cpu = (char*) arch;\n        }\n    }\n    return supper(cpu);\n}",
        "output": "1",
        "idx": 4996
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "chunk_new_with_alloc_size(size_t alloc)\n{\n  chunk_t *ch;\n  ch = tor_malloc(alloc);\n  ch->next = NULL;\n  ch->datalen = 0;\n#ifdef DEBUG_CHUNK_ALLOC\n  ch->DBG_alloc = alloc;\n#endif\n  ch->memlen = CHUNK_SIZE_WITH_ALLOC(alloc);\n  total_bytes_allocated_in_chunks += alloc;\n  ch->data = &ch->mem[0];\n  CHUNK_SET_SENTINEL(ch, alloc);\n  return ch;\n}",
        "output": "0",
        "idx": 8523
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jas_iccgetsint32(jas_stream_t *in, jas_iccsint32_t *val)\n{\n\tjas_ulonglong tmp;\n\tif (jas_iccgetuint(in, 4, &tmp))\n\t\treturn -1;\n\t*val = (tmp & 0x80000000) ? (-JAS_CAST(jas_longlong, (((~tmp) &\n\t  0x7fffffff) + 1))) : JAS_CAST(jas_longlong, tmp);\n\treturn 0;\n}",
        "output": "0",
        "idx": 7547
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0, reasonLen=0;\n    char *reason=NULL;\n\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n\n    authResult = rfbClientSwap32IfLE(authResult);\n\n    switch (authResult) {\n    case rfbVncAuthOK:\n      rfbClientLog(\"VNC authentication succeeded\\n\");\n      return TRUE;\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;\n        reasonLen = rfbClientSwap32IfLE(reasonLen);\n        reason = malloc((uint64_t)reasonLen+1);\n        if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }\n        reason[reasonLen]=0;\n        rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n        free(reason);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:\n      rfbClientLog(\"VNC authentication failed - too many tries\\n\");\n      return FALSE;\n    }\n\n    rfbClientLog(\"Unknown VNC authentication result: %d\\n\",\n                 (int)authResult);\n    return FALSE;\n}",
        "output": "1",
        "idx": 6342
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseAuthUsers(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprJson     *child;\n    cchar       *roles, *password;\n    int         ji;\n\n    for (ITERATE_CONFIG(route, prop, child, ji)) {\n        password = mprGetJson(child, \"password\");\n        roles = getList(mprGetJsonObj(child, \"roles\"));\n        if (httpAddUser(route->auth, child->name, password, roles) < 0) {\n            httpParseError(route, \"Cannot add user %s\", child->name);\n            break;\n        }\n        if (!route->auth->store) {\n            httpSetAuthStore(route->auth, \"config\");\n        }\n    }\n}",
        "output": "1",
        "idx": 5024
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void snd_msndmidi_input_read(void *mpuv)\n{\n\tunsigned long flags;\n\tstruct snd_msndmidi *mpu = mpuv;\n\tvoid *pwMIDQData = mpu->dev->mappedbase + MIDQ_DATA_BUFF;\n\tu16 head, tail, size;\n\n\tspin_lock_irqsave(&mpu->input_lock, flags);\n\thead = readw(mpu->dev->MIDQ + JQS_wHead);\n\ttail = readw(mpu->dev->MIDQ + JQS_wTail);\n\tsize = readw(mpu->dev->MIDQ + JQS_wSize);\n\tif (head > size || tail > size)\n\t\tgoto out;\n\twhile (head != tail) {\n\t\tunsigned char val = readw(pwMIDQData + 2 * head);\n\n\t\tif (test_bit(MSNDMIDI_MODE_BIT_INPUT_TRIGGER, &mpu->mode))\n\t\t\tsnd_rawmidi_receive(mpu->substream_input, &val, 1);\n\t\tif (++head > size)\n\t\t\thead = 0;\n\t\twritew(head, mpu->dev->MIDQ + JQS_wHead);\n\t}\n out:\n\tspin_unlock_irqrestore(&mpu->input_lock, flags);\n}",
        "output": "0",
        "idx": 2341
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "receive_carbon(void **state)\n{\n    prof_input(\"/carbons on\");\n\n    prof_connect();\n    assert_true(stbbr_received(\n        \"<iq id='*' type='set'><enable xmlns='urn:xmpp:carbons:2'/></iq>\"\n    ));\n\n    stbbr_send(\n        \"<presence to='stabber@localhost' from='buddy1@localhost/mobile'>\"\n            \"<priority>10</priority>\"\n            \"<status>On my mobile</status>\"\n        \"</presence>\"\n    );\n    assert_true(prof_output_exact(\"Buddy1 (mobile) is online, \\\"On my mobile\\\"\"));\n    prof_input(\"/msg Buddy1\");\n    assert_true(prof_output_exact(\"unencrypted\"));\n\n    stbbr_send(\n        \"<message type='chat' to='stabber@localhost/profanity' from='buddy1@localhost'>\"\n            \"<received xmlns='urn:xmpp:carbons:2'>\"\n                \"<forwarded xmlns='urn:xmpp:forward:0'>\"\n                    \"<message id='prof_msg_7' xmlns='jabber:client' type='chat' lang='en' to='stabber@localhost/profanity' from='buddy1@localhost/mobile'>\"\n                        \"<body>test carbon from recipient</body>\"\n                    \"</message>\"\n                \"</forwarded>\"\n            \"</received>\"\n        \"</message>\"\n    );\n\n    assert_true(prof_output_regex(\"Buddy1/mobile: .+test carbon from recipient\"));\n}",
        "output": "1",
        "idx": 6382
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev)\n{\n\tstruct virtproc_info *vrp = vdev->priv;\n\tstruct virtio_rpmsg_channel *vch;\n\tstruct rpmsg_device *rpdev_ctrl;\n\tint err = 0;\n\n\tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n\tif (!vch)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tvch->vrp = vrp;\n\n\trpdev_ctrl = &vch->rpdev;\n\trpdev_ctrl->ops = &virtio_rpmsg_ops;\n\n\trpdev_ctrl->dev.parent = &vrp->vdev->dev;\n\trpdev_ctrl->dev.release = virtio_rpmsg_release_device;\n\trpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);\n\n\terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n\tif (err) {\n\t\tkfree(vch);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn rpdev_ctrl;\n}",
        "output": "1",
        "idx": 2030
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tsiginfo_t info;\n\n\tif (copy_from_user(&info, uinfo, sizeof(siginfo_t)))\n\t\treturn -EFAULT;\n\n\tif (info.si_code != SI_QUEUE) {\n\t\tWARN_ON_ONCE(info.si_code < 0);\n\t\treturn -EPERM;\n\t}\n\tinfo.si_signo = sig;\n\n\treturn kill_proc_info(sig, &info, pid);\n}",
        "output": "0",
        "idx": 381
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cib_remote_dispatch(gpointer user_data)\n{\n    cib_t *cib = user_data;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n\n    xmlNode *msg = NULL;\n    const char *type = NULL;\n\n    crm_info(\"Message on callback channel\");\n    msg = crm_recv_remote_msg(private->callback.session, private->callback.encrypted);\n\n    type = crm_element_value(msg, F_TYPE);\n    crm_trace(\"Activating %s callbacks...\", type);\n\n    if (safe_str_eq(type, T_CIB)) {\n        cib_native_callback(cib, msg, 0, 0);\n\n    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {\n        g_list_foreach(cib->notify_list, cib_native_notify, msg);\n\n    } else {\n        crm_err(\"Unknown message type: %s\", type);\n    }\n\n    if (msg != NULL) {\n        free_xml(msg);\n        return 0;\n    }\n    return -1;\n}",
        "output": "1",
        "idx": 3730
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GIT_INLINE(bool) verify_dotgit_ntfs(git_repository *repo, const char *path, size_t len)\n{\n\tgit_buf *reserved = git_repository__reserved_names_win32;\n\tsize_t reserved_len = git_repository__reserved_names_win32_len;\n\tsize_t start = 0, i;\n\n\tif (repo)\n\t\tgit_repository__reserved_names(&reserved, &reserved_len, repo, true);\n\n\tfor (i = 0; i < reserved_len; i++) {\n\t\tgit_buf *r = &reserved[i];\n\n\t\tif (len >= r->size &&\n\t\t\tstrncasecmp(path, r->ptr, r->size) == 0) {\n\t\t\tstart = r->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!start)\n\t\treturn true;\n\n\tif (path[start] == '\\\\')\n\t\treturn false;\n\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
        "output": "1",
        "idx": 4890
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "qedi_dbg_warn(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & QEDI_LOG_WARN))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_warn(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tnfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_warn(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\n\nret:\n\tva_end(va);\n}",
        "output": "1",
        "idx": 3188
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main()\n{\n\tgdImagePtr im;\n\tFILE *fp;\n\tchar path[1024];\n\n\tsprintf(path, \"%s/gd2/invalid_neg_size.gd2\", GDTEST_TOP_DIR);\n\tfp = fopen(path, \"rb\");\n\tif (!fp) {\n\t\tprintf(\"failed, cannot open file\\n\");\n\t\treturn 1;\n\t}\n\tim = gdImageCreateFromGd2(fp);\n\tfclose(fp);\n\n\treturn im == NULL ? 0 : 1;\n}",
        "output": "0",
        "idx": 6239
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "}\n\nstatic inline bool f2fs_force_buffered_io(struct inode *inode,\n\t\t\t\tstruct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint rw = iov_iter_rw(iter);\n\n\tif (f2fs_post_read_required(inode))\n\t\treturn true;\n\tif (f2fs_is_multi_device(sbi))\n\t\treturn true;\n\tif (f2fs_sb_has_blkzoned(sbi))\n\t\treturn true;\n\tif (test_opt(sbi, LFS) && (rw == WRITE) &&\n\t\t\t\tblock_unaligned_IO(inode, iocb, iter))\n\t\treturn true;\n\tif (is_sbi_flag_set(F2FS_I_SB(inode), SBI_CP_DISABLED))\n\t\treturn true;\n",
        "output": "1",
        "idx": 3212
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void user_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %u\", key->datalen);\n}",
        "output": "1",
        "idx": 1746
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int target_xcopy_locate_se_dev_e4_iter(struct se_device *se_dev,\n\t\t\t\t\t      const unsigned char *dev_wwn)\n{\n\tunsigned char tmp_dev_wwn[XCOPY_NAA_IEEE_REGEX_LEN];\n\tint rc;\n\n\tif (!se_dev->dev_attrib.emulate_3pc) {\n\t\tpr_debug(\"XCOPY: emulate_3pc disabled on se_dev %p\\n\", se_dev);\n\t\treturn 0;\n\t}\n\n\tmemset(&tmp_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);\n\ttarget_xcopy_gen_naa_ieee(se_dev, &tmp_dev_wwn[0]);\n\n\trc = memcmp(&tmp_dev_wwn[0], dev_wwn, XCOPY_NAA_IEEE_REGEX_LEN);\n\tif (rc != 0) {\n\t\tpr_debug(\"XCOPY: skip non-matching: %*ph\\n\",\n\t\t\t XCOPY_NAA_IEEE_REGEX_LEN, tmp_dev_wwn);\n\t\treturn 0;\n\t}\n\tpr_debug(\"XCOPY 0xe4: located se_dev: %p\\n\", se_dev);\n\n\treturn 1;\n}",
        "output": "0",
        "idx": 2773
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);\n\tif (pipe) {\n\t\tpipe->bufs = kzalloc(sizeof(struct pipe_buffer) * PIPE_DEF_BUFFERS, GFP_KERNEL);\n\t\tif (pipe->bufs) {\n\t\t\tinit_waitqueue_head(&pipe->wait);\n\t\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\t\tpipe->buffers = PIPE_DEF_BUFFERS;\n\t\t\tmutex_init(&pipe->mutex);\n\t\t\treturn pipe;\n\t\t}\n\t\tkfree(pipe);\n\t}\n\n\treturn NULL;\n}",
        "output": "1",
        "idx": 1058
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\n\tif (dp->pos < 0 || dp->pos >= dp->realSize) {\n\t\treturn 0;\n\t}\n\n\tremain = dp->logicalSize - dp->pos;\n\tif(remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif(remain <= 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\trlen = remain;\n\t}\n\n\tif (dp->pos + rlen > dp->realSize) {\n\t\trlen = dp->realSize - dp->pos;\n\t}\n\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\n\treturn rlen;\n}",
        "output": "0",
        "idx": 6177
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error_t am335xEthAddVlanEntry(uint_t port, uint_t vlanId)\n{\n   error_t error;\n   uint_t index;\n   Am335xAleEntry entry;\n\n   index = am335xEthFindVlanEntry(vlanId);\n\n   if(index >= CPSW_ALE_MAX_ENTRIES)\n   {\n      index = am335xEthFindFreeEntry();\n   }\n\n   if(index < CPSW_ALE_MAX_ENTRIES)\n   {\n      entry.word2 = 0;\n      entry.word1 = CPSW_ALE_WORD1_ENTRY_TYPE_VLAN;\n      entry.word0 = 0;\n\n      entry.word1 |= CPSW_ALE_WORD1_VLAN_ID(vlanId);\n\n      entry.word0 |= CPSW_ALE_WORD0_FORCE_UNTAG_EGRESS(1 << port) |\n         CPSW_ALE_WORD0_FORCE_UNTAG_EGRESS(1 << CPSW_PORT0);\n\n      entry.word0 |= CPSW_ALE_WORD0_VLAN_MEMBER_LIST(1 << port) |\n         CPSW_ALE_WORD0_VLAN_MEMBER_LIST(1 << CPSW_PORT0);\n\n      am335xEthWriteEntry(index, &entry);\n\n      error = NO_ERROR;\n   }\n   else\n   {\n      error = ERROR_FAILURE;\n   }\n\n   return error;\n}",
        "output": "1",
        "idx": 8582
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_aead raead;\n\tstruct aead_alg *aead = &alg->cra_aead;\n\n\tstrncpy(raead.type, \"nivaead\", sizeof(raead.type));\n\tstrncpy(raead.geniv, aead->geniv, sizeof(raead.geniv));\n\n\traead.blocksize = alg->cra_blocksize;\n\traead.maxauthsize = aead->maxauthsize;\n\traead.ivsize = aead->ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,\n\t\t    sizeof(struct crypto_report_aead), &raead))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "0",
        "idx": 1173
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sd_ioctl(struct block_device *bdev, fmode_t mode,\n\t\t    unsigned int cmd, unsigned long arg)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct scsi_disk *sdkp = scsi_disk(disk);\n\tstruct scsi_device *sdp = sdkp->device;\n\tvoid __user *p = (void __user *)arg;\n\tint error;\n    \n\tSCSI_LOG_IOCTL(1, sd_printk(KERN_INFO, sdkp, \"sd_ioctl: disk=%s, \"\n\t\t\t\t    \"cmd=0x%x\\n\", disk->disk_name, cmd));\n\n\terror = scsi_verify_blk_ioctl(bdev, cmd);\n\tif (error < 0)\n\t\treturn error;\n\n\terror = scsi_nonblockable_ioctl(sdp, cmd, p,\n\t\t\t\t\t(mode & FMODE_NDELAY) != 0);\n\tif (!scsi_block_when_processing_errors(sdp) || !error)\n\t\tgoto out;\n\n\tswitch (cmd) {\n\t\tcase SCSI_IOCTL_GET_IDLUN:\n\t\tcase SCSI_IOCTL_GET_BUS_NUMBER:\n\t\t\terror = scsi_ioctl(sdp, cmd, p);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = scsi_cmd_blk_ioctl(bdev, mode, cmd, p);\n\t\t\tif (error != -ENOTTY)\n\t\t\t\tbreak;\n\t\t\terror = scsi_ioctl(sdp, cmd, p);\n\t\t\tbreak;\n\t}\nout:\n\treturn error;\n}",
        "output": "0",
        "idx": 863
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rtadv_read (struct thread *thread)\n{\n  int sock;\n  int len;\n  u_char buf[RTADV_MSG_SIZE];\n  struct sockaddr_in6 from;\n  ifindex_t ifindex = 0;\n  int hoplimit = -1;\n  struct zebra_vrf *zvrf = THREAD_ARG (thread);\n\n  sock = THREAD_FD (thread);\n  zvrf->rtadv.ra_read = NULL;\n\n  rtadv_event (zvrf, RTADV_READ, sock);\n\n  len = rtadv_recv_packet (sock, buf, BUFSIZ, &from, &ifindex, &hoplimit);\n\n  if (len < 0) \n    {\n      zlog_warn (\"router solicitation recv failed: %s.\", safe_strerror (errno));\n      return len;\n    }\n\n  rtadv_process_packet (buf, (unsigned)len, ifindex, hoplimit, zvrf->vrf_id);\n\n  return 0;\n}",
        "output": "1",
        "idx": 5674
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "test_js (void) {\n    GString *result = g_string_new(\"\");\n\n    parse_cmd_line(\"js ('x' + 345).toUpperCase()\", result);\n    g_assert_cmpstr(\"X345\", ==, result->str);\n\n    uzbl.net.useragent = \"Test useragent\";\n    parse_cmd_line(\"js Uzbl.run('print @useragent').toUpperCase();\", result);\n    g_assert_cmpstr(\"TEST USERAGENT\", ==, result->str);\n\n    g_string_free(result, TRUE);\n}",
        "output": "1",
        "idx": 3346
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << NM_VECTOR) | (1u << DB_VECTOR) | (1u << AC_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (enable_ept)\n\t\teb &= ~(1u << PF_VECTOR); \n\tif (vcpu->fpu_active)\n\t\teb &= ~(1u << NM_VECTOR);\n\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}",
        "output": "0",
        "idx": 1341
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,\n\t\t\t\t  int tlen, int offset)\n{\n\t__wsum csum = skb->csum;\n\n\tif (skb->ip_summed != CHECKSUM_COMPLETE)\n\t\treturn;\n\n\tif (offset != 0)\n\t\tcsum = csum_sub(csum,\n\t\t\t\tcsum_partial(skb_transport_header(skb) + tlen,\n\t\t\t\t\t     offset, 0));\n\n\tput_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &csum);\n}",
        "output": "1",
        "idx": 1486
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iperf_json_printf(const char *format, ...)\n{\n    cJSON* o;\n    va_list argp;\n    const char *cp;\n    char name[100];\n    char* np;\n    cJSON* j;\n\n    o = cJSON_CreateObject();\n    if (o == NULL)\n        return NULL;\n    va_start(argp, format);\n    np = name;\n    for (cp = format; *cp != '\\0'; ++cp) {\n\tswitch (*cp) {\n\t    case ' ':\n\t    break;\n\t    case ':':\n\t    *np = '\\0';\n\t    break;\n\t    case '%':\n\t    ++cp;\n\t    switch (*cp) {\n\t\tcase 'b':\n\t\tj = cJSON_CreateBool(va_arg(argp, int));\n\t\tbreak;\n\t\tcase 'd':\n\t\tj = cJSON_CreateInt(va_arg(argp, int64_t));\n\t\tbreak;\n\t\tcase 'f':\n\t\tj = cJSON_CreateFloat(va_arg(argp, double));\n\t\tbreak;\n\t\tcase 's':\n\t\tj = cJSON_CreateString(va_arg(argp, char *));\n\t\tbreak;\n\t\tdefault:\n\t\treturn NULL;\n\t    }\n\t    if (j == NULL)\n\t\treturn NULL;\n\t    cJSON_AddItemToObject(o, name, j);\n\t    np = name;\n\t    break;\n\t    default:\n\t    *np++ = *cp;\n\t    break;\n\t}\n    }\n    va_end(argp);\n    return o;\n}",
        "output": "1",
        "idx": 5970
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int ccid_hc_rx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid != NULL && ccid->ccid_ops->ccid_hc_rx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_rx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}",
        "output": "0",
        "idx": 1015
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vfio_msi_enable(struct vfio_pci_device *vdev, int nvec, bool msix)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tunsigned int flag = msix ? PCI_IRQ_MSIX : PCI_IRQ_MSI;\n\tint ret;\n\n\tif (!is_irq_none(vdev))\n\t\treturn -EINVAL;\n\n\tvdev->ctx = kcalloc(nvec, sizeof(struct vfio_pci_irq_ctx), GFP_KERNEL);\n\tif (!vdev->ctx)\n\t\treturn -ENOMEM;\n\n\tret = pci_alloc_irq_vectors(pdev, 1, nvec, flag);\n\tif (ret < nvec) {\n\t\tif (ret > 0)\n\t\t\tpci_free_irq_vectors(pdev);\n\t\tkfree(vdev->ctx);\n\t\treturn ret;\n\t}\n\n\tvdev->num_ctx = nvec;\n\tvdev->irq_type = msix ? VFIO_PCI_MSIX_IRQ_INDEX :\n\t\t\t\tVFIO_PCI_MSI_IRQ_INDEX;\n\n\tif (!msix) {\n\t\tvdev->msi_qmax = fls(nvec * 2 - 1) - 1;\n\t}\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1987
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int gasp_source_id(__be32 *p)\n{\n\treturn be32_to_cpu(p[0]) >> 16;\n}",
        "output": "0",
        "idx": 1997
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int fetchve(char ***argv, char ***envp)\n{\n\tchar *cmdline = NULL, *environ = NULL;\n\tsize_t cmdline_size, environ_size;\n\n\tcmdline = read_file(\"/proc/self/cmdline\", &cmdline_size);\n\tif (!cmdline)\n\t\tgoto error;\n\tenviron = read_file(\"/proc/self/environ\", &environ_size);\n\tif (!environ)\n\t\tgoto error;\n\n\tif (parse_xargs(cmdline, cmdline_size, argv) <= 0)\n\t\tgoto error;\n\tif (parse_xargs(environ, environ_size, envp) <= 0)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tfree(environ);\n\tfree(cmdline);\n\treturn -EINVAL;\n}",
        "output": "0",
        "idx": 8207
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)\n{\n\tif ((ctx->clockid == CLOCK_REALTIME ||\n\t     ctx->clockid == CLOCK_REALTIME_ALARM) &&\n\t    (flags & TFD_TIMER_ABSTIME) && (flags & TFD_TIMER_CANCEL_ON_SET)) {\n\t\tif (!ctx->might_cancel) {\n\t\t\tctx->might_cancel = true;\n\t\t\tspin_lock(&cancel_lock);\n\t\t\tlist_add_rcu(&ctx->clist, &cancel_list);\n\t\t\tspin_unlock(&cancel_lock);\n\t\t}\n\t} else if (ctx->might_cancel) {\n\t\ttimerfd_remove_cancel(ctx);\n\t}\n}",
        "output": "1",
        "idx": 1476
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void big_key_revoke(struct key *key)\n{\n\tstruct path *path = (struct path *)&key->payload.data[big_key_path];\n\n\tkey_payload_reserve(key, 0);\n\tif (key_is_positive(key) &&\n\t    (size_t)key->payload.data[big_key_len] > BIG_KEY_FILE_THRESHOLD)\n\t\tvfs_truncate(path, 0);\n}",
        "output": "0",
        "idx": 2481
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "batchCopyElem(batch_obj_t *pDest, batch_obj_t *pSrc) {\n\tmemset(pDest, 0, sizeof(batch_obj_t));\n\tpDest->pUsrp = pSrc->pUsrp;\n\tpDest->state = pSrc->state;\n}",
        "output": "0",
        "idx": 4723
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ntlm_write_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n{\n\tStream_Write(s, header->Signature, sizeof(NTLM_SIGNATURE));\n\tStream_Write_UINT32(s, header->MessageType);\n}",
        "output": "1",
        "idx": 4208
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void blendMode(HttpRoute *route, MprJson *config)\n{\n    MprJson     *currentMode, *app;\n    cchar       *mode;\n\n    mode = mprReadJson(config, \"app.mode\");\n    if (!mode) {\n        mode = sclone(\"debug\");\n    }\n    route->debug = smatch(mode, \"debug\");\n    if ((currentMode = mprReadJsonObj(config, sfmt(\"app.modes.%s\", mode))) != 0) {\n        app = mprReadJsonObj(config, \"app\");\n        mprBlendJson(app, currentMode, MPR_JSON_OVERWRITE);\n        mprWriteJson(app, \"app.mode\", mode);\n    }\n}",
        "output": "0",
        "idx": 7011
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {\n  packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,\n    packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,\n    packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,\n    packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,\n    packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,\n    packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,\n    packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->http_cookie.ptr = NULL,\n    packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,\n    packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,\n    packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,\n    packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0;\n}",
        "output": "1",
        "idx": 7888
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void iov_iter_pipe(struct iov_iter *i, int direction,\n\t\t\tstruct pipe_inode_info *pipe,\n\t\t\tsize_t count)\n{\n\tBUG_ON(direction != ITER_PIPE);\n\tWARN_ON(pipe->nrbufs == pipe->buffers);\n\ti->type = direction;\n\ti->pipe = pipe;\n\ti->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\ti->iov_offset = 0;\n\ti->count = count;\n}",
        "output": "0",
        "idx": 2093
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "local block_state deflate_huff(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    int bflush;             \n\n    for (;;) {\n        if (s->lookahead == 0) {\n            fill_window(s);\n            if (s->lookahead == 0) {\n                if (flush == Z_NO_FLUSH)\n                    return need_more;\n                break;      \n            }\n        }\n\n        s->match_length = 0;\n        Tracevv((stderr,\"%c\", s->window[s->strstart]));\n        _tr_tally_lit (s, s->window[s->strstart], bflush);\n        s->lookahead--;\n        s->strstart++;\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = 0;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->last_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}",
        "output": "1",
        "idx": 6088
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool may_move_pid(pid_t r, uid_t r_uid, pid_t v)\n{\n\tuid_t v_uid, tmpuid;\n\tgid_t v_gid;\n\n\tif (r == v)\n\t\treturn true;\n\tif (r_uid == 0)\n\t\treturn true;\n\tget_pid_creds(v, &v_uid, &v_gid);\n\tif (r_uid == v_uid)\n\t\treturn true;\n\tif (hostuid_to_ns(r_uid, r, &tmpuid) && tmpuid == 0\n\t\t\t&& hostuid_to_ns(v_uid, r, &tmpuid))\n\t\treturn true;\n\treturn false;\n}",
        "output": "0",
        "idx": 7317
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int perf_event_refresh(struct perf_event *event, int refresh)\n{\n\tstruct perf_event_context *ctx;\n\tint ret;\n\n\tctx = perf_event_ctx_lock(event);\n\tret = _perf_event_refresh(event, refresh);\n\tperf_event_ctx_unlock(event, ctx);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 3849
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int file_list_cpu(struct file *file)\n{\n#ifdef CONFIG_SMP\n\treturn file->f_sb_list_cpu;\n#else\n\treturn smp_processor_id();\n#endif\n}",
        "output": "1",
        "idx": 2386
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "wb_prep(netdissect_options *ndo,\n        const struct pkt_prep *prep, u_int len)\n{\n\tint n;\n\tconst struct pgstate *ps;\n\tconst u_char *ep = ndo->ndo_snapend;\n\n\tND_PRINT((ndo, \" wb-prep:\"));\n\tif (len < sizeof(*prep)) {\n\t\treturn (-1);\n\t}\n\tn = EXTRACT_32BITS(&prep->pp_n);\n\tps = (const struct pgstate *)(prep + 1);\n\twhile (--n >= 0 && ND_TTEST(*ps)) {\n\t\tconst struct id_off *io, *ie;\n\t\tchar c = '<';\n\n\t\tND_PRINT((ndo, \" %u/%s:%u\",\n\t\t    EXTRACT_32BITS(&ps->slot),\n\t\t    ipaddr_string(ndo, &ps->page.p_sid),\n\t\t    EXTRACT_32BITS(&ps->page.p_uid)));\n\t\tio = (struct id_off *)(ps + 1);\n\t\tfor (ie = io + ps->nid; io < ie && ND_TTEST(*io); ++io) {\n\t\t\tND_PRINT((ndo, \"%c%s:%u\", c, ipaddr_string(ndo, &io->id),\n\t\t\t    EXTRACT_32BITS(&io->off)));\n\t\t\tc = ',';\n\t\t}\n\t\tND_PRINT((ndo, \">\"));\n\t\tps = (struct pgstate *)io;\n\t}\n\treturn ((u_char *)ps <= ep? 0 : -1);\n}",
        "output": "0",
        "idx": 6523
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int iwch_cxgb3_ofld_send(struct t3cdev *tdev, struct sk_buff *skb)\n{\n\tint\terror = 0;\n\tstruct cxio_rdev *rdev;\n\n\trdev = (struct cxio_rdev *)tdev->ulp;\n\tif (cxio_fatal_error(rdev)) {\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\terror = cxgb3_ofld_send(tdev, skb);\n\tif (error < 0)\n\t\tkfree_skb(skb);\n\treturn error < 0 ? error : 0;\n}",
        "output": "0",
        "idx": 1483
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)\n{\n    PadContext *s = inlink->dst->priv;\n\n    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],\n                                         w + (s->w - s->in_w),\n                                         h + (s->h - s->in_h));\n    int plane;\n\n    if (!frame)\n        return NULL;\n\n    frame->width  = w;\n    frame->height = h;\n\n    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n        int hsub = s->draw.hsub[plane];\n        int vsub = s->draw.vsub[plane];\n        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +\n                              (s->y >> vsub) * frame->linesize[plane];\n    }\n\n    return frame;\n}",
        "output": "1",
        "idx": 3534
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "smtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args,\n    const char *domain)\n{\n\tchar   *p, *e;\n\n\tif (line == NULL)\n\t\treturn (0);\n\n\tif (*line != '<')\n\t\treturn (0);\n\n\te = strchr(line, '>');\n\tif (e == NULL)\n\t\treturn (0);\n\t*e++ = '\\0';\n\twhile (*e == ' ')\n\t\te++;\n\t*args = e;\n\n\tif (!text_to_mailaddr(maddr, line + 1))\n\t\treturn (0);\n\n\tp = strchr(maddr->user, ':');\n\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\n\tif (!valid_localpart(maddr->user) ||\n\t    !valid_domainpart(maddr->domain)) {\n\t\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\t\treturn (1);\n\n\t\tif (maddr->user[0] == '\\0')\n\t\t\treturn (0);\n\n\t\tif (maddr->domain[0] == '\\0') {\n\t\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\t    sizeof(maddr->domain));\n\t\t\treturn (1);\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (1);\n}",
        "output": "1",
        "idx": 5622
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ar6000_create_ap_interface(struct ar6_softc *ar, char *ap_ifname)\n{\n    struct net_device *dev;\n    struct ar_virtual_interface *arApDev;\n\n    dev = alloc_etherdev(sizeof(struct ar_virtual_interface));\n    if (dev == NULL) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_create_ap_interface: can't alloc etherdev\\n\"));\n        return A_ERROR;\n    } \n    \n    ether_setup(dev);\n    init_netdev(dev, ap_ifname);\n    dev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\n    if (register_netdev(dev)) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_create_ap_interface: register_netdev failed\\n\"));\n        return A_ERROR;\n    }\n\n    arApDev = netdev_priv(dev);\n    arApDev->arDev = ar;\n    arApDev->arNetDev = dev;\n    arApDev->arStaNetDev = ar->arNetDev;\n\n    ar->arApDev = arApDev;\n    arApNetDev = dev;\n\n    memcpy(dev->dev_addr, ar->arNetDev->dev_addr, AR6000_ETH_ADDR_LEN);\n\n    return 0;\n}",
        "output": "0",
        "idx": 759
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "grub_ext4_find_leaf (struct grub_ext2_data *data, char *buf,\n                     struct grub_ext4_extent_header *ext_block,\n                     grub_uint32_t fileblock)\n{\n  struct grub_ext4_extent_idx *index;\n\n  while (1)\n    {\n      int i;\n      grub_disk_addr_t block;\n\n      index = (struct grub_ext4_extent_idx *) (ext_block + 1);\n\n      if (grub_le_to_cpu16(ext_block->magic) != EXT4_EXT_MAGIC)\n        return 0;\n\n      if (ext_block->depth == 0)\n        return ext_block;\n\n      for (i = 0; i < grub_le_to_cpu16 (ext_block->entries); i++)\n        {\n          if (fileblock < grub_le_to_cpu32(index[i].block))\n            break;\n        }\n\n      if (--i < 0)\n        return 0;\n\n      block = grub_le_to_cpu16 (index[i].leaf_hi);\n      block = (block << 32) + grub_le_to_cpu32 (index[i].leaf);\n      if (grub_disk_read (data->disk,\n                          block << LOG2_EXT2_BLOCK_SIZE (data),\n                          0, EXT2_BLOCK_SIZE(data), buf))\n        return 0;\n\n      ext_block = (struct grub_ext4_extent_header *) buf;\n    }\n}",
        "output": "1",
        "idx": 6164
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "decode_sequence(const uint8_t *asn1, size_t len, const struct seq_info *seq,\n                void *val)\n{\n    krb5_error_code ret;\n    const uint8_t *contents;\n    size_t i, j, clen;\n    taginfo t;\n\n    assert(seq->n_fields > 0);\n    for (i = 0; i < seq->n_fields; i++) {\n        if (len == 0)\n            break;\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len, 0);\n        if (ret)\n            goto error;\n        for (; i < seq->n_fields; i++) {\n            if (check_atype_tag(seq->fields[i], &t))\n                break;\n            ret = omit_atype(seq->fields[i], val);\n            if (ret)\n                goto error;\n        }\n        if (i == seq->n_fields)\n            break;\n        ret = decode_atype(&t, contents, clen, seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    for (; i < seq->n_fields; i++) {\n        ret = omit_atype(seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    return 0;\n\nerror:\n    for (j = 0; j < i; j++)\n        free_atype(seq->fields[j], val);\n    for (j = 0; j < i; j++)\n        free_atype_ptr(seq->fields[j], val);\n    return ret;\n}",
        "output": "0",
        "idx": 309
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sraSpanRemove(sraSpan *span) {\n  span->_prev->_next = span->_next;\n  span->_next->_prev = span->_prev;\n}",
        "output": "1",
        "idx": 6360
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ipt_get_target_c(s);\n\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\n\t\tif (s->target_offset == sizeof(struct ipt_entry) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t   t->verdict < 0 &&\n\t\t   unconditional(&s->ip)) {\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1190
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void addFormVars(cchar *buf)\n{\n    char    *pair, *tok;\n\n    pair = stok(sclone(buf), \"&\", &tok);\n    while (pair) {\n        mprAddItem(app->formData, sclone(pair));\n        pair = stok(0, \"&\", &tok);\n    }\n}",
        "output": "0",
        "idx": 6985
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int perf_trace_event_perm(struct ftrace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tif (ftrace_event_is_function(tp_event) &&\n\t    perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))\n\t\treturn 0;\n\n\tif (p_event->attach_state == PERF_ATTACH_TASK) {\n\t\tif (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)\n\t\t\treturn 0;\n\t}\n\n\tif (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 3357
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "compile_get_env(char_u **arg, cctx_T *cctx)\n{\n    char_u\t*start = *arg;\n    int\t\tlen;\n    int\t\tret;\n    char_u\t*name;\n\n    ++*arg;\n    len = get_env_len(arg);\n    if (len == 0)\n    {\n\tsemsg(_(e_syntax_error_at_str), start);\n\treturn FAIL;\n    }\n\n    name = vim_strnsave(start, len + 1);\n    ret = generate_LOAD(cctx, ISN_LOADENV, 0, name, &t_string);\n    vim_free(name);\n    return ret;\n}",
        "output": "0",
        "idx": 7953
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *get_pid_environ_val(pid_t pid,char *val){\n  int temp_size = 500;\n  char *temp = malloc(temp_size);\n  \n  int i=0;\n  int foundit=0;\n  FILE *fp;\n\n  sprintf(temp,\"/proc/%d/environ\",pid);\n\n  fp=fopen(temp,\"r\");\n  if(fp==NULL)\n    return NULL;\n\n  \n  for(;;){\n    \n    if (i >= temp_size) {\n      temp_size *= 2;\n      temp = realloc(temp, temp_size);\n    }\n      \n    temp[i]=fgetc(fp);    \n\n    if(foundit==1 && (temp[i]==0 || temp[i]=='\\0' || temp[i]==EOF)){\n      char *ret;\n      temp[i]=0;\n      ret=malloc(strlen(temp)+10);\n      sprintf(ret,\"%s\",temp);\n      fclose(fp);\n      return ret;\n    }\n\n    switch(temp[i]){\n    case EOF:\n      fclose(fp);\n      return NULL;\n    case '=':\n      temp[i]=0;\n      if(!strcmp(temp,val)){\n\tfoundit=1;\n      }\n      i=0;\n      break;\n    case '\\0':\n      i=0;\n      break;\n    default:\n      i++;\n    }\n  }\n}",
        "output": "0",
        "idx": 7331
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "max3421_set_address(struct usb_hcd *hcd, struct usb_device *dev, int epnum)\n{\n\tint rcvtog, sndtog;\n\tu8 hctl;\n\n\trcvtog = usb_gettoggle(dev, epnum, 0);\n\tsndtog = usb_gettoggle(dev, epnum, 1);\n\thctl = (BIT(rcvtog + MAX3421_HCTL_RCVTOG0_BIT) |\n\t\tBIT(sndtog + MAX3421_HCTL_SNDTOG0_BIT));\n\n\tspi_wr8(hcd, MAX3421_REG_HCTL, hctl);\n\n\tspi_wr8(hcd, MAX3421_REG_PERADDR, dev->devnum);\n}",
        "output": "0",
        "idx": 2829
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int nntp_add_group(char *line, void *data)\n{\n  struct NntpServer *nserv = data;\n  struct NntpData *nntp_data = NULL;\n  char group[LONG_STRING];\n  char desc[HUGE_STRING] = \"\";\n  char mod;\n  anum_t first, last;\n\n  if (!nserv || !line)\n    return 0;\n\n  if (sscanf(line, \"%s \" ANUM \" \" ANUM \" %c %[^\\n]\", group, &last, &first, &mod, desc) < 4)\n    return 0;\n\n  nntp_data = nntp_data_find(nserv, group);\n  nntp_data->deleted = false;\n  nntp_data->first_message = first;\n  nntp_data->last_message = last;\n  nntp_data->allowed = (mod == 'y') || (mod == 'm');\n  mutt_str_replace(&nntp_data->desc, desc);\n  if (nntp_data->newsrc_ent || nntp_data->last_cached)\n    nntp_group_unread_stat(nntp_data);\n  else if (nntp_data->last_message && nntp_data->first_message <= nntp_data->last_message)\n    nntp_data->unread = nntp_data->last_message - nntp_data->first_message + 1;\n  else\n    nntp_data->unread = 0;\n  return 0;\n}",
        "output": "1",
        "idx": 6960
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int seed_from_urandom(uint32_t *seed) {\n\n    char data[sizeof(uint32_t)];\n    int ok;\n\n#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)\n    int urandom;\n    urandom = open(\"/dev/urandom\", O_RDONLY);\n    if (urandom == -1)\n        return 1;\n\n    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);\n    close(urandom);\n#else\n    FILE *urandom;\n\n    urandom = fopen(\"/dev/urandom\", \"rb\");\n    if (!urandom)\n        return 1;\n\n    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);\n    fclose(urandom);\n#endif\n\n    if (!ok)\n        return 1;\n\n    *seed = buf_to_uint32(data);\n    return 0;\n}",
        "output": "0",
        "idx": 5983
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct usb_host_interface *uas_find_uas_alt_setting(\n\t\tstruct usb_interface *intf)\n{\n\tint i;\n\n\tfor (i = 0; i < intf->num_altsetting; i++) {\n\t\tstruct usb_host_interface *alt = &intf->altsetting[i];\n\n\t\tif (uas_is_interface(alt))\n\t\t\treturn alt;\n\t}\n\n\treturn NULL;\n}",
        "output": "0",
        "idx": 2413
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rose_start_t3timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tdel_timer(&rose->timer);\n\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t3;\n\n\tadd_timer(&rose->timer);\n}",
        "output": "1",
        "idx": 2060
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n\tstruct sock *sk2;\n\tstruct alg_sock *ask2;\n\tstruct hash_ctx *ctx2;\n\tbool more;\n\tint err;\n\n\tlock_sock(sk);\n\tmore = ctx->more;\n\terr = more ? crypto_ahash_export(req, state) : 0;\n\trelease_sock(sk);\n\n\tif (err)\n\t\treturn err;\n\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\n\tsk2 = newsock->sk;\n\task2 = alg_sk(sk2);\n\tctx2 = ask2->private;\n\tctx2->more = more;\n\n\tif (!more)\n\t\treturn err;\n\n\terr = crypto_ahash_import(&ctx2->req, state);\n\tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\n\treturn err;\n}",
        "output": "0",
        "idx": 4057
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mm_answer_pam_free_ctx(int sock, Buffer *m)\n{\n\n\tdebug3(\"%s\", __func__);\n\t(sshpam_device.free_ctx)(sshpam_ctxt);\n\tbuffer_clear(m);\n\tmm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);\n\tauth_method = \"keyboard-interactive\";\n\tauth_submethod = \"pam\";\n\treturn (sshpam_authok == sshpam_ctxt);\n}",
        "output": "1",
        "idx": 5466
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bt_for_each(struct blk_mq_hw_ctx *hctx,\n\t\tstruct blk_mq_bitmap_tags *bt, unsigned int off,\n\t\tbusy_iter_fn *fn, void *data, bool reserved)\n{\n\tstruct request *rq;\n\tint bit, i;\n\n\tfor (i = 0; i < bt->map_nr; i++) {\n\t\tstruct blk_align_bitmap *bm = &bt->map[i];\n\n\t\tfor (bit = find_first_bit(&bm->word, bm->depth);\n\t\t     bit < bm->depth;\n\t\t     bit = find_next_bit(&bm->word, bm->depth, bit + 1)) {\n\t\t     \trq = blk_mq_tag_to_rq(hctx->tags, off + bit);\n\t\t\tif (rq->q == hctx->queue)\n\t\t\t\tfn(hctx, rq, data, reserved);\n\t\t}\n\n\t\toff += (1 << bt->bits_per_word);\n\t}\n}",
        "output": "1",
        "idx": 2892
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cil_reset_perm(struct cil_perm *perm)\n{\n\tcil_reset_classperms_list(perm->classperms);\n}",
        "output": "1",
        "idx": 6046
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void nfs4_close_sync(struct path *path, struct nfs4_state *state, fmode_t fmode)\n{\n\t__nfs4_close(path, state, fmode, 1);\n}",
        "output": "0",
        "idx": 3083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_be_short (SF_PRIVATE *psf, int x)\n{\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n\tpsf->header.ptr [psf->header.indx++] = x ;\n} ",
        "output": "0",
        "idx": 6903
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\n\tget_futex_key_refs(&q->key);\n\thb = hash_futex(&q->key);\n\tq->lock_ptr = &hb->lock;\n\n\tspin_lock(&hb->lock);\n\treturn hb;\n}",
        "output": "1",
        "idx": 232
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int netdev_printk(const char *level, const struct net_device *dev,\n\t\t  const char *format, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint r;\n\n\tva_start(args, format);\n\n\tvaf.fmt = format;\n\tvaf.va = &args;\n\n\tr = __netdev_printk(level, dev, &vaf);\n\tva_end(args);\n\n\treturn r;\n}",
        "output": "0",
        "idx": 325
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_report_kpp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_kpp rkpp;\n\n\tstrlcpy(rkpp.type, \"kpp\", sizeof(rkpp.type));\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_KPP,\n\t\t    sizeof(struct crypto_report_kpp), &rkpp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "1",
        "idx": 3028
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parsegid(const char *s, gid_t *gid)\n{\n\tstruct group *gr;\n\tconst char *errstr;\n\n\tif ((gr = getgrnam(s)) != NULL) {\n\t\t*gid = gr->gr_gid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*gid = strtonum(s, 0, GID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", gid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}",
        "output": "1",
        "idx": 7518
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int n_tty_ioctl(struct tty_struct *tty, struct file *file,\n\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint retval;\n\n\tswitch (cmd) {\n\tcase TIOCOUTQ:\n\t\treturn put_user(tty_chars_in_buffer(tty), (int __user *) arg);\n\tcase TIOCINQ:\n\t\tdown_write(&tty->termios_rwsem);\n\t\tif (L_ICANON(tty))\n\t\t\tretval = inq_canon(ldata);\n\t\telse\n\t\t\tretval = read_cnt(ldata);\n\t\tup_write(&tty->termios_rwsem);\n\t\treturn put_user(retval, (unsigned int __user *) arg);\n\tdefault:\n\t\treturn n_tty_ioctl_helper(tty, file, cmd, arg);\n\t}\n}",
        "output": "1",
        "idx": 1812
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void f_parser (lua_State *L, void *ud) {\n  int i;\n  Proto *tf;\n  Closure *cl;\n  struct SParser *p = cast(struct SParser *, ud);\n  int c = luaZ_lookahead(p->z);\n  luaC_checkGC(L);\n  tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p->z,\n                                                             &p->buff, p->name);\n  cl = luaF_newLclosure(L, tf->nups, hvalue(gt(L)));\n  cl->l.p = tf;\n  for (i = 0; i < tf->nups; i++)  \n    cl->l.upvals[i] = luaF_newupval(L);\n  setclvalue(L, L->top, cl);\n  incr_top(L);\n}",
        "output": "1",
        "idx": 3638
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "copy_thread(unsigned long clone_flags, unsigned long stack_start,\n\t    unsigned long stk_sz, struct task_struct *p)\n{\n\tstruct thread_info *thread = task_thread_info(p);\n\tstruct pt_regs *childregs = task_pt_regs(p);\n\n\tmemset(&thread->cpu_context, 0, sizeof(struct cpu_context_save));\n\n\tif (likely(!(p->flags & PF_KTHREAD))) {\n\t\t*childregs = *current_pt_regs();\n\t\tchildregs->ARM_r0 = 0;\n\t\tif (stack_start)\n\t\t\tchildregs->ARM_sp = stack_start;\n\t} else {\n\t\tmemset(childregs, 0, sizeof(struct pt_regs));\n\t\tthread->cpu_context.r4 = stk_sz;\n\t\tthread->cpu_context.r5 = stack_start;\n\t\tchildregs->ARM_cpsr = SVC_MODE;\n\t}\n\tthread->cpu_context.pc = (unsigned long)ret_from_fork;\n\tthread->cpu_context.sp = (unsigned long)childregs;\n\n\tclear_ptrace_hw_breakpoint(p);\n\n\tif (clone_flags & CLONE_SETTLS)\n\t\tthread->tp_value = childregs->ARM_r3;\n\n\tthread_notify(THREAD_NOTIFY_COPY, thread);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 2298
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline key_ref_t __key_update(key_ref_t key_ref,\n\t\t\t\t     struct key_preparsed_payload *prep)\n{\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = -EEXIST;\n\tif (!key->type->update)\n\t\tgoto error;\n\n\tdown_write(&key->sem);\n\n\tret = key->type->update(key, prep);\n\tif (ret == 0)\n\t\tmark_key_instantiated(key, 0);\n\n\tup_write(&key->sem);\n\n\tif (ret < 0)\n\t\tgoto error;\nout:\n\treturn key_ref;\n\nerror:\n\tkey_put(key);\n\tkey_ref = ERR_PTR(ret);\n\tgoto out;\n}",
        "output": "0",
        "idx": 2489
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "zfs_fuid_map_id(zfsvfs_t *zfsvfs, uint64_t fuid,\n    cred_t *cr, zfs_fuid_type_t type)\n{\n#ifdef HAVE_KSID\n\tuint32_t index = FUID_INDEX(fuid);\n\tconst char *domain;\n\tuid_t id;\n\n\tif (index == 0)\n\t\treturn (fuid);\n\n\tdomain = zfs_fuid_find_by_idx(zfsvfs, index);\n\tASSERT(domain != NULL);\n\n\tif (type == ZFS_OWNER || type == ZFS_ACE_USER) {\n\t\t(void) kidmap_getuidbysid(crgetzone(cr), domain,\n\t\t    FUID_RID(fuid), &id);\n\t} else {\n\t\t(void) kidmap_getgidbysid(crgetzone(cr), domain,\n\t\t    FUID_RID(fuid), &id);\n\t}\n\treturn (id);\n#else\n\treturn (fuid);\n#endif \n}",
        "output": "1",
        "idx": 8236
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, int mode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *pos, *ctx = NULL;\n\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(pos, &nfsi->open_files, list) {\n\t\tif (cred != NULL && pos->cred != cred)\n\t\t\tcontinue;\n\t\tif ((pos->mode & mode) == mode) {\n\t\t\tctx = get_nfs_open_context(pos);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn ctx;\n}",
        "output": "1",
        "idx": 2112
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int gup_huge_pgd(pgd_t orig, pgd_t *pgdp, unsigned long addr,\n\t\t\tunsigned long end, int write,\n\t\t\tstruct page **pages, int *nr)\n{\n\tint refs;\n\tstruct page *head, *page;\n\n\tif (!pgd_access_permitted(orig, write))\n\t\treturn 0;\n\n\tBUILD_BUG_ON(pgd_devmap(orig));\n\trefs = 0;\n\tpage = pgd_page(orig) + ((addr & ~PGDIR_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\thead = try_get_compound_head(pgd_page(orig), refs);\n\tif (!head) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(pgd_val(orig) != pgd_val(*pgdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\n\tSetPageReferenced(head);\n\treturn 1;\n}",
        "output": "0",
        "idx": 4345
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (unlikely(atomic_read(&modifying_ftrace_code)) &&\n\t    ftrace_int3_handler(regs))\n\t\treturn;\n#endif\n\tif (poke_int3_handler(regs))\n\t\treturn;\n\n\tist_enter(regs);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n#ifdef CONFIG_KGDB_LOW_LEVEL_TRAP\n\tif (kgdb_ll_trap(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n#endif \n\n#ifdef CONFIG_KPROBES\n\tif (kprobe_int3_handler(regs))\n\t\tgoto exit;\n#endif\n\n\tif (notify_die(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n\n\tdebug_stack_usage_inc();\n\tcond_local_irq_enable(regs);\n\tdo_trap(X86_TRAP_BP, SIGTRAP, \"int3\", regs, error_code, NULL);\n\tcond_local_irq_disable(regs);\n\tdebug_stack_usage_dec();\nexit:\n\tist_exit(regs);\n}",
        "output": "1",
        "idx": 2940
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int netlbl_cipsov4_add_common(struct genl_info *info,\n\t\t\t\t     struct cipso_v4_doi *doi_def)\n{\n\tstruct nlattr *nla;\n\tint nla_rem;\n\tu32 iter = 0;\n\n\tdoi_def->doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\n\tif (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_TAGLST],\n\t\t\t\tNLBL_CIPSOV4_A_MAX,\n\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)\n\t\tif (nla->nla_type == NLBL_CIPSOV4_A_TAG) {\n\t\t\tif (iter > CIPSO_V4_TAG_MAXCNT)\n\t\t\t\treturn -EINVAL;\n\t\t\tdoi_def->tags[iter++] = nla_get_u8(nla);\n\t\t}\n\tif (iter < CIPSO_V4_TAG_MAXCNT)\n\t\tdoi_def->tags[iter] = CIPSO_V4_TAG_INVALID;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 2070
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rose_stop_heartbeat(struct sock *sk)\n{\n\tsk_stop_timer(sk, &sk->sk_timer);\n}",
        "output": "0",
        "idx": 2953
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void test_simple()\n{\n    json_set_alloc_funcs(my_malloc, my_free);\n    create_and_free_complex_object();\n\n    if(malloc_called != 20 || free_called != 20)\n        fail(\"Custom allocation failed\");\n}",
        "output": "1",
        "idx": 4328
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n        p_code_block)\n{\n    OPJ_UINT32 l_data_size;\n\n    /* +1 is needed for https:\n    /* and actually +2 required for https:\n    l_data_size = 2 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n                                   (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n\n    if (l_data_size > p_code_block->data_size) {\n        if (p_code_block->data) {\n            opj_free(p_code_block->data - 1);\n        }\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1);\n        if (! p_code_block->data) {\n            p_code_block->data_size = 0U;\n            return OPJ_FALSE;\n        }\n        p_code_block->data_size = l_data_size;\n\n        p_code_block->data[0] = 0;\n        p_code_block->data += 1; \n    }\n    return OPJ_TRUE;\n}",
        "output": "0",
        "idx": 7747
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(DirectoryIterator, next)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tint skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern->u.dir.index++;\n\tdo {\n\t\tspl_filesystem_dir_read(intern TSRMLS_CC);\n\t} while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n\tif (intern->file_name) {\n\t\tefree(intern->file_name);\n\t\tintern->file_name = NULL;\n\t}\n}",
        "output": "0",
        "idx": 5541
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __detach_mounts(struct dentry *dentry)\n{\n\tstruct mountpoint *mp;\n\tstruct mount *mnt;\n\n\tnamespace_lock();\n\tmp = lookup_mountpoint(dentry);\n\tif (IS_ERR_OR_NULL(mp))\n\t\tgoto out_unlock;\n\n\tlock_mount_hash();\n\twhile (!hlist_empty(&mp->m_list)) {\n\t\tmnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);\n\t\tif (mnt->mnt.mnt_flags & MNT_UMOUNT) {\n\t\t\tstruct mount *p, *tmp;\n\t\t\tlist_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {\n\t\t\t\thlist_add_head(&p->mnt_umount.s_list, &unmounted);\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\telse umount_tree(mnt, UMOUNT_CONNECTED);\n\t}\n\tunlock_mount_hash();\n\tput_mountpoint(mp);\nout_unlock:\n\tnamespace_unlock();\n}",
        "output": "0",
        "idx": 3913
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ceph_crypt(const struct ceph_crypto_key *key, bool encrypt,\n\t       void *buf, int buf_len, int in_len, int *pout_len)\n{\n\tswitch (key->type) {\n\tcase CEPH_CRYPTO_NONE:\n\t\t*pout_len = in_len;\n\t\treturn 0;\n\tcase CEPH_CRYPTO_AES:\n\t\treturn ceph_aes_crypt(key, encrypt, buf, buf_len, in_len,\n\t\t\t\t      pout_len);\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}",
        "output": "0",
        "idx": 2045
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\tret = key_read_state(key);\n\tif (ret < 0)\n\t\tgoto error2; \n\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error2;\n\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\n\ncan_read_key:\n\tret = -EOPNOTSUPP;\n\tif (key->type->read) {\n\t\tdown_read(&key->sem);\n\t\tret = key_validate(key);\n\t\tif (ret == 0)\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\tup_read(&key->sem);\n\t}\n\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}",
        "output": "0",
        "idx": 2499
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h);\n\tsize_t pos = CDF_SHORT_SEC_POS(h, id);\n\tassert(ss == len);\n\tif (pos + len > CDF_SEC_SIZE(h) * sst->sst_len) {\n\t\tDPRINTF((\"Out of bounds read %\" SIZE_T_FORMAT \"u > %\"\n\t\t    SIZE_T_FORMAT \"u\\n\",\n\t\t    pos + len, CDF_SEC_SIZE(h) * sst->sst_len));\n\t\treturn -1;\n\t}\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + pos, len);\n\treturn len;\n}",
        "output": "0",
        "idx": 6079
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char* getPreferredTag(const char* gf_tag)\n{\n\tchar* result = NULL;\n\tint grOffset = 0;\n\n\tgrOffset = findOffset( LOC_GRANDFATHERED ,gf_tag);\n\tif(grOffset < 0) {\n\t\treturn NULL;\n\t}\n\tif( grOffset < LOC_PREFERRED_GRANDFATHERED_LEN ){\n\t\tresult = estrdup( LOC_PREFERRED_GRANDFATHERED[grOffset] );\n\t} else {\n\t\tresult = estrdup( LOC_GRANDFATHERED[grOffset] );\n\t}\n\treturn result;\n}",
        "output": "0",
        "idx": 5401
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int su3000_power_ctrl(struct dvb_usb_device *d, int i)\n{\n\tstruct dw2102_state *state = (struct dw2102_state *)d->priv;\n\tu8 obuf[] = {0xde, 0};\n\n\tinfo(\"%s: %d, initialized %d\", __func__, i, state->initialized);\n\n\tif (i && !state->initialized) {\n\t\tstate->initialized = 1;\n\t\treturn dvb_usb_generic_rw(d, obuf, 2, NULL, 0, 0);\n\t}\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1508
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mif_validate(jas_stream_t *in)\n{\n\tjas_uchar buf[MIF_MAGICLEN];\n\tuint_fast32_t magic;\n\tint i;\n\tint n;\n\n\tassert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);\n\n\tif ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {\n\t\treturn -1;\n\t}\n\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (n < MIF_MAGICLEN) {\n\t\treturn -1;\n\t}\n\n\tmagic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |\n\t  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |\n\t  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |\n\t  buf[3];\n\n\tif (magic != MIF_MAGIC) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 7583
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\n\tremain = dp->logicalSize - dp->pos;\n\tif(remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif(remain <= 0) {\n\t\t\treturn 0; \n\t\t}\n\n\t\trlen = remain;\n\t}\n\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\n\treturn rlen;\n}",
        "output": "0",
        "idx": 6169
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)\n{\n\tlong tmp = atomic_long_cmpxchg(&sem->count, *old, new);\n\tif (tmp == *old) {\n\t\t*old = new;\n\t\treturn 1;\n\t} else {\n\t\t*old = tmp;\n\t\treturn 0;\n\t}\n}",
        "output": "0",
        "idx": 3435
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ext4_end_io_dio(struct kiocb *iocb, loff_t offset,\n\t\t\t    ssize_t size, void *private)\n{\n        ext4_io_end_t *io_end = iocb->private;\n\tstruct workqueue_struct *wq;\n\n\tif (!io_end || !size)\n\t\treturn;\n\n\text_debug(\"ext4_end_io_dio(): io_end 0x%p\"\n\t\t  \"for inode %lu, iocb 0x%p, offset %llu, size %llu\\n\",\n \t\t  iocb->private, io_end->inode->i_ino, iocb, offset,\n\t\t  size);\n\n\tif (io_end->flag != EXT4_IO_UNWRITTEN){\n\t\text4_free_io_end(io_end);\n\t\tiocb->private = NULL;\n\t\treturn;\n\t}\n\n\tio_end->offset = offset;\n\tio_end->size = size;\n\twq = EXT4_SB(io_end->inode->i_sb)->dio_unwritten_wq;\n\n\tqueue_work(wq, &io_end->work);\n\n\tlist_add_tail(&io_end->list,\n\t\t &EXT4_I(io_end->inode)->i_completed_io_list);\n\tiocb->private = NULL;\n}",
        "output": "1",
        "idx": 2234
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ikev2_ke_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_ke ke;\n\tconst struct ikev2_ke *k;\n\n\tk = (const struct ikev2_ke *)ext;\n\tND_TCHECK(*k);\n\tUNALIGNED_MEMCPY(&ke, ext, sizeof(ke));\n\tikev2_pay_print(ndo, NPSTR(tpay), ke.h.critical);\n\n\tND_PRINT((ndo,\" len=%u group=%s\", ntohs(ke.h.len) - 8,\n\t\t  STR_OR_ID(ntohs(ke.ke_group), dh_p_map)));\n\n\tif (2 < ndo->ndo_vflag && 8 < ntohs(ke.h.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(k + 1), ntohs(ke.h.len) - 8))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(ke.h.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}",
        "output": "0",
        "idx": 6815
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char _x2c(char *hex) {\n        register char digit;\n        digit = ((hex[0] >= 'A') ? ((hex[0] & 0xdf) - 'A')+10 : (hex[0] - '0'));\n        digit *= 16;\n        digit += (hex[1] >= 'A' ? ((hex[1] & 0xdf) - 'A')+10 : (hex[1] - '0'));\n        return(digit);\n}",
        "output": "0",
        "idx": 8447
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parse_wcc_attr(netdissect_options *ndo,\n               const uint32_t *dp)\n{\n\tND_PRINT((ndo, \" sz %\" PRIu64, EXTRACT_64BITS(&dp[0])));\n\tND_PRINT((ndo, \" mtime %u.%06u ctime %u.%06u\",\n\t       EXTRACT_32BITS(&dp[2]), EXTRACT_32BITS(&dp[3]),\n\t       EXTRACT_32BITS(&dp[4]), EXTRACT_32BITS(&dp[5])));\n\treturn (dp + 6);\n}",
        "output": "0",
        "idx": 6569
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif ((svm->vcpu.arch.hflags & (HF_NMI_MASK | HF_IRET_MASK))\n\t    == HF_NMI_MASK)\n\t\treturn; \n\n\tsvm->nmi_singlestep = true;\n\tsvm->vmcb->save.rflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n\tupdate_db_bp_intercept(vcpu);\n}",
        "output": "1",
        "idx": 922
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\n\tint dumpable = 0;\n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\ttcred = __task_cred(task);\n\tif (uid_eq(cred->uid, tcred->euid) &&\n\t    uid_eq(cred->uid, tcred->suid) &&\n\t    uid_eq(cred->uid, tcred->uid)  &&\n\t    gid_eq(cred->gid, tcred->egid) &&\n\t    gid_eq(cred->gid, tcred->sgid) &&\n\t    gid_eq(cred->gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tsmp_rmb();\n\tif (task->mm)\n\t\tdumpable = get_dumpable(task->mm);\n\trcu_read_lock();\n\tif (dumpable != SUID_DUMP_USER &&\n\t    !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\trcu_read_unlock();\n\n\treturn security_ptrace_access_check(task, mode);\n}",
        "output": "0",
        "idx": 3365
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ref_list_remove_element (RefQueueEntry **prev, RefQueueEntry *element)\n{\n\tdo {\n\t\twhile (*prev != element)\n\t\t\tprev = &(*prev)->next;\n\t} while (prev && InterlockedCompareExchangePointer ((void*)prev, element->next, element) != element);\n}",
        "output": "0",
        "idx": 4703
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static enum count_type __read_io_type(struct page *page)\n{\n\tstruct address_space *mapping = page_file_mapping(page);\n\n\tif (mapping) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\n\t\tif (inode->i_ino == F2FS_META_INO(sbi))\n\t\t\treturn F2FS_RD_META;\n\n\t\tif (inode->i_ino == F2FS_NODE_INO(sbi))\n\t\t\treturn F2FS_RD_NODE;\n\t}\n\treturn F2FS_RD_DATA;\n}",
        "output": "0",
        "idx": 4427
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long ZEXPORT inflateMark(strm)\nz_streamp strm;\n{\n    struct inflate_state FAR *state;\n\n    if (strm == Z_NULL || strm->state == Z_NULL)\n        return (long)(((unsigned long)0 - 1) << 16);\n    state = (struct inflate_state FAR *)strm->state;\n    return (long)(((unsigned long)((long)state->back)) << 16) +\n        (state->mode == COPY ? state->length :\n            (state->mode == MATCH ? state->was - state->length : 0));\n}",
        "output": "0",
        "idx": 8541
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void do_perf_sw_event(enum perf_type_id type, u32 event_id,\n\t\t\t\t    u64 nr, int nmi,\n\t\t\t\t    struct perf_sample_data *data,\n\t\t\t\t    struct pt_regs *regs)\n{\n\tstruct swevent_htable *swhash = &__get_cpu_var(swevent_htable);\n\tstruct perf_event *event;\n\tstruct hlist_node *node;\n\tstruct hlist_head *head;\n\n\trcu_read_lock();\n\thead = find_swevent_head_rcu(swhash, type, event_id);\n\tif (!head)\n\t\tgoto end;\n\n\thlist_for_each_entry_rcu(event, node, head, hlist_entry) {\n\t\tif (perf_swevent_match(event, type, event_id, data, regs))\n\t\t\tperf_swevent_event(event, nr, nmi, data, regs);\n\t}\nend:\n\trcu_read_unlock();\n}",
        "output": "1",
        "idx": 526
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "search_make_new(const struct search_state *const state, int n, const char *const base_name) {\n\tconst size_t base_len = strlen(base_name);\n\tchar need_to_append_dot;\n\tstruct search_domain *dom;\n\n\tif (!base_len) return NULL;\n\tneed_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;\n\n\tfor (dom = state->head; dom; dom = dom->next) {\n\t\tif (!n--) {\n\t\t\tconst u8 *const postfix = ((u8 *) dom) + sizeof(struct search_domain);\n\t\t\tconst int postfix_len = dom->len;\n\t\t\tchar *const newname = (char *) mm_malloc(base_len + need_to_append_dot + postfix_len + 1);\n\t\t\tif (!newname) return NULL;\n\t\t\tmemcpy(newname, base_name, base_len);\n\t\t\tif (need_to_append_dot) newname[base_len] = '.';\n\t\t\tmemcpy(newname + base_len + need_to_append_dot, postfix, postfix_len);\n\t\t\tnewname[base_len + need_to_append_dot + postfix_len] = 0;\n\t\t\treturn newname;\n\t\t}\n\t}\n\n\tEVUTIL_ASSERT(0);\n\treturn NULL; \n}",
        "output": "0",
        "idx": 7857
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "horDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\tTIFFPredictorState* sp = PredictorState(tif);\n\ttmsize_t stride = sp->stride;\n\tuint32 *wp = (uint32*) cp0;\n\ttmsize_t wc = cc/4;\n\n\tassert((cc%(4*stride))==0);\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\twp += wc - 1;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] -= wp[0]; wp--)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n}",
        "output": "1",
        "idx": 4262
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_le_int (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\t} ;\n} ",
        "output": "1",
        "idx": 4934
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int stv06xx_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\tint err, packet_size;\n\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\terr = stv06xx_write_bridge(sd, STV_ISO_SIZE_L, packet_size);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = sd->sensor->start(sd);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = stv06xx_write_bridge(sd, STV_ISO_ENABLE, 1);\n\nout:\n\tif (err < 0)\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Starting stream failed\\n\");\n\telse\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Started streaming\\n\");\n\n\treturn (err < 0) ? err : 0;\n}",
        "output": "0",
        "idx": 4619
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void request_key_auth_describe(const struct key *key,\n\t\t\t\t      struct seq_file *m)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\n\tseq_puts(m, \"key:\");\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);\n}",
        "output": "1",
        "idx": 1740
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Jsi_RC NumberToExponentialCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<0) prec = 0;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf), \"%.*\" JSI_NUMEFMT, prec, num);\n#ifdef __WIN32\n    char *e = strrchr(buf, 'e');\n    if (e && (e[1]=='+' || e[1]=='-')) {\n        e++;\n        int eNum = atoi(e);\n        if (e[0]=='-')\n            eNum = -eNum;\n        e++;\n        snprintf(e, (e-buf), \"%02d\", eNum);\n    }\n#endif\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}",
        "output": "1",
        "idx": 8198
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "read_pbm_integer(j_compress_ptr cinfo, FILE *infile, unsigned int maxval)\n{\n  register int ch;\n  register unsigned int val;\n\n  do {\n    ch = pbm_getc(infile);\n    if (ch == EOF)\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n  } while (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\r');\n\n  if (ch < '0' || ch > '9')\n    ERREXIT(cinfo, JERR_PPM_NONNUMERIC);\n\n  val = ch - '0';\n  while ((ch = pbm_getc(infile)) >= '0' && ch <= '9') {\n    val *= 10;\n    val += ch - '0';\n  }\n\n  if (val > maxval)\n    ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n\n  return val;\n}",
        "output": "1",
        "idx": 6750
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ffs_user_copy_worker(struct work_struct *work)\n{\n\tstruct ffs_io_data *io_data = container_of(work, struct ffs_io_data,\n\t\t\t\t\t\t   work);\n\tint ret = io_data->req->status ? io_data->req->status :\n\t\t\t\t\t io_data->req->actual;\n\tbool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;\n\n\tif (io_data->read && ret > 0) {\n\t\tuse_mm(io_data->mm);\n\t\tret = copy_to_iter(io_data->buf, ret, &io_data->data);\n\t\tif (iov_iter_count(&io_data->data))\n\t\t\tret = -EFAULT;\n\t\tunuse_mm(io_data->mm);\n\t}\n\n\tio_data->kiocb->ki_complete(io_data->kiocb, ret, ret);\n\n\tif (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)\n\t\teventfd_signal(io_data->ffs->ffs_eventfd, 1);\n\n\tusb_ep_free_request(io_data->ep, io_data->req);\n\n\tif (io_data->read)\n\t\tkfree(io_data->to_free);\n\tkfree(io_data->buf);\n\tkfree(io_data);\n}",
        "output": "0",
        "idx": 1807
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);\n\tif (e) {\n\t\treturn e;\n\t}\n\tif (!((GF_DataInformationBox *)s)->dref) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n\t}\n\treturn GF_OK;\n}",
        "output": "1",
        "idx": 6774
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    GradFunContext *s = inlink->dst->priv;\n    AVFilterLink *outlink = inlink->dst->outputs[0];\n    AVFrame *out;\n    int p, direct;\n\n    if (av_frame_is_writable(in)) {\n        direct = 1;\n        out = in;\n    } else {\n        direct = 0;\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n\n    for (p = 0; p < 4 && in->data[p] && in->linesize[p]; p++) {\n        int w = inlink->w;\n        int h = inlink->h;\n        int r = s->radius;\n        if (p) {\n            w = s->chroma_w;\n            h = s->chroma_h;\n            r = s->chroma_r;\n        }\n\n        if (FFMIN(w, h) > 2 * r)\n            filter(s, out->data[p], in->data[p], w, h, out->linesize[p], in->linesize[p], r);\n        else if (out->data[p] != in->data[p])\n            av_image_copy_plane(out->data[p], out->linesize[p], in->data[p], in->linesize[p], w, h);\n    }\n\n    if (!direct)\n        av_frame_free(&in);\n\n    return ff_filter_frame(outlink, out);\n}",
        "output": "0",
        "idx": 4929
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "file_check_mem(struct magic_set *ms, unsigned int level)\n{\n\tsize_t len;\n\n\tif (level >= ms->c.len) {\n\t\tlen = (ms->c.len += 20) * sizeof(*ms->c.li);\n\t\tms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?\n\t\t    malloc(len) :\n\t\t    realloc(ms->c.li, len));\n\t\tif (ms->c.li == NULL) {\n\t\t\tfile_oomem(ms, len);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tms->c.li[level].got_match = 0;\n#ifdef ENABLE_CONDITIONALS\n\tms->c.li[level].last_match = 0;\n\tms->c.li[level].last_cond = COND_NONE;\n#endif \n\treturn 0;\n}",
        "output": "1",
        "idx": 4428
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void perf_event_enable(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct task_struct *task = ctx->task;\n\n\tif (!task) {\n\t\tcpu_function_call(event->cpu, __perf_event_enable, event);\n\t\treturn;\n\t}\n\n\traw_spin_lock_irq(&ctx->lock);\n\tif (event->state >= PERF_EVENT_STATE_INACTIVE)\n\t\tgoto out;\n\n\tif (event->state == PERF_EVENT_STATE_ERROR)\n\t\tevent->state = PERF_EVENT_STATE_OFF;\n\nretry:\n\tif (!ctx->is_active) {\n\t\t__perf_event_mark_enabled(event);\n\t\tgoto out;\n\t}\n\n\traw_spin_unlock_irq(&ctx->lock);\n\n\tif (!task_function_call(task, __perf_event_enable, event))\n\t\treturn;\n\n\traw_spin_lock_irq(&ctx->lock);\n\n\tif (ctx->is_active && event->state == PERF_EVENT_STATE_OFF) {\n\t\ttask = ctx->task;\n\t\tgoto retry;\n\t}\n\nout:\n\traw_spin_unlock_irq(&ctx->lock);\n}",
        "output": "1",
        "idx": 2760
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __net_random_once_deferred(struct work_struct *w)\n{\n\tstruct __net_random_once_work *work =\n\t\tcontainer_of(w, struct __net_random_once_work, work);\n\tBUG_ON(!static_key_enabled(work->key));\n\tstatic_key_slow_dec(work->key);\n\tkfree(work);\n}",
        "output": "0",
        "idx": 3543
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_akcipher rakcipher;\n\n\tstrncpy(rakcipher.type, \"akcipher\", sizeof(rakcipher.type));\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,\n\t\t    sizeof(struct crypto_report_akcipher), &rakcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "0",
        "idx": 4175
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data;\n\tvoid *vapic;\n\n\tif (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))\n\t\tapic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n\tdata = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));\n\tkunmap_atomic(vapic);\n\n\tapic_set_tpr(vcpu->arch.apic, data & 0xff);\n}",
        "output": "1",
        "idx": 2484
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "local unsigned long crc32_big(crc, buf, len)\n    unsigned long crc;\n    const unsigned char FAR *buf;\n    unsigned len;\n{\n    register z_crc_t c;\n    register const z_crc_t FAR *buf4;\n\n    c = ZSWAP32((z_crc_t)crc);\n    c = ~c;\n    while (len && ((ptrdiff_t)buf & 3)) {\n        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n        len--;\n    }\n\n    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;\n    buf4--;\n    while (len >= 32) {\n        DOBIG32;\n        len -= 32;\n    }\n    while (len >= 4) {\n        DOBIG4;\n        len -= 4;\n    }\n    buf4++;\n    buf = (const unsigned char FAR *)buf4;\n\n    if (len) do {\n        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n    } while (--len);\n    c = ~c;\n    return (unsigned long)(ZSWAP32(c));\n}",
        "output": "1",
        "idx": 6078
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tktime_t now, remaining, iv;\n\tstruct timespec64 ts64;\n\tbool sig_none;\n\n\tsig_none = timr->it_sigev_notify == SIGEV_NONE;\n\tiv = timr->it_interval;\n\n\tif (iv) {\n\t\tcur_setting->it_interval = ktime_to_timespec64(iv);\n\t} else if (!timr->it_active) {\n\t\tif (!sig_none)\n\t\t\treturn;\n\t}\n\n\tkc->clock_get(timr->it_clock, &ts64);\n\tnow = timespec64_to_ktime(ts64);\n\n\tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))\n\t\ttimr->it_overrun += (int)kc->timer_forward(timr, now);\n\n\tremaining = kc->timer_remaining(timr, now);\n\tif (remaining <= 0) {\n\t\tif (!sig_none)\n\t\t\tcur_setting->it_value.tv_nsec = 1;\n\t} else {\n\t\tcur_setting->it_value = ktime_to_timespec64(remaining);\n\t}\n}",
        "output": "1",
        "idx": 2988
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int gup_huge_pud(pud_t orig, pud_t *pudp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\n\tif (!pud_access_permitted(orig, write))\n\t\treturn 0;\n\n\tif (pud_devmap(orig))\n\t\treturn __gup_device_huge_pud(orig, pudp, addr, end, pages, nr);\n\n\trefs = 0;\n\tpage = pud_page(orig) + ((addr & ~PUD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\thead = try_get_compound_head(pud_page(orig), refs);\n\tif (!head) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(pud_val(orig) != pud_val(*pudp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\n\tSetPageReferenced(head);\n\treturn 1;\n}",
        "output": "0",
        "idx": 4351
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int pure_strcmp(const char * const s1, const char * const s2)\n{\n    return pure_memcmp(s1, s2, strlen(s1) + 1U);\n}",
        "output": "1",
        "idx": 3392
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)\n{\n\tstruct scm_fp_list *new_fpl;\n\tint i;\n\n\tif (!fpl)\n\t\treturn NULL;\n\n\tnew_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),\n\t\t\t  GFP_KERNEL);\n\tif (new_fpl) {\n\t\tfor (i = 0; i < fpl->count; i++)\n\t\t\tget_file(fpl->fp[i]);\n\t\tnew_fpl->max = new_fpl->count;\n\t\tnew_fpl->user = get_uid(fpl->user);\n\t}\n\treturn new_fpl;\n}",
        "output": "0",
        "idx": 1583
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC MprJson *mprLookupJsonObj(MprJson *obj, cchar *name)\n{\n    MprJson      *child;\n    int         i, index;\n\n    if (!obj || !name) {\n        return 0;\n    }\n    if (obj->type & MPR_JSON_OBJ) {\n        for (ITERATE_JSON(obj, child, i)) {\n            if (smatch(child->name, name)) {\n                return child;\n            }\n        }\n    } else if (obj->type & MPR_JSON_ARRAY) {\n        if (*name == '$') {\n            return 0;\n        }\n        index = (int) stoi(name);\n        for (ITERATE_JSON(obj, child, i)) {\n            if (i == index) {\n                return child;\n            }\n        }\n    }\n    return 0;\n}",
        "output": "1",
        "idx": 5094
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sf_open_fd\t(int fd, int mode, SF_INFO *sfinfo, int close_desc)\n{\tSF_PRIVATE \t*psf ;\n\n\tif ((SF_CONTAINER (sfinfo->format)) == SF_FORMAT_SD2)\n\t{\tsf_errno = SFE_SD2_FD_DISALLOWED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;\n\tcopy_filename (psf, \"\") ;\n\n\tpsf->file.mode = mode ;\n\tpsf_set_file (psf, fd) ;\n\tpsf->is_pipe = psf_is_pipe (psf) ;\n\tpsf->fileoffset = psf_ftell (psf) ;\n\n\tif (! close_desc)\n\t\tpsf->file.do_not_close_descriptor = SF_TRUE ;\n\n\treturn psf_open_file (psf, sfinfo) ;\n} ",
        "output": "1",
        "idx": 4950
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ikev2_parent_inI1outR1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inI1outR1: calculated ke+nonce, sending R1\"));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); \n\n\tset_cur_state(st);\n\n\tst->st_calculating = FALSE;\n\n\te = ikev2_parent_inI1outR1_tail(pcrc, r);\n\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t}\n\treset_globals();\n\n\tpassert(GLOBALS_ARE_RESET());\n}",
        "output": "1",
        "idx": 4382
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ceph_x_decrypt(struct ceph_crypto_key *secret,\n\t\t\t  void **p, void *end, void **obuf, size_t olen)\n{\n\tstruct ceph_x_encrypt_header head;\n\tsize_t head_len = sizeof(head);\n\tint len, ret;\n\n\tlen = ceph_decode_32(p);\n\tif (*p + len > end)\n\t\treturn -EINVAL;\n\n\tdout(\"ceph_x_decrypt len %d\\n\", len);\n\tif (*obuf == NULL) {\n\t\t*obuf = kmalloc(len, GFP_NOFS);\n\t\tif (!*obuf)\n\t\t\treturn -ENOMEM;\n\t\tolen = len;\n\t}\n\n\tret = ceph_decrypt2(secret, &head, &head_len, *obuf, &olen, *p, len);\n\tif (ret)\n\t\treturn ret;\n\tif (head.struct_v != 1 || le64_to_cpu(head.magic) != CEPHX_ENC_MAGIC)\n\t\treturn -EPERM;\n\t*p += len;\n\treturn olen;\n}",
        "output": "0",
        "idx": 3669
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int proc_sys_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct ctl_table_header *head = grab_header(file_inode(file));\n\tstruct ctl_table_header *h = NULL;\n\tstruct ctl_table *entry;\n\tstruct ctl_dir *ctl_dir;\n\tunsigned long pos;\n\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\n\tctl_dir = container_of(head, struct ctl_dir, header);\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\n\tpos = 2;\n\n\tfor (first_entry(ctl_dir, &h, &entry); h; next_entry(&h, &entry)) {\n\t\tif (!scan(h, entry, &pos, file, ctx)) {\n\t\t\tsysctl_head_finish(h);\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tsysctl_head_finish(head);\n\treturn 0;\n}",
        "output": "0",
        "idx": 2065
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {\n        int r;\n\n        assert(p);\n        assert(key);\n\n\n        if (DNS_PACKET_QR(p) != 1)\n                return 0;\n\n        r = dns_packet_extract(p);\n        if (r < 0)\n                return r;\n\n        if (!p->question)\n                return 0;\n\n        if (p->question->n_keys != 1)\n                return 0;\n\n        return dns_resource_key_equal(p->question->keys[0], key);\n}",
        "output": "0",
        "idx": 7687
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_ctl_elem_user_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tint change;\n\tstruct user_element *ue = kcontrol->private_data;\n\t\n\tchange = memcmp(&ucontrol->value, ue->elem_data, ue->elem_data_size) != 0;\n\tif (change)\n\t\tmemcpy(ue->elem_data, &ucontrol->value, ue->elem_data_size);\n\treturn change;\n}",
        "output": "1",
        "idx": 2598
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_function_line(\n\texarg_T\t\t*eap,\n\tchar_u\t\t**line_to_free,\n\tint\t\tindent,\n\tgetline_opt_T\tgetline_options)\n{\n    char_u *theline;\n\n    if (eap->getline == NULL)\n\ttheline = getcmdline(':', 0L, indent, 0);\n    else\n\ttheline = eap->getline(':', eap->cookie, indent, getline_options);\n    if (theline != NULL)\n    {\n\tif (*eap->cmdlinep == *line_to_free)\n\t    *eap->cmdlinep = theline;\n\tvim_free(*line_to_free);\n\t*line_to_free = theline;\n    }\n\n    return theline;\n}",
        "output": "1",
        "idx": 5710
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void handle_service_action(HttpRequest req, HttpResponse res) {\n        char *name = req->url;\n        Service_T s = Util_getService(++name);\n        if (! s) {\n                send_error(req, res, SC_NOT_FOUND, \"There is no service named \\\"%s\\\"\", name ? name : \"\");\n                return;\n        }\n        const char *action = get_parameter(req, \"action\");\n        if (action) {\n                if (is_readonly(req)) {\n                        send_error(req, res, SC_FORBIDDEN, \"You do not have sufficient privileges to access this page\");\n                        return;\n                }\n                Action_Type doaction = Util_getAction(action);\n                if (doaction == Action_Ignored) {\n                        send_error(req, res, SC_BAD_REQUEST, \"Invalid action \\\"%s\\\"\", action);\n                        return;\n                }\n                s->doaction = doaction;\n                const char *token = get_parameter(req, \"token\");\n                if (token) {\n                        FREE(s->token);\n                        s->token = Str_dup(token);\n                }\n                LogInfo(\"'%s' %s on user request\\n\", s->name, action);\n                Run.flags |= Run_ActionPending; \n                do_wakeupcall();\n        }\n        do_service(req, res, s);\n}",
        "output": "0",
        "idx": 8433
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void print_value(int output, int num, const char *devname,\n\t\t\tconst char *value, const char *name, size_t valsz)\n{\n\tif (output & OUTPUT_VALUE_ONLY) {\n\t\tfputs(value, stdout);\n\t\tfputc('\\n', stdout);\n\n\t} else if (output & OUTPUT_UDEV_LIST) {\n\t\tprint_udev_format(name, value);\n\n\t} else if (output & OUTPUT_EXPORT_LIST) {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"DEVNAME=%s\\n\", devname);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\", stdout);\n\t\tsafe_print(value, valsz, \" \\\\\\\"'$`<>\");\n\t\tfputs(\"\\n\", stdout);\n\n\t} else {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"%s:\", devname);\n\t\tfputs(\" \", stdout);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\\\"\", stdout);\n\t\tsafe_print(value, valsz, \"\\\"\\\\\");\n\t\tfputs(\"\\\"\", stdout);\n\t}\n}",
        "output": "0",
        "idx": 6505
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cifs_find_smb_ses(struct TCP_Server_Info *server, char *username)\n{\n\tstruct list_head *tmp;\n\tstruct cifsSesInfo *ses;\n\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);\n\t\tif (strncmp(ses->userName, username, MAX_USERNAME_SIZE))\n\t\t\tcontinue;\n\n\t\t++ses->ses_count;\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\treturn ses;\n\t}\n\twrite_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}",
        "output": "1",
        "idx": 222
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mrb_realloc(mrb_state *mrb, void *p, size_t len)\n{\n  void *p2;\n\n  p2 = mrb_realloc_simple(mrb, p, len);\n  if (len == 0) return p2;\n  if (p2 == NULL) {\n    mrb_free(mrb, p);\n    mrb->gc.out_of_memory = TRUE;\n    mrb_raise_nomemory(mrb);\n  }\n  else {\n    mrb->gc.out_of_memory = FALSE;\n  }\n\n  return p2;\n}",
        "output": "1",
        "idx": 6680
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dtls1_process_buffered_records(SSL *s)\n    {\n    pitem *item;\n    \n    item = pqueue_peek(s->d1->unprocessed_rcds.q);\n    if (item)\n        {\n        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)\n            return(1);  \n        \n        while (pqueue_peek(s->d1->unprocessed_rcds.q))\n            {\n            dtls1_get_unprocessed_record(s);\n            if ( ! dtls1_process_record(s))\n                return(0);\n            dtls1_buffer_record(s, &(s->d1->processed_rcds), \n                s->s3->rrec.seq_num);\n            }\n        }\n\n    s->d1->processed_rcds.epoch = s->d1->r_epoch;\n    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;\n\n    return(1);\n    }",
        "output": "1",
        "idx": 4554
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh, int create, int flag,\n\t\t\tpgoff_t *next_pgofs)\n{\n\tstruct f2fs_map_blocks map;\n\tint err;\n\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\tmap.m_next_pgofs = next_pgofs;\n\n\terr = f2fs_map_blocks(inode, &map, create, flag);\n\tif (!err) {\n\t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\t\tbh->b_state = (bh->b_state & ~F2FS_MAP_FLAGS) | map.m_flags;\n\t\tbh->b_size = map.m_len << inode->i_blkbits;\n\t}\n\treturn err;\n}",
        "output": "1",
        "idx": 1488
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tunsigned long *msr_bitmap;\n\n\tif (is_guest_mode(vcpu))\n\t\tmsr_bitmap = vmx_msr_bitmap_nested;\n\telse if (vcpu->arch.apic_base & X2APIC_ENABLE) {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t} else {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy;\n\t}\n\n\tvmcs_write64(MSR_BITMAP, __pa(msr_bitmap));\n}",
        "output": "1",
        "idx": 1278
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ndpi_netbios_name_interpret(char *in, size_t in_len, char *out, u_int out_len) {\n  u_int ret = 0, len, idx = in_len, out_idx = 0;\n\n  len = (*in++)/2;\n  out_len--;\n  out[out_idx] = 0;\n\n  if((len > out_len) || (len < 1) || ((2*len) > in_len))\n    return(-1);\n\n  while((len--) && (out_idx < out_len)) {\n    if((idx < 2) || (in[0] < 'A') || (in[0] > 'P') || (in[1] < 'A') || (in[1] > 'P')) {\n      out[out_idx] = 0;\n      break;\n    }\n\n    out[out_idx] = ((in[0] - 'A') << 4) + (in[1] - 'A');\n    in += 2, idx -= 2;\n\n    if(isprint(out[out_idx]))\n      out_idx++, ret++;\n  }\n\n  if(out_idx > 0) {\n    out[out_idx] = 0;\n    out_idx--;\n\n    while((out_idx > 0) && (out[out_idx] == ' ')) {\n      out[out_idx] = 0;\n      out_idx--;\n    }\n\n  }\n\n  return(ret);\n}",
        "output": "1",
        "idx": 7876
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "irc_ctcp_dcc_filename_without_quotes (const char *filename)\n{\n    int length;\n\n    length = strlen (filename);\n    if (length > 1)\n    {\n        if ((filename[0] == '\\\"') && (filename[length - 1] == '\\\"'))\n            return weechat_strndup (filename + 1, length - 2);\n    }\n    return strdup (filename);\n}",
        "output": "0",
        "idx": 8823
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "init_connection_options(MYSQL *mysql)\n{\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n                  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(mysql, MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*) &opt_ssl_verify_server_cert);\n#endif\n\n  if (opt_protocol)\n    mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);\n\n#ifdef HAVE_SMEM\n  if (shared_memory_base_name)\n    mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME, shared_memory_base_name);\n#endif\n}",
        "output": "1",
        "idx": 5270
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t qrtr_tun_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct qrtr_tun *tun = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tssize_t ret;\n\tvoid *kbuf;\n\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(kbuf, len, from))\n\t\treturn -EFAULT;\n\n\tret = qrtr_endpoint_post(&tun->ep, kbuf, len);\n\n\treturn ret < 0 ? ret : len;\n}",
        "output": "1",
        "idx": 3236
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mono_runtime_shutdown (void)\n{\n\tmono_domain_foreach (fire_process_exit_event, NULL);\n\n\tmono_reflection_shutdown ();\n}",
        "output": "0",
        "idx": 4709
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(DirectoryIterator, rewind)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern->u.dir.index = 0;\n\tif (intern->u.dir.dirp) {\n\t\tphp_stream_rewinddir(intern->u.dir.dirp);\n\t}\n\tspl_filesystem_dir_read(intern TSRMLS_CC);\n}",
        "output": "0",
        "idx": 5511
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)\n{\n\tconst char *s = name;\n\n\twhile (1) {\n\t\tconst char *s0 = s;\n\t\tchar *dirname;\n\n\t\twhile (1) {\n\t\t\tif (*s == 0) {\n\t\t\t\tif (last && s != s0)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\treturn dir;\n\t\t\t}\n\t\t\tif (*s == '/')\n\t\t\t\tbreak;\n\t\t\ts++;\n\t\t}\n\n\t\tdirname = g_strndup (s0, s - s0);\n\t\twhile (*s == '/')\n\t\t\ts++;\n\n\t\tif (strcmp (dirname, \".\") != 0) {\n\t\t\tGsfInput *subdir =\n\t\t\t\tgsf_infile_child_by_name (GSF_INFILE (dir),\n\t\t\t\t\t\t\t  dirname);\n\t\t\tif (subdir) {\n\t\t\t\tg_object_unref (subdir);\n\t\t\t\tdir = GSF_INFILE_TAR (subdir);\n\t\t\t} else\n\t\t\t\tdir = tar_create_dir (dir, dirname);\n\t\t}\n\n\t\tg_free (dirname);\n\t}\n}",
        "output": "1",
        "idx": 6096
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_msgtype_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_msgtype2str, \"MSGTYPE-#%u\",\n\t    EXTRACT_16BITS(ptr))));\n}",
        "output": "1",
        "idx": 4768
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sctp_sock_rfree_frag(struct sk_buff *skb)\n{\n\tstruct sk_buff *frag;\n\n\tif (!skb->data_len)\n\t\tgoto done;\n\n\tfor (frag = skb_shinfo(skb)->frag_list; frag; frag = frag->next)\n\t\tsctp_sock_rfree_frag(frag);\n\ndone:\n\tsctp_sock_rfree(skb);\n}",
        "output": "0",
        "idx": 2983
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, rewind)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);\n} ",
        "output": "0",
        "idx": 5583
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BOOL update_read_synchronize(rdpUpdate* update, wStream* s)\n{\n\tWINPR_UNUSED(update);\n\treturn Stream_SafeSeek(s, 2); \n}",
        "output": "0",
        "idx": 5719
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IW_IMPL(unsigned int) iw_get_ui16le(const iw_byte *b)\n{\n\treturn b[0] | (b[1]<<8);\n}",
        "output": "1",
        "idx": 6646
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main()\n{\n    check_file(\"heap_overflow_1.tga\");\n    check_file(\"heap_overflow_2.tga\");\n\n    return gdNumFailures();\n}",
        "output": "0",
        "idx": 6205
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_new_mount(struct path *path, const char *fstype, int flags,\n\t\t\tint mnt_flags, const char *name, void *data)\n{\n\tstruct file_system_type *type;\n\tstruct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;\n\tstruct vfsmount *mnt;\n\tint err;\n\n\tif (!fstype)\n\t\treturn -EINVAL;\n\n\ttype = get_fs_type(fstype);\n\tif (!type)\n\t\treturn -ENODEV;\n\n\tif (user_ns != &init_user_ns) {\n\t\tif (!(type->fs_flags & FS_USERNS_MOUNT)) {\n\t\t\tput_filesystem(type);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tif (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {\n\t\t\tflags |= MS_NODEV;\n\t\t\tmnt_flags |= MNT_NODEV;\n\t\t}\n\t}\n\n\tmnt = vfs_kern_mount(type, flags, name, data);\n\tif (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&\n\t    !mnt->mnt_sb->s_subtype)\n\t\tmnt = fs_set_subtype(mnt, fstype);\n\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\n\terr = do_add_mount(real_mount(mnt), path, mnt_flags);\n\tif (err)\n\t\tmntput(mnt);\n\treturn err;\n}",
        "output": "1",
        "idx": 2628
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b)\n{\n\tu64 now;\n\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\treturn;\n\n\tnow = sched_clock_cpu(smp_processor_id());\n\tcfs_b->runtime = cfs_b->quota;\n\tcfs_b->runtime_expires = now + ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n}",
        "output": "1",
        "idx": 3224
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mk_request_free(struct session_request *sr)\n{\n    if (sr->fd_file > 0) {\n        mk_vhost_close(sr);\n    }\n\n    if (sr->headers.location) {\n        mk_mem_free(sr->headers.location);\n    }\n\n    if (sr->uri_processed.data != sr->uri.data) {\n        mk_ptr_free(&sr->uri_processed);\n    }\n\n    if (sr->real_path.data != sr->real_path_static) {\n        mk_ptr_free(&sr->real_path);\n    }\n}",
        "output": "1",
        "idx": 3810
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n\t\tinfop, int, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);\n\tint signo = 0;\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t}\n\n\tif (!err) {\n\t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (!infop)\n\t\treturn err;\n\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}",
        "output": "1",
        "idx": 1684
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void common_hrtimer_rearm(struct k_itimer *timr)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\n\tif (!timr->it_interval)\n\t\treturn;\n\n\ttimr->it_overrun += hrtimer_forward(timer, timer->base->get_time(),\n\t\t\t\t\t    timr->it_interval);\n\thrtimer_restart(timer);\n}",
        "output": "0",
        "idx": 4129
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int evtchn_fifo_percpu_deinit(unsigned int cpu)\n{\n\t__evtchn_fifo_handle_events(cpu, true);\n\treturn 0;\n}",
        "output": "1",
        "idx": 1896
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "snmp_engine_get_next(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t varbinds_length)\n{\n  snmp_mib_resource_t *resource;\n  uint32_t i;\n\n  for(i = 0; i < varbinds_length; i++) {\n    resource = snmp_mib_find_next(varbinds[i].oid);\n    if(!resource) {\n      switch(header->version) {\n      case SNMP_VERSION_1:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = i + 1;\n        break;\n      case SNMP_VERSION_2C:\n        (&varbinds[i])->value_type = SNMP_DATA_TYPE_END_OF_MIB_VIEW;\n        break;\n      default:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = 0;\n      }\n    } else {\n      resource->handler(&varbinds[i], resource->oid);\n    }\n  }\n\n  return 0;\n}",
        "output": "1",
        "idx": 7970
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static enum led_brightness k90_backlight_get(struct led_classdev *led_cdev)\n{\n\tint ret;\n\tstruct k90_led *led = container_of(led_cdev, struct k90_led, cdev);\n\tstruct device *dev = led->cdev.dev->parent;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint brightness;\n\tchar data[8];\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tbrightness = data[4];\n\tif (brightness < 0 || brightness > 3) {\n\t\tdev_warn(dev,\n\t\t\t \"Read invalid backlight brightness: %02hhx.\\n\",\n\t\t\t data[4]);\n\t\treturn -EIO;\n\t}\n\treturn brightness;\n}",
        "output": "1",
        "idx": 1424
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int devmem_is_allowed(unsigned long pagenr)\n{\n\tif (page_is_ram(pagenr)) {\n\t\tif (pagenr < 256)\n\t\t\treturn 2;\n\n\t\treturn 0;\n\t}\n\n\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT)) {\n\t\tif (pagenr < 256)\n\t\t\treturn 1;\n\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
        "output": "0",
        "idx": 2235
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_accm_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tuint16_t val_h, val_l;\n\n\tif (length < 2) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tptr++;\t\t\n\tlength -= 2;\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tND_PRINT((ndo, \"send=%08x \", (val_h<<16) + val_l));\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"recv=%08x \", (val_h<<16) + val_l));\n}",
        "output": "0",
        "idx": 6677
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rds_ib_laddr_check(__be32 addr)\n{\n\tint ret;\n\tstruct rdma_cm_id *cm_id;\n\tstruct sockaddr_in sin;\n\n\tcm_id = rdma_create_id(NULL, NULL, RDMA_PS_TCP, IB_QPT_RC);\n\tif (IS_ERR(cm_id))\n\t\treturn PTR_ERR(cm_id);\n\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_family = AF_INET;\n\tsin.sin_addr.s_addr = addr;\n\n\tret = rdma_bind_addr(cm_id, (struct sockaddr *)&sin);\n\tif (ret || cm_id->device->node_type != RDMA_NODE_IB_CA)\n\t\tret = -EADDRNOTAVAIL;\n\n\trdsdebug(\"addr %pI4 ret %d node type %d\\n\",\n\t\t&addr, ret,\n\t\tcm_id->device ? cm_id->device->node_type : -1);\n\n\trdma_destroy_id(cm_id);\n\n\treturn ret;\n}",
        "output": "1",
        "idx": 2498
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err text_box_size(GF_Box *s)\n{\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\n\ts->size += 51 + 1;\n\tif (ptr->textName)\n\t\ts->size += strlen(ptr->textName);\n\treturn GF_OK;\n}",
        "output": "1",
        "idx": 6850
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ext2_xattr_destroy_cache(struct mb2_cache *cache)\n{\n\tif (cache)\n\t\tmb2_cache_destroy(cache);\n}",
        "output": "0",
        "idx": 1663
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void jp2_box_dump(jp2_box_t *box, FILE *out)\n{\n\tjp2_boxinfo_t *boxinfo;\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tassert(boxinfo);\n\n\tfprintf(out, \"JP2 box: \");\n\tfprintf(out, \"type=%c%s%c (0x%08\"PRIxFAST32\"); length=%\"PRIuFAST32\"\\n\", '\"', boxinfo->name,\n\t  '\"', box->type, box->len);\n\tif (box->ops->dumpdata) {\n\t\t(*box->ops->dumpdata)(box, out);\n\t}\n}",
        "output": "1",
        "idx": 5354
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Jsi_RC NumberToPrecisionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<=0) return JSI_ERROR;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf),\"%.*\" JSI_NUMFFMT, prec, num);\n    if (num<0)\n        prec++;\n    buf[prec+1] = 0;\n    if (buf[prec] == '.')\n        buf[prec] = 0;\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}",
        "output": "1",
        "idx": 8204
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(FilesystemIterator, current)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (SPL_FILE_DIR_CURRENT(intern, SPL_FILE_DIR_CURRENT_AS_PATHNAME)) {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t\tRETURN_STRINGL(intern->file_name, intern->file_name_len, 1);\n\t} else if (SPL_FILE_DIR_CURRENT(intern, SPL_FILE_DIR_CURRENT_AS_FILEINFO)) {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t\tspl_filesystem_object_create_type(0, intern, SPL_FS_INFO, NULL, return_value TSRMLS_CC);\n\t} else {\n\t\tRETURN_ZVAL(getThis(), 1, 0);\n\t}\n}",
        "output": "1",
        "idx": 3914
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int init_nss_hash(struct crypto_instance *instance)\n{\n\tPK11SlotInfo*\thash_slot = NULL;\n\tSECItem\t\thash_param;\n\n\tif (!hash_to_nss[instance->crypto_hash_type]) {\n\t\treturn 0;\n\t}\n\n\thash_param.type = siBuffer;\n\thash_param.data = instance->private_key;\n\thash_param.len = instance->private_key_len;\n\n\thash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);\n\tif (hash_slot == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Unable to find security slot (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\n\tinstance->nss_sym_key_sign = PK11_ImportSymKey(hash_slot,\n\t\t\t\t\t\t       hash_to_nss[instance->crypto_hash_type],\n\t\t\t\t\t\t       PK11_OriginUnwrap, CKA_SIGN,\n\t\t\t\t\t\t       &hash_param, NULL);\n\tif (instance->nss_sym_key_sign == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Failure to import key into NSS (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\n\tPK11_FreeSlot(hash_slot);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 5211
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)\n{\n\tInitializeCriticalSection(mutex);\n\treturn 0;\n}",
        "output": "1",
        "idx": 7842
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mwifiex_set_uap_rates(struct mwifiex_uap_bss_param *bss_cfg,\n\t\t      struct cfg80211_ap_settings *params)\n{\n\tstruct ieee_types_header *rate_ie;\n\tint var_offset = offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\tconst u8 *var_pos = params->beacon.head + var_offset;\n\tint len = params->beacon.head_len - var_offset;\n\tu8 rate_len = 0;\n\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_SUPP_RATES, var_pos, len);\n\tif (rate_ie) {\n\t\tif (rate_ie->len > MWIFIEX_SUPPORTED_RATES)\n\t\t\treturn;\n\t\tmemcpy(bss_cfg->rates, rate_ie + 1, rate_ie->len);\n\t\trate_len = rate_ie->len;\n\t}\n\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t   params->beacon.tail,\n\t\t\t\t\t   params->beacon.tail_len);\n\tif (rate_ie) {\n\t\tif (rate_ie->len > MWIFIEX_SUPPORTED_RATES - rate_len)\n\t\t\treturn;\n\t\tmemcpy(bss_cfg->rates + rate_len, rate_ie + 1, rate_ie->len);\n\t}\n\n\treturn;\n}",
        "output": "0",
        "idx": 4459
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool ndp_msg_check_valid(struct ndp_msg *msg)\n{\n\tsize_t len = ndp_msg_payload_len(msg);\n\tenum ndp_msg_type msg_type = ndp_msg_type(msg);\n\n\tif (len < ndp_msg_type_info(msg_type)->raw_struct_size)\n\t\treturn false;\n\n\tif (ndp_msg_type_info(msg_type)->addrto_validate)\n\t\treturn ndp_msg_type_info(msg_type)->addrto_validate(&msg->addrto);\n\telse\n\t\treturn true;\n}",
        "output": "0",
        "idx": 8239
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int search_old_relocation (struct reloc_struct_t *reloc_table,\n\t\t\t\t  ut32 addr_to_patch, int n_reloc) {\n\tint i;\n\tfor (i = 0; i < n_reloc; i++) {\n\t\tif (addr_to_patch == reloc_table[i].data_offset) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}",
        "output": "0",
        "idx": 8609
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "f_histadd(typval_T *argvars UNUSED, typval_T *rettv)\n{\n#ifdef FEAT_CMDHIST\n    int\t\thistype;\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n#endif\n\n    rettv->vval.v_number = FALSE;\n    if (check_restricted() || check_secure())\n\treturn;\n#ifdef FEAT_CMDHIST\n    str = tv_get_string_chk(&argvars[0]);\t\n    histype = str != NULL ? get_histtype(str) : -1;\n    if (histype >= 0)\n    {\n\tstr = tv_get_string_buf(&argvars[1], buf);\n\tif (*str != NUL)\n\t{\n\t    init_history();\n\t    add_to_history(histype, str, FALSE, NUL);\n\t    rettv->vval.v_number = TRUE;\n\t    return;\n\t}\n    }\n#endif\n}",
        "output": "1",
        "idx": 5852
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "stf_status ikev2parent_inI2outR2(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\n\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\n\t\t    \"ikev2 parent inI2outR2: calculating g^{xy} in order to decrypt I2\"));\n\n\tif (!md->chain[ISAKMP_NEXT_v2E]) {\n\t\tlibreswan_log(\"R2 state should receive an encrypted payload\");\n\t\treset_globals(); \n\t\treturn STF_FATAL;\n\t}\n\n\t{\n\t\tstruct dh_continuation *dh = alloc_thing(\n\t\t\tstruct dh_continuation,\n\t\t\t\"ikev2_inI2outR2 KE\");\n\t\tstf_status e;\n\n\t\tdh->md = md;\n\t\tset_suspended(st, dh->md);\n\n\t\tpcrc_init(&dh->dh_pcrc);\n\t\tdh->dh_pcrc.pcrc_func = ikev2_parent_inI2outR2_continue;\n\t\te = start_dh_v2(&dh->dh_pcrc, st, st->st_import, RESPONDER,\n\t\t\t\tst->st_oakley.groupnum);\n\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");\n\t\t\tdelete_state(st);\n\t\t}\n\n\t\treset_globals();\n\n\t\treturn e;\n\t}\n}",
        "output": "0",
        "idx": 6069
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "__u32 secure_tcpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t   __be16 sport, __be16 dport)\n{\n\tu32 secret[MD5_MESSAGE_BYTES / 4];\n\tu32 hash[MD5_DIGEST_WORDS];\n\tu32 i;\n\n\tmemcpy(hash, saddr, 16);\n\tfor (i = 0; i < 4; i++)\n\t\tsecret[i] = net_secret[i] + daddr[i];\n\tsecret[4] = net_secret[4] +\n\t\t(((__force u16)sport << 16) + (__force u16)dport);\n\tfor (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)\n\t\tsecret[i] = net_secret[i];\n\n\tmd5_transform(hash, secret);\n\n\treturn seq_scale(hash[0]);\n}",
        "output": "0",
        "idx": 781
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_siocgstampns(struct net *net, struct socket *sock,\n\t\t\t   unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timespec kts;\n\tint err;\n\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);\n\tset_fs(old_fs);\n\tif (!err)\n\t\terr = compat_put_timespec(&kts, up);\n\n\treturn err;\n}",
        "output": "0",
        "idx": 1039
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "find_link_ref(struct link_ref **references, uint8_t *name, size_t length)\n{\n\tunsigned int hash = hash_link_ref(name, length);\n\tstruct link_ref *ref = NULL;\n\n\tref = references[hash % REF_TABLE_SIZE];\n\n\twhile (ref != NULL) {\n\t\tif (ref->id == hash)\n\t\t\treturn ref;\n\n\t\tref = ref->next;\n\t}\n\n\treturn NULL;\n}",
        "output": "1",
        "idx": 8810
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sysServices_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_time_ticks(varbind, oid, clock_seconds() * 100);\n}",
        "output": "1",
        "idx": 7928
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct nfs4_opendata *nfs4_open_recoverdata_alloc(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs4_opendata *opendata;\n\n\topendata = nfs4_opendata_alloc(&ctx->path, state->owner, 0, 0, NULL);\n\tif (opendata == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\topendata->state = state;\n\tatomic_inc(&state->count);\n\treturn opendata;\n}",
        "output": "0",
        "idx": 3061
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct dst_entry *inet6_csk_route_req(const struct sock *sk,\n\t\t\t\t      struct flowi6 *fl6,\n\t\t\t\t      const struct request_sock *req,\n\t\t\t\t      u8 proto)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *final_p, final;\n\tstruct dst_entry *dst;\n\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_proto = proto;\n\tfl6->daddr = ireq->ir_v6_rmt_addr;\n\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n\tfl6->saddr = ireq->ir_v6_loc_addr;\n\tfl6->flowi6_oif = ireq->ir_iif;\n\tfl6->flowi6_mark = ireq->ir_mark;\n\tfl6->fl6_dport = ireq->ir_rmt_port;\n\tfl6->fl6_sport = htons(ireq->ir_num);\n\tsecurity_req_classify_flow(req, flowi6_to_flowi(fl6));\n\n\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\tif (IS_ERR(dst))\n\t\treturn NULL;\n\n\treturn dst;\n}",
        "output": "1",
        "idx": 960
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(DirectoryIterator, isDot)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_BOOL(spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n}",
        "output": "0",
        "idx": 5485
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateStringArray( const char **strings, int count )\n{\n\tint i;\n\tcJSON *n = 0, *p = 0, *a = cJSON_CreateArray();\n\tfor ( i = 0; a && i < count; ++i ) {\n\t\tn = cJSON_CreateString( strings[i] );\n\t\tif ( ! i )\n\t\t\ta->child = n;\n\t\telse\n\t\t\tsuffix_object( p, n );\n\t\tp = n;\n\t}\n\treturn a;\n}",
        "output": "1",
        "idx": 5942
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int createFromTiffRgba(TIFF * tif, gdImagePtr im)\n{\n\tint a;\n\tint x, y;\n\tint alphaBlendingFlag = 0;\n\tint color;\n\tint width = im->sx;\n\tint height = im->sy;\n\tuint32 *buffer;\n\tuint32 rgba;\n\n\talphaBlendingFlag = im->alphaBlendingFlag;\n\tgdImageAlphaBlending(im, 0);\n\n\tbuffer = (uint32 *) gdCalloc(sizeof(uint32), width * height);\n\tif (!buffer) {\n\t\treturn GD_FAILURE;\n\t}\n\n\tTIFFReadRGBAImage(tif, width, height, buffer, 0);\n\n\tfor(y = 0; y < height; y++) {\n\t\tfor(x = 0; x < width; x++) {\n\t\t\trgba = buffer[(y * width + x)];\n\t\t\ta = (0xff - TIFFGetA(rgba)) / 2;\n\t\t\tcolor = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);\n\n\t\t\tgdImageSetPixel(im, x, height - y - 1, color);\n\t\t}\n\t}\n\n\tgdFree(buffer);\n\n\tgdImageAlphaBlending(im, alphaBlendingFlag);\n\treturn GD_SUCCESS;\n}",
        "output": "1",
        "idx": 4442
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ucounts_lock, flags);\n\tucounts->count -= 1;\n\tif (!ucounts->count)\n\t\thlist_del_init(&ucounts->node);\n\telse\n\t\tucounts = NULL;\n\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\n\tkfree(ucounts);\n}",
        "output": "0",
        "idx": 2197
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sas_probe_devices(struct work_struct *work)\n{\n\tstruct domain_device *dev, *n;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\n\tclear_bit(DISCE_PROBE, &port->disc.pending);\n\n\tlist_for_each_entry(dev, &port->disco_list, disco_list_node) {\n\t\tspin_lock_irq(&port->dev_list_lock);\n\t\tlist_add_tail(&dev->dev_list_node, &port->dev_list);\n\t\tspin_unlock_irq(&port->dev_list_lock);\n\t}\n\n\tsas_probe_sata(port);\n\n\tlist_for_each_entry_safe(dev, n, &port->disco_list, disco_list_node) {\n\t\tint err;\n\n\t\terr = sas_rphy_add(dev->rphy);\n\t\tif (err)\n\t\t\tsas_fail_probe(dev, __func__, err);\n\t\telse\n\t\t\tlist_del_init(&dev->disco_list_node);\n\t}\n}",
        "output": "1",
        "idx": 1824
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ovl_remove_upper(struct dentry *dentry, bool is_dir)\n{\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *dir = upperdir->d_inode;\n\tstruct dentry *upper;\n\tint err;\n\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out_unlock;\n\n\terr = -ESTALE;\n\tif (upper == ovl_dentry_upper(dentry)) {\n\t\tif (is_dir)\n\t\t\terr = vfs_rmdir(dir, upper);\n\t\telse\n\t\t\terr = vfs_unlink(dir, upper, NULL);\n\t\tovl_dentry_version_inc(dentry->d_parent);\n\t}\n\tdput(upper);\n\n\tif (!err)\n\t\td_drop(dentry);\nout_unlock:\n\tinode_unlock(dir);\n\n\treturn err;\n}",
        "output": "0",
        "idx": 1725
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mutt_from_base64 (char *out, const char *in)\n{\n  int len = 0;\n  register unsigned char digit1, digit2, digit3, digit4;\n\n  do\n  {\n    digit1 = in[0];\n    if (digit1 > 127 || base64val (digit1) == BAD)\n      return -1;\n    digit2 = in[1];\n    if (digit2 > 127 || base64val (digit2) == BAD)\n      return -1;\n    digit3 = in[2];\n    if (digit3 > 127 || ((digit3 != '=') && (base64val (digit3) == BAD)))\n      return -1;\n    digit4 = in[3];\n    if (digit4 > 127 || ((digit4 != '=') && (base64val (digit4) == BAD)))\n      return -1;\n    in += 4;\n\n    *out++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4);\n    len++;\n    if (digit3 != '=')\n    {\n      *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);\n      len++;\n      if (digit4 != '=')\n      {\n\t*out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4);\n\tlen++;\n      }\n    }\n  }\n  while (*in && digit4 != '=');\n\n  return len;\n}",
        "output": "1",
        "idx": 6952
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vmx_complete_atomic_exit(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\n\tif (!(vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY\n\t      || vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI))\n\t\treturn;\n\n\tvmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\texit_intr_info = vmx->exit_intr_info;\n\n\tif (is_machine_check(exit_intr_info))\n\t\tkvm_machine_check();\n\n\tif (is_nmi(exit_intr_info)) {\n\t\tkvm_before_handle_nmi(&vmx->vcpu);\n\t\tasm(\"int $2\");\n\t\tkvm_after_handle_nmi(&vmx->vcpu);\n\t}\n}",
        "output": "0",
        "idx": 2057
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void grubfs_free (GrubFS *gf) {\n\tif (gf) {\n\t\tif (gf->file && gf->file->device) {\n\t\t\tfree (gf->file->device->disk);\n\t\t}\n\t\tfree (gf->file);\n\t\tfree (gf);\n\t}\n}",
        "output": "0",
        "idx": 8661
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CAMLprim value caml_alloc_dummy(value size)\n{\n  mlsize_t wosize = Int_val(size);\n\n  if (wosize == 0) return Atom(0);\n  return caml_alloc (wosize, 0);\n}",
        "output": "1",
        "idx": 5506
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long madvise_remove(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_area_struct **prev,\n\t\t\t\tunsigned long start, unsigned long end)\n{\n\tloff_t offset;\n\tint error;\n\n\t*prev = NULL;\t\n\n\tif (vma->vm_flags & (VM_LOCKED|VM_NONLINEAR|VM_HUGETLB))\n\t\treturn -EINVAL;\n\n\tif (!vma->vm_file || !vma->vm_file->f_mapping\n\t\t|| !vma->vm_file->f_mapping->host) {\n\t\t\treturn -EINVAL;\n\t}\n\n\tif ((vma->vm_flags & (VM_SHARED|VM_WRITE)) != (VM_SHARED|VM_WRITE))\n\t\treturn -EACCES;\n\n\toffset = (loff_t)(start - vma->vm_start)\n\t\t\t+ ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n\n\tup_read(&current->mm->mmap_sem);\n\terror = do_fallocate(vma->vm_file,\n\t\t\t\tFALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n\t\t\t\toffset, end - start);\n\tdown_read(&current->mm->mmap_sem);\n\treturn error;\n}",
        "output": "1",
        "idx": 734
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PixarLogClose(TIFF* tif)\n{\n        PixarLogState* sp = (PixarLogState*) tif->tif_data;\n\tTIFFDirectory *td = &tif->tif_dir;\n\n\tassert(sp != 0);\n\n        if (sp->state&PLSTATE_INIT) {\n             * http:\n            td->td_bitspersample = 8;\n            td->td_sampleformat = SAMPLEFORMAT_UINT;\n        }\n}",
        "output": "0",
        "idx": 5929
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int xstateregs_set(struct task_struct *target, const struct user_regset *regset,\n\t\t  unsigned int pos, unsigned int count,\n\t\t  const void *kbuf, const void __user *ubuf)\n{\n\tstruct fpu *fpu = &target->thread.fpu;\n\tstruct xregs_state *xsave;\n\tint ret;\n\n\tif (!boot_cpu_has(X86_FEATURE_XSAVE))\n\t\treturn -ENODEV;\n\n\tif ((pos != 0) || (count < fpu_user_xstate_size))\n\t\treturn -EFAULT;\n\n\txsave = &fpu->state.xsave;\n\n\tfpu__activate_fpstate_write(fpu);\n\n\tif (boot_cpu_has(X86_FEATURE_XSAVES)) {\n\t\tif (kbuf)\n\t\t\tret = copy_kernel_to_xstate(xsave, kbuf);\n\t\telse\n\t\t\tret = copy_user_to_xstate(xsave, ubuf);\n\t} else {\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, xsave, 0, -1);\n\n\t\tif (!ret && xsave->header.xcomp_bv)\n\t\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\tfpstate_init(&fpu->state);\n\n\txsave->i387.mxcsr &= mxcsr_feature_mask;\n\txsave->header.xfeatures &= xfeatures_mask;\n\tmemset(&xsave->header.reserved, 0, 48);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 2417
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int unix_dgram_peer_wake_me(struct sock *sk, struct sock *other)\n{\n\tint connected;\n\n\tconnected = unix_dgram_peer_wake_connect(sk, other);\n\n\tif (unix_recvq_full(other))\n\t\treturn 1;\n\n\tif (connected)\n\t\tunix_dgram_peer_wake_disconnect(sk, other);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1371
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void perf_event_disable(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx;\n\n\tctx = perf_event_ctx_lock(event);\n\t_perf_event_disable(event);\n\tperf_event_ctx_unlock(event, ctx);\n}",
        "output": "0",
        "idx": 3843
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int udp_push_pending_frames(struct sock *sk)\n{\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi4 *fl4 = &inet->cork.fl.u.ip4;\n\tstruct sk_buff *skb;\n\tint err = 0;\n\n\tskb = ip_finish_skb(sk, fl4);\n\tif (!skb)\n\t\tgoto out;\n\n\terr = udp_send_skb(skb, fl4);\n\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}",
        "output": "0",
        "idx": 3271
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void   cJSON_DeleteItemFromArray(cJSON *array,int which)\t\t\t{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}",
        "output": "0",
        "idx": 8291
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct clock_source *dce110_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "output": "0",
        "idx": 4517
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining;\n\ts64 ns;\n\tu32 tmcct;\n\n\tASSERT(apic != NULL);\n\n\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0 ||\n\t\tapic->lapic_timer.period == 0)\n\t\treturn 0;\n\n\tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = ktime_set(0, 0);\n\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\n\treturn tmcct;\n}",
        "output": "0",
        "idx": 3423
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv)\n{\n\tstruct nci_dev *ndev = priv->ndev;\n\n\tif (priv->ndev->nfc_dev->fw_download_in_progress)\n\t\tnfcmrvl_fw_dnld_abort(priv);\n\n\tnfcmrvl_fw_dnld_deinit(priv);\n\n\tif (gpio_is_valid(priv->config.reset_n_io))\n\t\tgpio_free(priv->config.reset_n_io);\n\n\tnci_unregister_device(ndev);\n\tnci_free_device(ndev);\n\tkfree(priv);\n}",
        "output": "1",
        "idx": 2034
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileInfo, __construct)\n{\n\tspl_filesystem_object *intern;\n\tchar *path;\n\tint len;\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &path, &len) == FAILURE) {\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\treturn;\n\t}\n\n\tintern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tspl_filesystem_info_set_filename(intern, path, len, 1 TSRMLS_CC);\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\n}",
        "output": "1",
        "idx": 3956
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *bpf_any_get(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tatomic_inc(&((struct bpf_prog *)raw)->aux->refcnt);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_inc(raw, true);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn raw;\n}",
        "output": "1",
        "idx": 1244
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC void httpSetIntParam(HttpConn *conn, cchar *var, int value) \n{\n    mprSetJson(httpGetParams(conn), var, sfmt(\"%d\", value));\n}",
        "output": "1",
        "idx": 5080
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void lpc546xxEthTick(NetInterface *interface)\n{\n   if(interface->phyDriver != NULL)\n   {\n      interface->phyDriver->tick(interface);\n   }\n   else if(interface->switchDriver != NULL)\n   {\n      interface->switchDriver->tick(interface);\n   }\n   else\n   {\n   }\n}",
        "output": "1",
        "idx": 8592
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void skip_metadata(struct pstore *ps)\n{\n\tuint32_t stride = ps->exceptions_per_area + 1;\n\tchunk_t next_free = ps->next_free;\n\tif (sector_div(next_free, stride) == NUM_SNAPSHOT_HDR_CHUNKS)\n\t\tps->next_free++;\n}",
        "output": "0",
        "idx": 3321
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned int ipv6_defrag(void *priv,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tconst struct nf_hook_state *state)\n{\n\tint err;\n\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n\tif (skb->nfct && !nf_ct_is_template((struct nf_conn *)skb->nfct))\n\t\treturn NF_ACCEPT;\n#endif\n\n\terr = nf_ct_frag6_gather(state->net, skb,\n\t\t\t\t nf_ct6_defrag_user(state->hook, skb));\n\tif (err == -EINPROGRESS)\n\t\treturn NF_STOLEN;\n\n\treturn err == 0 ? NF_ACCEPT : NF_DROP;\n}",
        "output": "0",
        "idx": 2029
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(FilesystemIterator, current)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (SPL_FILE_DIR_CURRENT(intern, SPL_FILE_DIR_CURRENT_AS_PATHNAME)) {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t\tRETURN_STRINGL(intern->file_name, intern->file_name_len, 1);\n\t} else if (SPL_FILE_DIR_CURRENT(intern, SPL_FILE_DIR_CURRENT_AS_FILEINFO)) {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t\tspl_filesystem_object_create_type(0, intern, SPL_FS_INFO, NULL, return_value TSRMLS_CC);\n\t} else {\n\t\tRETURN_ZVAL(getThis(), 1, 0);\n\t}\n}",
        "output": "0",
        "idx": 5503
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xdr_krb5_principal(XDR *xdrs, krb5_principal *objp)\n{\n    int\t    ret;\n    char\t    *p = NULL;\n    krb5_principal  pr = NULL;\n    static krb5_context context = NULL;\n\n\n    if (!context &&\n\tkadm5_init_krb5_context(&context))\n       return(FALSE);\n\n    switch(xdrs->x_op) {\n    case XDR_ENCODE:\n\tif (*objp) {\n\t     if((ret = krb5_unparse_name(context, *objp, &p)) != 0)\n\t\t  return FALSE;\n\t}\n\tif(!xdr_nullstring(xdrs, &p))\n\t    return FALSE;\n\tif (p) free(p);\n\tbreak;\n    case XDR_DECODE:\n\tif(!xdr_nullstring(xdrs, &p))\n\t    return FALSE;\n\tif (p) {\n\t     ret = krb5_parse_name(context, p, &pr);\n\t     if(ret != 0)\n\t\t  return FALSE;\n\t     *objp = pr;\n\t     free(p);\n\t} else\n\t     *objp = NULL;\n\tbreak;\n    case XDR_FREE:\n\tif(*objp != NULL)\n\t    krb5_free_principal(context, *objp);\n\t*objp = NULL;\n\tbreak;\n    }\n    return TRUE;\n}",
        "output": "0",
        "idx": 53
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_checkout_nasty__git_tilde1(void)\n{\n\ttest_checkout_fails(\"refs/heads/git_tilde1\", \".git/foobar\");\n\ttest_checkout_fails(\"refs/heads/git_tilde1\", \"git~1/foobar\");\n}",
        "output": "0",
        "idx": 6845
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct crypto_template *crypto_lookup_template(const char *name)\n{\n\treturn try_then_request_module(__crypto_lookup_template(name),\n\t\t\t\t       \"crypto-%s\", name);\n}",
        "output": "0",
        "idx": 3765
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,\n\t\t    gfp_t gfp, struct dma_attrs *attrs)\n{\n\tpgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);\n\tvoid *memory;\n\n\tif (dma_alloc_from_coherent(dev, size, handle, &memory))\n\t\treturn memory;\n\n\treturn __dma_alloc(dev, size, handle, gfp, prot, false,\n\t\t\t   __builtin_return_address(0));\n}",
        "output": "0",
        "idx": 3335
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void\tcJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)\t{cJSON_AddItemToObject(object,string,create_reference(item));}",
        "output": "0",
        "idx": 8317
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t aio_setup_vectored_rw(struct kiocb *kiocb,\n\t\t\t\t     int rw, char __user *buf,\n\t\t\t\t     unsigned long *nr_segs,\n\t\t\t\t     size_t *len,\n\t\t\t\t     struct iovec **iovec,\n\t\t\t\t     bool compat,\n\t\t\t\t     struct iov_iter *iter)\n{\n\tssize_t ret;\n\n\t*nr_segs = *len;\n\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\tret = compat_rw_copy_check_uvector(rw,\n\t\t\t\t(struct compat_iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\telse\n#endif\n\t\tret = rw_copy_check_uvector(rw,\n\t\t\t\t(struct iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*len = ret;\n\tiov_iter_init(iter, rw, *iovec, *nr_segs, *len);\n\treturn 0;\n}",
        "output": "0",
        "idx": 3917
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(locale_accept_from_http)\n{\n\tUEnumeration *available;\n\tchar *http_accept = NULL;\n\tint http_accept_len;\n\tUErrorCode status = 0;\n\tint len;\n\tchar resultLocale[INTL_MAX_LOCALE_LEN+1];\n\tUAcceptResult outResult;\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &http_accept, &http_accept_len) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\"locale_accept_from_http: unable to parse input parameters\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\t\n\tavailable = ures_openAvailableLocales(NULL, &status);\n\tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to retrieve locale list\");\n\tlen = uloc_acceptLanguageFromHTTP(resultLocale, INTL_MAX_LOCALE_LEN, \n\t\t\t\t\t\t&outResult, http_accept, available, &status);\n\tuenum_close(available);\n\tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to find acceptable locale\");\n\tif (len < 0 || outResult == ULOC_ACCEPT_FAILED) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL(resultLocale, len, 1);\n}",
        "output": "1",
        "idx": 3880
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init sit_init(void)\n{\n\tint err;\n\n\tprintk(KERN_INFO \"IPv6 over IPv4 tunneling driver\\n\");\n\n\tif (xfrm4_tunnel_register(&sit_handler, AF_INET6) < 0) {\n\t\tprintk(KERN_INFO \"sit init: Can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\terr = register_pernet_device(&sit_net_ops);\n\tif (err < 0)\n\t\txfrm4_tunnel_deregister(&sit_handler, AF_INET6);\n\n\treturn err;\n}",
        "output": "1",
        "idx": 2208
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n{\n    void **ptrptr = ptr;\n    *ptrptr = av_realloc_f(*ptrptr, nmemb, size);\n    if (!*ptrptr && nmemb && size)\n        return AVERROR(ENOMEM);\n    return 0;\n}",
        "output": "0",
        "idx": 4947
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs4_close_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tstruct nfs_server *server = NFS_SERVER(calldata->inode);\n\n\tif (RPC_ASSASSINATED(task))\n\t\treturn;\n\tswitch (task->tk_status) {\n\t\tcase 0:\n\t\t\tnfs_set_open_stateid(state, &calldata->res.stateid, 0);\n\t\t\trenew_lease(server, calldata->timestamp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tif (calldata->arg.open_flags == 0)\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (nfs4_async_handle_error(task, server, state) == -EAGAIN) {\n\t\t\t\trpc_restart_call(task);\n\t\t\t\treturn;\n\t\t\t}\n\t}\n\tnfs_refresh_inode(calldata->inode, calldata->res.fattr);\n}",
        "output": "1",
        "idx": 2154
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE3(osf_sysinfo, int, command, char __user *, buf, long, count)\n{\n\tconst char *sysinfo_table[] = {\n\t\tutsname()->sysname,\n\t\tutsname()->nodename,\n\t\tutsname()->release,\n\t\tutsname()->version,\n\t\tutsname()->machine,\n\t\t\"alpha\",\t\n\t\t\"dummy\",\t\n\t\t\"dummy\",\t\n\t\t\"dummy\",\t\n\t};\n\tunsigned long offset;\n\tconst char *res;\n\tlong len, err = -EINVAL;\n\n\toffset = command-1;\n\tif (offset >= ARRAY_SIZE(sysinfo_table)) {\n\t\tprintk(\"sysinfo(%d)\", command);\n\t\tgoto out;\n\t}\n\n\tdown_read(&uts_sem);\n\tres = sysinfo_table[offset];\n\tlen = strlen(res)+1;\n\tif (len > count)\n\t\tlen = count;\n\tif (copy_to_user(buf, res, len))\n\t\terr = -EFAULT;\n\telse\n\t\terr = 0;\n\tup_read(&uts_sem);\n out:\n\treturn err;\n}",
        "output": "1",
        "idx": 414
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "magic_setparam(struct magic_set *ms, int param, const void *val)\n{\n\tswitch (param) {\n\tcase MAGIC_PARAM_INDIR_MAX:\n\t\tms->indir_max = *(const size_t *)val;\n\t\treturn 0;\n\tcase MAGIC_PARAM_NAME_MAX:\n\t\tms->name_max = *(const size_t *)val;\n\t\treturn 0;\n\tcase MAGIC_PARAM_ELF_PHNUM_MAX:\n\t\tms->elf_phnum_max = *(const size_t *)val;\n\t\treturn 0;\n\tcase MAGIC_PARAM_ELF_SHNUM_MAX:\n\t\tms->elf_shnum_max = *(const size_t *)val;\n\t\treturn 0;\n\tcase MAGIC_PARAM_ELF_NOTES_MAX:\n\t\tms->elf_notes_max = *(const size_t *)val;\n\t\treturn 0;\n\tdefault:\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n}",
        "output": "0",
        "idx": 6123
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t buf_to_uint32(char *data) {\n    size_t i;\n    uint32_t result = 0;\n\n    for (i = 0; i < sizeof(uint32_t); i++)\n        result = (result << 8) | (unsigned char)data[i];\n\n    return result;\n}",
        "output": "0",
        "idx": 5989
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n{\n    void **ptrptr = ptr;\n    *ptrptr = av_realloc_f(*ptrptr, nmemb, size);\n    if (!*ptrptr && !(nmemb && size))\n        return AVERROR(ENOMEM);\n    return 0;\n}",
        "output": "1",
        "idx": 3542
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateNull( void )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item )\n\t\titem->type = cJSON_NULL;\n\treturn item;\n}",
        "output": "1",
        "idx": 5896
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\t__releases(&keyring_serialise_link_sem)\n{\n\tBUG_ON(index_key->type == NULL);\n\tkenter(\"%d,%s,\", keyring->serial, index_key->type->name);\n\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\n\n\tif (edit && !edit->dead_leaf) {\n\t\tkey_payload_reserve(keyring,\n\t\t\t\t    keyring->datalen - KEYQUOTA_LINK_BYTES);\n\t\tassoc_array_cancel_edit(edit);\n\t}\n\tup_write(&keyring->sem);\n}",
        "output": "1",
        "idx": 2882
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct bpf_prog *bpf_patch_insn_single(struct bpf_prog *prog, u32 off,\n\t\t\t\t       const struct bpf_insn *patch, u32 len)\n{\n\tu32 insn_adj_cnt, insn_rest, insn_delta = len - 1;\n\tstruct bpf_prog *prog_adj;\n\n\tif (insn_delta == 0) {\n\t\tmemcpy(prog->insnsi + off, patch, sizeof(*patch));\n\t\treturn prog;\n\t}\n\n\tinsn_adj_cnt = prog->len + insn_delta;\n\n\tprog_adj = bpf_prog_realloc(prog, bpf_prog_size(insn_adj_cnt),\n\t\t\t\t    GFP_USER);\n\tif (!prog_adj)\n\t\treturn NULL;\n\n\tprog_adj->len = insn_adj_cnt;\n\n\tinsn_rest = insn_adj_cnt - off - len;\n\n\tmemmove(prog_adj->insnsi + off + len, prog_adj->insnsi + off + 1,\n\t\tsizeof(*patch) * insn_rest);\n\tmemcpy(prog_adj->insnsi + off, patch, sizeof(*patch) * len);\n\n\tbpf_adj_branches(prog_adj, off, insn_delta);\n\n\treturn prog_adj;\n}",
        "output": "1",
        "idx": 2956
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseLanguages(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprJson     *child;\n    cchar       *path, *prefix, *suffix;\n    int         ji;\n\n    for (ITERATE_CONFIG(route, prop, child, ji)) {\n        if ((prefix = mprReadJson(child, \"prefix\")) != 0) {\n            httpAddRouteLanguageSuffix(route, child->name, child->value, HTTP_LANG_BEFORE);\n        }\n        if ((suffix = mprReadJson(child, \"suffix\")) != 0) {\n            httpAddRouteLanguageSuffix(route, child->name, child->value, HTTP_LANG_AFTER);\n        }\n        if ((path = mprReadJson(child, \"path\")) != 0) {\n            httpAddRouteLanguageDir(route, child->name, mprGetAbsPath(path));\n        }\n        if (smatch(mprReadJson(child, \"default\"), \"default\")) {\n            httpSetRouteDefaultLanguage(route, child->name);\n        }\n    }\n}",
        "output": "0",
        "idx": 7019
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NOEXPORT int verify_callback(int preverify_ok, X509_STORE_CTX *callback_ctx) {\n    SSL *ssl;\n    CLI *c;\n\n    ssl=X509_STORE_CTX_get_ex_data(callback_ctx,\n        SSL_get_ex_data_X509_STORE_CTX_idx());\n    c=SSL_get_ex_data(ssl, index_ssl_cli);\n\n    if(!c->opt->option.verify_chain && !c->opt->option.verify_peer) {\n        s_log(LOG_INFO, \"Certificate verification disabled\");\n        return 1; \n    }\n    if(verify_checks(c, preverify_ok, callback_ctx)) {\n        SSL_SESSION *sess=SSL_get1_session(c->ssl);\n        if(sess) {\n            int ok=SSL_SESSION_set_ex_data(sess, index_session_authenticated,\n                (void *)(-1));\n            SSL_SESSION_free(sess);\n            if(!ok) {\n                sslerror(\"SSL_SESSION_set_ex_data\");\n                return 0; \n            }\n        }\n        return 1; \n    }\n    if(c->opt->option.client || c->opt->protocol)\n        return 0; \n    if(c->opt->redirect_addr.names)\n        return 1; \n    return 0; \n}",
        "output": "1",
        "idx": 8478
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mlock_vma_page(struct page *page)\n{\n\tBUG_ON(!PageLocked(page));\n\n\tif (!TestSetPageMlocked(page)) {\n\t\tmod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t\tif (!isolate_lru_page(page))\n\t\t\tputback_lru_page(page);\n\t}\n}",
        "output": "0",
        "idx": 3499
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void scsi_write_complete(void * opaque, int ret)\n{\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t len;\n    uint32_t n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_WRITE)) {\n            return;\n        }\n    }\n\n    n = r->iov.iov_len / 512;\n    r->sector += n;\n    r->sector_count -= n;\n    if (r->sector_count == 0) {\n        scsi_req_complete(&r->req, GOOD);\n    } else {\n        len = r->sector_count * 512;\n        if (len > SCSI_DMA_BUF_SIZE) {\n            len = SCSI_DMA_BUF_SIZE;\n        }\n        r->iov.iov_len = len;\n        DPRINTF(\"Write complete tag=0x%x more=%d\\n\", r->req.tag, len);\n        scsi_req_data(&r->req, len);\n    }\n}",
        "output": "1",
        "idx": 3574
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(locale_accept_from_http)\n{\n\tUEnumeration *available;\n\tchar *http_accept = NULL;\n\tint http_accept_len;\n\tUErrorCode status = 0;\n\tint len;\n\tchar resultLocale[INTL_MAX_LOCALE_LEN+1];\n\tUAcceptResult outResult;\n\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &http_accept, &http_accept_len) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\"locale_accept_from_http: unable to parse input parameters\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\n\tavailable = ures_openAvailableLocales(NULL, &status);\n\tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to retrieve locale list\");\n\tlen = uloc_acceptLanguageFromHTTP(resultLocale, INTL_MAX_LOCALE_LEN,\n\t\t\t\t\t\t&outResult, http_accept, available, &status);\n\tuenum_close(available);\n\tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to find acceptable locale\");\n\tif (len < 0 || outResult == ULOC_ACCEPT_FAILED) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL(resultLocale, len, 1);\n}",
        "output": "0",
        "idx": 5419
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateFalse(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}",
        "output": "0",
        "idx": 8259
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void sctp_generate_t3_rtx_event(unsigned long peer)\n{\n\tint error;\n\tstruct sctp_transport *transport = (struct sctp_transport *) peer;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\n\t\tif (!mod_timer(&transport->T3_rtx_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_T3_RTX),\n\t\t\t   asoc->state,\n\t\t\t   asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\n\tif (error)\n\t\tsk->sk_err = -error;\n\nout_unlock:\n\tbh_unlock_sock(sk);\n\tsctp_transport_put(transport);\n}",
        "output": "0",
        "idx": 4027
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sanitize_speculative_path(struct bpf_verifier_env *env,\n\t\t\t  const struct bpf_insn *insn,\n\t\t\t  u32 next_idx, u32 curr_idx)\n{\n\tstruct bpf_verifier_state *branch;\n\tstruct bpf_reg_state *regs;\n\n\tbranch = push_stack(env, next_idx, curr_idx, true);\n\tif (branch && insn) {\n\t\tregs = branch->frame[branch->curframe]->regs;\n\t\tif (BPF_SRC(insn->code) == BPF_K) {\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tmark_reg_unknown(env, regs, insn->src_reg);\n\t\t}\n\t}\n\treturn branch;\n}",
        "output": "0",
        "idx": 2807
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(radius_get_vendor_attr)\n{\n\tconst void *data, *raw;\n\tint len;\n\tu_int32_t vendor;\n\tunsigned char type;\n\tsize_t data_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &raw, &len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (rad_get_vendor_attr(&vendor, &type, &data, &data_len, raw, len) == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\n\t\tarray_init(return_value);\n\t\tadd_assoc_long(return_value, \"attr\", type);\n\t\tadd_assoc_long(return_value, \"vendor\", vendor);\n\t\tadd_assoc_stringl(return_value, \"data\", (char *) data, data_len, 1);\n\t\treturn;\n\t}\n}",
        "output": "0",
        "idx": 5359
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t nfs4_proc_get_acl(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tint ret;\n\n\tif (!nfs4_server_supports_acls(server))\n\t\treturn -EOPNOTSUPP;\n\tret = nfs_revalidate_inode(server, inode);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (NFS_I(inode)->cache_validity & NFS_INO_INVALID_ACL)\n\t\tnfs_zap_acl_cache(inode);\n\tret = nfs4_read_cached_acl(inode, buf, buflen);\n\tif (ret != -ENOENT)\n\t\treturn ret;\n\treturn nfs4_get_acl_uncached(inode, buf, buflen);\n}",
        "output": "0",
        "idx": 845
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(DirectoryIterator, rewind)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern->u.dir.index = 0;\n\tif (intern->u.dir.dirp) {\n\t\tphp_stream_rewinddir(intern->u.dir.dirp);\n\t}\n\tspl_filesystem_dir_read(intern TSRMLS_CC);\n}",
        "output": "1",
        "idx": 3978
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parse_content_range(URLContext *h, const char *p)\n{\n    HTTPContext *s = h->priv_data;\n    const char *slash;\n\n    if (!strncmp(p, \"bytes \", 6)) {\n        p     += 6;\n        s->off = strtoll(p, NULL, 10);\n        if ((slash = strchr(p, '/')) && strlen(slash) > 0)\n            s->filesize = strtoll(slash + 1, NULL, 10);\n    }\n    if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))\n        h->is_streamed = 0; \n}",
        "output": "1",
        "idx": 3448
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void trustedSetSEK_backup(int *errStatus, char *errString,\n                          uint8_t *encrypted_sek, uint32_t *enc_len, const char *sek_hex) {\n    CALL_ONCE\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_sek);\n    CHECK_STATE(sek_hex);\n\n    uint64_t len;\n    hex2carray(sek_hex, &len, (uint8_t *) AES_key);\n    derive_DH_Key();\n\n    sealHexSEK(errStatus, errString, encrypted_sek, enc_len, (char *)sek_hex);\n\n    if (*errStatus != 0) {\n        LOG_ERROR(\"sealHexSEK failed\");\n        goto clean;\n    }\n\n    SET_SUCCESS\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}",
        "output": "1",
        "idx": 8704
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int au1200fb_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\n{\n\tstruct au1200fb_device *fbdev = info->par;\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tpgprot_val(vma->vm_page_prot) |= _CACHE_MASK; \n\n\treturn vm_iomap_memory(vma, fbdev->fb_phys, fbdev->fb_len);\n}",
        "output": "0",
        "idx": 3341
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint ret;\n\n\tif (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM)\n\t\treturn -ENODEV;\n\n\tret = cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);\n\n\tusbnet_link_change(dev, 0, 0);\n\treturn ret;\n}",
        "output": "1",
        "idx": 1136
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,\n\t\t\t\t     int event,\n\t\t\t\t     struct timespec *tstamp,\n\t\t\t\t     unsigned long resolution)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread r1;\n\tunsigned long flags;\n\n\tif (event >= SNDRV_TIMER_EVENT_START &&\n\t    event <= SNDRV_TIMER_EVENT_PAUSE)\n\t\ttu->tstamp = *tstamp;\n\tif ((tu->filter & (1 << event)) == 0 || !tu->tread)\n\t\treturn;\n\tmemset(&r1, 0, sizeof(r1));\n\tr1.event = event;\n\tr1.tstamp = *tstamp;\n\tr1.val = resolution;\n\tspin_lock_irqsave(&tu->qlock, flags);\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tspin_unlock_irqrestore(&tu->qlock, flags);\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}",
        "output": "0",
        "idx": 1861
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void init_xml_relax_ng()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"RelaxNG\", cNokogiriXmlSchema);\n\n  cNokogiriXmlRelaxNG = klass;\n\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n}",
        "output": "1",
        "idx": 8244
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_dev_random_seed()\n{\n    DEBUG_SEED(\"get_dev_random_seed\");\n    \n    int fd = open(dev_random_file, O_RDONLY);\n    if (fd < 0) {\n        fprintf(stderr, \"error opening %s: %s\", dev_random_file, strerror(errno));\n        exit(1);\n    }\n    \n    int r;\n    ssize_t nread = read(fd, &r, sizeof(r));\n    if (nread != sizeof(r)) {\n        fprintf(stderr, \"error read %s: %s\", dev_random_file, strerror(errno));\n        exit(1);\n    }\n    else if (nread != sizeof(r)) {\n        fprintf(stderr, \"error short read %s\", dev_random_file);\n        exit(1);\n    }\n    close(fd);\n    return r;\n}",
        "output": "0",
        "idx": 5955
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void Rp_test(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint opts;\n\tResub m;\n\n\tre = js_toregexp(J, 0);\n\ttext = js_tostring(J, 1);\n\n\topts = 0;\n\tif (re->flags & JS_REGEXP_G) {\n\t\tif (re->last > strlen(text)) {\n\t\t\tre->last = 0;\n\t\t\tjs_pushboolean(J, 0);\n\t\t\treturn;\n\t\t}\n\t\tif (re->last > 0) {\n\t\t\ttext += re->last;\n\t\t\topts |= REG_NOTBOL;\n\t\t}\n\t}\n\n\tif (!js_regexec(re->prog, text, &m, opts)) {\n\t\tif (re->flags & JS_REGEXP_G)\n\t\t\tre->last = re->last + (m.sub[0].ep - text);\n\t\tjs_pushboolean(J, 1);\n\t\treturn;\n\t}\n\n\tif (re->flags & JS_REGEXP_G)\n\t\tre->last = 0;\n\n\tjs_pushboolean(J, 0);\n}",
        "output": "1",
        "idx": 7410
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "alloc_limit_failure (char *fn_name, size_t size)\n{\n    fprintf (stderr, \n             \"%s: Maximum allocation size exceeded \"\n             \"(maxsize = %lu; size = %lu).\\n\",\n             fn_name,\n             (unsigned long)alloc_limit, \n             (unsigned long)size);\n}",
        "output": "1",
        "idx": 6390
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ntlm_print_message_fields(NTLM_MESSAGE_FIELDS* fields, const char* name)\n{\n\tWLog_DBG(TAG, \"%s (Len: %\"PRIu16\" MaxLen: %\"PRIu16\" BufferOffset: %\"PRIu32\")\",\n\t         name, fields->Len, fields->MaxLen, fields->BufferOffset);\n\n\tif (fields->Len > 0)\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, fields->Buffer, fields->Len);\n}",
        "output": "0",
        "idx": 5803
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void evtchn_fifo_handle_events(unsigned cpu,\n\t\t\t\t      struct evtchn_loop_ctrl *ctrl)\n{\n\t__evtchn_fifo_handle_events(cpu, ctrl);\n}",
        "output": "0",
        "idx": 2751
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "local block_state deflate_huff(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    int bflush;             \n\n    for (;;) {\n        if (s->lookahead == 0) {\n            fill_window(s);\n            if (s->lookahead == 0) {\n                if (flush == Z_NO_FLUSH)\n                    return need_more;\n                break;      \n            }\n        }\n\n        s->match_length = 0;\n        Tracevv((stderr,\"%c\", s->window[s->strstart]));\n        _tr_tally_lit (s, s->window[s->strstart], bflush);\n        s->lookahead--;\n        s->strstart++;\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = 0;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->sym_next)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}",
        "output": "0",
        "idx": 8549
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !inode_capable(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
        "output": "1",
        "idx": 2580
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *must_realloc(void *ptr, size_t size)\n{\n\tvoid *old = ptr;\n\tdo {\n\t\tptr = realloc(old, size);\n\t} while(!ptr);\n\treturn ptr;\n}",
        "output": "0",
        "idx": 8211
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nft_flush_table(struct nft_ctx *ctx)\n{\n\tint err;\n\tstruct nft_chain *chain, *nc;\n\tstruct nft_set *set, *ns;\n\n\tlist_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {\n\t\tctx->chain = chain;\n\n\t\terr = nft_delrule_by_chain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\terr = nft_delchain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry_safe(set, ns, &ctx->table->sets, list) {\n\t\tif (set->flags & NFT_SET_ANONYMOUS &&\n\t\t    !list_empty(&set->bindings))\n\t\t\tcontinue;\n\n\t\terr = nft_delset(ctx, set);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\terr = nft_deltable(ctx);\nout:\n\treturn err;\n}",
        "output": "1",
        "idx": 2750
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\n\tget_page(buf->page);\n}",
        "output": "1",
        "idx": 3162
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mpeg4_encode_gop_header(MpegEncContext *s)\n{\n    int64_t hours, minutes, seconds;\n    int64_t time;\n\n    put_bits(&s->pb, 16, 0);\n    put_bits(&s->pb, 16, GOP_STARTCODE);\n\n    time = s->current_picture_ptr->f->pts;\n    if (s->reordered_input_picture[1])\n        time = FFMIN(time, s->reordered_input_picture[1]->f->pts);\n    time = time * s->avctx->time_base.num;\n    s->last_time_base = FFUDIV(time, s->avctx->time_base.den);\n\n    seconds = FFUDIV(time, s->avctx->time_base.den);\n    minutes = FFUDIV(seconds, 60); seconds = FFUMOD(seconds, 60);\n    hours   = FFUDIV(minutes, 60); minutes = FFUMOD(minutes, 60);\n    hours   = FFUMOD(hours  , 24);\n\n    put_bits(&s->pb, 5, hours);\n    put_bits(&s->pb, 6, minutes);\n    put_bits(&s->pb, 1, 1);\n    put_bits(&s->pb, 6, seconds);\n\n    put_bits(&s->pb, 1, !!(s->avctx->flags & AV_CODEC_FLAG_CLOSED_GOP));\n    put_bits(&s->pb, 1, 0);  \n\n    ff_mpeg4_stuffing(&s->pb);\n}",
        "output": "0",
        "idx": 4741
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void pdf_get_version(FILE *fp, pdf_t *pdf)\n{\n    char *header, *c;\n\n    header = get_header(fp);\n\n    if ((c = strstr(header, \"%PDF-\")) && \n        (c + strlen(\"%PDF-M.m\") + 2))\n    {\n        pdf->pdf_major_version = atoi(c + strlen(\"%PDF-\"));\n        pdf->pdf_minor_version = atoi(c + strlen(\"%PDF-M.\"));\n    }\n\n    free(header);\n}",
        "output": "1",
        "idx": 7460
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_set_sec_context_option(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t *context_handle,\n\t\tconst gss_OID desired_object,\n\t\tconst gss_buffer_t value)\n{\n\tOM_uint32 ret;\n\tret = gss_set_sec_context_option(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    value);\n\treturn (ret);\n}",
        "output": "1",
        "idx": 84
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void virtio_config_writel(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val = data;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return;\n    }\n\n    stl_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}",
        "output": "0",
        "idx": 5299
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "findoprnd(ITEM *ptr, int32 *pos)\n{\n\tcheck_stack_depth();\n\n\tif (ptr[*pos].type == VAL || ptr[*pos].type == VALTRUE)\n\t{\n\t\tptr[*pos].left = 0;\n\t\t(*pos)++;\n\t}\n\telse if (ptr[*pos].val == (int32) '!')\n\t{\n\t\tptr[*pos].left = 1;\n\t\t(*pos)++;\n\t\tfindoprnd(ptr, pos);\n\t}\n\telse\n\t{\n\t\tITEM\t   *curitem = &ptr[*pos];\n\t\tint32\t\ttmp = *pos;\n\n\t\t(*pos)++;\n\t\tfindoprnd(ptr, pos);\n\t\tcuritem->left = *pos - tmp;\n\t\tfindoprnd(ptr, pos);\n\t}\n}",
        "output": "0",
        "idx": 6285
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "qedi_dbg_err(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t     const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_err(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t       nfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_err(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\n\n\tva_end(va);\n}",
        "output": "1",
        "idx": 3186
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rds_ib_laddr_check(__be32 addr)\n{\n\tint ret;\n\tstruct rdma_cm_id *cm_id;\n\tstruct sockaddr_in sin;\n\n\tcm_id = rdma_create_id(NULL, NULL, RDMA_PS_TCP, IB_QPT_RC);\n\tif (IS_ERR(cm_id))\n\t\treturn PTR_ERR(cm_id);\n\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_family = AF_INET;\n\tsin.sin_addr.s_addr = addr;\n\n\tret = rdma_bind_addr(cm_id, (struct sockaddr *)&sin);\n\tif (ret || !cm_id->device ||\n\t    cm_id->device->node_type != RDMA_NODE_IB_CA)\n\t\tret = -EADDRNOTAVAIL;\n\n\trdsdebug(\"addr %pI4 ret %d node type %d\\n\",\n\t\t&addr, ret,\n\t\tcm_id->device ? cm_id->device->node_type : -1);\n\n\trdma_destroy_id(cm_id);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 3441
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ossl_cipher_update(int argc, VALUE *argv, VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char *in;\n    long in_len, out_len;\n    VALUE data, str;\n\n    rb_scan_args(argc, argv, \"11\", &data, &str);\n\n    if (!RTEST(rb_attr_get(self, id_key_set)))\n\tossl_raise(eCipherError, \"key not set\");\n\n    StringValue(data);\n    in = (unsigned char *)RSTRING_PTR(data);\n    if ((in_len = RSTRING_LEN(data)) == 0)\n        ossl_raise(rb_eArgError, \"data must not be empty\");\n    GetCipher(self, ctx);\n    out_len = in_len+EVP_CIPHER_CTX_block_size(ctx);\n    if (out_len <= 0) {\n\tossl_raise(rb_eRangeError,\n\t\t   \"data too big to make output buffer: %ld bytes\", in_len);\n    }\n\n    if (NIL_P(str)) {\n        str = rb_str_new(0, out_len);\n    } else {\n        StringValue(str);\n        rb_str_resize(str, out_len);\n    }\n\n    if (!ossl_cipher_update_long(ctx, (unsigned char *)RSTRING_PTR(str), &out_len, in, in_len))\n\tossl_raise(eCipherError, NULL);\n    assert(out_len < RSTRING_LEN(str));\n    rb_str_set_len(str, out_len);\n\n    return str;\n}",
        "output": "0",
        "idx": 8503
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void bits2int(uECC_word_t *native,\n                     const uint8_t *bits,\n                     unsigned bits_size,\n                     uECC_Curve curve) {\n    unsigned num_n_bytes = BITS_TO_BYTES(curve->num_n_bits);\n    unsigned num_n_words = BITS_TO_WORDS(curve->num_n_bits);\n    int shift;\n    uECC_word_t carry;\n    uECC_word_t *ptr;\n\n    if (bits_size > num_n_bytes) {\n        bits_size = num_n_bytes;\n    }\n\n    uECC_vli_clear(native, num_n_words);\n#if uECC_VLI_NATIVE_LITTLE_ENDIAN\n    bcopy((uint8_t *) native, bits, bits_size);\n#else\n    uECC_vli_bytesToNative(native, bits, bits_size);\n#endif    \n    if (bits_size * 8 <= (unsigned)curve->num_n_bits) {\n        return;\n    }\n    shift = bits_size * 8 - curve->num_n_bits;\n    carry = 0;\n    ptr = native + num_n_words;\n    while (ptr-- > native) {\n        uECC_word_t temp = *ptr;\n        *ptr = (temp >> shift) | carry;\n        carry = temp << (uECC_WORD_BITS - shift);\n    }\n\n    if (uECC_vli_cmp_unsafe(curve->n, native, num_n_words) != 1) {\n        uECC_vli_sub(native, native, curve->n, num_n_words);\n    }\n}",
        "output": "1",
        "idx": 8358
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int copy_regset_to_user(struct task_struct *target,\n\t\t\t\t      const struct user_regset_view *view,\n\t\t\t\t      unsigned int setno,\n\t\t\t\t      unsigned int offset, unsigned int size,\n\t\t\t\t      void __user *data)\n{\n\tconst struct user_regset *regset = &view->regsets[setno];\n\n\tif (!regset->get)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!access_ok(VERIFY_WRITE, data, size))\n\t\treturn -EIO;\n\n\treturn regset->get(target, regset, offset, size, NULL, data);\n}",
        "output": "0",
        "idx": 883
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nfs4_open_revalidate(struct inode *dir, struct dentry *dentry, int openflags, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct rpc_cred *cred;\n\tstruct nfs4_state *state;\n\tfmode_t fmode = openflags & (FMODE_READ | FMODE_WRITE);\n\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn PTR_ERR(cred);\n\tstate = nfs4_do_open(dir, &path, fmode, openflags, NULL, cred);\n\tput_rpccred(cred);\n\tif (IS_ERR(state)) {\n\t\tswitch (PTR_ERR(state)) {\n\t\t\tcase -EPERM:\n\t\t\tcase -EACCES:\n\t\t\tcase -EDQUOT:\n\t\t\tcase -ENOSPC:\n\t\t\tcase -EROFS:\n\t\t\t\tlookup_instantiate_filp(nd, (struct dentry *)state, NULL);\n\t\t\t\treturn 1;\n\t\t\tdefault:\n\t\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (state->inode == dentry->d_inode) {\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\tnfs4_intent_set_file(nd, &path, state, fmode);\n\t\treturn 1;\n\t}\n\tnfs4_close_sync(&path, state, fmode);\nout_drop:\n\td_drop(dentry);\n\treturn 0;\n}",
        "output": "0",
        "idx": 3031
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long media_device_enum_entities(struct media_device *mdev,\n\t\t\t\t       struct media_entity_desc __user *uent)\n{\n\tstruct media_entity *ent;\n\tstruct media_entity_desc u_ent;\n\n\tmemset(&u_ent, 0, sizeof(u_ent));\n\tif (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))\n\t\treturn -EFAULT;\n\n\tent = find_entity(mdev, u_ent.id);\n\n\tif (ent == NULL)\n\t\treturn -EINVAL;\n\n\tu_ent.id = ent->id;\n\tif (ent->name) {\n\t\tstrncpy(u_ent.name, ent->name, sizeof(u_ent.name));\n\t\tu_ent.name[sizeof(u_ent.name) - 1] = '\\0';\n\t} else {\n\t\tmemset(u_ent.name, 0, sizeof(u_ent.name));\n\t}\n\tu_ent.type = ent->type;\n\tu_ent.revision = ent->revision;\n\tu_ent.flags = ent->flags;\n\tu_ent.group_id = ent->group_id;\n\tu_ent.pads = ent->num_pads;\n\tu_ent.links = ent->num_links - ent->num_backlinks;\n\tmemcpy(&u_ent.raw, &ent->info, sizeof(ent->info));\n\tif (copy_to_user(uent, &u_ent, sizeof(u_ent)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
        "output": "0",
        "idx": 3507
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MprJson *queryLeaf(MprJson *obj, cchar *property, MprJson *value, int flags)\n{\n    MprJson     *child;\n\n    assert(obj);\n    assert(property && *property);\n\n    if (value) {\n        setProperty(obj, sclone(property), value);\n        return 0;\n\n    } else if (flags & MPR_JSON_REMOVE) {\n        if ((child = mprLookupJsonObj(obj, property)) != 0) {\n            return mprRemoveJsonChild(obj, child);\n        }\n        return 0;\n\n    } else {\n        return mprCloneJson(mprLookupJsonObj(obj, property));\n    }   \n}",
        "output": "1",
        "idx": 5098
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void doGet(HttpRequest req, HttpResponse res) {\n        set_content_type(res, \"text/html\");\n        if (ACTION(HOME)) {\n                LOCK(Run.mutex)\n                do_home(res);\n                END_LOCK;\n        } else if (ACTION(RUNTIME)) {\n                handle_runtime(req, res);\n        } else if (ACTION(TEST)) {\n                is_monit_running(res);\n        } else if (ACTION(ABOUT)) {\n                do_about(res);\n        } else if (ACTION(FAVICON)) {\n                printFavicon(res);\n        } else if (ACTION(PING)) {\n                do_ping(res);\n        } else if (ACTION(GETID)) {\n                do_getid(res);\n        } else {\n                handle_service(req, res);\n        }\n}",
        "output": "0",
        "idx": 8421
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pow2gt (int x)\t{\t--x;\tx|=x>>1;\tx|=x>>2;\tx|=x>>4;\tx|=x>>8;\tx|=x>>16;\treturn x+1;\t}",
        "output": "0",
        "idx": 8339
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void virtio_config_writew(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint16_t val = data;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return;\n    }\n\n    stw_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}",
        "output": "0",
        "idx": 5305
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *path_name(const struct name_path *path, const char *name)\n{\n\tconst struct name_path *p;\n\tchar *n, *m;\n\tint nlen = strlen(name);\n\tint len = nlen + 1;\n\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len)\n\t\t\tlen += p->elem_len + 1;\n\t}\n\tn = xmalloc(len);\n\tm = n + len - (nlen + 1);\n\tstrcpy(m, name);\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len) {\n\t\t\tm -= p->elem_len + 1;\n\t\t\tmemcpy(m, p->elem, p->elem_len);\n\t\t\tm[p->elem_len] = '/';\n\t\t}\n\t}\n\treturn n;\n}",
        "output": "1",
        "idx": 5184
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n{\n\tbool ret =  __f2fs_init_extent_tree(inode, i_ext);\n\n\tif (!F2FS_I(inode)->extent_tree)\n\t\tset_inode_flag(inode, FI_NO_EXTENT);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 2315
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\n\tif (prepare && skb_rtable(skb)) {\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\tskb_dst_drop(skb);\n}",
        "output": "1",
        "idx": 1452
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xfs_file_splice_write(\n\tstruct pipe_inode_info\t*pipe,\n\tstruct file\t\t*outfilp,\n\tloff_t\t\t\t*ppos,\n\tsize_t\t\t\tcount,\n\tunsigned int\t\tflags)\n{\n\tstruct inode\t\t*inode = outfilp->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tint\t\t\tioflags = 0;\n\tssize_t\t\t\tret;\n\n\tXFS_STATS_INC(xs_write_calls);\n\n\tif (outfilp->f_mode & FMODE_NOCMTIME)\n\t\tioflags |= IO_INVIS;\n\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\n\txfs_ilock(ip, XFS_IOLOCK_EXCL);\n\n\ttrace_xfs_file_splice_write(ip, count, *ppos, ioflags);\n\n\tret = generic_file_splice_write(pipe, outfilp, ppos, count, flags);\n\tif (ret > 0)\n\t\tXFS_STATS_ADD(xs_write_bytes, ret);\n\n\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\treturn ret;\n}",
        "output": "1",
        "idx": 2594
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,\n        bigint *modulus, bigint *pub_exp)\n{\n    int i, size;\n    bigint *decrypted_bi, *dat_bi;\n    bigint *bir = NULL;\n    uint8_t *block = (uint8_t *)malloc(sig_len);\n\n    dat_bi = bi_import(ctx, sig, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);\n\n    bi_export(ctx, decrypted_bi, block, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    i = 10; \n    while (block[i++] && i < sig_len);\n    size = sig_len - i;\n\n    if (size > 0)\n    {\n        int len;\n        const uint8_t *sig_ptr = get_signature(&block[i], &len);\n\n        if (sig_ptr)\n        {\n            bir = bi_import(ctx, sig_ptr, len);\n        }\n    }\n    free(block);\n    bi_clear_cache(ctx);\n    return bir;\n}",
        "output": "1",
        "idx": 7010
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void perf_bp_event(struct perf_event *bp, void *data)\n{\n\tstruct perf_sample_data sample;\n\tstruct pt_regs *regs = data;\n\n\tperf_sample_data_init(&sample, bp->attr.bp_addr);\n\n\tif (!bp->hw.state && !perf_exclude_event(bp, regs))\n\t\tperf_swevent_event(bp, 1, 1, &sample, regs);\n}",
        "output": "1",
        "idx": 528
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int do_fpu_inst(unsigned short inst, struct pt_regs *regs)\n{\n\tstruct task_struct *tsk = current;\n\tstruct sh_fpu_soft_struct *fpu = &(tsk->thread.xstate->softfpu);\n\n\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);\n\n\tif (!(task_thread_info(tsk)->status & TS_USEDFPU)) {\n\t\tfpu_init(fpu);\n\t\ttask_thread_info(tsk)->status |= TS_USEDFPU;\n\t}\n\n\treturn fpu_emulate(inst, fpu, regs);\n}",
        "output": "0",
        "idx": 623
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sas_eh_finish_cmd(struct scsi_cmnd *cmd)\n{\n\tstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(cmd->device->host);\n\tstruct domain_device *dev = cmd_to_domain_dev(cmd);\n\tstruct sas_task *task = TO_SAS_TASK(cmd);\n\n\tsas_end_task(cmd, task);\n\n\tif (dev_is_sata(dev)) {\n\t\tlist_move_tail(&cmd->eh_entry, &sas_ha->eh_ata_q);\n\t\treturn;\n\t}\n\n\tscsi_eh_finish_cmd(cmd, &sas_ha->eh_done_q);\n}",
        "output": "0",
        "idx": 2685
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hugetlbfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(dentry->d_sb);\n\tstruct hstate *h = hstate_inode(dentry->d_inode);\n\n\tbuf->f_type = HUGETLBFS_MAGIC;\n\tbuf->f_bsize = huge_page_size(h);\n\tif (sbinfo) {\n\t\tspin_lock(&sbinfo->stat_lock);\n\t\tif (sbinfo->spool) {\n\t\t\tlong free_pages;\n\n\t\t\tspin_lock(&sbinfo->spool->lock);\n\t\t\tbuf->f_blocks = sbinfo->spool->max_hpages;\n\t\t\tfree_pages = sbinfo->spool->max_hpages\n\t\t\t\t- sbinfo->spool->used_hpages;\n\t\t\tbuf->f_bavail = buf->f_bfree = free_pages;\n\t\t\tspin_unlock(&sbinfo->spool->lock);\n\t\t\tbuf->f_files = sbinfo->max_inodes;\n\t\t\tbuf->f_ffree = sbinfo->free_inodes;\n\t\t}\n\t\tspin_unlock(&sbinfo->stat_lock);\n\t}\n\tbuf->f_namelen = NAME_MAX;\n\treturn 0;\n}",
        "output": "0",
        "idx": 885
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int bad_format(\n    char *fmt)\n{\n    char     *ptr;\n    int       n = 0;\n\n    ptr = fmt;\n    while (*ptr != '\\0')\n        if (*ptr++ == '%') {\n\n            if (*ptr == '\\0')\n                return 1;\n            if (*ptr == 's' || *ptr == 'S' || *ptr == '%')\n                ptr++;\n            else if (*ptr == 'c') {\n                ptr++;\n                n = 1;\n            }\n\n            else {\n                if (*ptr == ' ' || *ptr == '+' || *ptr == '-')\n                    ptr++;\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                if (*ptr == '.')\n                    ptr++;\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                if (*ptr++ != 'l')\n                    return 1;\n                if (*ptr == 'e' || *ptr == 'f' || *ptr == 'g')\n                    ptr++;\n                else\n                    return 1;\n                n++;\n            }\n        }\n\n    return (n != 1);\n}",
        "output": "1",
        "idx": 4600
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int __fsnotify_parent(const struct path *path, struct dentry *dentry, __u32 mask)\n{\n\tstruct dentry *parent;\n\tstruct inode *p_inode;\n\tint ret = 0;\n\n\tif (!dentry)\n\t\tdentry = path->dentry;\n\n\tif (!(dentry->d_flags & DCACHE_FSNOTIFY_PARENT_WATCHED))\n\t\treturn 0;\n\n\tparent = dget_parent(dentry);\n\tp_inode = parent->d_inode;\n\n\tif (unlikely(!fsnotify_inode_watches_children(p_inode)))\n\t\t__fsnotify_update_child_dentry_flags(p_inode);\n\telse if (p_inode->i_fsnotify_mask & mask) {\n\t\tstruct name_snapshot name;\n\n\t\tmask |= FS_EVENT_ON_CHILD;\n\n\t\ttake_dentry_name_snapshot(&name, dentry);\n\t\tif (path)\n\t\t\tret = fsnotify(p_inode, mask, path, FSNOTIFY_EVENT_PATH,\n\t\t\t\t       name.name, 0);\n\t\telse\n\t\t\tret = fsnotify(p_inode, mask, dentry->d_inode, FSNOTIFY_EVENT_INODE,\n\t\t\t\t       name.name, 0);\n\t\trelease_dentry_name_snapshot(&name);\n\t}\n\n\tdput(parent);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 2353
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ram_addr_t find_ram_offset(struct uc_struct *uc, ram_addr_t size)\n{\n    RAMBlock *block, *next_block;\n    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;\n\n    assert(size != 0); \n\n    if (QLIST_EMPTY(&uc->ram_list.blocks)) {\n        return 0;\n    }\n\n    RAMBLOCK_FOREACH(block) {\n        ram_addr_t candidate, next = RAM_ADDR_MAX;\n\n        candidate = block->offset + block->max_length;\n        candidate = ROUND_UP(candidate, BITS_PER_LONG << TARGET_PAGE_BITS);\n\n        RAMBLOCK_FOREACH(next_block) {\n            if (next_block->offset >= candidate) {\n                next = MIN(next, next_block->offset);\n            }\n        }\n\n        if (next - candidate >= size && next - candidate < mingap) {\n            offset = candidate;\n            mingap = next - candidate;\n        }\n    }\n\n    if (offset == RAM_ADDR_MAX) {\n        fprintf(stderr, \"Failed to find gap of requested size: %\" PRIu64 \"\\n\",\n                (uint64_t)size);\n        abort();\n    }\n\n    return offset;\n}",
        "output": "1",
        "idx": 8750
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rza1EthEventHandler(NetInterface *interface)\n{\n   error_t error;\n\n   if((ETHER.EESR0 & ETHER_EESR0_FR) != 0)\n   {\n      ETHER.EESR0 = ETHER_EESR0_FR;\n\n      do\n      {\n         error = rza1EthReceivePacket(interface);\n\n      } while(error != ERROR_BUFFER_EMPTY);\n   }\n\n   ETHER.EESIPR0 =  ETHER_EESIPR0_TWBIP | ETHER_EESIPR0_FRIP;\n}",
        "output": "1",
        "idx": 8616
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tassert((size_t)CDF_SHORT_SEC_SIZE(h) == len);\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + CDF_SHORT_SEC_POS(h, id), len);\n\treturn len;\n}",
        "output": "1",
        "idx": 3618
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init random_int_secret_init(void)\n{\n\tget_random_bytes(random_int_secret, sizeof(random_int_secret));\n\treturn 0;\n}",
        "output": "0",
        "idx": 773
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_set_cfgdata8(struct pci_vdev *dev, int offset, uint8_t val)\n{\n\tassert(offset <= PCI_REGMAX);\n\t*(uint8_t *)(dev->cfgdata + offset) = val;\n}",
        "output": "1",
        "idx": 7624
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateArray(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}",
        "output": "0",
        "idx": 8293
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void editPackageValue(int argc, char **argv)\n{\n    cchar   *key, *value;\n    int     i;\n\n    if (argc < 1) {\n        usageError();\n        return;\n    }\n    for (i = 0; i < argc; i++) {\n        key = stok(sclone(argv[i]), \"=\", (char**) &value);\n        if (value) {\n            setPackageKey(key, value);\n        } else {\n            value = getConfigValue(key, 0);\n            if (value) { \n                printf(\"%s\\n\", value);\n            } else {\n                printf(\"undefined\\n\");\n            }\n        }\n    }\n}",
        "output": "1",
        "idx": 4986
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TRIO_PUBLIC_STRING size_t trio_length TRIO_ARGS1((string), TRIO_CONST char* string)\n{\n\treturn trio_length_max(string, INT_MAX);\n}",
        "output": "0",
        "idx": 5785
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int er_supported(ERContext *s)\n{\n    if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||\n       !s->cur_pic.f                                                  ||\n       s->cur_pic.field_picture                                       ||\n       s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO\n    )\n        return 0;\n    return 1;\n}",
        "output": "1",
        "idx": 3408
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,\n\t\t   struct br_ip *group, int type)\n{\n\tstruct br_mdb_entry entry;\n\n\tmemset(&entry, 0, sizeof(entry));\n\tentry.ifindex = port->dev->ifindex;\n\tentry.addr.proto = group->proto;\n\tentry.addr.u.ip4 = group->u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tentry.addr.u.ip6 = group->u.ip6;\n#endif\n\t__br_mdb_notify(dev, &entry, type);\n}",
        "output": "0",
        "idx": 1201
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *read_file(char *path, size_t *length)\n{\n\tint fd;\n\tchar buf[4096], *copy = NULL;\n\n\tif (!length)\n\t\treturn NULL;\n\n\tfd = open(path, O_RDONLY | O_CLOEXEC);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\t*length = 0;\n\tfor (;;) {\n\t\tint n;\n\n\t\tn = read(fd, buf, sizeof(buf));\n\t\tif (n < 0)\n\t\t\tgoto error;\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tcopy = must_realloc(copy, (*length + n) * sizeof(*copy));\n\t\tmemcpy(copy + *length, buf, n);\n\t\t*length += n;\n\t}\n\tclose(fd);\n\treturn copy;\n\nerror:\n\tclose(fd);\n\tfree(copy);\n\treturn NULL;\n}",
        "output": "0",
        "idx": 8203
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void exit_io_context(void)\n{\n\tstruct io_context *ioc;\n\n\ttask_lock(current);\n\tioc = current->io_context;\n\tcurrent->io_context = NULL;\n\ttask_unlock(current);\n\n\tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n\t\tif (ioc->aic && ioc->aic->exit)\n\t\t\tioc->aic->exit(ioc->aic);\n\t\tcfq_exit(ioc);\n\n\t\tput_io_context(ioc);\n\t}\n}",
        "output": "1",
        "idx": 2188
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mb2_cache_destroy(struct mb2_cache *cache)\n{\n\tstruct mb2_cache_entry *entry, *next;\n\n\tunregister_shrinker(&cache->c_shrink);\n\n\tlist_for_each_entry_safe(entry, next, &cache->c_lru_list, e_lru_list) {\n\t\tif (!hlist_bl_unhashed(&entry->e_hash_list)) {\n\t\t\thlist_bl_del_init(&entry->e_hash_list);\n\t\t\tatomic_dec(&entry->e_refcnt);\n\t\t} else\n\t\t\tWARN_ON(1);\n\t\tlist_del(&entry->e_lru_list);\n\t\tWARN_ON(atomic_read(&entry->e_refcnt) != 1);\n\t\tmb2_cache_entry_put(cache, entry);\n\t}\n\tkfree(cache->c_hash);\n\tkfree(cache);\n\tmodule_put(THIS_MODULE);\n}",
        "output": "0",
        "idx": 1599
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int ext4_should_dioread_nolock(struct inode *inode)\n{\n\tif (!test_opt(inode->i_sb, DIOREAD_NOLOCK))\n\t\treturn 0;\n\tif (test_opt(inode->i_sb, NOBH))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (!(EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL))\n\t\treturn 0;\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\treturn 1;\n}",
        "output": "0",
        "idx": 3151
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CURLcode Curl_auth_create_plain_message(struct Curl_easy *data,\n                                        const char *userp,\n                                        const char *passwdp,\n                                        char **outptr, size_t *outlen)\n{\n  CURLcode result;\n  char *plainauth;\n  size_t ulen;\n  size_t plen;\n  size_t plainlen;\n\n  *outlen = 0;\n  *outptr = NULL;\n  ulen = strlen(userp);\n  plen = strlen(passwdp);\n\n  if((ulen > SIZE_T_MAX/2) || (plen > (SIZE_T_MAX/2 - 2)))\n    return CURLE_OUT_OF_MEMORY;\n  plainlen = 2 * ulen + plen + 2;\n\n  plainauth = malloc(plainlen);\n  if(!plainauth)\n    return CURLE_OUT_OF_MEMORY;\n\n  memcpy(plainauth, userp, ulen);\n  plainauth[ulen] = '\\0';\n  memcpy(plainauth + ulen + 1, userp, ulen);\n  plainauth[2 * ulen + 1] = '\\0';\n  memcpy(plainauth + 2 * ulen + 2, passwdp, plen);\n\n  result = Curl_base64_encode(data, plainauth, plainlen, outptr, outlen);\n  free(plainauth);\n\n  return result;\n}",
        "output": "1",
        "idx": 6036
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static cchar *setHeadersFromCache(HttpConn *conn, cchar *content)\n{\n    cchar   *data;\n    char    *header, *headers, *key, *value, *tok;\n\n    if ((data = strstr(content, \"\\n\\n\")) == 0) {\n        data = content;\n    } else {\n        headers = snclone(content, data - content);\n        data += 2;\n        for (header = stok(headers, \"\\n\", &tok); header; header = stok(NULL, \"\\n\", &tok)) {\n            key = stok(header, \": \", &value);\n            if (smatch(key, \"X-Status\")) {\n                conn->tx->status = (int) stoi(value);\n            } else {\n                httpAddHeaderString(conn, key, value);\n            }\n        }\n    }\n    return data;\n}",
        "output": "1",
        "idx": 5048
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void encode_openhdr(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\t__be32 *p;\n\tRESERVE_SPACE(8);\n\tWRITE32(OP_OPEN);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->open_flags);\n\tRESERVE_SPACE(28);\n\tWRITE64(arg->clientid);\n\tWRITE32(16);\n\tWRITEMEM(\"open id:\", 8);\n\tWRITE64(arg->id);\n}",
        "output": "1",
        "idx": 2174
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "yank_copy_line(struct block_def *bd, long y_idx, int exclude_trailing_space)\n{\n    char_u\t*pnew;\n\n    if (exclude_trailing_space)\n\tbd->endspaces = 0;\n    if ((pnew = alloc(bd->startspaces + bd->endspaces + bd->textlen + 1))\n\t\t\t\t\t\t\t\t      == NULL)\n\treturn FAIL;\n    y_current->y_array[y_idx] = pnew;\n    vim_memset(pnew, ' ', (size_t)bd->startspaces);\n    pnew += bd->startspaces;\n    mch_memmove(pnew, bd->textstart, (size_t)bd->textlen);\n    pnew += bd->textlen;\n    vim_memset(pnew, ' ', (size_t)bd->endspaces);\n    pnew += bd->endspaces;\n    if (exclude_trailing_space)\n    {\n\tint s = bd->textlen + bd->endspaces;\n\n\twhile (s > 0 && VIM_ISWHITE(*(bd->textstart + s - 1)))\n\t{\n\t    s = s - (*mb_head_off)(bd->textstart, bd->textstart + s - 1) - 1;\n\t    pnew--;\n\t}\n    }\n    *pnew = NUL;\n    return OK;\n}",
        "output": "0",
        "idx": 7973
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(locale_get_display_language)\n{\n    get_icu_disp_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}",
        "output": "0",
        "idx": 5415
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "wb_prep(netdissect_options *ndo,\n        const struct pkt_prep *prep, u_int len)\n{\n\tint n;\n\tconst struct pgstate *ps;\n\tconst u_char *ep = ndo->ndo_snapend;\n\n\tND_PRINT((ndo, \" wb-prep:\"));\n\tif (len < sizeof(*prep) || !ND_TTEST(*prep))\n\t\treturn (-1);\n\tn = EXTRACT_32BITS(&prep->pp_n);\n\tps = (const struct pgstate *)(prep + 1);\n\twhile (--n >= 0 && ND_TTEST(*ps)) {\n\t\tconst struct id_off *io, *ie;\n\t\tchar c = '<';\n\n\t\tND_PRINT((ndo, \" %u/%s:%u\",\n\t\t    EXTRACT_32BITS(&ps->slot),\n\t\t    ipaddr_string(ndo, &ps->page.p_sid),\n\t\t    EXTRACT_32BITS(&ps->page.p_uid)));\n\t\tio = (const struct id_off *)(ps + 1);\n\t\tfor (ie = io + ps->nid; io < ie && ND_TTEST(*io); ++io) {\n\t\t\tND_PRINT((ndo, \"%c%s:%u\", c, ipaddr_string(ndo, &io->id),\n\t\t\t    EXTRACT_32BITS(&io->off)));\n\t\t\tc = ',';\n\t\t}\n\t\tND_PRINT((ndo, \">\"));\n\t\tps = (const struct pgstate *)io;\n\t}\n\treturn ((const u_char *)ps <= ep? 0 : -1);\n}",
        "output": "0",
        "idx": 6707
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_lnums(int do_curwin)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif ((do_curwin || wp != curwin) && wp->w_buffer == curbuf)\n\t{\n\t    wp->w_save_cursor.w_cursor_save = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_save = wp->w_topline;\n\n\t    if (wp->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\twp->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    if (wp->w_topline > curbuf->b_ml.ml_line_count)\n\t\twp->w_topline = curbuf->b_ml.ml_line_count;\n\n\t    wp->w_save_cursor.w_cursor_corr = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_corr = wp->w_topline;\n\t}\n}",
        "output": "1",
        "idx": 5804
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void clear_evtchn_to_irq_row(unsigned row)\n{\n\tunsigned col;\n\n\tfor (col = 0; col < EVTCHN_PER_ROW; col++)\n\t\tWRITE_ONCE(evtchn_to_irq[row][col], -1);\n}",
        "output": "0",
        "idx": 2711
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\n\tstatic u32 challenge_timestamp;\n\tstatic unsigned int challenge_count;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 now;\n\n\tif (tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n\t\t\t\t &tp->last_oow_ack_time))\n\t\treturn;\n\n\tnow = jiffies / HZ;\n\tif (now != challenge_timestamp) {\n\t\tchallenge_timestamp = now;\n\t\tchallenge_count = 0;\n\t}\n\tif (++challenge_count <= sysctl_tcp_challenge_ack_limit) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\n\t\ttcp_send_ack(sk);\n\t}\n}",
        "output": "1",
        "idx": 1298
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "krb5_gss_context_time(minor_status, context_handle, time_rec)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    OM_uint32 *time_rec;\n{\n    krb5_error_code code;\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_timestamp now;\n    krb5_deltat lifetime;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    if ((code = krb5_timeofday(ctx->k5_context, &now))) {\n        *minor_status = code;\n        save_error_info(*minor_status, ctx->k5_context);\n        return(GSS_S_FAILURE);\n    }\n\n    if ((lifetime = ctx->krb_times.endtime - now) <= 0) {\n        *time_rec = 0;\n        *minor_status = 0;\n        return(GSS_S_CONTEXT_EXPIRED);\n    } else {\n        *time_rec = lifetime;\n        *minor_status = 0;\n        return(GSS_S_COMPLETE);\n    }\n}",
        "output": "1",
        "idx": 20
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\tif (!prev || !mmget_still_valid(mm) || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}",
        "output": "0",
        "idx": 4387
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_user_commands(expand_T *xp UNUSED, int idx)\n{\n    buf_T *buf =\n#ifdef FEAT_CMDWIN\n\tis_in_cmdwin() ? prevwin->w_buffer :\n#endif\n\tcurbuf;\n\n    if (idx < buf->b_ucmds.ga_len)\n\treturn USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;\n    idx -= buf->b_ucmds.ga_len;\n    if (idx < ucmds.ga_len)\n\treturn USER_CMD(idx)->uc_name;\n    return NULL;\n}",
        "output": "1",
        "idx": 5748
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int wc_ecc_gen_k(WC_RNG* rng, int size, mp_int* k, mp_int* order)\n{\n    int err;\n#ifdef WOLFSSL_SMALL_STACK\n    byte* buf;\n#else\n    byte  buf[ECC_MAXSIZE_GEN];\n#endif\n\n#ifdef WOLFSSL_SMALL_STACK\n    buf = (byte*)XMALLOC(ECC_MAXSIZE_GEN, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n    if (buf == NULL)\n        return MEMORY_E;\n#endif\n\n    size += 8;\n\n    err = wc_RNG_GenerateBlock(rng, buf, size);\n\n    if (err == 0)\n        err = mp_read_unsigned_bin(k, (byte*)buf, size);\n\n    if (err == MP_OKAY) {\n        if (mp_iszero(k) == MP_YES)\n          err = MP_ZERO_E;\n    }\n\n    if (err == MP_OKAY) {\n        if (mp_cmp(k, order) != MP_LT) {\n            err = mp_mod(k, order, k);\n        }\n    }\n\n    ForceZero(buf, ECC_MAXSIZE);\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(buf, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n#endif\n\n    return err;\n}",
        "output": "1",
        "idx": 6762
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n\n}",
        "output": "0",
        "idx": 3267
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int put_chars(u32 vtermno, const char *buf, int count)\n{\n\tstruct port *port;\n\tstruct scatterlist sg[1];\n\n\tif (unlikely(early_put_chars))\n\t\treturn early_put_chars(vtermno, buf, count);\n\n\tport = find_port_by_vtermno(vtermno);\n\tif (!port)\n\t\treturn -EPIPE;\n\n\tsg_init_one(sg, buf, count);\n\treturn __send_to_port(port, sg, 1, count, (void *)buf, false);\n}",
        "output": "1",
        "idx": 1498
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BOOL nsc_encode_sse2(NSC_CONTEXT* context, const BYTE* data,\n                            UINT32 scanline)\n{\n\tnsc_encode_argb_to_aycocg_sse2(context, data, scanline);\n\n\tif (context->ChromaSubsamplingLevel > 0)\n\t{\n\t\tnsc_encode_subsampling_sse2(context);\n\t}\n\n\treturn TRUE;\n}",
        "output": "0",
        "idx": 5833
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\n\ncan_read_key:\n\tret = key_validate(key);\n\tif (ret == 0) {\n\t\tret = -EOPNOTSUPP;\n\t\tif (key->type->read) {\n\t\t\tdown_read(&key->sem);\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\t\tup_read(&key->sem);\n\t\t}\n\t}\n\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}",
        "output": "1",
        "idx": 998
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PredictorDecodeTile(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)\n{\n\tTIFFPredictorState *sp = PredictorState(tif);\n\n\tassert(sp != NULL);\n\tassert(sp->decodetile != NULL);\n\n\tif ((*sp->decodetile)(tif, op0, occ0, s)) {\n\t\ttmsize_t rowsize = sp->rowsize;\n\t\tassert(rowsize > 0);\n\t\tassert((occ0%rowsize)==0);\n\t\tassert(sp->decodepfunc != NULL);\n\t\twhile (occ0 > 0) {\n\t\t\t(*sp->decodepfunc)(tif, op0, rowsize);\n\t\t\tocc0 -= rowsize;\n\t\t\top0 += rowsize;\n\t\t}\n\t\treturn 1;\n\t} else\n\t\treturn 0;\n}",
        "output": "1",
        "idx": 4282
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n\n\n    QLIST_REMOVE(block, next);\n    uc->ram_list.mru_block = NULL;\n    reclaim_ramblock(uc, block);\n}",
        "output": "1",
        "idx": 8748
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent)\n{\n\tint inspt;\n\tint i;\n\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tif (tab->ents[i]->ind > ent->ind) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tinspt = i;\n\n\tif (tab->numents >= tab->maxents) {\n\t\tif (jpc_ppxstab_grow(tab, tab->maxents + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfor (i = tab->numents; i > inspt; --i) {\n\t\ttab->ents[i] = tab->ents[i - 1];\n\t}\n\ttab->ents[i] = ent;\n\t++tab->numents;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 8938
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PredictorDecodeRow(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)\n{\n\tTIFFPredictorState *sp = PredictorState(tif);\n\n\tassert(sp != NULL);\n\tassert(sp->decoderow != NULL);\n\tassert(sp->decodepfunc != NULL);  \n\n\tif ((*sp->decoderow)(tif, op0, occ0, s)) {\n\t\treturn (*sp->decodepfunc)(tif, op0, occ0);\n\t} else\n\t\treturn 0;\n}",
        "output": "0",
        "idx": 5905
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pcrypt_free(struct crypto_instance *inst)\n{\n\tstruct pcrypt_instance_ctx *ctx = crypto_instance_ctx(inst);\n\n\tcrypto_drop_aead(&ctx->spawn);\n\tkfree(inst);\n}",
        "output": "1",
        "idx": 1816
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void sem_putref(struct sem_array *sma)\n{\n\tsem_lock_and_putref(sma);\n\tsem_unlock(sma, -1);\n}",
        "output": "0",
        "idx": 3203
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hb_set_intersect (hb_set_t       *set,\n\t\t  const hb_set_t *other)\n{\n  set->intersect (*other);\n}",
        "output": "0",
        "idx": 7763
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int async_polkit_callback(sd_bus_message *reply, void *userdata, sd_bus_error *error) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error_buffer = SD_BUS_ERROR_NULL;\n        AsyncPolkitQuery *q = userdata;\n        int r;\n\n        assert(reply);\n        assert(q);\n\n        q->slot = sd_bus_slot_unref(q->slot);\n        q->reply = sd_bus_message_ref(reply);\n\n        r = sd_bus_message_rewind(q->request, true);\n        if (r < 0) {\n                r = sd_bus_reply_method_errno(q->request, r, NULL);\n                goto finish;\n        }\n\n        r = q->callback(q->request, q->userdata, &error_buffer);\n        r = bus_maybe_reply_error(q->request, r, &error_buffer);\n\nfinish:\n        async_polkit_query_free(q);\n\n        return r;\n}",
        "output": "1",
        "idx": 5488
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int hugetlb_get_quota(struct address_space *mapping, long delta)\n{\n\tint ret = 0;\n\tstruct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(mapping->host->i_sb);\n\n\tif (sbinfo->free_blocks > -1) {\n\t\tspin_lock(&sbinfo->stat_lock);\n\t\tif (sbinfo->free_blocks - delta >= 0)\n\t\t\tsbinfo->free_blocks -= delta;\n\t\telse\n\t\t\tret = -ENOMEM;\n\t\tspin_unlock(&sbinfo->stat_lock);\n\t}\n\n\treturn ret;\n}",
        "output": "1",
        "idx": 680
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseRoutes(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprJson     *child;\n    HttpRoute   *newRoute;\n    cchar       *pattern;\n    int         ji;\n\n    if (route->loaded) {\n        mprLog(\"warn http config\", 1, \"Skip reloading routes - must reboot if routes are modified\");\n        return;\n    }\n    if (prop->type & MPR_JSON_STRING) {\n        httpAddRouteSet(route, prop->value);\n\n    } else if (prop->type & MPR_JSON_ARRAY) {\n        key = sreplace(key, \".routes\", \"\");\n        for (ITERATE_CONFIG(route, prop, child, ji)) {\n            if (child->type & MPR_JSON_STRING) {\n                httpAddRouteSet(route, child->value);\n\n            } else if (child->type & MPR_JSON_OBJ) {\n                newRoute = 0;\n                pattern = mprReadJson(child, \"pattern\");\n                if (pattern) {\n                    newRoute = httpLookupRouteByPattern(route->host, pattern);\n                    if (!newRoute) {\n                        newRoute = httpCreateInheritedRoute(route);\n                        httpSetRouteHost(newRoute, route->host);\n                    }\n                } else {\n                    newRoute = route;\n                }\n                parseAll(newRoute, key, child);\n                if (newRoute->error) {\n                    break;\n                }\n                if (pattern) {\n                    httpFinalizeRoute(newRoute);\n                }\n            }\n        }\n    }\n}",
        "output": "0",
        "idx": 7031
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool path_connected(const struct path *path)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\n\tif (mnt->mnt_root == mnt->mnt_sb->s_root)\n\t\treturn true;\n\n\treturn is_subdir(path->dentry, mnt->mnt_root);\n}",
        "output": "0",
        "idx": 4001
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "goto_tabpage_tp(\n    tabpage_T\t*tp,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    CHECK_CMDWIN;\n\n    set_keep_msg(NULL, 0);\n\n    if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer,\n\t\t\t\t\ttrigger_leave_autocmds) == OK)\n    {\n\tif (valid_tabpage(tp))\n\t    enter_tabpage(tp, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n\telse\n\t    enter_tabpage(curtab, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n    }\n}",
        "output": "0",
        "idx": 8013
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}",
        "output": "0",
        "idx": 3691
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint16_t enc624j600ReadPhyReg(NetInterface *interface, uint8_t address)\n{\n   enc624j600WriteReg(interface, ENC624J600_REG_MIREGADR, MIREGADR_R8 | address);\n   enc624j600WriteReg(interface, ENC624J600_REG_MICMD, MICMD_MIIRD);\n\n   usleep(100);\n   while((enc624j600ReadReg(interface, ENC624J600_REG_MISTAT) & MISTAT_BUSY) != 0)\n   {\n   }\n\n   enc624j600WriteReg(interface, ENC624J600_REG_MICMD, 0x00);\n\n   return enc624j600ReadReg(interface, ENC624J600_REG_MIRD);\n}",
        "output": "1",
        "idx": 8566
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Curl_attach_connnection(struct Curl_easy *data,\n                             struct connectdata *conn)\n{\n  DEBUGASSERT(!data->conn);\n  DEBUGASSERT(conn);\n  data->conn = conn;\n  Curl_llist_insert_next(&conn->easyq, conn->easyq.tail, data,\n                         &data->conn_queue);\n  if(conn->handler->attach)\n    conn->handler->attach(data, conn);\n  Curl_ssl_associate_conn(data, conn);\n}",
        "output": "0",
        "idx": 8453
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mcs_parse_domain_params(STREAM s)\n{\n\tint length;\n\n\tber_parse_header(s, MCS_TAG_DOMAIN_PARAMS, &length);\n\tin_uint8s(s, length);\n\n\treturn s_check(s);\n}",
        "output": "1",
        "idx": 7138
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w){\n    long i;\n#if !HAVE_FAST_UNALIGNED\n    if((long)src2 & (sizeof(long)-1)){\n        for(i=0; i+7<w; i+=8){\n            dst[i+0] = src1[i+0]-src2[i+0];\n            dst[i+1] = src1[i+1]-src2[i+1];\n            dst[i+2] = src1[i+2]-src2[i+2];\n            dst[i+3] = src1[i+3]-src2[i+3];\n            dst[i+4] = src1[i+4]-src2[i+4];\n            dst[i+5] = src1[i+5]-src2[i+5];\n            dst[i+6] = src1[i+6]-src2[i+6];\n            dst[i+7] = src1[i+7]-src2[i+7];\n        }\n    }else\n#endif\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n        long a = *(long*)(src1+i);\n        long b = *(long*)(src2+i);\n        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] = src1[i+0]-src2[i+0];\n}",
        "output": "1",
        "idx": 3558
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int stellaris_enet_load(QEMUFile *f, void *opaque, int version_id)\n{\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n    int i;\n\n    if (version_id != 1)\n        return -EINVAL;\n\n    s->ris = qemu_get_be32(f);\n    s->im = qemu_get_be32(f);\n    s->rctl = qemu_get_be32(f);\n    s->tctl = qemu_get_be32(f);\n    s->thr = qemu_get_be32(f);\n    s->mctl = qemu_get_be32(f);\n    s->mdv = qemu_get_be32(f);\n    s->mtxd = qemu_get_be32(f);\n    s->mrxd = qemu_get_be32(f);\n    s->np = qemu_get_be32(f);\n    s->tx_fifo_len = qemu_get_be32(f);\n    qemu_get_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n    for (i = 0; i < 31; i++) {\n        s->rx[i].len = qemu_get_be32(f);\n        qemu_get_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n\n    }\n    s->next_packet = qemu_get_be32(f);\n    s->rx_fifo_offset = qemu_get_be32(f);\n\n    return 0;\n}",
        "output": "1",
        "idx": 3782
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "disconnect_ice_connection (IceConn ice_conn)\n{\n        IceSetShutdownNegotiation (ice_conn, FALSE);\n        IceCloseConnection (ice_conn);\n}",
        "output": "0",
        "idx": 8725
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void nfs4_close_state(struct path *path, struct nfs4_state *state, mode_t mode)\n{\n\t__nfs4_close(path, state, mode, 0);\n}",
        "output": "1",
        "idx": 2170
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_flags);\n\n\thook_del_nick_can_register(check_registration_keywords);\n\n\thook_del_user_can_register(check_registration_keywords);\n\n\tdel_conf_item(\"ANOPE_FLAGS_COMPAT\", &chansvs.me->conf_table);\n}",
        "output": "0",
        "idx": 7131
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int proc_dmesg_restrict(struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n}",
        "output": "0",
        "idx": 399
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct hugepage_subpool *hugepage_new_subpool(long nr_blocks)\n{\n\tstruct hugepage_subpool *spool;\n\n\tspool = kmalloc(sizeof(*spool), GFP_KERNEL);\n\tif (!spool)\n\t\treturn NULL;\n\n\tspin_lock_init(&spool->lock);\n\tspool->count = 1;\n\tspool->max_hpages = nr_blocks;\n\tspool->used_hpages = 0;\n\n\treturn spool;\n}",
        "output": "0",
        "idx": 893
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\tunsigned char max_level = 0;\n\tint unix_sock_count = 0;\n\n\tfor (i = scm->fp->count - 1; i >= 0; i--) {\n\t\tstruct sock *sk = unix_get_socket(scm->fp->fp[i]);\n\n\t\tif (sk) {\n\t\t\tunix_sock_count++;\n\t\t\tmax_level = max(max_level,\n\t\t\t\t\tunix_sk(sk)->recursion_level);\n\t\t}\n\t}\n\tif (unlikely(max_level > MAX_RECURSION_LEVEL))\n\t\treturn -ETOOMANYREFS;\n\n\tUNIXCB(skb).fp = scm_fp_dup(scm->fp);\n\tif (!UNIXCB(skb).fp)\n\t\treturn -ENOMEM;\n\n\tif (unix_sock_count) {\n\t\tfor (i = scm->fp->count - 1; i >= 0; i--)\n\t\t\tunix_inflight(scm->fp->fp[i]);\n\t}\n\treturn max_level;\n}",
        "output": "1",
        "idx": 1022
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void * gdImageWBMPPtr (gdImagePtr im, int *size, int fg)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (!_gdImageWBMPCtx(im, fg, out)) {\n\t\trv = gdDPExtractData(out, size);\n\t} else {\n\t\trv = NULL;\n\t}\n\tout->gd_free(out);\n\n\treturn rv;\n}",
        "output": "0",
        "idx": 5703
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hb_set_set (hb_set_t       *set,\n\t    const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n\n  set->set (*other);\n}",
        "output": "1",
        "idx": 5558
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int truncate_inline_extent(struct inode *inode,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct btrfs_key *found_key,\n\t\t\t\t  const u64 item_end,\n\t\t\t\t  const u64 new_size)\n{\n\tstruct extent_buffer *leaf = path->nodes[0];\n\tint slot = path->slots[0];\n\tstruct btrfs_file_extent_item *fi;\n\tu32 size = (u32)(new_size - found_key->offset);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\n\tif (btrfs_file_extent_compression(leaf, fi) != BTRFS_COMPRESS_NONE) {\n\t\tloff_t offset = new_size;\n\t\tloff_t page_end = ALIGN(offset, PAGE_CACHE_SIZE);\n\n\t\tbtrfs_release_path(path);\n\t\treturn btrfs_truncate_page(inode, offset, page_end - offset, 0);\n\t}\n\n\tbtrfs_set_file_extent_ram_bytes(leaf, fi, size);\n\tsize = btrfs_file_extent_calc_inline_size(size);\n\tbtrfs_truncate_item(root, path, size, 1);\n\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\tinode_sub_bytes(inode, item_end + 1 - new_size);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 4047
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __exit xfrm6_tunnel_fini(void)\n{\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\n\tunregister_pernet_subsys(&xfrm6_tunnel_net_ops);\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n}",
        "output": "0",
        "idx": 3145
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dvb_usbv2_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *name = d->name;\n\tstruct device dev = d->udev->dev;\n\n\tdev_dbg(&d->udev->dev, \"%s: bInterfaceNumber=%d\\n\", __func__,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\n\tif (d->props->exit)\n\t\td->props->exit(d);\n\n\tdvb_usbv2_exit(d);\n\n\tdev_info(&dev, \"%s: '%s' successfully deinitialized and disconnected\\n\",\n\t\t\tKBUILD_MODNAME, name);\n}",
        "output": "1",
        "idx": 1468
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "snmp_ber_encode_unsigned_integer(unsigned char *out, uint32_t *out_len, uint8_t type, uint32_t number)\n{\n  uint32_t original_out_len;\n\n  original_out_len = *out_len;\n  do {\n    (*out_len)++;\n    *out-- = (uint8_t)(number & 0xFF);\n    number >>= 8;\n  } while(number);\n\n  out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF));\n  out = snmp_ber_encode_type(out, out_len, type);\n\n  return out;\n}",
        "output": "1",
        "idx": 7952
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "do_encrypt (const RIJNDAEL_context *ctx,\n            unsigned char *bx, const unsigned char *ax)\n{\n#ifdef USE_AMD64_ASM\n  return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n\t\t\t\t       encT);\n#elif defined(USE_ARM_ASM)\n  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);\n#else\n  return do_encrypt_fn (ctx, bx, ax);\n#endif \n}",
        "output": "1",
        "idx": 7442
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_DetachItemFromArray( cJSON *array, int which )\n{\n\tcJSON *c = array->child;\n\twhile ( c && which > 0 ) {\n\t\tc = c->next;\n\t\t--which;\n\t}\n\tif ( ! c )\n\t\treturn 0;\n\tif ( c->prev )\n\t\tc->prev->next = c->next;\n\tif ( c->next ) c->next->prev = c->prev;\n\tif ( c == array->child )\n\t\tarray->child = c->next;\n\tc->prev = c->next = 0;\n\treturn c;\n}",
        "output": "1",
        "idx": 5894
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cib_remote_command_dispatch(gpointer user_data)\n{\n    int disconnected = 0;\n    cib_t *cib = user_data;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n\n    crm_recv_remote_msg(private->command.session, &private->command.recv_buf, private->command.encrypted, -1, &disconnected);\n\n    free(private->command.recv_buf);\n    private->command.recv_buf = NULL;\n    crm_err(\"received late reply for remote cib connection, discarding\");\n\n    if (disconnected) {\n        return -1;\n    }\n    return 0;\n}",
        "output": "0",
        "idx": 5235
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tvoid *vapic;\n\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI) & 0xff;\n\tmax_irr = apic_find_highest_irr(apic);\n\tif (max_irr < 0)\n\t\tmax_irr = 0;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\n\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n\t*(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr)) = data;\n\tkunmap_atomic(vapic);\n}",
        "output": "1",
        "idx": 2482
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct ip_options_rcu *tcp_v4_save_options(struct sock *sk,\n\t\t\t\t\t\t  struct sk_buff *skb)\n{\n\tconst struct ip_options *opt = &(IPCB(skb)->opt);\n\tstruct ip_options_rcu *dopt = NULL;\n\n\tif (opt && opt->optlen) {\n\t\tint opt_size = sizeof(*dopt) + opt->optlen;\n\n\t\tdopt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (dopt) {\n\t\t\tif (ip_options_echo(&dopt->opt, skb)) {\n\t\t\t\tkfree(dopt);\n\t\t\t\tdopt = NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn dopt;\n}",
        "output": "0",
        "idx": 511
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileInfo, getRealPath)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar buff[MAXPATHLEN];\n\tchar *filename;\n\tzend_error_handling error_handling;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n\tif (intern->type == SPL_FS_DIR && !intern->file_name && intern->u.dir.entry.d_name[0]) {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t}\n\n\tif (intern->orig_path) {\n\t\tfilename = intern->orig_path;\n\t} else {\n\t\tfilename = intern->file_name;\n\t}\n\n\n\tif (filename && VCWD_REALPATH(filename, buff)) {\n#ifdef ZTS\n\t\tif (VCWD_ACCESS(buff, F_OK)) {\n\t\t\tRETVAL_FALSE;\n\t\t} else\n#endif\n\t\tRETVAL_STRING(buff, 1);\n\t} else {\n\t\tRETVAL_FALSE;\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}",
        "output": "0",
        "idx": 5515
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dsOpen(void) {\n    struct stat sb;\n    int retval;\n    char *path = server.diskstore_path;\n\n    if ((retval = stat(path,&sb) == -1) && errno != ENOENT) {\n        redisLog(REDIS_WARNING, \"Error opening disk store at %s: %s\",\n                path, strerror(errno));\n        return REDIS_ERR;\n    }\n\n    if (retval == 0 && S_ISDIR(sb.st_mode)) return REDIS_OK;\n\n    if (retval == 0 && !S_ISDIR(sb.st_mode)) {\n        redisLog(REDIS_WARNING,\"Disk store at %s is not a directory\", path);\n        return REDIS_ERR;\n    }\n\n    if (mkdir(path) == -1) {\n        redisLog(REDIS_WARNING,\"Disk store init failed creating dir %s: %s\",\n            path, strerror(errno));\n        return REDIS_ERR;\n    }\n    return REDIS_OK;\n}",
        "output": "1",
        "idx": 3650
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_hrtimer_start(struct snd_timer *t)\n{\n\tstruct snd_hrtimer *stime = t->private_data;\n\n\tatomic_set(&stime->running, 0);\n\thrtimer_cancel(&stime->hrt);\n\thrtimer_start(&stime->hrt, ns_to_ktime(t->sticks * resolution),\n\t\t      HRTIMER_MODE_REL);\n\tatomic_set(&stime->running, 1);\n\treturn 0;\n}",
        "output": "1",
        "idx": 1056
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void credential_write_item(FILE *fp, const char *key, const char *value)\n{\n\tif (!value)\n\t\treturn;\n\tif (strchr(value, '\\n'))\n\t\tdie(\"credential value for %s contains newline\", key);\n\tfprintf(fp, \"%s=%s\\n\", key, value);\n}",
        "output": "0",
        "idx": 7201
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "latin_ptr2len(char_u *p)\n{\n return MB_BYTE2LEN(*p);\n}",
        "output": "1",
        "idx": 5812
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "X509_NAME_oneline_ex(X509_NAME * a,\n                     char *buf,\n                     unsigned int *size,\n                     unsigned long flag)\n{\n    BIO *out = NULL;\n\n    out = BIO_new(BIO_s_mem ());\n    if (X509_NAME_print_ex(out, a, 0, flag) > 0) {\n        if (buf != NULL && (*size) >  (unsigned int) BIO_number_written(out)) {\n            memset(buf, 0, *size);\n            BIO_read(out, buf, (int) BIO_number_written(out));\n        }\n        else {\n            *size = BIO_number_written(out);\n        }\n    }\n    BIO_free(out);\n    return (buf);\n}",
        "output": "1",
        "idx": 192
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline ut16 r_read_le16(const void *src) {\n\tif (!src) {\n\t\treturn UT16_MAX;\n\t}\n\tconst ut8 *s = (const ut8*)src;\n\treturn (((ut16)s[1]) << 8) | (((ut16)s[0]) << 0);\n}",
        "output": "0",
        "idx": 8603
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void sas_init_disc(struct sas_discovery *disc, struct asd_sas_port *port)\n{\n\tint i;\n\n\tstatic const work_func_t sas_event_fns[DISC_NUM_EVENTS] = {\n\t\t[DISCE_DISCOVER_DOMAIN] = sas_discover_domain,\n\t\t[DISCE_REVALIDATE_DOMAIN] = sas_revalidate_domain,\n\t\t[DISCE_PROBE] = sas_probe_devices,\n\t\t[DISCE_SUSPEND] = sas_suspend_devices,\n\t\t[DISCE_RESUME] = sas_resume_devices,\n\t\t[DISCE_DESTRUCT] = sas_destruct_devices,\n\t};\n\n\tdisc->pending = 0;\n\tfor (i = 0; i < DISC_NUM_EVENTS; i++) {\n\t\tINIT_SAS_WORK(&disc->disc_work[i].work, sas_event_fns[i]);\n\t\tdisc->disc_work[i].port = port;\n\t}\n}",
        "output": "1",
        "idx": 1828
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tbs->size = se->length;\n\t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n\t\tbs->bits = R_SYS_BITS_16;\n\t\tbs->is_data = se->flags & IS_DATA;\n\t\tbs->perm = __translate_perms (se->flags);\n\t\tbs->paddr = (ut64)se->offset * bin->alignment;\n\t\tbs->name = r_str_newf (\"%s.%\" PFMT64d, se->flags & IS_MOVEABLE ? \"MOVEABLE\" : \"FIXED\", bs->paddr);\n\t\tbs->is_segment = true;\n\t\tr_list_append (segments, bs);\n\t}\n\tbin->segments = segments;\n\treturn segments;\n}",
        "output": "1",
        "idx": 6512
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mk_request_free(struct session_request *sr)\n{\n    if (sr->fd_file > 0) {\n        if (sr->fd_is_fdt == MK_TRUE) {\n            mk_vhost_close(sr);\n        }\n        else {\n            close(sr->fd_file);\n        }\n    }\n\n    if (sr->headers.location) {\n        mk_mem_free(sr->headers.location);\n    }\n\n    if (sr->uri_processed.data != sr->uri.data) {\n        mk_ptr_free(&sr->uri_processed);\n    }\n\n    if (sr->real_path.data != sr->real_path_static) {\n        mk_ptr_free(&sr->real_path);\n    }\n}",
        "output": "0",
        "idx": 5353
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_marker (SF_PRIVATE *psf, int x)\n{\tpsf->header.ptr [psf->header.indx++] = (x >> 24) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n\tpsf->header.ptr [psf->header.indx++] = x ;\n} ",
        "output": "0",
        "idx": 6897
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xfrm6_tunnel_spi_fini(void)\n{\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n}",
        "output": "1",
        "idx": 2216
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void sem_getref(struct sem_array *sma)\n{\n\tspin_lock(&(sma)->sem_perm.lock);\n\tipc_rcu_getref(sma);\n\tipc_unlock(&(sma)->sem_perm);\n}",
        "output": "1",
        "idx": 2258
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_read (SF_PRIVATE *psf, void *ptr, int bytes)\n{\tint count = 0 ;\n\n\tif (psf->headindex >= SIGNED_SIZEOF (psf->header))\n\t\treturn psf_fread (ptr, 1, bytes, psf) ;\n\n\tif (psf->headindex + bytes > SIGNED_SIZEOF (psf->header))\n\t{\tint most ;\n\n\t\tmost = SIGNED_SIZEOF (psf->header) - psf->headend ;\n\t\tpsf_fread (psf->header + psf->headend, 1, most, psf) ;\n\t\tmemcpy (ptr, psf->header + psf->headend, most) ;\n\t\tpsf->headend = psf->headindex += most ;\n\t\tpsf_fread ((char *) ptr + most, bytes - most, 1, psf) ;\n\t\treturn bytes ;\n\t\t} ;\n\n\tif (psf->headindex + bytes > psf->headend)\n\t{\tcount = psf_fread (psf->header + psf->headend, 1, bytes - (psf->headend - psf->headindex), psf) ;\n\t\tif (count != bytes - (int) (psf->headend - psf->headindex))\n\t\t{\tpsf_log_printf (psf, \"Error : psf_fread returned short count.\\n\") ;\n\t\t\treturn count ;\n\t\t\t} ;\n\t\tpsf->headend += count ;\n\t\t} ;\n\n\tmemcpy (ptr, psf->header + psf->headindex, bytes) ;\n\tpsf->headindex += bytes ;\n\n\treturn bytes ;\n} ",
        "output": "1",
        "idx": 4944
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct ucma_multicast* ucma_alloc_multicast(struct ucma_context *ctx)\n{\n\tstruct ucma_multicast *mc;\n\n\tmc = kzalloc(sizeof(*mc), GFP_KERNEL);\n\tif (!mc)\n\t\treturn NULL;\n\n\tmutex_lock(&mut);\n\tmc->id = idr_alloc(&multicast_idr, mc, 0, 0, GFP_KERNEL);\n\tmutex_unlock(&mut);\n\tif (mc->id < 0)\n\t\tgoto error;\n\n\tmc->ctx = ctx;\n\tlist_add_tail(&mc->list, &ctx->mc_list);\n\treturn mc;\n\nerror:\n\tkfree(mc);\n\treturn NULL;\n}",
        "output": "1",
        "idx": 2964
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pcrypt_free(struct aead_instance *inst)\n{\n\tstruct pcrypt_instance_ctx *ctx = aead_instance_ctx(inst);\n\n\tcrypto_drop_aead(&ctx->spawn);\n\tkfree(inst);\n}",
        "output": "0",
        "idx": 2629
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_get_mic(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_qop_t  qop_req,\n\t\tconst gss_buffer_t message_buffer,\n\t\tgss_buffer_t message_token)\n{\n\tOM_uint32 ret;\n\tret = gss_get_mic(minor_status,\n\t\t    context_handle,\n\t\t    qop_req,\n\t\t    message_buffer,\n\t\t    message_token);\n\treturn (ret);\n}",
        "output": "1",
        "idx": 60
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iakerb_alloc_context(iakerb_ctx_id_t *pctx)\n{\n    iakerb_ctx_id_t ctx;\n    krb5_error_code code;\n\n    *pctx = NULL;\n\n    ctx = k5alloc(sizeof(*ctx), &code);\n    if (ctx == NULL)\n        goto cleanup;\n    ctx->defcred = GSS_C_NO_CREDENTIAL;\n    ctx->magic = KG_IAKERB_CONTEXT;\n    ctx->state = IAKERB_AS_REQ;\n    ctx->count = 0;\n\n    code = krb5_gss_init_context(&ctx->k5c);\n    if (code != 0)\n        goto cleanup;\n\n    *pctx = ctx;\n\ncleanup:\n    if (code != 0)\n        iakerb_release_context(ctx);\n\n    return code;\n}",
        "output": "1",
        "idx": 120
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateDoubleArray(const double *numbers,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}",
        "output": "0",
        "idx": 8287
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void xenvif_carrier_off(struct xenvif *vif)\n{\n\tstruct net_device *dev = vif->dev;\n\n\trtnl_lock();\n\tnetif_carrier_off(dev); \n\tif (netif_running(dev))\n\t\txenvif_down(vif);\n\trtnl_unlock();\n\txenvif_put(vif);\n}",
        "output": "0",
        "idx": 1147
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mp_encode_lua_table_as_array(lua_State *L, mp_buf *buf, int level) {\n#if LUA_VERSION_NUM < 502\n    size_t len = lua_objlen(L,-1), j;\n#else\n    size_t len = lua_rawlen(L,-1), j;\n#endif\n\n    mp_encode_array(L,buf,len);\n    luaL_checkstack(L, 1, \"in function mp_encode_lua_table_as_array\");\n    for (j = 1; j <= len; j++) {\n        lua_pushnumber(L,j);\n        lua_gettable(L,-2);\n        mp_encode_lua_type(L,buf,level+1);\n    }\n}",
        "output": "0",
        "idx": 5107
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "destroyPresentationContextList(LST_HEAD ** l)\n{\n    PRV_PRESENTATIONCONTEXTITEM\n    * prvCtx;\n    DUL_SUBITEM\n        * subItem;\n\n    if (*l == NULL)\n        return;\n\n    prvCtx = (PRV_PRESENTATIONCONTEXTITEM*)LST_Dequeue(l);\n    while (prvCtx != NULL) {\n        subItem = (DUL_SUBITEM*)LST_Dequeue(&prvCtx->transferSyntaxList);\n        while (subItem != NULL) {\n            free(subItem);\n            subItem = (DUL_SUBITEM*)LST_Dequeue(&prvCtx->transferSyntaxList);\n        }\n        LST_Destroy(&prvCtx->transferSyntaxList);\n        free(prvCtx);\n        prvCtx = (PRV_PRESENTATIONCONTEXTITEM*)LST_Dequeue(l);\n    }\n    LST_Destroy(l);\n}",
        "output": "1",
        "idx": 8838
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void imap_quote_string (char *dest, size_t dlen, const char *src)\n{\n  static const char quote[] = \"\\\"\\\\\";\n  char *pt;\n  const char *s;\n\n  pt = dest;\n  s  = src;\n\n  *pt++ = '\"';\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr (quote, *s))\n    {\n      dlen -= 2;\n      if (!dlen)\n\tbreak;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = 0;\n}",
        "output": "1",
        "idx": 6942
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mark_desktop_file_executable_task_done (GObject      *source_object,\n                                        GAsyncResult *res,\n                                        gpointer      user_data)\n{\n    MarkTrustedJob *job = user_data;\n\n    g_object_unref (job->file);\n\n    if (job->done_callback)\n    {\n        job->done_callback (!job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n\n    finalize_common ((CommonJob *) job);\n}",
        "output": "0",
        "idx": 8817
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xen_irq_init(unsigned irq)\n{\n\tstruct irq_info *info;\n\n#ifdef CONFIG_SMP\n\tcpumask_copy(irq_get_affinity_mask(irq), cpumask_of(0));\n#endif\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (info == NULL)\n\t\tpanic(\"Unable to allocate metadata for IRQ%d\\n\", irq);\n\n\tinfo->type = IRQT_UNBOUND;\n\tinfo->refcnt = -1;\n\n\tset_info_for_irq(irq, info);\n\n\tINIT_LIST_HEAD(&info->eoi_list);\n\tlist_add_tail(&info->list, &xen_irq_list_head);\n}",
        "output": "0",
        "idx": 2741
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void trustedGenerateSEK(int *errStatus, char *errString,\n                        uint8_t *encrypted_sek, uint32_t *enc_len, char *sek_hex) {\n    CALL_ONCE\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n\n    CHECK_STATE(encrypted_sek);\n    CHECK_STATE(sek_hex);\n\n    RANDOM_CHAR_BUF(SEK_raw, SGX_AESGCM_KEY_SIZE);\n\n    carray2Hex((uint8_t*) SEK_raw, SGX_AESGCM_KEY_SIZE, sek_hex);\n    memcpy(AES_key, SEK_raw, SGX_AESGCM_KEY_SIZE);\n    derive_DH_Key();\n\n    sealHexSEK(errStatus, errString, encrypted_sek, enc_len, sek_hex);\n\n    if (*errStatus != 0) {\n        LOG_ERROR(\"sealHexSEK failed\");\n        goto clean;\n    }\n\n    SET_SUCCESS\n    clean:\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}",
        "output": "1",
        "idx": 8734
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void unix_inflight(struct user_struct *user, struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tspin_lock(&unix_gc_lock);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tif (atomic_long_inc_return(&u->inflight) == 1) {\n\t\t\tBUG_ON(!list_empty(&u->link));\n\t\t\tlist_add_tail(&u->link, &gc_inflight_list);\n\t\t} else {\n\t\t\tBUG_ON(list_empty(&u->link));\n\t\t}\n\t\tunix_tot_inflight++;\n\t}\n\tuser->unix_inflight++;\n\tspin_unlock(&unix_gc_lock);\n}",
        "output": "0",
        "idx": 1589
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_function_line(\n\texarg_T\t\t*eap,\n\tgarray_T\t*lines_to_free,\n\tint\t\tindent,\n\tgetline_opt_T\tgetline_options)\n{\n    char_u *theline;\n\n    if (eap->getline == NULL)\n\ttheline = getcmdline(':', 0L, indent, 0);\n    else\n\ttheline = eap->getline(':', eap->cookie, indent, getline_options);\n    if (theline != NULL)\n    {\n\tif (lines_to_free->ga_len > 0\n\t\t&& *eap->cmdlinep == ((char_u **)lines_to_free->ga_data)\n\t\t\t\t\t\t   [lines_to_free->ga_len - 1])\n\t    *eap->cmdlinep = theline;\n\tga_add_string(lines_to_free, theline);\n    }\n\n    return theline;\n}",
        "output": "0",
        "idx": 7949
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteIntArray* TfLiteIntArrayCreate(int size) {\n  TfLiteIntArray* ret =\n      (TfLiteIntArray*)malloc(TfLiteIntArrayGetSizeInBytes(size));\n  ret->size = size;\n  return ret;\n}",
        "output": "1",
        "idx": 7258
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_report_acomp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_acomp racomp;\n\n\tstrlcpy(racomp.type, \"acomp\", sizeof(racomp.type));\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_ACOMP,\n\t\t    sizeof(struct crypto_report_acomp), &racomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "1",
        "idx": 3030
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BOOL security_decrypt(BYTE* data, int length, rdpRdp* rdp)\n{\n\tif (rdp->rc4_decrypt_key == NULL)\n\t\treturn FALSE;\n\tif (rdp->decrypt_use_count >= 4096)\n\t{\n\t\tsecurity_key_update(rdp->decrypt_key, rdp->decrypt_update_key, rdp->rc4_key_len);\n\t\tcrypto_rc4_free(rdp->rc4_decrypt_key);\n\t\trdp->rc4_decrypt_key = crypto_rc4_init(rdp->decrypt_key, rdp->rc4_key_len);\n\t\trdp->decrypt_use_count = 0;\n\t}\n\tcrypto_rc4(rdp->rc4_decrypt_key, length, data, data);\n\trdp->decrypt_use_count += 1;\n\trdp->decrypt_checksum_use_count++;\n\treturn TRUE;\n}",
        "output": "0",
        "idx": 5837
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, hasChildren)\n{\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_FALSE;\n} ",
        "output": "0",
        "idx": 5489
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct dentry *aio_mount(struct file_system_type *fs_type,\n\t\t\t\tint flags, const char *dev_name, void *data)\n{\n\tstatic const struct dentry_operations ops = {\n\t\t.d_dname\t= simple_dname,\n\t};\n\tstruct dentry *root = mount_pseudo(fs_type, \"aio:\", NULL, &ops,\n\t\t\t\t\t   AIO_RING_MAGIC);\n\n\tif (!IS_ERR(root))\n\t\troot->d_sb->s_iflags |= SB_I_NOEXEC;\n\treturn root;\n}",
        "output": "0",
        "idx": 1929
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int scsi_verify_blk_ioctl(struct block_device *bd, unsigned int cmd)\n{\n\tif (bd && bd == bd->bd_contains)\n\t\treturn 0;\n\n\tswitch (cmd) {\n\tcase SCSI_IOCTL_GET_IDLUN:\n\tcase SCSI_IOCTL_GET_BUS_NUMBER:\n\tcase SCSI_IOCTL_GET_PCI:\n\tcase SCSI_IOCTL_PROBE_HOST:\n\tcase SG_GET_VERSION_NUM:\n\tcase SG_SET_TIMEOUT:\n\tcase SG_GET_TIMEOUT:\n\tcase SG_GET_RESERVED_SIZE:\n\tcase SG_SET_RESERVED_SIZE:\n\tcase SG_EMULATED_HOST:\n\t\treturn 0;\n\tcase CDROM_GET_CAPABILITY:\n\t\treturn -ENOIOCTLCMD;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tprintk_ratelimited(KERN_WARNING\n\t\t\t   \"%s: sending ioctl %x to a partition!\\n\", current->comm, cmd);\n\n\treturn capable(CAP_SYS_RAWIO) ? 0 : -ENOIOCTLCMD;\n}",
        "output": "0",
        "idx": 859
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)\n{\n\tstruct crypto_alg *alg;\n\n\tif (!name)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tmask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);\n\ttype &= mask;\n\n\talg = crypto_alg_lookup(name, type, mask);\n\tif (!alg) {\n\t\trequest_module(\"%s\", name);\n\n\t\tif (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &\n\t\t      CRYPTO_ALG_NEED_FALLBACK))\n\t\t\trequest_module(\"%s-all\", name);\n\n\t\talg = crypto_alg_lookup(name, type, mask);\n\t}\n\n\tif (alg)\n\t\treturn crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;\n\n\treturn crypto_larval_add(name, type, mask);\n}",
        "output": "1",
        "idx": 2726
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcf_poll *nfcf_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcf_poll->bit_rate = *data++;\n\tnfcf_poll->sensf_res_len = min_t(__u8, *data++, NFC_SENSF_RES_MAXSIZE);\n\n\tpr_debug(\"bit_rate %d, sensf_res_len %d\\n\",\n\t\t nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);\n\n\tmemcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);\n\tdata += nfcf_poll->sensf_res_len;\n\n\treturn data;\n}",
        "output": "0",
        "idx": 969
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int http_open(URLContext *h, const char *uri, int flags,\n                     AVDictionary **options)\n{\n    HTTPContext *s = h->priv_data;\n    int ret;\n\n    if( s->seekable == 1 )\n        h->is_streamed = 0;\n    else\n        h->is_streamed = 1;\n\n    s->filesize = UINT64_MAX;\n    s->location = av_strdup(uri);\n    if (!s->location)\n        return AVERROR(ENOMEM);\n    if (options)\n        av_dict_copy(&s->chained_options, *options, 0);\n\n    if (s->headers) {\n        int len = strlen(s->headers);\n        if (len < 2 || strcmp(\"\\r\\n\", s->headers + len - 2)) {\n            av_log(h, AV_LOG_WARNING,\n                   \"No trailing CRLF found in HTTP header.\\n\");\n            ret = av_reallocp(&s->headers, len + 3);\n            if (ret < 0)\n                return ret;\n            s->headers[len]     = '\\r';\n            s->headers[len + 1] = '\\n';\n            s->headers[len + 2] = '\\0';\n        }\n    }\n\n    if (s->listen) {\n        return http_listen(h, uri, flags, options);\n    }\n    ret = http_open_cnx(h, options);\n    if (ret < 0)\n        av_dict_free(&s->chained_options);\n    return ret;\n}",
        "output": "0",
        "idx": 4827
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parse_ranges(struct client *clt, char *str, size_t file_sz)\n{\n\tint\t\t\t i = 0;\n\tchar\t\t\t*p, *q;\n\tstruct range_data\t*r = &clt->clt_ranges;\n\n\tmemset(r, 0, sizeof(*r));\n\n\tif ((p = strchr(str, '=')) == NULL)\n\t\treturn (-1);\n\n\t*p++ = '\\0';\n\tif (strcmp(str, \"bytes\") != 0)\n\t\treturn (-1);\n\n\twhile ((q = strchr(p, ',')) != NULL) {\n\t\t*q++ = '\\0';\n\n\t\tif (parse_range_spec(p, file_sz, &r->range[i]) == 0)\n\t\t\tcontinue;\n\n\t\ti++;\n\t\tif (i == SERVER_MAX_RANGES)\n\t\t\treturn (-1);\n\n\t\tp = q;\n\t}\n\n\tif (parse_range_spec(p, file_sz, &r->range[i]) != 0)\n\t\ti++;\n\n\tr->range_total = file_sz;\n\tr->range_count = i;\n\treturn (i);\n}",
        "output": "0",
        "idx": 7799
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int xt_compat_check_entry_offsets(const void *base,\n\t\t\t\t  unsigned int target_offset,\n\t\t\t\t  unsigned int next_offset)\n{\n\tconst struct compat_xt_entry_target *t;\n\tconst char *e = base;\n\n\tif (target_offset + sizeof(*t) > next_offset)\n\t\treturn -EINVAL;\n\n\tt = (void *)(e + target_offset);\n\tif (t->u.target_size < sizeof(*t))\n\t\treturn -EINVAL;\n\n\tif (target_offset + t->u.target_size > next_offset)\n\t\treturn -EINVAL;\n\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&\n\t    target_offset + sizeof(struct compat_xt_standard_target) != next_offset)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1224
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct task_struct * __cpuinit fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\tstruct pt_regs regs;\n\n\ttask = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n\t\t\t    &init_struct_pid, 0);\n\tif (!IS_ERR(task)) {\n\t\tinit_idle_pids(task->pids);\n\t\tinit_idle(task, cpu);\n\t}\n\n\treturn task;\n}",
        "output": "0",
        "idx": 321
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int copy_verifier_state(struct bpf_verifier_state *dst_state,\n\t\t\t       const struct bpf_verifier_state *src)\n{\n\tstruct bpf_func_state *dst;\n\tint i, err;\n\n\tfor (i = src->curframe + 1; i <= dst_state->curframe; i++) {\n\t\tfree_func_state(dst_state->frame[i]);\n\t\tdst_state->frame[i] = NULL;\n\t}\n\tdst_state->speculative = src->speculative;\n\tdst_state->curframe = src->curframe;\n\tfor (i = 0; i <= src->curframe; i++) {\n\t\tdst = dst_state->frame[i];\n\t\tif (!dst) {\n\t\t\tdst = kzalloc(sizeof(*dst), GFP_KERNEL);\n\t\t\tif (!dst)\n\t\t\t\treturn -ENOMEM;\n\t\t\tdst_state->frame[i] = dst;\n\t\t}\n\t\terr = copy_func_state(dst, src->frame[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 4199
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t driver_override_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\treturn sprintf(buf, \"%s\\n\", pdev->driver_override);\n}",
        "output": "1",
        "idx": 1596
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_syscall_enter(void *ignore, struct pt_regs *regs, long id)\n{\n\tstruct syscall_metadata *sys_data;\n\tstruct syscall_trace_enter *rec;\n\tstruct hlist_head *head;\n\tint syscall_nr;\n\tint rctx;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\tif (!test_bit(syscall_nr, enabled_perf_enter_syscalls))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\thead = this_cpu_ptr(sys_data->enter_event->perf_events);\n\tif (hlist_empty(head))\n\t\treturn;\n\n\tsize = sizeof(unsigned long) * sys_data->nb_args + sizeof(*rec);\n\tsize = ALIGN(size + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\trec = (struct syscall_trace_enter *)perf_trace_buf_prepare(size,\n\t\t\t\tsys_data->enter_event->event.type, regs, &rctx);\n\tif (!rec)\n\t\treturn;\n\n\trec->nr = syscall_nr;\n\tsyscall_get_arguments(current, regs, 0, sys_data->nb_args,\n\t\t\t       (unsigned long *)&rec->args);\n\tperf_trace_buf_submit(rec, size, rctx, 0, 1, regs, head, NULL);\n}",
        "output": "0",
        "idx": 3747
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int cJSON_GetArraySize( cJSON *array )\n{\n\tcJSON *c = array->child;\n\tint i = 0;\n\twhile ( c ) {\n\t\t++i;\n\t\tc = c->next;\n\t}\n\treturn i;\n}",
        "output": "1",
        "idx": 5870
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct bpf_prog *bpf_patch_insn_single(struct bpf_prog *prog, u32 off,\n\t\t\t\t       const struct bpf_insn *patch, u32 len)\n{\n\tu32 insn_adj_cnt, insn_rest, insn_delta = len - 1;\n\tconst u32 cnt_max = S16_MAX;\n\tstruct bpf_prog *prog_adj;\n\n\tif (insn_delta == 0) {\n\t\tmemcpy(prog->insnsi + off, patch, sizeof(*patch));\n\t\treturn prog;\n\t}\n\n\tinsn_adj_cnt = prog->len + insn_delta;\n\n\tif (insn_adj_cnt > cnt_max &&\n\t    bpf_adj_branches(prog, off, insn_delta, true))\n\t\treturn NULL;\n\n\tprog_adj = bpf_prog_realloc(prog, bpf_prog_size(insn_adj_cnt),\n\t\t\t\t    GFP_USER);\n\tif (!prog_adj)\n\t\treturn NULL;\n\n\tprog_adj->len = insn_adj_cnt;\n\n\tinsn_rest = insn_adj_cnt - off - len;\n\n\tmemmove(prog_adj->insnsi + off + len, prog_adj->insnsi + off + 1,\n\t\tsizeof(*patch) * insn_rest);\n\tmemcpy(prog_adj->insnsi + off, patch, sizeof(*patch) * len);\n\n\tBUG_ON(bpf_adj_branches(prog_adj, off, insn_delta, false));\n\n\treturn prog_adj;\n}",
        "output": "0",
        "idx": 4083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int hashtable_init(hashtable_t *hashtable)\n{\n    size_t i;\n\n    hashtable->size = 0;\n    hashtable->num_buckets = 0;  \n    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));\n    if(!hashtable->buckets)\n        return -1;\n\n    list_init(&hashtable->list);\n\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n\n    return 0;\n}",
        "output": "1",
        "idx": 4316
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void print_primaries(WriterContext *w, enum AVColorPrimaries color_primaries)\n{\n    const char *val = av_color_primaries_name(color_primaries);\n    if (!val || color_primaries == AVCOL_PRI_UNSPECIFIED) {\n        print_str_opt(\"color_primaries\", \"unknown\");\n    } else {\n        print_str(\"color_primaries\", val);\n    }\n}",
        "output": "0",
        "idx": 4889
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n\t\t\t  struct posix_acl **acl)\n{\n\tumode_t mode = inode->i_mode;\n\tint error;\n\n\terror = posix_acl_equiv_mode(*acl, &mode);\n\tif (error < 0)\n\t\treturn error;\n\tif (error == 0)\n\t\t*acl = NULL;\n\tif (!in_group_p(inode->i_gid) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\tmode &= ~S_ISGID;\n\t*mode_p = mode;\n\treturn 0;\n}",
        "output": "0",
        "idx": 1957
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void encode_share_access(struct xdr_stream *xdr, fmode_t fmode)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(8);\n\tswitch (fmode & (FMODE_READ|FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_READ);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_WRITE);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_BOTH);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWRITE32(0);\n\t}\n\tWRITE32(0);\t\t\n}",
        "output": "0",
        "idx": 3093
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, getMaxLineLen)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_LONG((long)intern->u.file.max_line_len);\n} ",
        "output": "0",
        "idx": 5569
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n{\n\tif (file->f_flags & O_DSYNC)\n\t\treturn 0;\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n\t\treturn 1;\n\tif (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL ||\n\t\t\t(inode->i_flock->fl_start == 0 &&\n\t\t\tinode->i_flock->fl_end == OFFSET_MAX &&\n\t\t\tinode->i_flock->fl_type != F_RDLCK)))\n\t\treturn 1;\n\treturn 0;\n}",
        "output": "1",
        "idx": 2510
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ptrace_hbptriggered(struct perf_event *bp, int unused,\n\t\t\t\t     struct perf_sample_data *data,\n\t\t\t\t     struct pt_regs *regs)\n{\n\tstruct arch_hw_breakpoint *bkpt = counter_arch_bp(bp);\n\tlong num;\n\tint i;\n\tsiginfo_t info;\n\n\tfor (i = 0; i < ARM_MAX_HBP_SLOTS; ++i)\n\t\tif (current->thread.debug.hbp[i] == bp)\n\t\t\tbreak;\n\n\tnum = (i == ARM_MAX_HBP_SLOTS) ? 0 : ptrace_hbp_idx_to_num(i);\n\n\tinfo.si_signo\t= SIGTRAP;\n\tinfo.si_errno\t= (int)num;\n\tinfo.si_code\t= TRAP_HWBKPT;\n\tinfo.si_addr\t= (void __user *)(bkpt->trigger);\n\n\tforce_sig_info(SIGTRAP, &info, current);\n}",
        "output": "1",
        "idx": 424
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rose_start_idletimer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tdel_timer(&rose->idletimer);\n\n\tif (rose->idle > 0) {\n\t\trose->idletimer.function = rose_idletimer_expiry;\n\t\trose->idletimer.expires  = jiffies + rose->idle;\n\n\t\tadd_timer(&rose->idletimer);\n\t}\n}",
        "output": "1",
        "idx": 2048
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jpg_dec_parseopts(char *optstr, jpg_dec_importopts_t *opts)\n{\n\tjas_tvparser_t *tvp;\n\n\topts->max_size = 0;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\treturn -1;\n\t}\n\n\twhile (!jas_tvparser_next(tvp)) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_MAXSIZE:\n\t\t\topts->max_size = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t  jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 5406
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Curl_detach_connnection(struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n  if(conn) {\n    Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL);\n    Curl_ssl_detach_conn(data, conn);\n  }\n  data->conn = NULL;\n}",
        "output": "0",
        "idx": 8451
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *print_value( cJSON *item, int depth, int fmt )\n{\n\tchar *out = 0;\n\n\tif ( ! item )\n\t\treturn 0;\n\tswitch ( ( item->type ) & 255 ) {\n\t\tcase cJSON_NULL:   out = cJSON_strdup( \"null\" ); break;\n\t\tcase cJSON_False:  out = cJSON_strdup( \"false\" ); break;\n\t\tcase cJSON_True:   out = cJSON_strdup( \"true\" ); break;\n\t\tcase cJSON_Number: out = print_number( item ); break;\n\t\tcase cJSON_String: out = print_string( item ); break;\n\t\tcase cJSON_Array:  out = print_array( item, depth, fmt ); break;\n\t\tcase cJSON_Object: out = print_object( item, depth, fmt ); break;\n\t}\n\treturn out;\n}",
        "output": "1",
        "idx": 5884
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool_t enc624j600IrqHandler(NetInterface *interface)\n{\n   bool_t flag;\n   uint16_t status;\n\n   flag = FALSE;\n\n   enc624j600ClearBit(interface, ENC624J600_REG_EIE, EIE_INTIE);\n\n   status = enc624j600ReadReg(interface, ENC624J600_REG_EIR);\n\n   if((status & EIR_LINKIF) != 0)\n   {\n      enc624j600ClearBit(interface, ENC624J600_REG_EIE, EIE_LINKIE);\n\n      interface->nicEvent = TRUE;\n      flag |= osSetEventFromIsr(&netEvent);\n   }\n\n   if((status & EIR_PKTIF) != 0)\n   {\n      enc624j600ClearBit(interface, ENC624J600_REG_EIE, EIE_PKTIE);\n\n      interface->nicEvent = TRUE;\n      flag |= osSetEventFromIsr(&netEvent);\n   }\n\n   if((status & (EIR_TXIF | EIR_TXABTIF)) != 0)\n   {\n      enc624j600ClearBit(interface, ENC624J600_REG_EIR, EIR_TXIF | EIR_TXABTIF);\n\n      flag |= osSetEventFromIsr(&interface->nicTxEvent);\n   }\n\n   enc624j600SetBit(interface, ENC624J600_REG_EIE, EIE_INTIE);\n\n   return flag;\n}",
        "output": "1",
        "idx": 8552
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ntlm_write_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->Len > 0)\n\t{\n\t\tStream_SetPosition(s, fields->BufferOffset);\n\t\tStream_Write(s, fields->Buffer, fields->Len);\n\t}\n}",
        "output": "0",
        "idx": 5807
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __return_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\ts64 slack_runtime = cfs_rq->runtime_remaining - min_cfs_rq_runtime;\n\n\tif (slack_runtime <= 0)\n\t\treturn;\n\n\traw_spin_lock(&cfs_b->lock);\n\tif (cfs_b->quota != RUNTIME_INF &&\n\t    cfs_rq->runtime_expires == cfs_b->runtime_expires) {\n\t\tcfs_b->runtime += slack_runtime;\n\n\t\tif (cfs_b->runtime > sched_cfs_bandwidth_slice() &&\n\t\t    !list_empty(&cfs_b->throttled_cfs_rq))\n\t\t\tstart_cfs_slack_bandwidth(cfs_b);\n\t}\n\traw_spin_unlock(&cfs_b->lock);\n\n\tcfs_rq->runtime_remaining -= slack_runtime;\n}",
        "output": "1",
        "idx": 3226
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int asymmetric_key_match_preparse(struct key_match_data *match_data)\n{\n\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n\tmatch_data->cmp = asymmetric_key_cmp;\n\treturn 0;\n}",
        "output": "0",
        "idx": 3675
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool HHVM_FUNCTION(mb_parse_str,\n                   const String& encoded_string,\n                   VRefParam result ) {\n  php_mb_encoding_handler_info_t info;\n  info.data_type              = PARSE_STRING;\n  info.separator              = \";&\";\n  info.force_register_globals = false;\n  info.report_errors          = 1;\n  info.to_encoding            = MBSTRG(current_internal_encoding);\n  info.to_language            = MBSTRG(current_language);\n  info.from_encodings         = MBSTRG(http_input_list);\n  info.num_from_encodings     = MBSTRG(http_input_list_size);\n  info.from_language          = MBSTRG(current_language);\n\n  char *encstr = strndup(encoded_string.data(), encoded_string.size());\n  Array resultArr = Array::Create();\n  mbfl_encoding *detected =\n    _php_mb_encoding_handler_ex(&info, resultArr, encstr);\n  free(encstr);\n  result.assignIfRef(resultArr);\n\n  MBSTRG(http_input_identify) = detected;\n  return detected != nullptr;\n}",
        "output": "1",
        "idx": 4512
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int override_release(char __user *release, size_t len)\n{\n\tint ret = 0;\n\n\tif (current->personality & UNAME26) {\n\t\tconst char *rest = UTS_RELEASE;\n\t\tchar buf[65] = { 0 };\n\t\tint ndots = 0;\n\t\tunsigned v;\n\t\tsize_t copy;\n\n\t\twhile (*rest) {\n\t\t\tif (*rest == '.' && ++ndots >= 3)\n\t\t\t\tbreak;\n\t\t\tif (!isdigit(*rest) && *rest != '.')\n\t\t\t\tbreak;\n\t\t\trest++;\n\t\t}\n\t\tv = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;\n\t\tcopy = min(sizeof(buf), max_t(size_t, 1, len));\n\t\tcopy = scnprintf(buf, copy, \"2.6.%u%s\", v, rest);\n\t\tret = copy_to_user(release, buf, copy + 1);\n\t}\n\treturn ret;\n}",
        "output": "0",
        "idx": 1081
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct clock_source *dce80_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "output": "0",
        "idx": 4523
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void xacct_add_tsk(struct taskstats *stats, struct task_struct *p)\n{\n\tstruct mm_struct *mm;\n\n\tstats->coremem = jiffies_to_usecs(p->acct_rss_mem1) * PAGE_SIZE / MB;\n\tstats->virtmem = jiffies_to_usecs(p->acct_vm_mem1) * PAGE_SIZE / MB;\n\tmm = get_task_mm(p);\n\tif (mm) {\n\t\tstats->hiwater_rss   = mm->hiwater_rss * PAGE_SIZE / KB;\n\t\tstats->hiwater_vm    = mm->hiwater_vm * PAGE_SIZE / KB;\n\t\tmmput(mm);\n\t}\n\tstats->read_char\t= p->rchar;\n\tstats->write_char\t= p->wchar;\n\tstats->read_syscalls\t= p->syscr;\n\tstats->write_syscalls\t= p->syscw;\n}",
        "output": "0",
        "idx": 2977
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static size_t read_test_file(char **buffer, char *basename)\n{\n    char *filename;\n    FILE *fp;\n    size_t exp_size, act_size;\n\n    filename = gdTestFilePath2(\"tga\", basename);\n    fp = fopen(filename, \"rb\");\n    gdTestAssert(fp != NULL);\n\n\tfseek(fp, 0, SEEK_END);\n\texp_size = ftell(fp);\n\tfseek(fp, 0, SEEK_SET);\n\n    *buffer = malloc(exp_size);\n    gdTestAssert(*buffer != NULL);\n    act_size = fread(*buffer, sizeof(**buffer), exp_size, fp);\n    gdTestAssert(act_size == exp_size);\n\n    fclose(fp);\n    free(filename);\n\n    return act_size;\n}",
        "output": "0",
        "idx": 6173
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct resource_pool *dce112_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "output": "0",
        "idx": 4481
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n\n\tgpio_dev = platform_get_drvdata(pdev);\n\n\tgpiochip_remove(&gpio_dev->gc);\n\tpinctrl_unregister(gpio_dev->pctrl);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1230
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\n\tremain = dp->logicalSize - dp->pos;\n\tif(remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif(remain == 0) {\n\t\t\treturn 0; \n\t\t}\n\n\t\trlen = remain;\n\t}\n\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\n\treturn rlen;\n}",
        "output": "1",
        "idx": 4438
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint16_t lpc546xxEthReadPhyReg(uint8_t opcode, uint8_t phyAddr,\n   uint8_t regAddr)\n{\n   uint16_t data;\n   uint32_t temp;\n\n   if(opcode == SMI_OPCODE_READ)\n   {\n      temp = ENET->MAC_MDIO_ADDR & ENET_MAC_MDIO_ADDR_CR_MASK;\n      temp |= ENET_MAC_MDIO_ADDR_MOC(3) | ENET_MAC_MDIO_ADDR_MB_MASK;\n      temp |= ENET_MAC_MDIO_ADDR_PA(phyAddr);\n      temp |= ENET_MAC_MDIO_ADDR_RDA(regAddr);\n\n      ENET->MAC_MDIO_ADDR = temp;\n      while((ENET->MAC_MDIO_ADDR & ENET_MAC_MDIO_ADDR_MB_MASK) != 0)\n      {\n      }\n\n      data = ENET->MAC_MDIO_DATA & ENET_MAC_MDIO_DATA_MD_MASK;\n   }\n   else\n   {\n      data = 0;\n   }\n\n   return data;\n}",
        "output": "1",
        "idx": 8602
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nested_vmx_check_permission(struct kvm_vcpu *vcpu)\n{\n\tif (vmx_get_cpl(vcpu)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 0;\n\t}\n\n\tif (!to_vmx(vcpu)->nested.vmxon) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
        "output": "0",
        "idx": 4113
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "valid_filetype(char_u *val)\n{\n    char_u *s;\n\n    for (s = val; *s != NUL; ++s)\n\tif (!ASCII_ISALNUM(*s) && vim_strchr((char_u *)\".-_\", *s) == NULL)\n\t    return FALSE;\n    return TRUE;\n}",
        "output": "0",
        "idx": 8189
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int caif_seqpkt_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t       struct msghdr *m, size_t len, int flags)\n\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint ret;\n\tint copylen;\n\n\tret = -EOPNOTSUPP;\n\tif (m->msg_flags&MSG_OOB)\n\t\tgoto read_error;\n\n\tm->msg_namelen = 0;\n\n\tskb = skb_recv_datagram(sk, flags, 0 , &ret);\n\tif (!skb)\n\t\tgoto read_error;\n\tcopylen = skb->len;\n\tif (len < copylen) {\n\t\tm->msg_flags |= MSG_TRUNC;\n\t\tcopylen = len;\n\t}\n\n\tret = skb_copy_datagram_iovec(skb, 0, m->msg_iov, copylen);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = (flags & MSG_TRUNC) ? skb->len : copylen;\nout_free:\n\tskb_free_datagram(sk, skb);\n\tcaif_check_flow_release(sk);\n\treturn ret;\n\nread_error:\n\treturn ret;\n}",
        "output": "1",
        "idx": 2436
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iakerb_gss_wrap_iov_length(OM_uint32 *minor_status,\n                           gss_ctx_id_t context_handle, int conf_req_flag,\n                           gss_qop_t qop_req, int *conf_state,\n                           gss_iov_buffer_desc *iov, int iov_count)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_wrap_iov_length(minor_status, ctx->gssc, conf_req_flag,\n                                    qop_req, conf_state, iov, iov_count);\n}",
        "output": "0",
        "idx": 145
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "is_link_trusted (NautilusFile *file,\n                 gboolean      is_launcher)\n{\n    GFile *location;\n    gboolean res;\n    g_autofree gchar* trusted = NULL;\n\n    if (!is_launcher)\n    {\n        return TRUE;\n    }\n\n    trusted = nautilus_file_get_metadata (file,\n                                          NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,\n                                          NULL);\n    if (nautilus_file_can_execute (file) && trusted != NULL)\n    {\n        return TRUE;\n    }\n\n    res = FALSE;\n\n    if (nautilus_file_is_local (file))\n    {\n        location = nautilus_file_get_location (file);\n        res = nautilus_is_in_system_dir (location);\n        g_object_unref (location);\n    }\n\n    return res;\n}",
        "output": "0",
        "idx": 8811
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void update_db_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tclr_exception_intercept(svm, DB_VECTOR);\n\tclr_exception_intercept(svm, BP_VECTOR);\n\n\tif (svm->nmi_singlestep)\n\t\tset_exception_intercept(svm, DB_VECTOR);\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug &\n\t\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\tset_exception_intercept(svm, DB_VECTOR);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}",
        "output": "1",
        "idx": 924
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void php_html_entities(INTERNAL_FUNCTION_PARAMETERS, int all)\n{\n\tchar *str, *hint_charset = NULL;\n\tint str_len, hint_charset_len = 0;\n\tsize_t new_len;\n\tlong flags = ENT_COMPAT;\n\tchar *replaced;\n\tzend_bool double_encode = 1;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|ls!b\", &str, &str_len, &flags, &hint_charset, &hint_charset_len, &double_encode) == FAILURE) {\n\t\treturn;\n\t}\n\n\treplaced = php_escape_html_entities_ex(str, str_len, &new_len, all, (int) flags, hint_charset, double_encode TSRMLS_CC);\n\tif (new_len > INT_MAX) {\n\t\tefree(replaced);\n\t\tRETURN_FALSE;\n\t}\n\tRETVAL_STRINGL(replaced, (int)new_len, 0);\n}",
        "output": "0",
        "idx": 5389
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool glfs_check_config(const char *cfgstring, char **reason)\n{\n\tchar *path;\n\tglfs_t *fs = NULL;\n\tglfs_fd_t *gfd = NULL;\n\tgluster_server *hosts = NULL; \n\tbool result = true;\n\n\tpath = strchr(cfgstring, '/');\n\tif (!path) {\n\t\tif (asprintf(reason, \"No path found\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto done;\n\t}\n\tpath += 1; \n\n\tfs = tcmu_create_glfs_object(path, &hosts);\n\tif (!fs) {\n\t\ttcmu_err(\"tcmu_create_glfs_object failed\\n\");\n\t\tgoto done;\n\t}\n\n\tgfd = glfs_open(fs, hosts->path, ALLOWED_BSOFLAGS);\n\tif (!gfd) {\n\t\tif (asprintf(reason, \"glfs_open failed: %m\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto unref;\n\t}\n\n\tif (glfs_access(fs, hosts->path, R_OK|W_OK) == -1) {\n\t\tif (asprintf(reason, \"glfs_access file not present, or not writable\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto unref;\n\t}\n\n\tgoto done;\n\nunref:\n\tgluster_cache_refresh(fs, path);\n\ndone:\n\tif (gfd)\n\t\tglfs_close(gfd);\n\tgluster_free_server(&hosts);\n\n\treturn result;\n}",
        "output": "1",
        "idx": 6100
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sd_isoc_nego(struct gspca_dev *gspca_dev)\n{\n\tint ret, packet_size, min_packet_size;\n\tstruct usb_host_interface *alt;\n\n\tswitch (gspca_dev->pixfmt.width) {\n\tcase 160:\n\t\tmin_packet_size = 200;\n\t\tbreak;\n\tcase 176:\n\t\tmin_packet_size = 266;\n\t\tbreak;\n\tdefault:\n\t\tmin_packet_size = 400;\n\t\tbreak;\n\t}\n\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\tif (packet_size <= min_packet_size)\n\t\treturn -EIO;\n\n\tpacket_size -= 100;\n\tif (packet_size < min_packet_size)\n\t\tpacket_size = min_packet_size;\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(packet_size);\n\n\tret = usb_set_interface(gspca_dev->dev, gspca_dev->iface, 1);\n\tif (ret < 0)\n\t\tpr_err(\"set alt 1 err %d\\n\", ret);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 4625
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error_t ipv6ComputeSolicitedNodeAddr(const Ipv6Addr *ipAddr,\n   Ipv6Addr *solicitedNodeAddr)\n{\n   error_t error;\n\n   if(!ipv6IsMulticastAddr(ipAddr))\n   {\n      ipv6CopyAddr(solicitedNodeAddr, &IPV6_SOLICITED_NODE_ADDR_PREFIX);\n\n      solicitedNodeAddr->b[13] = ipAddr->b[13];\n      solicitedNodeAddr->b[14] = ipAddr->b[14];\n      solicitedNodeAddr->b[15] = ipAddr->b[15];\n\n      error = NO_ERROR;\n   }\n   else\n   {\n      error = ERROR_INVALID_ADDRESS;\n   }\n\n   return error;\n}",
        "output": "1",
        "idx": 8652
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int _perf_event_refresh(struct perf_event *event, int refresh)\n{\n\tif (event->attr.inherit || !is_sampling_event(event))\n\t\treturn -EINVAL;\n\n\tatomic_add(refresh, &event->event_limit);\n\t_perf_event_enable(event);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 3841
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ntlm_print_negotiate_flags(UINT32 flags)\n{\n\tint i;\n\tconst char* str;\n\tWLog_INFO(TAG, \"negotiateFlags \\\"0x%08\"PRIX32\"\\\"\", flags);\n\n\tfor (i = 31; i >= 0; i--)\n\t{\n\t\tif ((flags >> i) & 1)\n\t\t{\n\t\t\tstr = NTLM_NEGOTIATE_STRINGS[(31 - i)];\n\t\t\tWLog_INFO(TAG, \"\\t%s (%d),\", str, (31 - i));\n\t\t}\n\t}\n}",
        "output": "1",
        "idx": 4202
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xcopy_pt_undepend_remotedev(struct xcopy_op *xop)\n{\n\tstruct se_device *remote_dev;\n\n\tif (xop->op_origin == XCOL_SOURCE_RECV_OP)\n\t\tremote_dev = xop->dst_dev;\n\telse\n\t\tremote_dev = xop->src_dev;\n\n\tpr_debug(\"Calling configfs_undepend_item for\"\n\t\t  \" remote_dev: %p remote_dev->dev_group: %p\\n\",\n\t\t  remote_dev, &remote_dev->dev_group.cg_item);\n\n\ttarget_undepend_item(&remote_dev->dev_group.cg_item);\n}",
        "output": "1",
        "idx": 1922
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int f2fs_read_data_page(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret = -EAGAIN;\n\n\ttrace_f2fs_readpage(page, DATA);\n\n\tif (f2fs_has_inline_data(inode))\n\t\tret = f2fs_read_inline_data(inode, page);\n\tif (ret == -EAGAIN)\n\t\tret = f2fs_mpage_readpages(page->mapping, NULL, page, 1, false);\n\treturn ret;\n}",
        "output": "1",
        "idx": 3208
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void* leak_malloc(size_t bytes)\n{\n\n\n    size_t size = bytes + sizeof(AllocationEntry);\n    if (size < bytes) { \n        return NULL;\n    }\n\n    void* base = dlmalloc(size);\n    if (base != NULL) {\n        pthread_mutex_lock(&gAllocationsMutex);\n\n            intptr_t backtrace[BACKTRACE_SIZE];\n            size_t numEntries = get_backtrace(backtrace, BACKTRACE_SIZE);\n\n            AllocationEntry* header = (AllocationEntry*)base;\n            header->entry = record_backtrace(backtrace, numEntries, bytes);\n            header->guard = GUARD;\n\n            base = (AllocationEntry*)base + 1;\n\n        pthread_mutex_unlock(&gAllocationsMutex);\n    }\n\n    return base;\n}",
        "output": "0",
        "idx": 5075
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_get_vdev_info(int slot)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tstruct pci_vdev *dev = NULL;\n\n\tbi = pci_businfo[0];\n\tassert(bi != NULL);\n\n\tsi = &bi->slotinfo[slot];\n\tif (si != NULL)\n\t\tdev = si->si_funcs[0].fi_devi;\n\telse\n\t\tfprintf(stderr, \"slot=%d is empty!\\n\", slot);\n\n\treturn dev;\n}",
        "output": "1",
        "idx": 7580
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int r_sys_mkdirp(char *dir) {\n\tint ret = 1;\n\tconst char slash = DIRSEP;\n\tchar *path = dir;\n\tchar *ptr = path;\n\tif (*ptr == slash) {\n\t\tptr++;\n\t}\n#if __SDB_WINDOWS__\n\tchar *p = strstr (ptr, \":\\\\\");\n\tif (p) {\n\t\tptr = p + 2;\n\t}\n#endif\n\twhile ((ptr = strchr (ptr, slash))) {\n\t\t*ptr = 0;\n\t\tif (!r_sys_mkdir (path) && r_sys_mkdir_failed ()) {\n\t\t\teprintf (\"r_sys_mkdirp: fail '%s' of '%s'\\n\", path, dir);\n\t\t\t*ptr = slash;\n\t\t\treturn 0;\n\t\t}\n\t\t*ptr = slash;\n\t\tptr++;\n\t}\n\treturn ret;\n}",
        "output": "1",
        "idx": 6428
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DEFINE_TEST(test_read_format_mtree_crash747)\n{\n\tconst char *reffile = \"test_read_format_mtree_crash747.mtree.bz2\";\n\tstruct archive *a;\n\n\textract_reference_file(reffile);\n\n\tassert((a = archive_read_new()) != NULL);\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_filter_bzip2(a));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_mtree(a));\n\tassertEqualIntA(a, ARCHIVE_FATAL, archive_read_open_filename(a, reffile, 10240));\n\tassertEqualInt(ARCHIVE_OK, archive_read_free(a));\n}",
        "output": "0",
        "idx": 5203
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "writefile(const char *name, struct string *s)\n{\n\tFILE *f;\n\tint ret;\n\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n\n\treturn ret;\n}",
        "output": "1",
        "idx": 8674
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void usage(const char *progname)\n{\n    const char* progname_real; \n\n    progname_real = strrchr(progname, '/');\n\n    if (progname_real == NULL) \n    {\n        progname_real = progname;\n    }\n    else\n    {\n        progname_real++;\n    }\n\n    fprintf(stderr, \"\\nusage: %s {-e|-d} [ { -p <password> | -k <keyfile> } ] { [-o <output filename>] <file> | <file> [<file> ...] }\\n\\n\",\n            progname_real);\n}",
        "output": "1",
        "idx": 8960
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE4(ptrace, long, request, long, pid, unsigned long, addr,\n\t\tunsigned long, data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(current);\n\t\tgoto out;\n\t}\n\n\tchild = ptrace_get_task_struct(pid);\n\tif (IS_ERR(child)) {\n\t\tret = PTR_ERR(child);\n\t\tgoto out;\n\t}\n\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(child);\n\t\tgoto out_put_task_struct;\n\t}\n\n\tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n\t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (ret < 0)\n\t\tgoto out_put_task_struct;\n\n\tret = arch_ptrace(child, request, addr, data);\n\tif (ret || request != PTRACE_DETACH)\n\t\tptrace_unfreeze_traced(child);\n\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}",
        "output": "0",
        "idx": 1135
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rcomp;\n\n\tstrlcpy(rcomp.type, \"compression\", sizeof(rcomp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "1",
        "idx": 3038
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "LogLuvClose(TIFF* tif)\n{\n        LogLuvState* sp = (LogLuvState*) tif->tif_data;\n\tTIFFDirectory *td = &tif->tif_dir;\n\n\tassert(sp != 0);\n        if( sp->encoder_state )\n        {\n            td->td_samplesperpixel =\n                (td->td_photometric == PHOTOMETRIC_LOGL) ? 1 : 3;\n            td->td_bitspersample = 16;\n            td->td_sampleformat = SAMPLEFORMAT_INT;\n        }\n}",
        "output": "0",
        "idx": 5927
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CAMLprim value caml_alloc_dummy_float (value size)\n{\n  mlsize_t wosize = Int_val(size) * Double_wosize;\n\n  if (wosize == 0) return Atom(0);\n  return caml_alloc (wosize, 0);\n}",
        "output": "1",
        "idx": 5508
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "indenterror(struct tok_state *tok)\n{\n    if (tok->alterror) {\n        tok->done = E_TABSPACE;\n        tok->cur = tok->inp;\n        return 1;\n    }\n    if (tok->altwarning) {\n#ifdef PGEN\n        PySys_WriteStderr(\"inconsistent use of tabs and spaces \"\n                          \"in indentation\\n\");\n#else\n        PySys_FormatStderr(\"%U: inconsistent use of tabs and spaces \"\n                          \"in indentation\\n\", tok->filename);\n#endif\n        tok->altwarning = 0;\n    }\n    return 0;\n}",
        "output": "1",
        "idx": 7662
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_types) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tif (!(exp->ex_layout_types & (1 << layout_type))) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\n\treturn nfsd4_layout_ops[layout_type];\n}",
        "output": "1",
        "idx": 1580
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n\t\t\t  int iov_count)\n{\n    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n\t\t\t      iov_count);\n}",
        "output": "1",
        "idx": 66
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *cJSON_Print( cJSON *item )\n{\n\treturn print_value( item, 0, 1 );\n}",
        "output": "1",
        "idx": 5912
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_compr_allocate_buffer(struct snd_compr_stream *stream,\n\t\tstruct snd_compr_params *params)\n{\n\tunsigned int buffer_size;\n\tvoid *buffer;\n\n\tif (params->buffer.fragment_size == 0 ||\n\t    params->buffer.fragments > SIZE_MAX / params->buffer.fragment_size)\n\t\treturn -EINVAL;\n\n\tbuffer_size = params->buffer.fragment_size * params->buffer.fragments;\n\tif (stream->ops->copy) {\n\t\tbuffer = NULL;\n\t} else {\n\t\tbuffer = kmalloc(buffer_size, GFP_KERNEL);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tstream->runtime->fragment_size = params->buffer.fragment_size;\n\tstream->runtime->fragments = params->buffer.fragments;\n\tstream->runtime->buffer = buffer;\n\tstream->runtime->buffer_size = buffer_size;\n\treturn 0;\n}",
        "output": "0",
        "idx": 1043
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "update_bar_address(struct vmctx *ctx, struct pci_vdev *dev, uint64_t addr,\n\tint idx, int type, bool ignore_reg_unreg)\n{\n\tbool decode = false;\n\tuint64_t orig_addr = dev->bar[idx].addr;\n\n\tif (!ignore_reg_unreg) {\n\t\tif (dev->bar[idx].type == PCIBAR_IO)\n\t\t\tdecode = porten(dev);\n\t\telse\n\t\t\tdecode = memen(dev);\n\t}\n\n\tif (decode)\n\t\tunregister_bar(dev, idx);\n\n\tswitch (type) {\n\tcase PCIBAR_IO:\n\tcase PCIBAR_MEM32:\n\t\tdev->bar[idx].addr = addr;\n\t\tbreak;\n\tcase PCIBAR_MEM64:\n\t\tdev->bar[idx].addr &= ~0xffffffffUL;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tcase PCIBAR_MEMHI64:\n\t\tdev->bar[idx].addr &= 0xffffffff;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tdefault:\n\t\tassert(0);\n\t}\n\n\tif (decode)\n\t\tregister_bar(dev, idx);\n\n\tif (dev->dev_ops->vdev_update_bar_map && decode)\n\t\tdev->dev_ops->vdev_update_bar_map(ctx, dev, idx, orig_addr);\n}",
        "output": "1",
        "idx": 7592
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sco_send_frame(struct sock *sk, void *buf, int len,\n\t\t\t  unsigned int msg_flags)\n{\n\tstruct sco_conn *conn = sco_pi(sk)->conn;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tif (len > conn->mtu)\n\t\treturn -EINVAL;\n\n\tBT_DBG(\"sk %p len %d\", sk, len);\n\n\tskb = bt_skb_send_alloc(sk, len, msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\n\tmemcpy(skb_put(skb, len), buf, len);\n\thci_send_sco(conn->hcon, skb);\n\n\treturn len;\n}",
        "output": "0",
        "idx": 2853
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et;\n\tstruct extent_node *en;\n\tstruct extent_info ei;\n\n\tif (!f2fs_may_extent_tree(inode)) {\n\t\tif (i_ext && i_ext->len) {\n\t\t\ti_ext->len = 0;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tet = __grab_extent_tree(inode);\n\n\tif (!i_ext || !i_ext->len)\n\t\treturn false;\n\n\tget_extent_info(&ei, i_ext);\n\n\twrite_lock(&et->lock);\n\tif (atomic_read(&et->node_cnt))\n\t\tgoto out;\n\n\ten = __init_extent_tree(sbi, et, &ei);\n\tif (en) {\n\t\tspin_lock(&sbi->extent_lock);\n\t\tlist_add_tail(&en->list, &sbi->extent_list);\n\t\tspin_unlock(&sbi->extent_lock);\n\t}\nout:\n\twrite_unlock(&et->lock);\n\treturn false;\n}",
        "output": "1",
        "idx": 1594
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void trustedDecryptKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,\n                          uint32_t enc_len, char *key) {\n\n    LOG_DEBUG(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encryptedPrivateKey);\n    CHECK_STATE(key);\n\n    *errStatus = -9;\n\n    int status = AES_decrypt_DH(encryptedPrivateKey, enc_len, key, 3072);\n\n    if (status != 0) {\n        *errStatus = status;\n        snprintf(errString, BUF_LEN, \"aes decrypt failed with status %d\", status);\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    *errStatus = -10;\n\n    uint64_t keyLen = strnlen(key, MAX_KEY_LENGTH);\n\n    if (keyLen == MAX_KEY_LENGTH) {\n        snprintf(errString, BUF_LEN, \"Key is not null terminated\");\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    SET_SUCCESS\n    clean:\n    ;\n}",
        "output": "1",
        "idx": 8708
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int perf_cpu_time_max_percent_handler(struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp,\n\t\t\t\tloff_t *ppos)\n{\n\tint ret = proc_dointvec(table, write, buffer, lenp, ppos);\n\n\tif (ret || !write)\n\t\treturn ret;\n\n\tif (sysctl_perf_cpu_time_max_percent == 100 ||\n\t    sysctl_perf_cpu_time_max_percent == 0) {\n\t\tprintk(KERN_WARNING\n\t\t       \"perf: Dynamic interrupt throttling disabled, can hang your system!\\n\");\n\t\tWRITE_ONCE(perf_sample_allowed_ns, 0);\n\t} else {\n\t\tupdate_perf_cpu_limits();\n\t}\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1490
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mp_capable_print(netdissect_options *ndo,\n                 const u_char *opt, u_int opt_len, u_char flags)\n{\n        const struct mp_capable *mpc = (const struct mp_capable *) opt;\n\n        if (!(opt_len == 12 && flags & TH_SYN) &&\n            !(opt_len == 20 && (flags & (TH_SYN | TH_ACK)) == TH_ACK))\n                return 0;\n\n        if (MP_CAPABLE_OPT_VERSION(mpc->sub_ver) != 0) {\n                ND_PRINT((ndo, \" Unknown Version (%d)\", MP_CAPABLE_OPT_VERSION(mpc->sub_ver)));\n                return 1;\n        }\n\n        if (mpc->flags & MP_CAPABLE_C)\n                ND_PRINT((ndo, \" csum\"));\n        ND_PRINT((ndo, \" {0x%\" PRIx64, EXTRACT_64BITS(mpc->sender_key)));\n        if (opt_len == 20) \n                ND_PRINT((ndo, \",0x%\" PRIx64, EXTRACT_64BITS(mpc->receiver_key)));\n        ND_PRINT((ndo, \"}\"));\n        return 1;\n}",
        "output": "1",
        "idx": 4842
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct desc_struct *get_desc(unsigned short sel)\n{\n\tstruct desc_ptr gdt_desc = {0, 0};\n\tunsigned long desc_base;\n\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\tif ((sel & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tstruct desc_struct *desc = NULL;\n\t\tstruct ldt_struct *ldt;\n\n\t\tsel >>= 3;\n\n\t\tmutex_lock(&current->active_mm->context.lock);\n\t\tldt = current->active_mm->context.ldt;\n\t\tif (ldt && sel < ldt->nr_entries)\n\t\t\tdesc = &ldt->entries[sel];\n\n\t\tmutex_unlock(&current->active_mm->context.lock);\n\n\t\treturn desc;\n\t}\n#endif\n\tnative_store_gdt(&gdt_desc);\n\n\tdesc_base = sel & ~(SEGMENT_RPL_MASK | SEGMENT_TI_MASK);\n\n\tif (desc_base > gdt_desc.size)\n\t\treturn NULL;\n\n\treturn (struct desc_struct *)(gdt_desc.address + desc_base);\n}",
        "output": "1",
        "idx": 3196
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *tls_text_name(X509_NAME *name, int nid)\n{\n\tint     pos;\n\tX509_NAME_ENTRY *entry;\n\tASN1_STRING *entry_str;\n\tint     utf8_length;\n\tunsigned char *utf8_value;\n\tchar *result;\n\n\tif (name == 0 || (pos = X509_NAME_get_index_by_NID(name, nid, -1)) < 0) {\n\t\treturn NULL;\n    }\n\n    entry = X509_NAME_get_entry(name, pos);\n    g_return_val_if_fail(entry != NULL, NULL);\n    entry_str = X509_NAME_ENTRY_get_data(entry);\n    g_return_val_if_fail(entry_str != NULL, NULL);\n\n    if ((utf8_length = ASN1_STRING_to_UTF8(&utf8_value, entry_str)) < 0) {\n    \tg_warning(\"Error decoding ASN.1 type=%d\", ASN1_STRING_type(entry_str));\n    \treturn NULL;\n    }\n\n    if (has_internal_nul((char *)utf8_value, utf8_length)) {\n    \tg_warning(\"NUL character in hostname in certificate\");\n    \tOPENSSL_free(utf8_value);\n    \treturn NULL;\n    }\n\n    result = g_strdup((char *) utf8_value);\n\tOPENSSL_free(utf8_value);\n\treturn result;\n}",
        "output": "0",
        "idx": 4663
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sas_destruct_ports(struct asd_sas_port *port)\n{\n\tstruct sas_port *sas_port, *p;\n\n\tlist_for_each_entry_safe(sas_port, p, &port->sas_port_del_list, del_list) {\n\t\tlist_del_init(&sas_port->del_list);\n\t\tsas_port_delete(sas_port);\n\t}\n}",
        "output": "0",
        "idx": 2651
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static cJSON *cJSON_New_Item(void)\n{\n\tcJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));\n\tif (node) memset(node,0,sizeof(cJSON));\n\treturn node;\n}",
        "output": "0",
        "idx": 8319
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "obj2ast_alias(PyObject* obj, alias_ty* out, PyArena* arena)\n{\n    PyObject* tmp = NULL;\n    identifier name;\n    identifier asname;\n\n    if (_PyObject_HasAttrId(obj, &PyId_name)) {\n        int res;\n        tmp = _PyObject_GetAttrId(obj, &PyId_name);\n        if (tmp == NULL) goto failed;\n        res = obj2ast_identifier(tmp, &name, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    } else {\n        PyErr_SetString(PyExc_TypeError, \"required field \\\"name\\\" missing from alias\");\n        return 1;\n    }\n    if (exists_not_none(obj, &PyId_asname)) {\n        int res;\n        tmp = _PyObject_GetAttrId(obj, &PyId_asname);\n        if (tmp == NULL) goto failed;\n        res = obj2ast_identifier(tmp, &asname, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    } else {\n        asname = NULL;\n    }\n    *out = alias(name, asname, arena);\n    return 0;\nfailed:\n    Py_XDECREF(tmp);\n    return 1;\n}",
        "output": "1",
        "idx": 7712
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "resolve_op_end (FlatpakTransaction *self,\n                FlatpakTransactionOperation *op,\n                const char *checksum,\n                GFile *sideload_path,\n                GBytes *metadata_bytes)\n{\n  g_autoptr(GBytes) old_metadata_bytes = NULL;\n\n  old_metadata_bytes = load_deployed_metadata (self, op->ref, NULL, NULL);\n  mark_op_resolved (op, checksum, sideload_path, metadata_bytes, old_metadata_bytes);\n  emit_eol_and_maybe_skip (self, op);\n }",
        "output": "1",
        "idx": 7284
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\n\tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\n\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n\t}\n\n\txfrm_probe_algs();\n\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL);\n\tif (!supp_skb) {\n\t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n\n\t\treturn -ENOBUFS;\n\t}\n\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,\n\t\t\tsock_net(sk));\n\treturn 0;\n}",
        "output": "1",
        "idx": 2014
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static CURLcode pop3_parse_url_path(struct connectdata *conn)\n{\n  struct pop3_conn *pop3c = &conn->proto.pop3c;\n  struct SessionHandle *data = conn->data;\n  const char *path = data->state.path;\n\n  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n}",
        "output": "0",
        "idx": 5021
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BOOL glyph_cache_put(rdpGlyphCache* glyphCache, UINT32 id, UINT32 index, rdpGlyph* glyph)\n{\n\trdpGlyph* prevGlyph;\n\n\tif (id > 9)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache id: %\" PRIu32 \"\", id);\n\t\treturn FALSE;\n\t}\n\n\tif (index > glyphCache->glyphCache[id].number)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache index: %\" PRIu32 \" in cache id: %\" PRIu32 \"\", index, id);\n\t\treturn FALSE;\n\t}\n\n\tWLog_Print(glyphCache->log, WLOG_DEBUG, \"GlyphCachePut: id: %\" PRIu32 \" index: %\" PRIu32 \"\", id,\n\t           index);\n\tprevGlyph = glyphCache->glyphCache[id].entries[index];\n\n\tif (prevGlyph)\n\t\tprevGlyph->Free(glyphCache->context, prevGlyph);\n\n\tglyphCache->glyphCache[id].entries[index] = glyph;\n\treturn TRUE;\n}",
        "output": "1",
        "idx": 4158
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n\tcase MSR_MTRRdefType:\n\tcase MSR_IA32_CR_PAT:\n\t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n\t}\n\treturn false;\n}",
        "output": "1",
        "idx": 1274
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned long randomize_stack_top(unsigned long stack_top)\n{\n\tunsigned long random_variable = 0;\n\n\tif ((current->flags & PF_RANDOMIZE) &&\n\t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\trandom_variable = (unsigned long) get_random_int();\n\t\trandom_variable &= STACK_RND_MASK;\n\t\trandom_variable <<= PAGE_SHIFT;\n\t}\n#ifdef CONFIG_STACK_GROWSUP\n\treturn PAGE_ALIGN(stack_top) + random_variable;\n#else\n\treturn PAGE_ALIGN(stack_top) - random_variable;\n#endif\n}",
        "output": "0",
        "idx": 3865
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spl_filesystem_dir_it_move_forward(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n\t\n\tobject->u.dir.index++;\n\tspl_filesystem_dir_read(object TSRMLS_CC);\n\tif (object->file_name) {\n\t\tefree(object->file_name);\n\t\tobject->file_name = NULL;\n\t}\n}",
        "output": "1",
        "idx": 4028
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)\n{\n\tconst char* str;\n\tunsigned int retval;\n\tsize_t tmpretval;\n\tif(!file) return 0;\n\tstr = openmpt_module_get_instrument_name(file->mod,qual-1);\n\tif(!str){\n\t\tif(buff){\n\t\t\t*buff = '\\0';\n\t\t}\n\t\treturn 0;\n\t}\n\ttmpretval = strlen(str);\n\tif(tmpretval>=INT_MAX){\n\t\ttmpretval = INT_MAX-1;\n\t}\n\tretval = (int)tmpretval;\n\tif(buff){\n\t\tmemcpy(buff,str,retval+1);\n\t\tbuff[retval] = '\\0';\n\t}\n\topenmpt_free_string(str);\n\treturn retval;\n}",
        "output": "1",
        "idx": 6736
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mark_trusted_task_thread_func (GTask        *task,\n                               gpointer      source_object,\n                               gpointer      task_data,\n                               GCancellable *cancellable)\n{\n    MarkTrustedJob *job = task_data;\n    CommonJob *common;\n\n    common = (CommonJob *) job;\n\n    nautilus_progress_info_start (job->common.progress);\n\n    mark_desktop_file_trusted (common,\n                               cancellable,\n                               job->file,\n                               job->interactive);\n}",
        "output": "1",
        "idx": 6290
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jas_iccgetuint32(jas_stream_t *in, jas_iccuint32_t *val)\n{\n\tulonglong tmp;\n\tif (jas_iccgetuint(in, 4, &tmp))\n\t\treturn -1;\n\t*val = tmp;\n\treturn 0;\n}",
        "output": "1",
        "idx": 5392
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int propagate_mnt(struct mount *dest_mnt, struct mountpoint *dest_mp,\n\t\t    struct mount *source_mnt, struct hlist_head *tree_list)\n{\n\tstruct mount *m, *n;\n\tint ret = 0;\n\n\tuser_ns = current->nsproxy->mnt_ns->user_ns;\n\tlast_dest = dest_mnt;\n\tfirst_source = source_mnt;\n\tlast_source = source_mnt;\n\tmp = dest_mp;\n\tlist = tree_list;\n\tdest_master = dest_mnt->mnt_master;\n\n\tfor (n = next_peer(dest_mnt); n != dest_mnt; n = next_peer(n)) {\n\t\tret = propagate_one(n);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tfor (m = next_group(dest_mnt, dest_mnt); m;\n\t\t\tm = next_group(m, dest_mnt)) {\n\t\tn = m;\n\t\tdo {\n\t\t\tret = propagate_one(n);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tn = next_peer(n);\n\t\t} while (n != m);\n\t}\nout:\n\tread_seqlock_excl(&mount_lock);\n\thlist_for_each_entry(n, tree_list, mnt_hash) {\n\t\tm = n->mnt_parent;\n\t\tif (m->mnt_master != dest_mnt->mnt_master)\n\t\t\tCLEAR_MNT_MARK(m->mnt_master);\n\t}\n\tread_sequnlock_excl(&mount_lock);\n\treturn ret;\n}",
        "output": "0",
        "idx": 1851
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int uio_mmap_physical(struct vm_area_struct *vma)\n{\n\tstruct uio_device *idev = vma->vm_private_data;\n\tint mi = uio_find_mem_index(vma);\n\tif (mi < 0)\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &uio_physical_vm_ops;\n\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\treturn remap_pfn_range(vma,\n\t\t\t       vma->vm_start,\n\t\t\t       idev->info->mem[mi].addr >> PAGE_SHIFT,\n\t\t\t       vma->vm_end - vma->vm_start,\n\t\t\t       vma->vm_page_prot);\n}",
        "output": "1",
        "idx": 2350
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "on_response(void *data, krb5_error_code retval, otp_response response)\n{\n    struct request_state rs = *(struct request_state *)data;\n\n    free(data);\n\n    if (retval == 0 && response != otp_response_success)\n        retval = KRB5_PREAUTH_FAILED;\n\n    if (retval == 0)\n        rs.enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n\n    rs.respond(rs.arg, retval, NULL, NULL, NULL);\n}",
        "output": "0",
        "idx": 63
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int pdf_is_pdf(FILE *fp)\n{\n    int   is_pdf;\n    char *header;\n\n    header = get_header(fp);\n\n    if (header && strstr(header, \"%PDF-\"))\n      is_pdf = 1;\n    else \n      is_pdf = 0;\n\n    free(header);\n    return is_pdf;\n}",
        "output": "1",
        "idx": 7462
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool __f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et;\n\tstruct extent_node *en;\n\tstruct extent_info ei;\n\n\tif (!f2fs_may_extent_tree(inode)) {\n\t\tif (i_ext && i_ext->len) {\n\t\t\ti_ext->len = 0;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tet = __grab_extent_tree(inode);\n\n\tif (!i_ext || !i_ext->len)\n\t\treturn false;\n\n\tget_extent_info(&ei, i_ext);\n\n\twrite_lock(&et->lock);\n\tif (atomic_read(&et->node_cnt))\n\t\tgoto out;\n\n\ten = __init_extent_tree(sbi, et, &ei);\n\tif (en) {\n\t\tspin_lock(&sbi->extent_lock);\n\t\tlist_add_tail(&en->list, &sbi->extent_list);\n\t\tspin_unlock(&sbi->extent_lock);\n\t}\nout:\n\twrite_unlock(&et->lock);\n\treturn false;\n}",
        "output": "0",
        "idx": 2317
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ext4_free_io_end(ext4_io_end_t *io)\n{\n\tBUG_ON(!io);\n\tif (io->page)\n\t\tput_page(io->page);\n\tiput(io->inode);\n\tkfree(io);\n}",
        "output": "0",
        "idx": 3181
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct vfsmount *collect_mounts(struct path *path)\n{\n\tstruct mount *tree;\n\tnamespace_lock();\n\tif (!check_mnt(real_mount(path->mnt)))\n\t\ttree = ERR_PTR(-EINVAL);\n\telse\n\t\ttree = copy_tree(real_mount(path->mnt), path->dentry,\n\t\t\t\t CL_COPY_ALL | CL_PRIVATE);\n\tnamespace_unlock();\n\tif (IS_ERR(tree))\n\t\treturn ERR_CAST(tree);\n\treturn &tree->mnt;\n}",
        "output": "0",
        "idx": 3901
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int timer_start(Unit *u) {\n        Timer *t = TIMER(u);\n        TimerValue *v;\n\n        assert(t);\n        assert(t->state == TIMER_DEAD || t->state == TIMER_FAILED);\n\n        if (UNIT_TRIGGER(u)->load_state != UNIT_LOADED)\n                return -ENOENT;\n\n        t->last_trigger = DUAL_TIMESTAMP_NULL;\n\n        LIST_FOREACH(value, v, t->values)\n                if (v->base == TIMER_ACTIVE)\n                        v->disabled = false;\n\n        if (t->stamp_path) {\n                struct stat st;\n\n                if (stat(t->stamp_path, &st) >= 0)\n                        t->last_trigger.realtime = timespec_load(&st.st_atim);\n                else if (errno == ENOENT)\n                        touch_file(t->stamp_path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, MODE_INVALID);\n        }\n\n        t->result = TIMER_SUCCESS;\n        timer_enter_waiting(t, true);\n        return 1;\n}",
        "output": "0",
        "idx": 7679
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int wvlan_set_station_nickname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint         ret = 0;\n\n\n\tDBG_FUNC(\"wvlan_set_station_nickname\");\n\tDBG_ENTER(DbgInfo);\n\n\twl_lock(lp, &flags);\n\n\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\n\tmemcpy(lp->StationName, extra, wrqu->data.length);\n\n\twl_apply(lp);\n\twl_unlock(lp, &flags);\n\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} ",
        "output": "1",
        "idx": 2358
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BOOL rdp_read_flow_control_pdu(wStream* s, UINT16* type)\n{\n\t * http:\n\tUINT8 pduType;\n\tif (!type)\n\t\treturn FALSE;\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\treturn FALSE;\n\tStream_Read_UINT8(s, pduType); \n\t*type = pduType;\n\tStream_Seek_UINT8(s);  \n\tStream_Seek_UINT8(s);  \n\tStream_Seek_UINT8(s);  \n\tStream_Seek_UINT16(s); \n\treturn TRUE;\n}",
        "output": "0",
        "idx": 5713
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"blkcipher\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t alg->cra_blkcipher.geniv ?: \"<default>\");\n\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_blkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_blkcipher.ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "1",
        "idx": 850
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void vma_adjust_trans_huge(struct vm_area_struct *vma,\n\t\t\t\t\t unsigned long start,\n\t\t\t\t\t unsigned long end,\n\t\t\t\t\t long adjust_next)\n{\n\tif (!vma->anon_vma || vma->vm_ops || vma->vm_file)\n\t\treturn;\n\t__vma_adjust_trans_huge(vma, start, end, adjust_next);\n}",
        "output": "1",
        "idx": 304
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int f2fs_read_data_page(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\tint ret = -EAGAIN;\n\n\ttrace_f2fs_readpage(page, DATA);\n\n\tif (f2fs_has_inline_data(inode))\n\t\tret = f2fs_read_inline_data(inode, page);\n\tif (ret == -EAGAIN)\n\t\tret = f2fs_mpage_readpages(page_file_mapping(page),\n\t\t\t\t\t\tNULL, page, 1, false);\n\treturn ret;\n}",
        "output": "0",
        "idx": 4415
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data;\n\n\tif (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))\n\t\tapic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\tkvm_read_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n\t\t\t\tsizeof(u32));\n\n\tapic_set_tpr(vcpu->arch.apic, data & 0xff);\n}",
        "output": "0",
        "idx": 3427
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n{\n\t__u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr;\n\tstruct kvm_regs *regs = vcpu_gp_regs(vcpu);\n\tint nr_regs = sizeof(*regs) / sizeof(__u32);\n\tu32 off;\n\n\toff = core_reg_offset_from_id(reg->id);\n\tif (off >= nr_regs ||\n\t    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)\n\t\treturn -ENOENT;\n\n\tif (validate_core_offset(reg))\n\t\treturn -EINVAL;\n\n\tif (copy_to_user(uaddr, ((u32 *)regs) + off, KVM_REG_SIZE(reg->id)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 4161
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "f_histadd(typval_T *argvars UNUSED, typval_T *rettv)\n{\n#ifdef FEAT_CMDHIST\n    int\t\thistype;\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n#endif\n\n    rettv->vval.v_number = FALSE;\n    if (check_secure())\n\treturn;\n#ifdef FEAT_CMDHIST\n    str = tv_get_string_chk(&argvars[0]);\t\n    histype = str != NULL ? get_histtype(str) : -1;\n    if (histype >= 0)\n    {\n\tstr = tv_get_string_buf(&argvars[1], buf);\n\tif (*str != NUL)\n\t{\n\t    init_history();\n\t    add_to_history(histype, str, FALSE, NUL);\n\t    rettv->vval.v_number = TRUE;\n\t    return;\n\t}\n    }\n#endif\n}",
        "output": "0",
        "idx": 8175
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "count_comp_fors(struct compiling *c, const node *n)\n{\n    int n_fors = 0;\n    int is_async;\n\n  count_comp_for:\n    is_async = 0;\n    n_fors++;\n    REQ(n, comp_for);\n    if (TYPE(CHILD(n, 0)) == ASYNC) {\n        is_async = 1;\n    }\n    if (NCH(n) == (5 + is_async)) {\n        n = CHILD(n, 4 + is_async);\n    }\n    else {\n        return n_fors;\n    }\n  count_comp_iter:\n    REQ(n, comp_iter);\n    n = CHILD(n, 0);\n    if (TYPE(n) == comp_for)\n        goto count_comp_for;\n    else if (TYPE(n) == comp_if) {\n        if (NCH(n) == 3) {\n            n = CHILD(n, 2);\n            goto count_comp_iter;\n        }\n        else\n            return n_fors;\n    }\n\n    PyErr_SetString(PyExc_SystemError,\n                    \"logic error in count_comp_fors\");\n    return -1;\n}",
        "output": "1",
        "idx": 7760
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce)\n{\n\tlong elements;\n\n\telements = parse_iv2((*p) + 2, p);\n\n\t(*p) += 2;\n\n\tif (ce->serialize == NULL) {\n\t\tobject_init_ex(*rval, ce);\n\t} else {\n\t\tzend_error(E_WARNING, \"Erroneous data format for unserializing '%s'\", ce->name);\n\t\treturn 0;\n\t}\n\n\treturn elements;\n}",
        "output": "1",
        "idx": 4094
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "snmp_api_replace_oid(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  uint8_t i;\n\n  i = 0;\n  while(oid[i] != ((uint32_t)-1)) {\n    varbind->oid[i] = oid[i];\n    i++;\n  }\n  varbind->oid[i] = ((uint32_t)-1);\n}",
        "output": "1",
        "idx": 7944
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int xrstor_state_booting(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\n\tWARN_ON(system_state != SYSTEM_BOOTING);\n\n\tif (boot_cpu_has(X86_FEATURE_XSAVES))\n\t\tasm volatile(\"1:\"XRSTORS\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\telse\n\t\tasm volatile(\"1:\"XRSTOR\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\n\tasm volatile(xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\n\treturn err;\n}",
        "output": "1",
        "idx": 2798
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint32_t virtio_config_readw(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint16_t val;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return (uint32_t)-1;\n    }\n\n    k->get_config(vdev, vdev->config);\n\n    val = lduw_p(vdev->config + addr);\n    return val;\n}",
        "output": "0",
        "idx": 5307
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void do_viewlog(HttpRequest req, HttpResponse res) {\n        if (is_readonly(req)) {\n                send_error(req, res, SC_FORBIDDEN, \"You do not have sufficient privileges to access this page\");\n                return;\n        }\n        do_head(res, \"_viewlog\", \"View log\", 100);\n        if ((Run.flags & Run_Log) && ! (Run.flags & Run_UseSyslog)) {\n                FILE *f = fopen(Run.files.log, \"r\");\n                if (f) {\n                        size_t n;\n                        char buf[512];\n                        StringBuffer_append(res->outputbuffer, \"<br><p><form><textarea cols=120 rows=30 readonly>\");\n                        while ((n = fread(buf, sizeof(char), sizeof(buf) - 1, f)) > 0) {\n                                buf[n] = 0;\n                                StringBuffer_append(res->outputbuffer, \"%s\", buf);\n                        }\n                        fclose(f);\n                        StringBuffer_append(res->outputbuffer, \"</textarea></form>\");\n                } else {\n                        StringBuffer_append(res->outputbuffer, \"Error opening logfile: %s\", STRERROR);\n                }\n        } else {\n                StringBuffer_append(res->outputbuffer,\n                                    \"<b>Cannot view logfile:</b><br>\");\n                if (! (Run.flags & Run_Log))\n                        StringBuffer_append(res->outputbuffer, \"Monit was started without logging\");\n                else\n                        StringBuffer_append(res->outputbuffer, \"Monit uses syslog\");\n        }\n        do_foot(res);\n}",
        "output": "1",
        "idx": 6024
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void sem_lock_and_putref(struct sem_array *sma)\n{\n\trcu_read_lock();\n\tsem_lock(sma, NULL, -1);\n\tipc_rcu_putref(sma);\n}",
        "output": "0",
        "idx": 3223
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct siginfo info = {};\n\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_TKILL;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\treturn do_send_specific(tgid, pid, sig, &info);\n}",
        "output": "0",
        "idx": 1323
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cleanup_pathname(struct archive_write_disk *a)\n{\n\tstruct archive_string error_string;\n\tint error_number;\n\tint rc;\n\tarchive_string_init(&error_string);\n\trc = cleanup_pathname_fsobj(a->name, &error_number, &error_string, a->flags);\n\tif (rc != ARCHIVE_OK) {\n\t\tarchive_set_error(&a->archive, error_number, \"%s\", error_string.s);\n\t}\n\tarchive_string_free(&error_string);\n\treturn rc;\n}",
        "output": "0",
        "idx": 5191
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int crypto_rng_seedsize(struct crypto_rng *tfm)\n{\n\treturn crypto_rng_alg(tfm)->seedsize;\n}",
        "output": "0",
        "idx": 3939
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int unmap_ref_private(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t\t\tstruct page *page, unsigned long address)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct vm_area_struct *iter_vma;\n\tstruct address_space *mapping;\n\tstruct prio_tree_iter iter;\n\tpgoff_t pgoff;\n\n\taddress = address & huge_page_mask(h);\n\tpgoff = vma_hugecache_offset(h, vma, address);\n\tmapping = vma->vm_file->f_dentry->d_inode->i_mapping;\n\n\tmutex_lock(&mapping->i_mmap_mutex);\n\tvma_prio_tree_foreach(iter_vma, &iter, &mapping->i_mmap, pgoff, pgoff) {\n\t\tif (iter_vma == vma)\n\t\t\tcontinue;\n\n\t\tif (!is_vma_resv_set(iter_vma, HPAGE_RESV_OWNER))\n\t\t\t__unmap_hugepage_range(iter_vma,\n\t\t\t\taddress, address + huge_page_size(h),\n\t\t\t\tpage);\n\t}\n\tmutex_unlock(&mapping->i_mmap_mutex);\n\n\treturn 1;\n}",
        "output": "0",
        "idx": 903
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_proxy_auth_id_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\tif (length < 2) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tND_PRINT((ndo, \"%u\", EXTRACT_16BITS(ptr) & L2TP_PROXY_AUTH_ID_MASK));\n}",
        "output": "0",
        "idx": 6655
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sas_scsi_clear_queue_lu(struct list_head *error_q, struct scsi_cmnd *my_cmd)\n{\n\tstruct scsi_cmnd *cmd, *n;\n\n\tlist_for_each_entry_safe(cmd, n, error_q, eh_entry) {\n\t\tif (cmd->device->sdev_target == my_cmd->device->sdev_target &&\n\t\t    cmd->device->lun == my_cmd->device->lun)\n\t\t\tsas_eh_finish_cmd(cmd);\n\t}\n}",
        "output": "0",
        "idx": 2687
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "set_lenIV(const char* line)\n{\n  char *p = strstr(line, \"/lenIV \");\n\n  if (p && (isdigit((unsigned char) p[7]) || p[7] == '+' || p[7] == '-')) {\n    lenIV = atoi(p + 7);\n  }\n}",
        "output": "0",
        "idx": 7405
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct timespec ns_to_timespec(const s64 nsec)\n{\n\tstruct timespec ts;\n\n\tif (!nsec)\n\t\treturn (struct timespec) {0, 0};\n\n\tts.tv_sec = div_long_long_rem_signed(nsec, NSEC_PER_SEC, &ts.tv_nsec);\n\tif (unlikely(nsec < 0))\n\t\tset_normalized_timespec(&ts, ts.tv_sec, ts.tv_nsec);\n\n\treturn ts;\n}",
        "output": "1",
        "idx": 2100
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "snmp_ber_encode_integer(unsigned char *out, uint32_t *out_len, uint32_t number)\n{\n  uint32_t original_out_len;\n\n  original_out_len = *out_len;\n  do {\n    (*out_len)++;\n    *out-- = (uint8_t)(number & 0xFF);\n    number >>= 8;\n  } while(number);\n\n  out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF));\n  out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_INTEGER);\n\n  return out;\n}",
        "output": "1",
        "idx": 7954
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PredictorEncodeRow(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)\n{\n\tTIFFPredictorState *sp = PredictorState(tif);\n\n\tassert(sp != NULL);\n\tassert(sp->encodepfunc != NULL);\n\tassert(sp->encoderow != NULL);\n\n\t(*sp->encodepfunc)(tif, bp, cc);\n\treturn (*sp->encoderow)(tif, bp, cc, s);\n}",
        "output": "1",
        "idx": 4258
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n{\n\tu8 *buf = NULL;\n\tint err;\n\n\tif (!seed && slen) {\n\t\tbuf = kmalloc(slen, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\tget_random_bytes(buf, slen);\n\t\tseed = buf;\n\t}\n\n\terr = crypto_rng_alg(tfm)->seed(tfm, seed, slen);\n\n\tkfree(buf);\n\treturn err;\n}",
        "output": "0",
        "idx": 3935
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ast_for_decorator(struct compiling *c, const node *n)\n{\n    expr_ty d = NULL;\n    expr_ty name_expr;\n\n    REQ(n, decorator);\n    REQ(CHILD(n, 0), AT);\n    REQ(RCHILD(n, -1), NEWLINE);\n\n    name_expr = ast_for_dotted_name(c, CHILD(n, 1));\n    if (!name_expr)\n        return NULL;\n\n    if (NCH(n) == 3) { \n        d = name_expr;\n        name_expr = NULL;\n    }\n    else if (NCH(n) == 5) { \n        d = Call(name_expr, NULL, NULL, LINENO(n),\n                 n->n_col_offset, c->c_arena);\n        if (!d)\n            return NULL;\n        name_expr = NULL;\n    }\n    else {\n        d = ast_for_call(c, CHILD(n, 3), name_expr);\n        if (!d)\n            return NULL;\n        name_expr = NULL;\n    }\n\n    return d;\n}",
        "output": "1",
        "idx": 7740
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool key_is_negative(const struct key *key)\n{\n\treturn key_read_state(key) < 0;\n}",
        "output": "0",
        "idx": 2477
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "decoding_feof(struct tok_state *tok)\n{\n    if (tok->decoding_state != STATE_NORMAL) {\n        return feof(tok->fp);\n    } else {\n        PyObject* buf = tok->decoding_buffer;\n        if (buf == NULL) {\n            buf = PyObject_CallObject(tok->decoding_readline, NULL);\n            if (buf == NULL) {\n                error_ret(tok);\n                return 1;\n            } else {\n                tok->decoding_buffer = buf;\n            }\n        }\n        return PyObject_Length(buf) == 0;\n    }\n}",
        "output": "1",
        "idx": 7672
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\n\tint dumpable = 0;\n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\ttcred = __task_cred(task);\n\tif (uid_eq(cred->uid, tcred->euid) &&\n\t    uid_eq(cred->uid, tcred->suid) &&\n\t    uid_eq(cred->uid, tcred->uid)  &&\n\t    gid_eq(cred->gid, tcred->egid) &&\n\t    gid_eq(cred->gid, tcred->sgid) &&\n\t    gid_eq(cred->gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tsmp_rmb();\n\tif (task->mm)\n\t\tdumpable = get_dumpable(task->mm);\n\trcu_read_lock();\n\tif (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\trcu_read_unlock();\n\n\treturn security_ptrace_access_check(task, mode);\n}",
        "output": "1",
        "idx": 2400
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cJSON_ReplaceItemInArray( cJSON *array, int which, cJSON *newitem )\n{\n\tcJSON *c = array->child;\n\twhile ( c && which > 0 ) {\n\t\tc = c->next;\n\t\t--which;\n\t}\n\tif ( ! c )\n\t\treturn;\n\tnewitem->next = c->next;\n\tnewitem->prev = c->prev;\n\tif ( newitem->next )\n\t\tnewitem->next->prev = newitem;\n\tif ( c == array->child )\n\t\tarray->child = newitem;\n\telse\n\t\tnewitem->prev->next = newitem;\n\tc->next = c->prev = 0;\n\tcJSON_Delete( c );\n}",
        "output": "1",
        "idx": 5954
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long jpc_bitstream_getbits(jpc_bitstream_t *bitstream, int n)\n{\n\tlong v;\n\tint u;\n\n\tif (n < 0 || n >= 32) {\n\t\treturn -1;\n\t}\n\n\tv = 0;\n\twhile (--n >= 0) {\n\t\tif ((u = jpc_bitstream_getbit(bitstream)) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 1) | u;\n\t}\n\treturn v;\n}",
        "output": "0",
        "idx": 7505
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hns_xgmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)\n\t\treturn ARRAY_SIZE(g_xgmac_stats_string);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2271
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tkey = keyring_search_aux(keyring, &ctx);\n\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}",
        "output": "0",
        "idx": 3685
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kill_something_info(int sig, struct siginfo *info, pid_t pid)\n{\n\tint ret;\n\n\tif (pid > 0) {\n\t\trcu_read_lock();\n\t\tret = kill_pid_info(sig, info, find_vpid(pid));\n\t\trcu_read_unlock();\n\t\treturn ret;\n\t}\n\n\tif (pid == INT_MIN)\n\t\treturn -ESRCH;\n\n\tread_lock(&tasklist_lock);\n\tif (pid != -1) {\n\t\tret = __kill_pgrp_info(sig, info,\n\t\t\t\tpid ? find_vpid(-pid) : task_pgrp(current));\n\t} else {\n\t\tint retval = 0, count = 0;\n\t\tstruct task_struct * p;\n\n\t\tfor_each_process(p) {\n\t\t\tif (task_pid_vnr(p) > 1 &&\n\t\t\t\t\t!same_thread_group(p, current)) {\n\t\t\t\tint err = group_send_sig_info(sig, info, p);\n\t\t\t\t++count;\n\t\t\t\tif (err != -EPERM)\n\t\t\t\t\tretval = err;\n\t\t\t}\n\t\t}\n\t\tret = count ? retval : -ESRCH;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 2361
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_event_comm_output(struct perf_event *event,\n\t\t\t\t     struct perf_comm_event *comm_event)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint size = comm_event->event_id.header.size;\n\tint ret;\n\n\tperf_event_header__init_id(&comm_event->event_id.header, &sample, event);\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tcomm_event->event_id.header.size, 0);\n\n\tif (ret)\n\t\tgoto out;\n\n\tcomm_event->event_id.pid = perf_event_pid(event, comm_event->task);\n\tcomm_event->event_id.tid = perf_event_tid(event, comm_event->task);\n\n\tperf_output_put(&handle, comm_event->event_id);\n\t__output_copy(&handle, comm_event->comm,\n\t\t\t\t   comm_event->comm_size);\n\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\nout:\n\tcomm_event->event_id.header.size = size;\n}",
        "output": "0",
        "idx": 687
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const struct lxc_rootfs *rootfs,\n\t\t\t\t\t  const char *lxc_name)\n{\n\tchar *aux;\n\tchar path[MAXPATHLEN];\n\tint r, ret = 0, offset;\n\tconst char *lxcpath;\n\n\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\tif (!lxcpath) {\n\t\tERROR(\"Out of memory\");\n\t\treturn -1;\n\t}\n\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s/rootfs\", lxcpath, lxc_name);\n\tif (r < 0 || r >= MAXPATHLEN)\n\t\tgoto skipvarlib;\n\n\taux = strstr(mntent->mnt_dir, path);\n\tif (aux) {\n\t\toffset = strlen(path);\n\t\tgoto skipabs;\n\t}\n\nskipvarlib:\n\taux = strstr(mntent->mnt_dir, rootfs->path);\n\tif (!aux) {\n\t\tWARN(\"ignoring mount point '%s'\", mntent->mnt_dir);\n\t\treturn ret;\n\t}\n\toffset = strlen(rootfs->path);\n\nskipabs:\n\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s\", rootfs->mount,\n\t\t aux + offset);\n\tif (r < 0 || r >= MAXPATHLEN) {\n\t\tWARN(\"pathnme too long for '%s'\", mntent->mnt_dir);\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, rootfs->mount);\n}",
        "output": "0",
        "idx": 6041
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jas_iccprof_t *jas_iccprof_createfrombuf(uchar *buf, int len)\n{\n\tjas_stream_t *in;\n\tjas_iccprof_t *prof;\n\tif (!(in = jas_stream_memopen(JAS_CAST(char *, buf), len)))\n\t\tgoto error;\n\tif (!(prof = jas_iccprof_load(in)))\n\t\tgoto error;\n\tjas_stream_close(in);\n\treturn prof;\nerror:\n\tif (in)\n\t\tjas_stream_close(in);\n\treturn 0;\n}",
        "output": "1",
        "idx": 5378
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ipmi_si_port_setup(struct si_sm_io *io)\n{\n\tunsigned int addr = io->addr_data;\n\tint          idx;\n\n\tif (!addr)\n\t\treturn -ENODEV;\n\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = port_inb;\n\t\tio->outputb = port_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = port_inw;\n\t\tio->outputb = port_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = port_inl;\n\t\tio->outputb = port_outl;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_region(addr + idx * io->regspacing,\n\t\t\t\t   io->regsize, DEVICE_NAME) == NULL) {\n\t\t\twhile (idx--)\n\t\t\t\trelease_region(addr + idx * io->regspacing,\n\t\t\t\t\t       io->regsize);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tio->io_cleanup = port_cleanup;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 4239
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vgacon_flush_scrollback(struct vc_data *c)\n{\n\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\n\tvgacon_scrollback_reset(c->vc_num, size);\n}",
        "output": "1",
        "idx": 1870
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, ftruncate)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tlong size;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &size) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!php_stream_truncate_supported(intern->u.file.stream)) {\n\t\tzend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, \"Can't truncate file %s\", intern->file_name);\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_BOOL(0 == php_stream_truncate_set_size(intern->u.file.stream, size));\n} ",
        "output": "0",
        "idx": 5493
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hash_link_ref(const uint8_t *link_ref, size_t length)\n{\n\tsize_t i;\n\tunsigned int hash = 0;\n\n\tfor (i = 0; i < length; ++i)\n\t\thash = tolower(link_ref[i]) + (hash << 6) + (hash << 16) - hash;\n\n\treturn hash;\n}",
        "output": "1",
        "idx": 8812
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void update_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tclr_exception_intercept(svm, BP_VECTOR);\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}",
        "output": "0",
        "idx": 1347
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void br_multicast_del_pg(struct net_bridge *br,\n\t\t\t\tstruct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\n\tmdb = mlock_dereference(br->mdb, br);\n\n\tmp = br_mdb_ip_get(mdb, &pg->addr);\n\tif (WARN_ON(!mp))\n\t\treturn;\n\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p != pg)\n\t\t\tcontinue;\n\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\n\t\tif (!mp->ports && !mp->mglist && mp->timer_armed &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\n\t\treturn;\n\t}\n\n\tWARN_ON(1);\n}",
        "output": "0",
        "idx": 3281
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g) {\n    if(!p || !g) \n        return 0;\n    BN_free(dh->p);\n    BN_free(dh->q);\n    BN_free(dh->g);\n    dh->p = p;\n    dh->q = q;\n    dh->g = g;\n    if(q)\n        dh->length = BN_num_bits(q);\n    return 1;\n}",
        "output": "1",
        "idx": 8460
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id)\n{\n    streamIterator si;\n    int64_t numfields;\n    streamIteratorStart(&si,s,NULL,NULL,!first);\n    si.skip_tombstones = skip_tombstones;\n    int found = streamIteratorGetID(&si,edge_id,&numfields);\n    if (!found) {\n        streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};\n        *edge_id = first ? max_id : min_id;\n    }\n\n}",
        "output": "1",
        "idx": 8480
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int unix_dgram_peer_wake_connect(struct sock *sk, struct sock *other)\n{\n\tstruct unix_sock *u, *u_other;\n\tint rc;\n\n\tu = unix_sk(sk);\n\tu_other = unix_sk(other);\n\trc = 0;\n\tspin_lock(&u_other->peer_wait.lock);\n\n\tif (!u->peer_wake.private) {\n\t\tu->peer_wake.private = other;\n\t\t__add_wait_queue(&u_other->peer_wait, &u->peer_wake);\n\n\t\trc = 1;\n\t}\n\n\tspin_unlock(&u_other->peer_wait.lock);\n\treturn rc;\n}",
        "output": "0",
        "idx": 1373
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "horDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\tTIFFPredictorState* sp = PredictorState(tif);\n\ttmsize_t stride = sp->stride;\n\tuint16 *wp = (uint16*) cp0;\n\ttmsize_t wc = cc/2;\n\n\tassert((cc%(2*stride))==0);\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\twp += wc - 1;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] - (unsigned int)wp[0]) & 0xffff); wp--)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n}",
        "output": "1",
        "idx": 4276
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void handle_runtime_action(HttpRequest req, HttpResponse res) {\n        const char *action = get_parameter(req, \"action\");\n        if (action) {\n                if (is_readonly(req)) {\n                        send_error(req, res, SC_FORBIDDEN, \"You do not have sufficient privileges to access this page\");\n                        return;\n                }\n                if (IS(action, \"validate\")) {\n                        LogInfo(\"The Monit http server woke up on user request\\n\");\n                        do_wakeupcall();\n                } else if (IS(action, \"stop\")) {\n                        LogInfo(\"The Monit http server stopped on user request\\n\");\n                        send_error(req, res, SC_SERVICE_UNAVAILABLE, \"The Monit http server is stopped\");\n                        Engine_stop();\n                        return;\n                }\n        }\n        handle_runtime(req, res);\n}",
        "output": "0",
        "idx": 8427
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void hugepage_subpool_put_pages(struct hugepage_subpool *spool,\n\t\t\t\t       long delta)\n{\n\tif (!spool)\n\t\treturn;\n\n\tspin_lock(&spool->lock);\n\tspool->used_hpages -= delta;\n\tunlock_or_release_subpool(spool);\n}",
        "output": "0",
        "idx": 911
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int read_filesystem_tables_4()\n{\n\tlong long directory_table_end, table_start;\n\n\tif(read_xattrs_from_disk(fd, &sBlk.s, no_xattrs, &table_start) == 0)\n\t\treturn FALSE;\n\n\tif(read_uids_guids(&table_start) == FALSE)\n\t\treturn FALSE;\n\n\tif(parse_exports_table(&table_start) == FALSE)\n\t\treturn FALSE;\n\n\tif(read_fragment_table(&directory_table_end) == FALSE)\n\t\treturn FALSE;\n\n\tif(read_inode_table(sBlk.s.inode_table_start,\n\t\t\t\tsBlk.s.directory_table_start) == FALSE)\n\t\treturn FALSE;\n\n\tif(read_directory_table(sBlk.s.directory_table_start,\n\t\t\t\tdirectory_table_end) == FALSE)\n\t\treturn FALSE;\n\n\tif(no_xattrs)\n\t\tsBlk.s.xattr_id_table_start = SQUASHFS_INVALID_BLK;\n\n\treturn TRUE;\n}",
        "output": "1",
        "idx": 5334
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cJSON_InitHooks(cJSON_Hooks* hooks)\n{\n\tif ( ! hooks ) {\n\t\tcJSON_malloc = malloc;\n\t\tcJSON_free = free;\n\t\treturn;\n\t}\n\tcJSON_malloc = (hooks->malloc_fn) ? hooks->malloc_fn : malloc;\n\tcJSON_free = (hooks->free_fn) ? hooks->free_fn : free;\n}",
        "output": "1",
        "idx": 5890
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char* cJSON_strdup( const char* str )\n{\n\tsize_t len;\n\tchar* copy;\n\n\tlen = strlen( str ) + 1;\n\tif ( ! ( copy = (char*) cJSON_malloc( len ) ) )\n\t\treturn 0;\n\tmemcpy( copy, str, len );\n\treturn copy;\n}",
        "output": "1",
        "idx": 5934
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void ext4_truncate_failed_write(struct inode *inode)\n{\n\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text4_truncate(inode);\n\tup_write(&EXT4_I(inode)->i_mmap_sem);\n}",
        "output": "0",
        "idx": 1455
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct resource_pool *dce110_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct hw_asic_id asic_id)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\n\tif (!pool)\n\t\treturn NULL;\n\n\tif (construct(num_virtual_links, dc, pool, asic_id))\n\t\treturn &pool->base;\n\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "output": "0",
        "idx": 4479
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static RList *r_bin_wasm_get_global_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmGlobalEntry *ptr = NULL;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tint buflen = bin->buf->length - (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\n\twhile (i < len && len < buflen && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmGlobalEntry))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, (ut8*)&ptr->content_type, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, &ptr->mutability, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (len + 8 > buflen || !(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t\tr++;\n\t}\n\treturn ret;\nbeach:\n\tfree (ptr);\n\treturn ret;\n}",
        "output": "0",
        "idx": 8623
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int verify_compat_iovec(struct msghdr *kern_msg, struct iovec *kern_iov,\n\t\t   struct sockaddr_storage *kern_address, int mode)\n{\n\tint tot_len;\n\n\tif (kern_msg->msg_namelen) {\n\t\tif (mode == VERIFY_READ) {\n\t\t\tint err = move_addr_to_kernel(kern_msg->msg_name,\n\t\t\t\t\t\t      kern_msg->msg_namelen,\n\t\t\t\t\t\t      kern_address);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tkern_msg->msg_name = kern_address;\n\t} else\n\t\tkern_msg->msg_name = NULL;\n\n\ttot_len = iov_from_user_compat_to_kern(kern_iov,\n\t\t\t\t\t  (struct compat_iovec __user *)kern_msg->msg_iov,\n\t\t\t\t\t  kern_msg->msg_iovlen);\n\tif (tot_len >= 0)\n\t\tkern_msg->msg_iov = kern_iov;\n\n\treturn tot_len;\n}",
        "output": "1",
        "idx": 2440
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void flash_option_bytes_init(int boot_from_dfu)\n{\n    uint32_t val = 0xfffff8aa;\n\n    if (boot_from_dfu){\n        val &= ~(1<<27); \n    }\n    else {\n        if (solo_is_locked())\n        {\n            val = 0xfffff8cc;\n        }\n    }\n\n    val &= ~(1<<26); \n    val &= ~(1<<25); \n    val &= ~(1<<24); \n\n    if (FLASH->OPTR == val)\n    {\n        return;\n    }\n\n    __disable_irq();\n    while (FLASH->SR & (1<<16))\n        ;\n    flash_unlock();\n    if (FLASH->CR & (1<<30))\n    {\n        FLASH->OPTKEYR = 0x08192A3B;\n        FLASH->OPTKEYR = 0x4C5D6E7F;\n    }\n\n    FLASH->OPTR =val;\n    FLASH->CR |= (1<<17);\n\n    while (FLASH->SR & (1<<16))\n        ;\n\n    flash_lock();\n\n    __enable_irq();\n}",
        "output": "1",
        "idx": 8354
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rtrs_clt_dev_release(struct device *dev)\n{\n\tstruct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess,\n\t\t\t\t\t\t dev);\n\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\tkfree(clt);\n}",
        "output": "0",
        "idx": 2893
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cfm_network_addr_print(netdissect_options *ndo,\n                       register const u_char *tptr)\n{\n    u_int network_addr_type;\n    u_int hexdump =  FALSE;\n\n    network_addr_type = *tptr;\n    ND_PRINT((ndo, \"\\n\\t  Network Address Type %s (%u)\",\n           tok2str(af_values, \"Unknown\", network_addr_type),\n           network_addr_type));\n\n    switch(network_addr_type) {\n    case AFNUM_INET:\n        ND_PRINT((ndo, \", %s\", ipaddr_string(ndo, tptr + 1)));\n        break;\n\n    case AFNUM_INET6:\n        ND_PRINT((ndo, \", %s\", ip6addr_string(ndo, tptr + 1)));\n        break;\n\n    default:\n        hexdump = TRUE;\n        break;\n    }\n\n    return hexdump;\n}",
        "output": "1",
        "idx": 4852
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SQLWCHAR* _single_string_alloc_and_expand( LPCSTR in )\n{\n    SQLWCHAR *chr;\n    int len = 0;\n\n    if ( !in )\n    {\n        return in;\n    }\n\n    while ( in[ len ] != 0 )\n    {\n        len ++;\n    }\n\n    chr = malloc( sizeof( SQLWCHAR ) * ( len + 1 ));\n\n    len = 0;\n    while ( in[ len ] != 0 )\n    {\n        chr[ len ] = in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = 0;\n\n    return chr;\n}",
        "output": "1",
        "idx": 7326
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void usage(void)\n{\n  PRINT_VERSION;\n  puts(\"Copyright (c) 2011, Oracle and/or its affiliates. \"\n       \"All rights reserved.\\n\");\n  puts(\"Enable or disable plugins.\");\n  printf(\"\\nUsage: %s [options] <plugin> ENABLE|DISABLE\\n\\nOptions:\\n\",\n     my_progname);\n  my_print_help(my_long_options);\n  puts(\"\\n\");\n}",
        "output": "1",
        "idx": 5238
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int netbk_set_skb_gso(struct xenvif *vif,\n\t\t\t     struct sk_buff *skb,\n\t\t\t     struct xen_netif_extra_info *gso)\n{\n\tif (!gso->u.gso.size) {\n\t\tnetdev_err(vif->dev, \"GSO size must not be zero.\\n\");\n\t\tnetbk_fatal_tx_err(vif);\n\t\treturn -EINVAL;\n\t}\n\n\tif (gso->u.gso.type != XEN_NETIF_GSO_TYPE_TCPV4) {\n\t\tnetdev_err(vif->dev, \"Bad GSO type %d.\\n\", gso->u.gso.type);\n\t\tnetbk_fatal_tx_err(vif);\n\t\treturn -EINVAL;\n\t}\n\n\tskb_shinfo(skb)->gso_size = gso->u.gso.size;\n\tskb_shinfo(skb)->gso_type = SKB_GSO_TCPV4;\n\n\tskb_shinfo(skb)->gso_type |= SKB_GSO_DODGY;\n\tskb_shinfo(skb)->gso_segs = 0;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1153
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs_set_open_stateid_locked(struct nfs4_state *state, nfs4_stateid *stateid, fmode_t fmode)\n{\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tmemcpy(state->stateid.data, stateid->data, sizeof(state->stateid.data));\n\tmemcpy(state->open_stateid.data, stateid->data, sizeof(state->open_stateid.data));\n\tswitch (fmode) {\n\t\tcase FMODE_READ:\n\t\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tset_bit(NFS_O_RDWR_STATE, &state->flags);\n\t}\n}",
        "output": "0",
        "idx": 3045
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gnutls_x509_crt_verify (gnutls_x509_crt_t cert,\n\t\t\tconst gnutls_x509_crt_t * CA_list,\n\t\t\tint CA_list_length, unsigned int flags,\n\t\t\tunsigned int *verify)\n{\n  int ret;\n  ret =\n    _gnutls_verify_certificate2 (cert, CA_list, CA_list_length, flags,\n\t\t\t\t verify);\n  if (ret < 0)\n    {\n      gnutls_assert ();\n      return ret;\n    }\n\n  return 0;\n}",
        "output": "1",
        "idx": 4622
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "print_arrays_for(char *set)\n{\n  FILE *f;\n\n  snprintf(buf, sizeof(buf), \"%s.conf\", set);\n\n  if ((f = fopen(buf, \"r\")) == NULL) {\n    fprintf(stderr, \"%s: can't read conf file for charset %s\\n\", prog, set);\n    exit(EXIT_FAILURE);\n  }\n\n  printf(\"\\\n\\n\\n\",\n\t set, prog);\n\n  print_array(f, set, \"ctype\",      CTYPE_TABLE_SIZE);\n  print_array(f, set, \"to_lower\",   TO_LOWER_TABLE_SIZE);\n  print_array(f, set, \"to_upper\",   TO_UPPER_TABLE_SIZE);\n  print_array(f, set, \"sort_order\", SORT_ORDER_TABLE_SIZE);\n  printf(\"\\n\");\n\n  fclose(f);\n\n  return;\n}",
        "output": "0",
        "idx": 7347
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_swevent_overflow(struct perf_event *event, u64 overflow,\n\t\t\t\t    struct perf_sample_data *data,\n\t\t\t\t    struct pt_regs *regs)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint throttle = 0;\n\n\tdata->period = event->hw.last_period;\n\tif (!overflow)\n\t\toverflow = perf_swevent_set_period(event);\n\n\tif (hwc->interrupts == MAX_INTERRUPTS)\n\t\treturn;\n\n\tfor (; overflow; overflow--) {\n\t\tif (__perf_event_overflow(event, throttle,\n\t\t\t\t\t    data, regs)) {\n\t\t\tbreak;\n\t\t}\n\t\tthrottle = 1;\n\t}\n}",
        "output": "0",
        "idx": 697
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvm_set_guest_paused(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->arch.time_page)\n\t\treturn -EINVAL;\n\tvcpu->arch.pvclock_set_guest_stopped_request = true;\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\treturn 0;\n}",
        "output": "1",
        "idx": 884
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_xattrs(const char *path)\n{\n\t char value[200];\n\t if (getxattr(path, \"security.selinux\", value, 200) >= 0) {\n\t\tfprintf(stderr, \"leak at getxattr of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at getxattr of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}",
        "output": "0",
        "idx": 7291
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ext4_xattr_create_cache(char *name)\n{\n\treturn mb_cache_create(name, HASH_BUCKET_BITS);\n}",
        "output": "1",
        "idx": 1084
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __init int seqgen_init(void)\n{\n\trekey_seq_generator(NULL);\n\treturn 0;\n}",
        "output": "1",
        "idx": 600
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *cJSON_Print(cJSON *item)\t\t\t\t{return print_value(item,0,1,0);}",
        "output": "0",
        "idx": 8341
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint32_t generate_seed() {\n    uint32_t seed;\n    int done = 0;\n\n#if !defined(_WIN32) && defined(USE_URANDOM)\n    if (!done && seed_from_urandom(&seed) == 0)\n        done = 1;\n#endif\n\n#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n    if (!done && seed_from_windows_cryptoapi(&seed) == 0)\n        done = 1;\n#endif\n\n    if (!done) {\n        seed_from_timestamp_and_pid(&seed);\n    }\n\n    if (seed == 0)\n        seed = 1;\n\n    return seed;\n}",
        "output": "0",
        "idx": 5981
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_timer_start_slave(struct snd_timer_instance *timeri)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&slave_active_lock, flags);\n\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\tif (timeri->master && timeri->timer) {\n\t\tspin_lock(&timeri->timer->lock);\n\t\tlist_add_tail(&timeri->active_list,\n\t\t\t      &timeri->master->slave_active_head);\n\t\tspin_unlock(&timeri->timer->lock);\n\t}\n\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\treturn 1; \n}",
        "output": "0",
        "idx": 1535
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mif_validate(jas_stream_t *in)\n{\n\tuchar buf[MIF_MAGICLEN];\n\tuint_fast32_t magic;\n\tint i;\n\tint n;\n\n\tassert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);\n\n\tif ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {\n\t\treturn -1;\n\t}\n\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (n < MIF_MAGICLEN) {\n\t\treturn -1;\n\t}\n\n\tmagic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |\n\t  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |\n\t  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |\n\t  buf[3];\n\n\tif (magic != MIF_MAGIC) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 5412
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_SSL_match_hostname (const char *cert_hostname, const char *hostname)\n{\n\tconst char *cert_domain, *domain, *next_dot;\n\n\tif (g_ascii_strcasecmp (cert_hostname, hostname) == 0)\n\t\treturn 0;\n\n\tif (cert_hostname[0] == '*')\n\t{\n\t\tcert_domain = &cert_hostname[1];\n\t\tif (cert_domain[0] == '\\0')\n\t\t\treturn -1;\n\t\tif (cert_domain[0] != '.')\n\t\t\treturn -1;\n\t\tif (cert_domain[1] == '.')\n\t\t\treturn -1;\n\t\tnext_dot = strchr (&cert_domain[1], '.');\n\t\tif (next_dot == NULL)\n\t\t\treturn -1;\n\t\tif (next_dot[1] == '.')\n\t\t\treturn -1;\n\n\t\tdomain = strchr (hostname, '.');\n\n\t\tif (domain == NULL || strlen(domain) == 1)\n\t\t\treturn -1;\n\n\t\tif (g_ascii_strcasecmp (cert_domain, domain) == 0)\n\t\t\treturn 0;\n\t}\n\n\treturn -1;\n}",
        "output": "0",
        "idx": 6163
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void setConfigDefaults(HttpRoute *route)\n{\n    route->mode = mprGetJson(route->config, \"app.mode\");\n    if (smatch(route->mode, \"debug\")) {\n        httpSetRouteShowErrors(route, 1);\n        route->keepSource = 1;\n    }\n}",
        "output": "1",
        "idx": 5014
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic->pending_events;\n}",
        "output": "1",
        "idx": 2870
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VTermScreen *screen_new(VTerm *vt)\n{\n  VTermState *state = vterm_obtain_state(vt);\n  VTermScreen *screen;\n  int rows, cols;\n\n  if(!state)\n    return NULL;\n\n  screen = vterm_allocator_malloc(vt, sizeof(VTermScreen));\n\n  vterm_get_size(vt, &rows, &cols);\n\n  screen->vt = vt;\n  screen->state = state;\n\n  screen->damage_merge = VTERM_DAMAGE_CELL;\n  screen->damaged.start_row = -1;\n  screen->pending_scrollrect.start_row = -1;\n\n  screen->rows = rows;\n  screen->cols = cols;\n\n  screen->callbacks = NULL;\n  screen->cbdata    = NULL;\n\n  screen->buffers[0] = realloc_buffer(screen, NULL, rows, cols);\n\n  screen->buffer = screen->buffers[0];\n\n  screen->sb_buffer = vterm_allocator_malloc(screen->vt, sizeof(VTermScreenCell) * cols);\n\n  vterm_state_set_callbacks(screen->state, &state_cbs, screen);\n\n  return screen;\n}",
        "output": "1",
        "idx": 5832
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xen_evtchn_cpu_prepare(unsigned int cpu)\n{\n\tint ret = 0;\n\n\txen_cpu_init_eoi(cpu);\n\n\tif (evtchn_ops->percpu_init)\n\t\tret = evtchn_ops->percpu_init(cpu);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 2743
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "asmlinkage long sys_oabi_semtimedop(int semid,\n\t\t\t\t    struct oabi_sembuf __user *tsops,\n\t\t\t\t    unsigned nsops,\n\t\t\t\t    const struct timespec __user *timeout)\n{\n\tstruct sembuf *sops;\n\tstruct timespec local_timeout;\n\tlong err;\n\tint i;\n\n\tif (nsops < 1)\n\t\treturn -EINVAL;\n\tsops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);\n\tif (!sops)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tfor (i = 0; i < nsops; i++) {\n\t\t__get_user_error(sops[i].sem_num, &tsops->sem_num, err);\n\t\t__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);\n\t\t__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);\n\t\ttsops++;\n\t}\n\tif (timeout) {\n\t\terr |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));\n\t\ttimeout = &local_timeout;\n\t}\n\tif (err) {\n\t\terr = -EFAULT;\n\t} else {\n\t\tmm_segment_t fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = sys_semtimedop(semid, sops, nsops, timeout);\n\t\tset_fs(fs);\n\t}\n\tkfree(sops);\n\treturn err;\n}",
        "output": "1",
        "idx": 384
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int init_nss_hash(struct crypto_instance *instance)\n{\n\tPK11SlotInfo*\thash_slot = NULL;\n\tSECItem\t\thash_param;\n\n\tif (!hash_to_nss[instance->crypto_hash_type]) {\n\t\treturn 0;\n\t}\n\n\thash_param.type = siBuffer;\n\thash_param.data = 0;\n\thash_param.len = 0;\n\n\thash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);\n\tif (hash_slot == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Unable to find security slot (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\n\tinstance->nss_sym_key_sign = PK11_ImportSymKey(hash_slot,\n\t\t\t\t\t\t       hash_to_nss[instance->crypto_hash_type],\n\t\t\t\t\t\t       PK11_OriginUnwrap, CKA_SIGN,\n\t\t\t\t\t\t       &hash_param, NULL);\n\tif (instance->nss_sym_key_sign == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Failure to import key into NSS (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\n\tPK11_FreeSlot(hash_slot);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 3712
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "u64 secure_dccp_sequence_number(__be32 saddr, __be32 daddr,\n\t\t\t\t__be16 sport, __be16 dport)\n{\n\tu32 hash[MD5_DIGEST_WORDS];\n\tu64 seq;\n\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n\thash[3] = net_secret[15];\n\n\tmd5_transform(hash, net_secret);\n\n\tseq = hash[0] | (((u64)hash[1]) << 32);\n\tseq += ktime_to_ns(ktime_get_real());\n\tseq &= (1ull << 48) - 1;\n\n\treturn seq;\n}",
        "output": "0",
        "idx": 777
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void jbd2_journal_wait_updates(journal_t *journal)\n{\n\ttransaction_t *commit_transaction = journal->j_running_transaction;\n\n\tif (!commit_transaction)\n\t\treturn;\n\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (atomic_read(&commit_transaction->t_updates)) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&commit_transaction->t_updates)) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n}",
        "output": "1",
        "idx": 2012
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int masq_inet_event(struct notifier_block *this,\n\t\t\t   unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct in_device *idev = ((struct in_ifaddr *)ptr)->ifa_dev;\n\tstruct netdev_notifier_info info;\n\n\tif (idev->dead)\n\t\treturn NOTIFY_DONE;\n\n\tnetdev_notifier_info_init(&info, idev->dev);\n\treturn masq_device_event(this, event, &info);\n}",
        "output": "0",
        "idx": 1705
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __exit ipgre_fini(void)\n{\n\trtnl_link_unregister(&ipgre_tap_ops);\n\trtnl_link_unregister(&ipgre_link_ops);\n\tunregister_pernet_device(&ipgre_net_ops);\n\tif (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)\n\t\tprintk(KERN_INFO \"ipgre close: can't remove protocol\\n\");\n}",
        "output": "1",
        "idx": 2202
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE3(osf_sysinfo, int, command, char __user *, buf, long, count)\n{\n\tconst char *sysinfo_table[] = {\n\t\tutsname()->sysname,\n\t\tutsname()->nodename,\n\t\tutsname()->release,\n\t\tutsname()->version,\n\t\tutsname()->machine,\n\t\t\"alpha\",\t\n\t\t\"dummy\",\t\n\t\t\"dummy\",\t\n\t\t\"dummy\",\t\n\t};\n\tunsigned long offset;\n\tconst char *res;\n\tlong len, err = -EINVAL;\n\n\toffset = command-1;\n\tif (offset >= ARRAY_SIZE(sysinfo_table)) {\n\t\tprintk(\"sysinfo(%d)\", command);\n\t\tgoto out;\n\t}\n\n\tdown_read(&uts_sem);\n\tres = sysinfo_table[offset];\n\tlen = strlen(res)+1;\n\tif ((unsigned long)len > (unsigned long)count)\n\t\tlen = count;\n\tif (copy_to_user(buf, res, len))\n\t\terr = -EFAULT;\n\telse\n\t\terr = 0;\n\tup_read(&uts_sem);\n out:\n\treturn err;\n}",
        "output": "0",
        "idx": 563
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\tcpumask_clear(&mm->context.cpu_attach_mask);\n\tatomic_set(&mm->context.attach_count, 0);\n\tmm->context.flush_mm = 0;\n\tmm->context.asce_bits = _ASCE_TABLE_LENGTH | _ASCE_USER_BITS;\n\tmm->context.asce_bits |= _ASCE_TYPE_REGION3;\n#ifdef CONFIG_PGSTE\n\tmm->context.alloc_pgste = page_table_allocate_pgste;\n\tmm->context.has_pgste = 0;\n\tmm->context.use_skey = 0;\n#endif\n\tmm->context.asce_limit = STACK_TOP_MAX;\n\tcrst_table_init((unsigned long *) mm->pgd, pgd_entry_type(mm));\n\treturn 0;\n}",
        "output": "1",
        "idx": 1140
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int host_start(struct ci13xxx *ci)\n{\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd *ehci;\n\tint ret;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\thcd = usb_create_hcd(&ci_ehci_hc_driver, ci->dev, dev_name(ci->dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(ci->dev, ci);\n\thcd->rsrc_start = ci->hw_bank.phys;\n\thcd->rsrc_len = ci->hw_bank.size;\n\thcd->regs = ci->hw_bank.abs;\n\thcd->has_tt = 1;\n\n\thcd->power_budget = ci->platdata->power_budget;\n\thcd->phy = ci->transceiver;\n\n\tehci = hcd_to_ehci(hcd);\n\tehci->caps = ci->hw_bank.cap;\n\tehci->has_hostpc = ci->hw_bank.lpm;\n\n\tret = usb_add_hcd(hcd, 0, 0);\n\tif (ret)\n\t\tusb_put_hcd(hcd);\n\telse\n\t\tci->hcd = hcd;\n\n\tif (ci->platdata->flags & CI13XXX_DISABLE_STREAMING)\n\t\thw_write(ci, OP_USBMODE, USBMODE_CI_SDIS, USBMODE_CI_SDIS);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 1119
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sample_to_timespec(const clockid_t which_clock,\n\t\t\t       union cpu_time_count cpu,\n\t\t\t       struct timespec *tp)\n{\n\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED)\n\t\t*tp = ns_to_timespec(cpu.sched);\n\telse\n\t\tcputime_to_timespec(cpu.cpu, tp);\n}",
        "output": "0",
        "idx": 3009
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rds_tcp_kill_sock(struct net *net)\n{\n\tstruct rds_tcp_connection *tc, *_tc;\n\tLIST_HEAD(tmp_list);\n\tstruct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);\n\tstruct socket *lsock = rtn->rds_tcp_listen_sock;\n\n\trtn->rds_tcp_listen_sock = NULL;\n\trds_tcp_listen_stop(lsock, &rtn->rds_tcp_accept_w);\n\tspin_lock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) {\n\t\tstruct net *c_net = read_pnet(&tc->t_cpath->cp_conn->c_net);\n\n\t\tif (net != c_net)\n\t\t\tcontinue;\n\t\tif (!list_has_conn(&tmp_list, tc->t_cpath->cp_conn)) {\n\t\t\tlist_move_tail(&tc->t_tcp_node, &tmp_list);\n\t\t} else {\n\t\t\tlist_del(&tc->t_tcp_node);\n\t\t\ttc->t_tcp_node_detached = true;\n\t\t}\n\t}\n\tspin_unlock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &tmp_list, t_tcp_node)\n\t\trds_conn_destroy(tc->t_cpath->cp_conn);\n}",
        "output": "0",
        "idx": 4309
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "}\n\nstatic inline bool f2fs_force_buffered_io(struct inode *inode,\n\t\t\t\tstruct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint rw = iov_iter_rw(iter);\n\n\tif (f2fs_post_read_required(inode))\n\t\treturn true;\n\tif (f2fs_is_multi_device(sbi))\n\t\treturn true;\n\tif (f2fs_sb_has_blkzoned(sbi))\n\t\treturn true;\n\tif (test_opt(sbi, LFS) && (rw == WRITE) &&\n\t\t\t\tblock_unaligned_IO(inode, iocb, iter))\n\t\treturn true;\n\tif (is_sbi_flag_set(F2FS_I_SB(inode), SBI_CP_DISABLED) &&\n\t\t\t\t\t!(inode->i_flags & S_SWAPFILE))\n\t\treturn true;\n",
        "output": "0",
        "idx": 4431
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jpg_dec_parseopts(char *optstr, jpg_dec_importopts_t *opts)\n{\n\tjas_tvparser_t *tvp;\n\n\topts->max_samples = 64 * JAS_MEBI;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\treturn -1;\n\t}\n\n\twhile (!jas_tvparser_next(tvp)) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_MAXSIZE:\n\t\t\topts->max_samples = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t  jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 7575
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void handle_PORT(ctrl_t *ctrl, char *str)\n{\n\tint a, b, c, d, e, f;\n\tchar addr[INET_ADDRSTRLEN];\n\tstruct sockaddr_in sin;\n\n\tif (ctrl->data_sd > 0) {\n\t\tuev_io_stop(&ctrl->data_watcher);\n\t\tclose(ctrl->data_sd);\n\t\tctrl->data_sd = -1;\n\t}\n\n\tsscanf(str, \"%d,%d,%d,%d,%d,%d\", &a, &b, &c, &d, &e, &f);\n\tsprintf(addr, \"%d.%d.%d.%d\", a, b, c, d);\n\n\tif (!inet_aton(addr, &(sin.sin_addr))) {\n\t\tERR(0, \"Invalid address '%s' given to PORT command\", addr);\n\t\tsend_msg(ctrl->sd, \"500 Illegal PORT command.\\r\\n\");\n\t\treturn;\n\t}\n\n\tstrlcpy(ctrl->data_address, addr, sizeof(ctrl->data_address));\n\tctrl->data_port = e * 256 + f;\n\n\tDBG(\"Client PORT command accepted for %s:%d\", ctrl->data_address, ctrl->data_port);\n\tsend_msg(ctrl->sd, \"200 PORT command successful.\\r\\n\");\n}",
        "output": "1",
        "idx": 8128
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void jp2_box_dump(jp2_box_t *box, FILE *out)\n{\n\tjp2_boxinfo_t *boxinfo;\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tassert(boxinfo);\n\n\tfprintf(out, \"JP2 box: \");\n\tfprintf(out, \"type=%c%s%c (0x%08\"PRIxFAST32\"); length=%\"PRIuFAST32\"\\n\", '\"',\n\t  boxinfo->name, '\"', box->type, box->len);\n\tif (box->ops->dumpdata) {\n\t\t(*box->ops->dumpdata)(box, out);\n\t}\n}",
        "output": "0",
        "idx": 7495
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "guestfs___first_line_of_file (guestfs_h *g, const char *filename)\n{\n  CLEANUP_FREE char **lines = NULL; \n  int64_t size;\n  char *ret;\n\n  size = guestfs_filesize (g, filename);\n  if (size == -1)\n    return NULL;\n  if (size > MAX_SMALL_FILE_SIZE) {\n    error (g, _(\"size of %s is unreasonably large (%\" PRIi64 \" bytes)\"),\n           filename, size);\n    return NULL;\n  }\n\n  lines = guestfs_head_n (g, 1, filename);\n  if (lines == NULL)\n    return NULL;\n  if (lines[0] == NULL) {\n    guestfs___free_string_list (lines);\n    return safe_strdup (g, \"\");\n  }\n\n  ret = lines[0];               \n\n  return ret;\n}",
        "output": "1",
        "idx": 3806
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECTED)\n\t\terr = sco_send_frame(sk, msg, len);\n\telse\n\t\terr = -ENOTCONN;\n\n\trelease_sock(sk);\n\treturn err;\n}",
        "output": "1",
        "idx": 1988
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ice_protocol_timeout (IceConn ice_conn)\n{\n        GsmIceConnectionWatch *data;\n\n        g_debug (\"GsmXsmpServer: ice_protocol_timeout for IceConn %p with status %d\",\n                 ice_conn, IceConnectionStatus (ice_conn));\n\n        data = ice_conn->context;\n\n        free_ice_connection_watch (data);\n        disconnect_ice_connection (ice_conn);\n\n        return FALSE;\n}",
        "output": "0",
        "idx": 8729
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ptrace_check_attach(struct task_struct *child, bool ignore_state)\n{\n\tint ret = -ESRCH;\n\n\tread_lock(&tasklist_lock);\n\tif (child->ptrace && child->parent == current) {\n\t\tWARN_ON(child->state == __TASK_TRACED);\n\t\tif (ignore_state || ptrace_freeze_traced(child))\n\t\t\tret = 0;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tif (!ret && !ignore_state) {\n\t\tif (!wait_task_inactive(child, __TASK_TRACED)) {\n\t\t\tWARN_ON(child->state == __TASK_TRACED);\n\t\t\tret = -ESRCH;\n\t\t}\n\t}\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 1133
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PredictorDecodeTile(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s)\n{\n\tTIFFPredictorState *sp = PredictorState(tif);\n\n\tassert(sp != NULL);\n\tassert(sp->decodetile != NULL);\n\n\tif ((*sp->decodetile)(tif, op0, occ0, s)) {\n\t\ttmsize_t rowsize = sp->rowsize;\n\t\tassert(rowsize > 0);\n\t\tif((occ0%rowsize) !=0)\n        {\n            TIFFErrorExt(tif->tif_clientdata, \"PredictorDecodeTile\",\n                         \"%s\", \"occ0%rowsize != 0\");\n            return 0;\n        }\n\t\tassert(sp->decodepfunc != NULL);\n\t\twhile (occ0 > 0) {\n\t\t\tif( !(*sp->decodepfunc)(tif, op0, rowsize) )\n                return 0;\n\t\t\tocc0 -= rowsize;\n\t\t\top0 += rowsize;\n\t\t}\n\t\treturn 1;\n\t} else\n\t\treturn 0;\n}",
        "output": "0",
        "idx": 5911
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iakerb_alloc_context(iakerb_ctx_id_t *pctx, int initiate)\n{\n    iakerb_ctx_id_t ctx;\n    krb5_error_code code;\n\n    *pctx = NULL;\n\n    ctx = k5alloc(sizeof(*ctx), &code);\n    if (ctx == NULL)\n        goto cleanup;\n    ctx->defcred = GSS_C_NO_CREDENTIAL;\n    ctx->magic = KG_IAKERB_CONTEXT;\n    ctx->state = IAKERB_AS_REQ;\n    ctx->count = 0;\n    ctx->initiate = initiate;\n    ctx->established = 0;\n\n    code = krb5_gss_init_context(&ctx->k5c);\n    if (code != 0)\n        goto cleanup;\n\n    *pctx = ctx;\n\ncleanup:\n    if (code != 0)\n        iakerb_release_context(ctx);\n\n    return code;\n}",
        "output": "0",
        "idx": 147
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xen_irq_lateeoi_locked(struct irq_info *info)\n{\n\tevtchn_port_t evtchn;\n\n\tevtchn = info->evtchn;\n\tif (!VALID_EVTCHN(evtchn))\n\t\treturn;\n\n\tunmask_evtchn(evtchn);\n}",
        "output": "1",
        "idx": 1894
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)\n{\n\tstruct serial_icounter_struct icount = {};\n\tstruct sb_uart_icount cnow;\n\tstruct sb_uart_port *port = state->port;\n\n\tspin_lock_irq(&port->lock);\n\tmemcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));\n\tspin_unlock_irq(&port->lock);\n\n\ticount.cts         = cnow.cts;\n\ticount.dsr         = cnow.dsr;\n\ticount.rng         = cnow.rng;\n\ticount.dcd         = cnow.dcd;\n\ticount.rx          = cnow.rx;\n\ticount.tx          = cnow.tx;\n\ticount.frame       = cnow.frame;\n\ticount.overrun     = cnow.overrun;\n\ticount.parity      = cnow.parity;\n\ticount.brk         = cnow.brk;\n\ticount.buf_overrun = cnow.buf_overrun;\n\n\treturn copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;\n}",
        "output": "0",
        "idx": 3353
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct vfsmount *clone_private_mount(const struct path *path)\n{\n\tstruct mount *old_mnt = real_mount(path->mnt);\n\tstruct mount *new_mnt;\n\n\tif (IS_MNT_UNBINDABLE(old_mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tnew_mnt = clone_mnt(old_mnt, path->dentry, CL_PRIVATE);\n\tif (IS_ERR(new_mnt))\n\t\treturn ERR_CAST(new_mnt);\n\n\tnew_mnt->mnt_ns = MNT_NS_INTERNAL;\n\n\treturn &new_mnt->mnt;\n}",
        "output": "1",
        "idx": 1972
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)\n{\n\tint m;\n\n\tassert(n >= 0 && n < 32);\n\tassert(!(v & (~JAS_ONES(n))));\n\n\tm = n - 1;\n\twhile (--n >= 0) {\n\t\tif (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {\n\t\t\treturn EOF;\n\t\t}\n\t\tv <<= 1;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 5362
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mark_commit(struct commit *c, void *data)\n{\n\tmark_object(&c->object, NULL, data);\n}",
        "output": "0",
        "idx": 7239
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_emul_capwrite(struct pci_vdev *dev, int offset, int bytes, uint32_t val)\n{\n\tint capid;\n\tuint8_t capoff, nextoff;\n\n\tif ((offset & (bytes - 1)) != 0)\n\t\treturn;\n\n\tcapoff = CAP_START_OFFSET;\n\twhile (1) {\n\t\tnextoff = pci_get_cfgdata8(dev, capoff + 1);\n\t\tif (nextoff == 0)\n\t\t\tbreak;\n\t\tif (offset >= capoff && offset < nextoff)\n\t\t\tbreak;\n\n\t\tcapoff = nextoff;\n\t}\n\tassert(offset >= capoff);\n\n\tif (offset == capoff || offset == capoff + 1) {\n\t\tif (offset == capoff && bytes == 4) {\n\t\t\tbytes = 2;\n\t\t\toffset += 2;\n\t\t\tval >>= 16;\n\t\t} else\n\t\t\treturn;\n\t}\n\n\tcapid = pci_get_cfgdata8(dev, capoff);\n\tswitch (capid) {\n\tcase PCIY_MSI:\n\t\tmsicap_cfgwrite(dev, capoff, offset, bytes, val);\n\t\tbreak;\n\tcase PCIY_MSIX:\n\t\tmsixcap_cfgwrite(dev, capoff, offset, bytes, val);\n\t\tbreak;\n\tcase PCIY_EXPRESS:\n\t\tpciecap_cfgwrite(dev, capoff, offset, bytes, val);\n\t\tbreak;\n\tdefault:\n\t\tCFGWRITE(dev, offset, val, bytes);\n\t\tbreak;\n\t}\n}",
        "output": "1",
        "idx": 7598
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "file_rlookup(const char *filename)\t\n{\n  int\t\ti;\t\t\t\n  cache_t\t*wc;\t\t\t\n\n\n  for (i = web_files, wc = web_cache; i > 0; i --, wc ++)\n    if (!strcmp(wc->name, filename))\n      return (wc->url);\n\n  return (filename);\n}",
        "output": "1",
        "idx": 8486
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void destroy_super(struct super_block *s)\n{\n\tint i;\n\tlist_lru_destroy(&s->s_dentry_lru);\n\tlist_lru_destroy(&s->s_inode_lru);\n#ifdef CONFIG_SMP\n\tfree_percpu(s->s_files);\n#endif\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n\t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n\tsecurity_sb_free(s);\n\tWARN_ON(!list_empty(&s->s_mounts));\n\tkfree(s->s_subtype);\n\tkfree(s->s_options);\n\tkfree_rcu(s, rcu);\n}",
        "output": "1",
        "idx": 2394
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BOOL nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowstride)\n{\n\tif (!context || !bmpdata || (rowstride == 0))\n\t\treturn FALSE;\n\n\tif (!nsc_encode_argb_to_aycocg(context, bmpdata, rowstride))\n\t\treturn FALSE;\n\n\tif (context->ChromaSubsamplingLevel)\n\t{\n\t\tif (!nsc_encode_subsampling(context))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
        "output": "0",
        "idx": 5831
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MagickPixelPacket **AcquirePixelThreadSet(const Image *image)\n{\n  MagickPixelPacket\n    **pixels;\n\n  register ssize_t\n    i,\n    j;\n\n  size_t\n    number_threads;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixels=(MagickPixelPacket **) AcquireQuantumMemory(number_threads,\n    sizeof(*pixels));\n  if (pixels == (MagickPixelPacket **) NULL)\n    return((MagickPixelPacket **) NULL);\n  (void) memset(pixels,0,number_threads*sizeof(*pixels));\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    pixels[i]=(MagickPixelPacket *) AcquireQuantumMemory(image->columns,\n      sizeof(**pixels));\n    if (pixels[i] == (MagickPixelPacket *) NULL)\n      return(DestroyPixelThreadSet(pixels));\n    for (j=0; j < (ssize_t) image->columns; j++)\n      GetMagickPixelPacket(image,&pixels[i][j]);\n  }\n  return(pixels);\n}",
        "output": "1",
        "idx": 7052
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int bpf_adj_delta_to_off(struct bpf_insn *insn, u32 pos, u32 delta,\n\t\t\t\tu32 curr, const bool probe_pass)\n{\n\tconst s32 off_min = S16_MIN, off_max = S16_MAX;\n\ts32 off = insn->off;\n\n\tif (curr < pos && curr + off + 1 > pos)\n\t\toff += delta;\n\telse if (curr > pos + delta && curr + off + 1 <= pos + delta)\n\t\toff -= delta;\n\tif (off < off_min || off > off_max)\n\t\treturn -ERANGE;\n\tif (!probe_pass)\n\t\tinsn->off = off;\n\treturn 0;\n}",
        "output": "0",
        "idx": 4085
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool snd_ctl_remove_numid_conflict(struct snd_card *card,\n\t\t\t\t\t  unsigned int count)\n{\n\tstruct snd_kcontrol *kctl;\n\n\tif (card->last_numid >= UINT_MAX - count)\n\t\tcard->last_numid = 0;\n\n\tlist_for_each_entry(kctl, &card->controls, list) {\n\t\tif (kctl->id.numid < card->last_numid + 1 + count &&\n\t\t    kctl->id.numid + kctl->count > card->last_numid + 1) {\n\t\t    \tcard->last_numid = kctl->id.numid + kctl->count - 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
        "output": "0",
        "idx": 3593
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)\n{\n\tstruct perf_sample_data data;\n\tint rctx;\n\n\tpreempt_disable_notrace();\n\trctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn;\n\n\tperf_sample_data_init(&data, addr);\n\n\tdo_perf_sw_event(PERF_TYPE_SOFTWARE, event_id, nr, &data, regs);\n\n\tperf_swevent_put_recursion_context(rctx);\n\tpreempt_enable_notrace();\n}",
        "output": "0",
        "idx": 675
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nv_gotofile(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    linenr_T\tlnum = -1;\n\n    if (check_text_locked(cap->oap))\n\treturn;\n    if (curbuf_locked())\n    {\n\tclearop(cap->oap);\n\treturn;\n    }\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n\n    ptr = grab_file_name(cap->count1, &lnum);\n\n    if (ptr != NULL)\n    {\n\tif (curbufIsChanged() && curbuf->b_nwindows <= 1 && !buf_hide(curbuf))\n\t    (void)autowrite(curbuf, FALSE);\n\tsetpcmark();\n\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LAST,\n\t\t\t\tbuf_hide(curbuf) ? ECMD_HIDE : 0, curwin) == OK\n\t\t&& cap->nchar == 'F' && lnum >= 0)\n\t{\n\t    curwin->w_cursor.lnum = lnum;\n\t    check_cursor_lnum();\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n\tvim_free(ptr);\n    }\n    else\n\tclearop(cap->oap);\n}",
        "output": "0",
        "idx": 8043
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_exif_tag_dbl_value(struct iw_exif_state *e, unsigned int tag_pos,\n\tdouble *pv)\n{\n\tunsigned int field_type;\n\tunsigned int value_count;\n\tunsigned int value_pos;\n\tunsigned int numer, denom;\n\n\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n\n\tif(value_count!=1) return 0;\n\n\tif(field_type!=5) return 0; \n\n\n\tvalue_pos = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n\tif(value_pos > e->d_len-8) return 0;\n\n\tnumer = iw_get_ui32_e(&e->d[value_pos  ],e->endian);\n\tdenom = iw_get_ui32_e(&e->d[value_pos+4],e->endian);\n\tif(denom==0) return 0;\n\n\t*pv = ((double)numer)/denom;\n\treturn 1;\n}",
        "output": "1",
        "idx": 6660
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)\n{\n\tstruct mnt_namespace *new_ns;\n\tstruct ucounts *ucounts;\n\tint ret;\n\n\tucounts = inc_mnt_namespaces(user_ns);\n\tif (!ucounts)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tnew_ns = kmalloc(sizeof(struct mnt_namespace), GFP_KERNEL);\n\tif (!new_ns) {\n\t\tdec_mnt_namespaces(ucounts);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tret = ns_alloc_inum(&new_ns->ns);\n\tif (ret) {\n\t\tkfree(new_ns);\n\t\tdec_mnt_namespaces(ucounts);\n\t\treturn ERR_PTR(ret);\n\t}\n\tnew_ns->ns.ops = &mntns_operations;\n\tnew_ns->seq = atomic64_add_return(1, &mnt_ns_seq);\n\tatomic_set(&new_ns->count, 1);\n\tnew_ns->root = NULL;\n\tINIT_LIST_HEAD(&new_ns->list);\n\tinit_waitqueue_head(&new_ns->poll);\n\tnew_ns->event = 0;\n\tnew_ns->user_ns = get_user_ns(user_ns);\n\tnew_ns->ucounts = ucounts;\n\tnew_ns->mounts = 0;\n\tnew_ns->pending_mounts = 0;\n\treturn new_ns;\n}",
        "output": "0",
        "idx": 1973
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n{\n\tunsigned char *vec = walk->private;\n\tunsigned long nr = (end - addr) >> PAGE_SHIFT;\n\n\tmemset(vec, 0, nr);\n\twalk->private += nr;\n\treturn 0;\n}",
        "output": "0",
        "idx": 4229
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "test_function (char * (*my_asnprintf) (char *, size_t *, const char *, ...))\n{\n  char buf[8];\n  int size;\n\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length = size;\n      char *result = my_asnprintf (NULL, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      free (result);\n    }\n\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length;\n      char *result;\n\n      memcpy (buf, \"DEADBEEF\", 8);\n      length = size;\n      result = my_asnprintf (buf, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      if (size < 6)\n        ASSERT (result != buf);\n      ASSERT (memcmp (buf + size, &\"DEADBEEF\"[size], 8 - size) == 0);\n      if (result != buf)\n        free (result);\n    }\n}",
        "output": "1",
        "idx": 7072
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "delete_buff_tail(buffheader_T *buf, int slen)\n{\n    int len;\n\n    if (buf->bh_curr == NULL || buf->bh_curr->b_str == NULL)\n\treturn;  \n    len = (int)STRLEN(buf->bh_curr->b_str);\n    if (len >= slen)\n    {\n\tbuf->bh_curr->b_str[len - slen] = NUL;\n\tbuf->bh_space += slen;\n    }\n}",
        "output": "0",
        "idx": 7975
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Jsi_RC NumberToFixedCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    Jsi_Value *pa = Jsi_ValueArrayIndex(interp, args, skip);\n    if (pa && Jsi_GetIntFromValue(interp, pa, &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<0) prec = 0;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf), \"%.*\" JSI_NUMFFMT, prec, num);\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}",
        "output": "1",
        "idx": 8202
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void gdCtxPrintf(gdIOCtx * out, const char *format, ...)\n{\n\tchar buf[4096];\n\tint len;\n\tva_list args;\n\n\tva_start(args, format);\n\tlen = vsnprintf(buf, sizeof(buf)-1, format, args);\n\tva_end(args);\n\tout->putBuf(out, buf, len);\n}",
        "output": "1",
        "idx": 4472
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Box *mp4s_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_MP4S);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}",
        "output": "1",
        "idx": 6844
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __verify_planes_array_core(struct vb2_buffer *vb, const void *pb)\n{\n\treturn __verify_planes_array(vb, pb);\n}",
        "output": "0",
        "idx": 1787
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE cState_array_nl_set(VALUE self, VALUE array_nl)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(array_nl, T_STRING);\n    len = RSTRING_LEN(array_nl);\n    if (len == 0) {\n        if (state->array_nl) {\n            ruby_xfree(state->array_nl);\n            state->array_nl = NULL;\n        }\n    } else {\n        if (state->array_nl) ruby_xfree(state->array_nl);\n        state->array_nl = strdup(RSTRING_PTR(array_nl));\n        state->array_nl_len = len;\n    }\n    return Qnil;\n}",
        "output": "1",
        "idx": 6272
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parserep(netdissect_options *ndo,\n         register const struct sunrpc_msg *rp, register u_int length)\n{\n\tregister const uint32_t *dp;\n\tu_int len;\n\tenum sunrpc_accept_stat astat;\n\n\tdp = ((const uint32_t *)&rp->rm_reply) + 1;\n\tND_TCHECK(dp[1]);\n\tlen = EXTRACT_32BITS(&dp[1]);\n\tif (len >= length)\n\t\treturn (NULL);\n\tdp += (len + (2*sizeof(uint32_t) + 3)) / sizeof(uint32_t);\n\tND_TCHECK2(dp[0], 0);\n\n\tastat = (enum sunrpc_accept_stat) EXTRACT_32BITS(dp);\n\tif (astat != SUNRPC_SUCCESS) {\n\t\tND_PRINT((ndo, \" %s\", tok2str(sunrpc_str, \"ar_stat %d\", astat)));\n\t\tnfserr = 1;\t\t\n\t\treturn (NULL);\n\t}\n\tND_TCHECK2(*dp, sizeof(astat));\n\treturn ((const uint32_t *) (sizeof(astat) + ((const char *)dp)));\ntrunc:\n\treturn (0);\n}",
        "output": "1",
        "idx": 4702
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)\n{\n  struct Context *ctx = (struct Context *) data;\n  if (!ctx)\n    return -1;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  if (!pop_data)\n    return -1;\n\n#ifdef USE_HCACHE\n  if (strcmp(HC_FNAME \".\" HC_FEXT, id) == 0)\n    return 0;\n#endif\n\n  for (int i = 0; i < ctx->msgcount; i++)\n  {\n    if (ctx->hdrs[i]->data && (mutt_str_strcmp(ctx->hdrs[i]->data, id) == 0))\n      return 0;\n  }\n\n  return mutt_bcache_del(bcache, id);\n}",
        "output": "1",
        "idx": 6970
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_lintr_deassert(struct pci_vdev *dev)\n{\n\tassert(dev->lintr.pin > 0);\n\n\tpthread_mutex_lock(&dev->lintr.lock);\n\tif (dev->lintr.state == ASSERTED) {\n\t\tdev->lintr.state = IDLE;\n\t\tpci_irq_deassert(dev);\n\t} else if (dev->lintr.state == PENDING)\n\t\tdev->lintr.state = IDLE;\n\tpthread_mutex_unlock(&dev->lintr.lock);\n}",
        "output": "1",
        "idx": 7590
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int tipc_nl_compat_link_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t    struct nlattr **attrs)\n{\n\tstruct nlattr *link[TIPC_NLA_LINK_MAX + 1];\n\tstruct tipc_link_info link_info;\n\tint err;\n\n\tif (!attrs[TIPC_NLA_LINK])\n\t\treturn -EINVAL;\n\n\terr = nla_parse_nested(link, TIPC_NLA_LINK_MAX, attrs[TIPC_NLA_LINK],\n\t\t\t       NULL);\n\tif (err)\n\t\treturn err;\n\n\tlink_info.dest = nla_get_flag(link[TIPC_NLA_LINK_DEST]);\n\tlink_info.up = htonl(nla_get_flag(link[TIPC_NLA_LINK_UP]));\n\tnla_strlcpy(link_info.str, nla_data(link[TIPC_NLA_LINK_NAME]),\n\t\t    TIPC_MAX_LINK_NAME);\n\n\treturn tipc_add_tlv(msg->rep, TIPC_TLV_LINK_INFO,\n\t\t\t    &link_info, sizeof(link_info));\n}",
        "output": "0",
        "idx": 1887
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Ta3Grammar_FindDFA(grammar *g, int type)\n{\n    dfa *d;\n#if 1\n    d = &g->g_dfa[type - NT_OFFSET];\n    assert(d->d_type == type);\n    return d;\n#else\n    int i;\n\n    for (i = g->g_ndfas, d = g->g_dfa; --i >= 0; d++) {\n        if (d->d_type == type)\n            return d;\n    }\n    assert(0);\n#endif\n}",
        "output": "1",
        "idx": 7658
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ecma_op_internal_buffer_append (ecma_collection_t *container_p, \n                                ecma_value_t key_arg, \n                                ecma_value_t value_arg, \n                                lit_magic_string_id_t lit_id) \n{\n  JERRY_ASSERT (container_p != NULL);\n\n  ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));\n\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (value_arg));\n  }\n\n  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1);\n} ",
        "output": "1",
        "idx": 6678
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *mongo_data_append( char *start , const void *data , int len ) {\n    memcpy( start , data , len );\n    return start + len;\n}",
        "output": "1",
        "idx": 7924
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct perf_event *event = file->private_data;\n\tstruct perf_event_context *ctx;\n\tlong ret;\n\n\tctx = perf_event_ctx_lock(event);\n\tret = _perf_ioctl(event, cmd, arg);\n\tperf_event_ctx_unlock(event, ctx);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 3847
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vmacache_flush_all(struct mm_struct *mm)\n{\n\tstruct task_struct *g, *p;\n\n\tcount_vm_vmacache_event(VMACACHE_FULL_FLUSHES);\n\n\tif (atomic_read(&mm->mm_users) == 1)\n\t\treturn;\n\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (mm == p->mm)\n\t\t\tvmacache_flush(p);\n\t}\n\trcu_read_unlock();\n}",
        "output": "1",
        "idx": 3014
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_be_3byte (SF_PRIVATE *psf, int x)\n{\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n\tpsf->header.ptr [psf->header.indx++] = x ;\n} ",
        "output": "0",
        "idx": 6907
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int input_set_keycode(struct input_dev *dev,\n\t\t      const struct input_keymap_entry *ke)\n{\n\tunsigned long flags;\n\tunsigned int old_keycode;\n\tint retval;\n\n\tif (ke->keycode > KEY_MAX)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\n\tretval = dev->setkeycode(dev, ke, &old_keycode);\n\tif (retval)\n\t\tgoto out;\n\n\t__clear_bit(KEY_RESERVED, dev->keybit);\n\n\tif (test_bit(EV_KEY, dev->evbit) &&\n\t    !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&\n\t    __test_and_clear_bit(old_keycode, dev->key)) {\n\t\tstruct input_value vals[] =  {\n\t\t\t{ EV_KEY, old_keycode, 0 },\n\t\t\tinput_value_sync\n\t\t};\n\n\t\tinput_pass_values(dev, vals, ARRAY_SIZE(vals));\n\t}\n\n out:\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\n\treturn retval;\n}",
        "output": "1",
        "idx": 3314
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *zap = NULL;\n\tint ret;\n\n\tret = key_payload_reserve(key, prep->datalen);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tkey->expiry = prep->expiry;\n\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\tzap = dereference_key_locked(key);\n\trcu_assign_keypointer(key, prep->payload.data[0]);\n\tprep->payload.data[0] = NULL;\n\n\tif (zap)\n\t\tcall_rcu(&zap->rcu, user_free_payload_rcu);\n\treturn ret;\n}",
        "output": "1",
        "idx": 1744
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool sctp_chunk_pending(const struct sctp_chunk *chunk)\n{\n\treturn !list_empty(&chunk->list);\n}",
        "output": "0",
        "idx": 3709
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_rng rrng;\n\n\tstrncpy(rrng.type, \"rng\", sizeof(rrng.type));\n\n\trrng.seedsize = alg->cra_rng.seedsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_RNG,\n\t\t    sizeof(struct crypto_report_rng), &rrng))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "0",
        "idx": 1189
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool has_locked_children(struct mount *mnt, struct dentry *dentry)\n{\n\tstruct mount *child;\n\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\tif (!is_subdir(child->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\n\t\tif (child->mnt.mnt_flags & MNT_LOCKED)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
        "output": "1",
        "idx": 1974
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int i8042_start(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\n\tport->exists = true;\n\tmb();\n\treturn 0;\n}",
        "output": "1",
        "idx": 1636
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce)\n{\n\tlong elements;\n\n\tif( *p >= max - 2) {\n\t\tzend_error(E_WARNING, \"Bad unserialize data\");\n\t\treturn -1;\n\t}\n\n\telements = parse_iv2((*p) + 2, p);\n\n\t(*p) += 2;\n\n\tif (ce->serialize == NULL) {\n\t\tobject_init_ex(*rval, ce);\n\t} else {\n\t\tzend_error(E_WARNING, \"Erroneous data format for unserializing '%s'\", ce->name);\n\t\treturn -1;\n\t}\n\n\treturn elements;\n}",
        "output": "0",
        "idx": 5659
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct bpf_map *bpf_map_get_with_uref(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_map *map;\n\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn map;\n\n\tbpf_map_inc(map, true);\n\tfdput(f);\n\n\treturn map;\n}",
        "output": "1",
        "idx": 1246
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean has_internal_nul(const char* str, int len) {\n\twhile (len > 0 && str[len-1] == 0)\n\t\tlen--;\n\treturn strlen(str) != len;\n}",
        "output": "0",
        "idx": 4665
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int DefragMfIpv6Test(void)\n{\n    int retval = 0;\n    int ip_id = 9;\n    Packet *p = NULL;\n\n    DefragInit();\n\n    Packet *p1 = IPV6BuildTestPacket(ip_id, 2, 1, 'C', 8);\n    Packet *p2 = IPV6BuildTestPacket(ip_id, 0, 1, 'A', 8);\n    Packet *p3 = IPV6BuildTestPacket(ip_id, 1, 0, 'B', 8);\n    if (p1 == NULL || p2 == NULL || p3 == NULL) {\n        goto end;\n    }\n\n    p = Defrag(NULL, NULL, p1, NULL);\n    if (p != NULL) {\n        goto end;\n    }\n\n    p = Defrag(NULL, NULL, p2, NULL);\n    if (p != NULL) {\n        goto end;\n    }\n\n    p = Defrag(NULL, NULL, p3, NULL);\n    if (p == NULL) {\n        goto end;\n    }\n\n    if (IPV6_GET_PLEN(p) != 16) {\n        goto end;\n    }\n\n    retval = 1;\nend:\n    if (p1 != NULL) {\n        SCFree(p1);\n    }\n    if (p2 != NULL) {\n        SCFree(p2);\n    }\n    if (p3 != NULL) {\n        SCFree(p3);\n    }\n    if (p != NULL) {\n        SCFree(p);\n    }\n    DefragDestroy();\n    return retval;\n}",
        "output": "1",
        "idx": 6590
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC int espLoadApp(HttpRoute *route)\n{\n#if !ME_STATIC\n    EspRoute    *eroute;\n    eroute = route->eroute;\n    if (!eroute->skipApps) {\n        MprJson     *preload, *item;\n        cchar       *errMsg, *source;\n        char        *kind;\n        int         i;\n\n        if (!loadApp(route, NULL)) {\n            return MPR_ERR_CANT_LOAD;\n        }\n        if (!route->combine && (preload = mprGetJsonObj(route->config, \"esp.preload\")) != 0) {\n            for (ITERATE_JSON(preload, item, i)) {\n                source = stok(sclone(item->value), \":\", &kind);\n                if (!kind) kind = \"controller\";\n                source = mprJoinPath(httpGetDir(route, \"controllers\"), source);\n                if (espLoadModule(route, NULL, kind, source, &errMsg) < 0) {\n                    mprLog(\"error esp\", 0, \"Cannot preload esp module %s. %s\", source, errMsg);\n                    return MPR_ERR_CANT_LOAD;\n                }\n            }\n        }\n    }\n#endif\n    return 0;\n}",
        "output": "1",
        "idx": 5002
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ensure_cloned_binary(void)\n{\n\tint execfd;\n\tchar **argv = NULL, **envp = NULL;\n\n\tint cloned = is_self_cloned();\n\tif (cloned > 0 || cloned == -ENOTRECOVERABLE)\n\t\treturn cloned;\n\n\tif (fetchve(&argv, &envp) < 0)\n\t\treturn -EINVAL;\n\n\texecfd = clone_binary();\n\tif (execfd < 0)\n\t\treturn -EIO;\n\n\tfexecve(execfd, argv, envp);\n\treturn -ENOEXEC;\n}",
        "output": "0",
        "idx": 8201
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct btrfs_device *btrfs_find_device_by_path(\n\t\tstruct btrfs_fs_info *fs_info, const char *device_path)\n{\n\tint ret = 0;\n\tstruct btrfs_super_block *disk_super;\n\tu64 devid;\n\tu8 *dev_uuid;\n\tstruct block_device *bdev;\n\tstruct buffer_head *bh;\n\tstruct btrfs_device *device;\n\n\tret = btrfs_get_bdev_and_sb(device_path, FMODE_READ,\n\t\t\t\t    fs_info->bdev_holder, 0, &bdev, &bh);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\tdev_uuid = disk_super->dev_item.uuid;\n\tif (btrfs_fs_incompat(fs_info, METADATA_UUID))\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,\n\t\t\t\t\t   disk_super->metadata_uuid, true);\n\telse\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,\n\t\t\t\t\t   disk_super->fsid, true);\n\n\tbrelse(bh);\n\tif (!device)\n\t\tdevice = ERR_PTR(-ENOENT);\n\tblkdev_put(bdev, FMODE_READ);\n\treturn device;\n}",
        "output": "0",
        "idx": 4265
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)\n{\n\n\tif (timr->it.mmtimer.clock == TIMER_OFF) {\n\t\tcur_setting->it_interval.tv_nsec = 0;\n\t\tcur_setting->it_interval.tv_sec = 0;\n\t\tcur_setting->it_value.tv_nsec = 0;\n\t\tcur_setting->it_value.tv_sec =0;\n\t\treturn;\n\t}\n\n\tcur_setting->it_interval = ns_to_timespec(timr->it.mmtimer.incr * sgi_clock_period);\n\tcur_setting->it_value = ns_to_timespec((timr->it.mmtimer.expires - rtc_time()) * sgi_clock_period);\n}",
        "output": "0",
        "idx": 3005
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n{\n    long i;\n    for (i = 0; i <= w - (int)sizeof(long); i += sizeof(long)) {\n        long a = *(long *)(src1 + i);\n        long b = *(long *)(src2 + i);\n        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n    }\n    for (; i < w; i++)\n        dst[i] = src1[i] + src2[i];\n}",
        "output": "0",
        "idx": 4967
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void blendMode(HttpRoute *route, MprJson *config)\n{\n    MprJson     *currentMode, *app;\n    cchar       *mode;\n\n    mode = mprGetJson(config, \"app.mode\");\n    if (!mode) {\n        mode = sclone(\"debug\");\n    }\n    route->debug = smatch(mode, \"debug\");\n    if ((currentMode = mprGetJsonObj(config, sfmt(\"app.modes.%s\", mode))) != 0) {\n        app = mprLookupJsonObj(config, \"app\");\n        mprBlendJson(app, currentMode, MPR_JSON_OVERWRITE);\n        mprSetJson(app, \"app.mode\", mode);\n    }\n}",
        "output": "1",
        "idx": 5076
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __exit pcd_exit(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (!cd->disk)\n\t\t\tcontinue;\n\n\t\tif (cd->present) {\n\t\t\tdel_gendisk(cd->disk);\n\t\t\tpi_release(cd->pi);\n\t\t\tunregister_cdrom(&cd->info);\n\t\t}\n\t\tblk_cleanup_queue(cd->disk->queue);\n\t\tblk_mq_free_tag_set(&cd->tag_set);\n\t\tput_disk(cd->disk);\n\t}\n\tunregister_blkdev(major, name);\n\tpi_unregister_driver(par_drv);\n}",
        "output": "0",
        "idx": 4325
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mod_ty PyAST_obj2mod(PyObject* ast, PyArena* arena, int mode)\n{\n    mod_ty res;\n    PyObject *req_type[3];\n    char *req_name[] = {\"Module\", \"Expression\", \"Interactive\"};\n    int isinstance;\n\n    req_type[0] = (PyObject*)Module_type;\n    req_type[1] = (PyObject*)Expression_type;\n    req_type[2] = (PyObject*)Interactive_type;\n\n    assert(0 <= mode && mode <= 2);\n\n    if (!init_types())\n        return NULL;\n\n    isinstance = PyObject_IsInstance(ast, req_type[mode]);\n    if (isinstance == -1)\n        return NULL;\n    if (!isinstance) {\n        PyErr_Format(PyExc_TypeError, \"expected %s node, got %.400s\",\n                     req_name[mode], Py_TYPE(ast)->tp_name);\n        return NULL;\n    }\n    if (obj2ast_mod(ast, &res, arena) != 0)\n        return NULL;\n    else\n        return res;\n}",
        "output": "1",
        "idx": 7172
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hb_set_clear (hb_set_t *set)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n\n  set->clear ();\n}",
        "output": "1",
        "idx": 5554
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "swabHorDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n    uint32* wp = (uint32*) cp0;\n    tmsize_t wc = cc / 4;\n\n    horDiff32(tif, cp0, cc);\n\n    TIFFSwabArrayOfLong(wp, wc);\n}",
        "output": "1",
        "idx": 4284
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *seq_buf_alloc(unsigned long size)\n{\n\tif (unlikely(size > MAX_RW_COUNT))\n\t\treturn NULL;\n\n\treturn kvmalloc(size, GFP_KERNEL_ACCOUNT);\n}",
        "output": "0",
        "idx": 2827
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int can_open_cached(struct nfs4_state *state, fmode_t mode, int open_mode)\n{\n\tint ret = 0;\n\n\tif (open_mode & O_EXCL)\n\t\tgoto out;\n\tswitch (mode & (FMODE_READ|FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tret |= test_bit(NFS_O_RDONLY_STATE, &state->flags) != 0;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_WRONLY_STATE, &state->flags) != 0;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_RDWR_STATE, &state->flags) != 0;\n\t}\nout:\n\treturn ret;\n}",
        "output": "0",
        "idx": 3071
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ECDSA_verify(int type, const unsigned char *dgst, int dgst_len,\n\t\tconst unsigned char *sigbuf, int sig_len, EC_KEY *eckey)\n \t{\n\tECDSA_SIG *s;\n\tint ret=-1;\n\n\ts = ECDSA_SIG_new();\n\tif (s == NULL) return(ret);\n\tif (d2i_ECDSA_SIG(&s, &sigbuf, sig_len) == NULL) goto err;\n\tret=ECDSA_do_verify(dgst, dgst_len, s, eckey);\nerr:\n\tECDSA_SIG_free(s);\n\treturn(ret);\n\t}",
        "output": "1",
        "idx": 4532
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "flatpak_proxy_client_init (FlatpakProxyClient *client)\n{\n  init_side (client, &client->client_side);\n  init_side (client, &client->bus_side);\n\n  client->auth_end_offset = AUTH_END_INIT_OFFSET;\n  client->rewrite_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);\n  client->get_owner_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_free);\n  client->unique_id_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n}",
        "output": "1",
        "idx": 7290
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ParseNameValue(const char * buffer, int bufsize,\n               struct NameValueParserData * data)\n{\n\tstruct xmlparser parser;\n\tmemset(data, 0, sizeof(struct NameValueParserData));\n\tparser.xmlstart = buffer;\n\tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}",
        "output": "0",
        "idx": 6405
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ip6_mroute_getsockopt(struct sock *sk, int optname, char __user *optval,\n\t\t\t  int __user *optlen)\n{\n\tint olr;\n\tint val;\n\tstruct net *net = sock_net(sk);\n\tstruct mr6_table *mrt;\n\n\tif (sk->sk_type != SOCK_RAW ||\n\t    inet_sk(sk)->inet_num != IPPROTO_ICMPV6)\n\t\treturn -EOPNOTSUPP;\n\n\tmrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn -ENOENT;\n\n\tswitch (optname) {\n\tcase MRT6_VERSION:\n\t\tval = 0x0305;\n\t\tbreak;\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tcase MRT6_PIM:\n\t\tval = mrt->mroute_do_pim;\n\t\tbreak;\n#endif\n\tcase MRT6_ASSERT:\n\t\tval = mrt->mroute_do_assert;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (get_user(olr, optlen))\n\t\treturn -EFAULT;\n\n\tolr = min_t(int, olr, sizeof(int));\n\tif (olr < 0)\n\t\treturn -EINVAL;\n\n\tif (put_user(olr, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, olr))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
        "output": "0",
        "idx": 2175
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void print_value(int output, int num, const char *devname,\n\t\t\tconst char *value, const char *name, size_t valsz)\n{\n\tif (output & OUTPUT_VALUE_ONLY) {\n\t\tfputs(value, stdout);\n\t\tfputc('\\n', stdout);\n\n\t} else if (output & OUTPUT_UDEV_LIST) {\n\t\tprint_udev_format(name, value);\n\n\t} else if (output & OUTPUT_EXPORT_LIST) {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"DEVNAME=%s\\n\", devname);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\", stdout);\n\t\tsafe_print(value, valsz, NULL);\n\t\tfputs(\"\\n\", stdout);\n\n\t} else {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"%s:\", devname);\n\t\tfputs(\" \", stdout);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\\\"\", stdout);\n\t\tsafe_print(value, valsz, \"\\\"\");\n\t\tfputs(\"\\\"\", stdout);\n\t}\n}",
        "output": "1",
        "idx": 4644
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "test_read_integer_error (xd3_stream *stream, usize_t trunto, const char *msg)\n{\n  uint64_t eval = 1ULL << 34;\n  uint32_t rval;\n  xd3_output *buf = NULL;\n  const uint8_t *max;\n  const uint8_t *inp;\n  int ret;\n\n  buf = xd3_alloc_output (stream, buf);\n\n  if ((ret = xd3_emit_uint64_t (stream, & buf, eval)))\n    {\n      goto fail;\n    }\n\n again:\n\n  inp = buf->base;\n  max = buf->base + buf->next - trunto;\n\n  if ((ret = xd3_read_uint32_t (stream, & inp, max, & rval)) !=\n      XD3_INVALID_INPUT ||\n      !MSG_IS (msg))\n    {\n      ret = XD3_INTERNAL;\n    }\n  else if (trunto && trunto < buf->next)\n    {\n      trunto += 1;\n      goto again;\n    }\n  else\n    {\n      ret = 0;\n    }\n\n fail:\n  xd3_free_output (stream, buf);\n  return ret;\n}",
        "output": "0",
        "idx": 7113
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static RList *r_bin_wasm_get_data_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\n\tRList *ret = NULL;\n\tRBinWasmDataEntry *ptr = NULL;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\tsize_t n = 0;\n\n\twhile (i < len && r < count) {\n\n\t\tif (!(ptr = R_NEW0 (RBinWasmDataEntry))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(n = consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tptr->offset.len = n;\n\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->size, &i))) {\t\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tptr->data = sec->payload_data + i;\n\n\t\tr_list_append (ret, ptr);\n\n\t\tr += 1;\n\n\t}\n\n\treturn ret;\n}",
        "output": "1",
        "idx": 6138
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Huff_offsetReceive (node_t *node, int *ch, byte *fin, int *offset) {\n\tbloc = *offset;\n\twhile (node && node->symbol == INTERNAL_NODE) {\n\t\tif (get_bit(fin)) {\n\t\t\tnode = node->right;\n\t\t} else {\n\t\t\tnode = node->left;\n\t\t}\n\t}\n\tif (!node) {\n\t\t*ch = 0;\n\t\treturn;\n\t}\n\t*ch = node->symbol;\n\t*offset = bloc;\n}",
        "output": "1",
        "idx": 6234
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void perf_pmu_migrate_context(struct pmu *pmu, int src_cpu, int dst_cpu)\n{\n\tstruct perf_event_context *src_ctx;\n\tstruct perf_event_context *dst_ctx;\n\tstruct perf_event *event, *tmp;\n\tLIST_HEAD(events);\n\n\tsrc_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, src_cpu)->ctx;\n\tdst_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, dst_cpu)->ctx;\n\n\tmutex_lock(&src_ctx->mutex);\n\tlist_for_each_entry_safe(event, tmp, &src_ctx->event_list,\n\t\t\t\t event_entry) {\n\t\tperf_remove_from_context(event, false);\n\t\tunaccount_event_cpu(event, src_cpu);\n\t\tput_ctx(src_ctx);\n\t\tlist_add(&event->migrate_entry, &events);\n\t}\n\tmutex_unlock(&src_ctx->mutex);\n\n\tsynchronize_rcu();\n\n\tmutex_lock(&dst_ctx->mutex);\n\tlist_for_each_entry_safe(event, tmp, &events, migrate_entry) {\n\t\tlist_del(&event->migrate_entry);\n\t\tif (event->state >= PERF_EVENT_STATE_OFF)\n\t\t\tevent->state = PERF_EVENT_STATE_INACTIVE;\n\t\taccount_event_cpu(event, dst_cpu);\n\t\tperf_install_in_context(dst_ctx, event, dst_cpu);\n\t\tget_ctx(dst_ctx);\n\t}\n\tmutex_unlock(&dst_ctx->mutex);\n}",
        "output": "1",
        "idx": 2782
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid)\n{\n\tint frameSize = afGetVirtualFrameSize(infile, trackid, 1);\n\n\tconst int kBufferFrameCount = 65536;\n\tvoid *buffer = malloc(kBufferFrameCount * frameSize);\n\n\tAFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);\n\tAFframecount totalFramesWritten = 0;\n\n\tbool success = true;\n\n\twhile (totalFramesWritten < totalFrames)\n\t{\n\t\tAFframecount framesToRead = totalFrames - totalFramesWritten;\n\t\tif (framesToRead > kBufferFrameCount)\n\t\t\tframesToRead = kBufferFrameCount;\n\n\t\tAFframecount framesRead = afReadFrames(infile, trackid, buffer,\n\t\t\tframesToRead);\n\n\t\tif (framesRead < framesToRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad read of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tAFframecount framesWritten = afWriteFrames(outfile, trackid, buffer,\n\t\t\tframesRead);\n\n\t\tif (framesWritten < framesRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad write of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\n\t\ttotalFramesWritten += framesWritten;\n\t}\n\n\tfree(buffer);\n\n\treturn success;\n}",
        "output": "1",
        "idx": 6564
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int adjust_insn_aux_data(struct bpf_verifier_env *env, u32 prog_len,\n\t\t\t\tu32 off, u32 cnt)\n{\n\tstruct bpf_insn_aux_data *new_data, *old_data = env->insn_aux_data;\n\tint i;\n\n\tif (cnt == 1)\n\t\treturn 0;\n\tnew_data = vzalloc(sizeof(struct bpf_insn_aux_data) * prog_len);\n\tif (!new_data)\n\t\treturn -ENOMEM;\n\tmemcpy(new_data, old_data, sizeof(struct bpf_insn_aux_data) * off);\n\tmemcpy(new_data + off + cnt - 1, old_data + off,\n\t       sizeof(struct bpf_insn_aux_data) * (prog_len - off - cnt + 1));\n\tfor (i = off; i < off + cnt - 1; i++)\n\t\tnew_data[i].seen = true;\n\tenv->insn_aux_data = new_data;\n\tvfree(old_data);\n\treturn 0;\n}",
        "output": "0",
        "idx": 2565
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int TfLiteIntArrayGetSizeInBytes(int size) {\n  static TfLiteIntArray dummy;\n\n  int computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size;\n#if defined(_MSC_VER)\n  computed_size -= sizeof(dummy.data[0]);\n#endif\n  return computed_size;\n}",
        "output": "1",
        "idx": 7240
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int needs_empty_write(sector_t block, struct inode *inode)\n{\n\tint error;\n\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\n\tbh_map.b_size = 1 << inode->i_blkbits;\n\terror = gfs2_block_map(inode, block, &bh_map, 0);\n\tif (unlikely(error))\n\t\treturn error;\n\treturn !buffer_mapped(&bh_map);\n}",
        "output": "1",
        "idx": 636
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jpc_ppm_putparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *out)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\n\tcstate = 0;\n\n\tif (JAS_CAST(jas_uint, jas_stream_write(out, (char *) ppm->data, ppm->len)) != ppm->len) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 7565
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __inline__ int scm_check_creds(struct ucred *creds)\n{\n\tconst struct cred *cred = current_cred();\n\tkuid_t uid = make_kuid(cred->user_ns, creds->uid);\n\tkgid_t gid = make_kgid(cred->user_ns, creds->gid);\n\n\tif (!uid_valid(uid) || !gid_valid(gid))\n\t\treturn -EINVAL;\n\n\tif ((creds->pid == task_tgid_vnr(current) || nsown_capable(CAP_SYS_ADMIN)) &&\n\t    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||\n\t      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&\n\t    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||\n\t      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {\n\t       return 0;\n\t}\n\treturn -EPERM;\n}",
        "output": "1",
        "idx": 880
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline __must_check bool try_get_page(struct page *page)\n{\n\tpage = compound_head(page);\n\tif (WARN_ON_ONCE(page_ref_count(page) <= 0))\n\t\treturn false;\n\tpage_ref_inc(page);\n\treturn true;\n}",
        "output": "0",
        "idx": 4335
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hns_gmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)\n\t\treturn ARRAY_SIZE(g_gmac_stats_string);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2265
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mongo_env_write_socket( mongo *conn, const void *buf, int len ) {\n    const char *cbuf = buf;\n    int flags = 0;\n\n    while ( len ) {\n        int sent = send( conn->sock, cbuf, len, flags );\n        if ( sent == -1 ) {\n            __mongo_set_error( conn, MONGO_IO_ERROR, NULL, WSAGetLastError() );\n            conn->connected = 0;\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n\n    return MONGO_OK;\n}",
        "output": "1",
        "idx": 7902
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_event_interrupt(struct pt_regs *regs)\n{\n\tint i;\n\tstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\n\tstruct perf_event *event;\n\tunsigned long val;\n\tint found = 0;\n\tint nmi;\n\n\tnmi = perf_intr_is_nmi(regs);\n\tif (nmi)\n\t\tnmi_enter();\n\telse\n\t\tirq_enter();\n\n\tfor (i = 0; i < ppmu->n_counter; ++i) {\n\t\tevent = cpuhw->event[i];\n\n\t\tval = read_pmc(i);\n\t\tif ((int)val < 0) {\n\t\t\tif (event) {\n\t\t\t\tfound = 1;\n\t\t\t\trecord_and_restart(event, val, regs, nmi);\n\t\t\t} else {\n\t\t\t\twrite_pmc(i, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tmtmsr(mfmsr() | MSR_PMM);\n\tmtpmr(PMRN_PMGC0, PMGC0_PMIE | PMGC0_FCECE);\n\tisync();\n\n\tif (nmi)\n\t\tnmi_exit();\n\telse\n\t\tirq_exit();\n}",
        "output": "1",
        "idx": 448
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int asf_read_marker(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int i, count, name_len, ret;\n    char name[1024];\n\n    avio_rl64(pb);            \n    avio_rl64(pb);            \n    count = avio_rl32(pb);    \n    avio_rl16(pb);            \n    name_len = avio_rl16(pb); \n    avio_skip(pb, name_len);\n\n    for (i = 0; i < count; i++) {\n        int64_t pres_time;\n        int name_len;\n\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n\n        avio_rl64(pb);             \n        pres_time = avio_rl64(pb); \n        pres_time -= asf->hdr.preroll * 10000;\n        avio_rl16(pb);             \n        avio_rl32(pb);             \n        avio_rl32(pb);             \n        name_len = avio_rl32(pb);  \n        if ((ret = avio_get_str16le(pb, name_len * 2, name,\n                                    sizeof(name))) < name_len)\n            avio_skip(pb, name_len - ret);\n        avpriv_new_chapter(s, i, (AVRational) { 1, 10000000 }, pres_time,\n                           AV_NOPTS_VALUE, name);\n    }\n\n    return 0;\n}",
        "output": "0",
        "idx": 4897
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cdf_count_chain(const cdf_sat_t *sat, cdf_secid_t sid, size_t size)\n{\n\tsize_t i, j;\n\tcdf_secid_t maxsector = (cdf_secid_t)(sat->sat_len * size);\n\n\tDPRINTF((\"Chain:\"));\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tDPRINTF((\" %d\", sid));\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Counting chain loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\treturn (size_t)-1;\n\t\t}\n\t\tif (sid > maxsector) {\n\t\t\tDPRINTF((\"Sector %d > %d\\n\", sid, maxsector));\n\t\t\terrno = EFTYPE;\n\t\t\treturn (size_t)-1;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)sat->sat_tab[sid]);\n\t}\n\tif (i == 0) {\n\t\tDPRINTF((\" none, sid: %d\\n\", sid));\n\t\treturn (size_t)-1;\n\n\t}\n\tDPRINTF((\"\\n\"));\n\treturn i;\n}",
        "output": "1",
        "idx": 4408
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE cState_object_nl_set(VALUE self, VALUE object_nl)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(object_nl, T_STRING);\n    len = RSTRING_LEN(object_nl);\n    if (len == 0) {\n        if (state->object_nl) {\n            ruby_xfree(state->object_nl);\n            state->object_nl = NULL;\n        }\n    } else {\n        if (state->object_nl) ruby_xfree(state->object_nl);\n        state->object_nl = fstrndup(RSTRING_PTR(object_nl), len);\n        state->object_nl_len = len;\n    }\n    return Qnil;\n}",
        "output": "0",
        "idx": 8803
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int memfd_create(const char *name, unsigned int flags)\n{\n\treturn syscall(SYS_memfd_create, name, flags);\n}",
        "output": "0",
        "idx": 8215
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "auth_ice_connection (IceConn ice_conn)\n{\n        GIOChannel            *channel;\n        GsmIceConnectionWatch *data;\n        int                    fd;\n\n        g_debug (\"GsmXsmpServer: auth_ice_connection()\");\n\n        fd = IceConnectionNumber (ice_conn);\n        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n        channel = g_io_channel_unix_new (fd);\n\n        data = g_new0 (GsmIceConnectionWatch, 1);\n        ice_conn->context = data;\n\n        data->protocol_timeout = g_timeout_add_seconds (5,\n                                                        (GSourceFunc)ice_protocol_timeout,\n                                                        ice_conn);\n        data->watch_id = g_io_add_watch (channel,\n                                         G_IO_IN | G_IO_ERR,\n                                         (GIOFunc)auth_iochannel_watch,\n                                         ice_conn);\n        g_io_channel_unref (channel);\n}",
        "output": "0",
        "idx": 8719
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ECDSA_verify(int type, const unsigned char *dgst, int dgst_len,\n\t\tconst unsigned char *sigbuf, int sig_len, EC_KEY *eckey)\n \t{\n\tECDSA_SIG *s;\n\tconst unsigned char *p = sigbuf;\n\tunsigned char *der = NULL;\n\tint derlen = -1;\n\tint ret=-1;\n\n\ts = ECDSA_SIG_new();\n\tif (s == NULL) return(ret);\n\tif (d2i_ECDSA_SIG(&s, &p, sig_len) == NULL) goto err;\n\tderlen = i2d_ECDSA_SIG(s, &der);\n\tif (derlen != sig_len || memcmp(sigbuf, der, derlen))\n\t\tgoto err;\n\tret=ECDSA_do_verify(dgst, dgst_len, s, eckey);\nerr:\n\tif (derlen > 0)\n\t\t{\n\t\tOPENSSL_cleanse(der, derlen);\n\t\tOPENSSL_free(der);\n\t\t}\n\tECDSA_SIG_free(s);\n\treturn(ret);\n\t}",
        "output": "0",
        "idx": 6359
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)\n{\n\tstruct block_device *bdev;\n\tchar b[BDEVNAME_SIZE];\n\n\tbdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);\n\tif (IS_ERR(bdev))\n\t\tgoto fail;\n\treturn bdev;\n\nfail:\n\text3_msg(sb, \"error: failed to open journal device %s: %ld\",\n\t\t__bdevname(dev, b), PTR_ERR(bdev));\n\n\treturn NULL;\n}",
        "output": "1",
        "idx": 870
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "prologProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  const char *next = s;\n  int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}",
        "output": "1",
        "idx": 7526
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags, pte_t orig_pte)\n{\n\tpgoff_t pgoff = (((address & PAGE_MASK)\n\t\t\t- vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\n\tpte_unmap(page_table);\n\tif (!vma->vm_ops->fault)\n\t\treturn VM_FAULT_SIGBUS;\n\tif (!(flags & FAULT_FLAG_WRITE))\n\t\treturn do_read_fault(mm, vma, address, pmd, pgoff, flags,\n\t\t\t\torig_pte);\n\tif (!(vma->vm_flags & VM_SHARED))\n\t\treturn do_cow_fault(mm, vma, address, pmd, pgoff, flags,\n\t\t\t\torig_pte);\n\treturn do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);\n}",
        "output": "0",
        "idx": 3977
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_bearer_cap_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_CAP_ANALOG_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_CAP_DIGITAL_MASK) {\n\t\tND_PRINT((ndo, \"D\"));\n\t}\n}",
        "output": "1",
        "idx": 4748
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool ndp_msg_addrto_validate_link_local(struct in6_addr *addr)\n{\n\treturn IN6_IS_ADDR_LINKLOCAL (addr);\n}",
        "output": "0",
        "idx": 8237
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "find_jws(struct tang_keys_info* tki, const char* thp)\n{\n    if (!tki) {\n        return NULL;\n    }\n\n    if (thp == NULL) {\n        json_auto_t* jws = jwk_sign(tki->m_payload, tki->m_sign);\n        if (!jws) {\n            return NULL;\n        }\n        return json_incref(jws);\n    }\n    return find_by_thp(tki, thp);\n}",
        "output": "1",
        "idx": 8800
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)\t{cJSON *c=object?object->child:0;while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}",
        "output": "0",
        "idx": 8241
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "accept_xsmp_connection (SmsConn        sms_conn,\n                        GsmXsmpServer *server,\n                        unsigned long *mask_ret,\n                        SmsCallbacks  *callbacks_ret,\n                        char         **failure_reason_ret)\n{\n        IceConn        ice_conn;\n        GsmXSMPClient *client;\n\n        if (server->priv->xsmp_sockets == NULL) {\n                g_debug (\"GsmXsmpServer: In shutdown, rejecting new client\");\n\n                *failure_reason_ret = strdup (_(\"Refusing new client connection because the session is currently being shut down\\n\"));\n                return FALSE;\n        }\n\n        ice_conn = SmsGetIceConnection (sms_conn);\n        client = ice_conn->context;\n\n        g_return_val_if_fail (client != NULL, TRUE);\n\n        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);\n\n        return TRUE;\n}",
        "output": "1",
        "idx": 6218
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "snmp_engine_get(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t varbinds_length)\n{\n  snmp_mib_resource_t *resource;\n  uint32_t i;\n\n  for(i = 0; i < varbinds_length; i++) {\n    resource = snmp_mib_find(varbinds[i].oid);\n    if(!resource) {\n      switch(header->version) {\n      case SNMP_VERSION_1:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = i + 1;\n        break;\n      case SNMP_VERSION_2C:\n        (&varbinds[i])->value_type = SNMP_DATA_TYPE_NO_SUCH_INSTANCE;\n        break;\n      default:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = 0;\n      }\n    } else {\n      resource->handler(&varbinds[i], resource->oid);\n    }\n  }\n\n  return 0;\n}",
        "output": "1",
        "idx": 7976
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  mt_tbl *h;\n\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n\n  if (h && mt_del(mrb, h, mid)) return;\n  mrb_name_error(mrb, mid, \"method '%n' not defined in %C\", mid, c);\n}",
        "output": "1",
        "idx": 6704
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_GetArrayItem( cJSON *array, int item )\n{\n\tcJSON *c = array->child;\n\twhile ( c && item > 0 ) {\n\t\t--item;\n\t\tc = c->next;\n\t}\n\treturn c;\n}",
        "output": "1",
        "idx": 5936
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Jsi_RC WebSocketVersionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    const char *verStr = NULL;\n    verStr = lws_get_library_version();\n    if (verStr) {\n        char buf[100], *cp;\n        snprintf(buf, sizeof(buf), \"%s\", verStr);\n        cp = Jsi_Strchr(buf, ' ');\n        if (cp) *cp = 0;\n        Jsi_ValueMakeStringDup(interp, ret, buf);\n    }\n    return JSI_OK;\n}",
        "output": "1",
        "idx": 8228
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int bad_format_imginfo(\n    char *fmt)\n{\n    char     *ptr;\n    int       n = 0;\n\n    ptr = fmt;\n    while (*ptr != '\\0')\n        if (*ptr++ == '%') {\n\n            if (*ptr == '\\0')\n                return 1;\n            if (*ptr == '%')\n                ptr++;\n            else if (*ptr == 's' || *ptr == 'S') {\n                n = 1;\n                ptr++;\n            }\n\n            else {\n                if (*ptr == ' ')\n                    ptr++;\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                if (*ptr++ != 'l')\n                    return 1;\n                if (*ptr == 'u')\n                    ptr++;\n                else\n                    return 1;\n                n++;\n            }\n        }\n\n    return (n != 3);\n}",
        "output": "1",
        "idx": 4606
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct timespec ns_to_timespec(const s64 nsec)\n{\n\tstruct timespec ts;\n\ts32 rem;\n\n\tif (!nsec)\n\t\treturn (struct timespec) {0, 0};\n\n\tts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);\n\tif (unlikely(rem < 0)) {\n\t\tts.tv_sec--;\n\t\trem += NSEC_PER_SEC;\n\t}\n\tts.tv_nsec = rem;\n\n\treturn ts;\n}",
        "output": "0",
        "idx": 3015
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int createFromTiffRgba(TIFF * tif, gdImagePtr im)\n{\n\tint a;\n\tint x, y;\n\tint alphaBlendingFlag = 0;\n\tint color;\n\tint width = im->sx;\n\tint height = im->sy;\n\tuint32 *buffer;\n\tuint32 rgba;\n\tint success;\n\n\talphaBlendingFlag = im->alphaBlendingFlag;\n\tgdImageAlphaBlending(im, 0);\n\n\tbuffer = (uint32 *) gdCalloc(sizeof(uint32), width * height);\n\tif (!buffer) {\n\t\treturn GD_FAILURE;\n\t}\n\n\tsuccess = TIFFReadRGBAImage(tif, width, height, buffer, 1);\n\n\tif (success) {\n\t\tfor(y = 0; y < height; y++) {\n\t\t\tfor(x = 0; x < width; x++) {\n\t\t\t\trgba = buffer[(y * width + x)];\n\t\t\t\ta = (0xff - TIFFGetA(rgba)) / 2;\n\t\t\t\tcolor = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);\n\t\n\t\t\t\tgdImageSetPixel(im, x, height - y - 1, color);\n\t\t\t}\n\t\t}\n\t}\n\n\tgdFree(buffer);\n\n\tgdImageAlphaBlending(im, alphaBlendingFlag);\n\treturn success;\n}",
        "output": "0",
        "idx": 6179
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_TIFFmalloc(tmsize_t s)\n{\n        if (s == 0)\n                return ((void *) NULL);\n\n\treturn (malloc((size_t) s));\n}",
        "output": "0",
        "idx": 5853
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "txid_snapshot_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tTxidSnapshot *snap;\n\ttxid\t\tlast = 0;\n\tint\t\t\tnxip;\n\tint\t\t\ti;\n\ttxid\t\txmin,\n\t\t\t\txmax;\n\n\tnxip = pq_getmsgint(buf, 4);\n\tif (nxip < 0 || nxip > TXID_SNAPSHOT_MAX_NXIP)\n\t\tgoto bad_format;\n\n\txmin = pq_getmsgint64(buf);\n\txmax = pq_getmsgint64(buf);\n\tif (xmin == 0 || xmax == 0 || xmin > xmax || xmax > MAX_TXID)\n\t\tgoto bad_format;\n\n\tsnap = palloc(TXID_SNAPSHOT_SIZE(nxip));\n\tsnap->xmin = xmin;\n\tsnap->xmax = xmax;\n\tsnap->nxip = nxip;\n\tSET_VARSIZE(snap, TXID_SNAPSHOT_SIZE(nxip));\n\n\tfor (i = 0; i < nxip; i++)\n\t{\n\t\ttxid\t\tcur = pq_getmsgint64(buf);\n\n\t\tif (cur <= last || cur < xmin || cur >= xmax)\n\t\t\tgoto bad_format;\n\t\tsnap->xip[i] = cur;\n\t\tlast = cur;\n\t}\n\tPG_RETURN_POINTER(snap);\n\nbad_format:\n\telog(ERROR, \"invalid snapshot data\");\n\treturn (Datum) NULL;\n}",
        "output": "0",
        "idx": 6301
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n    xmlIDPtr id;\n    xmlChar *ID;\n\n    if (doc == NULL) return(-1);\n    if (attr == NULL) return(-1);\n\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n\n    ID = xmlNodeListGetString(doc, attr->children, 1);\n    if (ID == NULL)\n        return(-1);\n    xmlValidNormalizeString(ID);\n\n    id = xmlHashLookup(table, ID);\n    if (id == NULL || id->attr != attr) {\n        xmlFree(ID);\n        return(-1);\n    }\n\n    xmlHashRemoveEntry(table, ID, xmlFreeIDTableEntry);\n    xmlFree(ID);\n    attr->atype = 0;\n    return(0);\n}",
        "output": "0",
        "idx": 8859
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void doGet(HttpRequest req, HttpResponse res) {\n        set_content_type(res, \"text/html\");\n        if (ACTION(HOME)) {\n                LOCK(Run.mutex)\n                do_home(res);\n                END_LOCK;\n        } else if (ACTION(RUN)) {\n                handle_run(req, res);\n        } else if (ACTION(TEST)) {\n                is_monit_running(res);\n        } else if (ACTION(VIEWLOG)) {\n                do_viewlog(req, res);\n        } else if (ACTION(ABOUT)) {\n                do_about(res);\n        } else if (ACTION(FAVICON)) {\n                printFavicon(res);\n        } else if (ACTION(PING)) {\n                do_ping(res);\n        } else if (ACTION(GETID)) {\n                do_getid(res);\n        } else if (ACTION(STATUS)) {\n                print_status(req, res, 1);\n        } else if (ACTION(STATUS2)) {\n                print_status(req, res, 2);\n        } else if (ACTION(SUMMARY)) {\n                print_summary(req, res);\n        } else if (ACTION(REPORT)) {\n                _printReport(req, res);\n        } else if (ACTION(DOACTION)) {\n                handle_do_action(req, res);\n        } else {\n                handle_action(req, res);\n        }\n}",
        "output": "1",
        "idx": 6016
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int common_timer_set(struct k_itimer *timr, int flags,\n\t\t     struct itimerspec64 *new_setting,\n\t\t     struct itimerspec64 *old_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tbool sigev_none;\n\tktime_t expires;\n\n\tif (old_setting)\n\t\tcommon_timer_get(timr, old_setting);\n\n\ttimr->it_interval = 0;\n\tif (kc->timer_try_to_cancel(timr) < 0)\n\t\treturn TIMER_RETRY;\n\n\ttimr->it_active = 0;\n\ttimr->it_requeue_pending = (timr->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimr->it_overrun_last = 0;\n\n\tif (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)\n\t\treturn 0;\n\n\ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n\texpires = timespec64_to_ktime(new_setting->it_value);\n\tsigev_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE;\n\n\tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n\ttimr->it_active = !sigev_none;\n\treturn 0;\n}",
        "output": "1",
        "idx": 1796
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DhcpOption *dhcpGetOption(const DhcpMessage *message,\n   size_t length, uint8_t optionCode)\n{\n   uint_t i;\n   DhcpOption *option;\n\n   if(length < sizeof(DhcpMessage))\n      return NULL;\n   length -= sizeof(DhcpMessage);\n\n   for(i = 0; i < length; i++)\n   {\n      option = (DhcpOption *) (message->options + i);\n\n      if(option->code == DHCP_OPT_PAD)\n         continue;\n      if(option->code == DHCP_OPT_END)\n         break;\n      if((i + 1) >= length || (i + 1 + option->length) >= length)\n         break;\n\n      if(option->code == optionCode)\n         return option;\n\n      i += option->length + 1;\n   }\n\n   return NULL;\n}",
        "output": "1",
        "idx": 8514
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "IW_IMPL(int) iw_get_i32le(const iw_byte *b)\n{\n\treturn (iw_int32)(iw_uint32)(b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24));\n}",
        "output": "1",
        "idx": 6652
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {\n        _cleanup_close_ int fd;\n        int r;\n\n        assert(path);\n\n        if (parents)\n                mkdir_parents(path, 0755);\n\n        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);\n        if (fd < 0)\n                return -errno;\n\n        if (mode != MODE_INVALID) {\n                r = fchmod(fd, mode);\n                if (r < 0)\n                        return -errno;\n        }\n\n        if (uid != UID_INVALID || gid != GID_INVALID) {\n                r = fchown(fd, uid, gid);\n                if (r < 0)\n                        return -errno;\n        }\n\n        if (stamp != USEC_INFINITY) {\n                struct timespec ts[2];\n\n                timespec_store(&ts[0], stamp);\n                ts[1] = ts[0];\n                r = futimens(fd, ts);\n        } else\n                r = futimens(fd, NULL);\n        if (r < 0)\n                return -errno;\n\n        return 0;\n}",
        "output": "0",
        "idx": 7677
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void posixtimer_rearm(struct siginfo *info)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\n\ttimr = lock_timer(info->si_tid, &flags);\n\tif (!timr)\n\t\treturn;\n\n\tif (timr->it_requeue_pending == info->si_sys_private) {\n\t\ttimr->kclock->timer_rearm(timr);\n\n\t\ttimr->it_active = 1;\n\t\ttimr->it_overrun_last = timr->it_overrun;\n\t\ttimr->it_overrun = -1LL;\n\t\t++timr->it_requeue_pending;\n\n\t\tinfo->si_overrun = timer_overrun_to_int(timr, info->si_overrun);\n\t}\n\n\tunlock_timer(timr, flags);\n}",
        "output": "0",
        "idx": 4131
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "AsyncWith(asdl_seq * items, asdl_seq * body, int lineno, int col_offset, int\n          end_lineno, int end_col_offset, PyArena *arena)\n{\n    stmt_ty p;\n    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->kind = AsyncWith_kind;\n    p->v.AsyncWith.items = items;\n    p->v.AsyncWith.body = body;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    p->end_lineno = end_lineno;\n    p->end_col_offset = end_col_offset;\n    return p;\n}",
        "output": "1",
        "idx": 7166
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(locale_get_display_script)\n{\n    get_icu_disp_value_src_php( LOC_SCRIPT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}",
        "output": "0",
        "idx": 5437
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\n\tu16 offset = sizeof(struct ipv6hdr);\n\tunsigned int packet_len = skb_tail_pointer(skb) -\n\t\tskb_network_header(skb);\n\tint found_rhdr = 0;\n\t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n\n\twhile (offset <= packet_len) {\n\t\tstruct ipv6_opt_hdr *exthdr;\n\n\t\tswitch (**nexthdr) {\n\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\n\t\tif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)\n\t\t\treturn -EINVAL;\n\n\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t offset);\n\t\toffset += ipv6_optlen(exthdr);\n\t\t*nexthdr = &exthdr->nexthdr;\n\t}\n\n\treturn -EINVAL;\n}",
        "output": "0",
        "idx": 2301
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHPAPI char *php_unescape_html_entities(unsigned char *old, size_t oldlen, size_t *newlen, int all, int flags, char *hint_charset TSRMLS_DC)\n{\n\tsize_t retlen;\n\tchar *ret;\n\tenum entity_charset charset;\n\tconst entity_ht *inverse_map = NULL;\n\tsize_t new_size = TRAVERSE_FOR_ENTITIES_EXPAND_SIZE(oldlen);\n\n\tif (all) {\n\t\tcharset = determine_charset(hint_charset TSRMLS_CC);\n\t} else {\n\t\tcharset = cs_8859_1; \n\t}\n\n\n\tif (oldlen > new_size) {\n\t\tret = estrndup((char*)old, oldlen);\n\t\tretlen = oldlen;\n\t\tgoto empty_source;\n\t}\n\tret = emalloc(new_size);\n\t*ret = '\\0';\n\tretlen = oldlen;\n\tif (retlen == 0) {\n\t\tgoto empty_source;\n\t}\n\t\n\tinverse_map = unescape_inverse_map(all, flags);\n\t\n\ttraverse_for_entities(old, oldlen, ret, &retlen, all, flags, inverse_map, charset);\n\nempty_source:\t\n\t*newlen = retlen;\n\treturn ret;\n}",
        "output": "1",
        "idx": 3838
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char* _single_string_alloc_and_copy( LPCWSTR in )\n{\n    char *chr;\n    int len = 0;\n\n    if ( !in )\n    {\n        return in;\n    }\n\n    while ( in[ len ] != 0 )\n    {\n        len ++;\n    }\n\n    chr = malloc( len + 1 );\n\n    len = 0;\n    while ( in[ len ] != 0 )\n    {\n        chr[ len ] = 0xFF & in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = '\\0';\n\n    return chr;\n}",
        "output": "1",
        "idx": 7328
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof TSRMLS_DC)\n{\n\tuint64_t max_vars = PG(max_input_vars);\n\n\tvars->ptr = vars->str.c;\n\tvars->end = vars->str.c + vars->str.len;\n\twhile (add_post_var(arr, vars, eof TSRMLS_CC)) {\n\t\tif (++vars->cnt > max_vars) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\n\t\t\t\t\t\"Input variables exceeded %\" PRIu64 \". \"\n\t\t\t\t\t\"To increase the limit change max_input_vars in php.ini.\",\n\t\t\t\t\tmax_vars);\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\tif (!eof) {\n\t\tmemmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);\n\t}\n\treturn SUCCESS;\n}",
        "output": "1",
        "idx": 4104
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Curl_detach_connnection(struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n  if(conn)\n    Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL);\n  data->conn = NULL;\n}",
        "output": "1",
        "idx": 6030
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "\t__must_hold(&ctx->completion_lock)\n{\n\tu32 seq = ctx->cached_cq_tail - atomic_read(&ctx->cq_timeouts);\n\n\tspin_lock_irq(&ctx->timeout_lock);\n\twhile (!list_empty(&ctx->timeout_list)) {\n\t\tu32 events_needed, events_got;\n\t\tstruct io_kiocb *req = list_first_entry(&ctx->timeout_list,\n\t\t\t\t\t\tstruct io_kiocb, timeout.list);\n\n\t\tif (io_is_timeout_noseq(req))\n\t\t\tbreak;\n\n\t\tevents_needed = req->timeout.target_seq - ctx->cq_last_tm_flush;\n\t\tevents_got = seq - ctx->cq_last_tm_flush;\n\t\tif (events_got < events_needed)\n\t\t\tbreak;\n\n\t\tlist_del_init(&req->timeout.list);\n\t\tio_kill_timeout(req, 0);\n\t}\n\tctx->cq_last_tm_flush = seq;\n\tspin_unlock_irq(&ctx->timeout_lock);\n}",
        "output": "1",
        "idx": 2026
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mem_check_range(struct rxe_mem *mem, u64 iova, size_t length)\n{\n\tswitch (mem->type) {\n\tcase RXE_MEM_TYPE_DMA:\n\t\treturn 0;\n\n\tcase RXE_MEM_TYPE_MR:\n\tcase RXE_MEM_TYPE_FMR:\n\t\tif (iova < mem->iova ||\n\t\t    length > mem->length ||\n\t\t    iova > mem->iova + mem->length - length)\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EFAULT;\n\t}\n}",
        "output": "0",
        "idx": 2143
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\tspl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);\n\t\n\tobject->u.dir.index++;\n\tdo {\n\t\tspl_filesystem_dir_read(object TSRMLS_CC);\n\t} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));\n\tif (object->file_name) {\n\t\tefree(object->file_name);\n\t\tobject->file_name = NULL;\n\t}\n\tif (iterator->current) {\n\t\tzval_ptr_dtor(&iterator->current);\n\t\titerator->current = NULL;\n\t}\n}",
        "output": "1",
        "idx": 3946
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __netdev_printk(const char *level, const struct net_device *dev,\n\t\t\t   struct va_format *vaf)\n{\n\tint r;\n\n\tif (dev && dev->dev.parent)\n\t\tr = dev_printk(level, dev->dev.parent, \"%s: %pV\",\n\t\t\t       netdev_name(dev), vaf);\n\telse if (dev)\n\t\tr = printk(\"%s%s: %pV\", level, netdev_name(dev), vaf);\n\telse\n\t\tr = printk(\"%s(NULL net_device): %pV\", level, vaf);\n\n\treturn r;\n}",
        "output": "0",
        "idx": 327
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint64_t unpack_timestamp(const struct efi_time *timestamp)\n{\n\tuint64_t val = 0;\n\tuint16_t year = le32_to_cpu(timestamp->year);\n\n\tval |= ((uint64_t) timestamp->pad1 & 0xFF) << 0;\n\tval |= ((uint64_t) timestamp->second & 0xFF) << (1*8);\n\tval |= ((uint64_t) timestamp->minute & 0xFF) << (2*8);\n\tval |= ((uint64_t) timestamp->hour & 0xFF) << (3*8);\n\tval |= ((uint64_t) timestamp->day & 0xFF) << (4*8);\n\tval |= ((uint64_t) timestamp->month & 0xFF) << (5*8);\n\tval |= ((uint64_t) year) << (6*8);\n\n\treturn val;\n}",
        "output": "1",
        "idx": 8738
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_seq_ioctl_remove_events(struct snd_seq_client *client,\n\t\t\t\t       void __user *arg)\n{\n\tstruct snd_seq_remove_events info;\n\n\tif (copy_from_user(&info, arg, sizeof(info)))\n\t\treturn -EFAULT;\n\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_INPUT) {\n\t\tif (client->type == USER_CLIENT)\n\t\t\tsnd_seq_fifo_clear(client->data.user.fifo);\n\t}\n\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_OUTPUT)\n\t\tsnd_seq_queue_remove_cells(client->number, &info);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1034
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,\n\t\t\t      pte_t *ptep, pte_t pte)\n{\n\tif (pte_valid_user(pte)) {\n\t\tif (!pte_special(pte) && pte_exec(pte))\n\t\t\t__sync_icache_dcache(pte, addr);\n\t\tif (pte_dirty(pte) && pte_write(pte))\n\t\t\tpte_val(pte) &= ~PTE_RDONLY;\n\t\telse\n\t\t\tpte_val(pte) |= PTE_RDONLY;\n\t}\n\n\tset_pte(ptep, pte);\n}",
        "output": "0",
        "idx": 3545
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tbuf[1] &= ~(1 << offset);\n\tbuf[2] = gpio_push_pull;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = 0;\n\nexit:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret <= 0 ? ret : -EIO;\n}",
        "output": "1",
        "idx": 1438
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jpeg_size(unsigned char* data, unsigned int data_size,\n                     int *width, int *height)\n{\n    int i = 0;\n    if (i + 3 < data_size && data[i] == 0xFF && data[i+1] == 0xD8 &&\n            data[i+2] == 0xFF && data[i+3] == 0xE0) {\n        i += 4;\n        if(i + 6 < data_size &&\n                data[i+2] == 'J' && data[i+3] == 'F' && data[i+4] == 'I' &&\n                data[i+5] == 'F' && data[i+6] == 0x00) {\n            unsigned short block_length = data[i] * 256 + data[i+1];\n            while(i<data_size) {\n                i+=block_length;\n                if((i + 1) >= data_size)\n                    return -1;\n                if(data[i] != 0xFF)\n                    return -1;\n                if(data[i+1] == 0xC0) {\n                    *height = data[i+5]*256 + data[i+6];\n                    *width = data[i+7]*256 + data[i+8];\n                    return 0;\n                }\n                i+=2;\n                block_length = data[i] * 256 + data[i+1];\n            }\n        }\n    }\n\n    return -1;\n}",
        "output": "1",
        "idx": 6744
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int xsave_state_booting(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\n\tWARN_ON(system_state != SYSTEM_BOOTING);\n\n\tif (boot_cpu_has(X86_FEATURE_XSAVES))\n\t\tasm volatile(\"1:\"XSAVES\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\telse\n\t\tasm volatile(\"1:\"XSAVE\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\n\tasm volatile(xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\n\treturn err;\n}",
        "output": "1",
        "idx": 2794
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "new_fixup(struct archive_write_disk *a, const char *pathname)\n{\n\tstruct fixup_entry *fe;\n\n\tfe = (struct fixup_entry *)calloc(1, sizeof(struct fixup_entry));\n\tif (fe == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate memory for a fixup\");\n\t\treturn (NULL);\n\t}\n\tfe->next = a->fixup_list;\n\ta->fixup_list = fe;\n\tfe->fixup = 0;\n\tfe->mode = 0;\n\tfe->name = strdup(pathname);\n\treturn (fe);\n}",
        "output": "0",
        "idx": 5165
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ignore_error_for_testing(char_u *error)\n{\n    if (ignore_error_list.ga_itemsize == 0)\n\tga_init2(&ignore_error_list, sizeof(char_u *), 1);\n\n    if (STRCMP(\"RESET\", error) == 0)\n\tga_clear_strings(&ignore_error_list);\n    else\n\tga_copy_string(&ignore_error_list, error);\n}",
        "output": "0",
        "idx": 7943
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BOOL transport_connect_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tif (transport->layer == TRANSPORT_LAYER_TSG)\n\t\treturn TRUE;\n\n\tif (!transport_connect_tls(transport))\n\t\treturn FALSE;\n\n\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tif (!connectErrorCode)\n\t\t\tconnectErrorCode = AUTHENTICATIONERROR;\n\n\t\tfprintf(stderr, \"Authentication failure, check credentials.\\n\"\n\t\t\t\"If credentials are valid, the NTLMSSP implementation may be to blame.\\n\");\n\n\t\tcredssp_free(transport->credssp);\n\t\ttransport->credssp = NULL;\n\t\treturn FALSE;\n\t}\n\n\tcredssp_free(transport->credssp);\n\n\treturn TRUE;\n}",
        "output": "0",
        "idx": 5845
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iakerb_gss_import_sec_context(OM_uint32 *minor_status,\n                              gss_buffer_t interprocess_token,\n                              gss_ctx_id_t *context_handle)\n{\n    OM_uint32 maj, tmpmin;\n    krb5_error_code code;\n    gss_ctx_id_t gssc;\n    krb5_gss_ctx_id_t kctx;\n    iakerb_ctx_id_t ctx;\n\n    maj = krb5_gss_import_sec_context(minor_status, interprocess_token, &gssc);\n    if (maj != GSS_S_COMPLETE)\n        return maj;\n    kctx = (krb5_gss_ctx_id_t)gssc;\n\n    if (!kctx->established) {\n        krb5_gss_delete_sec_context(&tmpmin, &gssc, GSS_C_NO_BUFFER);\n        return GSS_S_FAILURE;\n    }\n\n    code = iakerb_alloc_context(&ctx, kctx->initiate);\n    if (code != 0) {\n        krb5_gss_delete_sec_context(&tmpmin, &gssc, GSS_C_NO_BUFFER);\n        *minor_status = code;\n        return GSS_S_FAILURE;\n    }\n\n    ctx->gssc = gssc;\n    ctx->established = 1;\n    *context_handle = (gss_ctx_id_t)ctx;\n    return GSS_S_COMPLETE;\n}",
        "output": "0",
        "idx": 175
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool new_idmap_permitted(const struct file *file, \n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, file->f_cred->fsuid))\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (gid_eq(gid, file->f_cred->fsgid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\n\tif (ns_capable(ns->parent, cap_setid) &&\n\t    file_ns_capable(file, ns->parent, cap_setid))\n\t\treturn true;\n\n\treturn false;\n}",
        "output": "0",
        "idx": 1315
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int hci_req_sync(struct hci_dev *hdev, int (*req)(struct hci_request *req,\n\t\t\t\t\t\t  unsigned long opt),\n\t\t unsigned long opt, u32 timeout, u8 *hci_status)\n{\n\tint ret;\n\n\thci_req_sync_lock(hdev);\n\tif (test_bit(HCI_UP, &hdev->flags))\n\t\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n\telse\n\t\tret = -ENETDOWN;\n\thci_req_sync_unlock(hdev);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 2781
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static enum test_return test_issue_102(void) {\n    char buffer[4096];\n    memset(buffer, ' ', sizeof(buffer));\n    buffer[sizeof(buffer) - 1] = '\\0';\n\n    close(sock);\n    sock = connect_server(\"127.0.0.1\", port, false);\n\n    send_ascii_command(buffer);\n    assert(read(sock, buffer, sizeof(buffer)) == 0);\n    close(sock);\n    sock = connect_server(\"127.0.0.1\", port, false);\n    return TEST_PASS;\n}",
        "output": "0",
        "idx": 4649
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ikev1_sig_print(netdissect_options *ndo, u_char tpay _U_,\n\t\tconst struct isakmp_gen *ext, u_int item_len _U_,\n\t\tconst u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_SIG)));\n\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_SIG)));\n\treturn NULL;\n}",
        "output": "0",
        "idx": 6817
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\n\tstrncpy(rblkcipher.type, \"givcipher\", sizeof(rblkcipher.type));\n\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \"<built-in>\",\n\t\tsizeof(rblkcipher.geniv));\n\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "0",
        "idx": 1171
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "snmp_ber_encode_null(unsigned char *out, uint32_t *out_len, uint8_t type)\n{\n  (*out_len)++;\n  *out-- = 0x00;\n  out = snmp_ber_encode_type(out, out_len, type);\n\n  return out;\n}",
        "output": "1",
        "idx": 7946
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jp2_box_t *jp2_box_create(int type)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(box, 0, sizeof(jp2_box_t));\n\tbox->type = type;\n\tbox->len = 0;\n\tif (!(boxinfo = jp2_boxinfolookup(type))) {\n\t\treturn 0;\n\t}\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\treturn box;\n}",
        "output": "1",
        "idx": 5444
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Huff_transmit (huff_t *huff, int ch, byte *fout, int maxoffset) {\n\tint i;\n\tif (huff->loc[ch] == NULL) { \n\t\tHuff_transmit(huff, NYT, fout, maxoffset);\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tadd_bit((char)((ch >> i) & 0x1), fout);\n\t\t}\n\t} else {\n\t\tsend(huff->loc[ch], NULL, fout, maxoffset);\n\t}\n}",
        "output": "0",
        "idx": 8751
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long ec_device_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)\n{\n\tlong ret;\n\tstruct cros_ec_command u_cmd;\n\tstruct cros_ec_command *s_cmd;\n\n\tif (copy_from_user(&u_cmd, arg, sizeof(u_cmd)))\n\t\treturn -EFAULT;\n\n\tif ((u_cmd.outsize > EC_MAX_MSG_BYTES) ||\n\t    (u_cmd.insize > EC_MAX_MSG_BYTES))\n\t\treturn -EINVAL;\n\n\ts_cmd = kmalloc(sizeof(*s_cmd) + max(u_cmd.outsize, u_cmd.insize),\n\t\t\tGFP_KERNEL);\n\tif (!s_cmd)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(s_cmd, arg, sizeof(*s_cmd) + u_cmd.outsize)) {\n\t\tret = -EFAULT;\n\t\tgoto exit;\n\t}\n\n\ts_cmd->command += ec->cmd_offset;\n\tret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + u_cmd.insize))\n\t\tret = -EFAULT;\nexit:\n\tkfree(s_cmd);\n\treturn ret;\n}",
        "output": "1",
        "idx": 1294
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void big_key_revoke(struct key *key)\n{\n\tstruct path *path = (struct path *)&key->payload.data[big_key_path];\n\n\tkey_payload_reserve(key, 0);\n\tif (key_is_instantiated(key) &&\n\t    (size_t)key->payload.data[big_key_len] > BIG_KEY_FILE_THRESHOLD)\n\t\tvfs_truncate(path, 0);\n}",
        "output": "1",
        "idx": 1716
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool check_underflow(const struct ip6t_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\n\tif (!unconditional(e))\n\t\treturn false;\n\tt = ip6t_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}",
        "output": "0",
        "idx": 1773
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseServerLog(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprTicks    timestamp;\n    cchar       *location;\n    ssize       size;\n    int         level, anew, backup;\n\n    if (mprGetCmdlineLogging()) {\n        mprLog(\"warn http config\", 4, \"Already logging. Ignoring log configuration\");\n        return;\n    }\n    location = mprGetJson(prop, \"location\");\n    level = (int) stoi(mprGetJson(prop, \"level\"));\n    backup = (int) stoi(mprGetJson(prop, \"backup\"));\n    anew = smatch(mprGetJson(prop, \"anew\"), \"true\");\n    size = (ssize) httpGetNumber(mprGetJson(prop, \"size\"));\n    timestamp = httpGetNumber(mprGetJson(prop, \"timestamp\"));\n\n    if (size < HTTP_TRACE_MIN_LOG_SIZE) {\n        size = HTTP_TRACE_MIN_LOG_SIZE;\n    }\n    if (location == 0) {\n        httpParseError(route, \"Missing location\");\n        return;\n    }\n    if (!smatch(location, \"stdout\") && !smatch(location, \"stderr\")) {\n        location = httpMakePath(route, 0, location);\n    }\n    mprSetLogBackup(size, backup, anew ? MPR_LOG_ANEW : 0);\n\n    if (mprStartLogging(location, 0) < 0) {\n        httpParseError(route, \"Cannot write to error log: %s\", location);\n        return;\n    }\n    mprSetLogLevel(level);\n    mprLogConfig();\n    if (timestamp) {\n        httpSetTimestamp(timestamp);\n    }\n}",
        "output": "1",
        "idx": 5052
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error_t httpClientSetMethod(HttpClientContext *context, const char_t *method)\n{\n   size_t m;\n   size_t n;\n   char_t *p;\n\n   if(context == NULL || method == NULL)\n      return ERROR_INVALID_PARAMETER;\n\n   n = osStrlen(method);\n\n   if(n == 0 || n > HTTP_CLIENT_MAX_METHOD_LEN)\n      return ERROR_INVALID_LENGTH;\n\n   if(context->bufferLen > HTTP_CLIENT_BUFFER_SIZE)\n      return ERROR_INVALID_SYNTAX;\n\n   context->buffer[context->bufferLen] = '\\0';\n\n   p = strchr(context->buffer, ' ');\n   if(p == NULL)\n      return ERROR_INVALID_SYNTAX;\n\n   m = p - context->buffer;\n\n   if((context->bufferLen + n - m) > HTTP_CLIENT_BUFFER_SIZE)\n      return ERROR_BUFFER_OVERFLOW;\n\n   osMemmove(context->buffer + n, p, context->bufferLen + 1 - m);\n   osStrncpy(context->buffer, method, n);\n\n   context->bufferLen = context->bufferLen + n - m;\n\n   osStrcpy(context->method, method);\n\n   return NO_ERROR;\n}",
        "output": "1",
        "idx": 8636
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int walk_hugetlb_range(unsigned long addr, unsigned long end,\n\t\t\t      struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long next;\n\tunsigned long hmask = huge_page_mask(h);\n\tunsigned long sz = huge_page_size(h);\n\tpte_t *pte;\n\tint err = 0;\n\n\tdo {\n\t\tnext = hugetlb_entry_end(h, addr, end);\n\t\tpte = huge_pte_offset(walk->mm, addr & hmask, sz);\n\t\tif (pte && walk->hugetlb_entry)\n\t\t\terr = walk->hugetlb_entry(pte, hmask, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (addr = next, addr != end);\n\n\treturn err;\n}",
        "output": "1",
        "idx": 1758
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void Sp_match(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint len;\n\tconst char *a, *b, *c, *e;\n\tResub m;\n\n\ttext = checkstring(J, 0);\n\n\tif (js_isregexp(J, 1))\n\t\tjs_copy(J, 1);\n\telse if (js_isundefined(J, 1))\n\t\tjs_newregexp(J, \"\", 0);\n\telse\n\t\tjs_newregexp(J, js_tostring(J, 1), 0);\n\n\tre = js_toregexp(J, -1);\n\tif (!(re->flags & JS_REGEXP_G)) {\n\t\tjs_RegExp_prototype_exec(J, re, text);\n\t\treturn;\n\t}\n\n\tre->last = 0;\n\n\tjs_newarray(J);\n\n\tlen = 0;\n\ta = text;\n\te = text + strlen(text);\n\twhile (a <= e) {\n\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n\t\t\tbreak;\n\n\t\tb = m.sub[0].sp;\n\t\tc = m.sub[0].ep;\n\n\t\tjs_pushlstring(J, b, c - b);\n\t\tjs_setindex(J, -2, len++);\n\n\t\ta = c;\n\t\tif (c - b == 0)\n\t\t\t++a;\n\t}\n\n\tif (len == 0) {\n\t\tjs_pop(J, 1);\n\t\tjs_pushnull(J);\n\t}\n}",
        "output": "1",
        "idx": 7416
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void hugepage_put_subpool(struct hugepage_subpool *spool)\n{\n\tspin_lock(&spool->lock);\n\tBUG_ON(!spool->count);\n\tspool->count--;\n\tunlock_or_release_subpool(spool);\n}",
        "output": "0",
        "idx": 909
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ccid3_hc_tx_getsockopt(struct sock *sk, const int optname, int len,\n\t\t\t\t  u32 __user *optval, int __user *optlen)\n{\n\tconst struct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\n\tstruct tfrc_tx_info tfrc;\n\tconst void *val;\n\n\tswitch (optname) {\n\tcase DCCP_SOCKOPT_CCID_TX_INFO:\n\t\tif (len < sizeof(tfrc))\n\t\t\treturn -EINVAL;\n\t\tmemset(&tfrc, 0, sizeof(tfrc));\n\t\ttfrc.tfrctx_x\t   = hc->tx_x;\n\t\ttfrc.tfrctx_x_recv = hc->tx_x_recv;\n\t\ttfrc.tfrctx_x_calc = hc->tx_x_calc;\n\t\ttfrc.tfrctx_rtt\t   = hc->tx_rtt;\n\t\ttfrc.tfrctx_p\t   = hc->tx_p;\n\t\ttfrc.tfrctx_rto\t   = hc->tx_t_rto;\n\t\ttfrc.tfrctx_ipi\t   = hc->tx_t_ipi;\n\t\tlen = sizeof(tfrc);\n\t\tval = &tfrc;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\n\tif (put_user(len, optlen) || copy_to_user(optval, val, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1019
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rose_start_idletimer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tsk_stop_timer(sk, &rose->idletimer);\n\n\tif (rose->idle > 0) {\n\t\trose->idletimer.function = rose_idletimer_expiry;\n\t\trose->idletimer.expires  = jiffies + rose->idle;\n\n\t\tsk_reset_timer(sk, &rose->idletimer, rose->idletimer.expires);\n\t}\n}",
        "output": "0",
        "idx": 2959
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n{\n\tgdImagePtr pim = 0, tim = im;\n\tint interlace, BitsPerPixel;\n\tinterlace = im->interlace;\n\tif (im->trueColor) {\n\t\tpim = gdImageCreatePaletteFromTrueColor(im, 1, 256);\n\t\tif (!pim) {\n\t\t\treturn;\n\t\t}\n\t\ttim = pim;\n\t}\n\tBitsPerPixel = colorstobpp(tim->colorsTotal);\n\tGIFEncode(\n\t\tout, tim->sx, tim->sy, tim->interlace, 0, tim->transparent, BitsPerPixel,\n\t\ttim->red, tim->green, tim->blue, tim);\n\tif (pim) {\n\t\tgdImageDestroy(\tpim);\n\t}\n}",
        "output": "1",
        "idx": 4118
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct completion *vfork_done = tsk->vfork_done;\n\n#ifdef CONFIG_FUTEX\n\tif (unlikely(tsk->robust_list))\n\t\texit_robust_list(tsk);\n#ifdef CONFIG_COMPAT\n\tif (unlikely(tsk->compat_robust_list))\n\t\tcompat_exit_robust_list(tsk);\n#endif\n#endif\n\n\tdeactivate_mm(tsk, mm);\n\n\tif (vfork_done) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork_done);\n\t}\n\n\tif (tsk->clear_child_tid\n\t    && !(tsk->flags & PF_SIGNALED)\n\t    && atomic_read(&mm->mm_users) > 1) {\n\t\tu32 __user * tidptr = tsk->clear_child_tid;\n\t\ttsk->clear_child_tid = NULL;\n\n\t\tput_user(0, tidptr);\n\t\tsys_futex(tidptr, FUTEX_WAKE, 1, NULL, NULL, 0);\n\t}\n}",
        "output": "0",
        "idx": 3025
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void uwbd_stop(struct uwb_rc *rc)\n{\n\tkthread_stop(rc->uwbd.task);\n\tuwbd_flush(rc);\n}",
        "output": "1",
        "idx": 1660
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool tls_desc_okay(const struct user_desc *info)\n{\n\tif (LDT_empty(info))\n\t\treturn true;\n\n\tif (!info->seg_32bit)\n\t\treturn false;\n\n\treturn true;\n}",
        "output": "0",
        "idx": 3773
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "INTERNAL void vterm_allocator_free(VTerm *vt, void *ptr)\n{\n  (*vt->allocator->free)(ptr, vt->allocdata);\n}",
        "output": "1",
        "idx": 5834
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "krb5_gss_process_context_token(minor_status, context_handle,\n                               token_buffer)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t token_buffer;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 majerr;\n\n    ctx = (krb5_gss_ctx_id_t) context_handle;\n\n    if (ctx->terminated || !ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    if (ctx->proto) {\n        *minor_status = 0;\n        return(GSS_S_DEFECTIVE_TOKEN);\n    }\n\n\n    if (GSS_ERROR(majerr = kg_unseal(minor_status, context_handle,\n                                     token_buffer,\n                                     GSS_C_NO_BUFFER, NULL, NULL,\n                                     KG_TOK_DEL_CTX)))\n        return(majerr);\n\n    ctx->terminated = 1;\n    return(GSS_S_COMPLETE);\n}",
        "output": "0",
        "idx": 45
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void altivec_unavailable_exception(struct pt_regs *regs)\n{\n#if !defined(CONFIG_ALTIVEC)\n\tif (user_mode(regs)) {\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\treturn;\n\t}\n#endif\n\tprintk(KERN_EMERG \"Unrecoverable VMX/Altivec Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable VMX/Altivec Unavailable Exception\", regs, SIGABRT);\n}",
        "output": "1",
        "idx": 2066
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int handle_emulation_failure(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.insn_emulation_fail;\n\ttrace_kvm_emulate_insn_failed(vcpu);\n\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\tvcpu->run->internal.ndata = 0;\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn EMULATE_FAIL;\n}",
        "output": "1",
        "idx": 248
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int verify_replay(struct xfrm_usersa_info *p,\n\t\t\t\tstruct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_REPLAY_ESN_VAL];\n\tstruct xfrm_replay_state_esn *rs;\n\n\tif (p->flags & XFRM_STATE_ESN) {\n\t\tif (!rt)\n\t\t\treturn -EINVAL;\n\n\t\trs = nla_data(rt);\n\n\t\tif (rs->bmp_len > XFRMA_REPLAY_ESN_MAX / sizeof(rs->bmp[0]) / 8)\n\t\t\treturn -EINVAL;\n\n\t\tif (nla_len(rt) < xfrm_replay_state_esn_len(rs) &&\n\t\t    nla_len(rt) != sizeof(*rs))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rt)\n\t\treturn 0;\n\n\tif (p->id.proto != IPPROTO_ESP)\n\t\treturn -EINVAL;\n\n\tif (p->replay_window != 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1061
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,\n\t\t      int atomic)\n{\n\tunsigned long copy;\n\n\twhile (len > 0) {\n\t\twhile (!iov->iov_len)\n\t\t\tiov++;\n\t\tcopy = min_t(unsigned long, len, iov->iov_len);\n\n\t\tif (atomic) {\n\t\t\tif (__copy_to_user_inatomic(iov->iov_base, from, copy))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tif (copy_to_user(iov->iov_base, from, copy))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\tfrom += copy;\n\t\tlen -= copy;\n\t\tiov->iov_base += copy;\n\t\tiov->iov_len -= copy;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 2536
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xfs_attr_shortform_addname(xfs_da_args_t *args)\n{\n\tint newsize, forkoff, retval;\n\n\ttrace_xfs_attr_sf_addname(args);\n\n\tretval = xfs_attr_shortform_lookup(args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\treturn retval;\n\t\tretval = xfs_attr_shortform_remove(args);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\targs->flags &= ~ATTR_REPLACE;\n\t}\n\n\tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;\n\n\tnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\n\tnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\n\tforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);\n\tif (!forkoff)\n\t\treturn -ENOSPC;\n\n\txfs_attr_shortform_add(args, forkoff);\n\treturn 0;\n}",
        "output": "0",
        "idx": 4073
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint16_t mesg_id (void) {\n\tstatic uint16_t id = 0;\n\n\tif (!id) {\n\t\tsrandom (time (NULL));\n\t\tid = random ();\n\t}\n\tid++;\n\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"mesg_id() = %d\", id);\n\treturn id;\n}",
        "output": "1",
        "idx": 8950
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void bnep_net_setup(struct net_device *dev)\n{\n\n\tmemset(dev->broadcast, 0xff, ETH_ALEN);\n\tdev->addr_len = ETH_ALEN;\n\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->netdev_ops = &bnep_netdev_ops;\n\n\tdev->watchdog_timeo  = HZ * 2;\n}",
        "output": "0",
        "idx": 763
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n{\n\treturn (tsfb->numlvls > 0 && jas_seq2d_size(a)) ?\n\t  jpc_tsfb_synthesize2(tsfb,\n\t  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),\n\t  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),\n\t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;\n}",
        "output": "0",
        "idx": 7485
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\tstruct skcipher_tfm *tfm;\n\tstruct crypto_skcipher *skcipher;\n\n\ttfm = kzalloc(sizeof(*tfm), GFP_KERNEL);\n\tif (!tfm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tskcipher = crypto_alloc_skcipher(name, type, mask);\n\tif (IS_ERR(skcipher)) {\n\t\tkfree(tfm);\n\t\treturn ERR_CAST(skcipher);\n\t}\n\n\ttfm->skcipher = skcipher;\n\n\treturn tfm;\n}",
        "output": "0",
        "idx": 1537
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sysLocation_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_string(varbind, oid, \"\");\n}",
        "output": "1",
        "idx": 7932
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NOEXPORT unsigned __stdcall daemon_thread(void *arg) {\n    (void)arg; \n\n    tls_alloc(NULL, NULL, \"main\"); \n    main_init();\n    SetEvent(main_initialized); \n    while(main_configure(cmdline.config_file, NULL)) {\n        if(cmdline.config_file && *cmdline.config_file=='-')\n            cmdline.config_file=NULL; \n        unbind_ports(); \n        log_flush(LOG_MODE_ERROR); \n        PostMessage(hwnd, WM_INVALID_CONFIG, 0, 0); \n        WaitForSingleObject(config_ready, INFINITE);\n    }\n    PostMessage(hwnd, WM_VALID_CONFIG, 0, 0);\n\n    daemon_loop();\n    main_cleanup();\n    _endthreadex(0); \n    return 0;\n}",
        "output": "1",
        "idx": 8474
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}",
        "output": "1",
        "idx": 3210
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h);\n\tsize_t pos = CDF_SHORT_SEC_POS(h, id);\n\tassert(ss == len);\n\tif (pos > CDF_SEC_SIZE(h) * sst->sst_len) {\n\t\tDPRINTF((\"Out of bounds read %\" SIZE_T_FORMAT \"u > %\"\n\t\t    SIZE_T_FORMAT \"u\\n\",\n\t\t    pos, CDF_SEC_SIZE(h) * sst->sst_len));\n\t\treturn -1;\n\t}\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + pos, len);\n\treturn len;\n}",
        "output": "0",
        "idx": 5059
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\n\tscm->fp = UNIXCB(skb).fp;\n\tUNIXCB(skb).fp = NULL;\n\n\tfor (i = scm->fp->count-1; i >= 0; i--)\n\t\tunix_notinflight(scm->fp->fp[i]);\n}",
        "output": "1",
        "idx": 1068
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void show_object_with_name(FILE *out, struct object *obj, const char *name)\n{\n\tconst char *p;\n\n\tfprintf(out, \"%s \", oid_to_hex(&obj->oid));\n\tfor (p = name; *p && *p != '\\n'; p++)\n\t\tfputc(*p, out);\n\tfputc('\\n', out);\n}",
        "output": "0",
        "idx": 7243
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hb_set_clear (hb_set_t *set)\n{\n  set->clear ();\n}",
        "output": "0",
        "idx": 7773
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int page_name_is_good(char* page_name)\n{\n    if (!page_name)\n        return FALSE;\n\n    if (!isalnum(page[0]))\n        return FALSE;\n\n    if (strstr(page, \"..\"))\n        return FALSE;\n\n    return TRUE;\n}",
        "output": "0",
        "idx": 6155
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateBool(int b)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}",
        "output": "0",
        "idx": 8303
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 18 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {\n\t\thid_info(hdev, \"fixing up Cherry Cymotion report descriptor\\n\");\n\t\trdesc[11] = rdesc[16] = 0xff;\n\t\trdesc[12] = rdesc[17] = 0x03;\n\t}\n\treturn rdesc;\n}",
        "output": "0",
        "idx": 3647
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "qedi_dbg_err(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t     const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_err(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t       func, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_err(\"[0000:00:00.0]:[%s:%d]: %pV\", func, line, &vaf);\n\n\tva_end(va);\n}",
        "output": "0",
        "idx": 4399
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct dentry *dir;\n\tint dir_has_key, cached_with_key;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tdir = dget_parent(dentry);\n\tif (!d_inode(dir)->i_sb->s_cop->is_encrypted(d_inode(dir))) {\n\t\tdput(dir);\n\t\treturn 0;\n\t}\n\n\tspin_lock(&dentry->d_lock);\n\tcached_with_key = dentry->d_flags & DCACHE_ENCRYPTED_WITH_KEY;\n\tspin_unlock(&dentry->d_lock);\n\tdir_has_key = (d_inode(dir)->i_crypt_info != NULL);\n\tdput(dir);\n\n\tif ((!cached_with_key && d_is_negative(dentry)) ||\n\t\t\t(!cached_with_key && dir_has_key) ||\n\t\t\t(cached_with_key && !dir_has_key))\n\t\treturn 0;\n\treturn 1;\n}",
        "output": "0",
        "idx": 2205
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo *hdr;\n    int err;\n\n    if (!*phdr)\n        *phdr = av_mallocz(sizeof(AC3HeaderInfo));\n    if (!*phdr)\n        return AVERROR(ENOMEM);\n    hdr = *phdr;\n\n    init_get_bits8(&gb, buf, size);\n    err = ff_ac3_parse_header(&gb, hdr);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n\n    return get_bits_count(&gb);\n}",
        "output": "1",
        "idx": 3404
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Jsi_RC NumberToStringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[500];\n    int radix = 10, skip = 0, argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    if (argc>skip && (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &radix) != JSI_OK\n        || radix<2))\n        return JSI_ERROR;\n    if (argc==skip)\n        return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);\n    switch (radix) {\n        case 16: snprintf(buf, sizeof(buf), \"%\" PRIx64, (Jsi_Wide)num); break;\n        case 8: snprintf(buf, sizeof(buf), \"%\" PRIo64, (Jsi_Wide)num); break;\n        case 10: snprintf(buf, sizeof(buf), \"%\" PRId64, (Jsi_Wide)num); break;\n        default: return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);\n    }\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}",
        "output": "1",
        "idx": 8200
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iakerb_gss_context_time(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                        OM_uint32 *time_rec)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_context_time(minor_status, ctx->gssc, time_rec);\n}",
        "output": "0",
        "idx": 167
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void big_key_describe(const struct key *key, struct seq_file *m)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\n\tseq_puts(m, key->description);\n\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %zu [%s]\",\n\t\t\t   datalen,\n\t\t\t   datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");\n}",
        "output": "1",
        "idx": 1714
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MprJson *queryLeaf(MprJson *obj, cchar *property, MprJson *value, int flags)\n{\n    MprJson     *child;\n\n    assert(obj);\n    assert(property && *property);\n\n    if (value) {\n        setProperty(obj, sclone(property), value);\n        return 0;\n\n    } else if (flags & MPR_JSON_REMOVE) {\n        if ((child = mprReadJsonObj(obj, property)) != 0) {\n            return mprRemoveJsonChild(obj, child);\n        }\n        return 0;\n\n    } else {\n        return mprCloneJson(mprReadJsonObj(obj, property));\n    }   \n}",
        "output": "0",
        "idx": 7081
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "raptor_libxml_getEntity(void* user_data, const xmlChar *name) {\n  raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  return libxml2_getEntity(sax2->xc, name);\n}",
        "output": "1",
        "idx": 3600
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parse_content_range(URLContext *h, const char *p)\n{\n    HTTPContext *s = h->priv_data;\n    const char *slash;\n\n    if (!strncmp(p, \"bytes \", 6)) {\n        p     += 6;\n        s->off = strtoull(p, NULL, 10);\n        if ((slash = strchr(p, '/')) && strlen(slash) > 0)\n            s->filesize = strtoull(slash + 1, NULL, 10);\n    }\n    if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))\n        h->is_streamed = 0; \n}",
        "output": "0",
        "idx": 4825
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int udp_push_pending_frames(struct sock *sk)\n{\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi4 *fl4 = &inet->cork.fl.u.ip4;\n\tstruct sk_buff *skb;\n\tint err = 0;\n\n\tskb = ip_finish_skb(sk, fl4);\n\tif (!skb)\n\t\tgoto out;\n\n\terr = udp_send_skb(skb, fl4);\n\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}",
        "output": "1",
        "idx": 2308
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __iov_iter_advance_iov(struct iov_iter *i, size_t bytes)\n{\n\tif (likely(i->nr_segs == 1)) {\n\t\ti->iov_offset += bytes;\n\t} else {\n\t\tconst struct iovec *iov = i->iov;\n\t\tsize_t base = i->iov_offset;\n\n\t\twhile (bytes) {\n\t\t\tint copy = min(bytes, iov->iov_len - base);\n\n\t\t\tbytes -= copy;\n\t\t\tbase += copy;\n\t\t\tif (iov->iov_len == base) {\n\t\t\t\tiov++;\n\t\t\t\tbase = 0;\n\t\t\t}\n\t\t}\n\t\ti->iov = iov;\n\t\ti->iov_offset = base;\n\t}\n}",
        "output": "1",
        "idx": 2082
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DefragTimeoutTest(void)\n{\n    int i;\n    int ret = 0;\n\n    if (ConfSet(\"defrag.trackers\", \"16\") != 1) {\n        printf(\"ConfSet failed: \");\n        goto end;\n    }\n\n    DefragInit();\n\n    for (i = 0; i < 16; i++) {\n        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);\n        if (p == NULL)\n            goto end;\n\n        Packet *tp = Defrag(NULL, NULL, p, NULL);\n\n        SCFree(p);\n\n        if (tp != NULL) {\n            SCFree(tp);\n            goto end;\n        }\n    }\n\n    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);\n    if (p == NULL)\n        goto end;\n\n    p->ts.tv_sec += (defrag_context->timeout + 1);\n    Packet *tp = Defrag(NULL, NULL, p, NULL);\n\n    if (tp != NULL) {\n        SCFree(tp);\n        goto end;\n    }\n\n    DefragTracker *tracker = DefragLookupTrackerFromHash(p);\n    if (tracker == NULL)\n        goto end;\n\n    if (tracker->id != 99)\n        goto end;\n\n    SCFree(p);\n\n    ret = 1;\nend:\n    DefragDestroy();\n    return ret;\n}",
        "output": "1",
        "idx": 6578
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void vlan_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\n\tdev->priv_flags\t\t|= IFF_802_1Q_VLAN;\n\tdev->priv_flags\t\t&= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n\tdev->tx_queue_len\t= 0;\n\n\tdev->netdev_ops\t\t= &vlan_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\tdev->ethtool_ops\t= &vlan_ethtool_ops;\n\n\tmemset(dev->broadcast, 0, ETH_ALEN);\n}",
        "output": "0",
        "idx": 761
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int spk_ttyio_ldisc_open(struct tty_struct *tty)\n{\n\tstruct spk_ldisc_data *ldisc_data;\n\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\tspeakup_tty = tty;\n\n\tldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);\n\tif (!ldisc_data)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&ldisc_data->completion);\n\tldisc_data->buf_free = true;\n\tspeakup_tty->disc_data = ldisc_data;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1914
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __iov_iter_advance_iov(struct iov_iter *i, size_t bytes)\n{\n\tif (likely(i->nr_segs == 1)) {\n\t\ti->iov_offset += bytes;\n\t} else {\n\t\tconst struct iovec *iov = i->iov;\n\t\tsize_t base = i->iov_offset;\n\n\t\twhile (bytes || !iov->iov_len) {\n\t\t\tint copy = min(bytes, iov->iov_len - base);\n\n\t\t\tbytes -= copy;\n\t\t\tbase += copy;\n\t\t\tif (iov->iov_len == base) {\n\t\t\t\tiov++;\n\t\t\t\tbase = 0;\n\t\t\t}\n\t\t}\n\t\ti->iov = iov;\n\t\ti->iov_offset = base;\n\t}\n}",
        "output": "0",
        "idx": 2995
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_hrtimer_start(struct snd_timer *t)\n{\n\tstruct snd_hrtimer *stime = t->private_data;\n\n\tatomic_set(&stime->running, 0);\n\thrtimer_try_to_cancel(&stime->hrt);\n\thrtimer_start(&stime->hrt, ns_to_ktime(t->sticks * resolution),\n\t\t      HRTIMER_MODE_REL);\n\tatomic_set(&stime->running, 1);\n\treturn 0;\n}",
        "output": "0",
        "idx": 1545
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int create_user_ns(struct cred *new)\n{\n\tstruct user_namespace *ns, *parent_ns = new->user_ns;\n\tkuid_t owner = new->euid;\n\tkgid_t group = new->egid;\n\tint ret;\n\n\tif (current_chrooted())\n\t\treturn -EPERM;\n\n\tif (!kuid_has_mapping(parent_ns, owner) ||\n\t    !kgid_has_mapping(parent_ns, group))\n\t\treturn -EPERM;\n\n\tns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);\n\tif (!ns)\n\t\treturn -ENOMEM;\n\n\tret = proc_alloc_inum(&ns->proc_inum);\n\tif (ret) {\n\t\tkmem_cache_free(user_ns_cachep, ns);\n\t\treturn ret;\n\t}\n\n\tatomic_set(&ns->count, 1);\n\tns->parent = parent_ns;\n\tns->owner = owner;\n\tns->group = group;\n\n\tset_cred_user_ns(new, ns);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1257
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int wrmsr_interception(struct vcpu_svm *svm)\n{\n\tstruct msr_data msr;\n\tu32 ecx = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\tu64 data = (svm->vcpu.arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(svm->vcpu.arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tif (kvm_set_msr(&svm->vcpu, &msr)) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t} else {\n\t\ttrace_kvm_msr_write(ecx, data);\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}",
        "output": "0",
        "idx": 3729
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int translate_desc(struct vhost_dev *dev, u64 addr, u32 len,\n\t\t\t  struct iovec iov[], int iov_size)\n{\n\tconst struct vhost_memory_region *reg;\n\tstruct vhost_memory *mem;\n\tstruct iovec *_iov;\n\tu64 s = 0;\n\tint ret = 0;\n\n\trcu_read_lock();\n\n\tmem = rcu_dereference(dev->memory);\n\twhile ((u64)len > s) {\n\t\tu64 size;\n\t\tif (unlikely(ret >= iov_size)) {\n\t\t\tret = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\treg = find_region(mem, addr, len);\n\t\tif (unlikely(!reg)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\t_iov = iov + ret;\n\t\tsize = reg->memory_size - addr + reg->guest_phys_addr;\n\t\t_iov->iov_len = min((u64)len, size);\n\t\t_iov->iov_base = (void __user *)(unsigned long)\n\t\t\t(reg->userspace_addr + addr - reg->guest_phys_addr);\n\t\ts += size;\n\t\taddr += size;\n\t\t++ret;\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}",
        "output": "1",
        "idx": 796
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "smb_ofile_flush(struct smb_request *sr, struct smb_ofile *of)\n{\n\tswitch (of->f_ftype) {\n\tcase SMB_FTYPE_DISK:\n\t\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
        "output": "0",
        "idx": 6861
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ntlm_populate_message_header(NTLM_MESSAGE_HEADER* header, UINT32 MessageType)\n{\n\tCopyMemory(header->Signature, NTLM_SIGNATURE, sizeof(NTLM_SIGNATURE));\n\theader->MessageType = MessageType;\n}",
        "output": "0",
        "idx": 5801
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int flakey_ioctl(struct dm_target *ti, unsigned int cmd, unsigned long arg)\n{\n\tstruct flakey_c *fc = ti->private;\n\n\treturn __blkdev_driver_ioctl(fc->dev->bdev, fc->dev->mode, cmd, arg);\n}",
        "output": "1",
        "idx": 666
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "handle_associated_event(struct cpu_hw_events *cpuc,\n\tint idx, struct perf_sample_data *data, struct pt_regs *regs)\n{\n\tstruct perf_event *event = cpuc->events[idx];\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tmipspmu_event_update(event, hwc, idx);\n\tdata->period = event->hw.last_period;\n\tif (!mipspmu_event_set_period(event, hwc, idx))\n\t\treturn;\n\n\tif (perf_event_overflow(event, data, regs))\n\t\tmipspmu->disable_event(idx);\n}",
        "output": "0",
        "idx": 583
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "kg_unseal_iov(OM_uint32 *minor_status,\n              gss_ctx_id_t context_handle,\n              int *conf_state,\n              gss_qop_t *qop_state,\n              gss_iov_buffer_desc *iov,\n              int iov_count,\n              int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 code;\n\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (!ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n\n    if (kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_STREAM) != NULL) {\n        code = kg_unseal_stream_iov(minor_status, ctx, conf_state, qop_state,\n                                    iov, iov_count, toktype);\n    } else {\n        code = kg_unseal_iov_token(minor_status, ctx, conf_state, qop_state,\n                                   iov, iov_count, toktype);\n    }\n\n    return code;\n}",
        "output": "1",
        "idx": 32
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "AP_DECLARE(int) ap_some_authn_required(request_rec *r)\n{\n    int access_status;\n\n    switch (ap_satisfies(r)) {\n    case SATISFY_ALL:\n    case SATISFY_NOSPEC:\n        if ((access_status = ap_run_access_checker(r)) != OK) {\n            break;\n        }\n\n        access_status = ap_run_access_checker_ex(r);\n        if (access_status == DECLINED) {\n            return TRUE;\n        }\n\n        break;\n    case SATISFY_ANY:\n        if ((access_status = ap_run_access_checker(r)) == OK) {\n            break;\n        }\n\n        access_status = ap_run_access_checker_ex(r);\n        if (access_status == DECLINED) {\n            return TRUE;\n        }\n\n        break;\n    }\n\n    return FALSE;\n}",
        "output": "0",
        "idx": 6459
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateFalse( void )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item )\n\t\titem->type = cJSON_False;\n\treturn item;\n}",
        "output": "1",
        "idx": 5926
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) \n{\n\tif (prev_options != NULL) {\n\t\t*prev_options = MBREX(regex_default_options);\n\t}\n\tif (prev_syntax != NULL) {\n\t\t*prev_syntax = MBREX(regex_default_syntax);\n\t}\n\tMBREX(regex_default_options) = options;\n\tMBREX(regex_default_syntax) = syntax;\n}",
        "output": "1",
        "idx": 4050
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static FILE * pw_tmpfile(int lockfd)\n{\n\tFILE *fd;\n\tchar *tmpname = NULL;\n\tchar *dir = \"/etc\";\n\n\tif ((fd = xfmkstemp(&tmpname, dir)) == NULL) {\n\t\tulckpwdf();\n\t\terr(EXIT_FAILURE, _(\"can't open temporary file\"));\n\t}\n\n\tcopyfile(lockfd, fileno(fd));\n\ttmp_file = tmpname;\n\treturn fd;\n}",
        "output": "1",
        "idx": 4654
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void encode_share_access(struct xdr_stream *xdr, int open_flags)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(8);\n\tswitch (open_flags & (FMODE_READ|FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_READ);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_WRITE);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_BOTH);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\tWRITE32(0);\t\t\n}",
        "output": "1",
        "idx": 2176
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static size_t consume_init_expr (ut8 *buf, ut8 *max, ut8 eoc, void *out, ut32 *offset) {\n\tut32 i = 0;\n\twhile (buf + i < max && buf[i] != eoc) {\n\t\ti += 1;\n\t}\n\tif (buf[i] != eoc) {\n\t\treturn 0;\n\t}\n\tif (offset) {\n\t\t*offset += i + 1;\n\t}\n\treturn i + 1;\n}",
        "output": "1",
        "idx": 6142
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *print_string(cJSON *item,printbuffer *p)\t{return print_string_ptr(item->valuestring,p);}",
        "output": "0",
        "idx": 8323
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileInfo, __construct)\n{\n\tspl_filesystem_object *intern;\n\tchar *path;\n\tint len;\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &path, &len) == FAILURE) {\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\treturn;\n\t}\n\n\tintern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tspl_filesystem_info_set_filename(intern, path, len, 1 TSRMLS_CC);\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\n}",
        "output": "0",
        "idx": 5539
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_cryptgenrandom_seed()\n{\n    DEBUG_SEED(\"get_cryptgenrandom_seed\");\n    \n    HCRYPTPROV hProvider = 0;\n    int r;\n    \n    if (!CryptAcquireContextW(&hProvider, 0, 0, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT | CRYPT_SILENT)) {\n        fprintf(stderr, \"error CryptAcquireContextW\");\n        exit(1);\n    }\n    \n    if (!CryptGenRandom(hProvider, sizeof(r), (BYTE*)&r)) {\n        fprintf(stderr, \"error CryptGenRandom\");\n        exit(1);\n    }\n    \n    CryptReleaseContext(hProvider, 0);\n    \n    return r;\n}",
        "output": "0",
        "idx": 5957
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_task(rq->curr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rq->curr->se.on_rq && test_tsk_need_resched(rq->curr))\n\t\trq->skip_clock_update = 1;\n}",
        "output": "0",
        "idx": 353
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "lldpd_alloc_mgmt(int family, void *addrptr, size_t addrsize, u_int32_t iface)\n{\n\tstruct lldpd_mgmt *mgmt;\n\n\tlog_debug(\"alloc\", \"allocate a new management address (family: %d)\", family);\n\n\tif (family <= LLDPD_AF_UNSPEC || family >= LLDPD_AF_LAST) {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn NULL;\n\t}\n\tif (addrsize > LLDPD_MGMT_MAXADDRSIZE) {\n\t\terrno = EOVERFLOW;\n\t\treturn NULL;\n\t}\n\tmgmt = calloc(1, sizeof(struct lldpd_mgmt));\n\tif (mgmt == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tmgmt->m_family = family;\n\tassert(addrsize <= LLDPD_MGMT_MAXADDRSIZE);\n\tmemcpy(&mgmt->m_addr, addrptr, addrsize);\n\tmgmt->m_addrsize = addrsize;\n\tmgmt->m_iface = iface;\n\treturn mgmt;\n}",
        "output": "1",
        "idx": 5468
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tint i;\n\tfprintf(out, \"qntsty = %d; numguard = %d; numstepsizes = %d\\n\",\n\t  (int) qcd->compparms.qntsty, qcd->compparms.numguard, qcd->compparms.numstepsizes);\n\tfor (i = 0; i < qcd->compparms.numstepsizes; ++i) {\n\t\tfprintf(out, \"expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n\",\n\t\t  i, (unsigned) JPC_QCX_GETEXPN(qcd->compparms.stepsizes[i]),\n\t\t  i, (unsigned) JPC_QCX_GETMANT(qcd->compparms.stepsizes[i]));\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 5364
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int blkcg_init_queue(struct request_queue *q)\n{\n\tstruct blkcg_gq *new_blkg, *blkg;\n\tbool preloaded;\n\tint ret;\n\n\tnew_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);\n\tif (!new_blkg)\n\t\treturn -ENOMEM;\n\n\tpreloaded = !radix_tree_preload(GFP_KERNEL);\n\n\trcu_read_lock();\n\tspin_lock_irq(q->queue_lock);\n\tblkg = blkg_create(&blkcg_root, q, new_blkg);\n\tspin_unlock_irq(q->queue_lock);\n\trcu_read_unlock();\n\n\tif (preloaded)\n\t\tradix_tree_preload_end();\n\n\tif (IS_ERR(blkg))\n\t\treturn PTR_ERR(blkg);\n\n\tq->root_blkg = blkg;\n\tq->root_rl.blkg = blkg;\n\n\tret = blk_throtl_init(q);\n\tif (ret) {\n\t\tspin_lock_irq(q->queue_lock);\n\t\tblkg_destroy_all(q);\n\t\tspin_unlock_irq(q->queue_lock);\n\t}\n\treturn ret;\n}",
        "output": "0",
        "idx": 2121
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\tif (key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\n\t\tsecurity_key_free(key);\n\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\n\t\tkey_user_put(key->user);\n\n\t\tkfree(key->description);\n\n#ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}",
        "output": "1",
        "idx": 2928
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void m_stop(struct seq_file *m, void *v)\n{\n\tstruct proc_maps_private *priv = m->private;\n\tstruct vm_area_struct *vma = v;\n\n\tif (!IS_ERR(vma))\n\t\tvma_stop(priv, vma);\n\tif (priv->task)\n\t\tput_task_struct(priv->task);\n}",
        "output": "0",
        "idx": 423
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE cState_indent_set(VALUE self, VALUE indent)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(indent, T_STRING);\n    len = RSTRING_LEN(indent);\n    if (len == 0) {\n        if (state->indent) {\n            ruby_xfree(state->indent);\n            state->indent = NULL;\n            state->indent_len = 0;\n        }\n    } else {\n        if (state->indent) ruby_xfree(state->indent);\n        state->indent = fstrndup(RSTRING_PTR(indent), len);\n        state->indent_len = len;\n    }\n    return Qnil;\n}",
        "output": "0",
        "idx": 8807
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mainloop_destroy_trigger(crm_trigger_t * source)\n{\n    source->trigger = FALSE;\n    if (source->id > 0) {\n        g_source_remove(source->id);\n        source->id = 0;\n    }\n    return TRUE;\n}",
        "output": "0",
        "idx": 5243
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int serdes_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *provider;\n\tstruct serdes_ctrl *ctrl;\n\tunsigned int i;\n\tint ret;\n\n\tctrl = devm_kzalloc(&pdev->dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\n\tctrl->dev = &pdev->dev;\n\tctrl->regs = syscon_node_to_regmap(pdev->dev.parent->of_node);\n\tif (IS_ERR(ctrl->regs))\n\t\treturn PTR_ERR(ctrl->regs);\n\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tret = serdes_phy_create(ctrl, i, &ctrl->phys[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdev_set_drvdata(&pdev->dev, ctrl);\n\n\tprovider = devm_of_phy_provider_register(ctrl->dev,\n\t\t\t\t\t\t serdes_simple_xlate);\n\n\treturn PTR_ERR_OR_ZERO(provider);\n}",
        "output": "1",
        "idx": 3024
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TIFFFlushData1(TIFF* tif)\n{\n\tif (tif->tif_rawcc > 0 && tif->tif_flags & TIFF_BUF4WRITE ) {\n\t\tif (!isFillOrder(tif, tif->tif_dir.td_fillorder) &&\n\t\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\t\tTIFFReverseBits((uint8*)tif->tif_rawdata,\n\t\t\t    tif->tif_rawcc);\n\t\tif (!TIFFAppendToStrip(tif,\n\t\t    isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip,\n\t\t    tif->tif_rawdata, tif->tif_rawcc))\n        {\n            tif->tif_rawcc = 0;\n            tif->tif_rawcp = tif->tif_rawdata;\n\t\t\treturn (0);\n        }\n\t\ttif->tif_rawcc = 0;\n\t\ttif->tif_rawcp = tif->tif_rawdata;\n\t}\n\treturn (1);\n}",
        "output": "0",
        "idx": 5871
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint32_t virtio_config_readw(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint16_t val;\n\n    k->get_config(vdev, vdev->config);\n\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n\n    val = lduw_p(vdev->config + addr);\n    return val;\n}",
        "output": "1",
        "idx": 3760
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sctp_setsockopt_auto_asconf(struct sock *sk, char __user *optval,\n\t\t\t\t\tunsigned int optlen)\n{\n\tint val;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\tif (!sctp_is_ep_boundall(sk) && val)\n\t\treturn -EINVAL;\n\tif ((val && sp->do_auto_asconf) || (!val && !sp->do_auto_asconf))\n\t\treturn 0;\n\n\tspin_lock_bh(&sock_net(sk)->sctp.addr_wq_lock);\n\tif (val == 0 && sp->do_auto_asconf) {\n\t\tlist_del(&sp->auto_asconf_list);\n\t\tsp->do_auto_asconf = 0;\n\t} else if (val && !sp->do_auto_asconf) {\n\t\tlist_add_tail(&sp->auto_asconf_list,\n\t\t    &sock_net(sk)->sctp.auto_asconf_splist);\n\t\tsp->do_auto_asconf = 1;\n\t}\n\tspin_unlock_bh(&sock_net(sk)->sctp.addr_wq_lock);\n\treturn 0;\n}",
        "output": "0",
        "idx": 3965
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int _nfs4_do_open_reclaim(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs4_opendata *opendata;\n\tfmode_t delegation_type = 0;\n\tint status;\n\n\topendata = nfs4_open_recoverdata_alloc(ctx, state);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\topendata->o_arg.claim = NFS4_OPEN_CLAIM_PREVIOUS;\n\topendata->o_arg.fh = NFS_FH(state->inode);\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(state->inode)->delegation);\n\tif (delegation != NULL && test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) != 0)\n\t\tdelegation_type = delegation->type;\n\trcu_read_unlock();\n\topendata->o_arg.u.delegation_type = delegation_type;\n\tstatus = nfs4_open_recover(opendata, state);\n\tnfs4_opendata_put(opendata);\n\treturn status;\n}",
        "output": "0",
        "idx": 3029
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main(int argc, char **argv)\n{\n    gdImagePtr im;\n    FILE *fp = gdTestFileOpen(\"tga/bug00247a.tga\");\n    im = gdImageCreateFromTga(fp);\n    gdTestAssert(im == NULL);\n    fclose(fp);\n    return gdNumFailures();\n}",
        "output": "0",
        "idx": 6255
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int compat_get_timex(struct timex *txc, const struct compat_timex __user *utp)\n{\n\tstruct compat_timex tx32;\n\n\tmemset(txc, 0, sizeof(struct timex));\n\tif (copy_from_user(&tx32, utp, sizeof(struct compat_timex)))\n\t\treturn -EFAULT;\n\n\ttxc->modes = tx32.modes;\n\ttxc->offset = tx32.offset;\n\ttxc->freq = tx32.freq;\n\ttxc->maxerror = tx32.maxerror;\n\ttxc->esterror = tx32.esterror;\n\ttxc->status = tx32.status;\n\ttxc->constant = tx32.constant;\n\ttxc->precision = tx32.precision;\n\ttxc->tolerance = tx32.tolerance;\n\ttxc->time.tv_sec = tx32.time.tv_sec;\n\ttxc->time.tv_usec = tx32.time.tv_usec;\n\ttxc->tick = tx32.tick;\n\ttxc->ppsfreq = tx32.ppsfreq;\n\ttxc->jitter = tx32.jitter;\n\ttxc->shift = tx32.shift;\n\ttxc->stabil = tx32.stabil;\n\ttxc->jitcnt = tx32.jitcnt;\n\ttxc->calcnt = tx32.calcnt;\n\ttxc->errcnt = tx32.errcnt;\n\ttxc->stbcnt = tx32.stbcnt;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 4079
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void trustedSetEncryptedDkgPolyAES(int *errStatus, char *errString, uint8_t *encrypted_poly, uint32_t enc_len) {\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_poly);\n\n    memset(getThreadLocalDecryptedDkgPoly(), 0, DKG_BUFER_LENGTH);\n\n    int status = AES_decrypt(encrypted_poly, enc_len, (char *) getThreadLocalDecryptedDkgPoly(),\n                             DKG_BUFER_LENGTH);\n\n    CHECK_STATUS2(\"sgx_unseal_data - encrypted_poly failed with status %d\")\n\n    SET_SUCCESS\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}",
        "output": "1",
        "idx": 8702
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ntlm_print_negotiate_flags(UINT32 flags)\n{\n\tint i;\n\tconst char* str;\n\tWLog_INFO(TAG, \"negotiateFlags \\\"0x%08\"PRIX32\"\\\"\", flags);\n\n\tfor (i = 31; i >= 0; i--)\n\t{\n\t\tif ((flags >> i) & 1)\n\t\t{\n\t\t\tstr = NTLM_NEGOTIATE_STRINGS[(31 - i)];\n\t\t\tWLog_INFO(TAG, \"\\t%s (%d),\", str, (31 - i));\n\t\t}\n\t}\n}",
        "output": "0",
        "idx": 5805
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hgcm_call_preprocess_linaddr(\n\tconst struct vmmdev_hgcm_function_parameter *src_parm,\n\tvoid **bounce_buf_ret, size_t *extra)\n{\n\tvoid *buf, *bounce_buf;\n\tbool copy_in;\n\tu32 len;\n\tint ret;\n\n\tbuf = (void *)src_parm->u.pointer.u.linear_addr;\n\tlen = src_parm->u.pointer.size;\n\tcopy_in = src_parm->type != VMMDEV_HGCM_PARM_TYPE_LINADDR_OUT;\n\n\tif (len > VBG_MAX_HGCM_USER_PARM)\n\t\treturn -E2BIG;\n\n\tbounce_buf = kvmalloc(len, GFP_KERNEL);\n\tif (!bounce_buf)\n\t\treturn -ENOMEM;\n\n\t*bounce_buf_ret = bounce_buf;\n\n\tif (copy_in) {\n\t\tret = copy_from_user(bounce_buf, (void __user *)buf, len);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemset(bounce_buf, 0, len);\n\t}\n\n\thgcm_call_add_pagelist_size(bounce_buf, len, extra);\n\treturn 0;\n}",
        "output": "0",
        "idx": 4555
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileInfo, getFilename)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tint path_len;\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_filesystem_object_get_path(intern, &path_len TSRMLS_CC);\n\t\n\tif (path_len && path_len < intern->file_name_len) {\n\t\tRETURN_STRINGL(intern->file_name + path_len + 1, intern->file_name_len - (path_len + 1), 1);\n\t} else {\n\t\tRETURN_STRINGL(intern->file_name, intern->file_name_len, 1);\n\t}\n}",
        "output": "1",
        "idx": 4032
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cil_reset_classpermission(struct cil_classpermission *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\n\tcil_reset_classperms_list(cp->classperms);\n}",
        "output": "1",
        "idx": 6044
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_import_sec_context(\n\tOM_uint32\t\t*minor_status,\n\tconst gss_buffer_t\tinterprocess_token,\n\tgss_ctx_id_t\t\t*context_handle)\n{\n\treturn GSS_S_UNAVAILABLE;\n}",
        "output": "0",
        "idx": 113
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void opt_kfree_rcu(struct rcu_head *head)\n{\n\tkfree(container_of(head, struct ip_options_rcu, rcu));\n}",
        "output": "0",
        "idx": 463
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ikev1_ke_print(netdissect_options *ndo, u_char tpay _U_,\n\t       const struct isakmp_gen *ext, u_int item_len _U_,\n\t       const u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t       uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_KE)));\n\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" key len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_KE)));\n\treturn NULL;\n}",
        "output": "0",
        "idx": 6799
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gnutls_x509_crt_verify (gnutls_x509_crt_t cert,\n\t\t\tconst gnutls_x509_crt_t * CA_list,\n\t\t\tint CA_list_length, unsigned int flags,\n\t\t\tunsigned int *verify)\n{\n  int ret;\n  ret =\n    _gnutls_verify_certificate2 (cert, CA_list, CA_list_length, flags,\n\t\t\t\t verify, NULL);\n  if (ret < 0)\n    {\n      gnutls_assert ();\n      return ret;\n    }\n\n  return 0;\n}",
        "output": "0",
        "idx": 6465
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ion_handle_put_nolock(struct ion_handle *handle)\n{\n\tint ret;\n\n\tret = kref_put(&handle->ref, ion_handle_destroy);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 1693
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct bpf_verifier_state *push_stack(struct bpf_verifier_env *env,\n\t\t\t\t\t     int insn_idx, int prev_insn_idx,\n\t\t\t\t\t     bool speculative)\n{\n\tstruct bpf_verifier_state *cur = env->cur_state;\n\tstruct bpf_verifier_stack_elem *elem;\n\tint err;\n\n\telem = kzalloc(sizeof(struct bpf_verifier_stack_elem), GFP_KERNEL);\n\tif (!elem)\n\t\tgoto err;\n\n\telem->insn_idx = insn_idx;\n\telem->prev_insn_idx = prev_insn_idx;\n\telem->next = env->head;\n\tenv->head = elem;\n\tenv->stack_size++;\n\terr = copy_verifier_state(&elem->st, cur);\n\tif (err)\n\t\tgoto err;\n\telem->st.speculative |= speculative;\n\tif (env->stack_size > BPF_COMPLEXITY_LIMIT_STACK) {\n\t\tverbose(env, \"BPF program is too complex\\n\");\n\t\tgoto err;\n\t}\n\treturn &elem->st;\nerr:\n\tfree_verifier_state(env->cur_state, true);\n\tenv->cur_state = NULL;\n\twhile (!pop_stack(env, NULL, NULL));\n\treturn NULL;\n}",
        "output": "0",
        "idx": 4197
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_report_kpp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_kpp rkpp;\n\n\tstrncpy(rkpp.type, \"kpp\", sizeof(rkpp.type));\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_KPP,\n\t\t    sizeof(struct crypto_report_kpp), &rkpp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "0",
        "idx": 4173
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SWFInput_readSBits(SWFInput input, int number)\n{\n\tint num = SWFInput_readBits(input, number);\n\n\tif ( num & (1<<(number-1)) )\n\t\treturn num - (1<<number);\n\telse\n\t\treturn num;\n}",
        "output": "1",
        "idx": 7456
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void bpf_map_inc(struct bpf_map *map, bool uref)\n{\n\tatomic_inc(&map->refcnt);\n\tif (uref)\n\t\tatomic_inc(&map->usercnt);\n}",
        "output": "1",
        "idx": 1250
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= user_match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}",
        "output": "1",
        "idx": 2680
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC cchar *mprGetJson(MprJson *obj, cchar *key)\n{\n    MprJson      *result;\n\n    if (key && !strpbrk(key, \".[]*\")) {\n        return mprLookupJson(obj, key);\n    }\n    if ((result = mprQueryJson(obj, key, 0, 0)) != 0) {\n        if (result->length == 1 && result->children->type & MPR_JSON_VALUE) {\n            return result->children->value;\n        } else if (result->length > 1) {\n            return mprJsonToString(result, 0);\n        }\n    }\n    return 0;\n}",
        "output": "1",
        "idx": 5110
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MprJson *setProperty(MprJson *obj, cchar *name, MprJson *child)\n{\n    MprJson      *prior, *existing;\n\n    if (!obj || !child) {\n        return 0;\n    }\n    if ((existing = mprReadJsonObj(obj, name)) != 0) {\n        existing->value = child->value;\n        existing->children = child->children;\n        existing->type = child->type;\n        existing->length = child->length;\n        return existing;\n    } \n    if (obj->children) {\n        prior = obj->children->prev;\n        child->next = obj->children;\n        child->prev = prior;\n        prior->next->prev = child;\n        prior->next = child;\n    } else {\n        child->next = child->prev = child;\n        obj->children = child;\n    }\n    child->name = name;\n    obj->length++;\n    return child;\n}",
        "output": "0",
        "idx": 7089
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void hugetlb_vm_op_close(struct vm_area_struct *vma)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct resv_map *reservations = vma_resv_map(vma);\n\tstruct hugepage_subpool *spool = subpool_vma(vma);\n\tunsigned long reserve;\n\tunsigned long start;\n\tunsigned long end;\n\n\tif (reservations) {\n\t\tstart = vma_hugecache_offset(h, vma, vma->vm_start);\n\t\tend = vma_hugecache_offset(h, vma, vma->vm_end);\n\n\t\treserve = (end - start) -\n\t\t\tregion_count(&reservations->regions, start, end);\n\n\t\tkref_put(&reservations->refs, resv_map_release);\n\n\t\tif (reserve) {\n\t\t\thugetlb_acct_memory(h, -reserve);\n\t\t\thugepage_subpool_put_pages(spool, reserve);\n\t\t}\n\t}\n}",
        "output": "0",
        "idx": 915
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sunkbd_set_leds_beeps(struct sunkbd *sunkbd)\n{\n\tserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\n\tserio_write(sunkbd->serio,\n\t\t(!!test_bit(LED_CAPSL,   sunkbd->dev->led) << 3) |\n\t\t(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |\n\t\t(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |\n\t\t !!test_bit(LED_NUML,    sunkbd->dev->led));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));\n}",
        "output": "0",
        "idx": 2763
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "translate_hex_string(char *s, char *saved_orphan)\n{\n  int c1 = *saved_orphan;\n  char *start = s;\n  char *t = s;\n  for (; *s; s++) {\n    if (isspace(*s))\n      continue;\n    if (c1) {\n      *t++ = (hexval(c1) << 4) + hexval(*s);\n      c1 = 0;\n    } else\n      c1 = *s;\n  }\n  *saved_orphan = c1;\n  return t - start;\n}",
        "output": "1",
        "idx": 5306
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_timer_start_slave(struct snd_timer_instance *timeri)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&slave_active_lock, flags);\n\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\tif (timeri->master)\n\t\tlist_add_tail(&timeri->active_list,\n\t\t\t      &timeri->master->slave_active_head);\n\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\treturn 1; \n}",
        "output": "1",
        "idx": 1046
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int xrstor_state(struct xsave_struct *fx, u64 mask)\n{\n\tint err = 0;\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\n\talternative_input(\n\t\t\"1: \" XRSTOR,\n\t\t\"1: \" XRSTORS,\n\t\tX86_FEATURE_XSAVES,\n\t\t\"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t: \"memory\");\n\n\tasm volatile(\"2:\\n\"\n\t\t     xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\n\treturn err;\n}",
        "output": "1",
        "idx": 2800
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ext2_xattr_put_super(struct super_block *sb)\n{\n}",
        "output": "1",
        "idx": 1122
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "AsyncFunctionDef(identifier name, arguments_ty args, asdl_seq * body, asdl_seq\n                 * decorator_list, expr_ty returns, int lineno, int col_offset,\n                 int end_lineno, int end_col_offset, PyArena *arena)\n{\n    stmt_ty p;\n    if (!name) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field name is required for AsyncFunctionDef\");\n        return NULL;\n    }\n    if (!args) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field args is required for AsyncFunctionDef\");\n        return NULL;\n    }\n    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->kind = AsyncFunctionDef_kind;\n    p->v.AsyncFunctionDef.name = name;\n    p->v.AsyncFunctionDef.args = args;\n    p->v.AsyncFunctionDef.body = body;\n    p->v.AsyncFunctionDef.decorator_list = decorator_list;\n    p->v.AsyncFunctionDef.returns = returns;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    p->end_lineno = end_lineno;\n    p->end_col_offset = end_col_offset;\n    return p;\n}",
        "output": "1",
        "idx": 7178
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static uint get_alen(char *arg, int default_len)\n{\n\tint\tj;\n\tint\talen;\n\n\talen = default_len;\n\tfor (j = 0; j < 8; j++) {\n\t\tif (arg[j] == '.') {\n\t\t\talen = arg[j+1] - '0';\n\t\t\tbreak;\n\t\t} else if (arg[j] == '\\0')\n\t\t\tbreak;\n\t}\n\treturn alen;\n}",
        "output": "1",
        "idx": 7398
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int crypto_rng_generate(struct crypto_rng *tfm,\n\t\t\t\t      const u8 *src, unsigned int slen,\n\t\t\t\t      u8 *dst, unsigned int dlen)\n{\n\treturn crypto_rng_alg(tfm)->generate(tfm, src, slen, dst, dlen);\n}",
        "output": "0",
        "idx": 3937
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ecryptfs_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct file *lower_file = ecryptfs_file_to_lower(file);\n\tif (!lower_file->f_op->mmap)\n\t\treturn -ENODEV;\n\treturn generic_file_mmap(file, vma);\n}",
        "output": "0",
        "idx": 1909
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(linkinfo)\n{\n\tchar *link;\n\tchar *dirname;\n\tsize_t link_len;\n\tzend_stat_t sb;\n\tint ret;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"p\", &link, &link_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tdirname = estrndup(link, link_len);\n\tphp_dirname(dirname, link_len);\n\n\tif (php_check_open_basedir(dirname)) {\n\t\tefree(dirname);\n\t\tRETURN_FALSE;\n\t}\n\n\tret = VCWD_STAT(link, &sb);\n\tif (ret == -1) {\n\t\tphp_error_docref(NULL, E_WARNING, \"%s\", strerror(errno));\n\t\tefree(dirname);\n\t\tRETURN_LONG(Z_L(-1));\n\t}\n\n\tefree(dirname);\n\tRETURN_LONG((zend_long) sb.st_dev);\n}",
        "output": "0",
        "idx": 5683
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "aiff_read_chanmap (SF_PRIVATE * psf, unsigned dword)\n{\tconst AIFF_CAF_CHANNEL_MAP * map_info ;\n\tunsigned channel_bitmap, channel_decriptions, bytesread ;\n\tint layout_tag ;\n\n\tbytesread = psf_binheader_readf (psf, \"444\", &layout_tag, &channel_bitmap, &channel_decriptions) ;\n\n\tif ((map_info = aiff_caf_of_channel_layout_tag (layout_tag)) == NULL)\n\t\treturn 0 ;\n\n\tpsf_log_printf (psf, \"  Tag    : %x\\n\", layout_tag) ;\n\tif (map_info)\n\t\tpsf_log_printf (psf, \"  Layout : %s\\n\", map_info->name) ;\n\n\tif (bytesread < dword)\n\t\tpsf_binheader_readf (psf, \"j\", dword - bytesread) ;\n\n\tif (map_info->channel_map != NULL)\n\t{\tsize_t chanmap_size = psf->sf.channels * sizeof (psf->channel_map [0]) ;\n\n\t\tfree (psf->channel_map) ;\n\n\t\tif ((psf->channel_map = malloc (chanmap_size)) == NULL)\n\t\t\treturn SFE_MALLOC_FAILED ;\n\n\t\tmemcpy (psf->channel_map, map_info->channel_map, chanmap_size) ;\n\t\t} ;\n\n\treturn 0 ;\n} ",
        "output": "1",
        "idx": 4912
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init ipgre_init(void)\n{\n\tint err;\n\n\tprintk(KERN_INFO \"GRE over IPv4 tunneling driver\\n\");\n\n\terr = register_pernet_device(&ipgre_net_ops);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = inet_add_protocol(&ipgre_protocol, IPPROTO_GRE);\n\tif (err < 0) {\n\t\tprintk(KERN_INFO \"ipgre init: can't add protocol\\n\");\n\t\tgoto add_proto_failed;\n\t}\n\n\terr = rtnl_link_register(&ipgre_link_ops);\n\tif (err < 0)\n\t\tgoto rtnl_link_failed;\n\n\terr = rtnl_link_register(&ipgre_tap_ops);\n\tif (err < 0)\n\t\tgoto tap_ops_failed;\n\nout:\n\treturn err;\n\ntap_ops_failed:\n\trtnl_link_unregister(&ipgre_link_ops);\nrtnl_link_failed:\n\tinet_del_protocol(&ipgre_protocol, IPPROTO_GRE);\nadd_proto_failed:\n\tunregister_pernet_device(&ipgre_net_ops);\n\tgoto out;\n}",
        "output": "0",
        "idx": 3135
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "feed_table_block_tag(struct table *tbl,\n\t\t     char *line, struct table_mode *mode, int indent, int cmd)\n{\n    int offset;\n    if (mode->indent_level <= 0 && indent == -1)\n\treturn;\n    if (mode->indent_level >= CHAR_MAX && indent == 1)\n\treturn;\n    setwidth(tbl, mode);\n    feed_table_inline_tag(tbl, line, mode, -1);\n    clearcontentssize(tbl, mode);\n    if (indent == 1) {\n\tmode->indent_level++;\n\tif (mode->indent_level <= MAX_INDENT_LEVEL)\n\t    tbl->indent += INDENT_INCR;\n    }\n    else if (indent == -1) {\n\tmode->indent_level--;\n\tif (mode->indent_level < MAX_INDENT_LEVEL)\n\t    tbl->indent -= INDENT_INCR;\n    }\n    if (tbl->indent < 0)\n\ttbl->indent = 0;\n    offset = tbl->indent;\n    if (cmd == HTML_DT) {\n\tif (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)\n\t    offset -= INDENT_INCR;\n\tif (offset < 0)\n\t    offset = 0;\n    }\n    if (tbl->indent > 0) {\n\tcheck_minimum0(tbl, 0);\n\taddcontentssize(tbl, offset);\n    }\n}",
        "output": "0",
        "idx": 8537
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "juniper_mlfr_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n\n        l2info.pictype = DLT_JUNIPER_MLFR;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n\n        p+=l2info.header_len;\n\n        if (ndo->ndo_eflag && EXTRACT_32BITS(l2info.cookie) != 1)\n            ND_PRINT((ndo, \"Bundle-ID %u, \", l2info.bundle));\n        switch (l2info.proto) {\n        case (LLC_UI):\n        case (LLC_UI<<8):\n            isoclns_print(ndo, p, l2info.length, l2info.caplen);\n            break;\n        case (LLC_UI<<8 | NLPID_Q933):\n        case (LLC_UI<<8 | NLPID_IP):\n        case (LLC_UI<<8 | NLPID_IP6):\n            isoclns_print(ndo, p - 1, l2info.length + 1, l2info.caplen + 1);\n            break;\n        default:\n            ND_PRINT((ndo, \"unknown protocol 0x%04x, length %u\", l2info.proto, l2info.length));\n        }\n\n        return l2info.header_len;\n}",
        "output": "1",
        "idx": 4684
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void php_mb_regex_free_cache(php_mb_regex_t **pre) \n{\n\tonig_free(*pre);\n}",
        "output": "1",
        "idx": 4038
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "id3_skip (SF_PRIVATE * psf)\n{\tunsigned char\tbuf [10] ;\n\n\tmemset (buf, 0, sizeof (buf)) ;\n\tpsf_binheader_readf (psf, \"pb\", 0, buf, 10) ;\n\n\tif (buf [0] == 'I' && buf [1] == 'D' && buf [2] == '3')\n\t{\tint\toffset = buf [6] & 0x7f ;\n\t\toffset = (offset << 7) | (buf [7] & 0x7f) ;\n\t\toffset = (offset << 7) | (buf [8] & 0x7f) ;\n\t\toffset = (offset << 7) | (buf [9] & 0x7f) ;\n\n\t\tpsf_log_printf (psf, \"ID3 length : %d\\n--------------------\\n\", offset) ;\n\n\t\tif (offset < 0)\n\t\t\treturn 0 ;\n\n\t\tpsf->fileoffset += offset + 10 ;\n\n\t\tif (psf->fileoffset < psf->filelength)\n\t\t{\tpsf_binheader_readf (psf, \"p\", psf->fileoffset) ;\n\t\t\treturn 1 ;\n\t\t\t} ;\n\t\t} ;\n\n\treturn 0 ;\n} ",
        "output": "0",
        "idx": 6869
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs4_open_confirm_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\tif (!data->rpc_done)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.open_flags);\nout_free:\n\tnfs4_opendata_put(data);\n}",
        "output": "1",
        "idx": 2164
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __u8 *mr_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 30 && rdesc[29] == 0x05 && rdesc[30] == 0x09) {\n\t\thid_info(hdev, \"fixing up button/consumer in HID report descriptor\\n\");\n\t\trdesc[30] = 0x0c;\n\t}\n\treturn rdesc;\n}",
        "output": "1",
        "idx": 2650
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct nfs4_state *nfs4_do_open(struct inode *dir, struct path *path, int flags, struct iattr *sattr, struct rpc_cred *cred)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs4_state *res;\n\tint status;\n\n\tdo {\n\t\tstatus = _nfs4_do_open(dir, path, flags, sattr, cred, &res);\n\t\tif (status == 0)\n\t\t\tbreak;\n\t\tif (status == -NFS4ERR_BAD_SEQID) {\n\t\t\tprintk(KERN_WARNING \"NFS: v4 server %s \"\n\t\t\t\t\t\" returned a bad sequence-id error!\\n\",\n\t\t\t\t\tNFS_SERVER(dir)->nfs_client->cl_hostname);\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -NFS4ERR_BAD_STATEID) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -EAGAIN) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tres = ERR_PTR(nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t\tstatus, &exception));\n\t} while (exception.retry);\n\treturn res;\n}",
        "output": "1",
        "idx": 2138
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_hash rhash;\n\n\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"ahash\");\n\n\trhash.blocksize = alg->cra_blocksize;\n\trhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_HASH,\n\t\t    sizeof(struct crypto_report_hash), &rhash))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "1",
        "idx": 848
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int jpg_validate(jas_stream_t *in)\n{\n\tuchar buf[JPG_MAGICLEN];\n\tint i;\n\tint n;\n\n\tassert(JAS_STREAM_MAXPUTBACK >= JPG_MAGICLEN);\n\n\tif ((n = jas_stream_read(in, buf, JPG_MAGICLEN)) < 0) {\n\t\treturn -1;\n\t}\n\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (n < JPG_MAGICLEN) {\n\t\treturn -1;\n\t}\n\n\tif (buf[0] != (JPG_MAGIC >> 8) || buf[1] != (JPG_MAGIC & 0xff)) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 5410
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)\n{\n\t__issue_discard_cmd(sbi, false);\n\t__drop_discard_cmd(sbi);\n\t__wait_discard_cmd(sbi, false);\n}",
        "output": "1",
        "idx": 1686
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void nfs4_close_sync(struct path *path, struct nfs4_state *state, mode_t mode)\n{\n\t__nfs4_close(path, state, mode, 1);\n}",
        "output": "1",
        "idx": 2168
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static freelist_idx_t next_random_slot(union freelist_init_state *state)\n{\n\tif (state->pos >= state->count)\n\t\tstate->pos = 0;\n\treturn state->list[state->pos++];\n}",
        "output": "0",
        "idx": 2073
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void show_object(struct object *object, const char *name, void *data)\n{\n\tstruct bitmap *base = data;\n\tbitmap_set(base, find_object_pos(object->oid.hash));\n\tmark_as_seen(object);\n}",
        "output": "0",
        "idx": 7233
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_pinfo *pi = sco_pi(sk);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state == BT_CONNECT2 &&\n\t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n\t\tsco_conn_defer_accept(pi->conn->hcon, pi->setting);\n\t\tsk->sk_state = BT_CONFIG;\n\t\tmsg->msg_namelen = 0;\n\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\n\trelease_sock(sk);\n\n\treturn bt_sock_recvmsg(iocb, sock, msg, len, flags);\n}",
        "output": "1",
        "idx": 2434
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ip6_append_data_mtu(int *mtu,\n\t\t\t\tint *maxfraglen,\n\t\t\t\tunsigned int fragheaderlen,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct rt6_info *rt)\n{\n\tif (!(rt->dst.flags & DST_XFRM_TUNNEL)) {\n\t\tif (skb == NULL) {\n\t\t\t*mtu = *mtu - rt->dst.header_len;\n\n\t\t} else {\n\t\t\t*mtu = dst_mtu(rt->dst.path);\n\t\t}\n\t\t*maxfraglen = ((*mtu - fragheaderlen) & ~7)\n\t\t\t      + fragheaderlen - sizeof(struct frag_hdr);\n\t}\n}",
        "output": "1",
        "idx": 2314
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE cState_space_before_set(VALUE self, VALUE space_before)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(space_before, T_STRING);\n    len = RSTRING_LEN(space_before);\n    if (len == 0) {\n        if (state->space_before) {\n            ruby_xfree(state->space_before);\n            state->space_before = NULL;\n            state->space_before_len = 0;\n        }\n    } else {\n        if (state->space_before) ruby_xfree(state->space_before);\n        state->space_before = strdup(RSTRING_PTR(space_before));\n        state->space_before_len = len;\n    }\n    return Qnil;\n}",
        "output": "1",
        "idx": 6270
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)\n{\n\tM_fs_info_t  *info = NULL;\n\tchar         *pold = NULL;\n\tchar         *pnew = NULL;\n\tM_fs_type_t   type;\n\tM_bool        ret  = M_TRUE;\n\n\tif (mode & M_FS_FILE_MODE_OVERWRITE)\n\t\treturn M_TRUE;\n\n\n\tif (M_fs_info(&info, p1, M_FS_PATH_INFO_FLAGS_BASIC) != M_FS_ERROR_SUCCESS)\n\t\treturn M_FALSE;\n\n\ttype = M_fs_info_get_type(info);\n\tM_fs_info_destroy(info);\n\n\tif (type != M_FS_TYPE_DIR) {\n\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)\n\t\t{\n\t\t\tret = M_FALSE;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tpold = M_fs_path_basename(p1, M_FS_SYSTEM_AUTO);\n\tpnew = M_fs_path_join(p2, pnew, M_FS_SYSTEM_AUTO);\n\tif (M_fs_perms_can_access(pnew, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n\t\tret = M_FALSE;\n\t\tgoto done;\n\t}\n\ndone:\n\tM_free(pnew);\n\tM_free(pold);\n\treturn ret;\n}",
        "output": "1",
        "idx": 6934
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){\n    long i;\n    for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){\n        long a = *(long*)(src+i);\n        long b = *(long*)(dst+i);\n        *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] += src[i+0];\n}",
        "output": "0",
        "idx": 4971
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err tenc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\n\tgf_isom_box_dump_start(a, \"TrackEncryptionBox\", trace);\n\n\tfprintf(trace, \"isEncrypted=\\\"%d\\\"\", ptr->isProtected);\n\tif (ptr->Per_Sample_IV_Size)\n\t\tfprintf(trace, \" IV_size=\\\"%d\\\" KID=\\\"\", ptr->Per_Sample_IV_Size);\n\telse {\n\t\tfprintf(trace, \" constant_IV_size=\\\"%d\\\" constant_IV=\\\"\", ptr->constant_IV_size);\n\t\tdump_data_hex(trace, (char *) ptr->constant_IV, ptr->constant_IV_size);\n\t\tfprintf(trace, \"\\\"  KID=\\\"\");\n\t}\n\tdump_data_hex(trace, (char *) ptr->KID, 16);\n\tif (ptr->version) \n\t\tfprintf(trace, \"\\\" crypt_byte_block=\\\"%d\\\" skip_byte_block=\\\"%d\", ptr->crypt_byte_block, ptr->skip_byte_block);\n\tfprintf(trace, \"\\\">\\n\");\n\tgf_isom_box_dump_done(\"TrackEncryptionBox\", a, trace);\n\treturn GF_OK;\n}",
        "output": "1",
        "idx": 6788
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void* chk_malloc(size_t bytes)\n{\n    char* buffer = (char*)dlmalloc(bytes + CHK_OVERHEAD_SIZE);\n    if (buffer) {\n        memset(buffer, CHK_SENTINEL_VALUE, bytes + CHK_OVERHEAD_SIZE);\n        size_t offset = dlmalloc_usable_size(buffer) - sizeof(size_t);\n        *(size_t *)(buffer + offset) = bytes;\n        buffer += CHK_SENTINEL_HEAD_SIZE;\n    }\n    return buffer;\n}",
        "output": "1",
        "idx": 3624
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int simulate_llsc(struct pt_regs *regs, unsigned int opcode)\n{\n\tif ((opcode & OPCODE) == LL) {\n\t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n\t\t\t\t1, 0, regs, 0);\n\t\treturn simulate_ll(regs, opcode);\n\t}\n\tif ((opcode & OPCODE) == SC) {\n\t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n\t\t\t\t1, 0, regs, 0);\n\t\treturn simulate_sc(regs, opcode);\n\t}\n\n\treturn -1;\t\t\t\n}",
        "output": "1",
        "idx": 432
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct usb_yurex *dev;\n\tint retval = 0;\n\tint bytes_read = 0;\n\tchar in_buffer[20];\n\tunsigned long flags;\n\n\tdev = file->private_data;\n\n\tmutex_lock(&dev->io_mutex);\n\tif (!dev->interface) {\t\t\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tbytes_read = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (*ppos < bytes_read) {\n\t\tif (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos))\n\t\t\tretval = -EFAULT;\n\t\telse {\n\t\t\tretval = bytes_read - *ppos;\n\t\t\t*ppos += bytes_read;\n\t\t}\n\t}\n\nexit:\n\tmutex_unlock(&dev->io_mutex);\n\treturn retval;\n}",
        "output": "1",
        "idx": 2996
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "INST_HANDLER (cpse) {\t\n\tint r = (buf[0] & 0xf) | ((buf[1] & 0x2) << 3);\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tRAnalOp next_op;\n\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\n\top->cycles = 1;\t\n\tESIL_A (\"r%d,r%d,^,!,\", r, d);\t\t\t\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t\n}",
        "output": "1",
        "idx": 6198
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "efind(name)\nchar *name;\n{\n\tstatic char efbuf[100];\n\tmy_regex_t re;\n\n\tsnprintf(efbuf, sizeof(efbuf), \"REG_%s\", name);\n\tassert(strlen(efbuf) < sizeof(efbuf));\n\tre.re_endp = efbuf;\n\t(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));\n\treturn(atoi(efbuf));\n}",
        "output": "0",
        "idx": 7349
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __perf_sw_event(u32 event_id, u64 nr, int nmi,\n\t\t\t    struct pt_regs *regs, u64 addr)\n{\n\tstruct perf_sample_data data;\n\tint rctx;\n\n\tpreempt_disable_notrace();\n\trctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn;\n\n\tperf_sample_data_init(&data, addr);\n\n\tdo_perf_sw_event(PERF_TYPE_SOFTWARE, event_id, nr, nmi, &data, regs);\n\n\tperf_swevent_put_recursion_context(rctx);\n\tpreempt_enable_notrace();\n}",
        "output": "1",
        "idx": 546
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\t_gdImageWebpCtx(im, out, -1);\n\tout->gd_free(out);\n}",
        "output": "0",
        "idx": 6193
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int crypto_rng_seedsize(struct crypto_rng *tfm)\n{\n\treturn tfm->seedsize;\n}",
        "output": "1",
        "idx": 2848
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "path_poly(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P(0);\n\tPOLYGON    *poly;\n\tint\t\t\tsize;\n\tint\t\t\ti;\n\n\tif (!path->closed)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"open path cannot be converted to polygon\")));\n\n\tsize = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * path->npts;\n\tpoly = (POLYGON *) palloc(size);\n\n\tSET_VARSIZE(poly, size);\n\tpoly->npts = path->npts;\n\n\tfor (i = 0; i < path->npts; i++)\n\t{\n\t\tpoly->p[i].x = path->p[i].x;\n\t\tpoly->p[i].y = path->p[i].y;\n\t}\n\n\tmake_bound_box(poly);\n\n\tPG_RETURN_POLYGON_P(poly);\n}",
        "output": "0",
        "idx": 6293
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct ip_options *tcp_v4_save_options(struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ip_options *opt = &(IPCB(skb)->opt);\n\tstruct ip_options *dopt = NULL;\n\n\tif (opt && opt->optlen) {\n\t\tint opt_size = optlength(opt);\n\t\tdopt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (dopt) {\n\t\t\tif (ip_options_echo(dopt, skb)) {\n\t\t\t\tkfree(dopt);\n\t\t\t\tdopt = NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn dopt;\n}",
        "output": "1",
        "idx": 374
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nautilus_file_mark_desktop_file_trusted (GFile              *file,\n                                         GtkWindow          *parent_window,\n                                         gboolean            interactive,\n                                         NautilusOpCallback  done_callback,\n                                         gpointer            done_callback_data)\n{\n    GTask *task;\n    MarkTrustedJob *job;\n\n    job = op_job_new (MarkTrustedJob, parent_window);\n    job->file = g_object_ref (file);\n    job->interactive = interactive;\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n\n    task = g_task_new (NULL, NULL, mark_trusted_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, mark_trusted_task_thread_func);\n    g_object_unref (task);\n}",
        "output": "1",
        "idx": 6286
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline pgd_t *pgd_alloc(struct mm_struct *mm)\n{\n\tspin_lock_init(&mm->context.list_lock);\n\tINIT_LIST_HEAD(&mm->context.pgtable_list);\n\tINIT_LIST_HEAD(&mm->context.gmap_list);\n\treturn (pgd_t *) crst_table_alloc(mm);\n}",
        "output": "1",
        "idx": 1142
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ff_jpeg2000_cleanup(Jpeg2000Component *comp, Jpeg2000CodingStyle *codsty)\n{\n    int reslevelno, bandno, precno;\n    for (reslevelno = 0;\n         comp->reslevel && reslevelno < codsty->nreslevels;\n         reslevelno++) {\n        Jpeg2000ResLevel *reslevel = comp->reslevel + reslevelno;\n\n        for (bandno = 0; bandno < reslevel->nbands; bandno++) {\n            Jpeg2000Band *band = reslevel->band + bandno;\n            for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++) {\n                Jpeg2000Prec *prec = band->prec + precno;\n                av_freep(&prec->zerobits);\n                av_freep(&prec->cblkincl);\n                av_freep(&prec->cblk);\n            }\n\n            av_freep(&band->prec);\n        }\n        av_freep(&reslevel->band);\n    }\n\n    ff_dwt_destroy(&comp->dwt);\n    av_freep(&comp->reslevel);\n    av_freep(&comp->i_data);\n    av_freep(&comp->f_data);\n}",
        "output": "1",
        "idx": 3550
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "zend_object_iterator *spl_filesystem_dir_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator;\n\tspl_filesystem_object   *dir_object;\n\n\tif (by_ref) {\n\t\tzend_error(E_ERROR, \"An iterator cannot be used with foreach by reference\");\n\t}\n\tdir_object = (spl_filesystem_object*)zend_object_store_get_object(object TSRMLS_CC);\n\titerator   = spl_filesystem_object_to_iterator(dir_object);\n\n\tif (iterator->intern.data == NULL) {\n\t\titerator->intern.data = object;\n\t\titerator->intern.funcs = &spl_filesystem_dir_it_funcs;\n\t\titerator->current = object;\n\t}\n\tzval_add_ref(&object);\n\t\n\treturn (zend_object_iterator*)iterator;\n}",
        "output": "1",
        "idx": 4016
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void init_idle_pids(struct pid_link *links)\n{\n\tenum pid_type type;\n\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {\n\t\tINIT_HLIST_NODE(&links[type].node); \n\t\tlinks[type].pid = &init_struct_pid;\n\t}\n}",
        "output": "0",
        "idx": 323
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "aodv_extension(netdissect_options *ndo,\n               const struct aodv_ext *ep, u_int length)\n{\n\tconst struct aodv_hello *ah;\n\n\tND_TCHECK(*ep);\n\tswitch (ep->type) {\n\tcase AODV_EXT_HELLO:\n\t\tah = (const struct aodv_hello *)(const void *)ep;\n\t\tND_TCHECK(*ah);\n\t\tif (length < sizeof(struct aodv_hello))\n\t\t\tgoto trunc;\n\t\tif (ep->length < 4) {\n\t\t\tND_PRINT((ndo, \"\\n\\text HELLO - bad length %u\", ep->length));\n\t\t\tbreak;\n\t\t}\n\t\tND_PRINT((ndo, \"\\n\\text HELLO %ld ms\",\n\t\t    (unsigned long)EXTRACT_32BITS(&ah->interval)));\n\t\tbreak;\n\n\tdefault:\n\t\tND_PRINT((ndo, \"\\n\\text %u %u\", ep->type, ep->length));\n\t\tbreak;\n\t}\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \" [|hello]\"));\n}",
        "output": "0",
        "idx": 6643
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "swabHorAcc32(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\tuint32* wp = (uint32*) cp0;\n\ttmsize_t wc = cc / 4;\n\n        TIFFSwabArrayOfLong(wp, wc);\n\thorAcc32(tif, cp0, cc);\n}",
        "output": "1",
        "idx": 4270
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_rdrand_seed()\n{\n    DEBUG_SEED(\"get_rdrand_seed\");\n    int _eax;\n    __asm__ __volatile__(\"1: .byte 0x0F\\n\"\n                         \"   .byte 0xC7\\n\"\n                         \"   .byte 0xF0\\n\"\n                         \"   jnc 1b;\\n\"\n                         : \"=a\" (_eax));\n    return _eax;\n}",
        "output": "0",
        "idx": 5953
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\n\trc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\n\tnfc_put_device(dev);\n\treturn rc;\n}",
        "output": "1",
        "idx": 3198
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int _setEdgePixel(const gdImagePtr src, unsigned int x, unsigned int y, gdFixed coverage, const int bgColor) \n{\n\tconst gdFixed f_127 = gd_itofx(127);\n\tregister int c = src->tpixels[y][x];\n\tc = c | (( (int) (gd_fxtof(gd_mulfx(coverage, f_127)) + 50.5f)) << 24);\n\treturn _color_blend(bgColor, c);\n}",
        "output": "1",
        "idx": 3906
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int persistent_prepare_exception(struct dm_exception_store *store,\n\t\t\t\t\tstruct dm_exception *e)\n{\n\tstruct pstore *ps = get_info(store);\n\tuint32_t stride;\n\tchunk_t next_free;\n\tsector_t size = get_dev_size(dm_snap_cow(store->snap)->bdev);\n\n\tif (size < ((ps->next_free + 1) * store->chunk_size))\n\t\treturn -ENOSPC;\n\n\te->new_chunk = ps->next_free;\n\n\tstride = (ps->exceptions_per_area + 1);\n\tnext_free = ++ps->next_free;\n\tif (sector_div(next_free, stride) == 1)\n\t\tps->next_free++;\n\n\tatomic_inc(&ps->pending_count);\n\treturn 0;\n}",
        "output": "1",
        "idx": 2340
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int setup_config(int type)\n{\n\tint rv;\n\n\trv = read_config(cl.configfile, type);\n\tif (rv < 0)\n\t\tgoto out;\n\n\tif (is_auth_req()) {\n\t\trv = read_authkey();\n\t\tif (rv < 0)\n\t\t\tgoto out;\n#if HAVE_LIBGCRYPT\n\t\tif (!gcry_check_version(NULL)) {\n\t\t\tlog_error(\"gcry_check_version\");\n\t\t\trv = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tgcry_control(GCRYCTL_DISABLE_SECMEM, 0);\n\t\tgcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\t}\n\n\tif (cl.type == DAEMON && cl.site[0]) {\n\t\tif (!find_site_by_name(cl.site, &local, 1)) {\n\t\t\tlog_error(\"Cannot find \\\"%s\\\" in the configuration.\",\n\t\t\t\t\tcl.site);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlocal->local = 1;\n\t} else\n\t\tfind_myself(NULL, type == CLIENT || type == GEOSTORE);\n\n\n\trv = check_config(type);\n\tif (rv < 0)\n\t\tgoto out;\n\n\n\tif (!cl.lockfile[0]) {\n\t\tsnprintf(cl.lockfile, sizeof(cl.lockfile)-1,\n\t\t\t\t\"%s/%s.pid\", BOOTH_RUN_DIR, booth_conf->name);\n\t}\n\nout:\n\treturn rv;\n}",
        "output": "1",
        "idx": 8904
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main(void)\n{\n\tFILE *f;\n\tchar *tmpname;\n\tf = xfmkstemp(&tmpname, NULL, \"test\");\n\tunlink(tmpname);\n\tfree(tmpname);\n\tfclose(f);\n\treturn EXIT_FAILURE;\n}",
        "output": "0",
        "idx": 6509
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mp_encode_lua_table_as_map(lua_State *L, mp_buf *buf, int level) {\n    size_t len = 0;\n\n    luaL_checkstack(L, 3, \"in function mp_encode_lua_table_as_map\");\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        lua_pop(L,1); \n        len++;\n    }\n\n    mp_encode_map(L,buf,len);\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        lua_pushvalue(L,-2); \n        mp_encode_lua_type(L,buf,level+1); \n        mp_encode_lua_type(L,buf,level+1); \n    }\n}",
        "output": "0",
        "idx": 5111
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sco_send_frame(struct sock *sk, struct msghdr *msg, int len)\n{\n\tstruct sco_conn *conn = sco_pi(sk)->conn;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tif (len > conn->mtu)\n\t\treturn -EINVAL;\n\n\tBT_DBG(\"sk %p len %d\", sk, len);\n\n\tskb = bt_skb_send_alloc(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\n\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\n\thci_send_sco(conn->hcon, skb);\n\n\treturn len;\n}",
        "output": "1",
        "idx": 1986
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean netscreen_read(wtap *wth, int *err, gchar **err_info,\n    gint64 *data_offset)\n{\n\tgint64\t\toffset;\n\tchar\t\tline[NETSCREEN_LINE_LENGTH];\n\n\toffset = netscreen_seek_next_packet(wth, err, err_info, line);\n\tif (offset < 0)\n\t\treturn FALSE;\n\n\tif (!parse_netscreen_packet(wth->fh, &wth->phdr,\n\t    wth->frame_buffer, line, err, err_info))\n\t\treturn FALSE;\n\n\tif (wth->file_encap == WTAP_ENCAP_UNKNOWN)\n\t\twth->file_encap = wth->phdr.pkt_encap;\n\telse {\n\t\tif (wth->file_encap != wth->phdr.pkt_encap)\n\t\t\twth->file_encap = WTAP_ENCAP_PER_PACKET;\n\t}\n\n\t*data_offset = offset;\n\treturn TRUE;\n}",
        "output": "0",
        "idx": 8371
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_framing_type_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_ASYNC_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_SYNC_MASK) {\n\t\tND_PRINT((ndo, \"S\"));\n\t}\n}",
        "output": "1",
        "idx": 4766
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __do_page_fault(struct mm_struct *mm, unsigned long addr,\n\t\t\t   unsigned int mm_flags, unsigned long vm_flags,\n\t\t\t   struct task_struct *tsk)\n{\n\tstruct vm_area_struct *vma;\n\tint fault;\n\n\tvma = find_vma(mm, addr);\n\tfault = VM_FAULT_BADMAP;\n\tif (unlikely(!vma))\n\t\tgoto out;\n\tif (unlikely(vma->vm_start > addr))\n\t\tgoto check_stack;\n\ngood_area:\n\tif (!(vma->vm_flags & vm_flags)) {\n\t\tfault = VM_FAULT_BADACCESS;\n\t\tgoto out;\n\t}\n\n\treturn handle_mm_fault(mm, vma, addr & PAGE_MASK, mm_flags);\n\ncheck_stack:\n\tif (vma->vm_flags & VM_GROWSDOWN && !expand_stack(vma, addr))\n\t\tgoto good_area;\nout:\n\treturn fault;\n}",
        "output": "1",
        "idx": 2576
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_devinfo_ioctl(struct comedi_device *dev,\n\t\t\t    struct comedi_devinfo __user *arg,\n\t\t\t    struct file *file)\n{\n\tstruct comedi_devinfo devinfo;\n\tconst unsigned minor = iminor(file->f_dentry->d_inode);\n\tstruct comedi_device_file_info *dev_file_info =\n\t    comedi_get_device_file_info(minor);\n\tstruct comedi_subdevice *read_subdev =\n\t    comedi_get_read_subdevice(dev_file_info);\n\tstruct comedi_subdevice *write_subdev =\n\t    comedi_get_write_subdevice(dev_file_info);\n\n\tmemset(&devinfo, 0, sizeof(devinfo));\n\n\tdevinfo.version_code = COMEDI_VERSION_CODE;\n\tdevinfo.n_subdevs = dev->n_subdevices;\n\tstrlcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);\n\tstrlcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);\n\n\tif (read_subdev)\n\t\tdevinfo.read_subdevice = read_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.read_subdevice = -1;\n\n\tif (write_subdev)\n\t\tdevinfo.write_subdevice = write_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.write_subdevice = -1;\n\n\tif (copy_to_user(arg, &devinfo, sizeof(struct comedi_devinfo)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 715
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void pid_ns_release_proc(struct pid_namespace *ns)\n{\n\tkern_unmount(ns->proc_mnt);\n}",
        "output": "0",
        "idx": 833
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void get_nb10(ut8* dbg_data, SCV_NB10_HEADER* res) {\n\tconst int nb10sz = 16;\n\tmemcpy (res, dbg_data, nb10sz);\n\tres->file_name = (ut8*) strdup ((const char*) dbg_data + nb10sz);\n}",
        "output": "1",
        "idx": 6194
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "yank_copy_line(struct block_def *bd, long y_idx, int exclude_trailing_space)\n{\n    char_u\t*pnew;\n\n    if (exclude_trailing_space)\n\tbd->endspaces = 0;\n    if ((pnew = alloc(bd->startspaces + bd->endspaces + bd->textlen + 1))\n\t\t\t\t\t\t\t\t      == NULL)\n\treturn FAIL;\n    y_current->y_array[y_idx] = pnew;\n    vim_memset(pnew, ' ', (size_t)bd->startspaces);\n    pnew += bd->startspaces;\n    mch_memmove(pnew, bd->textstart, (size_t)bd->textlen);\n    pnew += bd->textlen;\n    vim_memset(pnew, ' ', (size_t)bd->endspaces);\n    pnew += bd->endspaces;\n    if (exclude_trailing_space)\n    {\n\tint s = bd->textlen + bd->endspaces;\n\n\twhile (VIM_ISWHITE(*(bd->textstart + s - 1)) && s > 0)\n\t{\n\t    s = s - (*mb_head_off)(bd->textstart, bd->textstart + s - 1) - 1;\n\t    pnew--;\n\t}\n    }\n    *pnew = NUL;\n    return OK;\n}",
        "output": "1",
        "idx": 5726
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_session_handshake (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    struct ssh_userdata *sshu = NULL;\n\n    assert(lua_gettop(L) == 4);\n    sshu = (struct ssh_userdata *) nseU_checkudata(L, 3, SSH2_UDATA, \"ssh2\");\n\n    while ((rc = libssh2_session_handshake(sshu->session, sshu->sp[0])) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 3, \"filter\");\n        lua_pushvalue(L, 3);\n\n        assert(lua_status(L) == LUA_OK);\n        lua_callk(L, 1, 0, 0, do_session_handshake);\n    }\n\n    if (rc) {\n        libssh2_session_free(sshu->session);\n        sshu->session = NULL;\n        return luaL_error(L, \"Unable to complete libssh2 handshake.\");\n    }\n\n    lua_settop(L, 3);\n\n    return 1;\n}",
        "output": "0",
        "idx": 8887
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "toomany(struct magic_set *ms, const char *name, uint16_t num)\n{\n\tif (file_printf(ms, \", too many %s header sections (%u)\", name, num\n\t    ) == -1)\n\t\treturn -1;\n\treturn 0;\n}",
        "output": "0",
        "idx": 6101
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct btrfs_device *btrfs_find_device(struct btrfs_fs_devices *fs_devices,\n\t\t\t\t       u64 devid, u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\n\twhile (fs_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(fs_devices->metadata_uuid, fsid, BTRFS_FSID_SIZE)) {\n\t\t\tdevice = find_device(fs_devices, devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tfs_devices = fs_devices->seed;\n\t}\n\treturn NULL;\n}",
        "output": "1",
        "idx": 3098
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int create_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tstruct flush_cmd_control *fcc;\n\tint err = 0;\n\n\tif (SM_I(sbi)->fcc_info) {\n\t\tfcc = SM_I(sbi)->fcc_info;\n\t\tgoto init_thread;\n\t}\n\n\tfcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);\n\tif (!fcc)\n\t\treturn -ENOMEM;\n\tatomic_set(&fcc->issued_flush, 0);\n\tatomic_set(&fcc->issing_flush, 0);\n\tinit_waitqueue_head(&fcc->flush_wait_queue);\n\tinit_llist_head(&fcc->issue_list);\n\tSM_I(sbi)->fcc_info = fcc;\n\tif (!test_opt(sbi, FLUSH_MERGE))\n\t\treturn err;\n\ninit_thread:\n\tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n\t\t\t\t\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(fcc->f2fs_issue_flush)) {\n\t\terr = PTR_ERR(fcc->f2fs_issue_flush);\n\t\tkfree(fcc);\n\t\tSM_I(sbi)->fcc_info = NULL;\n\t\treturn err;\n\t}\n\n\treturn err;\n}",
        "output": "0",
        "idx": 2337
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_chmod(const char *path)\n{\n\tif (chmod(path, 0755) == 0) {\n\t\tfprintf(stderr, \"leak at chmod of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at chmod of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}",
        "output": "0",
        "idx": 7287
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __init proc_root_init(void)\n{\n\tstruct vfsmount *mnt;\n\tint err;\n\n\tproc_init_inodecache();\n\terr = register_filesystem(&proc_fs_type);\n\tif (err)\n\t\treturn;\n\tmnt = kern_mount_data(&proc_fs_type, &init_pid_ns);\n\tif (IS_ERR(mnt)) {\n\t\tunregister_filesystem(&proc_fs_type);\n\t\treturn;\n\t}\n\n\tinit_pid_ns.proc_mnt = mnt;\n\tproc_symlink(\"mounts\", NULL, \"self/mounts\");\n\n\tproc_net_init();\n\n#ifdef CONFIG_SYSVIPC\n\tproc_mkdir(\"sysvipc\", NULL);\n#endif\n\tproc_mkdir(\"fs\", NULL);\n\tproc_mkdir(\"driver\", NULL);\n\tproc_mkdir(\"fs/nfsd\", NULL); \n#if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE)\n\tproc_mkdir(\"openprom\", NULL);\n#endif\n\tproc_tty_init();\n#ifdef CONFIG_PROC_DEVICETREE\n\tproc_device_tree_init();\n#endif\n\tproc_mkdir(\"bus\", NULL);\n\tproc_sys_init();\n}",
        "output": "1",
        "idx": 644
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      const char *name, int name_len)\n{\n\tstruct btrfs_dir_item *dir_item;\n\tunsigned long name_ptr;\n\tu32 total_len;\n\tu32 cur = 0;\n\tu32 this_len;\n\tstruct extent_buffer *leaf;\n\n\tleaf = path->nodes[0];\n\tdir_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dir_item);\n\tif (verify_dir_item(root, leaf, dir_item))\n\t\treturn NULL;\n\n\ttotal_len = btrfs_item_size_nr(leaf, path->slots[0]);\n\twhile (cur < total_len) {\n\t\tthis_len = sizeof(*dir_item) +\n\t\t\tbtrfs_dir_name_len(leaf, dir_item) +\n\t\t\tbtrfs_dir_data_len(leaf, dir_item);\n\t\tname_ptr = (unsigned long)(dir_item + 1);\n\n\t\tif (btrfs_dir_name_len(leaf, dir_item) == name_len &&\n\t\t    memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)\n\t\t\treturn dir_item;\n\n\t\tcur += this_len;\n\t\tdir_item = (struct btrfs_dir_item *)((char *)dir_item +\n\t\t\t\t\t\t     this_len);\n\t}\n\treturn NULL;\n}",
        "output": "1",
        "idx": 2718
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_ctl_elem_write(struct snd_card *card, struct snd_ctl_file *file,\n\t\t\t      struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tint result;\n\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\t\tvd = &kctl->vd[index_offset];\n\t\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_WRITE) ||\n\t\t    kctl->put == NULL ||\n\t\t    (file && vd->owner && vd->owner != file)) {\n\t\t\tresult = -EPERM;\n\t\t} else {\n\t\t\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n\t\t\tresult = kctl->put(kctl, control);\n\t\t}\n\t\tif (result > 0) {\n\t\t\tstruct snd_ctl_elem_id id = control->id;\n\t\t\tup_read(&card->controls_rwsem);\n\t\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE, &id);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tup_read(&card->controls_rwsem);\n\treturn result;\n}",
        "output": "0",
        "idx": 3589
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ifb_setup(struct net_device *dev)\n{\n\tdev->destructor = free_netdev;\n\tdev->netdev_ops = &ifb_netdev_ops;\n\n\tether_setup(dev);\n\tdev->tx_queue_len = TX_Q_LIMIT;\n\n\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n\n\tdev->flags |= IFF_NOARP;\n\tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\trandom_ether_addr(dev->dev_addr);\n}",
        "output": "1",
        "idx": 580
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);\n}",
        "output": "1",
        "idx": 1374
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void hugetlbfs_put_super(struct super_block *sb)\n{\n\tstruct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);\n\n\tif (sbi) {\n\t\tsb->s_fs_info = NULL;\n\n\t\tif (sbi->spool)\n\t\t\thugepage_put_subpool(sbi->spool);\n\n\t\tkfree(sbi);\n\t}\n}",
        "output": "0",
        "idx": 889
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int timer_start(Unit *u) {\n        Timer *t = TIMER(u);\n        TimerValue *v;\n\n        assert(t);\n        assert(t->state == TIMER_DEAD || t->state == TIMER_FAILED);\n\n        if (UNIT_TRIGGER(u)->load_state != UNIT_LOADED)\n                return -ENOENT;\n\n        t->last_trigger = DUAL_TIMESTAMP_NULL;\n\n        LIST_FOREACH(value, v, t->values)\n                if (v->base == TIMER_ACTIVE)\n                        v->disabled = false;\n\n        if (t->stamp_path) {\n                struct stat st;\n\n                if (stat(t->stamp_path, &st) >= 0)\n                        t->last_trigger.realtime = timespec_load(&st.st_atim);\n                else if (errno == ENOENT)\n                        touch_file(t->stamp_path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);\n        }\n\n        t->result = TIMER_SUCCESS;\n        timer_enter_waiting(t, true);\n        return 1;\n}",
        "output": "1",
        "idx": 5482
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline static jas_int_asr(int x, int n)\n{\n\tassert(n >= 0);\n\treturn x >> n;\n}",
        "output": "0",
        "idx": 7479
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvaser_usb_leaf_flush_queue(struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->id = CMD_FLUSH_QUEUE;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_flush_queue);\n\tcmd->u.flush_queue.channel = priv->channel;\n\tcmd->u.flush_queue.flags = 0x00;\n\n\trc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len);\n\n\tkfree(cmd);\n\treturn rc;\n}",
        "output": "0",
        "idx": 4591
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "filter_session_io(struct io *io, int evt, void *arg)\n{\n\tstruct filter_session *fs = arg;\n\tchar *line = NULL;\n\tssize_t len;\n\n\tlog_trace(TRACE_IO, \"filter session: %p: %s %s\", fs, io_strevent(evt),\n\t    io_strio(io));\n\n\tswitch (evt) {\n\tcase IO_DATAIN:\n\tnextline:\n\t\tline = io_getline(fs->io, &len);\n\t\tif (line == NULL)\n\t\t\treturn;\n\n\t\tfilter_data(fs->id, line);\n\n\t\tgoto nextline;\n\n\tcase IO_DISCONNECTED:\n\t\tio_free(fs->io);\n\t\tfs->io = NULL;\n\t\tbreak;\n\t}\n}",
        "output": "1",
        "idx": 5628
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static wStream* rdg_receive_packet(rdpRdg* rdg)\n{\n\twStream* s;\n\tconst size_t header = sizeof(RdgPacketHeader);\n\tsize_t packetLength;\n\tassert(header <= INT_MAX);\n\ts = Stream_New(NULL, 1024);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tif (!rdg_read_all(rdg->tlsOut, Stream_Buffer(s), header))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\n\tStream_Seek(s, 4);\n\tStream_Read_UINT32(s, packetLength);\n\n\tif ((packetLength > INT_MAX) || !Stream_EnsureCapacity(s, packetLength))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\n\tif (!rdg_read_all(rdg->tlsOut, Stream_Buffer(s) + header, (int)packetLength - (int)header))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\n\tStream_SetLength(s, packetLength);\n\treturn s;\n}",
        "output": "1",
        "idx": 4156
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hb_set_invert (hb_set_t *set)\n{\n  set->invert ();\n}",
        "output": "0",
        "idx": 7771
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,\n\t\t\t\t\t struct nlattr *rp)\n{\n\tstruct xfrm_replay_state_esn *up;\n\tint ulen;\n\n\tif (!replay_esn || !rp)\n\t\treturn 0;\n\n\tup = nla_data(rp);\n\tulen = xfrm_replay_state_esn_len(up);\n\n\tif (nla_len(rp) < ulen ||\n\t    xfrm_replay_state_esn_len(replay_esn) != ulen ||\n\t    replay_esn->bmp_len != up->bmp_len)\n\t\treturn -EINVAL;\n\n\tif (up->replay_window > up->bmp_len * sizeof(__u32) * 8)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2225
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void SavePayload(size_t handle, uint32_t *payload, uint32_t index)\n{\n\tmp4object *mp4 = (mp4object *)handle;\n\tif (mp4 == NULL) return;\n\n\tuint32_t *MP4buffer = NULL;\n\tif (index < mp4->indexcount && mp4->mediafp && payload)\n\t{\n\t\tLONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);\n\t\tfwrite(payload, 1, mp4->metasizes[index], mp4->mediafp);\n\t}\n\treturn;\n}",
        "output": "1",
        "idx": 7510
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int skcipher_accept_parent(void *private, struct sock *sk)\n{\n\tstruct skcipher_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);\n\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),\n\t\t\t       GFP_KERNEL);\n\tif (!ctx->iv) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(private));\n\n\tINIT_LIST_HEAD(&ctx->tsgl);\n\tctx->len = len;\n\tctx->used = 0;\n\tctx->more = 0;\n\tctx->merge = 0;\n\tctx->enc = 0;\n\tatomic_set(&ctx->inflight, 0);\n\taf_alg_init_completion(&ctx->completion);\n\n\task->private = ctx;\n\n\tskcipher_request_set_tfm(&ctx->req, private);\n\tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      af_alg_complete, &ctx->completion);\n\n\tsk->sk_destruct = skcipher_sock_destruct;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1050
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseAll(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprJson     *routes;\n    MprJson     *child;\n    int         ji;\n\n    for (ITERATE_CONFIG(route, prop, child, ji)) {\n        parseKey(route, key, child);\n    }\n\n    if ((routes = mprReadJsonObj(prop, \"routes\")) != 0) {\n        parseRoutes(route, key, routes);\n    }\n}",
        "output": "0",
        "idx": 7049
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t available_instances_show(struct mdev_type *mtype,\n\t\t\t\t\tstruct mdev_type_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mtype_get_type_group_id(mtype)];\n\tint count = (max_mbytes - mbochs_used_mbytes) / type->mbytes;\n\n\treturn sprintf(buf, \"%d\\n\", count);\n}",
        "output": "1",
        "idx": 1976
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "trustedGetBlsPubKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint64_t key_len,\n                       char *bls_pub_key) {\n    LOG_DEBUG(__FUNCTION__);\n\n    INIT_ERROR_STATE\n\n    CHECK_STATE(bls_pub_key);\n    CHECK_STATE(encryptedPrivateKey);\n\n    SAFE_CHAR_BUF(skey_hex, ECDSA_SKEY_LEN);\n\n    int status = AES_decrypt(encryptedPrivateKey, key_len, skey_hex, ECDSA_SKEY_LEN);\n\n    CHECK_STATUS2(\"AES decrypt failed %d\");\n\n    skey_hex[ECDSA_SKEY_LEN - 1] = 0;\n\n    status = calc_bls_public_key(skey_hex, bls_pub_key);\n\n    CHECK_STATUS(\"could not calculate bls public key\");\n\n    SET_SUCCESS\n    static uint64_t counter = 0;\n    clean:\n    if (counter % 1000 == 0) {\n        LOG_INFO(__FUNCTION__);\n        LOG_INFO(\"Thousand SGX calls completed\");\n    }\n\n    counter++;\n}",
        "output": "1",
        "idx": 8730
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int perf_event_task_enable(void)\n{\n\tstruct perf_event_context *ctx;\n\tstruct perf_event *event;\n\n\tmutex_lock(&current->perf_event_mutex);\n\tlist_for_each_entry(event, &current->perf_event_list, owner_entry) {\n\t\tctx = perf_event_ctx_lock(event);\n\t\tperf_event_for_each_child(event, _perf_event_enable);\n\t\tperf_event_ctx_unlock(event, ctx);\n\t}\n\tmutex_unlock(&current->perf_event_mutex);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 3817
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Jsi_Value *jsi_treeFmtKey(Jsi_MapEntry* h, struct Jsi_MapOpts *opts, int flags)\n{\n    Jsi_TreeEntry* hPtr = (Jsi_TreeEntry*)h;\n    void *key = Jsi_TreeKeyGet(hPtr);\n    if (opts->keyType == JSI_KEYS_ONEWORD)\n        return Jsi_ValueNewNumber(opts->interp, (Jsi_Number)(intptr_t)key);\n    char nbuf[100];\n    snprintf(nbuf, sizeof(nbuf), \"%p\", key);\n    return Jsi_ValueNewStringDup(opts->interp, nbuf);\n}",
        "output": "1",
        "idx": 8218
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof)\n{\n\tchar *ksep, *vsep, *val;\n\tsize_t klen, vlen;\n\tsize_t new_vlen;\n\n\tif (var->ptr >= var->end) {\n\t\treturn 0;\n\t}\n\n\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n\tif (!vsep) {\n\t\tif (!eof) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvsep = var->end;\n\t\t}\n\t}\n\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\n\tphp_url_decode(var->ptr, klen);\n\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen)) {\n\t\tphp_register_variable_safe(var->ptr, val, new_vlen, arr);\n\t}\n\tefree(val);\n\n\tvar->ptr = vsep + (vsep != var->end);\n\treturn 1;\n}",
        "output": "1",
        "idx": 4100
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ext4_end_io_work(struct work_struct *work)\n{\n\text4_io_end_t\t\t*io = container_of(work, ext4_io_end_t, work);\n\tstruct inode\t\t*inode = io->inode;\n\tstruct ext4_inode_info\t*ei = EXT4_I(inode);\n\tunsigned long\t\tflags;\n\tint\t\t\tret;\n\n\tmutex_lock(&inode->i_mutex);\n\tret = ext4_end_io_nolock(io);\n\tif (ret < 0) {\n\t\tmutex_unlock(&inode->i_mutex);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&ei->i_completed_io_lock, flags);\n\tif (!list_empty(&io->list))\n\t\tlist_del_init(&io->list);\n\tspin_unlock_irqrestore(&ei->i_completed_io_lock, flags);\n\tmutex_unlock(&inode->i_mutex);\n\text4_free_io_end(io);\n}",
        "output": "0",
        "idx": 3169
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\t_gdImageWebpCtx(im, outfile, quality);\n}",
        "output": "0",
        "idx": 6189
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *rfc2047_decode_word(const char *s, size_t len, enum ContentEncoding enc)\n{\n  const char *it = s;\n  const char *end = s + len;\n\n  if (enc == ENCQUOTEDPRINTABLE)\n  {\n    struct Buffer buf = { 0 };\n    for (; it < end; ++it)\n    {\n      if (*it == '_')\n      {\n        mutt_buffer_addch(&buf, ' ');\n      }\n      else if ((*it == '=') && (!(it[1] & ~127) && hexval(it[1]) != -1) &&\n               (!(it[2] & ~127) && hexval(it[2]) != -1))\n      {\n        mutt_buffer_addch(&buf, (hexval(it[1]) << 4) | hexval(it[2]));\n        it += 2;\n      }\n      else\n      {\n        mutt_buffer_addch(&buf, *it);\n      }\n    }\n    mutt_buffer_addch(&buf, '\\0');\n    return buf.data;\n  }\n  else if (enc == ENCBASE64)\n  {\n    char *out = mutt_mem_malloc(3 * len / 4 + 1);\n    int dlen = mutt_b64_decode(out, it);\n    if (dlen == -1)\n    {\n      FREE(&out);\n      return NULL;\n    }\n    out[dlen] = '\\0';\n    return out;\n  }\n\n  assert(0); \n  return NULL;\n}",
        "output": "1",
        "idx": 6988
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cit_get_packet_size(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\n\tintf = usb_ifnum_to_if(gspca_dev->dev, gspca_dev->iface);\n\talt = usb_altnum_to_altsetting(intf, gspca_dev->alt);\n\tif (!alt) {\n\t\tpr_err(\"Couldn't get altsetting\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\treturn le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n}",
        "output": "0",
        "idx": 4623
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __exit void sctp_exit(void)\n{\n\n\tsctp_v6_del_protocol();\n\tsctp_v4_del_protocol();\n\n\tunregister_pernet_subsys(&sctp_net_ops);\n\n\tsctp_v6_protosw_exit();\n\tsctp_v4_protosw_exit();\n\n\tsctp_v6_pf_exit();\n\tsctp_v4_pf_exit();\n\n\tsctp_sysctl_unregister();\n\n\tfree_pages((unsigned long)sctp_assoc_hashtable,\n\t\t   get_order(sctp_assoc_hashsize *\n\t\t\t     sizeof(struct sctp_hashbucket)));\n\tkfree(sctp_ep_hashtable);\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\n\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\n\n\trcu_barrier(); \n\n\tkmem_cache_destroy(sctp_chunk_cachep);\n\tkmem_cache_destroy(sctp_bucket_cachep);\n}",
        "output": "1",
        "idx": 2906
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void put_crypt_info(struct fscrypt_info *ci)\n{\n\tif (!ci)\n\t\treturn;\n\n\tkey_put(ci->ci_keyring_key);\n\tcrypto_free_skcipher(ci->ci_ctfm);\n\tkmem_cache_free(fscrypt_info_cachep, ci);\n}",
        "output": "1",
        "idx": 1534
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)\n{\n\tint n;\n\tuint_fast32_t v;\n\tint c;\n\tfor (n = 4, v = 0;;) {\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tv |= (c << 24);\n\t\tif (--n <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tv >>= 8;\n\t}\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 5342
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int check_line_charstring(void)\n{\n  char *p = line;\n  while (isspace(*p))\n    p++;\n  return (*p == '/' || (p[0] == 'd' && p[1] == 'u' && p[2] == 'p'));\n}",
        "output": "1",
        "idx": 5300
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void gdImageWBMPCtx (gdImagePtr image, int fg, gdIOCtx * out)\n{\n\t_gdImageWBMPCtx(image, fg, out);\n}",
        "output": "0",
        "idx": 5701
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int atusb_get_and_show_revision(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char buffer[3];\n\tint ret;\n\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\tif (ret >= 0) {\n\t\tatusb->fw_ver_maj = buffer[0];\n\t\tatusb->fw_ver_min = buffer[1];\n\t\tatusb->fw_hw_type = buffer[2];\n\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware: major: %u, minor: %u, hardware type: %u\\n\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);\n\t}\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n\t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n\t}\n\n\treturn ret;\n}",
        "output": "1",
        "idx": 1416
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __exit xfrm6_tunnel_fini(void)\n{\n\tunregister_pernet_subsys(&xfrm6_tunnel_net_ops);\n\txfrm6_tunnel_spi_fini();\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\n}",
        "output": "1",
        "idx": 2214
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const struct lxc_rootfs *rootfs,\n\t\t\t\t\t  const char *lxc_name)\n{\n\tchar *aux;\n\tchar path[MAXPATHLEN];\n\tint r, ret = 0, offset;\n\tconst char *lxcpath;\n\n\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\tif (!lxcpath) {\n\t\tERROR(\"Out of memory\");\n\t\treturn -1;\n\t}\n\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s/rootfs\", lxcpath, lxc_name);\n\tif (r < 0 || r >= MAXPATHLEN)\n\t\tgoto skipvarlib;\n\n\taux = strstr(mntent->mnt_dir, path);\n\tif (aux) {\n\t\toffset = strlen(path);\n\t\tgoto skipabs;\n\t}\n\nskipvarlib:\n\taux = strstr(mntent->mnt_dir, rootfs->path);\n\tif (!aux) {\n\t\tWARN(\"ignoring mount point '%s'\", mntent->mnt_dir);\n\t\treturn ret;\n\t}\n\toffset = strlen(rootfs->path);\n\nskipabs:\n\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s\", rootfs->mount,\n\t\t aux + offset);\n\tif (r < 0 || r >= MAXPATHLEN) {\n\t\tWARN(\"pathnme too long for '%s'\", mntent->mnt_dir);\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path);\n}",
        "output": "1",
        "idx": 4370
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int parse_xargs(char *data, int data_length, char ***output)\n{\n\tint num = 0;\n\tchar *cur = data;\n\n\tif (!data || *output != NULL)\n\t\treturn -1;\n\n\twhile (cur < data + data_length) {\n\t\tnum++;\n\t\t*output = must_realloc(*output, (num + 1) * sizeof(**output));\n\t\t(*output)[num - 1] = cur;\n\t\tcur += strlen(cur) + 1;\n\t}\n\t(*output)[num] = NULL;\n\treturn num;\n}",
        "output": "0",
        "idx": 8205
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "crm_initiate_client_tls_handshake(void *session_data, int timeout_ms)\n{\n    int rc = 0;\n    int pollrc = 0;\n    time_t start = time(NULL);\n    gnutls_session *session = session_data;\n\n    do {\n        rc = gnutls_handshake(*session);\n        if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n            pollrc = crm_recv_remote_ready(session, TRUE, 1000);\n            if (pollrc < 0) {\n                rc = -1;\n            }\n        }\n    } while (((time(NULL) - start) < (timeout_ms/1000)) &&\n            (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN));\n\n    return rc;\n}",
        "output": "0",
        "idx": 5269
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct bpf_insn_aux_data *cur_aux(struct bpf_verifier_env *env)\n{\n\treturn &env->insn_aux_data[env->insn_idx];\n}",
        "output": "0",
        "idx": 4201
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, setMaxLineLen)\n{\n\tlong max_len;\n\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &max_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (max_len < 0) {\n\t\tzend_throw_exception_ex(spl_ce_DomainException, 0 TSRMLS_CC, \"Maximum line length must be greater than or equal zero\");\n\t\treturn;\n\t}\n\t\n\tintern->u.file.max_line_len = max_len;\n} ",
        "output": "1",
        "idx": 3916
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void coerce_reg_to_32(struct bpf_reg_state *reg)\n{\n\treg->var_off = tnum_cast(reg->var_off, 4);\n\t__update_reg_bounds(reg);\n}",
        "output": "1",
        "idx": 1808
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_lnums_both(int do_curwin, int nested)\n{\n    win_T\t*wp;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif ((do_curwin || wp != curwin) && wp->w_buffer == curbuf)\n\t{\n\t    if (!nested)\n\t    {\n\t\twp->w_save_cursor.w_cursor_save = wp->w_cursor;\n\t\twp->w_save_cursor.w_topline_save = wp->w_topline;\n\t    }\n\n\t    if (wp->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\twp->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    if (wp->w_topline > curbuf->b_ml.ml_line_count)\n\t\twp->w_topline = curbuf->b_ml.ml_line_count;\n\n\t    wp->w_save_cursor.w_cursor_corr = wp->w_cursor;\n\t    wp->w_save_cursor.w_topline_corr = wp->w_topline;\n\t}\n}",
        "output": "0",
        "idx": 8105
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx,\n\t\t\t\t  u8 status)\n{\n\tstruct xenvif *vif;\n\tstruct pending_tx_info *pending_tx_info;\n\tpending_ring_idx_t index;\n\n\tif (netbk->mmap_pages[pending_idx] == NULL)\n\t\treturn;\n\n\tpending_tx_info = &netbk->pending_tx_info[pending_idx];\n\n\tvif = pending_tx_info->vif;\n\n\tmake_tx_response(vif, &pending_tx_info->req, status);\n\n\tindex = pending_index(netbk->pending_prod++);\n\tnetbk->pending_ring[index] = pending_idx;\n\n\txenvif_put(vif);\n\n\tnetbk->mmap_pages[pending_idx]->mapping = 0;\n\tput_page(netbk->mmap_pages[pending_idx]);\n\tnetbk->mmap_pages[pending_idx] = NULL;\n}",
        "output": "0",
        "idx": 1159
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DefragIPv4NoDataTest(void)\n{\n    DefragContext *dc = NULL;\n    Packet *p = NULL;\n    int id = 12;\n    int ret = 0;\n\n    DefragInit();\n\n    dc = DefragContextNew();\n    if (dc == NULL)\n        goto end;\n\n    p = BuildTestPacket(id, 1, 0, 'A', 0);\n    if (p == NULL)\n        goto end;\n\n    if (Defrag(NULL, NULL, p, NULL) != NULL)\n        goto end;\n\n    if (dc->frag_pool->outstanding != 0)\n        return 0;\n\n    ret = 1;\nend:\n    if (dc != NULL)\n        DefragContextDestroy(dc);\n    if (p != NULL)\n        SCFree(p);\n\n    DefragDestroy();\n    return ret;\n}",
        "output": "1",
        "idx": 6582
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_tp_trap(struct pt_regs *regs, unsigned int instr)\n{\n\tint reg = (instr >> 12) & 15;\n\tif (reg == 15)\n\t\treturn 1;\n\tregs->uregs[reg] = current_thread_info()->tp_value[0];\n\tregs->ARM_pc += 4;\n\treturn 0;\n}",
        "output": "0",
        "idx": 3261
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_user_command_name(int idx, int cmdidx)\n{\n    if (cmdidx == CMD_USER && idx < ucmds.ga_len)\n\treturn USER_CMD(idx)->uc_name;\n    if (cmdidx == CMD_USER_BUF)\n    {\n\tbuf_T *buf =\n#ifdef FEAT_CMDWIN\n\t\t    is_in_cmdwin() ? prevwin->w_buffer :\n#endif\n\t\t    curbuf;\n\n\tif (idx < buf->b_ucmds.ga_len)\n\t    return USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;\n    }\n    return NULL;\n}",
        "output": "1",
        "idx": 5746
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\n\tret = snprintf(path, sizeof(path), \"%s/%s\", rootfs, mntent->mnt_dir);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path);\n}",
        "output": "1",
        "idx": 4366
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "virDomainGetTime(virDomainPtr dom,\n                 long long *seconds,\n                 unsigned int *nseconds,\n                 unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"seconds=%p, nseconds=%p, flags=%x\",\n                     seconds, nseconds, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n\n    if (dom->conn->driver->domainGetTime) {\n        int ret = dom->conn->driver->domainGetTime(dom, seconds,\n                                                   nseconds, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}",
        "output": "0",
        "idx": 7891
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tint result;\n\thandle_t *handle = NULL;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct super_block *sb = inode->i_sb;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\n\tif (write) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\n\t\t\t\t\t\tEXT4_DATA_TRANS_BLOCKS(sb));\n\t} else\n\t\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\n\tif (IS_ERR(handle))\n\t\tresult = VM_FAULT_SIGBUS;\n\telse\n\t\tresult = __dax_fault(vma, vmf, ext4_get_block_dax,\n\t\t\t\t\t\text4_end_io_unwritten);\n\n\tif (write) {\n\t\tif (!IS_ERR(handle))\n\t\t\text4_journal_stop(handle);\n\t\tup_read(&EXT4_I(inode)->i_mmap_sem);\n\t\tsb_end_pagefault(sb);\n\t} else\n\t\tup_read(&EXT4_I(inode)->i_mmap_sem);\n\n\treturn result;\n}",
        "output": "0",
        "idx": 1439
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gdImageScaleTwoPass(const gdImagePtr src, const unsigned int new_width,\n                    const unsigned int new_height)\n{\n    const unsigned int src_width = src->sx;\n    const unsigned int src_height = src->sy;\n\tgdImagePtr tmp_im = NULL;\n\tgdImagePtr dst = NULL;\n\n    if (src_width == new_width && src_height == new_height) {\n        return gdImageClone(src);\n    }\n\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\n    if (src_width == new_width) {\n        tmp_im = src;\n    } else {\n        tmp_im = gdImageCreateTrueColor(new_width, src_height);\n        if (tmp_im == NULL) {\n            return NULL;\n        }\n        gdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n\n        _gdScalePass(src, src_width, tmp_im, new_width, src_height, HORIZONTAL);\n    }\n\n    if (src_height == new_height) {\n        assert(tmp_im != src);\n        return tmp_im;\n    }\n\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst != NULL) {\n        gdImageSetInterpolationMethod(dst, src->interpolation_id);\n        _gdScalePass(tmp_im, src_height, dst, new_height, new_width, VERTICAL);\n    }\n\n    if (src != tmp_im) {\n        gdFree(tmp_im);\n    }\n\n\treturn dst;\n}",
        "output": "1",
        "idx": 4468
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mm_sshpam_init_ctx(Authctxt *authctxt)\n{\n\tBuffer m;\n\tint success;\n\n\tdebug3(\"%s\", __func__);\n\tbuffer_init(&m);\n\tbuffer_put_cstring(&m, authctxt->user);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_INIT_CTX, &m);\n\tdebug3(\"%s: waiting for MONITOR_ANS_PAM_INIT_CTX\", __func__);\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PAM_INIT_CTX, &m);\n\tsuccess = buffer_get_int(&m);\n\tif (success == 0) {\n\t\tdebug3(\"%s: pam_init_ctx failed\", __func__);\n\t\tbuffer_free(&m);\n\t\treturn (NULL);\n\t}\n\tbuffer_free(&m);\n\treturn (authctxt);\n}",
        "output": "1",
        "idx": 5464
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cg_rmdir(const char *path)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *cgdir = NULL, *controller;\n\tconst char *cgroup;\n\tint ret;\n\n\tif (!fc)\n\t\treturn -EIO;\n\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EINVAL;\n\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfprintf(stderr, \"rmdir: verifying access to %s:%s (req path %s)\\n\",\n\t\t\tcontroller, cgdir, path);\n\tif (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (!cgfs_remove(controller, cgroup)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\nout:\n\tfree(cgdir);\n\treturn ret;\n}",
        "output": "1",
        "idx": 5218
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vgacon_scrollback_switch(int vc_num)\n{\n\tif (!scrollback_persistent)\n\t\tvc_num = 0;\n\n\tif (!vgacon_scrollbacks[vc_num].data) {\n\t\tvgacon_scrollback_init(vc_num);\n\t} else {\n\t\tif (scrollback_persistent) {\n\t\t\tvgacon_scrollback_cur = &vgacon_scrollbacks[vc_num];\n\t\t} else {\n\t\t\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\n\t\t\tvgacon_scrollback_reset(vc_num, size);\n\t\t}\n\t}\n}",
        "output": "1",
        "idx": 1866
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TfLiteStatus EvalQuantized(TfLiteContext* context, TfLiteNode* node,\n                           OpData* data, const RuntimeShape& lhs_shape,\n                           const TfLiteTensor* lhs,\n                           const RuntimeShape& rhs_shape,\n                           const TfLiteTensor* rhs, TfLiteTensor* output) {\n  if (lhs->type == kTfLiteFloat32) {\n    TfLiteTensor* input_quantized = GetTemporary(context, node, 2);\n    TfLiteTensor* scaling_factors = GetTemporary(context, node, 3);\n    TfLiteTensor* accum_scratch = GetTemporary(context, node, 4);\n    TfLiteTensor* input_offsets = GetTemporary(context, node, 5);\n    TfLiteTensor* row_sums = GetTemporary(context, node, 6);\n    return EvalHybrid<kernel_type>(\n        context, node, data, lhs_shape, lhs, rhs_shape, rhs, input_quantized,\n        scaling_factors, accum_scratch, row_sums, input_offsets, output);\n  } else if (lhs->type == kTfLiteInt8) {\n    return EvalInt8<kernel_type>(context, data, lhs_shape, lhs, rhs_shape, rhs,\n                                 GetTensorShape(output), output);\n  } else {\n    TF_LITE_KERNEL_LOG(\n        context, \"Currently only hybrid and int8 quantization is supported.\\n\");\n    return kTfLiteError;\n  }\n  return kTfLiteOk;\n}",
        "output": "1",
        "idx": 7242
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n\n}",
        "output": "0",
        "idx": 1193
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "__perf_event_ctx_lock_double(struct perf_event *group_leader,\n\t\t\t     struct perf_event_context *ctx)\n{\n\tstruct perf_event_context *gctx;\n\nagain:\n\trcu_read_lock();\n\tgctx = READ_ONCE(group_leader->ctx);\n\tif (!atomic_inc_not_zero(&gctx->refcount)) {\n\t\trcu_read_unlock();\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\n\tmutex_lock_double(&gctx->mutex, &ctx->mutex);\n\n\tif (group_leader->ctx != gctx) {\n\t\tmutex_unlock(&ctx->mutex);\n\t\tmutex_unlock(&gctx->mutex);\n\t\tput_ctx(gctx);\n\t\tgoto again;\n\t}\n\n\treturn gctx;\n}",
        "output": "0",
        "idx": 2089
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int handle_dots(struct nameidata *nd, int type)\n{\n\tif (type == LAST_DOTDOT) {\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\treturn follow_dotdot_rcu(nd);\n\t\t} else\n\t\t\treturn follow_dotdot(nd);\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 4005
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n\tGC_REFCOUNT(ht) = 1;\n\tGC_TYPE_INFO(ht) = IS_ARRAY;\n\tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\tht->nTableSize = zend_hash_check_size(nSize);\n\tht->nTableMask = HT_MIN_MASK;\n\tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n\tht->nNextFreeElement = 0;\n\tht->pDestructor = pDestructor;\n}",
        "output": "1",
        "idx": 4098
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "For(expr_ty target, expr_ty iter, asdl_seq * body, asdl_seq * orelse, int\n    lineno, int col_offset, int end_lineno, int end_col_offset, PyArena *arena)\n{\n    stmt_ty p;\n    if (!target) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field target is required for For\");\n        return NULL;\n    }\n    if (!iter) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field iter is required for For\");\n        return NULL;\n    }\n    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->kind = For_kind;\n    p->v.For.target = target;\n    p->v.For.iter = iter;\n    p->v.For.body = body;\n    p->v.For.orelse = orelse;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    p->end_lineno = end_lineno;\n    p->end_col_offset = end_col_offset;\n    return p;\n}",
        "output": "1",
        "idx": 7190
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int isShadowTableName(sqlite3 *db, char *zName){\n  char *zTail;                  \n  Table *pTab;                  \n  Module *pMod;                 \n\n  zTail = strrchr(zName, '_');\n  if( zTail==0 ) return 0;\n  *zTail = 0;\n  pTab = sqlite3FindTable(db, zName, 0);\n  *zTail = '_';\n  if( pTab==0 ) return 0;\n  if( !IsVirtual(pTab) ) return 0;\n  pMod = (Module*)sqlite3HashFind(&db->aModule, pTab->azModuleArg[0]);\n  if( pMod==0 ) return 0;\n  if( pMod->pModule->iVersion<3 ) return 0;\n  if( pMod->pModule->xShadowName==0 ) return 0;\n  return pMod->pModule->xShadowName(zTail+1);\n}",
        "output": "1",
        "idx": 7634
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "remote_auth_timeout_cb(gpointer data)\n{\n    cib_client_t *client = data;\n\n    client->remote_auth_timeout = 0;\n\n    if (client->remote_auth == TRUE) {\n        return FALSE;\n    }\n\n    mainloop_del_fd(client->remote);\n    crm_err(\"Remote client authentication timed out\");\n\n    return FALSE;\n}",
        "output": "0",
        "idx": 5219
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void do_cpuid(int regs[], int h)\n{\n    __asm__ __volatile__(\n#if defined __x86_64__\n                         \"pushq %%rbx;\\n\"\n#else\n                         \"pushl %%ebx;\\n\"\n#endif\n                         \"cpuid;\\n\"\n#if defined __x86_64__\n                         \"popq %%rbx;\\n\"\n#else\n                         \"popl %%ebx;\\n\"\n#endif\n                         : \"=a\"(regs[0]), [ebx] \"=r\"(regs[1]), \"=c\"(regs[2]), \"=d\"(regs[3])\n                         : \"a\"(h));\n}",
        "output": "0",
        "idx": 5963
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dwc3_gadget_del_and_unmap_request(struct dwc3_ep *dep,\n\t\tstruct dwc3_request *req, int status)\n{\n\tstruct dwc3\t\t\t*dwc = dep->dwc;\n\n\treq->started = false;\n\tlist_del(&req->list);\n\treq->remaining = 0;\n\n\tif (req->request.status == -EINPROGRESS)\n\t\treq->request.status = status;\n\n\tif (req->trb)\n\t\tusb_gadget_unmap_request_by_dev(dwc->sysdev,\n\t\t\t\t&req->request, req->direction);\n\n\treq->trb = NULL;\n\ttrace_dwc3_gadget_giveback(req);\n\n\tif (dep->number > 1)\n\t\tpm_runtime_put(dwc->dev);\n}",
        "output": "0",
        "idx": 4067
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int snmp_helper(void *context, size_t hdrlen, unsigned char tag,\n\t\tconst void *data, size_t datalen)\n{\n\tstruct snmp_ctx *ctx = (struct snmp_ctx *)context;\n\t__be32 *pdata;\n\n\tif (datalen != 4)\n\t\treturn -EINVAL;\n\tpdata = (__be32 *)data;\n\tif (*pdata == ctx->from) {\n\t\tpr_debug(\"%s: %pI4 to %pI4\\n\", __func__,\n\t\t\t (void *)&ctx->from, (void *)&ctx->to);\n\n\t\tif (*ctx->check)\n\t\t\tfast_csum(ctx, (unsigned char *)data - ctx->begin);\n\t\t*pdata = ctx->to;\n\t}\n\n\treturn 1;\n}",
        "output": "0",
        "idx": 4241
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\tunsigned char max_level = 0;\n\tint unix_sock_count = 0;\n\n\tif (too_many_unix_fds(current))\n\t\treturn -ETOOMANYREFS;\n\n\tfor (i = scm->fp->count - 1; i >= 0; i--) {\n\t\tstruct sock *sk = unix_get_socket(scm->fp->fp[i]);\n\n\t\tif (sk) {\n\t\t\tunix_sock_count++;\n\t\t\tmax_level = max(max_level,\n\t\t\t\t\tunix_sk(sk)->recursion_level);\n\t\t}\n\t}\n\tif (unlikely(max_level > MAX_RECURSION_LEVEL))\n\t\treturn -ETOOMANYREFS;\n\n\tUNIXCB(skb).fp = scm_fp_dup(scm->fp);\n\tif (!UNIXCB(skb).fp)\n\t\treturn -ENOMEM;\n\n\tfor (i = scm->fp->count - 1; i >= 0; i--)\n\t\tunix_inflight(scm->fp->user, scm->fp->fp[i]);\n\treturn max_level;\n}",
        "output": "0",
        "idx": 1587
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ikev2_sub_print(netdissect_options *ndo,\n\t\tstruct isakmp *base,\n\t\tu_char np, const struct isakmp_gen *ext, const u_char *ep,\n\t\tuint32_t phase, uint32_t doi, uint32_t proto, int depth)\n{\n\tconst u_char *cp;\n\tint i;\n\tstruct isakmp_gen e;\n\n\tcp = (const u_char *)ext;\n\twhile (np) {\n\t\tND_TCHECK(*ext);\n\n\t\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\n\t\tND_TCHECK2(*ext, ntohs(e.len));\n\n\t\tdepth++;\n\t\tND_PRINT((ndo,\"\\n\"));\n\t\tfor (i = 0; i < depth; i++)\n\t\t\tND_PRINT((ndo,\"    \"));\n\t\tND_PRINT((ndo,\"(\"));\n\t\tcp = ikev2_sub0_print(ndo, base, np,\n\t\t\t\t      ext, ep, phase, doi, proto, depth);\n\t\tND_PRINT((ndo,\")\"));\n\t\tdepth--;\n\n\t\tif (cp == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tnp = e.np;\n\t\text = (const struct isakmp_gen *)cp;\n\t}\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(np)));\n\treturn NULL;\n}",
        "output": "1",
        "idx": 4864
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline __u8 l2cap_select_mode(__u8 mode, __u16 remote_feat_mask)\n{\n\tswitch (mode) {\n\tcase L2CAP_MODE_STREAMING:\n\tcase L2CAP_MODE_ERTM:\n\t\tif (l2cap_mode_supported(mode, remote_feat_mask))\n\t\t\treturn mode;\n\tdefault:\n\t\treturn L2CAP_MODE_BASIC;\n\t}\n}",
        "output": "0",
        "idx": 3097
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseContentMinify(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprJson     *child;\n    int         ji;\n\n    for (ITERATE_CONFIG(route, prop, child, ji)) {\n        if (mprGetJson(route->config, sfmt(\"app.http.content.compress[@ = '%s']\", child->value)) == 0) {\n            httpAddRouteMapping(route, child->value, \"min.${1}\");\n        }\n    }\n}",
        "output": "1",
        "idx": 5056
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool crypto_shash_alg_has_setkey(struct shash_alg *alg)\n{\n\treturn alg->setkey != shash_no_setkey;\n}",
        "output": "0",
        "idx": 2577
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_vcpu_has_lapic(vcpu) && vcpu->arch.apic->pending_events;\n}",
        "output": "0",
        "idx": 3959
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cib_remote_callback_dispatch(gpointer user_data)\n{\n    cib_t *cib = user_data;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n\n    xmlNode *msg = NULL;\n    int disconnected = 0;\n\n    crm_info(\"Message on callback channel\");\n\n    crm_recv_remote_msg(private->callback.session, &private->callback.recv_buf, private->callback.encrypted, -1, &disconnected);\n\n    msg = crm_parse_remote_buffer(&private->callback.recv_buf);\n    while (msg) {\n        const char *type = crm_element_value(msg, F_TYPE);\n        crm_trace(\"Activating %s callbacks...\", type);\n\n        if (safe_str_eq(type, T_CIB)) {\n            cib_native_callback(cib, msg, 0, 0);\n\n        } else if (safe_str_eq(type, T_CIB_NOTIFY)) {\n            g_list_foreach(cib->notify_list, cib_native_notify, msg);\n\n        } else {\n            crm_err(\"Unknown message type: %s\", type);\n        }\n\n        free_xml(msg);\n        msg = crm_parse_remote_buffer(&private->callback.recv_buf);\n    }\n\n    if (disconnected) {\n        return -1;\n    }\n\n    return 0;\n}",
        "output": "0",
        "idx": 5241
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char *cmd_hash_engine(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"on\") == 0)  {\n        dcfg->hash_is_enabled = HASH_ENABLED;\n        dcfg->hash_enforcement = HASH_ENABLED;\n    }\n    else if (strcasecmp(p1, \"off\") == 0)    {\n        dcfg->hash_is_enabled = HASH_DISABLED;\n        dcfg->hash_enforcement = HASH_DISABLED;\n    }\n    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRuleEngine: %s\", p1);\n\n    return NULL;\n}",
        "output": "1",
        "idx": 3756
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_le_3byte (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 3)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\t} ;\n} ",
        "output": "1",
        "idx": 4938
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int perf_event_task_enable(void)\n{\n\tstruct perf_event *event;\n\n\tmutex_lock(&current->perf_event_mutex);\n\tlist_for_each_entry(event, &current->perf_event_list, owner_entry)\n\t\tperf_event_for_each_child(event, perf_event_enable);\n\tmutex_unlock(&current->perf_event_mutex);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 2778
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int page_is_allowed(unsigned long pfn)\n{\n\treturn devmem_is_allowed(pfn);\n}",
        "output": "0",
        "idx": 2237
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_inquire_context(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tgss_name_t\t*src_name,\n\t\t\tgss_name_t\t*targ_name,\n\t\t\tOM_uint32\t*lifetime_rec,\n\t\t\tgss_OID\t\t*mech_type,\n\t\t\tOM_uint32\t*ctx_flags,\n\t\t\tint\t\t*locally_initiated,\n\t\t\tint\t\t*opened)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\n\tret = gss_inquire_context(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tsrc_name,\n\t\t\t\ttarg_name,\n\t\t\t\tlifetime_rec,\n\t\t\t\tmech_type,\n\t\t\t\tctx_flags,\n\t\t\t\tlocally_initiated,\n\t\t\t\topened);\n\n\treturn (ret);\n}",
        "output": "1",
        "idx": 96
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tint start = 0;\n\tu32 prev_legacy, cur_legacy;\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tprev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tcur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tif (!prev_legacy && cur_legacy)\n\t\tstart = 1;\n\tmemcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,\n\t       sizeof(kvm->arch.vpit->pit_state.channels));\n\tkvm->arch.vpit->pit_state.flags = ps->flags;\n\tkvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn 0;\n}",
        "output": "1",
        "idx": 1000
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC cchar *mprLookupJson(MprJson *obj, cchar *name)\n{\n    MprJson     *item;\n\n    if ((item = mprLookupJsonObj(obj, name)) != 0 && item->type & MPR_JSON_VALUE) {\n        return item->value;\n    }\n    return 0;\n}",
        "output": "1",
        "idx": 5092
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int override_release(char __user *release, int len)\n{\n\tint ret = 0;\n\tchar buf[65];\n\n\tif (current->personality & UNAME26) {\n\t\tchar *rest = UTS_RELEASE;\n\t\tint ndots = 0;\n\t\tunsigned v;\n\n\t\twhile (*rest) {\n\t\t\tif (*rest == '.' && ++ndots >= 3)\n\t\t\t\tbreak;\n\t\t\tif (!isdigit(*rest) && *rest != '.')\n\t\t\t\tbreak;\n\t\t\trest++;\n\t\t}\n\t\tv = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;\n\t\tsnprintf(buf, len, \"2.6.%u%s\", v, rest);\n\t\tret = copy_to_user(release, buf, len);\n\t}\n\treturn ret;\n}",
        "output": "1",
        "idx": 790
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ves_icall_System_Threading_InternalThread_Thread_free_internal (MonoInternalThread *this, HANDLE thread)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tTHREAD_DEBUG (g_message (\"%s: Closing thread %p, handle %p\", __func__, this, thread));\n\n\tif (thread)\n\t\tCloseHandle (thread);\n\n\tif (this->synch_cs) {\n\t\tDeleteCriticalSection (this->synch_cs);\n\t\tg_free (this->synch_cs);\n\t\tthis->synch_cs = NULL;\n\t}\n\n\tg_free (this->name);\n}",
        "output": "1",
        "idx": 3378
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\terror = posix_acl_update_mode(inode,\n\t\t\t\t&inode->i_mode, &acl);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tinode->i_ctime = current_time(inode);\n\tset_cached_acl(inode, type, acl);\n\treturn 0;\n}",
        "output": "0",
        "idx": 2067
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned int xdr_set_page_base(struct xdr_stream *xdr,\n\t\t\t\t      unsigned int base, unsigned int len)\n{\n\tunsigned int pgnr;\n\tunsigned int maxlen;\n\tunsigned int pgoff;\n\tunsigned int pgend;\n\tvoid *kaddr;\n\n\tmaxlen = xdr->buf->page_len;\n\tif (base >= maxlen)\n\t\treturn 0;\n\telse\n\t\tmaxlen -= base;\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\n\txdr_stream_page_set_pos(xdr, base);\n\tbase += xdr->buf->page_base;\n\n\tpgnr = base >> PAGE_SHIFT;\n\txdr->page_ptr = &xdr->buf->pages[pgnr];\n\tkaddr = page_address(*xdr->page_ptr);\n\n\tpgoff = base & ~PAGE_MASK;\n\txdr->p = (__be32*)(kaddr + pgoff);\n\n\tpgend = pgoff + len;\n\tif (pgend > PAGE_SIZE)\n\t\tpgend = PAGE_SIZE;\n\txdr->end = (__be32*)(kaddr + pgend);\n\txdr->iov = NULL;\n\treturn len;\n}",
        "output": "0",
        "idx": 2803
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ref_list_push (RefQueueEntry **head, RefQueueEntry *value)\n{\n\tRefQueueEntry *current;\n\tdo {\n\t\tcurrent = *head;\n\t\tvalue->next = current;\n\t} while (InterlockedCompareExchangePointer ((void*)head, value, current) != current);\n}",
        "output": "0",
        "idx": 4691
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hci_uart_set_proto(struct hci_uart *hu, int id)\n{\n\tconst struct hci_uart_proto *p;\n\tint err;\n\n\tp = hci_uart_get_proto(id);\n\tif (!p)\n\t\treturn -EPROTONOSUPPORT;\n\n\thu->proto = p;\n\n\terr = hci_uart_register_dev(hu);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n\treturn 0;\n}",
        "output": "0",
        "idx": 4275
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct mb2_cache *ext2_xattr_create_cache(void)\n{\n\treturn mb2_cache_create(HASH_BUCKET_BITS);\n}",
        "output": "0",
        "idx": 1657
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MprJson *queryCore(MprJson *obj, cchar *key, MprJson *value, int flags)\n{\n    MprJson     *result, *child;\n    char        *property, *rest;\n    int         termType;\n\n    if (obj == 0 || key == 0 || *key == '\\0' || obj->type & MPR_JSON_VALUE) {\n        return 0;\n    }\n    result = 0;\n    for (property = getNextTerm(obj, value, sclone(key), &rest, &termType); property; ) {\n        if (termType & JSON_PROP_COMPOUND) {\n            result = queryCompound(obj, property, rest, value, flags, termType);\n            break;\n\n        } else if (rest == 0) {\n            if (!result && !value) {\n                result = mprCreateJson(MPR_JSON_ARRAY);\n            }\n            appendItem(result, queryLeaf(obj, property, value, flags));\n            break;\n\n        } else if ((child = mprReadJsonObj(obj, property)) == 0) {\n            if (value) {\n                child = mprCreateJson(termType & JSON_PROP_ARRAY ? MPR_JSON_ARRAY : MPR_JSON_OBJ);\n                setProperty(obj, sclone(property), child);\n                obj = (MprJson*) child;\n            } else {\n                break;\n            }\n        }\n        obj = (MprJson*) child;\n        property = getNextTerm(obj, value, 0, &rest, &termType);\n    }\n    return result ? result : mprCreateJson(MPR_JSON_ARRAY);\n}",
        "output": "0",
        "idx": 7067
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void handle_service(HttpRequest req, HttpResponse res) {\n        char *name = req->url;\n        Service_T s = Util_getService(++name);\n        if (! s) {\n                send_error(req, res, SC_NOT_FOUND, \"There is no service named \\\"%s\\\"\", name ? name : \"\");\n                return;\n        }\n        do_service(req, res, s);\n}",
        "output": "0",
        "idx": 8419
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DefragVlanQinQTest(void)\n{\n    Packet *p1 = NULL, *p2 = NULL, *r = NULL;\n    int ret = 0;\n\n    DefragInit();\n\n    p1 = BuildTestPacket(1, 0, 1, 'A', 8);\n    if (p1 == NULL)\n        goto end;\n    p2 = BuildTestPacket(1, 1, 0, 'B', 8);\n    if (p2 == NULL)\n        goto end;\n\n    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)\n        goto end;\n    if ((r = Defrag(NULL, NULL, p2, NULL)) == NULL)\n        goto end;\n    SCFree(r);\n\n    p1->vlan_id[0] = 1;\n    p2->vlan_id[0] = 1;\n    p1->vlan_id[1] = 1;\n    p2->vlan_id[1] = 2;\n    if ((r = Defrag(NULL, NULL, p1, NULL)) != NULL)\n        goto end;\n    if ((r = Defrag(NULL, NULL, p2, NULL)) != NULL)\n        goto end;\n\n    ret = 1;\n\nend:\n    if (p1 != NULL)\n        SCFree(p1);\n    if (p2 != NULL)\n        SCFree(p2);\n    DefragDestroy();\n\n    return ret;\n}",
        "output": "1",
        "idx": 6608
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int blkcg_init_queue(struct request_queue *q)\n{\n\tstruct blkcg_gq *new_blkg, *blkg;\n\tbool preloaded;\n\tint ret;\n\n\tnew_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);\n\tif (!new_blkg)\n\t\treturn -ENOMEM;\n\n\tpreloaded = !radix_tree_preload(GFP_KERNEL);\n\n\trcu_read_lock();\n\tspin_lock_irq(q->queue_lock);\n\tblkg = blkg_create(&blkcg_root, q, new_blkg);\n\tspin_unlock_irq(q->queue_lock);\n\trcu_read_unlock();\n\n\tif (preloaded)\n\t\tradix_tree_preload_end();\n\n\tif (IS_ERR(blkg)) {\n\t\tblkg_free(new_blkg);\n\t\treturn PTR_ERR(blkg);\n\t}\n\n\tq->root_blkg = blkg;\n\tq->root_rl.blkg = blkg;\n\n\tret = blk_throtl_init(q);\n\tif (ret) {\n\t\tspin_lock_irq(q->queue_lock);\n\t\tblkg_destroy_all(q);\n\t\tspin_unlock_irq(q->queue_lock);\n\t}\n\treturn ret;\n}",
        "output": "1",
        "idx": 1450
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ipt_get_target_c(s);\n\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\n\t\tif (unconditional(s) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t   t->verdict < 0) {\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1757
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int hugetlb_reserve_pages(struct inode *inode,\n\t\t\t\t\tlong from, long to,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tvm_flags_t vm_flags)\n{\n\tlong ret, chg;\n\tstruct hstate *h = hstate_inode(inode);\n\n\tif (vm_flags & VM_NORESERVE)\n\t\treturn 0;\n\n\tif (!vma || vma->vm_flags & VM_MAYSHARE)\n\t\tchg = region_chg(&inode->i_mapping->private_list, from, to);\n\telse {\n\t\tstruct resv_map *resv_map = resv_map_alloc();\n\t\tif (!resv_map)\n\t\t\treturn -ENOMEM;\n\n\t\tchg = to - from;\n\n\t\tset_vma_resv_map(vma, resv_map);\n\t\tset_vma_resv_flags(vma, HPAGE_RESV_OWNER);\n\t}\n\n\tif (chg < 0)\n\t\treturn chg;\n\n\tif (hugetlb_get_quota(inode->i_mapping, chg))\n\t\treturn -ENOSPC;\n\n\tret = hugetlb_acct_memory(h, chg);\n\tif (ret < 0) {\n\t\thugetlb_put_quota(inode->i_mapping, chg);\n\t\treturn ret;\n\t}\n\n\tif (!vma || vma->vm_flags & VM_MAYSHARE)\n\t\tregion_add(&inode->i_mapping->private_list, from, to);\n\treturn 0;\n}",
        "output": "1",
        "idx": 694
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int simulate_sync(struct pt_regs *regs, unsigned int opcode)\n{\n\tif ((opcode & OPCODE) == SPEC0 && (opcode & FUNC) == SYNC) {\n\t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n\t\t\t\t1, regs, 0);\n\t\treturn 0;\n\t}\n\n\treturn -1;\t\t\t\n}",
        "output": "0",
        "idx": 585
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void receive_mountsources(int sockfd)\n{\n\tchar *mount_fds, *endp;\n\tlong new_fd;\n\n\tmount_fds = getenv(\"_LIBCONTAINER_MOUNT_FDS\");\n\n\tif (mount_fds[0] != '[') {\n\t\tbail(\"malformed _LIBCONTAINER_MOUNT_FDS env var: missing '['\");\n\t}\n\tmount_fds++;\n\n\tfor (endp = mount_fds; *endp != ']'; mount_fds = endp + 1) {\n\t\tnew_fd = strtol(mount_fds, &endp, 10);\n\t\tif (endp == mount_fds) {\n\t\t\tbail(\"malformed _LIBCONTAINER_MOUNT_FDS env var: not a number\");\n\t\t}\n\t\tif (*endp == '\\0') {\n\t\t\tbail(\"malformed _LIBCONTAINER_MOUNT_FDS env var: missing ]\");\n\t\t}\n\t\tif (new_fd == -1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (new_fd == LONG_MAX || new_fd < 0 || new_fd > INT_MAX) {\n\t\t\tbail(\"malformed _LIBCONTAINER_MOUNT_FDS env var: fds out of range\");\n\t\t}\n\n\t\treceive_fd(sockfd, new_fd);\n\t}\n}",
        "output": "0",
        "idx": 8229
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlValidNormalizeAttributeValue(xmlDocPtr doc, xmlNodePtr elem,\n\t\t\t        const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret;\n    xmlAttributePtr attrDecl = NULL;\n\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\n\tfullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n\tif (fullname == NULL)\n\t    return(NULL);\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\n    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    xmlValidNormalizeString(ret);\n    return(ret);\n}",
        "output": "0",
        "idx": 8849
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int perf_cpu_time_max_percent_handler(struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp,\n\t\t\t\tloff_t *ppos)\n{\n\tint ret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\n\tif (ret || !write)\n\t\treturn ret;\n\n\tif (sysctl_perf_cpu_time_max_percent == 100 ||\n\t    sysctl_perf_cpu_time_max_percent == 0) {\n\t\tprintk(KERN_WARNING\n\t\t       \"perf: Dynamic interrupt throttling disabled, can hang your system!\\n\");\n\t\tWRITE_ONCE(perf_sample_allowed_ns, 0);\n\t} else {\n\t\tupdate_perf_cpu_limits();\n\t}\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2169
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u32 rd_release_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n\t\t\t\t u32 sg_table_count)\n{\n\tstruct page *pg;\n\tstruct scatterlist *sg;\n\tu32 i, j, page_count = 0, sg_per_table;\n\n\tfor (i = 0; i < sg_table_count; i++) {\n\t\tsg = sg_table[i].sg_table;\n\t\tsg_per_table = sg_table[i].rd_sg_count;\n\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = sg_page(&sg[j]);\n\t\t\tif (pg) {\n\t\t\t\t__free_page(pg);\n\t\t\t\tpage_count++;\n\t\t\t}\n\t\t}\n\t\tkfree(sg);\n\t}\n\n\tkfree(sg_table);\n\treturn page_count;\n}",
        "output": "0",
        "idx": 3457
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(curl_escape)\n{\n\tchar       *str = NULL, *res = NULL;\n\tsize_t     str_len = 0;\n\tzval       *zid;\n\tphp_curl   *ch;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rs\", &zid, &str, &str_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((ch = (php_curl*)zend_fetch_resource(Z_RES_P(zid), le_curl_name, le_curl)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (ZEND_SIZE_T_INT_OVFL(str_len)) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif ((res = curl_easy_escape(ch->cp, str, str_len))) {\n\t\tRETVAL_STRING(res);\n\t\tcurl_free(res);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}",
        "output": "0",
        "idx": 5629
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t aio_setup_single_vector(struct kiocb *kiocb)\n{\n\tkiocb->ki_iovec = &kiocb->ki_inline_vec;\n\tkiocb->ki_iovec->iov_base = kiocb->ki_buf;\n\tkiocb->ki_iovec->iov_len = kiocb->ki_left;\n\tkiocb->ki_nr_segs = 1;\n\tkiocb->ki_cur_seg = 0;\n\treturn 0;\n}",
        "output": "1",
        "idx": 714
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_siocgstampns(struct net *net, struct socket *sock,\n\t\t\t   unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timespec kts;\n\tint err;\n\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);\n\tset_fs(old_fs);\n\tif (!err)\n\t\terr = compat_put_timespec(up, &kts);\n\n\treturn err;\n}",
        "output": "1",
        "idx": 758
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ext3_fsblk_t get_sb_block(void **data, struct super_block *sb)\n{\n\text3_fsblk_t\tsb_block;\n\tchar\t\t*options = (char *) *data;\n\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t\n\toptions += 3;\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\text3_msg(sb, KERN_ERR, \"error: invalid sb specification: %s\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\treturn sb_block;\n}",
        "output": "0",
        "idx": 1219
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "snmp_ber_encode_string_len(unsigned char *out, uint32_t *out_len, const char *str, uint32_t length)\n{\n  uint32_t i;\n\n  str += length - 1;\n  for(i = 0; i < length; ++i) {\n    (*out_len)++;\n    *out-- = (uint8_t)*str--;\n  }\n\n  out = snmp_ber_encode_length(out, out_len, length);\n  out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_OCTET_STRING);\n\n  return out;\n}",
        "output": "1",
        "idx": 7948
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tut8 op_MSB,op_LSB;\n\tint ret;\n\tif (!data || len < 2) {\n\t\treturn 0;\n\t}\n\tmemset (op, '\\0', sizeof (RAnalOp));\n\top->addr = addr;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->jump = op->fail = -1;\n\top->ptr = op->val = -1;\n\n\top->size = 2;\n\n\top_MSB = anal->big_endian? data[0]: data[1];\n\top_LSB = anal->big_endian? data[1]: data[0];\n\tret =  first_nibble_decode[(op_MSB>>4) & 0x0F](anal, op, (ut16)(op_MSB<<8 | op_LSB));\n\treturn ret;\n}",
        "output": "0",
        "idx": 8691
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Curl_ssl_detach_conn(struct Curl_easy *data,\n                          struct connectdata *conn)\n{\n  if(Curl_ssl->disassociate_connection) {\n    Curl_ssl->disassociate_connection(data, FIRSTSOCKET);\n    if(conn->sock[SECONDARYSOCKET] && conn->bits.sock_accepted)\n      Curl_ssl->disassociate_connection(data, SECONDARYSOCKET);\n  }\n}",
        "output": "0",
        "idx": 8459
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateFloatArray(const float *numbers,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}",
        "output": "0",
        "idx": 8257
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int hashtable_set(hashtable_t *hashtable,\n                  const char *key, size_t serial,\n                  json_t *value)\n{\n    pair_t *pair;\n    bucket_t *bucket;\n    size_t hash, index;\n\n    if(hashtable->size >= hashsize(hashtable->order))\n        if(hashtable_do_rehash(hashtable))\n            return -1;\n\n    hash = hash_str(key);\n    index = hash & hashmask(hashtable->order);\n    bucket = &hashtable->buckets[index];\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n\n    if(pair)\n    {\n        json_decref(pair->value);\n        pair->value = value;\n    }\n    else\n    {\n        pair = jsonp_malloc(offsetof(pair_t, key) + strlen(key) + 1);\n        if(!pair)\n            return -1;\n\n        pair->hash = hash;\n        pair->serial = serial;\n        strcpy(pair->key, key);\n        pair->value = value;\n        list_init(&pair->list);\n\n        insert_to_bucket(hashtable, bucket, &pair->list);\n\n        hashtable->size++;\n    }\n    return 0;\n}",
        "output": "0",
        "idx": 5975
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)\n{\n\tstruct crypto_alg *alg;\n\n\tif (!name)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tmask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);\n\ttype &= mask;\n\n\talg = crypto_alg_lookup(name, type, mask);\n\tif (!alg) {\n\t\trequest_module(\"crypto-%s\", name);\n\n\t\tif (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &\n\t\t      CRYPTO_ALG_NEED_FALLBACK))\n\t\t\trequest_module(\"crypto-%s-all\", name);\n\n\t\talg = crypto_alg_lookup(name, type, mask);\n\t}\n\n\tif (alg)\n\t\treturn crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;\n\n\treturn crypto_larval_add(name, type, mask);\n}",
        "output": "0",
        "idx": 3763
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __init netlink_add_usersock_entry(void)\n{\n\tstruct listeners *listeners;\n\tint groups = 32;\n\n\tlisteners = kzalloc(sizeof(*listeners) + NLGRPSZ(groups), GFP_KERNEL);\n\tif (!listeners)\n\t\tpanic(\"netlink_add_usersock_entry: Cannot allocate listeners\\n\");\n\n\tnetlink_table_grab();\n\n\tnl_table[NETLINK_USERSOCK].groups = groups;\n\trcu_assign_pointer(nl_table[NETLINK_USERSOCK].listeners, listeners);\n\tnl_table[NETLINK_USERSOCK].module = THIS_MODULE;\n\tnl_table[NETLINK_USERSOCK].registered = 1;\n\tnl_table[NETLINK_USERSOCK].nl_nonroot = NL_NONROOT_SEND;\n\n\tnetlink_table_ungrab();\n}",
        "output": "0",
        "idx": 1035
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ipc_rcu_putref(void *ptr)\n{\n\tif (!atomic_dec_and_test(&container_of(ptr, struct ipc_rcu_hdr, data)->refcount))\n\t\treturn;\n\n\tif (container_of(ptr, struct ipc_rcu_hdr, data)->is_vmalloc) {\n\t\tcall_rcu(&container_of(ptr, struct ipc_rcu_grace, data)->rcu,\n\t\t\t\tipc_schedule_free);\n\t} else {\n\t\tkfree_rcu(container_of(ptr, struct ipc_rcu_grace, data), rcu);\n\t}\n}",
        "output": "0",
        "idx": 3231
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool ndp_msg_check_valid(struct ndp_msg *msg)\n{\n\tsize_t len = ndp_msg_payload_len(msg);\n\tenum ndp_msg_type msg_type = ndp_msg_type(msg);\n\n\tif (len < ndp_msg_type_info(msg_type)->raw_struct_size)\n\t\treturn false;\n\treturn true;\n}",
        "output": "1",
        "idx": 5868
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mrb_class_real(struct RClass* cl)\n{\n  if (cl == 0)\n    return NULL;\n  while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {\n    cl = cl->super;\n  }\n  return cl;\n}",
        "output": "1",
        "idx": 6716
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "create_spnego_ctx(int initiate)\n{\n\tspnego_gss_ctx_id_t spnego_ctx = NULL;\n\tspnego_ctx = (spnego_gss_ctx_id_t)\n\t\tmalloc(sizeof (spnego_gss_ctx_id_rec));\n\n\tif (spnego_ctx == NULL) {\n\t\treturn (NULL);\n\t}\n\n\tspnego_ctx->magic_num = SPNEGO_MAGIC_ID;\n\tspnego_ctx->ctx_handle = GSS_C_NO_CONTEXT;\n\tspnego_ctx->mech_set = NULL;\n\tspnego_ctx->internal_mech = NULL;\n\tspnego_ctx->optionStr = NULL;\n\tspnego_ctx->DER_mechTypes.length = 0;\n\tspnego_ctx->DER_mechTypes.value = NULL;\n\tspnego_ctx->default_cred = GSS_C_NO_CREDENTIAL;\n\tspnego_ctx->mic_reqd = 0;\n\tspnego_ctx->mic_sent = 0;\n\tspnego_ctx->mic_rcvd = 0;\n\tspnego_ctx->mech_complete = 0;\n\tspnego_ctx->nego_done = 0;\n\tspnego_ctx->opened = 0;\n\tspnego_ctx->initiate = initiate;\n\tspnego_ctx->internal_name = GSS_C_NO_NAME;\n\tspnego_ctx->actual_mech = GSS_C_NO_OID;\n\n\tcheck_spnego_options(spnego_ctx);\n\n\treturn (spnego_ctx);\n}",
        "output": "0",
        "idx": 91
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __evtchn_fifo_handle_events(unsigned cpu,\n\t\t\t\t\tstruct evtchn_loop_ctrl *ctrl)\n{\n\tstruct evtchn_fifo_control_block *control_block;\n\tunsigned long ready;\n\tunsigned q;\n\n\tcontrol_block = per_cpu(cpu_control_block, cpu);\n\n\tready = xchg(&control_block->ready, 0);\n\n\twhile (ready) {\n\t\tq = find_first_bit(&ready, EVTCHN_FIFO_MAX_QUEUES);\n\t\tconsume_one_event(cpu, ctrl, control_block, q, &ready);\n\t\tready |= xchg(&control_block->ready, 0);\n\t}\n}",
        "output": "0",
        "idx": 2747
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,\n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n\tmant = JPC_QCX_GETMANT(refstepsize);\n\tnumbands = 3 * numrlvls - 2;\n\tfor (bandno = 0; bandno < numbands; ++bandno) {\n\t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +\n\t\t  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));\n\t}\n}",
        "output": "0",
        "idx": 7511
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xfrm_dump_policy_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\tstruct net *net = sock_net(cb->skb->sk);\n\n\txfrm_policy_walk_done(walk, net);\n\treturn 0;\n}",
        "output": "0",
        "idx": 2525
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long do_locks(unsigned int fd, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct flock64 kernel;\n\tstruct oabi_flock64 user;\n\tmm_segment_t fs;\n\tlong ret;\n\n\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n\t\t\t   sizeof(user)))\n\t\treturn -EFAULT;\n\tkernel.l_type\t= user.l_type;\n\tkernel.l_whence\t= user.l_whence;\n\tkernel.l_start\t= user.l_start;\n\tkernel.l_len\t= user.l_len;\n\tkernel.l_pid\t= user.l_pid;\n\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\tret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);\n\tset_fs(fs);\n\n\tif (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {\n\t\tuser.l_type\t= kernel.l_type;\n\t\tuser.l_whence\t= kernel.l_whence;\n\t\tuser.l_start\t= kernel.l_start;\n\t\tuser.l_len\t= kernel.l_len;\n\t\tuser.l_pid\t= kernel.l_pid;\n\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n\t\t\t\t &user, sizeof(user)))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}",
        "output": "0",
        "idx": 1489
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sysUpTime_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_time_ticks(varbind, oid, clock_seconds() * 100);\n}",
        "output": "1",
        "idx": 7936
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, current)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!intern->u.file.current_line && !intern->u.file.current_zval) {\n\t\tspl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC);\n\t}\n\tif (intern->u.file.current_line && (!SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV) || !intern->u.file.current_zval)) {\n\t\tRETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);\n\t} else if (intern->u.file.current_zval) {\n\t\tRETURN_ZVAL(intern->u.file.current_zval, 1, 0);\n\t}\n\tRETURN_FALSE;\n} ",
        "output": "1",
        "idx": 3918
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vt_kdsetmode(struct vc_data *vc, unsigned long mode)\n{\n\tswitch (mode) {\n\tcase KD_GRAPHICS:\n\t\tbreak;\n\tcase KD_TEXT0:\n\tcase KD_TEXT1:\n\t\tmode = KD_TEXT;\n\t\tfallthrough;\n\tcase KD_TEXT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (vc->vc_mode == mode)\n\t\treturn 0;\n\n\tvc->vc_mode = mode;\n\tif (vc->vc_num != fg_console)\n\t\treturn 0;\n\n\tconsole_lock();\n\tif (mode == KD_TEXT)\n\t\tdo_unblank_screen(1);\n\telse\n\t\tdo_blank_screen(1);\n\tconsole_unlock();\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1990
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int gup_huge_pud(pud_t orig, pud_t *pudp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\n\tif (!pud_access_permitted(orig, write))\n\t\treturn 0;\n\n\tif (pud_devmap(orig))\n\t\treturn __gup_device_huge_pud(orig, pudp, addr, end, pages, nr);\n\n\trefs = 0;\n\tpage = pud_page(orig) + ((addr & ~PUD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\thead = compound_head(pud_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(pud_val(orig) != pud_val(*pudp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\n\tSetPageReferenced(head);\n\treturn 1;\n}",
        "output": "1",
        "idx": 3150
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, next)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {\n\t\tspl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC);\n\t}\n\tintern->u.file.current_line_num++;\n} ",
        "output": "1",
        "idx": 3936
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int rose_parse_facilities(unsigned char *p,\n\tstruct rose_facilities_struct *facilities)\n{\n\tint facilities_len, len;\n\n\tfacilities_len = *p++;\n\n\tif (facilities_len == 0)\n\t\treturn 0;\n\n\twhile (facilities_len > 0) {\n\t\tif (*p == 0x00) {\n\t\t\tfacilities_len--;\n\t\t\tp++;\n\n\t\t\tswitch (*p) {\n\t\t\tcase FAC_NATIONAL:\t\t\n\t\t\t\tlen = rose_parse_national(p + 1, facilities, facilities_len - 1);\n\t\t\t\tif (len < 0)\n\t\t\t\t\treturn 0;\n\t\t\t\tfacilities_len -= len + 1;\n\t\t\t\tp += len + 1;\n\t\t\t\tbreak;\n\n\t\t\tcase FAC_CCITT:\t\t\n\t\t\t\tlen = rose_parse_ccitt(p + 1, facilities, facilities_len - 1);\n\t\t\t\tif (len < 0)\n\t\t\t\t\treturn 0;\n\t\t\t\tfacilities_len -= len + 1;\n\t\t\t\tp += len + 1;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_DEBUG \"ROSE: rose_parse_facilities - unknown facilities family %02X\\n\", *p);\n\t\t\t\tfacilities_len--;\n\t\t\t\tp++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\t\n\t}\n\n\treturn 1;\n}",
        "output": "0",
        "idx": 407
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nvmet_fc_find_target_queue(struct nvmet_fc_tgtport *tgtport,\n\t\t\t\tu64 connection_id)\n{\n\tstruct nvmet_fc_tgt_assoc *assoc;\n\tstruct nvmet_fc_tgt_queue *queue;\n\tu64 association_id = nvmet_fc_getassociationid(connection_id);\n\tu16 qid = nvmet_fc_getqueueid(connection_id);\n\tunsigned long flags;\n\n\tif (qid > NVMET_NR_QUEUES)\n\t\treturn NULL;\n\n\tspin_lock_irqsave(&tgtport->lock, flags);\n\tlist_for_each_entry(assoc, &tgtport->assoc_list, a_list) {\n\t\tif (association_id == assoc->association_id) {\n\t\t\tqueue = assoc->queues[qid];\n\t\t\tif (queue &&\n\t\t\t    (!atomic_read(&queue->connected) ||\n\t\t\t     !nvmet_fc_tgt_q_get(queue)))\n\t\t\t\tqueue = NULL;\n\t\t\tspin_unlock_irqrestore(&tgtport->lock, flags);\n\t\t\treturn queue;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&tgtport->lock, flags);\n\treturn NULL;\n}",
        "output": "0",
        "idx": 2429
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool too_many_pipe_buffers_soft(struct user_struct *user)\n{\n\treturn pipe_user_pages_soft &&\n\t       atomic_long_read(&user->pipe_bufs) >= pipe_user_pages_soft;\n}",
        "output": "0",
        "idx": 1555
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mongo_env_read_socket( mongo *conn, void *buf, int len ) {\n    char *cbuf = buf;\n\n    while ( len ) {\n        int sent = recv( conn->sock, cbuf, len, 0 );\n        if ( sent == 0 || sent == -1 ) {\n            __mongo_set_error( conn, MONGO_IO_ERROR, NULL, WSAGetLastError() );\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n\n    return MONGO_OK;\n}",
        "output": "1",
        "idx": 7900
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\tif (!prev || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}",
        "output": "1",
        "idx": 3178
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Module(asdl_seq * body, PyArena *arena)\n{\n    mod_ty p;\n    p = (mod_ty)PyArena_Malloc(arena, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->kind = Module_kind;\n    p->v.Module.body = body;\n    return p;\n}",
        "output": "1",
        "idx": 7186
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "wb_prep(netdissect_options *ndo,\n        const struct pkt_prep *prep, u_int len)\n{\n\tint n;\n\tconst struct pgstate *ps;\n\tconst u_char *ep = ndo->ndo_snapend;\n\n\tND_PRINT((ndo, \" wb-prep:\"));\n\tif (len < sizeof(*prep)) {\n\t\treturn (-1);\n\t}\n\tn = EXTRACT_32BITS(&prep->pp_n);\n\tps = (const struct pgstate *)(prep + 1);\n\twhile (--n >= 0 && ND_TTEST(*ps)) {\n\t\tconst struct id_off *io, *ie;\n\t\tchar c = '<';\n\n\t\tND_PRINT((ndo, \" %u/%s:%u\",\n\t\t    EXTRACT_32BITS(&ps->slot),\n\t\t    ipaddr_string(ndo, &ps->page.p_sid),\n\t\t    EXTRACT_32BITS(&ps->page.p_uid)));\n\t\tio = (const struct id_off *)(ps + 1);\n\t\tfor (ie = io + ps->nid; io < ie && ND_TTEST(*io); ++io) {\n\t\t\tND_PRINT((ndo, \"%c%s:%u\", c, ipaddr_string(ndo, &io->id),\n\t\t\t    EXTRACT_32BITS(&io->off)));\n\t\t\tc = ',';\n\t\t}\n\t\tND_PRINT((ndo, \">\"));\n\t\tps = (const struct pgstate *)io;\n\t}\n\treturn ((const u_char *)ps <= ep? 0 : -1);\n}",
        "output": "1",
        "idx": 4788
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error_t ftpClientParsePwdReply(FtpClientContext *context, char_t *path,\n   size_t maxLen)\n{\n   size_t length;\n   char_t *p;\n\n   p = strrchr(context->buffer, '\\\"');\n   if(p == NULL)\n      return ERROR_INVALID_SYNTAX;\n\n   *p = '\\0';\n\n   p = strchr(context->buffer, '\\\"');\n   if(p == NULL)\n      return ERROR_INVALID_SYNTAX;\n\n   length = osStrlen(p + 1);\n   length = MIN(length, maxLen);\n\n   osStrncpy(path, p + 1, length);\n   path[length] = '\\0';\n\n   return NO_ERROR;\n}",
        "output": "1",
        "idx": 8626
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tun_net_init(struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\tswitch (tun->flags & TUN_TYPE_MASK) {\n\tcase TUN_TUN_DEV:\n\t\tdev->netdev_ops = &tun_netdev_ops;\n\n\t\tdev->hard_header_len = 0;\n\t\tdev->addr_len = 0;\n\t\tdev->mtu = 1500;\n\n\t\tdev->type = ARPHRD_NONE;\n\t\tdev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\t\tdev->tx_queue_len = TUN_READQ_SIZE;  \n\t\tbreak;\n\n\tcase TUN_TAP_DEV:\n\t\tdev->netdev_ops = &tap_netdev_ops;\n\t\tether_setup(dev);\n\t\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\n\t\trandom_ether_addr(dev->dev_addr);\n\n\t\tdev->tx_queue_len = TUN_READQ_SIZE;  \n\t\tbreak;\n\t}\n}",
        "output": "0",
        "idx": 749
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void control_work_handler(struct work_struct *work)\n{\n\tstruct ports_device *portdev;\n\tstruct virtqueue *vq;\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\n\tportdev = container_of(work, struct ports_device, control_work);\n\tvq = portdev->c_ivq;\n\n\tspin_lock(&portdev->c_ivq_lock);\n\twhile ((buf = virtqueue_get_buf(vq, &len))) {\n\t\tspin_unlock(&portdev->c_ivq_lock);\n\n\t\tbuf->len = min_t(size_t, len, buf->size);\n\t\tbuf->offset = 0;\n\n\t\thandle_control_message(vq->vdev, portdev, buf);\n\n\t\tspin_lock(&portdev->c_ivq_lock);\n\t\tif (add_inbuf(portdev->c_ivq, buf) < 0) {\n\t\t\tdev_warn(&portdev->vdev->dev,\n\t\t\t\t \"Error adding buffer to queue\\n\");\n\t\t\tfree_buf(buf, false);\n\t\t}\n\t}\n\tspin_unlock(&portdev->c_ivq_lock);\n}",
        "output": "0",
        "idx": 2823
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)\n{\n\tstruct serial_icounter_struct icount;\n\tstruct sb_uart_icount cnow;\n\tstruct sb_uart_port *port = state->port;\n\n\tspin_lock_irq(&port->lock);\n\tmemcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));\n\tspin_unlock_irq(&port->lock);\n\n\ticount.cts         = cnow.cts;\n\ticount.dsr         = cnow.dsr;\n\ticount.rng         = cnow.rng;\n\ticount.dcd         = cnow.dcd;\n\ticount.rx          = cnow.rx;\n\ticount.tx          = cnow.tx;\n\ticount.frame       = cnow.frame;\n\ticount.overrun     = cnow.overrun;\n\ticount.parity      = cnow.parity;\n\ticount.brk         = cnow.brk;\n\ticount.buf_overrun = cnow.buf_overrun;\n\n\treturn copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;\n}",
        "output": "1",
        "idx": 2362
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool unconditional(const struct ip6t_ip6 *ipv6)\n{\n\tstatic const struct ip6t_ip6 uncond;\n\n\treturn memcmp(ipv6, &uncond, sizeof(uncond)) == 0;\n}",
        "output": "1",
        "idx": 1198
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int user_match(const struct key *key, const struct key_match_data *match_data)\n{\n\treturn strcmp(key->description, match_data->raw_data) == 0;\n}",
        "output": "1",
        "idx": 2682
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "entry_guard_obeys_restriction(const entry_guard_t *guard,\n                              const entry_guard_restriction_t *rst)\n{\n  tor_assert(guard);\n  if (! rst)\n    return 1; \n\n  const node_t *node = node_get_by_id((const char*)rst->exclude_id);\n  if (node && guard_in_node_family(guard, node))\n    return 0;\n\n  return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN);\n}",
        "output": "0",
        "idx": 8529
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cjson_get_object_item_should_not_crash_with_array(void) {\n    cJSON *array = NULL;\n    cJSON *found = NULL;\n    array = cJSON_Parse(\"[1]\");\n\n    found = cJSON_GetObjectItem(array, \"name\");\n    TEST_ASSERT_NULL(found);\n\n    cJSON_Delete(array);\n}",
        "output": "0",
        "idx": 7899
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pq_buffer_has_data(void)\n{\n\treturn (PqRecvPointer < PqRecvLength);\n}",
        "output": "0",
        "idx": 6311
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void hugetlb_put_quota(struct address_space *mapping, long delta)\n{\n\tstruct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(mapping->host->i_sb);\n\n\tif (sbinfo->free_blocks > -1) {\n\t\tspin_lock(&sbinfo->stat_lock);\n\t\tsbinfo->free_blocks += delta;\n\t\tspin_unlock(&sbinfo->stat_lock);\n\t}\n}",
        "output": "1",
        "idx": 684
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tmemset(la, 0, sizeof(struct sockaddr_l2));\n\taddr->sa_family = AF_BLUETOOTH;\n\t*len = sizeof(struct sockaddr_l2);\n\n\tif (peer) {\n\t\tla->l2_psm = chan->psm;\n\t\tbacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);\n\t\tla->l2_cid = cpu_to_le16(chan->dcid);\n\t} else {\n\t\tla->l2_psm = chan->sport;\n\t\tbacpy(&la->l2_bdaddr, &bt_sk(sk)->src);\n\t\tla->l2_cid = cpu_to_le16(chan->scid);\n\t}\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1009
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void acpi_ns_terminate(void)\n{\n\tacpi_status status;\n\tunion acpi_operand_object *prev;\n\tunion acpi_operand_object *next;\n\n\tACPI_FUNCTION_TRACE(ns_terminate);\n\n\n\tnext = acpi_gbl_module_code_list;\n\twhile (next) {\n\t\tprev = next;\n\t\tnext = next->method.mutex;\n\t\tprev->method.mutex = NULL;\t\n\t\tacpi_ut_remove_reference(prev);\n\t}\n\n\tacpi_ns_delete_namespace_subtree(acpi_gbl_root_node);\n\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_VOID;\n\t}\n\n\tacpi_ns_delete_node(acpi_gbl_root_node);\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\n\tACPI_DEBUG_PRINT((ACPI_DB_INFO, \"Namespace freed\\n\"));\n\treturn_VOID;\n}",
        "output": "0",
        "idx": 2263
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "le64addr_string(netdissect_options *ndo, const u_char *ep)\n{\n\tconst unsigned int len = 8;\n\tregister u_int i;\n\tregister char *cp;\n\tregister struct enamemem *tp;\n\tchar buf[BUFSIZE];\n\n\ttp = lookup_bytestring(ndo, ep, len);\n\tif (tp->e_name)\n\t\treturn (tp->e_name);\n\n\tcp = buf;\n\tfor (i = len; i > 0 ; --i) {\n\t\t*cp++ = hex[*(ep + i - 1) >> 4];\n\t\t*cp++ = hex[*(ep + i - 1) & 0xf];\n\t\t*cp++ = ':';\n\t}\n\tcp --;\n\n\t*cp = '\\0';\n\n\ttp->e_name = strdup(buf);\n\tif (tp->e_name == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"le64addr_string: strdup(buf)\");\n\n\treturn (tp->e_name);\n}",
        "output": "1",
        "idx": 4706
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\tunsigned char max_level = 0;\n\tint unix_sock_count = 0;\n\n\tif (too_many_unix_fds(current))\n\t\treturn -ETOOMANYREFS;\n\n\tfor (i = scm->fp->count - 1; i >= 0; i--) {\n\t\tstruct sock *sk = unix_get_socket(scm->fp->fp[i]);\n\n\t\tif (sk) {\n\t\t\tunix_sock_count++;\n\t\t\tmax_level = max(max_level,\n\t\t\t\t\tunix_sk(sk)->recursion_level);\n\t\t}\n\t}\n\tif (unlikely(max_level > MAX_RECURSION_LEVEL))\n\t\treturn -ETOOMANYREFS;\n\n\tUNIXCB(skb).fp = scm_fp_dup(scm->fp);\n\tif (!UNIXCB(skb).fp)\n\t\treturn -ENOMEM;\n\n\tfor (i = scm->fp->count - 1; i >= 0; i--)\n\t\tunix_inflight(scm->fp->fp[i]);\n\treturn max_level;\n}",
        "output": "0",
        "idx": 1499
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "INST_HANDLER (lds) {\t\n\tif (len < 4) {\n\t\treturn;\n\t}\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tint k = (buf[3] << 8) | buf[2];\n\top->ptr = k;\n\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 0);\n\tESIL_A (\"r%d,=,\", d);\n}",
        "output": "0",
        "idx": 8699
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "error_t lpc546xxEthUpdateMacConfig(NetInterface *interface)\n{\n   uint32_t config;\n\n   config = ENET->MAC_CONFIG;\n\n   if(interface->linkSpeed == NIC_LINK_SPEED_100MBPS)\n   {\n      config |= ENET_MAC_CONFIG_FES_MASK;\n   }\n   else\n   {\n      config &= ~ENET_MAC_CONFIG_FES_MASK;\n   }\n\n   if(interface->duplexMode == NIC_FULL_DUPLEX_MODE)\n   {\n      config |= ENET_MAC_CONFIG_DM_MASK;\n   }\n   else\n   {\n      config &= ~ENET_MAC_CONFIG_DM_MASK;\n   }\n\n   ENET->MAC_CONFIG = config;\n\n   return NO_ERROR;\n}",
        "output": "1",
        "idx": 8596
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int timer_overrun_to_int(struct k_itimer *timr, int baseval)\n{\n\ts64 sum = timr->it_overrun_last + (s64)baseval;\n\n\treturn sum > (s64)INT_MAX ? INT_MAX : (int)sum;\n}",
        "output": "0",
        "idx": 4133
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_event_ctx_unlock(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx)\n{\n\tmutex_unlock(&ctx->mutex);\n\tput_ctx(ctx);\n}",
        "output": "0",
        "idx": 3819
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static EjsAny *app_env(Ejs *ejs, EjsObj *app, int argc, EjsObj **argv)\n{\n#if VXWORKS\n    return ESV(null);\n#else\n    EjsPot  *result;\n    char        **ep, *pair, *key, *value;\n\n    result = ejsCreatePot(ejs, ESV(Object), 0);\n    for (ep = environ; ep && *ep; ep++) {\n        pair = sclone(*ep);\n        key = stok(pair, \"=\", &value);\n        ejsSetPropertyByName(ejs, result, EN(key), ejsCreateStringFromAsc(ejs, value));\n    }\n    return result;\n#endif\n}",
        "output": "1",
        "idx": 4966
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t k90_show_macro_mode(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tconst char *macro_mode;\n\tchar data[8];\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_GET_MODE,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 2,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial mode (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\n\tswitch (data[0]) {\n\tcase K90_MACRO_MODE_HW:\n\t\tmacro_mode = \"HW\";\n\t\tbreak;\n\n\tcase K90_MACRO_MODE_SW:\n\t\tmacro_mode = \"SW\";\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"K90 in unknown mode: %02hhx.\\n\",\n\t\t\t data[0]);\n\t\treturn -EIO;\n\t}\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", macro_mode);\n}",
        "output": "1",
        "idx": 1426
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dns_resolver_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key)) {\n\t\tint err = PTR_ERR(key->payload.data[dns_key_error]);\n\n\t\tif (err)\n\t\t\tseq_printf(m, \": %d\", err);\n\t\telse\n\t\t\tseq_printf(m, \": %u\", key->datalen);\n\t}\n}",
        "output": "1",
        "idx": 1712
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int install_thread_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tBUG_ON(new->thread_keyring);\n\n\tret = install_thread_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\n\treturn commit_creds(new);\n}",
        "output": "1",
        "idx": 1560
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct ucma_multicast* ucma_alloc_multicast(struct ucma_context *ctx)\n{\n\tstruct ucma_multicast *mc;\n\n\tmc = kzalloc(sizeof(*mc), GFP_KERNEL);\n\tif (!mc)\n\t\treturn NULL;\n\n\tmutex_lock(&mut);\n\tmc->id = idr_alloc(&multicast_idr, NULL, 0, 0, GFP_KERNEL);\n\tmutex_unlock(&mut);\n\tif (mc->id < 0)\n\t\tgoto error;\n\n\tmc->ctx = ctx;\n\tlist_add_tail(&mc->list, &ctx->mc_list);\n\treturn mc;\n\nerror:\n\tkfree(mc);\n\treturn NULL;\n}",
        "output": "0",
        "idx": 4097
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hashtable_do_rehash(hashtable_t *hashtable)\n{\n    list_t *list, *next;\n    pair_t *pair;\n    size_t i, index, new_size;\n\n    jsonp_free(hashtable->buckets);\n\n    hashtable->order++;\n    new_size = hashsize(hashtable->order);\n\n    hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n    if(!hashtable->buckets)\n        return -1;\n\n    for(i = 0; i < hashsize(hashtable->order); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n\n    list = hashtable->list.next;\n    list_init(&hashtable->list);\n\n    for(; list != &hashtable->list; list = next) {\n        next = list->next;\n        pair = list_to_pair(list);\n        index = pair->hash % new_size;\n        insert_to_bucket(hashtable, &hashtable->buckets[index], &pair->list);\n    }\n\n    return 0;\n}",
        "output": "0",
        "idx": 5979
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)\n{\n\tstruct ip_options_rcu *opt;\n\tint res = -ENOMSG;\n\n\trcu_read_lock();\n\topt = rcu_dereference(inet_sk(sk)->inet_opt);\n\tif (opt && opt->opt.cipso)\n\t\tres = cipso_v4_getattr(opt->opt.__data +\n\t\t\t\t\t\topt->opt.cipso -\n\t\t\t\t\t\tsizeof(struct iphdr),\n\t\t\t\t       secattr);\n\trcu_read_unlock();\n\treturn res;\n}",
        "output": "0",
        "idx": 465
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *cJSON_PrintUnformatted(cJSON *item)\t{return print_value(item,0,0,0);}",
        "output": "0",
        "idx": 8269
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_verify_mic(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_buffer_t msg_buffer,\n\t\tconst gss_buffer_t token_buffer,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_NO_CONTEXT);\n\n\tret = gss_verify_mic(minor_status,\n\t\t\t    sc->ctx_handle,\n\t\t\t    msg_buffer,\n\t\t\t    token_buffer,\n\t\t\t    qop_state);\n\treturn (ret);\n}",
        "output": "0",
        "idx": 85
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\tspl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);\n\n\tobject->u.dir.index++;\n\tdo {\n\t\tspl_filesystem_dir_read(object TSRMLS_CC);\n\t} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));\n\tif (object->file_name) {\n\t\tefree(object->file_name);\n\t\tobject->file_name = NULL;\n\t}\n\tif (iterator->current) {\n\t\tzval_ptr_dtor(&iterator->current);\n\t\titerator->current = NULL;\n\t}\n}",
        "output": "0",
        "idx": 5549
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void o2nm_unlock_subsystem(void)\n{\n\tmutex_unlock(&o2nm_cluster_group.cs_subsys.su_mutex);\n}",
        "output": "0",
        "idx": 2559
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void lzxd_free(struct lzxd_stream *lzx) {\n  struct mspack_system *sys;\n  if (lzx) {\n    sys = lzx->sys;\n    sys->free(lzx->inbuf);\n    sys->free(lzx->window);\n    sys->free(lzx);\n  }\n}",
        "output": "1",
        "idx": 3796
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct btrfs_device *btrfs_find_device_by_devspec(\n\t\tstruct btrfs_fs_info *fs_info, u64 devid,\n\t\tconst char *device_path)\n{\n\tstruct btrfs_device *device;\n\n\tif (devid) {\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, NULL,\n\t\t\t\t\t   NULL, true);\n\t\tif (!device)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\treturn device;\n\t}\n\n\tif (!device_path || !device_path[0])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (strcmp(device_path, \"missing\") == 0) {\n\t\tlist_for_each_entry(device, &fs_info->fs_devices->devices,\n\t\t\t\t    dev_list) {\n\t\t\tif (test_bit(BTRFS_DEV_STATE_IN_FS_METADATA,\n\t\t\t\t     &device->dev_state) && !device->bdev)\n\t\t\t\treturn device;\n\t\t}\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\treturn btrfs_find_device_by_path(fs_info, device_path);\n}",
        "output": "0",
        "idx": 4271
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ex_function(exarg_T *eap)\n{\n    garray_T lines_to_free;\n\n    ga_init2(&lines_to_free, sizeof(char_u *), 50);\n    (void)define_function(eap, NULL, &lines_to_free);\n    ga_clear_strings(&lines_to_free);\n}",
        "output": "0",
        "idx": 7945
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseParams(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprJson     *child;\n    cchar       *name, *value;\n    int         not, ji;\n\n    for (ITERATE_CONFIG(route, prop, child, ji)) {\n        name = mprGetJson(child, \"name\");\n        value = mprGetJson(child, \"value\");\n        not = smatch(mprGetJson(child, \"equals\"), \"true\") ? 0 : HTTP_ROUTE_NOT;\n        httpAddRouteParam(route, name, value, not);\n    }\n}",
        "output": "1",
        "idx": 5034
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __detach_mounts(struct dentry *dentry)\n{\n\tstruct mountpoint *mp;\n\tstruct mount *mnt;\n\n\tnamespace_lock();\n\tmp = lookup_mountpoint(dentry);\n\tif (IS_ERR_OR_NULL(mp))\n\t\tgoto out_unlock;\n\n\tlock_mount_hash();\n\twhile (!hlist_empty(&mp->m_list)) {\n\t\tmnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);\n\t\tif (mnt->mnt.mnt_flags & MNT_UMOUNT) {\n\t\t\tstruct mount *p, *tmp;\n\t\t\tlist_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {\n\t\t\t\thlist_add_head(&p->mnt_umount.s_list, &unmounted);\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\telse umount_tree(mnt, 0);\n\t}\n\tunlock_mount_hash();\n\tput_mountpoint(mp);\nout_unlock:\n\tnamespace_unlock();\n}",
        "output": "1",
        "idx": 2822
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_emul_dinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)\n{\n\tint error;\n\tstruct pci_emul_dummy *dummy;\n\n\tdummy = calloc(1, sizeof(struct pci_emul_dummy));\n\n\tdev->arg = dummy;\n\n\tpci_set_cfgdata16(dev, PCIR_DEVICE, 0x0001);\n\tpci_set_cfgdata16(dev, PCIR_VENDOR, 0x10DD);\n\tpci_set_cfgdata8(dev, PCIR_CLASS, 0x02);\n\n\terror = pci_emul_add_msicap(dev, PCI_EMUL_MSI_MSGS);\n\tassert(error == 0);\n\n\terror = pci_emul_alloc_bar(dev, 0, PCIBAR_IO, DIOSZ);\n\tassert(error == 0);\n\n\terror = pci_emul_alloc_bar(dev, 1, PCIBAR_MEM32, DMEMSZ);\n\tassert(error == 0);\n\n\terror = pci_emul_alloc_bar(dev, 2, PCIBAR_MEM32, DMEMSZ);\n\tassert(error == 0);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 7606
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parse_field(netdissect_options *ndo, const char **pptr, int *len)\n{\n    const char *s;\n\n    if (*len <= 0 || !pptr || !*pptr)\n\treturn NULL;\n    if (*pptr > (const char *) ndo->ndo_snapend)\n\treturn NULL;\n\n    s = *pptr;\n    while (*pptr <= (const char *) ndo->ndo_snapend && *len >= 0 && **pptr) {\n\t(*pptr)++;\n\t(*len)--;\n    }\n    (*pptr)++;\n    (*len)--;\n    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)\n\treturn NULL;\n    return s;\n}",
        "output": "1",
        "idx": 4718
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileInfo, getPath)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar *path;\n\tint path_len;\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n  \tpath = spl_filesystem_object_get_path(intern, &path_len TSRMLS_CC);\n\tRETURN_STRINGL(path, path_len, 1);\n}",
        "output": "1",
        "idx": 3934
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvaser_usb_leaf_set_opt_mode(const struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->id = CMD_SET_CTRL_MODE;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_ctrl_mode);\n\tcmd->u.ctrl_mode.tid = 0xff;\n\tcmd->u.ctrl_mode.channel = priv->channel;\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tcmd->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_SILENT;\n\telse\n\t\tcmd->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_NORMAL;\n\n\trc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len);\n\n\tkfree(cmd);\n\treturn rc;\n}",
        "output": "0",
        "idx": 4589
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mb2_cache_entry_touch(struct mb2_cache *cache,\n\t\t\t   struct mb2_cache_entry *entry)\n{\n\tspin_lock(&cache->c_lru_list_lock);\n\tif (!list_empty(&entry->e_lru_list))\n\t\tlist_move_tail(&cache->c_lru_list, &entry->e_lru_list);\n\tspin_unlock(&cache->c_lru_list_lock);\n}",
        "output": "0",
        "idx": 1617
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static enum hrtimer_restart perf_swevent_hrtimer(struct hrtimer *hrtimer)\n{\n\tenum hrtimer_restart ret = HRTIMER_RESTART;\n\tstruct perf_sample_data data;\n\tstruct pt_regs *regs;\n\tstruct perf_event *event;\n\tu64 period;\n\n\tevent = container_of(hrtimer, struct perf_event, hw.hrtimer);\n\n\tif (event->state != PERF_EVENT_STATE_ACTIVE)\n\t\treturn HRTIMER_NORESTART;\n\n\tevent->pmu->read(event);\n\n\tperf_sample_data_init(&data, 0);\n\tdata.period = event->hw.last_period;\n\tregs = get_irq_regs();\n\n\tif (regs && !perf_exclude_event(event, regs)) {\n\t\tif (!(event->attr.exclude_idle && current->pid == 0))\n\t\t\tif (perf_event_overflow(event, 0, &data, regs))\n\t\t\t\tret = HRTIMER_NORESTART;\n\t}\n\n\tperiod = max_t(u64, 10000, event->hw.sample_period);\n\thrtimer_forward_now(hrtimer, ns_to_ktime(period));\n\n\treturn ret;\n}",
        "output": "1",
        "idx": 520
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {\n\t\thid_info(hdev, \"fixing up Cherry Cymotion report descriptor\\n\");\n\t\trdesc[11] = rdesc[16] = 0xff;\n\t\trdesc[12] = rdesc[17] = 0x03;\n\t}\n\treturn rdesc;\n}",
        "output": "1",
        "idx": 2646
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\tsize_t weights_size;\n\n\tif (overflow2(windows_size, sizeof(double))) {\n\t\treturn NULL;\n\t} else {\n\t\tweights_size = windows_size * sizeof(double);\n\t}\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tres->ContribRow[u].Weights = (double *) gdMalloc(weights_size);\n\t\tif (res->ContribRow[u].Weights == NULL) {\n\t\t\tunsigned int i;\n\n\t\t\tfor (i=0;i<u;i++) {\n\t\t\t\tgdFree(res->ContribRow[i].Weights);\n\t\t\t}\n\t\t\tgdFree(res->ContribRow);\n\t\t\tgdFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}",
        "output": "0",
        "idx": 6199
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ntlm_free_message_fields_buffer(NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields)\n\t{\n\t\tif (fields->Buffer)\n\t\t{\n\t\t\tfree(fields->Buffer);\n\t\t\tfields->Len = 0;\n\t\t\tfields->MaxLen = 0;\n\t\t\tfields->Buffer = NULL;\n\t\t\tfields->BufferOffset = 0;\n\t\t}\n\t}\n}",
        "output": "1",
        "idx": 4192
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __inline__ void scm_set_cred(struct scm_cookie *scm,\n\t\t\t\t    struct pid *pid, const struct cred *cred)\n{\n\tscm->pid  = get_pid(pid);\n\tscm->cred = cred ? get_cred(cred) : NULL;\n\tscm->creds.pid = pid_vnr(pid);\n\tscm->creds.uid = cred ? cred->uid : INVALID_UID;\n\tscm->creds.gid = cred ? cred->gid : INVALID_GID;\n}",
        "output": "0",
        "idx": 1327
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cJSON_ReplaceItemInObject( cJSON *object, const char *string, cJSON *newitem )\n{\n\tint i = 0;\n\tcJSON *c = object->child;\n\twhile ( c && cJSON_strcasecmp( c->string, string ) ) {\n\t\t++i;\n\t\tc = c->next;\n\t}\n\tif ( c ) {\n\t\tnewitem->string = cJSON_strdup( string );\n\t\tcJSON_ReplaceItemInArray( object, i, newitem );\n\t}\n}",
        "output": "1",
        "idx": 5880
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __socket_slurp (RSocket *s, ut8 *buf, int bufsz) {\n\tint i;\n\tint chsz = 1;\n\tif (r_socket_read_block (s, (ut8 *) buf, 1) != 1) {\n\t\treturn 0;\n\t}\n\tfor (i = 1; i < bufsz; i += chsz) {\n\t\tbuf[i] =0;\n\t\tr_socket_block_time (s, 1, 0, 1000);\n\t\tint olen = r_socket_read_block (s, (ut8 *) buf + i , chsz);\n\t\tif (olen != chsz) {\n\t\t\tbuf[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}",
        "output": "1",
        "idx": 6420
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ast2obj_withitem(void* _o)\n{\n    withitem_ty o = (withitem_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n\n    result = PyType_GenericNew(withitem_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_expr(o->context_expr);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_context_expr, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_expr(o->optional_vars);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_optional_vars, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    return result;\nfailed:\n    Py_XDECREF(value);\n    Py_XDECREF(result);\n    return NULL;\n}",
        "output": "1",
        "idx": 7674
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dns_resolver_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_positive(key)) {\n\t\tint err = PTR_ERR(key->payload.data[dns_key_error]);\n\n\t\tif (err)\n\t\t\tseq_printf(m, \": %d\", err);\n\t\telse\n\t\t\tseq_printf(m, \": %u\", key->datalen);\n\t}\n}",
        "output": "0",
        "idx": 2479
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)\n{\n\tunsigned long val;\n\tvoid *ptr = NULL;\n\n\tif (!atomic_pool) {\n\t\tWARN(1, \"coherent pool not initialised!\\n\");\n\t\treturn NULL;\n\t}\n\n\tval = gen_pool_alloc(atomic_pool, size);\n\tif (val) {\n\t\tphys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);\n\n\t\t*ret_page = phys_to_page(phys);\n\t\tptr = (void *)val;\n\t\tmemset(ptr, 0, size);\n\t}\n\n\treturn ptr;\n}",
        "output": "0",
        "idx": 3943
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void buffer_pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n\n\tref->ref++;\n}",
        "output": "1",
        "idx": 3170
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_name)\n{\n\tzval**\tele_value\t= NULL;\n\n\tif(zend_hash_find(hash_arr , key_name , strlen(key_name) + 1 ,(void **)&ele_value ) == SUCCESS ) {\n\t\tif(Z_TYPE_PP(ele_value)!= IS_STRING ){\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif(strcmp(key_name, LOC_LANG_TAG) != 0 && \n\t\t   strcmp(key_name, LOC_GRANDFATHERED_LANG_TAG)!=0 ) {\n\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n\t\t}\n\t\tsmart_str_appendl(loc_name, Z_STRVAL_PP(ele_value) , Z_STRLEN_PP(ele_value));\n\t\treturn SUCCESS;\n\t}\n\n\treturn LOC_NOT_FOUND;\n}",
        "output": "1",
        "idx": 3904
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_mibindex_add( const char *dirname, int i )\n{\n    const int old_mibindex_max = _mibindex_max;\n\n    DEBUGMSGTL((\"mibindex\", \"add: %s (%d)\\n\", dirname, i ));\n    if ( i == -1 )\n        i = _mibindex++;\n    if ( i >= _mibindex_max ) {\n        _mibindex_max = i + 10;\n        _mibindexes = realloc(_mibindexes,\n                              _mibindex_max * sizeof(_mibindexes[0]));\n        netsnmp_assert(_mibindexes);\n        memset(_mibindexes + old_mibindex_max, 0,\n               (_mibindex_max - old_mibindex_max) * sizeof(_mibindexes[0]));\n    }\n\n    _mibindexes[ i ] = strdup( dirname );\n    if ( i >= _mibindex )\n        _mibindex = i+1;\n\n    DEBUGMSGTL((\"mibindex\", \"add: %d/%d/%d\\n\", i, _mibindex, _mibindex_max ));\n    return i;\n}",
        "output": "1",
        "idx": 7806
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ffs_user_copy_worker(struct work_struct *work)\n{\n\tstruct ffs_io_data *io_data = container_of(work, struct ffs_io_data,\n\t\t\t\t\t\t   work);\n\tint ret = io_data->req->status ? io_data->req->status :\n\t\t\t\t\t io_data->req->actual;\n\n\tif (io_data->read && ret > 0) {\n\t\tuse_mm(io_data->mm);\n\t\tret = copy_to_iter(io_data->buf, ret, &io_data->data);\n\t\tif (iov_iter_count(&io_data->data))\n\t\t\tret = -EFAULT;\n\t\tunuse_mm(io_data->mm);\n\t}\n\n\tio_data->kiocb->ki_complete(io_data->kiocb, ret, ret);\n\n\tif (io_data->ffs->ffs_eventfd &&\n\t    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))\n\t\teventfd_signal(io_data->ffs->ffs_eventfd, 1);\n\n\tusb_ep_free_request(io_data->ep, io_data->req);\n\n\tio_data->kiocb->private = NULL;\n\tif (io_data->read)\n\t\tkfree(io_data->to_free);\n\tkfree(io_data->buf);\n\tkfree(io_data);\n}",
        "output": "1",
        "idx": 1228
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, next)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {\n\t\tspl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC);\n\t}\n\tintern->u.file.current_line_num++;\n} ",
        "output": "0",
        "idx": 5545
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\tint overflow_error = 0;\n\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tif (overflow2(windows_size, sizeof(double))) {\n\t\t\toverflow_error = 1;\n\t\t} else {\n\t\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n\t\t}\n\t\tif (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {\n\t\t\tunsigned int i;\n\t\t\tu--;\n\t\t\tfor (i=0;i<=u;i++) {\n\t\t\t\tgdFree(res->ContribRow[i].Weights);\n\t\t\t}\n\t\t\tgdFree(res->ContribRow);\n\t\t\tgdFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}",
        "output": "1",
        "idx": 4454
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(void) gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n{\n\t_gdImageGifCtx(im, out);\n}",
        "output": "0",
        "idx": 6221
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void lxc_execute_bind_init(struct lxc_conf *conf)\n{\n\tint ret;\n\tchar path[PATH_MAX], destpath[PATH_MAX], *p;\n\n\tp = choose_init(conf->rootfs.mount);\n\tif (p) {\n\t\tfree(p);\n\t\treturn;\n\t}\n\n\tret = snprintf(path, PATH_MAX, SBINDIR \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long searching for lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(path)) {\n\t\tINFO(\"%s does not exist on host\", path);\n\t\treturn;\n\t}\n\n\tret = snprintf(destpath, PATH_MAX, \"%s%s\", conf->rootfs.mount, \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long for container's lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(destpath)) {\n\t\tFILE * pathfile = fopen(destpath, \"wb\");\n\t\tif (!pathfile) {\n\t\t\tSYSERROR(\"Failed to create mount target '%s'\", destpath);\n\t\t\treturn;\n\t\t}\n\t\tfclose(pathfile);\n\t}\n\n\tret = mount(path, destpath, \"none\", MS_BIND, NULL);\n\tif (ret < 0)\n\t\tSYSERROR(\"Failed to bind lxc.init.static into container\");\n\tINFO(\"lxc.init.static bound into container at %s\", path);\n}",
        "output": "1",
        "idx": 4368
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "init_syntax_once ()\n{\n   register int c;\n   static int done = 0;\n\n   if (done)\n     return;\n   bzero (re_syntax_table, sizeof re_syntax_table);\n\n   for (c = 0; c < CHAR_SET_SIZE; ++c)\n     if (ISALNUM (c))\n\tre_syntax_table[c] = Sword;\n\n   re_syntax_table['_'] = Sword;\n\n   done = 1;\n}",
        "output": "0",
        "idx": 5
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)\n{\n\tstruct cred *cred;\n\n\tif (!(unshare_flags & CLONE_NEWUSER))\n\t\treturn 0;\n\n\tcred = prepare_creds();\n\tif (!cred)\n\t\treturn -ENOMEM;\n\n\t*new_cred = cred;\n\treturn create_user_ns(cred);\n}",
        "output": "1",
        "idx": 2324
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rcomp;\n\n\tsnprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"compression\");\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "1",
        "idx": 852
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "open_log_file(const char *name, const char *prog, const char *namespace, const char *instance)\n{\n\tchar *file_name;\n\n\tif (log_file) {\n\t\tfclose(log_file);\n\t\tlog_file = NULL;\n\t}\n\n\tif (!name)\n\t\treturn;\n\n\tfile_name = make_file_name(name, prog, namespace, instance);\n\n\tlog_file = fopen(file_name, \"a\");\n\tif (log_file) {\n\t\tint n = fileno(log_file);\n\t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));\n\t\tfcntl(n, F_SETFL, O_NONBLOCK | fcntl(n, F_GETFL));\n\t}\n\n\tFREE(file_name);\n}",
        "output": "1",
        "idx": 7098
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xfs_iget_check_free_state(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tif (flags & XFS_IGET_CREATE) {\n\t\tif (VFS_I(ip)->i_mode != 0) {\n\t\t\txfs_warn(ip->i_mount,\n\"Corruption detected! Free inode 0x%llx not marked free! (mode 0x%x)\",\n\t\t\t\tip->i_ino, VFS_I(ip)->i_mode);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\n\t\tif (ip->i_d.di_nblocks != 0) {\n\t\t\txfs_warn(ip->i_mount,\n\"Corruption detected! Free inode 0x%llx has blocks allocated!\",\n\t\t\t\tip->i_ino);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (VFS_I(ip)->i_mode == 0)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 4075
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "perf_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct perf_event *event = file->private_data;\n\n\treturn perf_read_hw(event, buf, count);\n}",
        "output": "1",
        "idx": 2766
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u32 read_32(cdk_stream_t s)\n{\n\tbyte buf[4];\n\tsize_t nread;\n\n\tassert(s != NULL);\n\n\tstream_read(s, buf, 4, &nread);\n\tif (nread != 4)\n\t\treturn (u32) - 1;\n\treturn buf[0] << 24 | buf[1] << 16 | buf[2] << 8 | buf[3];\n}",
        "output": "1",
        "idx": 4632
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void jas_stream_initbuf(jas_stream_t *stream, int bufmode, char *buf,\n  int bufsize)\n{\n\tassert(!stream->bufbase_);\n\n\tif (bufmode != JAS_STREAM_UNBUF) {\n\t\tif (!buf) {\n\t\t\tif ((stream->bufbase_ = jas_malloc(JAS_STREAM_BUFSIZE +\n\t\t\t  JAS_STREAM_MAXPUTBACK))) {\n\t\t\t\tstream->bufmode_ |= JAS_STREAM_FREEBUF;\n\t\t\t\tstream->bufsize_ = JAS_STREAM_BUFSIZE;\n\t\t\t} else {\n\t\t\t\tstream->bufbase_ = stream->tinybuf_;\n\t\t\t\tstream->bufsize_ = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tassert(bufsize > JAS_STREAM_MAXPUTBACK);\n\t\t\tstream->bufbase_ = JAS_CAST(jas_uchar *, buf);\n\t\t\tstream->bufsize_ = bufsize - JAS_STREAM_MAXPUTBACK;\n\t\t}\n\t} else {\n\t\tassert(!buf);\n\t\tstream->bufbase_ = stream->tinybuf_;\n\t\tstream->bufsize_ = 1;\n\t}\n\tstream->bufstart_ = &stream->bufbase_[JAS_STREAM_MAXPUTBACK];\n\tstream->ptr_ = stream->bufstart_;\n\tstream->cnt_ = 0;\n\tstream->bufmode_ |= bufmode & JAS_STREAM_BUFMODEMASK;\n}",
        "output": "0",
        "idx": 7561
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nntp_hcache_namer(const char *path, char *dest, size_t destlen)\n{\n  return snprintf(dest, destlen, \"%s.hcache\", path);\n}",
        "output": "1",
        "idx": 6962
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "guard_in_node_family(const entry_guard_t *guard, const node_t *node)\n{\n  const node_t *guard_node = node_get_by_id(guard->identity);\n  if (guard_node) {\n    return nodes_in_same_family(guard_node, node);\n  } else {\n    if (get_options()->EnforceDistinctSubnets && guard->bridge_addr) {\n      tor_addr_t node_addr;\n      node_get_addr(node, &node_addr);\n      if (addrs_in_same_network_family(&node_addr,\n                                       &guard->bridge_addr->addr)) {\n        return 1;\n      }\n    }\n    return 0;\n  }\n}",
        "output": "0",
        "idx": 8531
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ftrace_regex_lseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t ret;\n\n\tif (file->f_mode & FMODE_READ)\n\t\tret = seq_lseek(file, offset, whence);\n\telse\n\t\tfile->f_pos = ret = 1;\n\n\treturn ret;\n}",
        "output": "1",
        "idx": 898
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *__dma_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t  dma_addr_t *dma_handle, gfp_t flags,\n\t\t\t\t  struct dma_attrs *attrs)\n{\n\tif (dev == NULL) {\n\t\tWARN_ONCE(1, \"Use an actual device structure for DMA allocation\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (IS_ENABLED(CONFIG_ZONE_DMA) &&\n\t    dev->coherent_dma_mask <= DMA_BIT_MASK(32))\n\t\tflags |= GFP_DMA;\n\tif (IS_ENABLED(CONFIG_DMA_CMA) && (flags & __GFP_WAIT)) {\n\t\tstruct page *page;\n\t\tvoid *addr;\n\n\t\tsize = PAGE_ALIGN(size);\n\t\tpage = dma_alloc_from_contiguous(dev, size >> PAGE_SHIFT,\n\t\t\t\t\t\t\tget_order(size));\n\t\tif (!page)\n\t\t\treturn NULL;\n\n\t\t*dma_handle = phys_to_dma(dev, page_to_phys(page));\n\t\taddr = page_address(page);\n\t\tif (flags & __GFP_ZERO)\n\t\t\tmemset(addr, 0, size);\n\t\treturn addr;\n\t} else {\n\t\treturn swiotlb_alloc_coherent(dev, size, dma_handle, flags);\n\t}\n}",
        "output": "1",
        "idx": 2852
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,\n\t\t\t\tstruct bpf_reg_state *src_reg)\n{\n\tbool src_known = tnum_subreg_is_const(src_reg->var_off);\n\tbool dst_known = tnum_subreg_is_const(dst_reg->var_off);\n\tstruct tnum var32_off = tnum_subreg(dst_reg->var_off);\n\ts32 smin_val = src_reg->s32_min_value;\n\tu32 umin_val = src_reg->u32_min_value;\n\n\tif (src_known && dst_known)\n\t\treturn;\n\n\tdst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);\n\tdst_reg->u32_max_value = var32_off.value | var32_off.mask;\n\tif (dst_reg->s32_min_value < 0 || smin_val < 0) {\n\t\tdst_reg->s32_min_value = S32_MIN;\n\t\tdst_reg->s32_max_value = S32_MAX;\n\t} else {\n\t\tdst_reg->s32_min_value = dst_reg->u32_min_value;\n\t\tdst_reg->s32_max_value = dst_reg->u32_max_value;\n\t}\n}",
        "output": "0",
        "idx": 2707
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void setConfigDefaults(HttpRoute *route)\n{\n    route->mode = mprReadJson(route->config, \"app.mode\");\n    if (smatch(route->mode, \"debug\")) {\n        httpSetRouteShowErrors(route, 1);\n        route->keepSource = 1;\n    }\n}",
        "output": "0",
        "idx": 7009
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int restore_fpu_checking(struct task_struct *tsk)\n{\n\tif (unlikely(static_cpu_has(X86_FEATURE_FXSAVE_LEAK))) {\n\t\tasm volatile(\n\t\t\t\"fnclex\\n\\t\"\n\t\t\t\"emms\\n\\t\"\n\t\t\t\"fildl %P[addr]\"\t\n\t\t\t: : [addr] \"m\" (tsk->thread.fpu.has_fpu));\n\t}\n\n\treturn fpu_restore_checking(&tsk->thread.fpu);\n}",
        "output": "0",
        "idx": 3451
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_GetObjectItem( cJSON *object, const char *string )\n{\n\tcJSON *c = object->child;\n\twhile ( c && cJSON_strcasecmp( c->string, string ) )\n\t\tc = c->next;\n\treturn c;\n}",
        "output": "1",
        "idx": 5960
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "is_link_trusted (NautilusFile *file,\n                 gboolean      is_launcher)\n{\n    GFile *location;\n    gboolean res;\n\n    if (!is_launcher)\n    {\n        return TRUE;\n    }\n\n    if (nautilus_file_can_execute (file))\n    {\n        return TRUE;\n    }\n\n    res = FALSE;\n\n    if (nautilus_file_is_local (file))\n    {\n        location = nautilus_file_get_location (file);\n        res = nautilus_is_in_system_dir (location);\n        g_object_unref (location);\n    }\n\n    return res;\n}",
        "output": "1",
        "idx": 6280
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.time_page) {\n\t\tkvm_release_page_dirty(vcpu->arch.time_page);\n\t\tvcpu->arch.time_page = NULL;\n\t}\n}",
        "output": "1",
        "idx": 882
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_set_cfgdata16(struct pci_vdev *dev, int offset, uint16_t val)\n{\n\tassert(offset <= (PCI_REGMAX - 1) && (offset & 1) == 0);\n\t*(uint16_t *)(dev->cfgdata + offset) = val;\n}",
        "output": "1",
        "idx": 7622
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int can_open_delegated(struct nfs_delegation *delegation, mode_t open_flags)\n{\n\tif ((delegation->type & open_flags) != open_flags)\n\t\treturn 0;\n\tif (test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags))\n\t\treturn 0;\n\tnfs_mark_delegation_referenced(delegation);\n\treturn 1;\n}",
        "output": "1",
        "idx": 2136
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool key_is_positive(const struct key *key)\n{\n\treturn key_read_state(key) == KEY_IS_POSITIVE;\n}",
        "output": "0",
        "idx": 2473
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseAuthAutoRoles(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprHash     *abilities;\n    MprKey      *kp;\n    MprJson     *child, *job;\n    int         ji;\n\n    if ((job = mprReadJsonObj(route->config, \"app.http.auth.roles\")) != 0) {\n        parseAuthRoles(route, \"app.http.auth.roles\", job);\n    }\n    abilities = mprCreateHash(0, 0);\n    for (ITERATE_CONFIG(route, prop, child, ji)) {\n        httpComputeRoleAbilities(route->auth, abilities, child->value);\n    }\n    if (mprGetHashLength(abilities) > 0) {\n        job = mprCreateJson(MPR_JSON_ARRAY);\n        for (ITERATE_KEYS(abilities, kp)) {\n            mprSetJson(job, \"$\", kp->key);\n        }\n        mprWriteJsonObj(route->config, \"app.http.auth.auto.abilities\", job);\n    }\n}",
        "output": "0",
        "idx": 6991
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void scsi_write_complete(void * opaque, int ret)\n{\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    uint32_t n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_WRITE)) {\n            return;\n        }\n    }\n\n    n = r->qiov.size / 512;\n    r->sector += n;\n    r->sector_count -= n;\n    if (r->sector_count == 0) {\n        scsi_req_complete(&r->req, GOOD);\n    } else {\n        scsi_init_iovec(r);\n        DPRINTF(\"Write complete tag=0x%x more=%d\\n\", r->req.tag, r->qiov.size);\n        scsi_req_data(&r->req, r->qiov.size);\n    }\n}",
        "output": "0",
        "idx": 4993
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\n\tstatic u32 challenge_timestamp;\n\tstatic unsigned int challenge_count;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 count, now;\n\n\tif (tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n\t\t\t\t &tp->last_oow_ack_time))\n\t\treturn;\n\n\tnow = jiffies / HZ;\n\tif (now != challenge_timestamp) {\n\t\tu32 half = (sysctl_tcp_challenge_ack_limit + 1) >> 1;\n\n\t\tchallenge_timestamp = now;\n\t\tWRITE_ONCE(challenge_count, half +\n\t\t\t   prandom_u32_max(sysctl_tcp_challenge_ack_limit));\n\t}\n\tcount = READ_ONCE(challenge_count);\n\tif (count > 0) {\n\t\tWRITE_ONCE(challenge_count, count - 1);\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\n\t\ttcp_send_ack(sk);\n\t}\n}",
        "output": "0",
        "idx": 1911
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void vmacache_invalidate(struct mm_struct *mm)\n{\n\tmm->vmacache_seqnum++;\n\n\tif (unlikely(mm->vmacache_seqnum == 0))\n\t\tvmacache_flush_all(mm);\n}",
        "output": "1",
        "idx": 3010
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t k90_show_current_profile(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint current_profile;\n\tchar *data;\n\n\tdata = kmalloc(8, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tcurrent_profile = data[7];\n\tif (current_profile < 1 || current_profile > 3) {\n\t\tdev_warn(dev, \"Read invalid current profile: %02hhx.\\n\",\n\t\t\t data[7]);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\nout:\n\tkfree(data);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 2085
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rose_start_t1timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tdel_timer(&rose->timer);\n\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t1;\n\n\tadd_timer(&rose->timer);\n}",
        "output": "1",
        "idx": 2046
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int xrstor_state(struct xsave_struct *fx, u64 mask)\n{\n\tint err = 0;\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\n\talternative_input(\n\t\t\"1: \" XRSTOR,\n\t\tXRSTORS,\n\t\tX86_FEATURE_XSAVES,\n\t\t\"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t: \"memory\");\n\n\tasm volatile(\"2:\\n\"\n\t\t     xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\n\treturn err;\n}",
        "output": "0",
        "idx": 3877
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parse_user_name(char *user_input, char **ret_username)\n{\n\tregister char *ptr;\n\tregister int index = 0;\n\tchar username[PAM_MAX_RESP_SIZE];\n\n\t*ret_username = NULL;\n\n\tbzero((void *)username, PAM_MAX_RESP_SIZE);\n\n\tptr = user_input;\n\n\twhile ((*ptr == ' ') || (*ptr == '\\t'))\n\t\tptr++;\n\n\tif (*ptr == '\\0') {\n\t\treturn (PAM_BUF_ERR);\n\t}\n\n\twhile (*ptr != '\\0') {\n\t\tif ((*ptr == ' ') || (*ptr == '\\t') ||\n\t\t    (index >= PAM_MAX_RESP_SIZE)) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tusername[index] = *ptr;\n\t\t\tindex++;\n\t\t\tptr++;\n\t\t}\n\t}\n\n\tif (index >= PAM_MAX_RESP_SIZE ||\n\t    (*ret_username = strdup(username)) == NULL)\n\t\treturn (PAM_BUF_ERR);\n\treturn (PAM_SUCCESS);\n}",
        "output": "0",
        "idx": 6863
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hugetlbfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(dentry->d_sb);\n\tstruct hstate *h = hstate_inode(dentry->d_inode);\n\n\tbuf->f_type = HUGETLBFS_MAGIC;\n\tbuf->f_bsize = huge_page_size(h);\n\tif (sbinfo) {\n\t\tspin_lock(&sbinfo->stat_lock);\n\t\tif (sbinfo->max_blocks >= 0) {\n\t\t\tbuf->f_blocks = sbinfo->max_blocks;\n\t\t\tbuf->f_bavail = buf->f_bfree = sbinfo->free_blocks;\n\t\t\tbuf->f_files = sbinfo->max_inodes;\n\t\t\tbuf->f_ffree = sbinfo->free_inodes;\n\t\t}\n\t\tspin_unlock(&sbinfo->stat_lock);\n\t}\n\tbuf->f_namelen = NAME_MAX;\n\treturn 0;\n}",
        "output": "1",
        "idx": 678
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC void httpSetCredentials(HttpConn *conn, cchar *username, cchar *password, cchar *authType)\n{\n    char    *ptok;\n\n    httpResetCredentials(conn);\n    if (password == NULL && strchr(username, ':') != 0) {\n        conn->username = stok(sclone(username), \":\", &ptok);\n        conn->password = sclone(ptok);\n    } else {\n        conn->username = sclone(username);\n        conn->password = sclone(password);\n    }\n    if (authType) {\n        conn->authType = sclone(authType);\n    }\n}",
        "output": "1",
        "idx": 5054
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hb_set_symmetric_difference (hb_set_t       *set,\n\t\t\t     const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n\n  set->symmetric_difference (*other);\n}",
        "output": "1",
        "idx": 5560
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ut64 MACH0_(get_baddr)(struct MACH0_(obj_t)* bin) {\n\tint i;\n\n\tif (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER)\n\t\treturn 0;\n\n\tfor (i = 0; i < bin->nsegs; ++i)\n\t\tif (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0)\n\t\t\treturn bin->segs[i].vmaddr;\n\treturn 0;\n}",
        "output": "1",
        "idx": 6152
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE1(timer_getoverrun, timer_t, timer_id)\n{\n\tstruct k_itimer *timr;\n\tint overrun;\n\tunsigned long flags;\n\n\ttimr = lock_timer(timer_id, &flags);\n\tif (!timr)\n\t\treturn -EINVAL;\n\n\toverrun = timer_overrun_to_int(timr, 0);\n\tunlock_timer(timr, flags);\n\n\treturn overrun;\n}",
        "output": "0",
        "idx": 4127
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "win_goto(win_T *wp)\n{\n#ifdef FEAT_CONCEAL\n    win_T\t*owp = curwin;\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (popup_is_popup(wp))\n    {\n\temsg(_(e_not_allowed_to_enter_popup_window));\n\treturn;\n    }\n#endif\n    if (text_locked())\n    {\n\tbeep_flush();\n\ttext_locked_msg();\n\treturn;\n    }\n    if (curbuf_locked())\n\treturn;\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n    win_enter(wp, TRUE);\n\n#ifdef FEAT_CONCEAL\n    if (win_valid(owp) && owp->w_p_cole > 0 && !msg_scrolled)\n\tredrawWinline(owp, owp->w_cursor.lnum);\n    if (curwin->w_p_cole > 0 && !msg_scrolled)\n\tneed_cursor_line_redraw = TRUE;\n#endif\n}",
        "output": "1",
        "idx": 5770
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, fgets)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (spl_filesystem_file_read(intern, 0 TSRMLS_CC) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);\n} ",
        "output": "1",
        "idx": 3980
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init ipip_init(void)\n{\n\tint err;\n\n\tprintk(banner);\n\n\tif (xfrm4_tunnel_register(&ipip_handler, AF_INET)) {\n\t\tprintk(KERN_INFO \"ipip init: can't register tunnel\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\terr = register_pernet_device(&ipip_net_ops);\n\tif (err)\n\t\txfrm4_tunnel_deregister(&ipip_handler, AF_INET);\n\n\treturn err;\n}",
        "output": "1",
        "idx": 2204
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API void r_anal_bb_free(RAnalBlock *bb) {\n\tif (!bb) {\n\t\treturn;\n\t}\n\tr_anal_cond_free (bb->cond);\n\tR_FREE (bb->fingerprint);\n\tr_anal_diff_free (bb->diff);\n\tbb->diff = NULL;\n\tR_FREE (bb->op_bytes);\n\tr_anal_switch_op_free (bb->switch_op);\n\tbb->switch_op = NULL;\n\tbb->fingerprint = NULL;\n\tbb->cond = NULL;\n\tR_FREE (bb->label);\n\tR_FREE (bb->op_pos);\n\tR_FREE (bb->parent_reg_arena);\n\tif (bb->prev) {\n\t\tif (bb->prev->jumpbb == bb) {\n\t\t\tbb->prev->jumpbb = NULL;\n\t\t}\n\t\tif (bb->prev->failbb == bb) {\n\t\t\tbb->prev->failbb = NULL;\n\t\t}\n\t\tbb->prev = NULL;\n\t}\n\tif (bb->jumpbb) {\n\t\tbb->jumpbb->prev = NULL;\n\t\tbb->jumpbb = NULL;\n\t}\n\tif (bb->failbb) {\n\t\tbb->failbb->prev = NULL;\n\t\tbb->failbb = NULL;\n\t}\n\tR_FREE (bb);\n}",
        "output": "1",
        "idx": 6208
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void get_page(struct page *page)\n{\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(page_ref_zero_or_close_to_overflow(page), page);\n\tpage_ref_inc(page);\n}",
        "output": "0",
        "idx": 4333
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int perf_event_task_disable(void)\n{\n\tstruct perf_event *event;\n\n\tmutex_lock(&current->perf_event_mutex);\n\tlist_for_each_entry(event, &current->perf_event_list, owner_entry)\n\t\tperf_event_for_each_child(event, perf_event_disable);\n\tmutex_unlock(&current->perf_event_mutex);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 2762
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "parse_netscreen_rec_hdr(struct wtap_pkthdr *phdr, const char *line, char *cap_int,\n    gboolean *cap_dir, char *cap_dst, int *err, gchar **err_info)\n{\n\tint\tsec;\n\tint\tdsec, pkt_len;\n\tchar\tdirection[2];\n\tchar\tcap_src[13];\n\n\tphdr->rec_type = REC_TYPE_PACKET;\n\tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\n\tif (sscanf(line, \"%9d.%9d: %15[a-z0-9/:.-](%1[io]) len=%9d:%12s->%12s/\",\n\t\t   &sec, &dsec, cap_int, direction, &pkt_len, cap_src, cap_dst) < 5) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"netscreen: Can't parse packet-header\");\n\t\treturn -1;\n\t}\n\n\t*cap_dir = (direction[0] == 'o' ? NETSCREEN_EGRESS : NETSCREEN_INGRESS);\n\n\tphdr->ts.secs  = sec;\n\tphdr->ts.nsecs = dsec * 100000000;\n\tphdr->len = pkt_len;\n\n\treturn pkt_len;\n}",
        "output": "1",
        "idx": 5984
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct mb2_cache *mb2_cache_create(int bucket_bits)\n{\n\tstruct mb2_cache *cache;\n\tint bucket_count = 1 << bucket_bits;\n\tint i;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn NULL;\n\n\tcache = kzalloc(sizeof(struct mb2_cache), GFP_KERNEL);\n\tif (!cache)\n\t\tgoto err_out;\n\tcache->c_bucket_bits = bucket_bits;\n\tINIT_LIST_HEAD(&cache->c_lru_list);\n\tspin_lock_init(&cache->c_lru_list_lock);\n\tcache->c_hash = kmalloc(bucket_count * sizeof(struct hlist_bl_head),\n\t\t\t\tGFP_KERNEL);\n\tif (!cache->c_hash) {\n\t\tkfree(cache);\n\t\tgoto err_out;\n\t}\n\tfor (i = 0; i < bucket_count; i++)\n\t\tINIT_HLIST_BL_HEAD(&cache->c_hash[i]);\n\n\tcache->c_shrink.count_objects = mb2_cache_count;\n\tcache->c_shrink.scan_objects = mb2_cache_scan;\n\tcache->c_shrink.seeks = DEFAULT_SEEKS;\n\tregister_shrinker(&cache->c_shrink);\n\n\treturn cache;\n\nerr_out:\n\tmodule_put(THIS_MODULE);\n\treturn NULL;\n}",
        "output": "0",
        "idx": 1601
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n\tstruct sock *sk2;\n\tstruct alg_sock *ask2;\n\tstruct hash_ctx *ctx2;\n\tint err;\n\n\terr = crypto_ahash_export(req, state);\n\tif (err)\n\t\treturn err;\n\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\n\tsk2 = newsock->sk;\n\task2 = alg_sk(sk2);\n\tctx2 = ask2->private;\n\tctx2->more = 1;\n\n\terr = crypto_ahash_import(&ctx2->req, state);\n\tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\n\treturn err;\n}",
        "output": "1",
        "idx": 2936
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long ioctl_file_dedupe_range(struct file *file, void __user *arg)\n{\n\tstruct file_dedupe_range __user *argp = arg;\n\tstruct file_dedupe_range *same = NULL;\n\tint ret;\n\tunsigned long size;\n\tu16 count;\n\n\tif (get_user(count, &argp->dest_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tsize = offsetof(struct file_dedupe_range __user, info[count]);\n\n\tsame = memdup_user(argp, size);\n\tif (IS_ERR(same)) {\n\t\tret = PTR_ERR(same);\n\t\tsame = NULL;\n\t\tgoto out;\n\t}\n\n\tsame->dest_count = count;\n\tret = vfs_dedupe_file_range(file, same);\n\tif (ret)\n\t\tgoto out;\n\n\tret = copy_to_user(argp, same, size);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout:\n\tkfree(same);\n\treturn ret;\n}",
        "output": "0",
        "idx": 1917
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ext3_fsblk_t get_sb_block(void **data, struct super_block *sb)\n{\n\text3_fsblk_t\tsb_block;\n\tchar\t\t*options = (char *) *data;\n\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t\n\toptions += 3;\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\text3_msg(sb, \"error: invalid sb specification: %s\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\treturn sb_block;\n}",
        "output": "1",
        "idx": 868
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void spl_filesystem_info_set_filename(spl_filesystem_object *intern, char *path, int len, int use_copy TSRMLS_DC) \n{\n\tchar *p1, *p2;\n\n\tif (intern->file_name) {\n\t\tefree(intern->file_name);\n\t}\n\n\tintern->file_name = use_copy ? estrndup(path, len) : path;\n\tintern->file_name_len = len;\n\n\twhile(IS_SLASH_AT(intern->file_name, intern->file_name_len-1) && intern->file_name_len > 1) {\n\t\tintern->file_name[intern->file_name_len-1] = 0;\n\t\tintern->file_name_len--;\n\t}\n\n\tp1 = strrchr(intern->file_name, '/');\n#if defined(PHP_WIN32) || defined(NETWARE)\n\tp2 = strrchr(intern->file_name, '\\\\');\n#else\n\tp2 = 0;\n#endif\n\tif (p1 || p2) {\n\t\tintern->_path_len = (p1 > p2 ? p1 : p2) - intern->file_name;\n\t} else {\n\t\tintern->_path_len = 0;\n\t}\n\n\tif (intern->_path) {\n\t\tefree(intern->_path);\n\t}\n\tintern->_path = estrndup(path, intern->_path_len);\n} ",
        "output": "0",
        "idx": 5481
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,\n\t\t\t       __be16 dport)\n{\n\tu32 secret[MD5_MESSAGE_BYTES / 4];\n\tu32 hash[MD5_DIGEST_WORDS];\n\tu32 i;\n\n\tmemcpy(hash, saddr, 16);\n\tfor (i = 0; i < 4; i++)\n\t\tsecret[i] = net_secret[i] + (__force u32) daddr[i];\n\tsecret[4] = net_secret[4] + (__force u32)dport;\n\tfor (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)\n\t\tsecret[i] = net_secret[i];\n\n\tmd5_transform(hash, secret);\n\n\treturn hash[0];\n}",
        "output": "0",
        "idx": 783
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj)\n{\n    char obj_txt[128];\n\n    int len = OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);\n    BIO_write(bio, obj_txt, len);\n    BIO_write(bio, \"\\n\", 1);\n\n    return 1;\n}",
        "output": "1",
        "idx": 4520
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void addParamsFromBuf(HttpConn *conn, cchar *buf, ssize len)\n{\n    MprJson     *params, *prior;\n    char        *newValue, *decoded, *keyword, *value, *tok;\n\n    assert(conn);\n    params = httpGetParams(conn);\n    decoded = mprAlloc(len + 1);\n    decoded[len] = '\\0';\n    memcpy(decoded, buf, len);\n\n    keyword = stok(decoded, \"&\", &tok);\n    while (keyword != 0) {\n        if ((value = strchr(keyword, '=')) != 0) {\n            *value++ = '\\0';\n            value = mprUriDecode(value);\n        } else {\n            value = MPR->emptyString;\n        }\n        keyword = mprUriDecode(keyword);\n        if (*keyword) {\n            prior = mprLookupJsonObj(params, keyword);\n            if (prior && prior->type == MPR_JSON_VALUE) {\n                if (*value) {\n                    newValue = sjoin(prior->value, \" \", value, NULL);\n                    mprSetJson(params, keyword, newValue);\n                }\n            } else {\n                mprSetJson(params, keyword, value);\n            }\n        }\n        keyword = stok(0, \"&\", &tok);\n    }\n}",
        "output": "1",
        "idx": 5078
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jiffies_to_timespec(const unsigned long jiffies, struct timespec *value)\n{\n\tu32 rem;\n\tvalue->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,\n\t\t\t\t    NSEC_PER_SEC, &rem);\n\tvalue->tv_nsec = rem;\n}",
        "output": "0",
        "idx": 3011
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int ccid_hc_tx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid != NULL && ccid->ccid_ops->ccid_hc_tx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_tx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}",
        "output": "0",
        "idx": 1017
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "find_auth_end (FlatpakProxyClient *client, Buffer *buffer)\n{\n  guchar *match;\n  int i;\n\n  if (client->auth_end_offset > 0)\n    {\n      gsize left = strlen (AUTH_END_STRING) - client->auth_end_offset;\n      gsize to_match = MIN (left, buffer->pos);\n      if (memcmp (buffer->data, &AUTH_END_STRING[client->auth_end_offset], to_match) == 0)\n        {\n          client->auth_end_offset += to_match;\n\n          if (client->auth_end_offset == strlen (AUTH_END_STRING))\n            return to_match;\n\n          return -1;\n        }\n\n      client->auth_end_offset = -1;\n    }\n\n  match = memmem (buffer, buffer->pos,\n                  AUTH_END_STRING, strlen (AUTH_END_STRING));\n  if (match != NULL)\n    return match - buffer->data + strlen (AUTH_END_STRING);\n\n  for (i = MIN (strlen (AUTH_END_STRING) - 1, buffer->pos); i > 0; i--)\n    {\n      if (memcmp (buffer->data + buffer->pos - i, AUTH_END_STRING, i) == 0)\n        {\n          client->auth_end_offset = i;\n          break;\n        }\n    }\n\n  return -1;\n}",
        "output": "1",
        "idx": 7288
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *funcs, void *allocdata)\n{\n  VTerm *vt = (*funcs->malloc)(sizeof(VTerm), allocdata);\n\n  if (vt == NULL)\n    return NULL;\n  vt->allocator = funcs;\n  vt->allocdata = allocdata;\n\n  vt->rows = rows;\n  vt->cols = cols;\n\n  vt->parser.state = NORMAL;\n\n  vt->parser.callbacks = NULL;\n  vt->parser.cbdata    = NULL;\n\n  vt->parser.strbuffer_len = 500; \n  vt->parser.strbuffer_cur = 0;\n  vt->parser.strbuffer = vterm_allocator_malloc(vt, vt->parser.strbuffer_len);\n  if (vt->parser.strbuffer == NULL)\n  {\n    vterm_allocator_free(vt, vt);\n    return NULL;\n  }\n\n  vt->outbuffer_len = 200;\n  vt->outbuffer_cur = 0;\n  vt->outbuffer = vterm_allocator_malloc(vt, vt->outbuffer_len);\n  if (vt->outbuffer == NULL)\n  {\n    vterm_allocator_free(vt, vt->parser.strbuffer);\n    vterm_allocator_free(vt, vt);\n    return NULL;\n  }\n\n  return vt;\n}",
        "output": "0",
        "idx": 8149
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "queue_unlock(struct futex_q *q, struct futex_hash_bucket *hb)\n{\n\tspin_unlock(&hb->lock);\n\tdrop_futex_key_refs(&q->key);\n}",
        "output": "1",
        "idx": 234
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vips_tracked_malloc( size_t size )\n{\n        void *buf;\n\n\tvips_tracked_init(); \n\n\tsize += 16;\n\n        if( !(buf = g_try_malloc( size )) ) {\n#ifdef DEBUG\n\t\tg_assert_not_reached();\n#endif \n\n\t\tvips_error( \"vips_tracked\", \n\t\t\t_( \"out of memory --- size == %dMB\" ), \n\t\t\t(int) (size / (1024.0 * 1024.0))  );\n\t\tg_warning( _( \"out of memory --- size == %dMB\" ), \n\t\t\t(int) (size / (1024.0 * 1024.0))  );\n\n                return( NULL );\n\t}\n\n\tg_mutex_lock( vips_tracked_mutex );\n\n\t*((size_t *)buf) = size;\n\tbuf = (void *) ((char *)buf + 16);\n\n\tvips_tracked_mem += size;\n\tif( vips_tracked_mem > vips_tracked_mem_highwater ) \n\t\tvips_tracked_mem_highwater = vips_tracked_mem;\n\tvips_tracked_allocs += 1;\n\n#ifdef DEBUG_VERBOSE\n\tprintf( \"vips_tracked_malloc: %p, %zd bytes\\n\", buf, size ); \n#endif \n\n\tg_mutex_unlock( vips_tracked_mutex );\n\n\tVIPS_GATE_MALLOC( size ); \n\n        return( buf );\n}",
        "output": "1",
        "idx": 7536
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)\n{\tva_list\targptr ;\n\tint\t\tmaxlen ;\n\tchar\t*start ;\n\n\tmaxlen = strlen ((char*) psf->header.ptr) ;\n\tstart\t= ((char*) psf->header.ptr) + maxlen ;\n\tmaxlen\t= psf->header.len - maxlen ;\n\n\tva_start (argptr, format) ;\n\tvsnprintf (start, maxlen, format, argptr) ;\n\tva_end (argptr) ;\n\n\tstart [maxlen - 1] = 0 ;\n\n\tpsf->header.indx = strlen ((char*) psf->header.ptr) ;\n\n\treturn ;\n} ",
        "output": "0",
        "idx": 6895
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "test_read_integer_error (xd3_stream *stream, usize_t trunto, const char *msg)\n{\n  uint64_t eval = 1ULL << 34;\n  uint32_t rval;\n  xd3_output *buf = NULL;\n  const uint8_t *max;\n  const uint8_t *inp;\n  int ret;\n\n  buf = xd3_alloc_output (stream, buf);\n\n  if ((ret = xd3_emit_uint64_t (stream, & buf, eval)))\n    {\n      goto fail;\n    }\n\n again:\n\n  inp = buf->base;\n  max = buf->base + buf->next - trunto;\n\n  if ((ret = xd3_read_uint32_t (stream, & inp, max, & rval)) != \n      XD3_INVALID_INPUT ||\n      !MSG_IS (msg))\n    {\n      ret = XD3_INTERNAL;\n    }\n  else if (trunto && trunto < buf->next)\n    {\n      trunto += 1;\n      goto again;\n    }\n  else\n    {\n      ret = 0;\n    }\n\n fail:\n  xd3_free_output (stream, buf);\n  return ret;\n}",
        "output": "1",
        "idx": 5134
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tokenadd(struct jv_parser* p, char c) {\n  assert(p->tokenpos <= p->tokenlen);\n  if (p->tokenpos >= (p->tokenlen - 1)) {\n    p->tokenlen = p->tokenlen*2 + 256;\n    p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen);\n  }\n  assert(p->tokenpos < p->tokenlen);\n  p->tokenbuf[p->tokenpos++] = c;\n}",
        "output": "0",
        "idx": 7713
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API st64 r_buf_fread_at(RBuffer *b, ut64 addr, ut8 *buf, const char *fmt, int n) {\n\tr_return_val_if_fail (b && buf && fmt, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tr = r_buf_fread (b, buf, fmt, n);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}",
        "output": "1",
        "idx": 6488
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "process(register int code, unsigned char** fill)\n{\n    int incode;\n    static unsigned char firstchar;\n\n    if (code == clear) {\n\tcodesize = datasize + 1;\n\tcodemask = (1 << codesize) - 1;\n\tavail = clear + 2;\n\toldcode = -1;\n\treturn 1;\n    }\n\n    if (oldcode == -1) {\n        if (code >= clear) {\n            fprintf(stderr, \"bad input: code=%d is larger than clear=%d\\n\",code, clear);\n            return 0;\n        }\n\t*(*fill)++ = suffix[code];\n\tfirstchar = oldcode = code;\n\treturn 1;\n    }\n    if (code > avail) {\n\tfprintf(stderr, \"code %d too large for %d\\n\", code, avail);\n\treturn 0; \n    }\n\n    incode = code;\n    if (code == avail) {      \n\t*stackp++ = firstchar;\n\tcode = oldcode;\n    }\n    while (code > clear) {\n\t*stackp++ = suffix[code];\n\tcode = prefix[code];\n    }\n\n    *stackp++ = firstchar = suffix[code];\n    prefix[avail] = oldcode;\n    suffix[avail] = firstchar;\n    avail++;\n\n    if (((avail & codemask) == 0) && (avail < 4096)) {\n\tcodesize++;\n\tcodemask += avail;\n    }\n    oldcode = incode;\n    do {\n\t*(*fill)++ = *--stackp;\n    } while (stackp > stack);\n    return 1;\n}",
        "output": "0",
        "idx": 5857
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ptrace_unfreeze_traced(struct task_struct *task)\n{\n\tif (task->state != __TASK_TRACED)\n\t\treturn;\n\n\tWARN_ON(!task->ptrace || task->parent != current);\n\n\tspin_lock_irq(&task->sighand->siglock);\n\tif (__fatal_signal_pending(task))\n\t\twake_up_state(task, __TASK_TRACED);\n\telse\n\t\ttask->state = TASK_TRACED;\n\tspin_unlock_irq(&task->sighand->siglock);\n}",
        "output": "0",
        "idx": 1129
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "chunk_grow(chunk_t *chunk, size_t sz)\n{\n  off_t offset;\n  const size_t memlen_orig = chunk->memlen;\n  const size_t orig_alloc = CHUNK_ALLOC_SIZE(memlen_orig);\n  const size_t new_alloc = CHUNK_ALLOC_SIZE(sz);\n  tor_assert(sz > chunk->memlen);\n  offset = chunk->data - chunk->mem;\n  chunk = tor_realloc(chunk, new_alloc);\n  chunk->memlen = sz;\n  chunk->data = chunk->mem + offset;\n#ifdef DEBUG_CHUNK_ALLOC\n  tor_assert(chunk->DBG_alloc == orig_alloc);\n  chunk->DBG_alloc = new_alloc;\n#endif\n  total_bytes_allocated_in_chunks += new_alloc - orig_alloc;\n  CHUNK_SET_SENTINEL(chunk, new_alloc);\n  return chunk;\n}",
        "output": "0",
        "idx": 8521
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {\n        _cleanup_close_ int fd;\n        int r;\n\n        assert(path);\n\n        if (parents)\n                mkdir_parents(path, 0755);\n\n        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,\n                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);\n        if (fd < 0)\n                return -errno;\n\n        if (mode != MODE_INVALID) {\n                r = fchmod(fd, mode);\n                if (r < 0)\n                        return -errno;\n        }\n\n        if (uid != UID_INVALID || gid != GID_INVALID) {\n                r = fchown(fd, uid, gid);\n                if (r < 0)\n                        return -errno;\n        }\n\n        if (stamp != USEC_INFINITY) {\n                struct timespec ts[2];\n\n                timespec_store(&ts[0], stamp);\n                ts[1] = ts[0];\n                r = futimens(fd, ts);\n        } else\n                r = futimens(fd, NULL);\n        if (r < 0)\n                return -errno;\n\n        return 0;\n}",
        "output": "0",
        "idx": 7685
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int check_sticky(struct inode *dir, struct inode *inode)\n{\n\tkuid_t fsuid = current_fsuid();\n\n\tif (!(dir->i_mode & S_ISVTX))\n\t\treturn 0;\n\tif (uid_eq(inode->i_uid, fsuid))\n\t\treturn 0;\n\tif (uid_eq(dir->i_uid, fsuid))\n\t\treturn 0;\n\treturn !inode_capable(inode, CAP_FOWNER);\n}",
        "output": "1",
        "idx": 2586
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xfs_attr_shortform_addname(xfs_da_args_t *args)\n{\n\tint newsize, forkoff, retval;\n\n\ttrace_xfs_attr_sf_addname(args);\n\n\tretval = xfs_attr_shortform_lookup(args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\treturn retval;\n\t\tretval = xfs_attr_shortform_remove(args);\n\t\tASSERT(retval == 0);\n\t}\n\n\tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;\n\n\tnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\n\tnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\n\tforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);\n\tif (!forkoff)\n\t\treturn -ENOSPC;\n\n\txfs_attr_shortform_add(args, forkoff);\n\treturn 0;\n}",
        "output": "1",
        "idx": 2948
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n\t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n\t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n{\n    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t    return (GSS_S_NO_CONTEXT);\n\n    return gss_get_mic_iov_length(minor_status, sc->ctx_handle, qop_req, iov,\n\t\t\t\t  iov_count);\n}",
        "output": "0",
        "idx": 103
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int regset_tls_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n\tstruct user_desc infobuf[GDT_ENTRY_TLS_ENTRIES];\n\tconst struct user_desc *info;\n\tint i;\n\n\tif (pos >= GDT_ENTRY_TLS_ENTRIES * sizeof(struct user_desc) ||\n\t    (pos % sizeof(struct user_desc)) != 0 ||\n\t    (count % sizeof(struct user_desc)) != 0)\n\t\treturn -EINVAL;\n\n\tif (kbuf)\n\t\tinfo = kbuf;\n\telse if (__copy_from_user(infobuf, ubuf, count))\n\t\treturn -EFAULT;\n\telse\n\t\tinfo = infobuf;\n\n\tfor (i = 0; i < count / sizeof(struct user_desc); i++)\n\t\tif (!tls_desc_okay(info + i))\n\t\t\treturn -EINVAL;\n\n\tset_tls_desc(target,\n\t\t     GDT_ENTRY_TLS_MIN + (pos / sizeof(struct user_desc)),\n\t\t     info, count / sizeof(struct user_desc));\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 3771
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int spk_ttyio_ldisc_open(struct tty_struct *tty)\n{\n\tstruct spk_ldisc_data *ldisc_data;\n\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&speakup_tty_mutex);\n\tif (speakup_tty) {\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\treturn -EBUSY;\n\t}\n\tspeakup_tty = tty;\n\n\tldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);\n\tif (!ldisc_data) {\n\t\tspeakup_tty = NULL;\n\t\tmutex_unlock(&speakup_tty_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\tinit_completion(&ldisc_data->completion);\n\tldisc_data->buf_free = true;\n\tspeakup_tty->disc_data = ldisc_data;\n\tmutex_unlock(&speakup_tty_mutex);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2765
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE2(osf_getdomainname, char __user *, name, int, namelen)\n{\n\tunsigned len;\n\tint i;\n\n\tif (!access_ok(VERIFY_WRITE, name, namelen))\n\t\treturn -EFAULT;\n\n\tlen = namelen;\n\tif (namelen > 32)\n\t\tlen = 32;\n\n\tdown_read(&uts_sem);\n\tfor (i = 0; i < len; ++i) {\n\t\t__put_user(utsname()->domainname[i], name + i);\n\t\tif (utsname()->domainname[i] == '\\0')\n\t\t\tbreak;\n\t}\n\tup_read(&uts_sem);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 410
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct nfs4_state *nfs4_do_open(struct inode *dir, struct path *path, fmode_t fmode, int flags, struct iattr *sattr, struct rpc_cred *cred)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs4_state *res;\n\tint status;\n\n\tdo {\n\t\tstatus = _nfs4_do_open(dir, path, fmode, flags, sattr, cred, &res);\n\t\tif (status == 0)\n\t\t\tbreak;\n\t\tif (status == -NFS4ERR_BAD_SEQID) {\n\t\t\tprintk(KERN_WARNING \"NFS: v4 server %s \"\n\t\t\t\t\t\" returned a bad sequence-id error!\\n\",\n\t\t\t\t\tNFS_SERVER(dir)->nfs_client->cl_hostname);\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -NFS4ERR_BAD_STATEID) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -EAGAIN) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tres = ERR_PTR(nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t\tstatus, &exception));\n\t} while (exception.retry);\n\treturn res;\n}",
        "output": "0",
        "idx": 3073
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int may_create_in_sticky(struct dentry * const dir,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir->d_inode->i_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir->d_inode->i_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\n\tif (likely(dir->d_inode->i_mode & 0002) ||\n\t    (dir->d_inode->i_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";\n\t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 3318
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int options_parse(CONF_TYPE type) {\n    SERVICE_OPTIONS *section;\n\n    options_defaults();\n    section=&new_service_options;\n    if(options_file(configuration_file, type, &section))\n        return 1;\n    if(init_section(1, &section))\n        return 1;\n\n    s_log(LOG_NOTICE, \"Configuration successful\");\n    return 0;\n}",
        "output": "1",
        "idx": 8446
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_set_cfgdata32(struct pci_vdev *dev, int offset, uint32_t val)\n{\n\tassert(offset <= (PCI_REGMAX - 3) && (offset & 3) == 0);\n\t*(uint32_t *)(dev->cfgdata + offset) = val;\n}",
        "output": "1",
        "idx": 7626
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tm_reclaim_thread(struct thread_struct *thr,\n\t\t\t      struct thread_info *ti, uint8_t cause)\n{\n\tunsigned long msr_diff = 0;\n\n\tif (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {\n\t\tmsr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;\n\t\tif (msr_diff & MSR_FP)\n\t\t\tmemcpy(&thr->transact_fp, &thr->fp_state,\n\t\t\t       sizeof(struct thread_fp_state));\n\t\tif (msr_diff & MSR_VEC)\n\t\t\tmemcpy(&thr->transact_vr, &thr->vr_state,\n\t\t\t       sizeof(struct thread_vr_state));\n\t\tclear_ti_thread_flag(ti, TIF_RESTORE_TM);\n\t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n\t}\n\n\tif (!MSR_TM_SUSPENDED(mfmsr()))\n\t\treturn;\n\n\ttm_reclaim(thr, thr->regs->msr, cause);\n\n\tthr->regs->msr |= msr_diff;\n}",
        "output": "0",
        "idx": 1353
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n{\n    VirtQueueElement elem;\n    VirtQueue *vq;\n\n    vq = vser->c_ivq;\n    if (!virtio_queue_ready(vq)) {\n        return 0;\n    }\n    if (!virtqueue_pop(vq, &elem)) {\n        return 0;\n    }\n\n    iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len);\n\n    virtqueue_push(vq, &elem, len);\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n    return len;\n}",
        "output": "0",
        "idx": 5325
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sd_compat_ioctl(struct block_device *bdev, fmode_t mode,\n\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\tstruct scsi_device *sdev = scsi_disk(bdev->bd_disk)->device;\n\n\tif (!scsi_block_when_processing_errors(sdev))\n\t\treturn -ENODEV;\n\t       \n\tif (sdev->host->hostt->compat_ioctl) {\n\t\tint ret;\n\n\t\tret = sdev->host->hostt->compat_ioctl(sdev, cmd, (void __user *)arg);\n\n\t\treturn ret;\n\t}\n\n\treturn -ENOIOCTLCMD; \n}",
        "output": "1",
        "idx": 664
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)\n{\n\tstruct ip_options *opt;\n\n\topt = inet_sk(sk)->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn -ENOMSG;\n\n\treturn cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct iphdr),\n\t\t\t\tsecattr);\n}",
        "output": "1",
        "idx": 328
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *fstrndup(const char *ptr, unsigned long len) {\n  char *result;\n  if (len <= 0) return NULL;\n  result = ALLOC_N(char, len);\n  memccpy(result, ptr, 0, len);\n  return result;\n}",
        "output": "1",
        "idx": 6268
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void timer_enter_running(Timer *t) {\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        int r;\n\n        assert(t);\n\n        if (unit_stop_pending(UNIT(t)))\n                return;\n\n        r = manager_add_job(UNIT(t)->manager, JOB_START, UNIT_TRIGGER(UNIT(t)),\n                            JOB_REPLACE, true, &error, NULL);\n        if (r < 0)\n                goto fail;\n\n        dual_timestamp_get(&t->last_trigger);\n\n        if (t->stamp_path)\n                touch_file(t->stamp_path, true, t->last_trigger.realtime, UID_INVALID, GID_INVALID, 0);\n\n        timer_set_state(t, TIMER_RUNNING);\n        return;\n\nfail:\n        log_unit_warning(UNIT(t), \"Failed to queue unit startup job: %s\", bus_error_message(&error, r));\n        timer_enter_dead(t, TIMER_FAILURE_RESOURCES);\n}",
        "output": "1",
        "idx": 5480
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_bind(const char *path)\n{\n\tint sfd;\n\tstruct sockaddr_un my_addr, peer_addr;\n\n\tsfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\n\tif (sfd < 0) {\n\t\tfprintf(stderr, \"Failed to open a socket for bind test\\n\");\n\t\texit(1);\n\t}\n\tmemset(&my_addr, 0, sizeof(struct sockaddr_un));\n\tmy_addr.sun_family = AF_UNIX;\n\tstrncpy(my_addr.sun_path, path,\n\t\t\tsizeof(my_addr.sun_path) - 1);\n\tif (bind(sfd, (struct sockaddr *) &my_addr,\n\t\t\t\tsizeof(struct sockaddr_un)) != -1) {\n\t\tfprintf(stderr, \"leak at bind of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at bind of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n\tclose(sfd);\n}",
        "output": "0",
        "idx": 7301
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,\n\t\t    gfp_t gfp, struct dma_attrs *attrs)\n{\n\tpgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);\n\tvoid *memory;\n\n\tif (dma_alloc_from_coherent(dev, size, handle, &memory))\n\t\treturn memory;\n\n\treturn __dma_alloc(dev, size, handle, gfp, prot, false,\n\t\t\t   __builtin_return_address(0));\n}",
        "output": "1",
        "idx": 2348
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr_storage *address, int mode)\n{\n\tint size, ct, err;\n\n\tif (m->msg_namelen) {\n\t\tif (mode == VERIFY_READ) {\n\t\t\tvoid __user *namep;\n\t\t\tnamep = (void __user __force *) m->msg_name;\n\t\t\terr = move_addr_to_kernel(namep, m->msg_namelen,\n\t\t\t\t\t\t  address);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (m->msg_name)\n\t\t\tm->msg_name = address;\n\t} else {\n\t\tm->msg_name = NULL;\n\t}\n\n\tsize = m->msg_iovlen * sizeof(struct iovec);\n\tif (copy_from_user(iov, (void __user __force *) m->msg_iov, size))\n\t\treturn -EFAULT;\n\n\tm->msg_iov = iov;\n\terr = 0;\n\n\tfor (ct = 0; ct < m->msg_iovlen; ct++) {\n\t\tsize_t len = iov[ct].iov_len;\n\n\t\tif (len > INT_MAX - err) {\n\t\t\tlen = INT_MAX - err;\n\t\t\tiov[ct].iov_len = len;\n\t\t}\n\t\terr += len;\n\t}\n\n\treturn err;\n}",
        "output": "0",
        "idx": 3397
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "obj2ast_type_ignore(PyObject* obj, type_ignore_ty* out, PyArena* arena)\n{\n    int isinstance;\n\n    PyObject *tmp = NULL;\n\n    if (obj == Py_None) {\n        *out = NULL;\n        return 0;\n    }\n    isinstance = PyObject_IsInstance(obj, (PyObject*)TypeIgnore_type);\n    if (isinstance == -1) {\n        return 1;\n    }\n    if (isinstance) {\n        int lineno;\n\n        if (_PyObject_HasAttrId(obj, &PyId_lineno)) {\n            int res;\n            tmp = _PyObject_GetAttrId(obj, &PyId_lineno);\n            if (tmp == NULL) goto failed;\n            res = obj2ast_int(tmp, &lineno, arena);\n            if (res != 0) goto failed;\n            Py_CLEAR(tmp);\n        } else {\n            PyErr_SetString(PyExc_TypeError, \"required field \\\"lineno\\\" missing from TypeIgnore\");\n            return 1;\n        }\n        *out = TypeIgnore(lineno, arena);\n        if (*out == NULL) goto failed;\n        return 0;\n    }\n\n    PyErr_Format(PyExc_TypeError, \"expected some sort of type_ignore, but got %R\", obj);\n    failed:\n    Py_XDECREF(tmp);\n    return 1;\n}",
        "output": "1",
        "idx": 7680
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining;\n\ts64 ns;\n\tu32 tmcct;\n\n\tASSERT(apic != NULL);\n\n\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0)\n\t\treturn 0;\n\n\tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = ktime_set(0, 0);\n\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\n\treturn tmcct;\n}",
        "output": "1",
        "idx": 2478
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rose_stop_idletimer(struct sock *sk)\n{\n\tdel_timer(&rose_sk(sk)->idletimer);\n}",
        "output": "1",
        "idx": 2054
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n}",
        "output": "1",
        "idx": 1768
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int spl_filesystem_file_read_line(zval * this_ptr, spl_filesystem_object *intern, int silent TSRMLS_DC) \n{\n\tint ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);\n\n\twhile (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY) && ret == SUCCESS && spl_filesystem_file_is_empty_line(intern TSRMLS_CC)) {\n\t\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\t\tret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);\n\t}\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 5573
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "prepenv(const struct rule *rule)\n{\n\tstatic const char *safeset[] = {\n\t\t\"DISPLAY\", \"HOME\", \"LOGNAME\", \"MAIL\",\n\t\t\"PATH\", \"TERM\", \"USER\", \"USERNAME\",\n\t\tNULL\n\t};\n\tstruct env *env;\n\n\tenv = createenv(rule);\n\n\tif (!(rule->options & KEEPENV))\n\t\tfillenv(env, safeset);\n\tif (rule->envlist)\n\t\tfillenv(env, rule->envlist);\n\n\treturn flattenenv(env);\n}",
        "output": "1",
        "idx": 7836
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned paravirt_patch_jmp(void *insnbuf, const void *target,\n\t\t\t    unsigned long addr, unsigned len)\n{\n\tstruct branch *b = insnbuf;\n\tunsigned long delta = (unsigned long)target - (addr+5);\n\n\tif (len < 5) {\n#ifdef CONFIG_RETPOLINE\n\t\tWARN_ONCE(\"Failing to patch indirect JMP in %ps\\n\", (void *)addr);\n#endif\n\t\treturn len;\t\n\t}\n\n\tb->opcode = 0xe9;\t\n\tb->delta = delta;\n\n\treturn 5;\n}",
        "output": "0",
        "idx": 4145
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iakerb_gss_unwrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                      int *conf_state, gss_qop_t *qop_state,\n                      gss_iov_buffer_desc *iov, int iov_count)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_unwrap_iov(minor_status, ctx->gssc, conf_state, qop_state,\n                               iov, iov_count);\n}",
        "output": "0",
        "idx": 159
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "av_cold void ff_mpv_idct_init(MpegEncContext *s)\n{\n    if (s->codec_id == AV_CODEC_ID_MPEG4)\n        s->idsp.mpeg4_studio_profile = s->studio_profile;\n    ff_idctdsp_init(&s->idsp, s->avctx);\n\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);\n    }\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n}",
        "output": "0",
        "idx": 4745
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int r_cmd_java_call(void *user, const char *input) {\n\tRCore *core = (RCore *) user;\n\tint res = false;\n\tut32 i = 0;\n\tif (strncmp (input, \"java\", 4)) {\n\t\treturn false;\n\t}\n\tif (input[4] != ' ') {\n\t\treturn r_cmd_java_handle_help (core, input);\n\t}\n\tfor (; i < END_CMDS; i++) {\n\t\tIFDBG r_cons_printf (\"Checking cmd: %s %d\\n\", JAVA_CMDS[i].name,\n\t\t\tstrncmp (input+5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len));\n\t\tif (!strncmp (input + 5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len)) {\n\t\t\tconst char *cmd = input + 5 + JAVA_CMDS[i].name_len;\n\t\t\tif (*cmd && *cmd == ' ') {\n\t\t\t\tcmd++;\n\t\t\t}\n\t\t\tres =  JAVA_CMDS[i].handler (core, cmd);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!res) {\n\t\treturn r_cmd_java_handle_help (core, input);\n\t}\n\treturn true;\n}",
        "output": "1",
        "idx": 6550
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int spl_filesystem_file_is_empty_line(spl_filesystem_object *intern TSRMLS_DC) \n{\n\tif (intern->u.file.current_line) {\n\t\treturn intern->u.file.current_line_len == 0;\n\t} else if (intern->u.file.current_zval) {\n\t\tswitch(Z_TYPE_P(intern->u.file.current_zval)) {\n\t\tcase IS_STRING:\n\t\t\treturn Z_STRLEN_P(intern->u.file.current_zval) == 0;\n\t\tcase IS_ARRAY:\n\t\t\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV)\n\t\t\t&& zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 1) {\n\t\t\t\tzval ** first = Z_ARRVAL_P(intern->u.file.current_zval)->pListHead->pData;\n\n\t\t\t\treturn Z_TYPE_PP(first) == IS_STRING && Z_STRLEN_PP(first) == 0;\n\t\t\t}\n\t\t\treturn zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 0;\n\t\tcase IS_NULL:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\treturn 1;\n\t}\n}",
        "output": "0",
        "idx": 5525
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ipmi_destroy_user(struct ipmi_user *user)\n{\n\t_ipmi_destroy_user(user);\n\n\tcleanup_srcu_struct(&user->release_barrier);\n\tkref_put(&user->refcount, free_user);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 3072
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void inet_sock_destruct(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_error_queue);\n\n\tsk_mem_reclaim(sk);\n\n\tif (sk->sk_type == SOCK_STREAM && sk->sk_state != TCP_CLOSE) {\n\t\tpr_err(\"Attempt to release TCP socket in state %d %p\\n\",\n\t\t       sk->sk_state, sk);\n\t\treturn;\n\t}\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive inet socket %p\\n\", sk);\n\t\treturn;\n\t}\n\n\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n\tWARN_ON(sk->sk_wmem_queued);\n\tWARN_ON(sk->sk_forward_alloc);\n\n\tkfree(rcu_dereference_protected(inet->inet_opt, 1));\n\tdst_release(rcu_dereference_check(sk->sk_dst_cache, 1));\n\tsk_refcnt_debug_dec(sk);\n}",
        "output": "0",
        "idx": 459
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hybiWsFrameComplete(ws_ctx_t *wsctx)\n{\n  return wsctx != NULL && hybiRemaining(wsctx) == 0;\n}",
        "output": "0",
        "idx": 8891
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int hci_req_sync(struct hci_dev *hdev, int (*req)(struct hci_request *req,\n\t\t\t\t\t\t  unsigned long opt),\n\t\t unsigned long opt, u32 timeout, u8 *hci_status)\n{\n\tint ret;\n\n\tif (!test_bit(HCI_UP, &hdev->flags))\n\t\treturn -ENETDOWN;\n\n\thci_req_sync_lock(hdev);\n\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n\thci_req_sync_unlock(hdev);\n\n\treturn ret;\n}",
        "output": "1",
        "idx": 1928
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_rsvg_io_get_file_path (const gchar * filename,\n                        const gchar * base_uri)\n{\n    gchar *absolute_filename;\n\n    if (g_file_test (filename, G_FILE_TEST_EXISTS) || g_path_is_absolute (filename)) {\n        absolute_filename = g_strdup (filename);\n    } else {\n        gchar *tmpcdir;\n        gchar *base_filename;\n\n        if (base_uri) {\n            base_filename = g_filename_from_uri (base_uri, NULL, NULL);\n            if (base_filename != NULL) {\n                tmpcdir = g_path_get_dirname (base_filename);\n                g_free (base_filename);\n            } else \n                return NULL;\n        } else\n            tmpcdir = g_get_current_dir ();\n\n        absolute_filename = g_build_filename (tmpcdir, filename, NULL);\n        g_free (tmpcdir);\n    }\n\n    return absolute_filename;\n}",
        "output": "1",
        "idx": 6722
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "replace(const char *s, const char *old, const char *new)\n{\n\tchar *ret;\n\tint i, count = 0;\n\tsize_t newlen = strlen(new);\n\tsize_t oldlen = strlen(old);\n\n\tfor (i = 0; s[i] != '\\0'; i++) {\n\t\tif (strstr(&s[i], old) == &s[i]) {\n\t\t\tcount++;\n\t\t\ti += oldlen - 1;\n\t\t}\n\t}\n\tret = malloc(i + 1 + count * (newlen - oldlen));\n\tif (ret != NULL) {\n\t\ti = 0;\n\t\twhile (*s) {\n\t\t\tif (strstr(s, old) == s) {\n\t\t\t\tstrcpy(&ret[i], new);\n\t\t\t\ti += newlen;\n\t\t\t\ts += oldlen;\n\t\t\t} else {\n\t\t\t\tret[i++] = *s++;\n\t\t\t}\n\t\t}\n\t\tret[i] = '\\0';\n\t}\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 5083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct pid *good_sigevent(sigevent_t * event)\n{\n\tstruct task_struct *rtn = current->group_leader;\n\n\tswitch (event->sigev_notify) {\n\tcase SIGEV_SIGNAL | SIGEV_THREAD_ID:\n\t\trtn = find_task_by_vpid(event->sigev_notify_thread_id);\n\t\tif (!rtn || !same_thread_group(rtn, current))\n\t\t\treturn NULL;\n\tcase SIGEV_SIGNAL:\n\tcase SIGEV_THREAD:\n\t\tif (event->sigev_signo <= 0 || event->sigev_signo > SIGRTMAX)\n\t\t\treturn NULL;\n\tcase SIGEV_NONE:\n\t\treturn task_pid(rtn);\n\tdefault:\n\t\treturn NULL;\n\t}\n}",
        "output": "0",
        "idx": 2591
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int bson_check_string( bson *b, const char *string,\n                       const int length ) {\n\n    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 0, 0 );\n}",
        "output": "1",
        "idx": 7892
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iakerb_gss_process_context_token(OM_uint32 *minor_status,\n                                 const gss_ctx_id_t context_handle,\n                                 const gss_buffer_t token_buffer)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_DEFECTIVE_TOKEN;\n\n    return krb5_gss_process_context_token(minor_status, ctx->gssc,\n                                          token_buffer);\n}",
        "output": "0",
        "idx": 143
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)\n{\n\tlong tmp = *old;\n\t*old = atomic_long_cmpxchg(&sem->count, *old, new);\n\treturn *old == tmp;\n}",
        "output": "1",
        "idx": 2496
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long kernel_wait4(pid_t upid, int __user *stat_addr, int options,\n\t\t  struct rusage *ru)\n{\n\tstruct wait_opts wo;\n\tstruct pid *pid = NULL;\n\tenum pid_type type;\n\tlong ret;\n\n\tif (options & ~(WNOHANG|WUNTRACED|WCONTINUED|\n\t\t\t__WNOTHREAD|__WCLONE|__WALL))\n\t\treturn -EINVAL;\n\n\tif (upid == INT_MIN)\n\t\treturn -ESRCH;\n\n\tif (upid == -1)\n\t\ttype = PIDTYPE_MAX;\n\telse if (upid < 0) {\n\t\ttype = PIDTYPE_PGID;\n\t\tpid = find_get_pid(-upid);\n\t} else if (upid == 0) {\n\t\ttype = PIDTYPE_PGID;\n\t\tpid = get_task_pid(current, PIDTYPE_PGID);\n\t} else  {\n\t\ttype = PIDTYPE_PID;\n\t\tpid = find_get_pid(upid);\n\t}\n\n\two.wo_type\t= type;\n\two.wo_pid\t= pid;\n\two.wo_flags\t= options | WEXITED;\n\two.wo_info\t= NULL;\n\two.wo_stat\t= 0;\n\two.wo_rusage\t= ru;\n\tret = do_wait(&wo);\n\tput_pid(pid);\n\tif (ret > 0 && stat_addr && put_user(wo.wo_stat, stat_addr))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 2363
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iakerb_gss_get_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                   gss_qop_t qop_req, gss_buffer_t message_buffer,\n                   gss_buffer_t message_token)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_get_mic(minor_status, ctx->gssc, qop_req, message_buffer,\n                            message_token);\n}",
        "output": "0",
        "idx": 135
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "split_der(asn1buf *buf, uint8_t *const *der, size_t len, taginfo *tag_out)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n\n    ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    if (rlen != 0)\n        return ASN1_BAD_LENGTH;\n    insert_bytes(buf, contents, clen);\n    return 0;\n}",
        "output": "1",
        "idx": 198
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,\n\t\t\t\t    void *insn, int insn_len)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tint r;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tr = x86_decode_insn(ctxt, insn, insn_len, emulation_type);\n\n\ttrace_kvm_emulate_insn_start(vcpu);\n\t++vcpu->stat.insn_emulation;\n\n\treturn r;\n}",
        "output": "0",
        "idx": 2939
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t  const struct isakmp_gen *ext,\n\t\t  u_int item_len _U_,\n\t\t  const u_char *ep,\n\t\t  uint32_t phase _U_, uint32_t doi _U_,\n\t\t  uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" n len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\treturn NULL;\n}",
        "output": "1",
        "idx": 4728
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_swevent_overflow(struct perf_event *event, u64 overflow,\n\t\t\t\t    int nmi, struct perf_sample_data *data,\n\t\t\t\t    struct pt_regs *regs)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint throttle = 0;\n\n\tdata->period = event->hw.last_period;\n\tif (!overflow)\n\t\toverflow = perf_swevent_set_period(event);\n\n\tif (hwc->interrupts == MAX_INTERRUPTS)\n\t\treturn;\n\n\tfor (; overflow; overflow--) {\n\t\tif (__perf_event_overflow(event, nmi, throttle,\n\t\t\t\t\t    data, regs)) {\n\t\t\tbreak;\n\t\t}\n\t\tthrottle = 1;\n\t}\n}",
        "output": "1",
        "idx": 532
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Ta3Tokenizer_FindEncodingFilename(int fd, PyObject *filename)\n{\n    struct tok_state *tok;\n    FILE *fp;\n    char *p_start =NULL , *p_end =NULL , *encoding = NULL;\n\n#ifndef PGEN\n#if PY_MINOR_VERSION >= 4\n    fd = _Py_dup(fd);\n#endif\n#else\n    fd = dup(fd);\n#endif\n    if (fd < 0) {\n        return NULL;\n    }\n\n    fp = fdopen(fd, \"r\");\n    if (fp == NULL) {\n        return NULL;\n    }\n    tok = Ta3Tokenizer_FromFile(fp, NULL, NULL, NULL);\n    if (tok == NULL) {\n        fclose(fp);\n        return NULL;\n    }\n#ifndef PGEN\n    if (filename != NULL) {\n        Py_INCREF(filename);\n        tok->filename = filename;\n    }\n    else {\n        tok->filename = PyUnicode_FromString(\"<string>\");\n        if (tok->filename == NULL) {\n            fclose(fp);\n            Ta3Tokenizer_Free(tok);\n            return encoding;\n        }\n    }\n#endif\n    while (tok->lineno < 2 && tok->done == E_OK) {\n        Ta3Tokenizer_Get(tok, &p_start, &p_end);\n    }\n    fclose(fp);\n    if (tok->encoding) {\n        encoding = (char *)PyMem_MALLOC(strlen(tok->encoding) + 1);\n        if (encoding)\n        strcpy(encoding, tok->encoding);\n    }\n    Ta3Tokenizer_Free(tok);\n    return encoding;\n}",
        "output": "1",
        "idx": 7664
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "display_dollar(colnr_T col_arg)\n{\n    colnr_T col = col_arg < 0 ? 0 : col_arg;\n    colnr_T save_col;\n\n    if (!redrawing())\n\treturn;\n\n    cursor_off();\n    save_col = curwin->w_cursor.col;\n    curwin->w_cursor.col = col;\n    if (has_mbyte)\n    {\n\tchar_u *p;\n\n\tp = ml_get_curline();\n\tcurwin->w_cursor.col -= (*mb_head_off)(p, p + col);\n    }\n    curs_columns(FALSE);\t    \n    if (curwin->w_wcol < curwin->w_width)\n    {\n\tedit_putchar('$', FALSE);\n\tdollar_vcol = curwin->w_virtcol;\n    }\n    curwin->w_cursor.col = save_col;\n}",
        "output": "0",
        "idx": 8119
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,\n\t\t\t       __be16 dport)\n{\n\tstruct keydata *keyptr = get_keyptr();\n\tu32 hash[12];\n\n\tmemcpy(hash, saddr, 16);\n\thash[4] = (__force u32)dport;\n\tmemcpy(&hash[5], keyptr->secret, sizeof(__u32) * 7);\n\n\treturn twothirdsMD4Transform((const __u32 *)daddr, hash);\n}",
        "output": "1",
        "idx": 592
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int crypto_reportstat(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t      struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto drop_alg;\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = crypto_reportstat_alg(alg, &info);\n\ndrop_alg:\n\tcrypto_mod_put(alg);\n\n\tif (err)\n\t\treturn err;\n\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}",
        "output": "1",
        "idx": 3282
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jas_iccputsint(jas_stream_t *out, int n, longlong val)\n{\n\tulonglong tmp;\n\ttmp = (val < 0) ? (abort(), 0) : val;\n\treturn jas_iccputuint(out, n, tmp);\n}",
        "output": "1",
        "idx": 5384
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint rc, xprefix;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode;\n\n\t\t\trc = posix_acl_update_mode(inode, &mode, &acl);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tif (inode->i_mode != mode) {\n\t\t\t\tstruct iattr attr;\n\n\t\t\t\tattr.ia_valid = ATTR_MODE | ATTR_CTIME;\n\t\t\t\tattr.ia_mode = mode;\n\t\t\t\tattr.ia_ctime = CURRENT_TIME_SEC;\n\t\t\t\trc = jffs2_do_setattr(inode, &attr);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txprefix = JFFS2_XPREFIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\trc = __jffs2_set_acl(inode, xprefix, acl);\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\treturn rc;\n}",
        "output": "0",
        "idx": 1949
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main()\n{\n    gdImagePtr im;\n    char *buffer;\n    size_t size;\n\n    size = read_test_file(&buffer, \"heap_overflow.tga\");\n    im = gdImageCreateFromTgaPtr(size, (void *) buffer);\n    gdTestAssert(im == NULL);\n    free(buffer);\n\n    return gdNumFailures();\n}",
        "output": "0",
        "idx": 6175
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int parse_token(char **name, char **value, char **cp)\n{\n\tchar *end;\n\n\tif (!name || !value || !cp)\n\t\treturn -BLKID_ERR_PARAM;\n\n\tif (!(*value = strchr(*cp, '=')))\n\t\treturn 0;\n\n\t**value = '\\0';\n\t*name = strip_line(*cp);\n\t*value = skip_over_blank(*value + 1);\n\n\tif (**value == '\"') {\n\t\tend = strchr(*value + 1, '\"');\n\t\tif (!end) {\n\t\t\tDBG(READ, ul_debug(\"unbalanced quotes at: %s\", *value));\n\t\t\t*cp = *value;\n\t\t\treturn -BLKID_ERR_CACHE;\n\t\t}\n\t\t(*value)++;\n\t\t*end = '\\0';\n\t\tend++;\n\t} else {\n\t\tend = skip_over_word(*value);\n\t\tif (*end) {\n\t\t\t*end = '\\0';\n\t\t\tend++;\n\t\t}\n\t}\n\t*cp = end;\n\n\treturn 1;\n}",
        "output": "1",
        "idx": 4640
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,\n                                     uint32_t lun, void *hba_private)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n\n    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);\n    r = DO_UPCAST(SCSIDiskReq, req, req);\n    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);\n    return req;\n}",
        "output": "1",
        "idx": 3584
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode,\n\t\t\t   int relocated)\n{\n\tint flags = relocated ? RR_RELOC_DE : 0;\n\tint result = parse_rock_ridge_inode_internal(de, inode, flags);\n\n\tif ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)\n\t    && (ISOFS_SB(inode->i_sb)->s_rock == 2)) {\n\t\tresult = parse_rock_ridge_inode_internal(de, inode,\n\t\t\t\t\t\t\t flags | RR_REGARD_XA);\n\t}\n\treturn result;\n}",
        "output": "0",
        "idx": 3641
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dsOpen(void) {\n    struct stat sb;\n    int retval;\n    char *path = server.ds_path;\n\n    if ((retval = stat(path,&sb) == -1) && errno != ENOENT) {\n        redisLog(REDIS_WARNING, \"Error opening disk store at %s: %s\",\n                path, strerror(errno));\n        return REDIS_ERR;\n    }\n\n    if (retval == 0 && S_ISDIR(sb.st_mode)) return REDIS_OK;\n\n    if (retval == 0 && !S_ISDIR(sb.st_mode)) {\n        redisLog(REDIS_WARNING,\"Disk store at %s is not a directory\", path);\n        return REDIS_ERR;\n    }\n\n    if (mkdir(path) == -1) {\n        redisLog(REDIS_WARNING,\"Disk store init failed creating dir %s: %s\",\n            path, strerror(errno));\n        return REDIS_ERR;\n    }\n    return REDIS_OK;\n}",
        "output": "0",
        "idx": 5115
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int jas_stream_pad(jas_stream_t *stream, int n, int c)\n{\n\tint m;\n\tif (n < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_pad\");\n\t}\n\tm = n;\n\tfor (m = n; m > 0; --m) {\n\t\tif (jas_stream_putc(stream, c) == EOF)\n\t\t\treturn n - m;\n\t}\n\treturn n;\n}",
        "output": "0",
        "idx": 7523
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "next_line(struct archive_read *a,\n    const char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl)\n{\n\tssize_t len;\n\tint quit;\n\t\n\tquit = 0;\n\tif (*avail == 0) {\n\t\t*nl = 0;\n\t\tlen = 0;\n\t} else\n\t\tlen = get_line_size(*b, *avail, nl);\n\twhile (*nl == 0 && len == *avail && !quit) {\n\t\tssize_t diff = *ravail - *avail;\n\t\tsize_t nbytes_req = (*ravail+1023) & ~1023U;\n\t\tssize_t tested;\n\n\t\tif (nbytes_req < (size_t)*ravail + 160)\n\t\t\tnbytes_req <<= 1;\n\n\t\t*b = __archive_read_ahead(a, nbytes_req, avail);\n\t\tif (*b == NULL) {\n\t\t\tif (*ravail >= *avail)\n\t\t\t\treturn (0);\n\t\t\t*b = __archive_read_ahead(a, *avail, avail);\n\t\t\tquit = 1;\n\t\t}\n\t\t*ravail = *avail;\n\t\t*b += diff;\n\t\t*avail -= diff;\n\t\ttested = len;\n\t\tlen = get_line_size(*b, *avail, nl);\n\t\tif (len >= 0)\n\t\t\tlen += tested;\n\t}\n\treturn (len);\n}",
        "output": "1",
        "idx": 3710
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline long div_ll_X_l_rem(long long divs, long div, long *rem)\n{\n\tlong dum2;\n\tasm(\"divl %2\":\"=a\"(dum2), \"=d\"(*rem)\n\t    : \"rm\"(div), \"A\"(divs));\n\n\treturn dum2;\n\n}",
        "output": "1",
        "idx": 2096
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void usb_sg_cancel(struct usb_sg_request *io)\n{\n\tunsigned long flags;\n\tint i, retval;\n\n\tspin_lock_irqsave(&io->lock, flags);\n\tif (io->status) {\n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\treturn;\n\t}\n\tio->status = -ECONNRESET;\n\tspin_unlock_irqrestore(&io->lock, flags);\n\n\tfor (i = io->entries - 1; i >= 0; --i) {\n\t\tusb_block_urb(io->urbs[i]);\n\n\t\tretval = usb_unlink_urb(io->urbs[i]);\n\t\tif (retval != -EINPROGRESS\n\t\t    && retval != -ENODEV\n\t\t    && retval != -EBUSY\n\t\t    && retval != -EIDRM)\n\t\t\tdev_warn(&io->dev->dev, \"%s, unlink --> %d\\n\",\n\t\t\t\t __func__, retval);\n\t}\n}",
        "output": "1",
        "idx": 3338
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void nfs4_close_state(struct path *path, struct nfs4_state *state, fmode_t fmode)\n{\n\t__nfs4_close(path, state, fmode, 0);\n}",
        "output": "0",
        "idx": 3081
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(DirectoryIterator, getFilename)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_STRING(intern->u.dir.entry.d_name, 1);\n}",
        "output": "1",
        "idx": 4026
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static cchar *findAcceptableVersion(cchar *name, cchar *originalCriteria)\n{\n    MprDirEntry     *dp;\n    MprList         *files;\n    cchar           *criteria;\n    int             next;\n\n    criteria = originalCriteria;\n    if (!criteria || smatch(criteria, \"*\")) {\n        criteria = \"x\";\n    }\n    if (schr(name, '#')) {\n        name = ssplit(sclone(name), \"#\", (char**) &criteria);\n    }\n    files = mprGetPathFiles(mprJoinPath(app->paksCacheDir, name), MPR_PATH_RELATIVE);\n    mprSortList(files, (MprSortProc) reverseSortFiles, 0);\n    for (ITERATE_ITEMS(files, dp, next)) {\n        if (acceptableVersion(criteria, dp->name)) {\n            return dp->name;\n        }\n    }\n    if (originalCriteria) {\n        fail(\"Cannot find acceptable version for: \\\"%s\\\" with version criteria \\\"%s\\\" in %s\", \n            name, originalCriteria, app->paksCacheDir);\n    } else {\n        fail(\"Cannot find pak: \\\"%s\\\" in %s\", name, app->paksCacheDir);\n    }\n    mprLog(\"\", 0, \"Use \\\"pak install %s\\\" to install\", name);\n    return 0;\n}",
        "output": "0",
        "idx": 6951
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline pmd_t pmd_read_atomic(pmd_t *pmdp)\n{\n\tpmdval_t ret;\n\tu32 *tmp = (u32 *)pmdp;\n\n\tret = (pmdval_t) (*tmp);\n\tif (ret) {\n\t\tsmp_rmb();\n\t\tret |= ((pmdval_t)*(tmp + 1)) << 32;\n\t}\n\n\treturn (pmd_t) { ret };\n}",
        "output": "0",
        "idx": 955
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int perf_event_refresh(struct perf_event *event, int refresh)\n{\n\tif (event->attr.inherit || !is_sampling_event(event))\n\t\treturn -EINVAL;\n\n\tatomic_add(refresh, &event->event_limit);\n\tperf_event_enable(event);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 2770
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ipc_rcu_getref(void *ptr)\n{\n\tcontainer_of(ptr, struct ipc_rcu_hdr, data)->refcount++;\n}",
        "output": "1",
        "idx": 2278
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t bat_socket_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct socket_packet *socket_packet;\n\tsize_t packet_len;\n\tint error;\n\n\tif ((file->f_flags & O_NONBLOCK) && (socket_client->queue_len == 0))\n\t\treturn -EAGAIN;\n\n\tif ((!buf) || (count < sizeof(struct icmp_packet)))\n\t\treturn -EINVAL;\n\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\n\terror = wait_event_interruptible(socket_client->queue_wait,\n\t\t\t\t\t socket_client->queue_len);\n\n\tif (error)\n\t\treturn error;\n\n\tspin_lock_bh(&socket_client->lock);\n\n\tsocket_packet = list_first_entry(&socket_client->queue_list,\n\t\t\t\t\t struct socket_packet, list);\n\tlist_del(&socket_packet->list);\n\tsocket_client->queue_len--;\n\n\tspin_unlock_bh(&socket_client->lock);\n\n\terror = copy_to_user(buf, &socket_packet->icmp_packet,\n\t\t\t     socket_packet->icmp_len);\n\n\tpacket_len = socket_packet->icmp_len;\n\tkfree(socket_packet);\n\n\tif (error)\n\t\treturn -EFAULT;\n\n\treturn packet_len;\n}",
        "output": "1",
        "idx": 648
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rose_start_t1timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tsk_stop_timer(sk, &rose->timer);\n\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t1;\n\n\tsk_reset_timer(sk, &rose->timer, rose->timer.expires);\n}",
        "output": "0",
        "idx": 2949
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void do_sched_cfs_slack_timer(struct cfs_bandwidth *cfs_b)\n{\n\tu64 runtime = 0, slice = sched_cfs_bandwidth_slice();\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&cfs_b->lock, flags);\n\tcfs_b->slack_started = false;\n\tif (cfs_b->distribute_running) {\n\t\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n\t\treturn;\n\t}\n\n\tif (runtime_refresh_within(cfs_b, min_bandwidth_expiration)) {\n\t\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n\t\treturn;\n\t}\n\n\tif (cfs_b->quota != RUNTIME_INF && cfs_b->runtime > slice)\n\t\truntime = cfs_b->runtime;\n\n\tif (runtime)\n\t\tcfs_b->distribute_running = 1;\n\n\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n\n\tif (!runtime)\n\t\treturn;\n\n\truntime = distribute_cfs_runtime(cfs_b, runtime);\n\n\traw_spin_lock_irqsave(&cfs_b->lock, flags);\n\tlsub_positive(&cfs_b->runtime, runtime);\n\tcfs_b->distribute_running = 0;\n\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n}",
        "output": "0",
        "idx": 4441
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int inet6_csk_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl_unused)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint res;\n\n\tdst = inet6_csk_route_socket(sk, &fl6);\n\tif (IS_ERR(dst)) {\n\t\tsk->sk_err_soft = -PTR_ERR(dst);\n\t\tsk->sk_route_caps = 0;\n\t\tkfree_skb(skb);\n\t\treturn PTR_ERR(dst);\n\t}\n\n\trcu_read_lock();\n\tskb_dst_set_noref(skb, dst);\n\n\tfl6.daddr = sk->sk_v6_daddr;\n\n\tres = ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n\trcu_read_unlock();\n\treturn res;\n}",
        "output": "1",
        "idx": 958
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vrrp_print_data(void)\n{\n\tFILE *file = fopen (dump_file, \"w\");\n\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",\n\t\t\tdump_file, errno, strerror(errno));\n\t\treturn;\n\t}\n\n\tdump_data_vrrp(file);\n\n\tfclose(file);\n}",
        "output": "1",
        "idx": 7092
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int getStrrtokenPos(char* str, int savedPos)\n{\n\tint result =-1;\n\tint i;\n\n\tfor(i=savedPos-1; i>=0; i--) {\n\t\tif(isIDSeparator(*(str+i)) ){\n\t\t\tif(i>=2 && isIDSeparator(*(str+i-2)) ){\n\t\t\t\tresult = i-2;\n\t\t\t} else {\n\t\t\t\tresult = i;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(result < 1){\n\t\tresult =-1;\n\t}\n\treturn result;\n}",
        "output": "0",
        "idx": 5443
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_restricted(void)\n{\n    if (restricted)\n    {\n\temsg(_(\"E145: Shell commands and some functionality not allowed in rvim\"));\n\treturn TRUE;\n    }\n    return FALSE;\n}",
        "output": "0",
        "idx": 8183
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, valid)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {\n\t\tRETURN_BOOL(intern->u.file.current_line || intern->u.file.current_zval);\n\t} else {\n\t\tRETVAL_BOOL(!php_stream_eof(intern->u.file.stream));\n\t}\n} ",
        "output": "0",
        "idx": 5557
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tint i;\n\tfprintf(out, \"qntsty = %d; numguard = %d; numstepsizes = %d\\n\",\n\t  (int) qcd->compparms.qntsty, qcd->compparms.numguard, qcd->compparms.numstepsizes);\n\tfor (i = 0; i < qcd->compparms.numstepsizes; ++i) {\n\t\tfprintf(out, \"expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n\",\n\t\t  i, JAS_CAST(unsigned, JPC_QCX_GETEXPN(qcd->compparms.stepsizes[i])),\n\t\t  i, JAS_CAST(unsigned, JPC_QCX_GETMANT(qcd->compparms.stepsizes[i])));\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 7509
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline u64 get_canonical(u64 la)\n{\n\treturn ((int64_t)la << 16) >> 16;\n}",
        "output": "0",
        "idx": 3727
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VALUE cState_array_nl_set(VALUE self, VALUE array_nl)\n{\n    unsigned long len;\n    GET_STATE(self);\n    Check_Type(array_nl, T_STRING);\n    len = RSTRING_LEN(array_nl);\n    if (len == 0) {\n        if (state->array_nl) {\n            ruby_xfree(state->array_nl);\n            state->array_nl = NULL;\n        }\n    } else {\n        if (state->array_nl) ruby_xfree(state->array_nl);\n        state->array_nl = fstrndup(RSTRING_PTR(array_nl), len);\n        state->array_nl_len = len;\n    }\n    return Qnil;\n}",
        "output": "0",
        "idx": 8799
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_report(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t\t struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto drop_alg;\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = crypto_report_alg(alg, &info);\n\ndrop_alg:\n\tcrypto_mod_put(alg);\n\n\tif (err)\n\t\treturn err;\n\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}",
        "output": "1",
        "idx": 3280
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static LUA_FUNCTION(openssl_x509_check_email)\n{\n  X509 * cert = CHECK_OBJECT(1, X509, \"openssl.x509\");\n  if (lua_isstring(L, 2))\n  {\n    const char *email = lua_tostring(L, 2);\n    lua_pushboolean(L, X509_check_email(cert, email, strlen(email), 0));\n  }\n  else\n  {\n    lua_pushboolean(L, 0);\n  }\n  return 1;\n}",
        "output": "1",
        "idx": 8426
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)\n{\n\tstruct channel *pch;\n\tstruct ppp_net *pn;\n\n\tpch = kzalloc(sizeof(struct channel), GFP_KERNEL);\n\tif (!pch)\n\t\treturn -ENOMEM;\n\n\tpn = ppp_pernet(net);\n\n\tpch->ppp = NULL;\n\tpch->chan = chan;\n\tpch->chan_net = net;\n\tchan->ppp = pch;\n\tinit_ppp_file(&pch->file, CHANNEL);\n\tpch->file.hdrlen = chan->hdrlen;\n#ifdef CONFIG_PPP_MULTILINK\n\tpch->lastseq = -1;\n#endif \n\tinit_rwsem(&pch->chan_sem);\n\tspin_lock_init(&pch->downl);\n\trwlock_init(&pch->upl);\n\n\tspin_lock_bh(&pn->all_channels_lock);\n\tpch->file.index = ++pn->last_channel_index;\n\tlist_add(&pch->list, &pn->new_channels);\n\tatomic_inc(&channel_count);\n\tspin_unlock_bh(&pn->all_channels_lock);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1166
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "MONGO_EXPORT void __mongo_set_error( mongo *conn, mongo_error_t err, const char *str,\n                                     int errcode ) {\n    int errstr_size, str_size;\n\n    conn->err = err;\n    conn->errcode = errcode;\n\n    if( str ) {\n        str_size = strlen( str ) + 1;\n        errstr_size = str_size > MONGO_ERR_LEN ? MONGO_ERR_LEN : str_size;\n        memcpy( conn->errstr, str, errstr_size );\n        conn->errstr[errstr_size-1] = '\\0';\n    }\n}",
        "output": "1",
        "idx": 7910
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static punycode_uint decode_digit(punycode_uint cp)\n{\n  return  cp - 48 < 10 ? cp - 22 :  cp - 65 < 26 ? cp - 65 :\n          cp - 97 < 26 ? cp - 97 :  base;\n}",
        "output": "1",
        "idx": 6260
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct desc;\n\tunsigned long limit;\n\tshort sel;\n\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn 0;\n\n\tif (user_64bit_mode(regs) || v8086_mode(regs))\n\t\treturn -1L;\n\n\tif (!sel)\n\t\treturn 0;\n\n\tif (!get_desc(&desc, sel))\n\t\treturn 0;\n\n\tlimit = get_desc_limit(&desc);\n\tif (desc.g)\n\t\tlimit = (limit << 12) + 0xfff;\n\n\treturn limit;\n}",
        "output": "0",
        "idx": 4409
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xfrm_dump_policy_start(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\n\tBUILD_BUG_ON(sizeof(*walk) > sizeof(cb->args));\n\n\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\treturn 0;\n}",
        "output": "0",
        "idx": 2527
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "crm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted)\n{\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        cib_send_tls(session, msg);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        cib_send_plaintext(GPOINTER_TO_INT(session), msg);\n    }\n}",
        "output": "1",
        "idx": 3744
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "COMPAT_SYSCALL_DEFINE3(set_mempolicy, int, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode)\n{\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tDECLARE_BITMAP(bm, MAX_NUMNODES);\n\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\n\tif (nmask) {\n\t\tif (compat_get_bitmap(bm, nmask, nr_bits))\n\t\t\treturn -EFAULT;\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\tif (copy_to_user(nm, bm, alloc_size))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn sys_set_mempolicy(mode, nm, nr_bits+1);\n}",
        "output": "0",
        "idx": 2231
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_aead raead;\n\tstruct aead_alg *aead = &alg->cra_aead;\n\n\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"nivaead\");\n\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \"%s\", aead->geniv);\n\n\traead.blocksize = alg->cra_blocksize;\n\traead.maxauthsize = aead->maxauthsize;\n\traead.ivsize = aead->ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,\n\t\t    sizeof(struct crypto_report_aead), &raead))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "1",
        "idx": 844
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_name)\n{\n\tzval**\tele_value\t= NULL;\n\n\tif(zend_hash_find(hash_arr , key_name , strlen(key_name) + 1 ,(void **)&ele_value ) == SUCCESS ) {\n\t\tif(Z_TYPE_PP(ele_value)!= IS_STRING ){\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif(strcmp(key_name, LOC_LANG_TAG) != 0 &&\n\t\t   strcmp(key_name, LOC_GRANDFATHERED_LANG_TAG)!=0 ) {\n\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n\t\t}\n\t\tsmart_str_appendl(loc_name, Z_STRVAL_PP(ele_value) , Z_STRLEN_PP(ele_value));\n\t\treturn SUCCESS;\n\t}\n\n\treturn LOC_NOT_FOUND;\n}",
        "output": "0",
        "idx": 5431
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int skcipher_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t   unsigned int keylen)\n{\n\tstruct skcipher_alg *cipher = crypto_skcipher_alg(tfm);\n\tunsigned long alignmask = crypto_skcipher_alignmask(tfm);\n\n\tif (keylen < cipher->min_keysize || keylen > cipher->max_keysize) {\n\t\tcrypto_skcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((unsigned long)key & alignmask)\n\t\treturn skcipher_setkey_unaligned(tfm, key, keylen);\n\n\treturn cipher->setkey(tfm, key, keylen);\n}",
        "output": "0",
        "idx": 2305
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void usb_sg_cancel(struct usb_sg_request *io)\n{\n\tunsigned long flags;\n\tint i, retval;\n\n\tspin_lock_irqsave(&io->lock, flags);\n\tif (io->status || io->count == 0) {\n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\treturn;\n\t}\n\tio->status = -ECONNRESET;\n\tio->count++;\t\t\n\tspin_unlock_irqrestore(&io->lock, flags);\n\n\tfor (i = io->entries - 1; i >= 0; --i) {\n\t\tusb_block_urb(io->urbs[i]);\n\n\t\tretval = usb_unlink_urb(io->urbs[i]);\n\t\tif (retval != -EINPROGRESS\n\t\t    && retval != -ENODEV\n\t\t    && retval != -EBUSY\n\t\t    && retval != -EIDRM)\n\t\t\tdev_warn(&io->dev->dev, \"%s, unlink --> %d\\n\",\n\t\t\t\t __func__, retval);\n\t}\n\n\tspin_lock_irqsave(&io->lock, flags);\n\tio->count--;\n\tif (!io->count)\n\t\tcomplete(&io->complete);\n\tspin_unlock_irqrestore(&io->lock, flags);\n}",
        "output": "0",
        "idx": 4637
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi, bool umount)\n{\n\t__issue_discard_cmd(sbi, false);\n\t__drop_discard_cmd(sbi);\n\t__wait_discard_cmd(sbi, !umount);\n}",
        "output": "0",
        "idx": 2439
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MprJson *queryRange(MprJson *obj, char *property, cchar *rest, MprJson *value, int flags)\n{\n    MprJson     *child, *result;\n    ssize       start, end;\n    char        *e, *s, ibuf[16];\n    int         index;\n\n    result = mprCreateJson(MPR_JSON_ARRAY);\n    if (!(obj->type & MPR_JSON_ARRAY)) {\n        return result;\n    }\n    s = stok(property, \": \\t\", &e);\n    start = (ssize) stoi(s);\n    end = (ssize) stoi(e);\n    if (start < 0) {\n        start = obj->length + start;\n    }\n    if (end < 0) {\n        end = obj->length + end;\n    }\n    for (ITERATE_JSON(obj, child, index)) {\n        if (index < start) continue;\n        if (index > end) break;\n        if (rest == 0) {\n            if (flags & MPR_JSON_REMOVE) {\n                appendItem(result, mprRemoveJsonChild(obj, child));\n            } else {\n                appendItem(result, queryLeaf(obj, itosbuf(ibuf, sizeof(ibuf), index, 10), value, flags));\n            }\n        } else {\n            appendItems(result, queryCore(child, rest, value, flags));\n        }\n    }\n    return result;\n}",
        "output": "1",
        "idx": 5086
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)\n{\n\tif (prev_options != NULL) {\n\t\t*prev_options = MBREX(regex_default_options);\n\t}\n\tif (prev_syntax != NULL) {\n\t\t*prev_syntax = MBREX(regex_default_syntax);\n\t}\n\tMBREX(regex_default_options) = options;\n\tMBREX(regex_default_syntax) = syntax;\n}",
        "output": "0",
        "idx": 5587
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseAll(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprJson     *routes;\n    MprJson     *child;\n    int         ji;\n\n    for (ITERATE_CONFIG(route, prop, child, ji)) {\n        parseKey(route, key, child);\n    }\n\n    if ((routes = mprGetJsonObj(prop, \"routes\")) != 0) {\n        parseRoutes(route, key, routes);\n    }\n}",
        "output": "1",
        "idx": 5038
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int btrfs_scrub_progress(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t struct btrfs_scrub_progress *progress)\n{\n\tstruct btrfs_device *dev;\n\tstruct scrub_ctx *sctx = NULL;\n\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL, true);\n\tif (dev)\n\t\tsctx = dev->scrub_ctx;\n\tif (sctx)\n\t\tmemcpy(progress, &sctx->stat, sizeof(*progress));\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\n\treturn dev ? (sctx ? 0 : -ENOTCONN) : -ENODEV;\n}",
        "output": "0",
        "idx": 4255
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void set_fdc(int drive)\n{\n\tif (drive >= 0 && drive < N_DRIVE) {\n\t\tfdc = FDC(drive);\n\t\tcurrent_drive = drive;\n\t}\n\tif (fdc != 1 && fdc != 0) {\n\t\tpr_info(\"bad fdc value\\n\");\n\t\treturn;\n\t}\n\tset_dor(fdc, ~0, 8);\n#if N_FDC > 1\n\tset_dor(1 - fdc, ~8, 0);\n#endif\n\tif (FDCS->rawcmd == 2)\n\t\treset_fdc_info(1);\n\tif (fd_inb(FD_STATUS) != STATUS_READY)\n\t\tFDCS->reset = 1;\n}",
        "output": "1",
        "idx": 3322
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bittok2str_internal(register const struct tok *lp, register const char *fmt,\n\t   register u_int v, const char *sep)\n{\n        static char buf[256]; \n        int buflen=0;\n        register u_int rotbit; \n        register u_int tokval;\n        const char * sepstr = \"\";\n\n\twhile (lp != NULL && lp->s != NULL) {\n            tokval=lp->v;   \n            rotbit=1;\n            while (rotbit != 0) {\n\t\tif (tokval == (v&rotbit)) {\n                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, \"%s%s\",\n                                     sepstr, lp->s);\n                    sepstr = sep;\n                    break;\n                }\n                rotbit=rotbit<<1; \n            }\n            lp++;\n\t}\n\n        if (buflen == 0)\n            (void)snprintf(buf, sizeof(buf), fmt == NULL ? \"#%08x\" : fmt, v);\n        return (buf);\n}",
        "output": "1",
        "idx": 4782
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct clock_source *dce112_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\n\tif (!clk_src)\n\t\treturn NULL;\n\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}",
        "output": "0",
        "idx": 4519
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "AcpiNsTerminate (\n    void)\n{\n    ACPI_STATUS             Status;\n    ACPI_OPERAND_OBJECT     *Prev;\n    ACPI_OPERAND_OBJECT     *Next;\n\n\n    ACPI_FUNCTION_TRACE (NsTerminate);\n\n\n\n    Next = AcpiGbl_ModuleCodeList;\n    while (Next)\n    {\n        Prev = Next;\n        Next = Next->Method.Mutex;\n        Prev->Method.Mutex = NULL; \n        AcpiUtRemoveReference (Prev);\n    }\n\n    AcpiNsDeleteNamespaceSubtree (AcpiGbl_RootNode);\n\n\n    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);\n    if (ACPI_FAILURE (Status))\n    {\n        return_VOID;\n    }\n\n    AcpiNsDeleteNode (AcpiGbl_RootNode);\n    (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);\n\n    ACPI_DEBUG_PRINT ((ACPI_DB_INFO, \"Namespace freed\\n\"));\n    return_VOID;\n}",
        "output": "0",
        "idx": 8737
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tunsigned int i;\n\tbpcc->bpcs = 0;\n\tbpcc->numcmpts = box->datalen;\n\tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_getuint8(in, &bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 7621
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)\t\t{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;\n\tnewitem->next=c->next;newitem->prev=c->prev;if (newitem->next) newitem->next->prev=newitem;\n\tif (c==array->child) array->child=newitem; else newitem->prev->next=newitem;c->next=c->prev=0;cJSON_Delete(c);}",
        "output": "0",
        "idx": 8265
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void flush_tlb_page(struct vm_area_struct *vma, unsigned long start)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\n\tpreempt_disable();\n\n\tif (current->active_mm == mm) {\n\t\tif (current->mm) {\n\t\t\t__flush_tlb_one(start);\n\t\t} else {\n\t\t\tleave_mm(smp_processor_id());\n\n\t\t\tsmp_mb();\n\t\t}\n\t}\n\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, start, 0UL);\n\n\tpreempt_enable();\n}",
        "output": "0",
        "idx": 1513
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gsm_xsmp_client_disconnect (GsmXSMPClient *client)\n{\n        if (client->priv->watch_id > 0) {\n                g_source_remove (client->priv->watch_id);\n        }\n\n        if (client->priv->conn != NULL) {\n                SmsCleanUp (client->priv->conn);\n        }\n\n        if (client->priv->ice_connection != NULL) {\n                IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);\n                IceCloseConnection (client->priv->ice_connection);\n        }\n\n        if (client->priv->protocol_timeout > 0) {\n                g_source_remove (client->priv->protocol_timeout);\n        }\n}",
        "output": "1",
        "idx": 6210
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PJ_DEF(int) pj_scan_get_char( pj_scanner *scanner )\n{\n    int chr = *scanner->curptr;\n\n    if (!chr) {\n\tpj_scan_syntax_err(scanner);\n\treturn 0;\n    }\n\n    ++scanner->curptr;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n    return chr;\n}",
        "output": "1",
        "idx": 8046
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "tpaddr_print_ip(netdissect_options *ndo,\n\t        const struct arp_pkthdr *ap, u_short pro)\n{\n\tif (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)\n\t\tND_PRINT((ndo, \"<wrong proto type>\"));\n\telse if (PROTO_LEN(ap) != 4)\n\t\tND_PRINT((ndo, \"<wrong len>\"));\n\telse\n\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, TPA(ap))));\n}",
        "output": "0",
        "idx": 6699
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void exit_io_context(void)\n{\n}",
        "output": "1",
        "idx": 2190
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ip_options_get_from_user(struct net *net, struct ip_options **optp,\n\t\t\t     unsigned char __user *data, int optlen)\n{\n\tstruct ip_options *opt = ip_options_get_alloc(optlen);\n\n\tif (!opt)\n\t\treturn -ENOMEM;\n\tif (optlen && copy_from_user(opt->__data, data, optlen)) {\n\t\tkfree(opt);\n\t\treturn -EFAULT;\n\t}\n\treturn ip_options_get_finish(net, optp, opt, optlen);\n}",
        "output": "1",
        "idx": 354
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int parse_exports_table(long long *table_start)\n{\n\tint res;\n\tint indexes = SQUASHFS_LOOKUP_BLOCKS((long long) sBlk.s.inodes);\n\tint length = SQUASHFS_LOOKUP_BLOCK_BYTES((long long) sBlk.s.inodes);\n\tlong long *export_index_table;\n\n\tif(length != (*table_start - sBlk.s.lookup_table_start)) {\n\t\tERROR(\"parse_exports_table: Bad inode count in super block\\n\");\n\t\treturn FALSE;\n\t}\n\n\texport_index_table = alloc_index_table(indexes);\n\n\tres = read_fs_bytes(fd, sBlk.s.lookup_table_start, length,\n\t\t\t\t\t\t\texport_index_table);\n\tif(res == FALSE) {\n\t\tERROR(\"parse_exports_table: failed to read export index table\\n\");\n\t\treturn FALSE;\n\t}\n\tSQUASHFS_INSWAP_LOOKUP_BLOCKS(export_index_table, indexes);\n\n\t*table_start = export_index_table[0];\n\n\treturn TRUE;\n}",
        "output": "0",
        "idx": 7447
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void perf_pmu_migrate_context(struct pmu *pmu, int src_cpu, int dst_cpu)\n{\n\tstruct perf_event_context *src_ctx;\n\tstruct perf_event_context *dst_ctx;\n\tstruct perf_event *event, *tmp;\n\tLIST_HEAD(events);\n\n\tsrc_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, src_cpu)->ctx;\n\tdst_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, dst_cpu)->ctx;\n\n\tmutex_lock_double(&src_ctx->mutex, &dst_ctx->mutex);\n\tlist_for_each_entry_safe(event, tmp, &src_ctx->event_list,\n\t\t\t\t event_entry) {\n\t\tperf_remove_from_context(event, false);\n\t\tunaccount_event_cpu(event, src_cpu);\n\t\tput_ctx(src_ctx);\n\t\tlist_add(&event->migrate_entry, &events);\n\t}\n\n\tsynchronize_rcu();\n\n\tlist_for_each_entry_safe(event, tmp, &events, migrate_entry) {\n\t\tlist_del(&event->migrate_entry);\n\t\tif (event->state >= PERF_EVENT_STATE_OFF)\n\t\t\tevent->state = PERF_EVENT_STATE_INACTIVE;\n\t\taccount_event_cpu(event, dst_cpu);\n\t\tperf_install_in_context(dst_ctx, event, dst_cpu);\n\t\tget_ctx(dst_ctx);\n\t}\n\tmutex_unlock(&dst_ctx->mutex);\n\tmutex_unlock(&src_ctx->mutex);\n}",
        "output": "0",
        "idx": 3851
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int seed_from_timestamp_and_pid(uint32_t *seed) {\n#ifdef HAVE_GETTIMEOFDAY\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    *seed = (uint32_t)tv.tv_sec ^ (uint32_t)tv.tv_usec;\n#else\n    *seed = (uint32_t)time(NULL);\n#endif\n\n#if defined(_WIN32)\n    *seed ^= (uint32_t)_getpid();\n#elif defined(HAVE_GETPID)\n    *seed ^= (uint32_t)getpid();\n#endif\n\n    return 0;\n}",
        "output": "0",
        "idx": 5987
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint32 bps = tif->tif_dir.td_bitspersample / 8;\n\ttmsize_t wc = cc / bps;\n\ttmsize_t count;\n\tuint8 *cp = (uint8 *) cp0;\n\tuint8 *tmp = (uint8 *)_TIFFmalloc(cc);\n\n\tassert((cc%(bps*stride))==0);\n\n\tif (!tmp)\n\t\treturn;\n\n\t_TIFFmemcpy(tmp, cp0, cc);\n\tfor (count = 0; count < wc; count++) {\n\t\tuint32 byte;\n\t\tfor (byte = 0; byte < bps; byte++) {\n\t\t\t#if WORDS_BIGENDIAN\n\t\t\tcp[byte * wc + count] = tmp[bps * count + byte];\n\t\t\t#else\n\t\t\tcp[(bps - byte - 1) * wc + count] =\n\t\t\t\ttmp[bps * count + byte];\n\t\t\t#endif\n\t\t}\n\t}\n\t_TIFFfree(tmp);\n\n\tcp = (uint8 *) cp0;\n\tcp += cc - stride - 1;\n\tfor (count = cc; count > stride; count -= stride)\n\t\tREPEAT4(stride, cp[stride] = (unsigned char)((cp[stride] - cp[0])&0xff); cp--)\n}",
        "output": "1",
        "idx": 4260
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseCache(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprJson     *child;\n    MprTicks    clientLifespan, serverLifespan;\n    cchar       *methods, *extensions, *uris, *mimeTypes, *client, *server;\n    int         flags, ji;\n\n    clientLifespan = serverLifespan = 0;\n    for (ITERATE_CONFIG(route, prop, child, ji)) {\n        flags = 0;\n        if ((client = mprReadJson(child, \"client\")) != 0) {\n            flags |= HTTP_CACHE_CLIENT;\n            clientLifespan = httpGetTicks(client);\n        }\n        if ((server = mprReadJson(child, \"server\")) != 0) {\n            flags |= HTTP_CACHE_SERVER;\n            serverLifespan = httpGetTicks(server);\n        }\n        methods = getList(mprReadJsonObj(child, \"methods\"));\n        extensions = getList(mprReadJsonObj(child, \"extensions\"));\n        uris = getList(mprReadJsonObj(child, \"uris\"));\n        mimeTypes = getList(mprReadJsonObj(child, \"mime\"));\n\n        if (smatch(mprReadJson(child, \"unique\"), \"true\")) {\n            flags |= HTTP_CACHE_UNIQUE;\n        }\n        if (smatch(mprReadJson(child, \"manual\"), \"true\")) {\n            flags |= HTTP_CACHE_MANUAL;\n        }\n        httpAddCache(route, methods, uris, extensions, mimeTypes, clientLifespan, serverLifespan, flags);\n    }\n}",
        "output": "0",
        "idx": 6993
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int linear_ioctl(struct dm_target *ti, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct linear_c *lc = (struct linear_c *) ti->private;\n\treturn __blkdev_driver_ioctl(lc->dev->bdev, lc->dev->mode, cmd, arg);\n}",
        "output": "1",
        "idx": 668
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack)\n{\n\tGF_TimeToSampleBox *stts = stbl->TimeToSample;\n\n\tif (!nb_pack) nb_pack = 1;\n\tif (stts->nb_entries) {\n\t\tif (stts->entries[stts->nb_entries-1].sampleDelta == duration) {\n\t\t\tstts->entries[stts->nb_entries-1].sampleCount += nb_pack;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\tif (stts->nb_entries==stts->alloc_size) {\n\t\tALLOC_INC(stts->alloc_size);\n\t\tstts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);\n\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) );\n\t}\n\tstts->entries[stts->nb_entries].sampleCount = nb_pack;\n\tstts->entries[stts->nb_entries].sampleDelta = duration;\n\tstts->nb_entries++;\n\tif (stts->max_ts_delta < duration ) stts->max_ts_delta = duration;\n\treturn GF_OK;\n}",
        "output": "1",
        "idx": 6874
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int asymmetric_key_cmp(const struct key *key,\n\t\t\t      const struct key_match_data *match_data)\n{\n\tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n\tconst char *description = match_data->raw_data;\n\tconst char *spec = description;\n\tconst char *id;\n\tptrdiff_t speclen;\n\n\tif (!subtype || !spec || !*spec)\n\t\treturn 0;\n\n\tif (key->description && strcmp(key->description, description) == 0)\n\t\treturn 1;\n\n\tid = strchr(spec, ':');\n\tif (!id)\n\t\treturn 0;\n\n\tspeclen = id - spec;\n\tid++;\n\n\tif (speclen == 2 && memcmp(spec, \"id\", 2) == 0)\n\t\treturn asymmetric_keyid_match(asymmetric_key_id(key), id);\n\n\tif (speclen == subtype->name_len &&\n\t    memcmp(spec, subtype->name, speclen) == 0)\n\t\treturn 1;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 3677
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int netlbl_cipsov4_add_common(struct genl_info *info,\n\t\t\t\t     struct cipso_v4_doi *doi_def)\n{\n\tstruct nlattr *nla;\n\tint nla_rem;\n\tu32 iter = 0;\n\n\tdoi_def->doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\n\tif (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_TAGLST],\n\t\t\t\tNLBL_CIPSOV4_A_MAX,\n\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)\n\t\tif (nla->nla_type == NLBL_CIPSOV4_A_TAG) {\n\t\t\tif (iter >= CIPSO_V4_TAG_MAXCNT)\n\t\t\t\treturn -EINVAL;\n\t\t\tdoi_def->tags[iter++] = nla_get_u8(nla);\n\t\t}\n\twhile (iter < CIPSO_V4_TAG_MAXCNT)\n\t\tdoi_def->tags[iter++] = CIPSO_V4_TAG_INVALID;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2979
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateTrue( void )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item )\n\t\titem->type = cJSON_True;\n\treturn item;\n}",
        "output": "1",
        "idx": 5958
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "COMPAT_SYSCALL_DEFINE3(set_mempolicy, int, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode)\n{\n\tlong err = 0;\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tDECLARE_BITMAP(bm, MAX_NUMNODES);\n\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\n\tif (nmask) {\n\t\terr = compat_get_bitmap(bm, nmask, nr_bits);\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\terr |= copy_to_user(nm, bm, alloc_size);\n\t}\n\n\tif (err)\n\t\treturn -EFAULT;\n\n\treturn sys_set_mempolicy(mode, nm, nr_bits+1);\n}",
        "output": "1",
        "idx": 1546
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void sctp_generate_heartbeat_event(unsigned long data)\n{\n\tint error = 0;\n\tstruct sctp_transport *transport = (struct sctp_transport *) data;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\n\t\tif (!mod_timer(&transport->hb_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_HEARTBEAT),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\n\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_transport_put(transport);\n}",
        "output": "1",
        "idx": 2912
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex)\n{\n\n\tGF_DataEntryURLBox *entry;\n\tGF_DataMap *map;\n\tGF_Err e;\n\tif (!mdia || !dataEntryIndex || dataEntryIndex > gf_list_count(mdia->information->dataInformation->dref->child_boxes)) return GF_BAD_PARAM;\n\n\tentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataEntryIndex - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\tif (entry->flags == 1) return GF_OK;\n\n\tif (entry->type == GF_ISOM_BOX_TYPE_URN) return GF_NOT_SUPPORTED;\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_WRITE) {\n\t\te = gf_isom_datamap_new(entry->location, NULL, GF_ISOM_DATA_MAP_READ, &map);\n\t} else {\n\t\te = gf_isom_datamap_new(entry->location, mdia->mediaTrack->moov->mov->fileName, GF_ISOM_DATA_MAP_READ, &map);\n\t}\n\tif (e) return e;\n\tgf_isom_datamap_del(map);\n\treturn GF_OK;\n}",
        "output": "1",
        "idx": 6860
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tWARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING &&\n\t\t\t!(task_thread_info(p)->preempt_count & PREEMPT_ACTIVE));\n\n#ifdef CONFIG_LOCKDEP\n\tWARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||\n\t\t\t\t      lockdep_is_held(&task_rq(p)->lock)));\n#endif\n#endif\n\n\ttrace_sched_migrate_task(p, new_cpu);\n\n\tif (task_cpu(p) != new_cpu) {\n\t\tp->se.nr_migrations++;\n\t\tperf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, NULL, 0);\n\t}\n\n\t__set_task_cpu(p, new_cpu);\n}",
        "output": "0",
        "idx": 709
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jas_iccgetsint32(jas_stream_t *in, jas_iccsint32_t *val)\n{\n\tulonglong tmp;\n\tif (jas_iccgetuint(in, 4, &tmp))\n\t\treturn -1;\n\t*val = (tmp & 0x80000000) ? (-JAS_CAST(longlong, (((~tmp) &\n\t  0x7fffffff) + 1))) : JAS_CAST(longlong, tmp);\n\treturn 0;\n}",
        "output": "1",
        "idx": 5390
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(radius_get_vendor_attr)\n{\n\tint res;\n\tconst void *data;\n\tint len;\n\tu_int32_t vendor;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &data, &len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tres = rad_get_vendor_attr(&vendor, &data, (size_t *) &len);\n\tif (res == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\n\t\tarray_init(return_value);\n\t\tadd_assoc_long(return_value, \"attr\", res);\n\t\tadd_assoc_long(return_value, \"vendor\", vendor);\n\t\tadd_assoc_stringl(return_value, \"data\", (char *) data, len, 1);\n\t\treturn;\n\t}\n}",
        "output": "1",
        "idx": 3816
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pam_converse (int num_msg, PAM_CONVERSE_ARG2_TYPE **msg,\n  struct pam_response **resp, void *appdata_ptr)\n{\nint sep = 0;\nstruct pam_response *reply;\n\n\nif (  pam_arg_ended\n   || !(reply = malloc(sizeof(struct pam_response) * num_msg)))\n  return PAM_CONV_ERR;\n\nfor (int i = 0; i < num_msg; i++)\n  {\n  uschar *arg;\n  switch (msg[i]->msg_style)\n    {\n    case PAM_PROMPT_ECHO_ON:\n    case PAM_PROMPT_ECHO_OFF:\n      if (!(arg = string_nextinlist(&pam_args, &sep, NULL, 0)))\n\t{\n\targ = US\"\";\n\tpam_arg_ended = TRUE;\n\t}\n      reply[i].resp = CS string_copy_malloc(arg); \n      reply[i].resp_retcode = PAM_SUCCESS;\n      break;\n\n    case PAM_TEXT_INFO:    \n    case PAM_ERROR_MSG:\n      reply[i].resp_retcode = PAM_SUCCESS;\n      reply[i].resp = NULL;\n      break;\n\n    default:  \n      free(reply);\n      pam_conv_had_error = TRUE;\n      return PAM_CONV_ERR;\n    }\n  }\n\n*resp = reply;\nreturn PAM_SUCCESS;\n}",
        "output": "1",
        "idx": 6108
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "crm_recv_remote_msg(void *session, gboolean encrypted)\n{\n    char *reply = NULL;\n    xmlNode *xml = NULL;\n\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        reply = cib_recv_tls(session);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        reply = cib_recv_plaintext(GPOINTER_TO_INT(session));\n    }\n    if (reply == NULL || strlen(reply) == 0) {\n        crm_trace(\"Empty reply\");\n\n    } else {\n        xml = string2xml(reply);\n        if (xml == NULL) {\n            crm_err(\"Couldn't parse: '%.120s'\", reply);\n        }\n    }\n\n    free(reply);\n    return xml;\n}",
        "output": "1",
        "idx": 3746
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tpsf->header.ptr [psf->header.indx++] = x ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 24) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 32) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 40) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 48) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 56) ;\n} ",
        "output": "0",
        "idx": 6889
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct request *blk_mq_tag_to_rq(struct blk_mq_tags *tags, unsigned int tag)\n{\n\treturn tags->rqs[tag];\n}",
        "output": "0",
        "idx": 3997
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __exit void sctp_exit(void)\n{\n\n\tsctp_v6_del_protocol();\n\tsctp_v4_del_protocol();\n\n\tunregister_pernet_subsys(&sctp_ctrlsock_ops);\n\n\tsctp_v6_protosw_exit();\n\tsctp_v4_protosw_exit();\n\n\tunregister_pernet_subsys(&sctp_defaults_ops);\n\n\tsctp_v6_pf_exit();\n\tsctp_v4_pf_exit();\n\n\tsctp_sysctl_unregister();\n\n\tfree_pages((unsigned long)sctp_assoc_hashtable,\n\t\t   get_order(sctp_assoc_hashsize *\n\t\t\t     sizeof(struct sctp_hashbucket)));\n\tkfree(sctp_ep_hashtable);\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\n\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\n\n\trcu_barrier(); \n\n\tkmem_cache_destroy(sctp_chunk_cachep);\n\tkmem_cache_destroy(sctp_bucket_cachep);\n}",
        "output": "0",
        "idx": 4015
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xmlIsStreaming(xmlValidCtxtPtr ctxt) {\n    xmlParserCtxtPtr pctxt;\n\n    if (ctxt == NULL)\n        return(0);\n    if ((ctxt->finishDtd != XML_CTXT_FINISH_DTD_0) &&\n        (ctxt->finishDtd != XML_CTXT_FINISH_DTD_1))\n        return(0);\n    pctxt = ctxt->userData;\n    return(pctxt->parseMode == XML_PARSE_READER);\n}",
        "output": "0",
        "idx": 8857
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int lstat_cache_aware_rmdir(const char *path)\n{\n\tint ret = rmdir(path);\n\n\tif (!ret)\n\t\tinvalidate_lstat_cache();\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 7209
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_path_dotgit__dotgit_modules_symlink(void)\n{\n\tcl_assert_equal_b(true, git_path_isvalid(NULL, \".gitmodules\", 0, GIT_PATH_REJECT_DOT_GIT_HFS|GIT_PATH_REJECT_DOT_GIT_NTFS));\n\tcl_assert_equal_b(false, git_path_isvalid(NULL, \".gitmodules\", S_IFLNK, GIT_PATH_REJECT_DOT_GIT_HFS));\n\tcl_assert_equal_b(false, git_path_isvalid(NULL, \".gitmodules\", S_IFLNK, GIT_PATH_REJECT_DOT_GIT_NTFS));\n\tcl_assert_equal_b(false, git_path_isvalid(NULL, \".gitmodules . .::$DATA\", S_IFLNK, GIT_PATH_REJECT_DOT_GIT_NTFS));\n}",
        "output": "0",
        "idx": 6853
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh, int create, int flag,\n\t\t\tpgoff_t *next_pgofs)\n{\n\tstruct f2fs_map_blocks map;\n\tint err;\n\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\tmap.m_next_pgofs = next_pgofs;\n\n\terr = f2fs_map_blocks(inode, &map, create, flag);\n\tif (!err) {\n\t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\t\tbh->b_state = (bh->b_state & ~F2FS_MAP_FLAGS) | map.m_flags;\n\t\tbh->b_size = (u64)map.m_len << inode->i_blkbits;\n\t}\n\treturn err;\n}",
        "output": "0",
        "idx": 2167
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iakerb_gss_wrap_size_limit(OM_uint32 *minor_status,\n                           gss_ctx_id_t context_handle, int conf_req_flag,\n                           gss_qop_t qop_req, OM_uint32 req_output_size,\n                           OM_uint32 *max_input_size)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_wrap_size_limit(minor_status, ctx->gssc, conf_req_flag,\n                                    qop_req, req_output_size, max_input_size);\n}",
        "output": "0",
        "idx": 127
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int pmd_large(pmd_t pte)\n{\n\treturn (pmd_flags(pte) & (_PAGE_PSE | _PAGE_PRESENT)) ==\n\t\t(_PAGE_PSE | _PAGE_PRESENT);\n}",
        "output": "1",
        "idx": 780
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xfs_attr_calc_size(\n\tstruct xfs_inode \t*ip,\n\tint\t\t\tnamelen,\n\tint\t\t\tvaluelen,\n\tint\t\t\t*local)\n{\n\tstruct xfs_mount \t*mp = ip->i_mount;\n\tint\t\t\tsize;\n\tint\t\t\tnblks;\n\n\tsize = xfs_attr_leaf_newentsize(namelen, valuelen,\n\t\t\t\t\tmp->m_sb.sb_blocksize, local);\n\n\tnblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);\n\tif (*local) {\n\t\tif (size > (mp->m_sb.sb_blocksize >> 1)) {\n\t\t\tnblks *= 2;\n\t\t}\n\t} else {\n\t\tuint\tdblocks = XFS_B_TO_FSB(mp, valuelen);\n\t\tnblks += dblocks;\n\t\tnblks += XFS_NEXTENTADD_SPACE_RES(mp, dblocks, XFS_ATTR_FORK);\n\t}\n\n\treturn nblks;\n}",
        "output": "1",
        "idx": 2548
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "find_sig8_target_as_global_offset(Dwarf_Attribute attr,\n    Dwarf_Sig8  *sig8,\n    Dwarf_Bool  *is_info,\n    Dwarf_Off   *targoffset,\n    Dwarf_Error *error)\n{\n    Dwarf_Die  targdie = 0;\n    Dwarf_Bool targ_is_info = 0;\n    Dwarf_Off  localoff = 0;\n    int res = 0;\n\n    targ_is_info = attr->ar_cu_context->cc_is_info;\n    memcpy(sig8,attr->ar_debug_ptr,sizeof(*sig8));\n    res = dwarf_find_die_given_sig8(attr->ar_dbg,\n        sig8,&targdie,&targ_is_info,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    res = dwarf_die_offsets(targdie,targoffset,&localoff,error);\n    if (res != DW_DLV_OK) {\n        dwarf_dealloc_die(targdie);\n        return res;\n    }\n    *is_info = targdie->di_cu_context->cc_is_info;\n    dwarf_dealloc_die(targdie);\n    return DW_DLV_OK;\n}",
        "output": "1",
        "idx": 8946
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *bpf_obj_do_get(const struct filename *pathname,\n\t\t\t    enum bpf_type *type)\n{\n\tstruct inode *inode;\n\tstruct path path;\n\tvoid *raw;\n\tint ret;\n\n\tret = kern_path(pathname->name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tinode = d_backing_inode(path.dentry);\n\tret = inode_permission(inode, MAY_WRITE);\n\tif (ret)\n\t\tgoto out;\n\n\tret = bpf_inode_type(inode, type);\n\tif (ret)\n\t\tgoto out;\n\n\traw = bpf_any_get(inode->i_private, *type);\n\ttouch_atime(&path);\n\n\tpath_put(&path);\n\treturn raw;\nout:\n\tpath_put(&path);\n\treturn ERR_PTR(ret);\n}",
        "output": "1",
        "idx": 1242
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(DirectoryIterator, getBasename)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar *suffix = 0, *fname;\n\tint slen = 0;\n\tsize_t flen;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|s\", &suffix, &slen) == FAILURE) {\n\t\treturn;\n\t}\n\n\tphp_basename(intern->u.dir.entry.d_name, strlen(intern->u.dir.entry.d_name), suffix, slen, &fname, &flen TSRMLS_CC);\n\n\tRETURN_STRINGL(fname, flen, 0);\n}",
        "output": "1",
        "idx": 4002
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "matchCurrentInput(\n\t\tconst InString *input, int pos, const widechar *passInstructions, int passIC) {\n\tint k;\n\tint kk = pos;\n\tfor (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)\n\t\tif (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++])\n\t\t\treturn 0;\n\treturn 1;\n}",
        "output": "1",
        "idx": 7068
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(skcipher);\n\n\tif (tfm->__crt_alg->cra_type == &crypto_blkcipher_type)\n\t\treturn crypto_init_skcipher_ops_blkcipher(tfm);\n\n\tif (tfm->__crt_alg->cra_type == &crypto_ablkcipher_type ||\n\t    tfm->__crt_alg->cra_type == &crypto_givcipher_type)\n\t\treturn crypto_init_skcipher_ops_ablkcipher(tfm);\n\n\tskcipher->setkey = skcipher_setkey;\n\tskcipher->encrypt = alg->encrypt;\n\tskcipher->decrypt = alg->decrypt;\n\tskcipher->ivsize = alg->ivsize;\n\tskcipher->keysize = alg->max_keysize;\n\n\tif (alg->exit)\n\t\tskcipher->base.exit = crypto_skcipher_exit_tfm;\n\n\tif (alg->init)\n\t\treturn alg->init(skcipher);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2307
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "encodeJsonStructure(const void *src, const UA_DataType *type, CtxJson *ctx) {\n    if(ctx->depth > UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    ctx->depth++;\n\n    status ret = writeJsonObjStart(ctx);\n\n    uintptr_t ptr = (uintptr_t) src;\n    u8 membersSize = type->membersSize;\n    const UA_DataType * typelists[2] = {UA_TYPES, &type[-type->typeIndex]};\n    for(size_t i = 0; i < membersSize && ret == UA_STATUSCODE_GOOD; ++i) {\n        const UA_DataTypeMember *m = &type->members[i];\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n\n        if(m->memberName != NULL && *m->memberName != 0)\n            ret |= writeJsonKey(ctx, m->memberName);\n\n        if(!m->isArray) {\n            ptr += m->padding;\n            size_t memSize = mt->memSize;\n            ret |= encodeJsonJumpTable[mt->typeKind]((const void*) ptr, mt, ctx);\n            ptr += memSize;\n        } else {\n            ptr += m->padding;\n            const size_t length = *((const size_t*) ptr);\n            ptr += sizeof (size_t);\n            ret |= encodeJsonArray(ctx, *(void * const *)ptr, length, mt);\n            ptr += sizeof (void*);\n        }\n    }\n\n    ret |= writeJsonObjEnd(ctx);\n\n    ctx->depth--;\n    return ret;\n}",
        "output": "1",
        "idx": 8392
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int gup_huge_pmd(pmd_t orig, pmd_t *pmdp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\n\tif (!pmd_access_permitted(orig, write))\n\t\treturn 0;\n\n\tif (pmd_devmap(orig))\n\t\treturn __gup_device_huge_pmd(orig, pmdp, addr, end, pages, nr);\n\n\trefs = 0;\n\tpage = pmd_page(orig) + ((addr & ~PMD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\n\thead = try_get_compound_head(pmd_page(orig), refs);\n\tif (!head) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(pmd_val(orig) != pmd_val(*pmdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\n\tSetPageReferenced(head);\n\treturn 1;\n}",
        "output": "0",
        "idx": 4343
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int fscrypt_get_encryption_info(struct inode *inode)\n{\n\tstruct fscrypt_info *ci = inode->i_crypt_info;\n\n\tif (!ci ||\n\t\t(ci->ci_keyring_key &&\n\t\t (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t\t\t       (1 << KEY_FLAG_REVOKED) |\n\t\t\t\t\t       (1 << KEY_FLAG_DEAD)))))\n\t\treturn fscrypt_get_crypt_info(inode);\n\treturn 0;\n}",
        "output": "1",
        "idx": 1530
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int install_process_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tret = install_process_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret != -EEXIST ? ret : 0;\n\t}\n\n\treturn commit_creds(new);\n}",
        "output": "1",
        "idx": 1558
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_get_cfgdata32(struct pci_vdev *dev, int offset)\n{\n\tassert(offset <= (PCI_REGMAX - 3) && (offset & 3) == 0);\n\treturn (*(uint32_t *)(dev->cfgdata + offset));\n}",
        "output": "1",
        "idx": 7620
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\tstruct xfrm_dump_info info;\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\n\treturn skb->len;\n}",
        "output": "0",
        "idx": 2531
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int install_thread_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->thread_keyring)\n\t\treturn 0;\n\n\tkeyring = keyring_alloc(\"_tid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->thread_keyring = keyring;\n\treturn 0;\n}",
        "output": "0",
        "idx": 2249
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tcdef->ents = 0;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 7623
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void array_cleanup( char* arr[] , int arr_size)\n{\n\tint i=0;\n\tfor( i=0; i< arr_size; i++ ){\n\t\tif( arr[i*2] ){\n\t\t\tefree( arr[i*2]);\n\t\t}\n\t}\n\tefree(arr);\n}",
        "output": "0",
        "idx": 5435
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void gtkui_conf_read(void) {\n   FILE *fd;\n   const char *path;\n   char line[100], name[30];\n   short value;\n\n#ifdef OS_WINDOWS\n   path = ec_win_get_user_dir();\n#else\n   path = g_get_tmp_dir();\n#endif\n\n   filename = g_build_filename(path, \".ettercap_gtk\", NULL);\n\n   DEBUG_MSG(\"gtkui_conf_read: %s\", filename);\n\n   fd = fopen(filename, \"r\");\n   if(!fd) \n      return;\n\n   while(fgets(line, 100, fd)) {\n      sscanf(line, \"%s = %hd\", name, &value);\n\n      gtkui_conf_set(name, value);\n   }\n   fclose(fd);\n}",
        "output": "1",
        "idx": 3372
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nlmclnt_unlock_callback(struct rpc_task *task, void *data)\n{\n\tstruct nlm_rqst\t*req = data;\n\tu32 status = ntohl(req->a_res.status);\n\n\tif (RPC_ASSASSINATED(task))\n\t\tgoto die;\n\n\tif (task->tk_status < 0) {\n\t\tdprintk(\"lockd: unlock failed (err = %d)\\n\", -task->tk_status);\n\t\tgoto retry_rebind;\n\t}\n\tif (status == NLM_LCK_DENIED_GRACE_PERIOD) {\n\t\trpc_delay(task, NLMCLNT_GRACE_WAIT);\n\t\tgoto retry_unlock;\n\t}\n\tif (status != NLM_LCK_GRANTED)\n\t\tprintk(KERN_WARNING \"lockd: unexpected unlock status: %d\\n\", status);\ndie:\n\treturn;\n retry_rebind:\n\tnlm_rebind_host(req->a_host);\n retry_unlock:\n\trpc_restart_call(task);\n}",
        "output": "1",
        "idx": 406
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n{\n\tif (sta_id >= IWLAGN_STATION_COUNT) {\n\t\tIWL_ERR(priv, \"invalid sta_id %u\", sta_id);\n\t\treturn -EINVAL;\n\t}\n\tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\n\t\tIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n\t\t\t\"addr %pM\\n\",\n\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {\n\t\tIWL_DEBUG_ASSOC(priv,\n\t\t\t\t\"STA id %u addr %pM already present in uCode \"\n\t\t\t\t\"(according to driver)\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t} else {\n\t\tpriv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;\n\t\tIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 873
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool tailmatch(const char *cooke_domain, const char *hostname)\n{\n  size_t cookie_domain_len = strlen(cooke_domain);\n  size_t hostname_len = strlen(hostname);\n\n  if(hostname_len < cookie_domain_len)\n    return FALSE;\n\n  if(!Curl_raw_equal(cooke_domain, hostname+hostname_len-cookie_domain_len))\n    return FALSE;\n\n  if(hostname_len == cookie_domain_len)\n    return TRUE;\n  if('.' == *(hostname + hostname_len - cookie_domain_len - 1))\n    return TRUE;\n  return FALSE;\n}",
        "output": "0",
        "idx": 5025
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "usage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-P pkcs11_whitelist] [-t life] [command [arg ...]]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}",
        "output": "0",
        "idx": 7791
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* serial)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_NORMAL);\n        if (card->serialnr.len)   {\n                *serial = card->serialnr;\n                SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n        }\n\tif (priv->cac_id_len) {\n\t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);\n}",
        "output": "1",
        "idx": 7012
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void update_open_stateflags(struct nfs4_state *state, mode_t open_flags)\n{\n\tswitch (open_flags) {\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr++;\n\t}\n\tnfs4_state_set_mode_locked(state, state->state | open_flags);\n}",
        "output": "1",
        "idx": 2158
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}",
        "output": "1",
        "idx": 6746
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_export_sec_context(\n\t\t\t    OM_uint32\t  *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t interprocess_token)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = *(spnego_gss_ctx_id_t *)context_handle;\n\n\tif (!sc->opened)\n\t\treturn GSS_S_UNAVAILABLE;\n\n\tret = gss_export_sec_context(minor_status,\n\t\t\t\t    &sc->ctx_handle,\n\t\t\t\t    interprocess_token);\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT) {\n\t\trelease_spnego_ctx(&sc);\n\t\t*context_handle = GSS_C_NO_CONTEXT;\n\t}\n\treturn (ret);\n}",
        "output": "0",
        "idx": 105
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536 || item_num < 0) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    if (mxf->local_tags)\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple primer packs\\n\");\n    av_free(mxf->local_tags);\n    mxf->local_tags_count = 0;\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}",
        "output": "0",
        "idx": 4911
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int AES_encrypt_DH(char *message, uint8_t *encr_message, uint64_t encrLen) {\n\n    if (!message) {\n        LOG_ERROR(\"Null message in AES_encrypt_DH\");\n        return -1;\n    }\n\n    if (!encr_message) {\n        LOG_ERROR(\"Null encr message in AES_encrypt_DH\");\n        return -2;\n    }\n\n    uint64_t len = strlen(message) + 1;\n\n    if (len + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE > encrLen ) {\n        LOG_ERROR(\"Output buffer too small\");\n        return -3;\n    }\n\n    sgx_read_rand(encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE);\n\n    sgx_status_t status = sgx_rijndael128GCM_encrypt(&AES_DH_key, (uint8_t*)message, strlen(message),\n                                                     encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE,\n                                                     encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,\n                                                     NULL, 0,\n                                                     (sgx_aes_gcm_128bit_tag_t *) encr_message);\n\n    return status;\n}",
        "output": "1",
        "idx": 8696
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_event_for_each_child(struct perf_event *event,\n\t\t\t\t\tvoid (*func)(struct perf_event *))\n{\n\tstruct perf_event *child;\n\n\tWARN_ON_ONCE(event->ctx->parent_ctx);\n\n\tmutex_lock(&event->child_mutex);\n\tfunc(event);\n\tlist_for_each_entry(child, &event->child_list, child_list)\n\t\tfunc(child);\n\tmutex_unlock(&event->child_mutex);\n}",
        "output": "0",
        "idx": 3845
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct r_bin_pe_addr_t *PE_(check_unknow)(RBinPEObj *pe) {\n\tstruct r_bin_pe_addr_t *entry;\n\tif (!pe || !pe->b) {\n\t\treturn 0LL;\n\t}\n\tut8 b[512];\n\tZERO_FILL (b);\n\tentry = PE_ (r_bin_pe_get_entrypoint) (pe);\n\tif (r_buf_read_at (pe->b, entry->paddr, b, 512) < 1) {\n\t\tpe_printf (\"Warning: Cannot read entry at 0x%08\"PFMT64x\"\\n\", entry->paddr);\n\t\tfree (entry);\n\t\treturn NULL;\n\t}\n\tif (b[367] == 0xe8) {\n\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 367);\n\t\treturn entry;\n\t}\n\tsize_t i;\n\tfor (i = 0; i < 512 - 16 ; i++) {\n\t\tif (!memcmp (b + i, \"\\xff\\x15\", 2)) {\n\t\t\tif (b[i + 6] == 0x50) {\n\t\t\t\tif (b[i + 7] == 0xe8) {\n\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, i + 7);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfree (entry);\n\treturn NULL;\n}",
        "output": "1",
        "idx": 6474
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct fsnotify_group *inotify_new_group(struct user_struct *user, unsigned int max_events)\n{\n\tstruct fsnotify_group *group;\n\n\tgroup = fsnotify_alloc_group(&inotify_fsnotify_ops);\n\tif (IS_ERR(group))\n\t\treturn group;\n\n\tgroup->max_events = max_events;\n\n\tspin_lock_init(&group->inotify_data.idr_lock);\n\tidr_init(&group->inotify_data.idr);\n\tgroup->inotify_data.last_wd = 0;\n\tgroup->inotify_data.user = user;\n\tgroup->inotify_data.fa = NULL;\n\n\treturn group;\n}",
        "output": "1",
        "idx": 292
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_siocgstamp(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timeval ktv;\n\tint err;\n\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);\n\tset_fs(old_fs);\n\tif (!err)\n\t\terr = compat_put_timeval(up, &ktv);\n\n\treturn err;\n}",
        "output": "1",
        "idx": 760
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_lintr_route(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct intxinfo *ii;\n\n\tif (dev->lintr.pin == 0)\n\t\treturn;\n\n\tbi = pci_businfo[dev->bus];\n\tassert(bi != NULL);\n\tii = &bi->slotinfo[dev->slot].si_intpins[dev->lintr.pin - 1];\n\n\tif (ii->ii_ioapic_irq == 0)\n\t\tii->ii_ioapic_irq = ioapic_pci_alloc_irq(dev);\n\tassert(ii->ii_ioapic_irq > 0);\n\n\tif (ii->ii_pirq_pin == 0)\n\t\tii->ii_pirq_pin = pirq_alloc_pin(dev);\n\tassert(ii->ii_pirq_pin > 0);\n\n\tdev->lintr.ioapic_irq = ii->ii_ioapic_irq;\n\tdev->lintr.pirq_pin = ii->ii_pirq_pin;\n\tpci_set_cfgdata8(dev, PCIR_INTLINE, pirq_irq(ii->ii_pirq_pin));\n}",
        "output": "1",
        "idx": 7612
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint32_t virtio_config_readb(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return (uint32_t)-1;\n    }\n\n    k->get_config(vdev, vdev->config);\n\n    val = ldub_p(vdev->config + addr);\n    return val;\n}",
        "output": "0",
        "idx": 5297
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"givcipher\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t alg->cra_ablkcipher.geniv ?: \"<built-in>\");\n\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "1",
        "idx": 842
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cJSON_Delete( cJSON *c )\n{\n\tcJSON *next;\n\n\twhile ( c ) {\n\t\tnext = c->next;\n\t\tif ( ! ( c->type & cJSON_IsReference ) && c->child )\n\t\t\tcJSON_Delete( c->child );\n\t\tif ( ! ( c->type & cJSON_IsReference ) && c->valuestring )\n\t\t\tcJSON_free( c->valuestring );\n\t\tif ( c->string )\n\t\t\tcJSON_free( c->string );\n\t\tcJSON_free( c );\n\t\tc = next;\n\t}\n}",
        "output": "1",
        "idx": 5878
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ssh_packet_set_compress_hooks(struct ssh *ssh, void *ctx,\n    void *(*allocfunc)(void *, u_int, u_int),\n    void (*freefunc)(void *, void *))\n{\n\tssh->state->compression_out_stream.zalloc = (alloc_func)allocfunc;\n\tssh->state->compression_out_stream.zfree = (free_func)freefunc;\n\tssh->state->compression_out_stream.opaque = ctx;\n\tssh->state->compression_in_stream.zalloc = (alloc_func)allocfunc;\n\tssh->state->compression_in_stream.zfree = (free_func)freefunc;\n\tssh->state->compression_in_stream.opaque = ctx;\n}",
        "output": "1",
        "idx": 5580
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int checkout_verify_paths(\n\tgit_repository *repo,\n\tint action,\n\tgit_diff_delta *delta)\n{\n\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\n\tif (action & CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot remove invalid path '%s'\", delta->old_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (action & ~CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->new_file.path, delta->new_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot checkout to invalid path '%s'\", delta->new_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 4886
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "atol10(const char *p, size_t char_cnt)\n{\n\tuint64_t l;\n\tint digit;\n\n\tif (char_cnt == 0)\n\t\treturn (0);\n\n\tl = 0;\n\tdigit = *p - '0';\n\twhile (digit >= 0 && digit < 10  && char_cnt-- > 0) {\n\t\tl = (l * 10) + digit;\n\t\tdigit = *++p - '0';\n\t}\n\treturn (l);\n}",
        "output": "0",
        "idx": 5133
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int snmp_helper(void *context, size_t hdrlen, unsigned char tag,\n\t\tconst void *data, size_t datalen)\n{\n\tstruct snmp_ctx *ctx = (struct snmp_ctx *)context;\n\t__be32 *pdata = (__be32 *)data;\n\n\tif (*pdata == ctx->from) {\n\t\tpr_debug(\"%s: %pI4 to %pI4\\n\", __func__,\n\t\t\t (void *)&ctx->from, (void *)&ctx->to);\n\n\t\tif (*ctx->check)\n\t\t\tfast_csum(ctx, (unsigned char *)data - ctx->begin);\n\t\t*pdata = ctx->to;\n\t}\n\n\treturn 1;\n}",
        "output": "1",
        "idx": 3078
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sctp_generate_timeout_event(struct sctp_association *asoc,\n\t\t\t\t\tsctp_event_timeout_t timeout_type)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\tint error = 0;\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk)) {\n\t\tpr_debug(\"%s: sock is busy: timer %d\\n\", __func__,\n\t\t\t timeout_type);\n\n\t\tif (!mod_timer(&asoc->timers[timeout_type], jiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(timeout_type),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   (void *)timeout_type, GFP_ATOMIC);\n\n\tif (error)\n\t\tsk->sk_err = -error;\n\nout_unlock:\n\tbh_unlock_sock(sk);\n\tsctp_association_put(asoc);\n}",
        "output": "0",
        "idx": 4031
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void take_dentry_name_snapshot(struct name_snapshot *name, struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tif (unlikely(dname_external(dentry))) {\n\t\tstruct external_name *p = external_name(dentry);\n\t\tatomic_inc(&p->u.count);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tname->name = p->name;\n\t} else {\n\t\tmemcpy(name->inline_name, dentry->d_iname, DNAME_INLINE_LEN);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tname->name = name->inline_name;\n\t}\n}",
        "output": "0",
        "idx": 2345
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct rt6_info *rt = res->rt6;\n\tstruct net_device *dev = NULL;\n\n\tif (!rt)\n\t\treturn false;\n\n\tif (rt->rt6i_idev)\n\t\tdev = rt->rt6i_idev->dev;\n\n\tif (rt->rt6i_dst.plen <= rule->suppress_prefixlen)\n\t\tgoto suppress_route;\n\n\tif (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)\n\t\tgoto suppress_route;\n\n\treturn false;\n\nsuppress_route:\n\tif (!(arg->flags & FIB_LOOKUP_NOREF))\n\t\tip6_rt_put(rt);\n\treturn true;\n}",
        "output": "0",
        "idx": 4487
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Map1to1(SDL_Palette * src, SDL_Palette * dst, int *identical)\n{\n    Uint8 *map;\n    int i;\n\n    if (identical) {\n        if (src->ncolors <= dst->ncolors) {\n            if (src == dst\n                ||\n                (SDL_memcmp\n                 (src->colors, dst->colors,\n                  src->ncolors * sizeof(SDL_Color)) == 0)) {\n                *identical = 1;\n                return (NULL);\n            }\n        }\n        *identical = 0;\n    }\n    map = (Uint8 *) SDL_malloc(src->ncolors);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < src->ncolors; ++i) {\n        map[i] = SDL_FindColor(dst,\n                               src->colors[i].r, src->colors[i].g,\n                               src->colors[i].b, src->colors[i].a);\n    }\n    return (map);\n}",
        "output": "1",
        "idx": 8690
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ptrace_triggered(struct perf_event *bp, int nmi,\n\t\t      struct perf_sample_data *data, struct pt_regs *regs)\n{\n\tstruct perf_event_attr attr;\n\n\tattr = bp->attr;\n\tattr.disabled = true;\n\tmodify_user_hw_breakpoint(bp, &attr);\n}",
        "output": "1",
        "idx": 450
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(GlobIterator, count)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (php_stream_is(intern->u.dir.dirp ,&php_glob_stream_ops)) {\n\t\tRETURN_LONG(php_glob_stream_get_count(intern->u.dir.dirp, NULL));\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"GlobIterator lost glob state\");\n\t}\n}",
        "output": "1",
        "idx": 3926
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, seek)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tlong line_pos;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &line_pos) == FAILURE) {\n\t\treturn;\n\t}\n\tif (line_pos < 0) {\n\t\tzend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, \"Can't seek file %s to negative line %ld\", intern->file_name, line_pos);\n\t\tRETURN_FALSE;\n\t}\n\n\tspl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);\n\n\twhile(intern->u.file.current_line_num < line_pos) {\n\t\tif (spl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC) == FAILURE) {\n\t\t\tbreak;\n\t\t}\n\t}\n} ",
        "output": "0",
        "idx": 5521
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void inotify_free_group_priv(struct fsnotify_group *group)\n{\n\tidr_for_each(&group->inotify_data.idr, idr_callback, group);\n\tidr_remove_all(&group->inotify_data.idr);\n\tidr_destroy(&group->inotify_data.idr);\n\tatomic_dec(&group->inotify_data.user->inotify_devs);\n\tfree_uid(group->inotify_data.user);\n}",
        "output": "0",
        "idx": 427
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init net_secret_init(void)\n{\n\tget_random_bytes(net_secret, sizeof(net_secret));\n\treturn 0;\n}",
        "output": "0",
        "idx": 779
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *command_init(struct pci_dev *dev, int offset)\n{\n\tstruct pci_cmd_info *cmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tint err;\n\n\tif (!cmd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = pci_read_config_word(dev, PCI_COMMAND, &cmd->val);\n\tif (err) {\n\t\tkfree(cmd);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn cmd;\n}",
        "output": "0",
        "idx": 3881
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "f_mzeval(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n\n    if (check_restricted() || check_secure())\n\treturn;\n    str = tv_get_string_buf(&argvars[0], buf);\n    do_mzeval(str, rettv);\n}",
        "output": "0",
        "idx": 8173
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int check_sticky(struct inode *dir, struct inode *inode)\n{\n\tkuid_t fsuid = current_fsuid();\n\n\tif (!(dir->i_mode & S_ISVTX))\n\t\treturn 0;\n\tif (uid_eq(inode->i_uid, fsuid))\n\t\treturn 0;\n\tif (uid_eq(dir->i_uid, fsuid))\n\t\treturn 0;\n\treturn !capable_wrt_inode_uidgid(inode, CAP_FOWNER);\n}",
        "output": "0",
        "idx": 3559
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void sctp_generate_t3_rtx_event(unsigned long peer)\n{\n\tint error;\n\tstruct sctp_transport *transport = (struct sctp_transport *) peer;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\n\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\n\t\tif (!mod_timer(&transport->T3_rtx_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_T3_RTX),\n\t\t\t   asoc->state,\n\t\t\t   asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\n\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_transport_put(transport);\n}",
        "output": "1",
        "idx": 2918
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ga_init2(garray_T *gap, size_t itemsize, int growsize)\n{\n    ga_init(gap);\n    gap->ga_itemsize = itemsize;\n    gap->ga_growsize = growsize;\n}",
        "output": "0",
        "idx": 7939
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "decode_sequence_of(const uint8_t *asn1, size_t len,\n                   const struct atype_info *elemtype, void **seq_out,\n                   size_t *count_out)\n{\n    krb5_error_code ret;\n    void *seq = NULL, *elem, *newseq;\n    const uint8_t *contents;\n    size_t clen, count = 0;\n    taginfo t;\n\n    *seq_out = NULL;\n    *count_out = 0;\n    while (len > 0) {\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        if (!check_atype_tag(elemtype, &t)) {\n            ret = ASN1_BAD_ID;\n            goto error;\n        }\n        newseq = realloc(seq, (count + 1) * elemtype->size);\n        if (newseq == NULL) {\n            ret = ENOMEM;\n            goto error;\n        }\n        seq = newseq;\n        elem = (char *)seq + count * elemtype->size;\n        memset(elem, 0, elemtype->size);\n        ret = decode_atype(&t, contents, clen, elemtype, elem);\n        if (ret)\n            goto error;\n        count++;\n    }\n    *seq_out = seq;\n    *count_out = count;\n    return 0;\n\nerror:\n    free_sequence_of(elemtype, seq, count);\n    free(seq);\n    return ret;\n}",
        "output": "1",
        "idx": 206
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "do_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap __attribute__((__unused__)), uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags)\n{\n\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n\t    type == NT_GNU_BUILD_ID && (descsz >= 4 || descsz <= 20)) {\n\t\tuint8_t desc[20];\n\t\tconst char *btype;\n\t\tuint32_t i;\n\t\t*flags |= FLAGS_DID_BUILD_ID;\n\t\tswitch (descsz) {\n\t\tcase 8:\n\t\t    btype = \"xxHash\";\n\t\t    break;\n\t\tcase 16:\n\t\t    btype = \"md5/uuid\";\n\t\t    break;\n\t\tcase 20:\n\t\t    btype = \"sha1\";\n\t\t    break;\n\t\tdefault:\n\t\t    btype = \"unknown\";\n\t\t    break;\n\t\t}\n\t\tif (file_printf(ms, \", BuildID[%s]=\", btype) == -1)\n\t\t\treturn 1;\n\t\t(void)memcpy(desc, &nbuf[doff], descsz);\n\t\tfor (i = 0; i < descsz; i++)\n\t\t    if (file_printf(ms, \"%02x\", desc[i]) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 4390
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int save_dev(blkid_dev dev, FILE *file)\n{\n\tstruct list_head *p;\n\n\tif (!dev || dev->bid_name[0] != '/')\n\t\treturn 0;\n\n\tDBG(SAVE, ul_debug(\"device %s, type %s\", dev->bid_name, dev->bid_type ?\n\t\t   dev->bid_type : \"(null)\"));\n\n\tfprintf(file, \"<device DEVNO=\\\"0x%04lx\\\" TIME=\\\"%ld.%ld\\\"\",\n\t\t\t(unsigned long) dev->bid_devno,\n\t\t\t(long) dev->bid_time,\n\t\t\t(long) dev->bid_utime);\n\n\tif (dev->bid_pri)\n\t\tfprintf(file, \" PRI=\\\"%d\\\"\", dev->bid_pri);\n\n\tlist_for_each(p, &dev->bid_tags) {\n\t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);\n\n\t\tfputc(' ', file);\t\t\t\n\t\tfputs(tag->bit_name, file);\t\t\n\t\tfputc('=', file);\t\t\t\n\t\tsave_quoted(tag->bit_val, file);\t\n\t}\n\tfprintf(file, \">%s</device>\\n\", dev->bid_name);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 6501
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int raw_cmd_copyout(int cmd, void __user *param,\n\t\t\t\t  struct floppy_raw_cmd *ptr)\n{\n\tint ret;\n\n\twhile (ptr) {\n\t\tret = copy_to_user(param, ptr, sizeof(*ptr));\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tparam += sizeof(struct floppy_raw_cmd);\n\t\tif ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {\n\t\t\tif (ptr->length >= 0 &&\n\t\t\t    ptr->length <= ptr->buffer_length) {\n\t\t\t\tlong length = ptr->buffer_length - ptr->length;\n\t\t\t\tret = fd_copyout(ptr->data, ptr->kernel_data,\n\t\t\t\t\t\t length);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 2546
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, const nfs4_stateid *deleg_stateid, int open_flags)\n{\n\twrite_seqlock(&state->seqlock);\n\tif (deleg_stateid != NULL) {\n\t\tmemcpy(state->stateid.data, deleg_stateid->data, sizeof(state->stateid.data));\n\t\tset_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n\tif (open_stateid != NULL)\n\t\tnfs_set_open_stateid_locked(state, open_stateid, open_flags);\n\twrite_sequnlock(&state->seqlock);\n\tspin_lock(&state->owner->so_lock);\n\tupdate_open_stateflags(state, open_flags);\n\tspin_unlock(&state->owner->so_lock);\n}",
        "output": "1",
        "idx": 2118
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xfrm6_tunnel_rcv(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\t__be32 spi;\n\n\tspi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);\n\treturn xfrm6_rcv_spi(skb, spi) > 0 ? : 0;\n}",
        "output": "0",
        "idx": 2987
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool is_noncanonical_address(u64 la)\n{\n#ifdef CONFIG_X86_64\n\treturn get_canonical(la) != la;\n#else\n\treturn false;\n#endif\n}",
        "output": "0",
        "idx": 3725
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {\n\tRASN1Object *object;\n\tRCMS *container;\n\tif (!buffer || !length) {\n\t\treturn NULL;\n\t}\n\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n\t\treturn NULL;\n\t}\n\tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects ||\n\t\t!object->list.objects[0] || !object->list.objects[1] ||\n\t\tobject->list.objects[1]->list.length != 1) {\n\t\tr_asn1_free_object (object);\n\t\tfree (container);\n\t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tr_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);\n\tr_asn1_free_object (object);\n\treturn container;\n}",
        "output": "0",
        "idx": 8621
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcf_poll *nfcf_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcf_poll->bit_rate = *data++;\n\tnfcf_poll->sensf_res_len = *data++;\n\n\tpr_debug(\"bit_rate %d, sensf_res_len %d\\n\",\n\t\t nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);\n\n\tmemcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);\n\tdata += nfcf_poll->sensf_res_len;\n\n\treturn data;\n}",
        "output": "1",
        "idx": 730
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct xt_table_info *xt_alloc_table_info(unsigned int size)\n{\n\tstruct xt_table_info *info = NULL;\n\tsize_t sz = sizeof(*info) + size;\n\n\tif (sz < sizeof(*info))\n\t\treturn NULL;\n\n\tif ((SMP_ALIGN(size) >> PAGE_SHIFT) + 2 > totalram_pages)\n\t\treturn NULL;\n\n\tif (sz <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER))\n\t\tinfo = kmalloc(sz, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (!info) {\n\t\tinfo = vmalloc(sz);\n\t\tif (!info)\n\t\t\treturn NULL;\n\t}\n\tmemset(info, 0, sizeof(*info));\n\tinfo->size = size;\n\treturn info;\n}",
        "output": "0",
        "idx": 1699
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int asymmetric_key_match(const struct key *key,\n\t\t\t\tconst struct key_match_data *match_data)\n{\n\tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n\tconst char *description = match_data->raw_data;\n\tconst char *spec = description;\n\tconst char *id;\n\tptrdiff_t speclen;\n\n\tif (!subtype || !spec || !*spec)\n\t\treturn 0;\n\n\tif (key->description && strcmp(key->description, description) == 0)\n\t\treturn 1;\n\n\tid = strchr(spec, ':');\n\tif (!id)\n\t\treturn 0;\n\n\tspeclen = id - spec;\n\tid++;\n\n\tif (speclen == 2 && memcmp(spec, \"id\", 2) == 0)\n\t\treturn asymmetric_keyid_match(asymmetric_key_id(key), id);\n\n\tif (speclen == subtype->name_len &&\n\t    memcmp(spec, subtype->name, speclen) == 0)\n\t\treturn 1;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 2670
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vgacon_scrollback_update(struct vc_data *c, int t, int count)\n{\n\tvoid *p;\n\n\tif (!vgacon_scrollback_cur->data || !vgacon_scrollback_cur->size ||\n\t    c->vc_num != fg_console)\n\t\treturn;\n\n\tp = (void *) (c->vc_origin + t * c->vc_size_row);\n\n\twhile (count--) {\n\t\tif ((vgacon_scrollback_cur->tail + c->vc_size_row) >\n\t\t    vgacon_scrollback_cur->size)\n\t\t\tvgacon_scrollback_cur->tail = 0;\n\n\t\tscr_memcpyw(vgacon_scrollback_cur->data +\n\t\t\t    vgacon_scrollback_cur->tail,\n\t\t\t    p, c->vc_size_row);\n\n\t\tvgacon_scrollback_cur->cnt++;\n\t\tp += c->vc_size_row;\n\t\tvgacon_scrollback_cur->tail += c->vc_size_row;\n\n\t\tif (vgacon_scrollback_cur->tail >= vgacon_scrollback_cur->size)\n\t\t\tvgacon_scrollback_cur->tail = 0;\n\n\t\tif (vgacon_scrollback_cur->cnt > vgacon_scrollback_cur->rows)\n\t\t\tvgacon_scrollback_cur->cnt = vgacon_scrollback_cur->rows;\n\n\t\tvgacon_scrollback_cur->cur = vgacon_scrollback_cur->cnt;\n\t}\n}",
        "output": "1",
        "idx": 1878
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,\n\t\t     rpmpsm psm, int nodigest, int *setmeta,\n\t\t     int * firsthardlink)\n{\n    int rc = 0;\n    int numHardlinks = rpmfiFNlink(fi);\n\n    if (numHardlinks > 1) {\n\tif (*firsthardlink < 0) {\n\t    *firsthardlink = rpmfiFX(fi);\n\t    rc = expandRegular(fi, dest, psm, nodigest, 1);\n\t} else {\n\t    char *fn = rpmfilesFN(files, *firsthardlink);\n\t    rc = link(fn, dest);\n\t    if (rc < 0) {\n\t\trc = RPMERR_LINK_FAILED;\n\t    }\n\t    free(fn);\n\t}\n    }\n    if (numHardlinks<=1) {\n\tif (!rc)\n\t    rc = expandRegular(fi, dest, psm, nodigest, 0);\n    } else if (rpmfiArchiveHasContent(fi)) {\n\tif (!rc)\n\t    rc = expandRegular(fi, dest, psm, nodigest, 0);\n\t*firsthardlink = -1;\n    } else {\n\t*setmeta = 0;\n    }\n\n    return rc;\n}",
        "output": "1",
        "idx": 6618
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "log2vis_unicode (PyObject * unicode, FriBidiParType base_direction, int clean, int reordernsm)\n{\n\tPyObject *logical = NULL;\t\n\tPyObject *visual = NULL;\t\n\tPyObject *result = NULL;\t\n\n\tint length = PyUnicode_GET_SIZE (unicode);\n\n\tlogical = PyUnicode_AsUTF8String (unicode);\n\tif (logical == NULL)\n\t\tgoto cleanup;\n\n\tvisual = log2vis_utf8 (logical, length, base_direction, clean, reordernsm);\n\tif (visual == NULL)\n\t\tgoto cleanup;\n\n\tresult = PyUnicode_DecodeUTF8 (PyString_AS_STRING (visual),\n\t\t\t\t       PyString_GET_SIZE (visual), \"strict\");\n\n      cleanup:\n\tPy_XDECREF (logical);\n\tPy_XDECREF (visual);\n\n\treturn result;\n}",
        "output": "1",
        "idx": 3612
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init big_key_init(void)\n{\n\treturn register_key_type(&key_type_big_key);\n}",
        "output": "1",
        "idx": 1352
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,\n\t\t\t       struct scm_cookie *scm)\n{\n\tmemset(scm, 0, sizeof(*scm));\n\tunix_get_peersec_dgram(sock, scm);\n\tif (msg->msg_controllen <= 0)\n\t\treturn 0;\n\treturn __scm_send(sock, msg, scm);\n}",
        "output": "1",
        "idx": 750
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int getSingletonPos(const char* str)\n{\n\tint result =-1;\n\tint i=0;\n\tint len = 0;\n\n\tif( str && ((len=strlen(str))>0) ){\n\t\tfor( i=0; i<len ; i++){\n\t\t\tif( isIDSeparator(*(str+i)) ){\n\t\t\t\tif( i==1){\n\t\t\t\t\tresult =0;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tif( isIDSeparator(*(str+i+2)) ){\n\t\t\t\t\t\tresult = i+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\treturn result;\n}",
        "output": "0",
        "idx": 5411
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "destroyPresentationContextList(LST_HEAD ** lst)\n{\n    DUL_PRESENTATIONCONTEXT *pc;\n    DUL_TRANSFERSYNTAX *ts;\n\n    if ((lst == NULL) || (*lst == NULL))\n        return;\n    while ((pc = (DUL_PRESENTATIONCONTEXT*) LST_Dequeue(lst)) != NULL) {\n        if (pc->proposedTransferSyntax != NULL) {\n            while ((ts = (DUL_TRANSFERSYNTAX*) LST_Dequeue(&pc->proposedTransferSyntax)) != NULL) {\n                free(ts);\n            }\n            LST_Destroy(&pc->proposedTransferSyntax);\n        }\n        free(pc);\n    }\n    LST_Destroy(lst);\n}",
        "output": "1",
        "idx": 8834
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct mapped_device *dm_get_from_kobject(struct kobject *kobj)\n{\n\tstruct mapped_device *md;\n\n\tmd = container_of(kobj, struct mapped_device, kobj_holder.kobj);\n\n\tspin_lock(&_minor_lock);\n\tif (test_bit(DMF_FREEING, &md->flags) || dm_deleting_md(md)) {\n\t\tmd = NULL;\n\t\tgoto out;\n\t}\n\tdm_get(md);\nout:\n\tspin_unlock(&_minor_lock);\n\n\treturn md;\n}",
        "output": "0",
        "idx": 2541
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,\n\t\t\tstruct sock *sk)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\n\tev->type   = LLC_SAP_EV_TYPE_PDU;\n\tev->reason = 0;\n\tskb_orphan(skb);\n\tsock_hold(sk);\n\tskb->sk = sk;\n\tskb->destructor = sock_efree;\n\tllc_sap_state_process(sap, skb);\n}",
        "output": "0",
        "idx": 2155
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __kvm_migrate_pit_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pit *pit = vcpu->kvm->arch.vpit;\n\tstruct hrtimer *timer;\n\n\tif (!kvm_vcpu_is_bsp(vcpu) || !pit)\n\t\treturn;\n\n\ttimer = &pit->pit_state.timer;\n\tmutex_lock(&pit->pit_state.lock);\n\tif (hrtimer_cancel(timer))\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n\tmutex_unlock(&pit->pit_state.lock);\n}",
        "output": "0",
        "idx": 3735
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n\t\t      gss_ctx_id_t context_handle,\n\t\t      int *conf_state,\n\t\t      gss_qop_t *qop_state,\n\t\t      gss_iov_buffer_desc *iov,\n\t\t      int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_iov(minor_status,\n\t\t\t     context_handle,\n\t\t\t     conf_state,\n\t\t\t     qop_state,\n\t\t\t     iov,\n\t\t\t     iov_count);\n\treturn (ret);\n}",
        "output": "1",
        "idx": 98
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void async_polkit_query_free(AsyncPolkitQuery *q) {\n\n        if (!q)\n                return;\n\n        sd_bus_slot_unref(q->slot);\n\n        if (q->registry && q->request)\n                hashmap_remove(q->registry, q->request);\n\n        sd_bus_message_unref(q->request);\n        sd_bus_message_unref(q->reply);\n\n        free(q->action);\n        strv_free(q->details);\n\n        free(q);\n}",
        "output": "1",
        "idx": 5490
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileInfo, setFileClass)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_class_entry *ce = spl_ce_SplFileObject;\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n\t\tintern->file_class = ce;\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}",
        "output": "0",
        "idx": 5529
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "AcpiNsTerminate (\n    void)\n{\n    ACPI_STATUS             Status;\n\n\n    ACPI_FUNCTION_TRACE (NsTerminate);\n\n\n#ifdef ACPI_EXEC_APP\n    {\n        ACPI_OPERAND_OBJECT     *Prev;\n        ACPI_OPERAND_OBJECT     *Next;\n\n\n        Next = AcpiGbl_ModuleCodeList;\n        while (Next)\n        {\n            Prev = Next;\n            Next = Next->Method.Mutex;\n            Prev->Method.Mutex = NULL; \n            AcpiUtRemoveReference (Prev);\n        }\n    }\n#endif\n\n    AcpiNsDeleteNamespaceSubtree (AcpiGbl_RootNode);\n\n\n    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);\n    if (ACPI_FAILURE (Status))\n    {\n        return_VOID;\n    }\n\n    AcpiNsDeleteNode (AcpiGbl_RootNode);\n    (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);\n\n    ACPI_DEBUG_PRINT ((ACPI_DB_INFO, \"Namespace freed\\n\"));\n    return_VOID;\n}",
        "output": "1",
        "idx": 6224
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *create_output_name(char *fname) {\n    char *out, *p;\n    if ((out = malloc(strlen(fname) + 1))) {\n        while (*fname == '/' || *fname == '\\\\') fname++;\n        strcpy(out, (*fname) ? fname : \"x\");\n\n        for (p = out; *p; p++) {\n            if (p[0] == '.' && p[1] == '.' && (p[2] == '/' || p[2] == '\\\\')) {\n               p[0] = p[1] = 'x';\n            }\n        }\n    }\n    return out;\n}",
        "output": "0",
        "idx": 7417
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE1(inotify_init1, int, flags)\n{\n\tstruct fsnotify_group *group;\n\tint ret;\n\n\tBUILD_BUG_ON(IN_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(IN_NONBLOCK != O_NONBLOCK);\n\n\tif (flags & ~(IN_CLOEXEC | IN_NONBLOCK))\n\t\treturn -EINVAL;\n\n\tgroup = inotify_new_group(inotify_max_queued_events);\n\tif (IS_ERR(group))\n\t\treturn PTR_ERR(group);\n\n\tret = anon_inode_getfd(\"inotify\", &inotify_fops, group,\n\t\t\t\t  O_RDONLY | flags);\n\tif (ret < 0)\n\t\tfsnotify_put_group(group);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 431
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pidfile_write(const char *pid_file, int pid)\n{\n\tFILE *pidfile = NULL;\n\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\n\tif (pidfd != -1) pidfile = fdopen(pidfd, \"w\");\n\n\tif (!pidfile) {\n\t\tlog_message(LOG_INFO, \"pidfile_write : Cannot open %s pidfile\",\n\t\t       pid_file);\n\t\treturn 0;\n\t}\n\tfprintf(pidfile, \"%d\\n\", pid);\n\tfclose(pidfile);\n\treturn 1;\n}",
        "output": "1",
        "idx": 7082
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "snmp_ber_decode_string_len_buffer(unsigned char *buf, uint32_t *buff_len, const char **str, uint32_t *length)\n{\n  uint8_t type, i, length_bytes;\n\n  buf = snmp_ber_decode_type(buf, buff_len, &type);\n\n  if(buf == NULL || type != BER_DATA_TYPE_OCTET_STRING) {\n    return NULL;\n  }\n\n  if((*buf & 0x80) == 0) {\n    *length = (uint32_t)*buf++;\n    (*buff_len)--;\n  } else {\n\n    length_bytes = (uint8_t)(*buf++ & 0x7F);\n    (*buff_len)--;\n    if(length_bytes > 4) {\n      return NULL;\n    }\n\n    *length = (uint32_t)*buf++;\n    (*buff_len)--;\n    for(i = 1; i < length_bytes; ++i) {\n      *length <<= 8;\n      *length |= *buf++;\n      (*buff_len)--;\n    }\n  }\n\n  *str = (const char *)buf;\n  *buff_len -= *length;\n\n  return buf + *length;\n}",
        "output": "1",
        "idx": 7962
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ntlm_print_message_fields(NTLM_MESSAGE_FIELDS* fields, const char* name)\n{\n\tWLog_DBG(TAG, \"%s (Len: %\"PRIu16\" MaxLen: %\"PRIu16\" BufferOffset: %\"PRIu32\")\",\n\t         name, fields->Len, fields->MaxLen, fields->BufferOffset);\n\n\tif (fields->Len > 0)\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, fields->Buffer, fields->Len);\n}",
        "output": "1",
        "idx": 4200
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,\n\t\t\t      indx, data, size, 100);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}",
        "output": "1",
        "idx": 1458
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dmar_free_irte(const struct intr_source *intr_src, uint16_t index)\n{\n\tstruct dmar_drhd_rt *dmar_unit;\n\tunion dmar_ir_entry *ir_table, *ir_entry;\n\tunion pci_bdf sid;\n\n\tif (intr_src->is_msi) {\n\t\tdmar_unit = device_to_dmaru((uint8_t)intr_src->src.msi.bits.b, intr_src->src.msi.fields.devfun);\n\t} else {\n\t\tdmar_unit = ioapic_to_dmaru(intr_src->src.ioapic_id, &sid);\n\t}\n\n\tif (is_dmar_unit_valid(dmar_unit, sid)) {\n\t\tir_table = (union dmar_ir_entry *)hpa2hva(dmar_unit->ir_table_addr);\n\t\tir_entry = ir_table + index;\n\t\tir_entry->bits.remap.present = 0x0UL;\n\n\t\tiommu_flush_cache(ir_entry, sizeof(union dmar_ir_entry));\n\t\tdmar_invalid_iec(dmar_unit, index, 0U, false);\n\n\t\tif (!is_irte_reserved(dmar_unit, index)) {\n\t\t\tspinlock_obtain(&dmar_unit->lock);\n\t\t\tbitmap_clear_nolock(index & 0x3FU, &dmar_unit->irte_alloc_bitmap[index >> 6U]);\n\t\t\tspinlock_release(&dmar_unit->lock);\n\t\t}\n\t}\n\n}",
        "output": "1",
        "idx": 7568
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs4_open_confirm_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\tif (!data->rpc_done)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.fmode);\nout_free:\n\tnfs4_opendata_put(data);\n}",
        "output": "0",
        "idx": 3075
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\treturn crypto_alloc_skcipher(name, type, mask);\n}",
        "output": "1",
        "idx": 1052
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void scsi_read_complete(void * opaque, int ret)\n{\n    SCSIDiskReq *r = (SCSIDiskReq *)opaque;\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    int n;\n\n    if (r->req.aiocb != NULL) {\n        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_READ)) {\n            return;\n        }\n    }\n\n    DPRINTF(\"Data ready tag=0x%x len=%zd\\n\", r->req.tag, r->iov.iov_len);\n\n    n = r->iov.iov_len / 512;\n    r->sector += n;\n    r->sector_count -= n;\n    scsi_req_data(&r->req, r->iov.iov_len);\n}",
        "output": "1",
        "idx": 3570
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_get_cfgdata8(struct pci_vdev *dev, int offset)\n{\n\tassert(offset <= PCI_REGMAX);\n\treturn (*(uint8_t *)(dev->cfgdata + offset));\n}",
        "output": "1",
        "idx": 7628
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "externalParEntProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  const char *next = s;\n  int tok;\n\n  tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  if (tok <= 0) {\n    if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    switch (tok) {\n    case XML_TOK_INVALID:\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_NONE: \n    default:\n      break;\n    }\n  }\n  else if (tok == XML_TOK_BOM) {\n    s = next;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  }\n\n  parser->m_processor = prologProcessor;\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}",
        "output": "1",
        "idx": 7524
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ngx_mail_core_create_srv_conf(ngx_conf_t *cf)\n{\n    ngx_mail_core_srv_conf_t  *cscf;\n\n    cscf = ngx_pcalloc(cf->pool, sizeof(ngx_mail_core_srv_conf_t));\n    if (cscf == NULL) {\n        return NULL;\n    }\n\n\n    cscf->timeout = NGX_CONF_UNSET_MSEC;\n    cscf->resolver_timeout = NGX_CONF_UNSET_MSEC;\n\n    cscf->max_errors = NGX_CONF_UNSET_UINT;\n\n    cscf->resolver = NGX_CONF_UNSET_PTR;\n\n    cscf->file_name = cf->conf_file->file.name.data;\n    cscf->line = cf->conf_file->line;\n\n    return cscf;\n}",
        "output": "0",
        "idx": 8953
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_rmdir(const char *path)\n{\n\tsize_t len = strlen(path) + 30;\n\tchar *tmpname = alloca(len);\n\tsnprintf(tmpname, len, \"%s/%d\", path, (int)getpid());\n\n\tif (rmdir(path) == 0 || errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at rmdir of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (rmdir(tmpname) == 0 || errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at rmdir of %s\\n\", tmpname);\n\t\texit(1);\n\t}\n}",
        "output": "0",
        "idx": 7271
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void keyring_describe(const struct key *keyring, struct seq_file *m)\n{\n\tif (keyring->description)\n\t\tseq_puts(m, keyring->description);\n\telse\n\t\tseq_puts(m, \"[anon]\");\n\n\tif (key_is_positive(keyring)) {\n\t\tif (keyring->keys.nr_leaves_on_tree != 0)\n\t\t\tseq_printf(m, \": %lu\", keyring->keys.nr_leaves_on_tree);\n\t\telse\n\t\t\tseq_puts(m, \": empty\");\n\t}\n}",
        "output": "0",
        "idx": 2503
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "juniper_pppoe_atm_print(netdissect_options *ndo,\n                        const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n\tuint16_t extracted_ethertype;\n\n        l2info.pictype = DLT_JUNIPER_PPPOE_ATM;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n\n        p+=l2info.header_len;\n\n        ND_TCHECK2(p[0], 2);\n        extracted_ethertype = EXTRACT_16BITS(p);\n        if (ethertype_print(ndo, extracted_ethertype,\n                              p+ETHERTYPE_LEN,\n                              l2info.length-ETHERTYPE_LEN,\n                              l2info.caplen-ETHERTYPE_LEN,\n                              NULL, NULL) == 0)\n            ND_PRINT((ndo, \"unknown ethertype 0x%04x\", extracted_ethertype));\n\n        return l2info.header_len;\n\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_pppoe_atm]\"));\n\treturn l2info.header_len;\n}",
        "output": "0",
        "idx": 6621
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint32 bps = tif->tif_dir.td_bitspersample / 8;\n\ttmsize_t wc = cc / bps;\n\ttmsize_t count = cc;\n\tuint8 *cp = (uint8 *) cp0;\n\tuint8 *tmp = (uint8 *)_TIFFmalloc(cc);\n\n\tassert((cc%(bps*stride))==0);\n\n\tif (!tmp)\n\t\treturn;\n\n\twhile (count > stride) {\n\t\tREPEAT4(stride, cp[stride] =\n                        (unsigned char) ((cp[stride] + cp[0]) & 0xff); cp++)\n\t\tcount -= stride;\n\t}\n\n\t_TIFFmemcpy(tmp, cp0, cc);\n\tcp = (uint8 *) cp0;\n\tfor (count = 0; count < wc; count++) {\n\t\tuint32 byte;\n\t\tfor (byte = 0; byte < bps; byte++) {\n\t\t\t#if WORDS_BIGENDIAN\n\t\t\tcp[bps * count + byte] = tmp[byte * wc + count];\n\t\t\t#else\n\t\t\tcp[bps * count + byte] =\n\t\t\t\ttmp[(bps - byte - 1) * wc + count];\n\t\t\t#endif\n\t\t}\n\t}\n\t_TIFFfree(tmp);\n}",
        "output": "1",
        "idx": 4264
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, key)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_LONG(intern->u.file.current_line_num);\n} ",
        "output": "1",
        "idx": 3924
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void put_utf16(wchar_t *s, unsigned c, enum utf16_endian endian)\n{\n\tswitch (endian) {\n\tdefault:\n\t\t*s = (wchar_t) c;\n\t\tbreak;\n\tcase UTF16_LITTLE_ENDIAN:\n\t\t*s = __cpu_to_le16(c);\n\t\tbreak;\n\tcase UTF16_BIG_ENDIAN:\n\t\t*s = __cpu_to_be16(c);\n\t\tbreak;\n\t}\n}",
        "output": "0",
        "idx": 825
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ptrace_triggered(struct perf_event *bp, int nmi,\n\t\t\t     struct perf_sample_data *data,\n\t\t\t     struct pt_regs *regs)\n{\n\tint i;\n\tstruct thread_struct *thread = &(current->thread);\n\n\tfor (i = 0; i < HBP_NUM; i++) {\n\t\tif (thread->ptrace_bps[i] == bp)\n\t\t\tbreak;\n\t}\n\n\tthread->debugreg6 |= (DR_TRAP0 << i);\n}",
        "output": "1",
        "idx": 510
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct ip_options_rcu *ip_options_get_alloc(const int optlen)\n{\n\treturn kzalloc(sizeof(struct ip_options_rcu) + ((optlen + 3) & ~3),\n\t\t       GFP_KERNEL);\n}",
        "output": "0",
        "idx": 485
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init sit_init(void)\n{\n\tint err;\n\n\tprintk(KERN_INFO \"IPv6 over IPv4 tunneling driver\\n\");\n\n\terr = register_pernet_device(&sit_net_ops);\n\tif (err < 0)\n\t\treturn err;\n\terr = xfrm4_tunnel_register(&sit_handler, AF_INET6);\n\tif (err < 0) {\n\t\tunregister_pernet_device(&sit_net_ops);\n\t\tprintk(KERN_INFO \"sit init: Can't add protocol\\n\");\n\t}\n\treturn err;\n}",
        "output": "0",
        "idx": 3143
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,\n\t\tunsigned int, flags, struct sockaddr __user *, addr,\n\t\tint __user *, addr_len)\n{\n\tstruct socket *sock;\n\tstruct iovec iov;\n\tstruct msghdr msg;\n\tstruct sockaddr_storage address;\n\tint err, err2;\n\tint fput_needed;\n\n\tif (size > INT_MAX)\n\t\tsize = INT_MAX;\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_iov = &iov;\n\tiov.iov_len = size;\n\tiov.iov_base = ubuf;\n\tmsg.msg_name = addr ? (struct sockaddr *)&address : NULL;\n\tmsg.msg_namelen = 0;\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\terr = sock_recvmsg(sock, &msg, size, flags);\n\n\tif (err >= 0 && addr != NULL) {\n\t\terr2 = move_addr_to_user(&address,\n\t\t\t\t\t msg.msg_namelen, addr, addr_len);\n\t\tif (err2 < 0)\n\t\t\terr = err2;\n\t}\n\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}",
        "output": "0",
        "idx": 3409
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static wStream* rdg_receive_packet(rdpRdg* rdg)\n{\n\twStream* s;\n\tconst size_t header = sizeof(RdgPacketHeader);\n\tsize_t packetLength;\n\tassert(header <= INT_MAX);\n\ts = Stream_New(NULL, 1024);\n\n\tif (!s)\n\t\treturn NULL;\n\n\tif (!rdg_read_all(rdg->tlsOut, Stream_Buffer(s), header))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\n\tStream_Seek(s, 4);\n\tStream_Read_UINT32(s, packetLength);\n\n\tif ((packetLength > INT_MAX) || !Stream_EnsureCapacity(s, packetLength) ||\n\t    (packetLength < header))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\n\tif (!rdg_read_all(rdg->tlsOut, Stream_Buffer(s) + header, (int)packetLength - (int)header))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\n\tStream_SetLength(s, packetLength);\n\treturn s;\n}",
        "output": "0",
        "idx": 5743
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cib_timeout_handler(gpointer data)\n{\n    struct timer_rec_s *timer = data;\n\n    timer_expired = TRUE;\n    crm_err(\"Call %d timed out after %ds\", timer->call_id, timer->timeout);\n\n    return TRUE;\n}",
        "output": "1",
        "idx": 3736
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ves_icall_System_Threading_InternalThread_Thread_free_internal (MonoInternalThread *this, HANDLE thread)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tTHREAD_DEBUG (g_message (\"%s: Closing thread %p, handle %p\", __func__, this, thread));\n\n\tif (thread)\n\t\tCloseHandle (thread);\n\n\tif (this->synch_cs) {\n\t\tCRITICAL_SECTION *synch_cs = this->synch_cs;\n\t\tthis->synch_cs = NULL;\n\t\tDeleteCriticalSection (synch_cs);\n\t\tg_free (synch_cs);\n\t}\n\n\tif (this->name) {\n\t\tvoid *name = this->name;\n\t\tthis->name = NULL;\n\t\tg_free (name);\n\t}\n}",
        "output": "0",
        "idx": 4711
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "snmp_mib_add(snmp_mib_resource_t *new_resource)\n{\n  snmp_mib_resource_t *resource;\n\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource->next) {\n\n    if(snmp_oid_cmp_oid(resource->oid, new_resource->oid) > 0) {\n      break;\n    }\n  }\n  if(resource == NULL) {\n    list_add(snmp_mib, new_resource);\n  } else {\n    list_insert(snmp_mib, new_resource, resource);\n  }\n\n#if LOG_LEVEL == LOG_LEVEL_DBG\n  LOG_DBG(\"Table after insert.\\n\");\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource->next) {\n\n    snmp_oid_print(resource->oid);\n  }\n#endif \n}",
        "output": "1",
        "idx": 7982
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void smp_task_done(struct sas_task *task)\n{\n\tif (!del_timer(&task->slow_task->timer))\n\t\treturn;\n\tcomplete(&task->slow_task->completion);\n}",
        "output": "1",
        "idx": 3016
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,\n\t\t\tint atomic)\n{\n\tunsigned long copy;\n\n\twhile (len > 0) {\n\t\twhile (!iov->iov_len)\n\t\t\tiov++;\n\t\tcopy = min_t(unsigned long, len, iov->iov_len);\n\n\t\tif (atomic) {\n\t\t\tif (__copy_from_user_inatomic(to, iov->iov_base, copy))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tif (copy_from_user(to, iov->iov_base, copy))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\tto += copy;\n\t\tlen -= copy;\n\t\tiov->iov_base += copy;\n\t\tiov->iov_len -= copy;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 2564
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\n\tret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,\n\t\t\t      indx, data, size, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}",
        "output": "1",
        "idx": 1456
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)\n{\n\tint m;\n\n\tif (n < 0 || n >= 32) {\n\t\treturn EOF;\n\t}\n\tassert(!(v & (~JAS_ONES(n))));\n\n\tm = n - 1;\n\twhile (--n >= 0) {\n\t\tif (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {\n\t\t\treturn EOF;\n\t\t}\n\t\tv <<= 1;\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 7507
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int follow_dotdot(struct nameidata *nd)\n{\n\tif (!nd->root.mnt)\n\t\tset_root(nd);\n\n\twhile(1) {\n\t\tstruct dentry *old = nd->path.dentry;\n\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tnd->path.dentry = dget_parent(nd->path.dentry);\n\t\t\tdput(old);\n\t\t\tif (unlikely(!path_connected(&nd->path)))\n\t\t\t\treturn -ENOENT;\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up(&nd->path))\n\t\t\tbreak;\n\t}\n\tfollow_mount(&nd->path);\n\tnd->inode = nd->path.dentry->d_inode;\n\treturn 0;\n}",
        "output": "0",
        "idx": 4003
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool freelist_state_initialize(union freelist_init_state *state,\n\t\t\t\tstruct kmem_cache *cachep,\n\t\t\t\tunsigned int count)\n{\n\tbool ret;\n\tunsigned int rand;\n\n\trand = get_random_int();\n\n\tif (!cachep->random_seq) {\n\t\tprandom_seed_state(&state->rnd_state, rand);\n\t\tret = false;\n\t} else {\n\t\tstate->list = cachep->random_seq;\n\t\tstate->count = count;\n\t\tstate->pos = 0;\n\t\tstate->rand = rand;\n\t\tret = true;\n\t}\n\treturn ret;\n}",
        "output": "1",
        "idx": 1412
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int vm_iomap_memory(struct vm_area_struct *vma, phys_addr_t start, unsigned long len)\n{\n\tunsigned long vm_len, pfn, pages;\n\n\tif (start + len < start)\n\t\treturn -EINVAL;\n\tlen += start & ~PAGE_MASK;\n\tpfn = start >> PAGE_SHIFT;\n\tpages = (len + ~PAGE_MASK) >> PAGE_SHIFT;\n\tif (pfn + pages < pfn)\n\t\treturn -EINVAL;\n\n\tif (vma->vm_pgoff > pages)\n\t\treturn -EINVAL;\n\tpfn += vma->vm_pgoff;\n\tpages -= vma->vm_pgoff;\n\n\tvm_len = vma->vm_end - vma->vm_start;\n\tif (vm_len >> PAGE_SHIFT > pages)\n\t\treturn -EINVAL;\n\n\treturn io_remap_pfn_range(vma, vma->vm_start, pfn, vm_len, vma->vm_page_prot);\n}",
        "output": "0",
        "idx": 1321
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *path_name(const struct name_path *path, const char *name)\n{\n\tconst struct name_path *p;\n\tchar *n, *m;\n\tint nlen = strlen(name);\n\tint len = nlen + 1;\n\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len)\n\t\t\tlen += p->elem_len + 1;\n\t}\n\tn = xmalloc(len);\n\tm = n + len - (nlen + 1);\n\tmemcpy(m, name, nlen + 1);\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len) {\n\t\t\tm -= p->elem_len + 1;\n\t\t\tmemcpy(m, p->elem, p->elem_len);\n\t\t\tm[p->elem_len] = '/';\n\t\t}\n\t}\n\treturn n;\n}",
        "output": "0",
        "idx": 7217
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "COMPAT_SYSCALL_DEFINE6(mbind, compat_ulong_t, start, compat_ulong_t, len,\n\t\t       compat_ulong_t, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode, compat_ulong_t, flags)\n{\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tnodemask_t bm;\n\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\n\tif (nmask) {\n\t\tif (compat_get_bitmap(nodes_addr(bm), nmask, nr_bits))\n\t\t\treturn -EFAULT;\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\tif (copy_to_user(nm, nodes_addr(bm), alloc_size))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn sys_mbind(start, len, mode, nm, nr_bits+1, flags);\n}",
        "output": "0",
        "idx": 2229
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u32 gasp_specifier_id(__be32 *p)\n{\n\treturn (be32_to_cpu(p[0]) & 0xffff) << 8 |\n\t       (be32_to_cpu(p[1]) & 0xff000000) >> 24;\n}",
        "output": "0",
        "idx": 2001
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, char *file_name, size_t file_size)\n{\n\tbee_t *bee = ic->bee;\n\tbee_user_t *bu = bee_user_by_handle(bee, ic, handle);\n\n\tif (bee->ui->ft_in_start && bu) {\n\t\treturn bee->ui->ft_in_start(bee, bu, file_name, file_size);\n\t} else {\n\t\treturn NULL;\n\t}\n}",
        "output": "0",
        "idx": 7849
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(curl_escape)\n{\n\tchar       *str = NULL, *res = NULL;\n\tsize_t        str_len = 0;\n\tzval       *zid;\n\tphp_curl   *ch;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rs\", &zid, &str, &str_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((ch = (php_curl*)zend_fetch_resource(Z_RES_P(zid), le_curl_name, le_curl)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif ((res = curl_easy_escape(ch->cp, str, str_len))) {\n\t\tRETVAL_STRING(res);\n\t\tcurl_free(res);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}",
        "output": "1",
        "idx": 4070
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int key_update(key_ref_t key_ref, const void *payload, size_t plen)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\n\tkey_check(key);\n\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!key->type->update)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tdown_write(&key->sem);\n\n\tret = key->type->update(key, &prep);\n\tif (ret == 0)\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\n\tup_write(&key->sem);\n\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}",
        "output": "1",
        "idx": 1722
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *__dma_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t  dma_addr_t *dma_handle, gfp_t flags,\n\t\t\t\t  struct dma_attrs *attrs)\n{\n\tif (dev == NULL) {\n\t\tWARN_ONCE(1, \"Use an actual device structure for DMA allocation\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (IS_ENABLED(CONFIG_ZONE_DMA) &&\n\t    dev->coherent_dma_mask <= DMA_BIT_MASK(32))\n\t\tflags |= GFP_DMA;\n\tif (IS_ENABLED(CONFIG_DMA_CMA) && (flags & __GFP_WAIT)) {\n\t\tstruct page *page;\n\t\tvoid *addr;\n\n\t\tsize = PAGE_ALIGN(size);\n\t\tpage = dma_alloc_from_contiguous(dev, size >> PAGE_SHIFT,\n\t\t\t\t\t\t\tget_order(size));\n\t\tif (!page)\n\t\t\treturn NULL;\n\n\t\t*dma_handle = phys_to_dma(dev, page_to_phys(page));\n\t\taddr = page_address(page);\n\t\tmemset(addr, 0, size);\n\t\treturn addr;\n\t} else {\n\t\treturn swiotlb_alloc_coherent(dev, size, dma_handle, flags);\n\t}\n}",
        "output": "0",
        "idx": 3941
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t exitcode_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tchar *end, buf[sizeof(\"nnnnn\\0\")];\n\tint tmp;\n\n\tif (copy_from_user(buf, buffer, count))\n\t\treturn -EFAULT;\n\n\ttmp = simple_strtol(buf, &end, 0);\n\tif ((*end != '\\0') && !isspace(*end))\n\t\treturn -EINVAL;\n\n\tuml_exitcode = tmp;\n\treturn count;\n}",
        "output": "1",
        "idx": 2356
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_le_short (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 2)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\t} ;\n} ",
        "output": "1",
        "idx": 4924
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "server_request_direct_streamlocal(void)\n{\n\tChannel *c = NULL;\n\tchar *target, *originator;\n\tu_short originator_port;\n\n\ttarget = packet_get_string(NULL);\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\n\tdebug(\"server_request_direct_streamlocal: originator %s port %d, target %s\",\n\t    originator, originator_port, target);\n\n\tif ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&\n\t    !no_port_forwarding_flag && !options.disable_forwarding &&\n\t    use_privsep) {\n\t\tc = channel_connect_to_path(target,\n\t\t    \"direct-streamlocal@openssh.com\", \"direct-streamlocal\");\n\t} else {\n\t\tlogit(\"refused streamlocal port forward: \"\n\t\t    \"originator %s port %d, target %s\",\n\t\t    originator, originator_port, target);\n\t}\n\n\tfree(originator);\n\tfree(target);\n\n\treturn c;\n}",
        "output": "0",
        "idx": 7795
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool pmc_overflow(unsigned long val)\n{\n\tif ((int)val < 0)\n\t\treturn true;\n\n\tif (__is_processor(PV_POWER7) && ((0x80000000 - val) <= 256))\n\t\treturn true;\n\n\treturn false;\n}",
        "output": "0",
        "idx": 375
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int gdAlphaBlend (int dst, int src) {\n    int src_alpha = gdTrueColorGetAlpha(src);\n    int dst_alpha, alpha, red, green, blue;\n    int src_weight, dst_weight, tot_weight;\n\n    if( src_alpha == gdAlphaOpaque )\n        return src;\n\n    dst_alpha = gdTrueColorGetAlpha(dst);\n    if( src_alpha == gdAlphaTransparent )\n        return dst;\n    if( dst_alpha == gdAlphaTransparent )\n        return src;\n\n    src_weight = gdAlphaTransparent - src_alpha;\n    dst_weight = (gdAlphaTransparent - dst_alpha) * src_alpha / gdAlphaMax;\n    tot_weight = src_weight + dst_weight;\n    \n    alpha = src_alpha * dst_alpha / gdAlphaMax;\n\n    red = (gdTrueColorGetRed(src) * src_weight\n           + gdTrueColorGetRed(dst) * dst_weight) / tot_weight;\n    green = (gdTrueColorGetGreen(src) * src_weight\n           + gdTrueColorGetGreen(dst) * dst_weight) / tot_weight;\n    blue = (gdTrueColorGetBlue(src) * src_weight\n           + gdTrueColorGetBlue(dst) * dst_weight) / tot_weight;\n\n    return ((alpha << 24) + (red << 16) + (green << 8) + blue);\n\n}",
        "output": "1",
        "idx": 4060
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "batchCopyElem(batch_obj_t *pDest, batch_obj_t *pSrc) {\n\tmemcpy(pDest, pSrc, sizeof(batch_obj_t));\n}",
        "output": "1",
        "idx": 3384
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *etm_setup_aux(int event_cpu, void **pages,\n\t\t\t   int nr_pages, bool overwrite)\n{\n\tint cpu;\n\tcpumask_t *mask;\n\tstruct coresight_device *sink;\n\tstruct etm_event_data *event_data = NULL;\n\n\tevent_data = alloc_event_data(event_cpu);\n\tif (!event_data)\n\t\treturn NULL;\n\n\tsink = coresight_get_enabled_sink(true);\n\tif (!sink)\n\t\tgoto err;\n\n\tINIT_WORK(&event_data->work, free_event_data);\n\n\tmask = &event_data->mask;\n\n\tfor_each_cpu(cpu, mask) {\n\t\tstruct coresight_device *csdev;\n\n\t\tcsdev = per_cpu(csdev_src, cpu);\n\t\tif (!csdev)\n\t\t\tgoto err;\n\n\t\tevent_data->path[cpu] = coresight_build_path(csdev, sink);\n\t\tif (IS_ERR(event_data->path[cpu]))\n\t\t\tgoto err;\n\t}\n\n\tif (!sink_ops(sink)->alloc_buffer)\n\t\tgoto err;\n\n\tcpu = cpumask_first(mask);\n\tevent_data->snk_config =\n\t\t\tsink_ops(sink)->alloc_buffer(sink, cpu, pages,\n\t\t\t\t\t\t     nr_pages, overwrite);\n\tif (!event_data->snk_config)\n\t\tgoto err;\n\nout:\n\treturn event_data;\n\nerr:\n\tetm_free_aux(event_data);\n\tevent_data = NULL;\n\tgoto out;\n}",
        "output": "0",
        "idx": 2101
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void read_conf(FILE *conffile)\n{\n    char *buffer, *line, *val;\n\n    buffer = loadfile(conffile);\n    for (line = strtok(buffer, \"\\r\\n\"); line; line = strtok(NULL, \"\\r\\n\")) {\n        if (!strncmp(line, \"export \", 7))\n            continue;\n        val = strchr(line, '=');\n        if (!val) {\n            printf(\"invalid configuration line\\n\");\n            break;\n        }\n        *val++ = '\\0';\n\n        if (!strcmp(line, \"JSON_INDENT\"))\n            conf.indent = atoi(val);\n        if (!strcmp(line, \"JSON_COMPACT\"))\n            conf.compact = atoi(val);\n        if (!strcmp(line, \"JSON_ENSURE_ASCII\"))\n            conf.ensure_ascii = atoi(val);\n        if (!strcmp(line, \"JSON_PRESERVE_ORDER\"))\n            conf.preserve_order = atoi(val);\n        if (!strcmp(line, \"JSON_SORT_KEYS\"))\n            conf.sort_keys = atoi(val);\n        if (!strcmp(line, \"STRIP\"))\n            conf.strip = atoi(val);\n        if (!strcmp(line, \"HASHSEED\")) {\n            conf.have_hashseed = 1;\n            conf.hashseed = atoi(val);\n        } else {\n            conf.have_hashseed = 0;\n        }\n    }\n\n    free(buffer);\n}",
        "output": "0",
        "idx": 5997
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static enum hrtimer_restart perf_swevent_hrtimer(struct hrtimer *hrtimer)\n{\n\tenum hrtimer_restart ret = HRTIMER_RESTART;\n\tstruct perf_sample_data data;\n\tstruct pt_regs *regs;\n\tstruct perf_event *event;\n\tu64 period;\n\n\tevent = container_of(hrtimer, struct perf_event, hw.hrtimer);\n\n\tif (event->state != PERF_EVENT_STATE_ACTIVE)\n\t\treturn HRTIMER_NORESTART;\n\n\tevent->pmu->read(event);\n\n\tperf_sample_data_init(&data, 0);\n\tdata.period = event->hw.last_period;\n\tregs = get_irq_regs();\n\n\tif (regs && !perf_exclude_event(event, regs)) {\n\t\tif (!(event->attr.exclude_idle && current->pid == 0))\n\t\t\tif (perf_event_overflow(event, &data, regs))\n\t\t\t\tret = HRTIMER_NORESTART;\n\t}\n\n\tperiod = max_t(u64, 10000, event->hw.sample_period);\n\thrtimer_forward_now(hrtimer, ns_to_ktime(period));\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 689
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\tspin_lock_init(&mm->context.list_lock);\n\tINIT_LIST_HEAD(&mm->context.pgtable_list);\n\tINIT_LIST_HEAD(&mm->context.gmap_list);\n\tcpumask_clear(&mm->context.cpu_attach_mask);\n\tatomic_set(&mm->context.attach_count, 0);\n\tmm->context.flush_mm = 0;\n#ifdef CONFIG_PGSTE\n\tmm->context.alloc_pgste = page_table_allocate_pgste;\n\tmm->context.has_pgste = 0;\n\tmm->context.use_skey = 0;\n#endif\n\tif (mm->context.asce_limit == 0) {\n\t\tmm->context.asce_bits = _ASCE_TABLE_LENGTH |\n\t\t\t_ASCE_USER_BITS | _ASCE_TYPE_REGION3;\n\t\tmm->context.asce_limit = STACK_TOP_MAX;\n\t} else if (mm->context.asce_limit == (1UL << 31)) {\n\t\tmm_inc_nr_pmds(mm);\n\t}\n\tcrst_table_init((unsigned long *) mm->pgd, pgd_entry_type(mm));\n\treturn 0;\n}",
        "output": "0",
        "idx": 1677
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\tpmd_t pmdval = pmd_read_atomic(pmd);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tif (!pmd_trans_huge(pmdval))\n\t\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 957
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void print_buttons(HttpRequest req, HttpResponse res, Service_T s) {\n        if (is_readonly(req)) {\n                return;\n        }\n        StringBuffer_append(res->outputbuffer, \"<table id='buttons'><tr>\");\n        if (s->start)\n                StringBuffer_append(res->outputbuffer,\n                                    \"<td><form method=POST action=%s>\"\n                                    \"<input type=hidden value='start' name=action>\"\n                                    \"<input type=submit value='Start service'></form></td>\", s->name);\n        if (s->stop)\n                StringBuffer_append(res->outputbuffer,\n                                    \"<td><form method=POST action=%s>\"\n                                    \"<input type=hidden value='stop' name=action>\"\n                                    \"<input type=submit value='Stop service'></form></td>\", s->name);\n        if ((s->start && s->stop) || s->restart)\n                StringBuffer_append(res->outputbuffer,\n                                    \"<td><form method=POST action=%s>\"\n                                    \"<input type=hidden value='restart' name=action>\"\n                                    \"<input type=submit value='Restart service'></form></td>\", s->name);\n        StringBuffer_append(res->outputbuffer,\n                            \"<td><form method=POST action=%s>\"\n                            \"<input type=hidden value='%s' name=action>\"\n                            \"<input type=submit value='%s'></form></td></tr></table>\",\n                            s->name,\n                            s->monitor ? \"unmonitor\" : \"monitor\",\n                            s->monitor ? \"Disable monitoring\" : \"Enable monitoring\");\n}",
        "output": "1",
        "idx": 6014
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "crm_send_plaintext(int sock, const char *buf, size_t len)\n{\n\n    int rc = 0;\n    const char *unsent = buf;\n    int total_send;\n\n    if (buf == NULL) {\n        return -1;\n    }\n    total_send = len;\n\n    crm_trace(\"Message on socket %d: size=%d\", sock, len);\n  retry:\n    rc = write(sock, unsent, len);\n    if (rc < 0) {\n        switch (errno) {\n        case EINTR:\n        case EAGAIN:\n            crm_trace(\"Retry\");\n            goto retry;\n        default:\n            crm_perror(LOG_ERR, \"Could only write %d of the remaining %d bytes\", rc, (int) len);\n            break;\n        }\n\n    } else if (rc < len) {\n        crm_trace(\"Only sent %d of %d remaining bytes\", rc, len);\n        len -= rc;\n        unsent += rc;\n        goto retry;\n\n     } else {\n        crm_trace(\"Sent %d bytes: %.100s\", rc, buf);\n    }\n\n    return rc < 0 ? rc : total_send;\n\n}",
        "output": "0",
        "idx": 5247
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MprJson *setProperty(MprJson *obj, cchar *name, MprJson *child)\n{\n    MprJson      *prior, *existing;\n\n    if (!obj || !child) {\n        return 0;\n    }\n    if ((existing = mprLookupJsonObj(obj, name)) != 0) {\n        existing->value = child->value;\n        existing->children = child->children;\n        existing->type = child->type;\n        existing->length = child->length;\n        return existing;\n    } \n    if (obj->children) {\n        prior = obj->children->prev;\n        child->next = obj->children;\n        child->prev = prior;\n        prior->next->prev = child;\n        prior->next = child;\n    } else {\n        child->next = child->prev = child;\n        obj->children = child;\n    }\n    child->name = name;\n    obj->length++;\n    return child;\n}",
        "output": "1",
        "idx": 5088
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb)\n{\n\tint ret;\n\tint size;\n\n\tif (ud->side == USBIP_STUB) {\n\t\tif (usb_pipein(urb->pipe))\n\t\t\treturn 0;\n\n\t\tsize = urb->transfer_buffer_length;\n\t} else {\n\t\tif (usb_pipeout(urb->pipe))\n\t\t\treturn 0;\n\n\t\tsize = urb->actual_length;\n\t}\n\n\tif (!(size > 0))\n\t\treturn 0;\n\n\tif (size > urb->transfer_buffer_length) {\n\t\tif (ud->side == USBIP_STUB) {\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\n\tret = usbip_recv(ud->tcp_socket, urb->transfer_buffer, size);\n\tif (ret != size) {\n\t\tdev_err(&urb->dev->dev, \"recv xbuf, %d\\n\", ret);\n\t\tif (ud->side == USBIP_STUB) {\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\t} else {\n\t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 1775
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cipso_v4_sock_delattr(struct sock *sk)\n{\n\tint hdr_delta;\n\tstruct ip_options *opt;\n\tstruct inet_sock *sk_inet;\n\n\tsk_inet = inet_sk(sk);\n\topt = sk_inet->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn;\n\n\thdr_delta = cipso_v4_delopt(&sk_inet->opt);\n\tif (sk_inet->is_icsk && hdr_delta > 0) {\n\t\tstruct inet_connection_sock *sk_conn = inet_csk(sk);\n\t\tsk_conn->icsk_ext_hdr_len -= hdr_delta;\n\t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n\t}\n}",
        "output": "1",
        "idx": 326
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseResources(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprJson     *child, *groups, *singletons, *sets;\n    int         ji;\n\n    if ((sets = mprReadJsonObj(prop, \"sets\")) != 0) {\n        for (ITERATE_CONFIG(route, sets, child, ji)) {\n            httpAddRouteSet(route, child->value);\n        }\n    }\n    if ((groups = mprReadJsonObj(prop, \"groups\")) != 0) {\n        for (ITERATE_CONFIG(route, groups, child, ji)) {\n            httpAddResourceGroup(route, route->serverPrefix, child->value);\n        }\n    }\n    if ((singletons = mprReadJsonObj(prop, \"singletons\")) != 0) {\n        for (ITERATE_CONFIG(route, singletons, child, ji)) {\n            httpAddResource(route, route->serverPrefix, child->value);\n        }\n    }\n}",
        "output": "0",
        "idx": 7025
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sample_hbp_handler(struct perf_event *bp, int nmi,\n\t\t\t       struct perf_sample_data *data,\n\t\t\t       struct pt_regs *regs)\n{\n\tprintk(KERN_INFO \"%s value is changed\\n\", ksym_name);\n\tdump_stack();\n\tprintk(KERN_INFO \"Dump stack from sample_hbp_handler\\n\");\n}",
        "output": "1",
        "idx": 556
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\tstruct rt6_info *rt;\n\n\trt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);\n\tif (rt->dst.error == -EAGAIN) {\n\t\tip6_rt_put_flags(rt, flags);\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tif (!(flags | RT6_LOOKUP_F_DST_NOREF))\n\t\t\tdst_hold(&rt->dst);\n\t}\n\n\treturn &rt->dst;\n}",
        "output": "1",
        "idx": 3240
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\tif (inode_capable(inode, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}",
        "output": "1",
        "idx": 2582
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n{\n\tvoid *buf;\n\tint ret;\n\n\tbuf = kmalloc(size, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t      RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,\n\t\t\t      indx, 0, buf, size, 500);\n\tif (ret > 0 && ret <= size)\n\t\tmemcpy(data, buf, ret);\n\tkfree(buf);\n\treturn ret;\n}",
        "output": "0",
        "idx": 2131
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void uc_invalidate_tb(struct uc_struct *uc, uint64_t start_addr, size_t len) \n{\n    tb_page_addr_t start, end;\n\n    start = get_page_addr_code(uc->cpu->env_ptr, start_addr) & (target_ulong)(-1);\n    \n    end = (start + len) & (target_ulong)(-1);\n\n    if (start > end) {\n        return;\n    }\n\n    tb_invalidate_phys_range(uc, start, end);\n}",
        "output": "1",
        "idx": 8742
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void snd_timer_check_master(struct snd_timer_instance *master)\n{\n\tstruct snd_timer_instance *slave, *tmp;\n\n\tlist_for_each_entry_safe(slave, tmp, &snd_timer_slave_list, open_list) {\n\t\tif (slave->slave_class == master->slave_class &&\n\t\t    slave->slave_id == master->slave_id) {\n\t\t\tlist_move_tail(&slave->open_list, &master->slave_list_head);\n\t\t\tspin_lock_irq(&slave_active_lock);\n\t\t\tspin_lock(&master->timer->lock);\n\t\t\tslave->master = master;\n\t\t\tslave->timer = master->timer;\n\t\t\tif (slave->flags & SNDRV_TIMER_IFLG_RUNNING)\n\t\t\t\tlist_add_tail(&slave->active_list,\n\t\t\t\t\t      &master->slave_active_head);\n\t\t\tspin_unlock(&master->timer->lock);\n\t\t\tspin_unlock_irq(&slave_active_lock);\n\t\t}\n\t}\n}",
        "output": "0",
        "idx": 1533
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, valid)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {\n\t\tRETURN_BOOL(intern->u.file.current_line || intern->u.file.current_zval);\n\t} else {\n\t\tRETVAL_BOOL(!php_stream_eof(intern->u.file.stream));\n\t}\n} ",
        "output": "1",
        "idx": 3942
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int smacker_decode_tree(BitstreamContext *bc, HuffContext *hc,\n                               uint32_t prefix, int length)\n{\n    if (length > SMKTREE_DECODE_MAX_RECURSION) {\n        av_log(NULL, AV_LOG_ERROR, \"Maximum tree recursion level exceeded.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (!bitstream_read_bit(bc)) { \n        if(hc->current >= 256){\n            av_log(NULL, AV_LOG_ERROR, \"Tree size exceeded!\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if(length){\n            hc->bits[hc->current] = prefix;\n            hc->lengths[hc->current] = length;\n        } else {\n            hc->bits[hc->current] = 0;\n            hc->lengths[hc->current] = 0;\n        }\n        hc->values[hc->current] = bitstream_read(bc, 8);\n        hc->current++;\n        if(hc->maxlength < length)\n            hc->maxlength = length;\n        return 0;\n    } else { \n        int r;\n        length++;\n        r = smacker_decode_tree(bc, hc, prefix, length);\n        if(r)\n            return r;\n        return smacker_decode_tree(bc, hc, prefix | (1 << (length - 1)), length);\n    }\n}",
        "output": "0",
        "idx": 8517
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "set_lenIV(char *line)\n{\n  char *p = strstr(line, \"/lenIV \");\n\n  if (p && (isdigit(p[7]) || p[7] == '+' || p[7] == '-')) {\n    lenIV = atoi(p + 7);\n  }\n}",
        "output": "1",
        "idx": 5302
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __lo_release(struct loop_device *lo)\n{\n\tint err;\n\n\tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\n\tmutex_unlock(&lo->lo_ctl_mutex);\n}",
        "output": "0",
        "idx": 2637
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int http_buf_read(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int len;\n    len = s->buf_end - s->buf_ptr;\n    if (len > 0) {\n        if (len > size)\n            len = size;\n        memcpy(buf, s->buf_ptr, len);\n        s->buf_ptr += len;\n    } else {\n        int64_t target_end = s->end_off ? s->end_off : s->filesize;\n        if ((!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off >= target_end)\n            return AVERROR_EOF;\n        len = ffurl_read(s->hd, buf, size);\n        if (!len && (!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off < target_end) {\n            av_log(h, AV_LOG_ERROR,\n                   \"Stream ends prematurely at %\"PRId64\", should be %\"PRId64\"\\n\",\n                   s->off, target_end\n                  );\n            return AVERROR(EIO);\n        }\n    }\n    if (len > 0) {\n        s->off += len;\n        if (s->chunksize > 0)\n            s->chunksize -= len;\n    }\n    return len;\n}",
        "output": "1",
        "idx": 3454
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main(void)\n{\n\tint fd;\n\tunsigned int i;\n\tunsigned int start = 0;\n\tunsigned int _gap = ~0;\n\tunsigned int gap = _gap / 8;\n\tstruct qcedev_cipher_op_req req = { 0 };\n\tchar *data;\n\tfd = open(dev, O_RDWR);\n\tif (fd < 0) {\n\t\tprintf(\"Failed to open %s with errno %s\\n\", dev,\n\t\t       strerror(errno));\n\t\treturn EXIT_FAILURE;\n\n\t}\n\tthread_func(start, start + gap, fd);\n\n\tsleep(1000000);\n\treturn EXIT_FAILURE;\n}",
        "output": "0",
        "idx": 8567
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tsiginfo_t info;\n\n\tif (copy_from_user(&info, uinfo, sizeof(siginfo_t)))\n\t\treturn -EFAULT;\n\n\tif (info.si_code >= 0)\n\t\treturn -EPERM;\n\tinfo.si_signo = sig;\n\n\treturn kill_proc_info(sig, &info, pid);\n}",
        "output": "1",
        "idx": 264
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ast2obj_keyword(void* _o)\n{\n    keyword_ty o = (keyword_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n\n    result = PyType_GenericNew(keyword_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_identifier(o->arg);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_arg, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_expr(o->value);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_value, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    return result;\nfailed:\n    Py_XDECREF(value);\n    Py_XDECREF(result);\n    return NULL;\n}",
        "output": "1",
        "idx": 7682
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int simulate_sync(struct pt_regs *regs, unsigned int opcode)\n{\n\tif ((opcode & OPCODE) == SPEC0 && (opcode & FUNC) == SYNC) {\n\t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n\t\t\t\t1, 0, regs, 0);\n\t\treturn 0;\n\t}\n\n\treturn -1;\t\t\t\n}",
        "output": "1",
        "idx": 434
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_pyfribidi_log2vis (PyObject * self, PyObject * args, PyObject * kw)\n{\n    PyUnicodeObject *logical = NULL;\t\n    FriBidiParType base = FRIBIDI_TYPE_RTL;\t\n    int clean = 0; \n    int reordernsm = 1; \n\n    static char *kwargs[] =\n        { \"logical\", \"base_direction\", \"clean\", \"reordernsm\", NULL };\n\n    if (!PyArg_ParseTupleAndKeywords (args, kw, \"U|iii\", kwargs,\n                                      &logical, &base, &clean, &reordernsm)) {\n        return NULL;\n    }\n\n\n    if (!(base == FRIBIDI_TYPE_RTL\n          || base == FRIBIDI_TYPE_LTR\n          || base == FRIBIDI_TYPE_ON)) {\n        return PyErr_Format (PyExc_ValueError,\n                             \"invalid value %d: use either RTL, LTR or ON\",\n                             base);\n    }\n\n    return unicode_log2vis (logical, base, clean, reordernsm);\n}",
        "output": "0",
        "idx": 5051
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int uio_mmap_physical(struct vm_area_struct *vma)\n{\n\tstruct uio_device *idev = vma->vm_private_data;\n\tint mi = uio_find_mem_index(vma);\n\tstruct uio_mem *mem;\n\tif (mi < 0)\n\t\treturn -EINVAL;\n\tmem = idev->info->mem + mi;\n\n\tif (vma->vm_end - vma->vm_start > mem->size)\n\t\treturn -EINVAL;\n\n\tvma->vm_ops = &uio_physical_vm_ops;\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\n\treturn remap_pfn_range(vma,\n\t\t\t       vma->vm_start,\n\t\t\t       mem->addr >> PAGE_SHIFT,\n\t\t\t       vma->vm_end - vma->vm_start,\n\t\t\t       vma->vm_page_prot);\n}",
        "output": "0",
        "idx": 3337
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC char *websValidateUriPath(char *uri)\n{\n    if (uri == 0 || *uri != '/') {\n        return 0;\n    }\n    if (!websValidUriChars(uri)) {\n        return 0;\n    }\n    websDecodeUrl(uri, uri, -1);\n    if ((uri = websNormalizeUriPath(uri)) == 0) {\n        return 0;\n    }\n    if (*uri != '/' || strchr(uri, '\\\\')) {\n        return 0;\n    }\n    return uri;\n}",
        "output": "0",
        "idx": 6931
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void sem_putref(struct sem_array *sma)\n{\n\tipc_lock_by_ptr(&sma->sem_perm);\n\tipc_rcu_putref(sma);\n\tipc_unlock(&(sma)->sem_perm);\n}",
        "output": "1",
        "idx": 2254
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void * calloc(size_t n, size_t lb)\n{\n    if ((lb | n) > GC_SQRT_SIZE_MAX \n        && lb && n > GC_SIZE_MAX / lb)\n      return NULL;\n#   if defined(GC_LINUX_THREADS) \n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}",
        "output": "0",
        "idx": 5069
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __intel_pmu_pebs_event(struct perf_event *event,\n\t\t\t\t   struct pt_regs *iregs, void *__pebs)\n{\n\tstruct pebs_record_core *pebs = __pebs;\n\tstruct perf_sample_data data;\n\tstruct pt_regs regs;\n\n\tif (!intel_pmu_save_and_restart(event))\n\t\treturn;\n\n\tperf_sample_data_init(&data, 0);\n\tdata.period = event->hw.last_period;\n\n\tregs = *iregs;\n\tregs.ip = pebs->ip;\n\tregs.bp = pebs->bp;\n\tregs.sp = pebs->sp;\n\n\tif (event->attr.precise_ip > 1 && intel_pmu_pebs_fixup_ip(&regs))\n\t\tregs.flags |= PERF_EFLAGS_EXACT;\n\telse\n\t\tregs.flags &= ~PERF_EFLAGS_EXACT;\n\n\tif (perf_event_overflow(event, 1, &data, &regs))\n\t\tx86_pmu_stop(event, 0);\n}",
        "output": "1",
        "idx": 504
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void file_sb_list_add(struct file *file, struct super_block *sb)\n{\n\tif (likely(!(file->f_mode & FMODE_WRITE)))\n\t\treturn;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\treturn;\n\tlg_local_lock(&files_lglock);\n\t__file_sb_list_add(file, sb);\n\tlg_local_unlock(&files_lglock);\n}",
        "output": "1",
        "idx": 2374
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int udf_symlink_filler(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *bh = NULL;\n\tunsigned char *symlink;\n\tint err = -EIO;\n\tunsigned char *p = kmap(page);\n\tstruct udf_inode_info *iinfo;\n\tuint32_t pos;\n\n\tiinfo = UDF_I(inode);\n\tpos = udf_block_map(inode, 0);\n\n\tdown_read(&iinfo->i_data_sem);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tsymlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n\t} else {\n\t\tbh = sb_bread(inode->i_sb, pos);\n\n\t\tif (!bh)\n\t\t\tgoto out;\n\n\t\tsymlink = bh->b_data;\n\t}\n\n\tudf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);\n\tbrelse(bh);\n\n\tup_read(&iinfo->i_data_sem);\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\n\nout:\n\tup_read(&iinfo->i_data_sem);\n\tSetPageError(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn err;\n}",
        "output": "1",
        "idx": 2734
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args)\n{\n\tstruct cil_args_build *args = extra_args;\n\tstruct cil_tree_node *ast = args->ast;\n\n\tif (ast->flavor == CIL_ROOT) {\n\t\treturn SEPOL_OK;\n\t}\n\n\targs->ast = ast->parent;\n\n\tif (ast->flavor == CIL_TUNABLEIF) {\n\t\targs->tunif = NULL;\n\t}\n\n\tif (ast->flavor == CIL_IN) {\n\t\targs->in = NULL;\n\t}\n\n\tif (ast->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t}\n\n\tif (ast->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *n = ast->parent;\n\t\targs->optional = NULL;\n\t\twhile (n && n->flavor != CIL_ROOT) {\n\t\t\tif (n->flavor == CIL_OPTIONAL) {\n\t\t\t\targs->optional = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn = n->parent;\n\t\t}\n\t}\n\n\tif (ast->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t}\n\n\tcil_tree_children_destroy(parse_current->parent);\n\n\treturn SEPOL_OK;\n}",
        "output": "0",
        "idx": 8487
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void coerce_reg_to_size(struct bpf_reg_state *reg, int size)\n{\n\tu64 mask;\n\n\treg->var_off = tnum_cast(reg->var_off, size);\n\n\tmask = ((u64)1 << (size * 8)) - 1;\n\tif ((reg->umin_value & ~mask) == (reg->umax_value & ~mask)) {\n\t\treg->umin_value &= mask;\n\t\treg->umax_value &= mask;\n\t} else {\n\t\treg->umin_value = 0;\n\t\treg->umax_value = mask;\n\t}\n\treg->smin_value = reg->umin_value;\n\treg->smax_value = reg->umax_value;\n}",
        "output": "0",
        "idx": 2607
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _perf_event_enable(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct task_struct *task = ctx->task;\n\n\tif (!task) {\n\t\tcpu_function_call(event->cpu, __perf_event_enable, event);\n\t\treturn;\n\t}\n\n\traw_spin_lock_irq(&ctx->lock);\n\tif (event->state >= PERF_EVENT_STATE_INACTIVE)\n\t\tgoto out;\n\n\tif (event->state == PERF_EVENT_STATE_ERROR)\n\t\tevent->state = PERF_EVENT_STATE_OFF;\n\nretry:\n\tif (!ctx->is_active) {\n\t\t__perf_event_mark_enabled(event);\n\t\tgoto out;\n\t}\n\n\traw_spin_unlock_irq(&ctx->lock);\n\n\tif (!task_function_call(task, __perf_event_enable, event))\n\t\treturn;\n\n\traw_spin_lock_irq(&ctx->lock);\n\n\tif (ctx->is_active && event->state == PERF_EVENT_STATE_OFF) {\n\t\ttask = ctx->task;\n\t\tgoto retry;\n\t}\n\nout:\n\traw_spin_unlock_irq(&ctx->lock);\n}",
        "output": "0",
        "idx": 3829
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "irc_nick_realloc_prefixes (struct t_irc_server *server,\n                           int old_length, int new_length)\n{\n    struct t_irc_channel *ptr_channel;\n    struct t_irc_nick *ptr_nick;\n    char *new_prefixes;\n\n    for (ptr_channel = server->channels; ptr_channel;\n         ptr_channel = ptr_channel->next_channel)\n    {\n        for (ptr_nick = ptr_channel->nicks; ptr_nick;\n             ptr_nick = ptr_nick->next_nick)\n        {\n            if (ptr_nick->prefixes)\n            {\n                new_prefixes = realloc (ptr_nick->prefixes, new_length + 1);\n                if (new_prefixes)\n                {\n                    ptr_nick->prefixes = new_prefixes;\n                    if (new_length > old_length)\n                    {\n                        memset (ptr_nick->prefixes + old_length,\n                                ' ',\n                                new_length - old_length);\n                    }\n                    ptr_nick->prefixes[new_length] = '\\0';\n                }\n            }\n            else\n            {\n                ptr_nick->prefixes = malloc (new_length + 1);\n                if (ptr_nick->prefixes)\n                {\n                    memset (ptr_nick->prefixes, ' ', new_length);\n                    ptr_nick->prefixes[new_length] = '\\0';\n                }\n            }\n        }\n    }\n}",
        "output": "0",
        "idx": 8827
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n{\n\tgdImagePtr pim = 0, tim = im;\n\tint interlace, BitsPerPixel;\n\tinterlace = im->interlace;\n\tif (im->trueColor) {\n\t\tpim = gdImageCreatePaletteFromTrueColor(im, 1, 256);\n\t\tif (!pim) {\n\t\t\treturn 1;\n\t\t}\n\t\ttim = pim;\n\t}\n\tBitsPerPixel = colorstobpp(tim->colorsTotal);\n\tGIFEncode(\n\t\tout, tim->sx, tim->sy, tim->interlace, 0, tim->transparent, BitsPerPixel,\n\t\ttim->red, tim->green, tim->blue, tim);\n\tif (pim) {\n\t\tgdImageDestroy(\tpim);\n\t}\n\n    return 0;\n}",
        "output": "0",
        "idx": 5687
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "name_len(netdissect_options *ndo,\n         const unsigned char *s, const unsigned char *maxbuf)\n{\n    const unsigned char *s0 = s;\n    unsigned char c;\n\n    if (s >= maxbuf)\n\treturn(-1);\t\n    ND_TCHECK2(*s, 1);\n    c = *s;\n    if ((c & 0xC0) == 0xC0)\n\treturn(2);\n    while (*s) {\n\tif (s >= maxbuf)\n\t    return(-1);\t\n\tND_TCHECK2(*s, 1);\n\ts += (*s) + 1;\n\tND_TCHECK2(*s, 1);\n    }\n    return(PTR_DIFF(s, s0) + 1);\n\ntrunc:\n    return(-1);\t\n}",
        "output": "0",
        "idx": 6575
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, const nfs4_stateid *deleg_stateid, fmode_t fmode)\n{\n\twrite_seqlock(&state->seqlock);\n\tif (deleg_stateid != NULL) {\n\t\tmemcpy(state->stateid.data, deleg_stateid->data, sizeof(state->stateid.data));\n\t\tset_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n\tif (open_stateid != NULL)\n\t\tnfs_set_open_stateid_locked(state, open_stateid, fmode);\n\twrite_sequnlock(&state->seqlock);\n\tspin_lock(&state->owner->so_lock);\n\tupdate_open_stateflags(state, fmode);\n\tspin_unlock(&state->owner->so_lock);\n}",
        "output": "0",
        "idx": 3055
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void iwjpeg_scan_exif(struct iwjpegrcontext *rctx,\n\t\tconst iw_byte *d, size_t d_len)\n{\n\tstruct iw_exif_state e;\n\tiw_uint32 ifd;\n\n\tif(d_len<8) return;\n\n\tiw_zeromem(&e,sizeof(struct iw_exif_state));\n\te.d = d;\n\te.d_len = d_len;\n\n\te.endian = d[0]=='I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG;\n\n\tifd = iw_get_ui32_e(&d[4],e.endian);\n\n\tiwjpeg_scan_exif_ifd(rctx,&e,ifd);\n}",
        "output": "1",
        "idx": 6662
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    AVFilterContext *ctx = inlink->dst;\n    BoxBlurContext *s = ctx->priv;\n    AVFilterLink *outlink = inlink->dst->outputs[0];\n    AVFrame *out;\n    int plane;\n    int cw = FF_CEIL_RSHIFT(inlink->w, s->hsub), ch = FF_CEIL_RSHIFT(in->height, s->vsub);\n    int w[4] = { inlink->w, cw, cw, inlink->w };\n    int h[4] = { in->height, ch, ch, in->height };\n\n    out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n    if (!out) {\n        av_frame_free(&in);\n        return AVERROR(ENOMEM);\n    }\n    av_frame_copy_props(out, in);\n\n    for (plane = 0; in->data[plane] && plane < 4; plane++)\n        hblur(out->data[plane], out->linesize[plane],\n              in ->data[plane], in ->linesize[plane],\n              w[plane], h[plane], s->radius[plane], s->power[plane],\n              s->temp);\n\n    for (plane = 0; in->data[plane] && plane < 4; plane++)\n        vblur(out->data[plane], out->linesize[plane],\n              out->data[plane], out->linesize[plane],\n              w[plane], h[plane], s->radius[plane], s->power[plane],\n              s->temp);\n\n    av_frame_free(&in);\n\n    return ff_filter_frame(outlink, out);\n}",
        "output": "1",
        "idx": 3516
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sgi_clock_get(clockid_t clockid, struct timespec *tp)\n{\n\tu64 nsec;\n\n\tnsec = rtc_time() * sgi_clock_period\n\t\t\t+ sgi_clock_offset.tv_nsec;\n\ttp->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tp->tv_nsec)\n\t\t\t+ sgi_clock_offset.tv_sec;\n\treturn 0;\n};",
        "output": "1",
        "idx": 2094
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "njs_function_frame_invoke(njs_vm_t *vm, njs_value_t *retval)\n{\n    njs_native_frame_t  *frame;\n\n    frame = vm->top_frame;\n    frame->retval = retval;\n\n    if (njs_function_object_type(vm, frame->function)\n        == NJS_OBJ_TYPE_ASYNC_FUNCTION)\n    {\n        return njs_async_function_frame_invoke(vm, retval);\n    }\n\n    if (frame->native) {\n        return njs_function_native_call(vm);\n\n    } else {\n        return njs_function_lambda_call(vm);\n    }\n}",
        "output": "1",
        "idx": 8878
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "getlogin_r (name, name_len)\n     char *name;\n     size_t name_len;\n{\n  char tty_pathname[2 + 2 * NAME_MAX];\n  char *real_tty_path = tty_pathname;\n  int result = 0;\n  struct utmp *ut, line, buffer;\n\n\n  result = __ttyname_r (0, real_tty_path, sizeof (tty_pathname));\n  \n  if (result != 0)\n    return result;\n\n  real_tty_path += 5;\t\t\n\n  __setutent ();\n  strncpy (line.ut_line, real_tty_path, sizeof line.ut_line);\n  if (__getutline_r (&line, &buffer, &ut) < 0)\n    {\n      if (errno == ESRCH)\n\tresult = ENOENT;\n      else\n\tresult = errno;\n    }\n  else\n    {\n      size_t needed = strlen (ut->ut_user) + 1;\n\n      if (needed > name_len)\n\t{\n\t  __set_errno (ERANGE);\n\t  result = ERANGE;\n\t}\n      else\n\t{\n\t  memcpy (name, ut->ut_user, needed);\n\t  result = 0;\n\t}\n    }\n  __endutent ();\n\n  return result;\n}",
        "output": "0",
        "idx": 9
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rdp_read_flow_control_pdu(wStream* s, UINT16* type)\n{\n\t * http:\n\tUINT8 pduType;\n\tStream_Read_UINT8(s, pduType); \n\t*type = pduType;\n\tStream_Seek_UINT8(s);  \n\tStream_Seek_UINT8(s);  \n\tStream_Seek_UINT8(s);  \n\tStream_Seek_UINT16(s); \n}",
        "output": "1",
        "idx": 4134
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CAMLprim value caml_alloc_dummy(value size)\n{\n  mlsize_t wosize = Long_val(size);\n\n  if (wosize == 0) return Atom(0);\n  return caml_alloc (wosize, 0);\n}",
        "output": "0",
        "idx": 7717
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int prepare_binprm(struct linux_binprm *bprm)\n{\n\tint retval;\n\n\tbprm_fill_uid(bprm);\n\n\tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm->cred_prepared = 1;\n\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);\n}",
        "output": "0",
        "idx": 3929
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int raw_cmd_copyout(int cmd, void __user *param,\n\t\t\t\t  struct floppy_raw_cmd *ptr)\n{\n\tint ret;\n\n\twhile (ptr) {\n\t\tstruct floppy_raw_cmd cmd = *ptr;\n\t\tcmd.next = NULL;\n\t\tcmd.kernel_data = NULL;\n\t\tret = copy_to_user(param, &cmd, sizeof(cmd));\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tparam += sizeof(struct floppy_raw_cmd);\n\t\tif ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {\n\t\t\tif (ptr->length >= 0 &&\n\t\t\t    ptr->length <= ptr->buffer_length) {\n\t\t\t\tlong length = ptr->buffer_length - ptr->length;\n\t\t\t\tret = fd_copyout(ptr->data, ptr->kernel_data,\n\t\t\t\t\t\t length);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 3513
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint32_t GetPayloadTime(size_t handle, uint32_t index, float *in, float *out)\n{\n\tmp4object *mp4 = (mp4object *)handle;\n\tif (mp4 == NULL) return 0;\n\n\tif (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 1;\n\n\t*in = (float)((double)index * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n\t*out = (float)((double)(index + 1) * (double)mp4->basemetadataduration / (double)mp4->meta_clockdemon);\n\treturn 0;\n}",
        "output": "1",
        "idx": 7506
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int __close_fd_get_file(unsigned int fd, struct file **res)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\tstruct fdtable *fdt;\n\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (fd >= fdt->max_fds)\n\t\tgoto out_unlock;\n\tfile = fdt->fd[fd];\n\tif (!file)\n\t\tgoto out_unlock;\n\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n\tget_file(file);\n\t*res = file;\n\treturn filp_close(file, files);\n\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\t*res = NULL;\n\treturn -ENOENT;\n}",
        "output": "1",
        "idx": 8900
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_context_time(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tOM_uint32\t*time_rec)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_NO_CONTEXT);\n\n\tret = gss_context_time(minor_status,\n\t\t\t    sc->ctx_handle,\n\t\t\t    time_rec);\n\treturn (ret);\n}",
        "output": "0",
        "idx": 115
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ip_options_get_finish(struct net *net, struct ip_options_rcu **optp,\n\t\t\t\t struct ip_options_rcu *opt, int optlen)\n{\n\twhile (optlen & 3)\n\t\topt->opt.__data[optlen++] = IPOPT_END;\n\topt->opt.optlen = optlen;\n\tif (optlen && ip_options_compile(net, &opt->opt, NULL)) {\n\t\tkfree(opt);\n\t\treturn -EINVAL;\n\t}\n\tkfree(*optp);\n\t*optp = opt;\n\treturn 0;\n}",
        "output": "0",
        "idx": 487
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_event_comm_output(struct perf_event *event,\n\t\t\t\t     struct perf_comm_event *comm_event)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint size = comm_event->event_id.header.size;\n\tint ret;\n\n\tperf_event_header__init_id(&comm_event->event_id.header, &sample, event);\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tcomm_event->event_id.header.size, 0, 0);\n\n\tif (ret)\n\t\tgoto out;\n\n\tcomm_event->event_id.pid = perf_event_pid(event, comm_event->task);\n\tcomm_event->event_id.tid = perf_event_tid(event, comm_event->task);\n\n\tperf_output_put(&handle, comm_event->event_id);\n\t__output_copy(&handle, comm_event->comm,\n\t\t\t\t   comm_event->comm_size);\n\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\nout:\n\tcomm_event->event_id.header.size = size;\n}",
        "output": "1",
        "idx": 524
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "qedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t\tconst char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & QEDI_LOG_NOTICE))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_notice(\"[%s]:[%s:%d]:%d: %pV\",\n\t\t\t  dev_name(&qedi->pdev->dev), func, line,\n\t\t\t  qedi->host_no, &vaf);\n\telse\n\t\tpr_notice(\"[0000:00:00.0]:[%s:%d]: %pV\", func, line, &vaf);\n\nret:\n\tva_end(va);\n}",
        "output": "0",
        "idx": 4395
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SYSCALL_DEFINE1(timer_getoverrun, timer_t, timer_id)\n{\n\tstruct k_itimer *timr;\n\tint overrun;\n\tunsigned long flags;\n\n\ttimr = lock_timer(timer_id, &flags);\n\tif (!timr)\n\t\treturn -EINVAL;\n\n\toverrun = timr->it_overrun_last;\n\tunlock_timer(timr, flags);\n\n\treturn overrun;\n}",
        "output": "1",
        "idx": 2984
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int whiteheat_probe(struct usb_serial *serial,\n\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tsize_t num_bulk_in = 0;\n\tsize_t num_bulk_out = 0;\n\tsize_t min_num_bulk;\n\tunsigned int i;\n\n\tiface_desc = serial->interface->cur_altsetting;\n\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\t\tif (usb_endpoint_is_bulk_in(endpoint))\n\t\t\t++num_bulk_in;\n\t\tif (usb_endpoint_is_bulk_out(endpoint))\n\t\t\t++num_bulk_out;\n\t}\n\n\tmin_num_bulk = COMMAND_PORT + 1;\n\tif (num_bulk_in < min_num_bulk || num_bulk_out < min_num_bulk)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 4025
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)\n{\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\n\tif (info->si_code != SI_QUEUE) {\n\t\tWARN_ON_ONCE(info->si_code < 0);\n\t\treturn -EPERM;\n\t}\n\tinfo->si_signo = sig;\n\n\treturn do_send_specific(tgid, pid, sig, info);\n}",
        "output": "0",
        "idx": 383
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "decode_bytes_with_escapes(struct compiling *c, const node *n, const char *s,\n                          size_t len)\n{\n    return PyBytes_DecodeEscape(s, len, NULL, 0, NULL);\n}",
        "output": "1",
        "idx": 7774
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ext4_invalidatepage_free_endio(struct page *page, unsigned long offset)\n{\n\tstruct buffer_head *head, *bh;\n\tunsigned int curr_off = 0;\n\n\tif (!page_has_buffers(page))\n\t\treturn;\n\thead = bh = page_buffers(page);\n\tdo {\n\t\tif (offset <= curr_off && test_clear_buffer_uninit(bh)\n\t\t\t\t\t&& bh->b_private) {\n\t\t\text4_free_io_end(bh->b_private);\n\t\t\tbh->b_private = NULL;\n\t\t\tbh->b_end_io = NULL;\n\t\t}\n\t\tcurr_off = curr_off + bh->b_size;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}",
        "output": "0",
        "idx": 3171
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ext4_xattr_destroy_cache(struct mb_cache *cache)\n{\n\tif (cache)\n\t\tmb_cache_destroy(cache);\n}",
        "output": "1",
        "idx": 1088
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ntlm_read_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->Len > 0)\n\t{\n\t\tconst UINT64 offset = (UINT64)fields->BufferOffset + (UINT64)fields->Len;\n\n\t\tif (offset > Stream_Length(s))\n\t\t\treturn -1;\n\n\t\tfields->Buffer = (PBYTE) malloc(fields->Len);\n\n\t\tif (!fields->Buffer)\n\t\t\treturn -1;\n\n\t\tStream_SetPosition(s, fields->BufferOffset);\n\t\tStream_Read(s, fields->Buffer, fields->Len);\n\t}\n\n\treturn 1;\n}",
        "output": "0",
        "idx": 5795
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mspack_fmap_free(void *mem)\n{\n\tfree(mem);\n}",
        "output": "1",
        "idx": 3798
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\terr = security_sb_remount(sb, data);\n\tif (err)\n\t\treturn err;\n\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n\t\terr = do_remount_sb(sb, flags, data, 0);\n\tif (!err) {\n\t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;\n\t\tmnt->mnt.mnt_flags = mnt_flags;\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}",
        "output": "0",
        "idx": 3617
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseResources(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprJson     *child, *groups, *singletons, *sets;\n    int         ji;\n\n    if ((sets = mprGetJsonObj(prop, \"sets\")) != 0) {\n        for (ITERATE_CONFIG(route, sets, child, ji)) {\n            httpAddRouteSet(route, child->value);\n        }\n    }\n    if ((groups = mprGetJsonObj(prop, \"groups\")) != 0) {\n        for (ITERATE_CONFIG(route, groups, child, ji)) {\n            httpAddResourceGroup(route, route->serverPrefix, child->value);\n        }\n    }\n    if ((singletons = mprGetJsonObj(prop, \"singletons\")) != 0) {\n        for (ITERATE_CONFIG(route, singletons, child, ji)) {\n            httpAddResource(route, route->serverPrefix, child->value);\n        }\n    }\n}",
        "output": "1",
        "idx": 5022
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_timer_user_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\n\tif (file->private_data) {\n\t\ttu = file->private_data;\n\t\tfile->private_data = NULL;\n\t\tmutex_lock(&tu->ioctl_lock);\n\t\tif (tu->timeri)\n\t\t\tsnd_timer_close(tu->timeri);\n\t\tmutex_unlock(&tu->ioctl_lock);\n\t\tkfree(tu->queue);\n\t\tkfree(tu->tqueue);\n\t\tkfree(tu);\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 1527
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BYTE get_cbr2_bpp(UINT32 bpp, BOOL* pValid)\n{\n\tif (pValid)\n\t\t*pValid = TRUE;\n\tswitch (bpp)\n\t{\n\t\tcase 3:\n\t\t\treturn 8;\n\t\tcase 4:\n\t\t\treturn 16;\n\t\tcase 5:\n\t\t\treturn 24;\n\t\tcase 6:\n\t\t\treturn 32;\n\t\tdefault:\n\t\t\tWLog_WARN(TAG, \"Invalid bpp %\" PRIu32, bpp);\n\t\t\tif (pValid)\n\t\t\t\t*pValid = FALSE;\n\t\t\treturn 0;\n\t}\n}",
        "output": "0",
        "idx": 5779
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *lxclock_name(const char *p, const char *n)\n{\n\tint ret;\n\tint len;\n\tchar *dest;\n\tchar *rundir;\n\n\n\tlen = strlen(\"/lxc/lock/\") + strlen(n) + strlen(p) + 3;\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn NULL;\n\tlen += strlen(rundir);\n\n\tif ((dest = malloc(len)) == NULL) {\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\n\tret = snprintf(dest, len, \"%s/lxc/lock/%s\", rundir, p);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = mkdir_p(dest, 0755);\n\tif (ret < 0) {\n\t\tfree(dest);\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\n\tret = snprintf(dest, len, \"%s/lxc/lock/%s/.%s\", rundir, p, n);\n\tfree(rundir);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\treturn NULL;\n\t}\n\treturn dest;\n}",
        "output": "0",
        "idx": 6019
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sd_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tint max_packet_size;\n\n\tswitch (gspca_dev->pixfmt.width) {\n\tcase 160:\n\t\tmax_packet_size = 450;\n\t\tbreak;\n\tcase 176:\n\t\tmax_packet_size = 600;\n\t\tbreak;\n\tdefault:\n\t\tmax_packet_size = 1022;\n\t\tbreak;\n\t}\n\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(max_packet_size);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 3328
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int bpf_adj_delta_to_imm(struct bpf_insn *insn, u32 pos, u32 delta,\n\t\t\t\tu32 curr, const bool probe_pass)\n{\n\tconst s64 imm_min = S32_MIN, imm_max = S32_MAX;\n\ts64 imm = insn->imm;\n\n\tif (curr < pos && curr + imm + 1 > pos)\n\t\timm += delta;\n\telse if (curr > pos + delta && curr + imm + 1 <= pos + delta)\n\t\timm -= delta;\n\tif (imm < imm_min || imm > imm_max)\n\t\treturn -ERANGE;\n\tif (!probe_pass)\n\t\tinsn->imm = imm;\n\treturn 0;\n}",
        "output": "0",
        "idx": 4089
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile)\n{\n\tsr->user_cr = smb_ofile_getcred(ofile);\n\n\tif ((ofile->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t(void) smb_fsop_commit(sr, sr->user_cr, ofile->f_node);\n}",
        "output": "1",
        "idx": 4898
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,\n\t\t\t      pte_t *ptep, pte_t pte)\n{\n\tif (pte_valid_ng(pte)) {\n\t\tif (!pte_special(pte) && pte_exec(pte))\n\t\t\t__sync_icache_dcache(pte, addr);\n\t\tif (pte_dirty(pte) && pte_write(pte))\n\t\t\tpte_val(pte) &= ~PTE_RDONLY;\n\t\telse\n\t\t\tpte_val(pte) |= PTE_RDONLY;\n\t}\n\n\tset_pte(ptep, pte);\n}",
        "output": "1",
        "idx": 2572
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init mb2cache_init(void)\n{\n\tmb2_entry_cache = kmem_cache_create(\"mbcache\",\n\t\t\t\tsizeof(struct mb2_cache_entry), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD, NULL);\n\tBUG_ON(!mb2_entry_cache);\n\treturn 0;\n}",
        "output": "0",
        "idx": 1613
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int pmd_present(pmd_t pmd)\n{\n\treturn pmd_flags(pmd) & _PAGE_PRESENT;\n}",
        "output": "1",
        "idx": 778
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t bat_socket_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct socket_packet *socket_packet;\n\tsize_t packet_len;\n\tint error;\n\n\tif ((file->f_flags & O_NONBLOCK) && (socket_client->queue_len == 0))\n\t\treturn -EAGAIN;\n\n\tif ((!buf) || (count < sizeof(struct icmp_packet)))\n\t\treturn -EINVAL;\n\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\n\terror = wait_event_interruptible(socket_client->queue_wait,\n\t\t\t\t\t socket_client->queue_len);\n\n\tif (error)\n\t\treturn error;\n\n\tspin_lock_bh(&socket_client->lock);\n\n\tsocket_packet = list_first_entry(&socket_client->queue_list,\n\t\t\t\t\t struct socket_packet, list);\n\tlist_del(&socket_packet->list);\n\tsocket_client->queue_len--;\n\n\tspin_unlock_bh(&socket_client->lock);\n\n\tpacket_len = min(count, socket_packet->icmp_len);\n\terror = copy_to_user(buf, &socket_packet->icmp_packet, packet_len);\n\n\tkfree(socket_packet);\n\n\tif (error)\n\t\treturn -EFAULT;\n\n\treturn packet_len;\n}",
        "output": "0",
        "idx": 837
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_cipher rcipher;\n\n\tsnprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"cipher\");\n\n\trcipher.blocksize = alg->cra_blocksize;\n\trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n\trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\n\t\t    sizeof(struct crypto_report_cipher), &rcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "1",
        "idx": 856
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "expr_context_name(expr_context_ty ctx)\n{\n    switch (ctx) {\n    case Load:\n        return \"Load\";\n    case Store:\n        return \"Store\";\n    case Del:\n        return \"Del\";\n    case AugLoad:\n        return \"AugLoad\";\n    case AugStore:\n        return \"AugStore\";\n    case Param:\n        return \"Param\";\n    default:\n        assert(0);\n        return \"(unknown)\";\n    }\n}",
        "output": "1",
        "idx": 7736
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rtl8xxxu_submit_int_urb(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct urb *urb;\n\tu32 val32;\n\tint ret;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tusb_fill_int_urb(urb, priv->udev, priv->pipe_interrupt,\n\t\t\t priv->int_buf, USB_INTR_CONTENT_LENGTH,\n\t\t\t rtl8xxxu_int_complete, priv, 1);\n\tusb_anchor_urb(urb, &priv->int_anchor);\n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret) {\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_urb(urb);\n\t\tgoto error;\n\t}\n\n\tval32 = rtl8xxxu_read32(priv, REG_USB_HIMR);\n\tval32 |= USB_HIMR_CPWM;\n\trtl8xxxu_write32(priv, REG_USB_HIMR, val32);\n\nerror:\n\treturn ret;\n}",
        "output": "0",
        "idx": 4511
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void hostap_setup_dev(struct net_device *dev, local_info_t *local,\n\t\t      int type)\n{\n\tstruct hostap_interface *iface;\n\n\tiface = netdev_priv(dev);\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\n\tif (iface) {\n\t\tiface->wireless_data.spy_data = &iface->spy_data;\n\t\tdev->wireless_data = &iface->wireless_data;\n\t}\n\tdev->wireless_handlers = &hostap_iw_handler_def;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\n\tswitch(type) {\n\tcase HOSTAP_INTERFACE_AP:\n\t\tdev->tx_queue_len = 0;\t\n\t\tdev->netdev_ops = &hostap_mgmt_netdev_ops;\n\t\tdev->type = ARPHRD_IEEE80211;\n\t\tdev->header_ops = &hostap_80211_ops;\n\t\tbreak;\n\tcase HOSTAP_INTERFACE_MASTER:\n\t\tdev->netdev_ops = &hostap_master_ops;\n\t\tbreak;\n\tdefault:\n\t\tdev->tx_queue_len = 0;\t\n\t\tdev->netdev_ops = &hostap_netdev_ops;\n\t}\n\n\tdev->mtu = local->mtu;\n\n\n\tSET_ETHTOOL_OPS(dev, &prism2_ethtool_ops);\n\n}",
        "output": "0",
        "idx": 757
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int check_symlink(int fd)\n{\n\tstruct stat sb;\n\tint ret = fstat(fd, &sb);\n\tif (ret < 0)\n\t\treturn -ENOENT;\n\tif (S_ISLNK(sb.st_mode))\n\t\treturn -ELOOP;\n\treturn 0;\n}",
        "output": "0",
        "idx": 6055
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "setup_secureChannel(void) {\n    TestingPolicy(&dummyPolicy, dummyCertificate, &fCalled, &keySizes);\n    UA_SecureChannel_init(&testChannel, &UA_ConnectionConfig_default);\n    UA_SecureChannel_setSecurityPolicy(&testChannel, &dummyPolicy, &dummyCertificate);\n\n    testingConnection = createDummyConnection(65535, &sentData);\n    UA_Connection_attachSecureChannel(&testingConnection, &testChannel);\n    testChannel.connection = &testingConnection;\n\n    testChannel.state = UA_SECURECHANNELSTATE_OPEN;\n}",
        "output": "1",
        "idx": 8394
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static const char *tls_dns_name(const GENERAL_NAME * gn)\n{\n\tconst char *dnsname;\n\n\tif (ASN1_STRING_type(gn->d.ia5) != V_ASN1_IA5STRING) {\n\t\tg_warning(\"Invalid ASN1 value type in subjectAltName\");\n\t\treturn NULL;\n\t}\n\n\tdnsname = (char *) ASN1_STRING_data(gn->d.ia5);\n\n\tif (has_internal_nul(dnsname, ASN1_STRING_length(gn->d.ia5))) {\n\t\tg_warning(\"Internal NUL in subjectAltName\");\n\t\treturn NULL;\n\t}\n\n\treturn dnsname;\n}",
        "output": "0",
        "idx": 4671
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int on_header_value(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (at && length) {\n        SWITCH(data->header_field)\n        CASE(OGS_SBI_CONTENT_TYPE)\n            if (data->part[data->num_of_part].content_type)\n                ogs_free(data->part[data->num_of_part].content_type);\n            data->part[data->num_of_part].content_type =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_type);\n            break;\n        CASE(OGS_SBI_CONTENT_ID)\n            if (data->part[data->num_of_part].content_id)\n                ogs_free(data->part[data->num_of_part].content_id);\n            data->part[data->num_of_part].content_id =\n                ogs_strndup(at, length);\n            ogs_assert(data->part[data->num_of_part].content_id);\n            break;\n\n        DEFAULT\n            ogs_error(\"Unknown header field [%s]\", data->header_field);\n        END\n    }\n\n    return 0;\n}",
        "output": "1",
        "idx": 8852
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct mb2_cache_entry *mb2_cache_entry_find_first(struct mb2_cache *cache,\n\t\t\t\t\t\t   u32 key)\n{\n\treturn __entry_find(cache, NULL, key);\n}",
        "output": "0",
        "idx": 1607
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ssh_packet_set_postauth(struct ssh *ssh)\n{\n\tint r;\n\n\tdebug(\"%s: called\", __func__);\n\tssh->state->after_authentication = 1;\n\tssh->state->rekeying = 0;\n\tif ((r = ssh_packet_enable_delayed_compress(ssh)) != 0)\n\t\treturn r;\n\treturn 0;\n}",
        "output": "0",
        "idx": 7781
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "NOEXPORT int init_section(int eof, SERVICE_OPTIONS **section_ptr) {\n    char *errstr;\n\n#ifndef USE_WIN32\n    (*section_ptr)->option.log_stderr=new_global_options.option.log_stderr;\n#endif \n\n    if(*section_ptr==&new_service_options) {\n        errstr=parse_global_option(CMD_INITIALIZE, NULL, NULL);\n        if(errstr) {\n            s_log(LOG_ERR, \"Global options: %s\", errstr);\n            return 1;\n        }\n    }\n\n    if(*section_ptr!=&new_service_options || eof) {\n        if(*section_ptr==&new_service_options)\n            s_log(LOG_INFO, \"Initializing inetd mode configuration\");\n        else\n            s_log(LOG_INFO, \"Initializing service [%s]\",\n                (*section_ptr)->servname);\n        errstr=parse_service_option(CMD_INITIALIZE, section_ptr, NULL, NULL);\n        if(errstr) {\n            if(*section_ptr==&new_service_options)\n                s_log(LOG_ERR, \"Inetd mode: %s\", errstr);\n            else\n                s_log(LOG_ERR, \"Service [%s]: %s\",\n                    (*section_ptr)->servname, errstr);\n            return 1;\n        }\n    }\n    return 0;\n}",
        "output": "1",
        "idx": 8452
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_Unpickler_ResizeMemoList(UnpicklerObject *self, Py_ssize_t new_size)\n{\n    Py_ssize_t i;\n\n    assert(new_size > self->memo_size);\n\n    PyObject **memo_new = self->memo;\n    PyMem_RESIZE(memo_new, PyObject *, new_size);\n    if (memo_new == NULL) {\n        PyErr_NoMemory();\n        return -1;\n    }\n    self->memo = memo_new;\n    for (i = self->memo_size; i < new_size; i++)\n        self->memo[i] = NULL;\n    self->memo_size = new_size;\n    return 0;\n}",
        "output": "1",
        "idx": 7152
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ion_handle_put(struct ion_handle *handle)\n{\n\tstruct ion_client *client = handle->client;\n\tint ret;\n\n\tmutex_lock(&client->lock);\n\tret = kref_put(&handle->ref, ion_handle_destroy);\n\tmutex_unlock(&client->lock);\n\n\treturn ret;\n}",
        "output": "1",
        "idx": 1152
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u64 distribute_cfs_runtime(struct cfs_bandwidth *cfs_b,\n\t\tu64 remaining, u64 expires)\n{\n\tstruct cfs_rq *cfs_rq;\n\tu64 runtime;\n\tu64 starting_runtime = remaining;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(cfs_rq, &cfs_b->throttled_cfs_rq,\n\t\t\t\tthrottled_list) {\n\t\tstruct rq *rq = rq_of(cfs_rq);\n\t\tstruct rq_flags rf;\n\n\t\trq_lock_irqsave(rq, &rf);\n\t\tif (!cfs_rq_throttled(cfs_rq))\n\t\t\tgoto next;\n\n\t\truntime = -cfs_rq->runtime_remaining + 1;\n\t\tif (runtime > remaining)\n\t\t\truntime = remaining;\n\t\tremaining -= runtime;\n\n\t\tcfs_rq->runtime_remaining += runtime;\n\t\tcfs_rq->runtime_expires = expires;\n\n\t\tif (cfs_rq->runtime_remaining > 0)\n\t\t\tunthrottle_cfs_rq(cfs_rq);\n\nnext:\n\t\trq_unlock_irqrestore(rq, &rf);\n\n\t\tif (!remaining)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn starting_runtime - remaining;\n}",
        "output": "1",
        "idx": 3216
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\n\tmutex_lock(&ue->card->user_ctl_lock);\n\tmemcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);\n\tmutex_unlock(&ue->card->user_ctl_lock);\n\treturn 0;\n}",
        "output": "0",
        "idx": 3579
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "size_t compile_tree(struct filter_op **fop)\n{\n   int i = 1;\n   struct filter_op *array = NULL;\n   struct unfold_elm *ue;\n\n   BUG_IF(tree_root == NULL);\n  \n   fprintf(stdout, \" Unfolding the meta-tree \");\n   fflush(stdout);\n     \n   unfold_blk(&tree_root);\n\n   fprintf(stdout, \" done.\\n\\n\");\n\n   labels_to_offsets();\n   \n   TAILQ_FOREACH(ue, &unfolded_tree, next) {\n\n      if (ue->label == 0) {\n         SAFE_REALLOC(array, i * sizeof(struct filter_op));\n         memcpy(&array[i - 1], &ue->fop, sizeof(struct filter_op));\n         i++;\n      }\n   }\n   \n   SAFE_REALLOC(array, i * sizeof(struct filter_op));\n   array[i - 1].opcode = FOP_EXIT;\n   \n   *fop = array;\n   \n   return (i);\n}",
        "output": "1",
        "idx": 6560
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "CAMLprim value caml_alloc_dummy_float (value size)\n{\n  mlsize_t wosize = Long_val(size) * Double_wosize;\n\n  if (wosize == 0) return Atom(0);\n  return caml_alloc (wosize, 0);\n}",
        "output": "0",
        "idx": 7719
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ext4_invalidatepage(struct page *page, unsigned long offset)\n{\n\tjournal_t *journal = EXT4_JOURNAL(page->mapping->host);\n\n\tif (ext4_should_dioread_nolock(page->mapping->host))\n\t\text4_invalidatepage_free_endio(page, offset);\n\tif (offset == 0)\n\t\tClearPageChecked(page);\n\n\tif (journal)\n\t\tjbd2_journal_invalidatepage(journal, page, offset);\n\telse\n\t\tblock_invalidatepage(page, offset);\n}",
        "output": "0",
        "idx": 3187
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_export_sec_context(\n\t\t\t    OM_uint32\t  *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t interprocess_token)\n{\n\tOM_uint32 ret;\n\tret = gss_export_sec_context(minor_status,\n\t\t\t\t    context_handle,\n\t\t\t\t    interprocess_token);\n\treturn (ret);\n}",
        "output": "1",
        "idx": 90
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int yr_object_array_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    int index)\n{\n  YR_OBJECT_ARRAY* array;\n\n  int i;\n  int count;\n\n  assert(index >= 0);\n  assert(object->type == OBJECT_TYPE_ARRAY);\n\n  array = object_as_array(object);\n\n  if (array->items == NULL)\n  {\n    count = yr_max(64, (index + 1) * 2);\n\n    array->items = (YR_ARRAY_ITEMS*) yr_malloc(\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));\n\n    array->items->count = count;\n  }\n  else if (index >= array->items->count)\n  {\n    count = array->items->count * 2;\n    array->items = (YR_ARRAY_ITEMS*) yr_realloc(\n        array->items,\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    for (i = array->items->count; i < count; i++)\n      array->items->objects[i] = NULL;\n\n    array->items->count = count;\n  }\n\n  item->parent = object;\n  array->items->objects[index] = item;\n\n  return ERROR_SUCCESS;\n}",
        "output": "1",
        "idx": 5666
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ast2obj_comprehension(void* _o)\n{\n    comprehension_ty o = (comprehension_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n\n    result = PyType_GenericNew(comprehension_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_expr(o->target);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_target, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_expr(o->iter);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_iter, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_list(o->ifs, ast2obj_expr);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_ifs, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_int(o->is_async);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_is_async, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    return result;\nfailed:\n    Py_XDECREF(value);\n    Py_XDECREF(result);\n    return NULL;\n}",
        "output": "1",
        "idx": 7722
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct uvesafb_pal_entry *entries;\n\tint shift = 16 - dac_width;\n\tint i, err = 0;\n\n\tif (info->var.bits_per_pixel == 8) {\n\t\tif (cmap->start + cmap->len > info->cmap.start +\n\t\t    info->cmap.len || cmap->start < info->cmap.start)\n\t\t\treturn -EINVAL;\n\n\t\tentries = kmalloc_array(cmap->len, sizeof(*entries),\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!entries)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\tentries[i].red   = cmap->red[i]   >> shift;\n\t\t\tentries[i].green = cmap->green[i] >> shift;\n\t\t\tentries[i].blue  = cmap->blue[i]  >> shift;\n\t\t\tentries[i].pad   = 0;\n\t\t}\n\t\terr = uvesafb_setpalette(entries, cmap->len, cmap->start, info);\n\t\tkfree(entries);\n\t} else {\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\terr |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],\n\t\t\t\t\t\tcmap->green[i], cmap->blue[i],\n\t\t\t\t\t\t0, info);\n\t\t}\n\t}\n\treturn err;\n}",
        "output": "0",
        "idx": 4115
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void init_once(void *foo)\n{\n\tstruct ext4_inode_info *ei = (struct ext4_inode_info *) foo;\n\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\tinit_rwsem(&ei->xattr_sem);\n\tinit_rwsem(&ei->i_data_sem);\n\tinit_rwsem(&ei->i_mmap_sem);\n\tinode_init_once(&ei->vfs_inode);\n}",
        "output": "0",
        "idx": 1453
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "snmp_ber_decode_type(unsigned char *buff, uint32_t *buff_len, uint8_t *type)\n{\n  if(*buff_len == 0) {\n    return NULL;\n  }\n\n  *type = *buff++;\n  (*buff_len)--;\n\n  return buff;\n}",
        "output": "1",
        "idx": 7956
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index)\n{\n\tmp4object *mp4 = (mp4object *)handle;\n\tif (mp4 == NULL) return NULL;\n\n\tuint32_t *MP4buffer = NULL;\n\tif (index < mp4->indexcount && mp4->mediafp)\n\t{\n\t\tMP4buffer = (uint32_t *)realloc((void *)lastpayload, mp4->metasizes[index]);\n\n\t\tif (MP4buffer)\n\t\t{\n\t\t\tLONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);\n\t\t\tfread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);\n\t\t\treturn MP4buffer;\n\t\t}\n\t}\n\treturn NULL;\n}",
        "output": "1",
        "idx": 7498
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}",
        "output": "0",
        "idx": 8295
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t _epoll_read(oe_fd_t* epoll_, void* buf, size_t count)\n{\n    ssize_t ret = -1;\n    epoll_t* file = _cast_epoll(epoll_);\n\n    oe_errno = 0;\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_read_ocall(&ret, file->host_fd, buf, count) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}",
        "output": "1",
        "idx": 8014
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "__u32 secure_ip_id(__be32 daddr)\n{\n\tstruct keydata *keyptr;\n\t__u32 hash[4];\n\n\tkeyptr = get_keyptr();\n\n\thash[0] = (__force __u32)daddr;\n\thash[1] = keyptr->secret[9];\n\thash[2] = keyptr->secret[10];\n\thash[3] = keyptr->secret[11];\n\n\treturn half_md4_transform(hash, keyptr->secret);\n}",
        "output": "1",
        "idx": 604
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void record_recent_object(struct object *obj,\n\t\t\t\t struct strbuf *path,\n\t\t\t\t const char *last,\n\t\t\t\t void *data)\n{\n\tsha1_array_append(&recent_objects, obj->oid.hash);\n}",
        "output": "1",
        "idx": 5186
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t\t  const struct flowi6 *fl6)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt;\n\n\tif (!dst)\n\t\tgoto out;\n\n\tif (dst->ops->family != AF_INET6) {\n\t\tdst_release(dst);\n\t\treturn NULL;\n\t}\n\n\trt = (struct rt6_info *)dst;\n\tif (ip6_rt_check(&rt->rt6i_dst, &fl6->daddr, np->daddr_cache) ||\n#ifdef CONFIG_IPV6_SUBTREES\n\t    ip6_rt_check(&rt->rt6i_src, &fl6->saddr, np->saddr_cache) ||\n#endif\n\t    (fl6->flowi6_oif && fl6->flowi6_oif != dst->dev->ifindex)) {\n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\n\nout:\n\treturn dst;\n}",
        "output": "0",
        "idx": 3265
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.pv_time_enabled = false;\n}",
        "output": "0",
        "idx": 1245
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rpcomp;\n\n\tsnprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"pcomp\");\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rpcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "1",
        "idx": 858
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "magic_getparam(struct magic_set *ms, int param, void *val)\n{\n\tswitch (param) {\n\tcase MAGIC_PARAM_INDIR_MAX:\n\t\t*(size_t *)val = ms->indir_max;\n\t\treturn 0;\n\tcase MAGIC_PARAM_NAME_MAX:\n\t\t*(size_t *)val = ms->name_max;\n\t\treturn 0;\n\tcase MAGIC_PARAM_ELF_PHNUM_MAX:\n\t\t*(size_t *)val = ms->elf_phnum_max;\n\t\treturn 0;\n\tcase MAGIC_PARAM_ELF_SHNUM_MAX:\n\t\t*(size_t *)val = ms->elf_shnum_max;\n\t\treturn 0;\n\tcase MAGIC_PARAM_ELF_NOTES_MAX:\n\t\t*(size_t *)val = ms->elf_notes_max;\n\t\treturn 0;\n\tdefault:\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n}",
        "output": "0",
        "idx": 6125
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int simulate_llsc(struct pt_regs *regs, unsigned int opcode)\n{\n\tif ((opcode & OPCODE) == LL) {\n\t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n\t\t\t\t1, regs, 0);\n\t\treturn simulate_ll(regs, opcode);\n\t}\n\tif ((opcode & OPCODE) == SC) {\n\t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n\t\t\t\t1, regs, 0);\n\t\treturn simulate_sc(regs, opcode);\n\t}\n\n\treturn -1;\t\t\t\n}",
        "output": "0",
        "idx": 589
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct phy *serdes_simple_xlate(struct device *dev,\n\t\t\t\t       struct of_phandle_args *args)\n{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tport = args->args[0];\n\tidx = args->args[1];\n\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\n\t\tif (idx != SERDES6G(0) && macro->port >= 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\n\t\tmacro->port = port;\n\t\treturn ctrl->phys[i];\n\t}\n\n\treturn ERR_PTR(-ENODEV);\n}",
        "output": "1",
        "idx": 3022
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dev_load(struct net *net, const char *name)\n{\n\tstruct net_device *dev;\n\n\trcu_read_lock();\n\tdev = dev_get_by_name_rcu(net, name);\n\trcu_read_unlock();\n\n\tif (!dev && capable(CAP_NET_ADMIN))\n\t\trequest_module(\"%s\", name);\n}",
        "output": "1",
        "idx": 256
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Huff_Compress(msg_t *mbuf, int offset) {\n\tint\t\t\ti, ch, size;\n\tbyte\t\tseq[65536];\n\tbyte*\t\tbuffer;\n\thuff_t\t\thuff;\n\n\tsize = mbuf->cursize - offset;\n\tbuffer = mbuf->data+ + offset;\n\n\tif (size<=0) {\n\t\treturn;\n\t}\n\n\tCom_Memset(&huff, 0, sizeof(huff_t));\n\thuff.tree = huff.lhead = huff.loc[NYT] =  &(huff.nodeList[huff.blocNode++]);\n\thuff.tree->symbol = NYT;\n\thuff.tree->weight = 0;\n\thuff.lhead->next = huff.lhead->prev = NULL;\n\thuff.tree->parent = huff.tree->left = huff.tree->right = NULL;\n\n\tseq[0] = (size>>8);\n\tseq[1] = size&0xff;\n\n\tbloc = 16;\n\n\tfor (i=0; i<size; i++ ) {\n\t\tch = buffer[i];\n\t\tHuff_transmit(&huff, ch, seq);\t\t\t\t\t\t\n\t\tHuff_addRef(&huff, (byte)ch);\t\t\t\t\t\t\t\t\n\t}\n\n\tbloc += 8;\t\t\t\t\t\t\t\t\t\t\t\t\n\n\tmbuf->cursize = (bloc>>3) + offset;\n\tCom_Memcpy(mbuf->data+offset, seq, (bloc>>3));\n}",
        "output": "1",
        "idx": 6236
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned char *oidc_cache_hash_passphrase(request_rec *r,\n\t\tconst char *passphrase) {\n\n\tunsigned char *key = NULL;\n\tunsigned int key_len = 0;\n\toidc_jose_error_t err;\n\n\tif (oidc_jose_hash_bytes(r->pool, OIDC_JOSE_ALG_SHA256,\n\t\t\t(const unsigned char *) passphrase, strlen(passphrase), &key,\n\t\t\t&key_len, &err) == FALSE) {\n\t\toidc_error(r, \"oidc_jose_hash_bytes returned an error: %s\", err.text);\n\t\treturn NULL;\n\t}\n\n\treturn key;\n}",
        "output": "1",
        "idx": 7348
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    \"disallowed submodule name: %s\",\n\t\t\t\t    name);\n\tif (!strcmp(key, \"url\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_URL,\n\t\t\t\t    \"disallowed submodule url: %s\",\n\t\t\t\t    value);\n\tfree(name);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 7197
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, quality);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}",
        "output": "1",
        "idx": 4446
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateInt( int64_t num )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item ) {\n\t\titem->type = cJSON_Number;\n\t\titem->valuefloat = num;\n\t\titem->valueint = num;\n\t}\n\treturn item;\n}",
        "output": "1",
        "idx": 5940
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void pipe_advance(struct iov_iter *i, size_t size)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tstruct pipe_buffer *buf;\n\tint idx = i->idx;\n\tsize_t off = i->iov_offset, orig_sz;\n\t\n\tif (unlikely(i->count < size))\n\t\tsize = i->count;\n\torig_sz = size;\n\n\tif (size) {\n\t\tif (off) \n\t\t\tsize += off - pipe->bufs[idx].offset;\n\t\twhile (1) {\n\t\t\tbuf = &pipe->bufs[idx];\n\t\t\tif (size <= buf->len)\n\t\t\t\tbreak;\n\t\t\tsize -= buf->len;\n\t\t\tidx = next_idx(idx, pipe);\n\t\t}\n\t\tbuf->len = size;\n\t\ti->idx = idx;\n\t\toff = i->iov_offset = buf->offset + size;\n\t}\n\tif (off)\n\t\tidx = next_idx(idx, pipe);\n\tif (pipe->nrbufs) {\n\t\tint unused = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\twhile (idx != unused) {\n\t\t\tpipe_buf_release(pipe, &pipe->bufs[idx]);\n\t\t\tidx = next_idx(idx, pipe);\n\t\t\tpipe->nrbufs--;\n\t\t}\n\t}\n\ti->count -= orig_sz;\n}",
        "output": "1",
        "idx": 1430
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileInfo, getFileInfo)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_class_entry *ce = intern->info_class;\n\tzend_error_handling error_handling;\n\t\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n\t\tspl_filesystem_object_create_type(ht, intern, SPL_FS_INFO, ce, return_value TSRMLS_CC);\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}",
        "output": "1",
        "idx": 3928
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int secure_decrypt(void *data, unsigned int data_length, int is_signed)\n{\n\tat91_aes_key_size_t key_size;\n\tunsigned int cmac_key[8], cipher_key[8];\n\tunsigned int iv[AT91_AES_IV_SIZE_WORD];\n\tunsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];\n\tunsigned int fixed_length;\n\tconst unsigned int *cmac;\n\tint rc = -1;\n\n\tinit_keys(&key_size, cipher_key, cmac_key, iv);\n\n\tat91_aes_init();\n\n\tif (is_signed) {\n\t\tif (at91_aes_cmac(data_length, data, computed_cmac,\n\t\t\t\t  key_size, cmac_key))\n\t\t\tgoto exit;\n\n\t\tfixed_length = at91_aes_roundup(data_length);\n\t\tcmac = (const unsigned int *)((char *)data + fixed_length);\n\t\tif (memcmp(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))\n\t\t\tgoto exit;\n\t}\n\n\tif (at91_aes_cbc(data_length, data, data, 0,\n\t\t\t key_size, cipher_key, iv))\n\t\tgoto exit;\n\n\trc = 0;\nexit:\n\tat91_aes_cleanup();\n\n\tmemset(cmac_key, 0, sizeof(cmac_key));\n\tmemset(cipher_key, 0, sizeof(cipher_key));\n\tmemset(iv, 0, sizeof(iv));\n\n\treturn rc;\n}",
        "output": "1",
        "idx": 7864
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct ipv6_txoptions *ipv6_update_options(struct sock *sk,\n\t\t\t\t\t   struct ipv6_txoptions *opt)\n{\n\tif (inet_sk(sk)->is_icsk) {\n\t\tif (opt &&\n\t\t    !((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE)) &&\n\t\t    inet_sk(sk)->inet_daddr != LOOPBACK4_IPV6) {\n\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\t\t\ticsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;\n\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\t}\n\t}\n\topt = xchg((__force struct ipv6_txoptions **)&inet6_sk(sk)->opt,\n\t\t   opt);\n\tsk_dst_reset(sk);\n\n\treturn opt;\n}",
        "output": "0",
        "idx": 1411
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(DirectoryIterator, next)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tint skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern->u.dir.index++;\n\tdo {\n\t\tspl_filesystem_dir_read(intern TSRMLS_CC);\n\t} while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n\tif (intern->file_name) {\n\t\tefree(intern->file_name);\n\t\tintern->file_name = NULL;\n\t}\n}",
        "output": "1",
        "idx": 4004
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t ocfs2_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tget_block_t *get_block;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\tif (iocb->ki_pos + iter->count > i_size_read(inode) &&\n\t    !ocfs2_supports_append_dio(osb))\n\t\treturn 0;\n\n\tif (iov_iter_rw(iter) == READ)\n\t\tget_block = ocfs2_lock_get_block;\n\telse\n\t\tget_block = ocfs2_dio_wr_get_block;\n\n\treturn __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t    iter, get_block,\n\t\t\t\t    ocfs2_dio_end_io, NULL, 0);\n}",
        "output": "0",
        "idx": 2551
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC MprJson *mprLookupJsonValue(MprJson *obj, cchar *value)\n{\n    MprJson     *child;\n    int         i;\n\n    if (!obj || !value) {\n        return 0;\n    }\n    for (ITERATE_JSON(obj, child, i)) {\n        if (smatch(child->value, value)) {\n            return child;\n        }\n    }\n    return 0;\n}",
        "output": "1",
        "idx": 5108
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\tstruct msghdr *msg, size_t len, int noblock, int flags,\n\t\tint *addr_len)\n{\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\tstruct sockaddr_ieee802154 *saddr;\n\n\tsaddr = (struct sockaddr_ieee802154 *)msg->msg_name;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (saddr) {\n\t\tsaddr->family = AF_IEEE802154;\n\t\tsaddr->addr = mac_cb(skb)->sa;\n\t}\n\tif (addr_len)\n\t\t*addr_len = sizeof(*saddr);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (err)\n\t\treturn err;\n\treturn copied;\n}",
        "output": "1",
        "idx": 2402
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat)\n{\n\tND_PRINT((ndo, \"%u.%u\", (EXTRACT_16BITS(dat) >> 8),\n\t    (EXTRACT_16BITS(dat) & 0xff)));\n}",
        "output": "1",
        "idx": 4772
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "asmlinkage void do_ade(struct pt_regs *regs)\n{\n\tunsigned int __user *pc;\n\tmm_segment_t seg;\n\n\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS,\n\t\t\t1, 0, regs, regs->cp0_badvaddr);\n\tif ((regs->cp0_badvaddr == regs->cp0_epc) || (regs->cp0_epc & 0x1))\n\t\tgoto sigbus;\n\n\tpc = (unsigned int __user *) exception_epc(regs);\n\tif (user_mode(regs) && !test_thread_flag(TIF_FIXADE))\n\t\tgoto sigbus;\n\tif (unaligned_action == UNALIGNED_ACTION_SIGNAL)\n\t\tgoto sigbus;\n\telse if (unaligned_action == UNALIGNED_ACTION_SHOW)\n\t\tshow_registers(regs);\n\n\tseg = get_fs();\n\tif (!user_mode(regs))\n\t\tset_fs(KERNEL_DS);\n\temulate_load_store_insn(regs, (void __user *)regs->cp0_badvaddr, pc);\n\tset_fs(seg);\n\n\treturn;\n\nsigbus:\n\tdie_if_kernel(\"Kernel unaligned instruction access\", regs);\n\tforce_sig(SIGBUS, current);\n\n}",
        "output": "1",
        "idx": 436
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n\t\n\tobject->u.dir.index = 0;\n\tif (object->u.dir.dirp) {\n\t\tphp_stream_rewinddir(object->u.dir.dirp);\n\t}\n\tspl_filesystem_dir_read(object TSRMLS_CC);\n}",
        "output": "1",
        "idx": 3952
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __exit mb2cache_exit(void)\n{\n\tkmem_cache_destroy(mb2_entry_cache);\n}",
        "output": "0",
        "idx": 1609
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline __u32 secure_dccpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t\t\t  __be16 sport, __be16 dport   )\n{\n\treturn secure_tcpv6_sequence_number(saddr, daddr, sport, dport);\n}",
        "output": "1",
        "idx": 616
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned paravirt_patch_call(void *insnbuf,\n\t\t\t     const void *target, u16 tgt_clobbers,\n\t\t\t     unsigned long addr, u16 site_clobbers,\n\t\t\t     unsigned len)\n{\n\tstruct branch *b = insnbuf;\n\tunsigned long delta = (unsigned long)target - (addr+5);\n\n\tif (tgt_clobbers & ~site_clobbers)\n\t\treturn len;\t\n\tif (len < 5)\n\t\treturn len;\t\n\n\tb->opcode = 0xe8; \n\tb->delta = delta;\n\tBUILD_BUG_ON(sizeof(*b) != 5);\n\n\treturn 5;\n}",
        "output": "1",
        "idx": 3002
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned long lh_char_hash(const void *k)\n{\n\tstatic volatile int random_seed = -1;\n\n\tif (random_seed == -1) {\n\t\tint seed;\n\t\twhile ((seed = json_c_get_random_seed()) == -1);\n#if defined __GNUC__\n\t\t__sync_val_compare_and_swap(&random_seed, -1, seed);\n#elif defined _MSC_VER\n\t\tInterlockedCompareExchange(&random_seed, seed, -1);\n#else\n#warning \"racy random seed initializtion if used by multiple threads\"\n\t\trandom_seed = seed; \n#endif\n\t}\n\n\treturn hashlittle((const char*)k, strlen((const char*)k), random_seed); \n}",
        "output": "0",
        "idx": 5949
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int f2fs_swap_activate(struct swap_info_struct *sis, struct file *file,\n\t\t\t\tsector_t *span)\n{\n\tstruct inode *inode = file_inode(file);\n\tint ret;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (f2fs_readonly(F2FS_I_SB(inode)->sb))\n\t\treturn -EROFS;\n\n\tret = f2fs_convert_inline_inode(inode);\n\tif (ret)\n\t\treturn ret;\n\n\tret = check_swap_activate(file, sis->max);\n\tif (ret)\n\t\treturn ret;\n\n\tset_inode_flag(inode, FI_PIN_FILE);\n\tf2fs_precache_extents(inode);\n\tf2fs_update_time(F2FS_I_SB(inode), REQ_TIME);\n\treturn 0;\n}",
        "output": "0",
        "idx": 4421
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hns_gmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ARRAY_SIZE(g_gmac_stats_string);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1566
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int process_numeric_entity(const char **buf, unsigned *code_point)\n{\n\tlong code_l;\n\tint hexadecimal = (**buf == 'x' || **buf == 'X'); \n\tchar *endptr;\n\n\tif (hexadecimal && (**buf != '\\0'))\n\t\t(*buf)++;\n\t\t\t\n\tif ((hexadecimal && !isxdigit(**buf)) ||\n\t\t\t(!hexadecimal && !isdigit(**buf))) {\n\t\treturn FAILURE;\n\t}\n\n\tcode_l = strtol(*buf, &endptr, hexadecimal ? 16 : 10);\n\t*buf = endptr;\n\n\tif (**buf != ';')\n\t\treturn FAILURE;\n\n\tif (code_l > 0x10FFFFL)\n\t\treturn FAILURE;\n\n\tif (code_point != NULL)\n\t\t*code_point = (unsigned)code_l;\n\n\treturn SUCCESS;\n}",
        "output": "1",
        "idx": 3830
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\tstruct msghdr *msg, size_t len, int noblock, int flags,\n\t\tint *addr_len)\n{\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\tstruct sockaddr_ieee802154 *saddr;\n\n\tsaddr = (struct sockaddr_ieee802154 *)msg->msg_name;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (saddr) {\n\t\tsaddr->family = AF_IEEE802154;\n\t\tsaddr->addr = mac_cb(skb)->sa;\n\t\t*addr_len = sizeof(*saddr);\n\t}\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (err)\n\t\treturn err;\n\treturn copied;\n}",
        "output": "0",
        "idx": 3367
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool valid_filetype(char_u *val)\n{\n  for (char_u *s = val; *s != NUL; s++) {\n    if (!ASCII_ISALNUM(*s) && vim_strchr((char_u *)\".-_\", *s) == NULL) {\n      return false;\n    }\n  }\n  return true;\n}",
        "output": "0",
        "idx": 8195
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct ion_handle *ion_handle_get_by_id(struct ion_client *client,\n\t\t\t\t\t\tint id)\n{\n\tstruct ion_handle *handle;\n\n\tmutex_lock(&client->lock);\n\thandle = ion_handle_get_by_id_nolock(client, id);\n\tmutex_unlock(&client->lock);\n\n\treturn handle;\n}",
        "output": "0",
        "idx": 1687
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __exit ipgre_fini(void)\n{\n\trtnl_link_unregister(&ipgre_tap_ops);\n\trtnl_link_unregister(&ipgre_link_ops);\n\tif (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)\n\t\tprintk(KERN_INFO \"ipgre close: can't remove protocol\\n\");\n\tunregister_pernet_device(&ipgre_net_ops);\n}",
        "output": "0",
        "idx": 3137
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "auth_iochannel_watch (GIOChannel   *source,\n                      GIOCondition  condition,\n                      IceConn       ice_conn)\n{\n\n        GsmIceConnectionWatch *data;\n        gboolean               keep_going;\n\n        data = ice_conn->context;\n\n        switch (IceProcessMessages (ice_conn, NULL, NULL)) {\n        case IceProcessMessagesSuccess:\n                keep_going = TRUE;\n                break;\n        case IceProcessMessagesIOError:\n                g_debug (\"GsmXsmpServer: IceProcessMessages returned IceProcessMessagesIOError\");\n                free_ice_connection_watch (data);\n                disconnect_ice_connection (ice_conn);\n                keep_going = FALSE;\n                break;\n        case IceProcessMessagesConnectionClosed:\n                g_debug (\"GsmXsmpServer: IceProcessMessages returned IceProcessMessagesConnectionClosed\");\n                free_ice_connection_watch (data);\n                keep_going = FALSE;\n                break;\n        default:\n                g_assert_not_reached ();\n        }\n\n        return keep_going;\n}",
        "output": "0",
        "idx": 8727
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_bindmount(const char *path)\n{\n\tif (mount(path, path, \"none\", MS_BIND, NULL) == 0) {\n\t\tfprintf(stderr, \"leak at bind mount of %s\\n\", path);\n\t\texit(1);\n\t}\n}",
        "output": "0",
        "idx": 7267
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&\n\t\t    key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\n\t\tsecurity_key_free(key);\n\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\n\t\tkey_user_put(key->user);\n\n\t\tkfree(key->description);\n\n\t\tmemzero_explicit(key, sizeof(*key));\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}",
        "output": "1",
        "idx": 1720
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_link(const char *path)\n{\n\tchar *d = strdupa(path), *tmpname;\n\td = dirname(d);\n\tsize_t len = strlen(path) + 30;\n\ttmpname = alloca(len);\n\tsnprintf(tmpname, len, \"%s/%d\", d, (int)getpid());\n\n\tif (link(path, tmpname) == 0) {\n\t\tfprintf(stderr, \"leak at link of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at link of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n\n\tif (link(tmpname, path) == 0) {\n\t\tfprintf(stderr, \"leak at link (2) of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at link (2) of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}",
        "output": "0",
        "idx": 7295
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "alloc_limit_assert (char *fn_name, size_t size)\n{\n    if (alloc_limit && size > alloc_limit)\n    {\n\talloc_limit_failure (fn_name, size);\n\texit (-1);\n    }\n}",
        "output": "1",
        "idx": 6392
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n{\n    char *buffer=NULL;\n    int   n=0;\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);\n    if (length>0) {\n        buffer=malloc((uint64_t)length+1);\n        if (buffer!=NULL) {\n            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(cl);\n                if (buffer!=NULL) free(buffer);\n                return NULL;\n            }\n            buffer[length]=0;\n        }\n    }\n    return buffer;\n}",
        "output": "1",
        "idx": 6348
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline ut8 r_read_le8(const void *src) {\n\tif (!src) {\n\t\treturn UT8_MAX;\n\t}\n\treturn r_read_ble8 (src);\n}",
        "output": "0",
        "idx": 8599
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_PyMemoTable_ResizeTable(PyMemoTable *self, Py_ssize_t min_size)\n{\n    PyMemoEntry *oldtable = NULL;\n    PyMemoEntry *oldentry, *newentry;\n    Py_ssize_t new_size = MT_MINSIZE;\n    Py_ssize_t to_process;\n\n    assert(min_size > 0);\n\n    while (new_size < min_size && new_size > 0)\n        new_size <<= 1;\n    if (new_size <= 0) {\n        PyErr_NoMemory();\n        return -1;\n    }\n    assert((new_size & (new_size - 1)) == 0);\n\n    oldtable = self->mt_table;\n    self->mt_table = PyMem_NEW(PyMemoEntry, new_size);\n    if (self->mt_table == NULL) {\n        self->mt_table = oldtable;\n        PyErr_NoMemory();\n        return -1;\n    }\n    self->mt_allocated = new_size;\n    self->mt_mask = new_size - 1;\n    memset(self->mt_table, 0, sizeof(PyMemoEntry) * new_size);\n\n    to_process = self->mt_used;\n    for (oldentry = oldtable; to_process > 0; oldentry++) {\n        if (oldentry->me_key != NULL) {\n            to_process--;\n            newentry = _PyMemoTable_Lookup(self, oldentry->me_key);\n            newentry->me_key = oldentry->me_key;\n            newentry->me_value = oldentry->me_value;\n        }\n    }\n\n    PyMem_FREE(oldtable);\n    return 0;\n}",
        "output": "1",
        "idx": 7156
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct perf_event_context *perf_event_ctx_lock(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx;\n\nagain:\n\trcu_read_lock();\n\tctx = ACCESS_ONCE(event->ctx);\n\tif (!atomic_inc_not_zero(&ctx->refcount)) {\n\t\trcu_read_unlock();\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\n\tmutex_lock(&ctx->mutex);\n\tif (event->ctx != ctx) {\n\t\tmutex_unlock(&ctx->mutex);\n\t\tput_ctx(ctx);\n\t\tgoto again;\n\t}\n\n\treturn ctx;\n}",
        "output": "0",
        "idx": 3831
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static UINT drive_process_irp_write(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 Length;\n\tUINT64 Offset;\n\n\tif (!drive || !irp || !irp->input || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); \n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_seek(file, Offset))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_write(file, Stream_Pointer(irp->input), Length))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); \n\treturn irp->Complete(irp);\n}",
        "output": "1",
        "idx": 4150
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n\t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\n\tcomplete(&task->slow_task->completion);\n}",
        "output": "1",
        "idx": 3018
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p,\n                                  int *got_frame, uint8_t *data_start,\n                                  unsigned int data_size)\n{\n    WebPContext *s = avctx->priv_data;\n    AVPacket pkt;\n    int ret;\n\n    if (!s->initialized) {\n        ff_vp8_decode_init(avctx);\n        s->initialized = 1;\n    }\n    avctx->pix_fmt = s->has_alpha ? AV_PIX_FMT_YUVA420P : AV_PIX_FMT_YUV420P;\n    s->lossless = 0;\n\n    if (data_size > INT_MAX) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported chunk size\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    av_init_packet(&pkt);\n    pkt.data = data_start;\n    pkt.size = data_size;\n\n    ret = ff_vp8_decode_frame(avctx, p, got_frame, &pkt);\n    if (ret < 0)\n        return ret;\n\n    update_canvas_size(avctx, avctx->width, avctx->height);\n\n    if (s->has_alpha) {\n        ret = vp8_lossy_decode_alpha(avctx, p, s->alpha_data,\n                                     s->alpha_data_size);\n        if (ret < 0)\n            return ret;\n    }\n    return ret;\n}",
        "output": "0",
        "idx": 4863
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vhost_scsi_send_evt(struct vhost_scsi *vs,\n\t\t   struct vhost_scsi_tpg *tpg,\n\t\t   struct se_lun *lun,\n\t\t   u32 event,\n\t\t   u32 reason)\n{\n\tstruct vhost_scsi_evt *evt;\n\n\tevt = vhost_scsi_allocate_evt(vs, event, reason);\n\tif (!evt)\n\t\treturn;\n\n\tif (tpg && lun) {\n\t\tevt->event.lun[0] = 0x01;\n\t\tevt->event.lun[1] = tpg->tport_tpgt & 0xFF;\n\t\tif (lun->unpacked_lun >= 256)\n\t\t\tevt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;\n\t\tevt->event.lun[3] = lun->unpacked_lun & 0xFF;\n\t}\n\n\tllist_add(&evt->list, &vs->vs_event_list);\n\tvhost_work_queue(&vs->dev, &vs->vs_event_work);\n}",
        "output": "1",
        "idx": 2784
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n\n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    reason = malloc((uint64_t)reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n    free(reason);\n}",
        "output": "1",
        "idx": 6344
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int changedline (const Proto *p, int oldpc, int newpc) {\n  while (oldpc++ < newpc) {\n    if (p->lineinfo[oldpc] != 0)\n      return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));\n  }\n  return 0;  \n}",
        "output": "1",
        "idx": 8116
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "njs_promise_resolve(njs_vm_t *vm, njs_value_t *constructor, njs_value_t *x)\n{\n    njs_int_t                 ret;\n    njs_value_t               value;\n    njs_object_t              *object;\n    njs_promise_capability_t  *capability;\n\n    static const njs_value_t  string_constructor = njs_string(\"constructor\");\n\n    if (njs_is_object(x)) {\n        object = njs_object_proto_lookup(njs_object(x), NJS_PROMISE,\n                                         njs_object_t);\n\n        if (object != NULL) {\n            ret = njs_value_property(vm, x, njs_value_arg(&string_constructor),\n                                     &value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NULL;\n            }\n\n            if (njs_values_same(&value, constructor)) {\n                return njs_promise(x);\n            }\n        }\n    }\n\n    capability = njs_promise_new_capability(vm, constructor);\n    if (njs_slow_path(capability == NULL)) {\n        return NULL;\n    }\n\n    ret = njs_function_call(vm, njs_function(&capability->resolve),\n                            &njs_value_undefined, x, 1, &value);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return NULL;\n    }\n\n    return njs_promise(&capability->promise);\n}",
        "output": "1",
        "idx": 8868
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs4_return_incompatible_delegation(struct inode *inode, fmode_t fmode)\n{\n\tstruct nfs_delegation *delegation;\n\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation == NULL || (delegation->type & fmode) == fmode) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\tnfs_inode_return_delegation(inode);\n}",
        "output": "0",
        "idx": 3065
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool too_many_unix_fds(struct task_struct *p)\n{\n\tstruct user_struct *user = current_user();\n\n\tif (unlikely(user->unix_inflight > task_rlimit(p, RLIMIT_NOFILE)))\n\t\treturn !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN);\n\treturn false;\n}",
        "output": "0",
        "idx": 1501
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vapic_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint idx;\n\n\tif (!apic || !apic->vapic_addr)\n\t\treturn;\n\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_release_page_dirty(apic->vapic_page);\n\tmark_page_dirty(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n}",
        "output": "1",
        "idx": 2486
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool ieee80211_validate_radiotap_len(struct sk_buff *skb)\n{\n\tstruct ieee80211_radiotap_header *rthdr =\n\t\t(struct ieee80211_radiotap_header *)skb->data;\n\n\tif (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))\n\t\treturn false; \n\n\tif (unlikely(rthdr->it_version))\n\t\treturn false; \n\n\tif (unlikely(skb->len < ieee80211_get_radiotap_len(skb->data)))\n\t\treturn false; \n\n\treturn true;\n}",
        "output": "0",
        "idx": 2789
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mwifiex_pcie_alloc_cmdrsp_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct sk_buff *skb;\n\n\tskb = dev_alloc_skb(MWIFIEX_UPLD_SIZE);\n\tif (!skb) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Unable to allocate skb for command response data.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, MWIFIEX_UPLD_SIZE);\n\tif (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE,\n\t\t\t\t   PCI_DMA_FROMDEVICE)) {\n\t\tkfree_skb(skb);\n\t\treturn -1;\n\t}\n\n\tcard->cmdrsp_buf = skb;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 4539
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n\tint chan = sa->rc_channel;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->rc_bdaddr);\n\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\twrite_lock(&rfcomm_sk_list.lock);\n\n\tif (chan && __rfcomm_get_listen_sock_by_addr(chan, &sa->rc_bdaddr)) {\n\t\terr = -EADDRINUSE;\n\t} else {\n\t\tbacpy(&rfcomm_pi(sk)->src, &sa->rc_bdaddr);\n\t\trfcomm_pi(sk)->channel = chan;\n\t\tsk->sk_state = BT_BOUND;\n\t}\n\n\twrite_unlock(&rfcomm_sk_list.lock);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}",
        "output": "1",
        "idx": 2872
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\n\tif (!ext4_handle_valid(handle)) {\n\t\text4_put_nojournal(handle);\n\t\treturn 0;\n\t}\n\n\terr = handle->h_err;\n\tif (!handle->h_transaction) {\n\t\trc = jbd2_journal_stop(handle);\n\t\treturn err ? err : rc;\n\t}\n\n\tsb = handle->h_transaction->t_journal->j_private;\n\trc = jbd2_journal_stop(handle);\n\n\tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext4_std_error(sb, where, line, err);\n\treturn err;\n}",
        "output": "0",
        "idx": 4051
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct sem_array *sem_obtain_lock(struct ipc_namespace *ns, int id)\n{\n\tstruct kern_ipc_perm *ipcp;\n\tstruct sem_array *sma;\n\n\trcu_read_lock();\n\tipcp = ipc_obtain_object(&sem_ids(ns), id);\n\tif (IS_ERR(ipcp)) {\n\t\tsma = ERR_CAST(ipcp);\n\t\tgoto err;\n\t}\n\n\tspin_lock(&ipcp->lock);\n\n\tif (!ipcp->deleted)\n\t\treturn container_of(ipcp, struct sem_array, sem_perm);\n\n\tspin_unlock(&ipcp->lock);\n\tsma = ERR_PTR(-EINVAL);\nerr:\n\trcu_read_unlock();\n\treturn sma;\n}",
        "output": "1",
        "idx": 2256
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);\n\tif (pipe) {\n\t\tunsigned long pipe_bufs = PIPE_DEF_BUFFERS;\n\t\tstruct user_struct *user = get_current_user();\n\n\t\tif (!too_many_pipe_buffers_hard(user)) {\n\t\t\tif (too_many_pipe_buffers_soft(user))\n\t\t\t\tpipe_bufs = 1;\n\t\t\tpipe->bufs = kzalloc(sizeof(struct pipe_buffer) * pipe_bufs, GFP_KERNEL);\n\t\t}\n\n\t\tif (pipe->bufs) {\n\t\t\tinit_waitqueue_head(&pipe->wait);\n\t\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\t\tpipe->buffers = pipe_bufs;\n\t\t\tpipe->user = user;\n\t\t\taccount_pipe_buffers(pipe, 0, pipe_bufs);\n\t\t\tmutex_init(&pipe->mutex);\n\t\t\treturn pipe;\n\t\t}\n\t\tfree_uid(user);\n\t\tkfree(pipe);\n\t}\n\n\treturn NULL;\n}",
        "output": "0",
        "idx": 1563
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_syscall_exit(void *ignore, struct pt_regs *regs, long ret)\n{\n\tstruct syscall_metadata *sys_data;\n\tstruct syscall_trace_exit *rec;\n\tstruct hlist_head *head;\n\tint syscall_nr;\n\tint rctx;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0 || syscall_nr >= NR_syscalls)\n\t\treturn;\n\tif (!test_bit(syscall_nr, enabled_perf_exit_syscalls))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\thead = this_cpu_ptr(sys_data->exit_event->perf_events);\n\tif (hlist_empty(head))\n\t\treturn;\n\n\tsize = ALIGN(sizeof(*rec) + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\trec = (struct syscall_trace_exit *)perf_trace_buf_prepare(size,\n\t\t\t\tsys_data->exit_event->event.type, regs, &rctx);\n\tif (!rec)\n\t\treturn;\n\n\trec->nr = syscall_nr;\n\trec->ret = syscall_get_return_value(current, regs);\n\tperf_trace_buf_submit(rec, size, rctx, 0, 1, regs, head, NULL);\n}",
        "output": "0",
        "idx": 3751
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_event_exit_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\n\tperf_event_exit_cpu_context(cpu);\n\n\tmutex_lock(&swhash->hlist_mutex);\n\tswhash->online = false;\n\tswevent_hlist_release(swhash);\n\tmutex_unlock(&swhash->hlist_mutex);\n}",
        "output": "1",
        "idx": 1014
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mt76_add_fragment(struct mt76_dev *dev, struct mt76_queue *q, void *data,\n\t\t  int len, bool more)\n{\n\tstruct page *page = virt_to_head_page(data);\n\tint offset = data - page_address(page);\n\tstruct sk_buff *skb = q->rx_head;\n\n\toffset += q->buf_offset;\n\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page, offset, len,\n\t\t\tq->buf_size);\n\n\tif (more)\n\t\treturn;\n\n\tq->rx_head = NULL;\n\tdev->drv->rx_skb(dev, q - dev->q_rx, skb);\n}",
        "output": "1",
        "idx": 3324
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void arch_pick_mmap_layout(struct mm_struct *mm)\n{\n\tunsigned long random_factor = 0UL;\n\n\tif (current->flags & PF_RANDOMIZE)\n\t\trandom_factor = arch_mmap_rnd();\n\n\tmm->mmap_legacy_base = mmap_legacy_base(random_factor);\n\n\tif (mmap_is_legacy()) {\n\t\tmm->mmap_base = mm->mmap_legacy_base;\n\t\tmm->get_unmapped_area = arch_get_unmapped_area;\n\t} else {\n\t\tmm->mmap_base = mmap_base(random_factor);\n\t\tmm->get_unmapped_area = arch_get_unmapped_area_topdown;\n\t}\n}",
        "output": "1",
        "idx": 1144
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "n_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n\n    trigger_modechanged();\n    setmouse();\n#ifdef FEAT_CONCEAL\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t\n#ifdef FEAT_CLIPBOARD\n    clip_star.vmode = NUL;\n#endif\n\n    if (curwin->w_redr_type < INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}",
        "output": "0",
        "idx": 7919
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __u8 *nci_extract_rf_params_nfcb_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcb_poll *nfcb_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcb_poll->sensb_res_len = min_t(__u8, *data++, NFC_SENSB_RES_MAXSIZE);\n\n\tpr_debug(\"sensb_res_len %d\\n\", nfcb_poll->sensb_res_len);\n\n\tmemcpy(nfcb_poll->sensb_res, data, nfcb_poll->sensb_res_len);\n\tdata += nfcb_poll->sensb_res_len;\n\n\treturn data;\n}",
        "output": "0",
        "idx": 971
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_framing_type_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_ASYNC_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_SYNC_MASK) {\n\t\tND_PRINT((ndo, \"S\"));\n\t}\n}",
        "output": "0",
        "idx": 6651
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileInfo, getPathInfo)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_class_entry *ce = intern->info_class;\n\tzend_error_handling error_handling;\n\t\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n\t\tint path_len;\n\t\tchar *path = spl_filesystem_object_get_pathname(intern, &path_len TSRMLS_CC);\n\t\tif (path) {\n\t\t\tchar *dpath = estrndup(path, path_len);\n\t\t\tpath_len = php_dirname(dpath, path_len);\n\t\t\tspl_filesystem_object_create_info(intern, dpath, path_len, 1, ce, return_value TSRMLS_CC);\n\t\t\tefree(dpath);\n\t\t}\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}",
        "output": "1",
        "idx": 3920
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_chdir(const char *path)\n{\n\tif (chdir(path) == 0) {\n\t\tfprintf(stderr, \"leak at chdir to %s\\n\", path);\n\t\texit(1);\n\t}\n}",
        "output": "0",
        "idx": 7261
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct htx_blk *htx_add_header(struct htx *htx, const struct ist name,\n\t\t\t\t\t     const struct ist value)\n{\n\tstruct htx_blk *blk;\n\n\tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}",
        "output": "1",
        "idx": 8794
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static HashTable *spl_array_get_gc(zval *object, zval ***gc_data, int *gc_data_count TSRMLS_DC) \n{\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\n\t*gc_data = &intern->array;\n\t*gc_data_count = 1;\n\treturn zend_std_get_properties(object);\n}",
        "output": "0",
        "idx": 5605
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void _perf_event_disable(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct task_struct *task = ctx->task;\n\n\tif (!task) {\n\t\tcpu_function_call(event->cpu, __perf_event_disable, event);\n\t\treturn;\n\t}\n\nretry:\n\tif (!task_function_call(task, __perf_event_disable, event))\n\t\treturn;\n\n\traw_spin_lock_irq(&ctx->lock);\n\tif (event->state == PERF_EVENT_STATE_ACTIVE) {\n\t\traw_spin_unlock_irq(&ctx->lock);\n\t\ttask = ctx->task;\n\t\tgoto retry;\n\t}\n\n\tif (event->state == PERF_EVENT_STATE_INACTIVE) {\n\t\tupdate_group_times(event);\n\t\tevent->state = PERF_EVENT_STATE_OFF;\n\t}\n\traw_spin_unlock_irq(&ctx->lock);\n}",
        "output": "0",
        "idx": 3825
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool __net_get_random_once(void *buf, int nbytes, bool *done,\n\t\t\t   struct static_key *once_key)\n{\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&lock, flags);\n\tif (*done) {\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t\treturn false;\n\t}\n\n\tget_random_bytes(buf, nbytes);\n\t*done = true;\n\tspin_unlock_irqrestore(&lock, flags);\n\n\t__net_random_once_disable_jump(once_key);\n\n\treturn true;\n}",
        "output": "0",
        "idx": 3541
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Jsi_ValueArrayShift(Jsi_Interp *interp, Jsi_Value *v)\n{\n    if (v->vt != JSI_VT_OBJECT) {\n        Jsi_LogBug(\"Jsi_ValueArrayShift, target is not object\");\n        return;\n    }\n    Jsi_Obj *o = v->d.obj;\n    if (o->isarrlist) {\n        uint i;\n        if (!o->arrCnt)\n            return;\n        if (o->arr[0])\n            Jsi_DecrRefCount(interp, o->arr[0]);\n        for (i=1; i<o->arrCnt; i++) {\n            o->arr[i-1] = o->arr[i];\n        }\n        o->arr[o->arrCnt--] = NULL;\n        return;\n    }\n    \n    int len = Jsi_ObjGetLength(interp, v->d.obj);\n    if (len <= 0) return;\n    \n    Jsi_Value *v0 = Jsi_ValueArrayIndex(interp, v, 0);\n    if (!v0) return;\n    \n    Jsi_ValueReset(interp, &v0);\n    \n    int i;\n    Jsi_Value *last = v0;\n    for (i = 1; i < len; ++i) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, v, i);\n        if (!t) return;\n        Jsi_ValueCopy(interp, last, t);\n        Jsi_ValueReset(interp, &t);\n        last = t;\n    }\n    Jsi_ObjSetLength(interp, v->d.obj, len - 1);\n}",
        "output": "1",
        "idx": 8138
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void sock_release(struct socket *sock)\n{\n\t__sock_release(sock, NULL);\n}",
        "output": "0",
        "idx": 4107
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "proc_lambda(mrb_state *mrb, mrb_value self)\n{\n  mrb_value blk;\n  struct RProc *p;\n\n  mrb_get_args(mrb, \"&\", &blk);\n  if (mrb_nil_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"tried to create Proc object without a block\");\n  }\n  if (!mrb_proc_p(blk)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"not a proc\");\n  }\n  p = mrb_proc_ptr(blk);\n  if (!MRB_PROC_STRICT_P(p)) {\n    struct RProc *p2 = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, p->c);\n    mrb_proc_copy(p2, p);\n    p2->flags |= MRB_PROC_STRICT;\n    return mrb_obj_value(p2);\n  }\n  return blk;\n}",
        "output": "1",
        "idx": 6684
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,\n\t\t    unsigned int keylen)\n{\n\treturn -ENOSYS;\n}",
        "output": "0",
        "idx": 2575
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline unsigned char unimap_bsearch(const uni_to_enc *table, unsigned code_key_a, size_t num)\n{\n\tconst uni_to_enc *l = table,\n\t\t\t\t\t *h = &table[num-1],\n\t\t\t\t\t *m;\n\tunsigned short code_key;\n\n\tif (code_key_a > 0xFFFFU)\n\t\treturn 0;\n\n\tcode_key = (unsigned short) code_key_a;\n\n\twhile (l <= h) {\n\t\tm = l + (h - l) / 2;\n\t\tif (code_key < m->un_code_point)\n\t\t\th = m - 1;\n\t\telse if (code_key > m->un_code_point)\n\t\t\tl = m + 1;\n\t\telse\n\t\t\treturn m->cs_code;\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 5385
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ac_interception(struct vcpu_svm *svm)\n{\n\tkvm_queue_exception_e(&svm->vcpu, AC_VECTOR, 0);\n\treturn 1;\n}",
        "output": "0",
        "idx": 1339
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void rd_release_device_space(struct rd_dev *rd_dev)\n{\n\tu32 i, j, page_count = 0, sg_per_table;\n\tstruct rd_dev_sg_table *sg_table;\n\tstruct page *pg;\n\tstruct scatterlist *sg;\n\n\tif (!rd_dev->sg_table_array || !rd_dev->sg_table_count)\n\t\treturn;\n\n\tsg_table = rd_dev->sg_table_array;\n\n\tfor (i = 0; i < rd_dev->sg_table_count; i++) {\n\t\tsg = sg_table[i].sg_table;\n\t\tsg_per_table = sg_table[i].rd_sg_count;\n\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = sg_page(&sg[j]);\n\t\t\tif (pg) {\n\t\t\t\t__free_page(pg);\n\t\t\t\tpage_count++;\n\t\t\t}\n\t\t}\n\n\t\tkfree(sg);\n\t}\n\n\tpr_debug(\"CORE_RD[%u] - Released device space for Ramdisk\"\n\t\t\" Device ID: %u, pages %u in %u tables total bytes %lu\\n\",\n\t\trd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count,\n\t\trd_dev->sg_table_count, (unsigned long)page_count * PAGE_SIZE);\n\n\tkfree(sg_table);\n\trd_dev->sg_table_array = NULL;\n\trd_dev->sg_table_count = 0;\n}",
        "output": "1",
        "idx": 2514
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct hugepage_subpool *subpool_vma(struct vm_area_struct *vma)\n{\n\treturn subpool_inode(vma->vm_file->f_dentry->d_inode);\n}",
        "output": "0",
        "idx": 891
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int stv06xx_isoc_nego(struct gspca_dev *gspca_dev)\n{\n\tint ret, packet_size, min_packet_size;\n\tstruct usb_host_interface *alt;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\tmin_packet_size = sd->sensor->min_packet_size[gspca_dev->curr_mode];\n\tif (packet_size <= min_packet_size)\n\t\treturn -EIO;\n\n\tpacket_size -= 100;\n\tif (packet_size < min_packet_size)\n\t\tpacket_size = min_packet_size;\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(packet_size);\n\n\tret = usb_set_interface(gspca_dev->dev, gspca_dev->iface, 1);\n\tif (ret < 0)\n\t\tgspca_err(gspca_dev, \"set alt 1 err %d\\n\", ret);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 4617
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int add_attributes(PyTypeObject* type, char**attrs, int num_fields)\n{\n    int i, result;\n    _Py_IDENTIFIER(_attributes);\n    PyObject *s, *l = PyTuple_New(num_fields);\n    if (!l)\n        return 0;\n    for (i = 0; i < num_fields; i++) {\n        s = PyUnicode_FromString(attrs[i]);\n        if (!s) {\n            Py_DECREF(l);\n            return 0;\n        }\n        PyTuple_SET_ITEM(l, i, s);\n    }\n    result = _PyObject_SetAttrId((PyObject*)type, &PyId__attributes, l) >= 0;\n    Py_DECREF(l);\n    return result;\n}",
        "output": "1",
        "idx": 7704
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_1_6_dummy(kadm5_principal_ent_t entry, long mask,\n                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)\n{\n    int i;\n    char *password = *passptr;\n\n    if (!(mask & KADM5_ATTRIBUTES) ||\n        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))\n        return;\n\n    for (i = 0; (unsigned char) password[i] == i + 1; i++);\n    if (password[i] != '\\0' || i != 255)\n        return;\n\n    *passptr = NULL;\n}",
        "output": "1",
        "idx": 6
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "file_pop_buffer(struct magic_set *ms, file_pushbuf_t *pb)\n{\n\tchar *rbuf;\n\n\tif (ms->event_flags & EVENT_HAD_ERR) {\n\t\tfree(pb->buf);\n\t\tfree(pb);\n\t\treturn NULL;\n\t}\n\n\trbuf = ms->o.buf;\n\n\tms->o.buf = pb->buf;\n\tms->offset = pb->offset;\n\n\tfree(pb);\n\treturn rbuf;\n}",
        "output": "0",
        "idx": 6111
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "test_save_copy (const char *origname)\n{\n  char buf[TESTBUFSIZE];\n  int ret;\n\n  snprintf_func (buf, TESTBUFSIZE, \"cp -f %s %s\", origname, TEST_COPY_FILE);\n\n  if ((ret = system (buf)) != 0)\n    {\n      return XD3_INTERNAL;\n    }\n\n  return 0;\n}",
        "output": "1",
        "idx": 5130
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ion_free(struct ion_client *client, struct ion_handle *handle)\n{\n\tBUG_ON(client != handle->client);\n\n\tmutex_lock(&client->lock);\n\tion_free_nolock(client, handle);\n\tmutex_unlock(&client->lock);\n}",
        "output": "0",
        "idx": 1697
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __init clear_bss(void)\n{\n\tmemset(__bss_start, 0,\n\t       (unsigned long) __bss_stop - (unsigned long) __bss_start);\n}",
        "output": "1",
        "idx": 2062
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ex_function(exarg_T *eap)\n{\n    (void)define_function(eap, NULL);\n}",
        "output": "1",
        "idx": 5696
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "init_device (u2fh_devs * devs, struct u2fdevice *dev)\n{\n  unsigned char resp[1024];\n  unsigned char nonce[8];\n  if (obtain_nonce(nonce) != 0)\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  size_t resplen = sizeof (resp);\n  dev->cid = CID_BROADCAST;\n\n  if (u2fh_sendrecv\n      (devs, dev->id, U2FHID_INIT, nonce, sizeof (nonce), resp,\n       &resplen) == U2FH_OK)\n    {\n      U2FHID_INIT_RESP initresp;\n      if (resplen > sizeof (initresp))\n\t{\n\t  return U2FH_MEMORY_ERROR;\n\t}\n      memcpy (&initresp, resp, resplen);\n      dev->cid = initresp.cid;\n      dev->versionInterface = initresp.versionInterface;\n      dev->versionMajor = initresp.versionMajor;\n      dev->versionMinor = initresp.versionMinor;\n      dev->capFlags = initresp.capFlags;\n    }\n  else\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  return U2FH_OK;\n}",
        "output": "1",
        "idx": 7860
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "webSocketsHasDataInBuffer(rfbClientPtr cl)\n{\n    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n\n    if (wsctx && wsctx->readlen)\n      return TRUE;\n\n    return (cl->sslctx && rfbssl_pending(cl) > 0);\n}",
        "output": "0",
        "idx": 8889
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_video_set_spu_palette(unsigned int fd, unsigned int cmd,\n\t\tstruct compat_video_spu_palette __user *up)\n{\n\tstruct video_spu_palette __user *up_native;\n\tcompat_uptr_t palp;\n\tint length, err;\n\n\terr  = get_user(palp, &up->palette);\n\terr |= get_user(length, &up->length);\n\tif (err)\n\t\treturn -EFAULT;\n\n\tup_native = compat_alloc_user_space(sizeof(struct video_spu_palette));\n\terr  = put_user(compat_ptr(palp), &up_native->palette);\n\terr |= put_user(length, &up_native->length);\n\tif (err)\n\t\treturn -EFAULT;\n\n\terr = sys_ioctl(fd, cmd, (unsigned long) up_native);\n\n\treturn err;\n}",
        "output": "0",
        "idx": 1083
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, getMaxLineLen)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_LONG((long)intern->u.file.max_line_len);\n} ",
        "output": "1",
        "idx": 3950
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ip4_datagram_release_cb(struct sock *sk)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct ip_options_rcu *inet_opt;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\n\tif (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))\n\t\treturn;\n\n\trcu_read_lock();\n\tinet_opt = rcu_dereference(inet->inet_opt);\n\tif (inet_opt && inet_opt->opt.srr)\n\t\tdaddr = inet_opt->opt.faddr;\n\trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n\t\t\t\t   inet->inet_saddr, inet->inet_dport,\n\t\t\t\t   inet->inet_sport, sk->sk_protocol,\n\t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt))\n\t\t__sk_dst_set(sk, &rt->dst);\n\trcu_read_unlock();\n}",
        "output": "1",
        "idx": 2592
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __inline__ void scm_set_cred(struct scm_cookie *scm,\n\t\t\t\t    struct pid *pid, const struct cred *cred)\n{\n\tscm->pid  = get_pid(pid);\n\tscm->cred = cred ? get_cred(cred) : NULL;\n\tscm->creds.pid = pid_vnr(pid);\n\tscm->creds.uid = cred ? cred->euid : INVALID_UID;\n\tscm->creds.gid = cred ? cred->egid : INVALID_GID;\n}",
        "output": "1",
        "idx": 912
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool current_chrooted(void)\n{\n\tstruct path ns_root;\n\tstruct path fs_root;\n\tbool chrooted;\n\n\tns_root.mnt = &current->nsproxy->mnt_ns->root->mnt;\n\tns_root.dentry = ns_root.mnt->mnt_root;\n\tpath_get(&ns_root);\n\twhile (d_mountpoint(ns_root.dentry) && follow_down_one(&ns_root))\n\t\t;\n\n\tget_fs_root(current->fs, &fs_root);\n\n\tchrooted = !path_equal(&fs_root, &ns_root);\n\n\tpath_put(&fs_root);\n\tpath_put(&ns_root);\n\n\treturn chrooted;\n}",
        "output": "0",
        "idx": 1255
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void do_free_upto(BIO *f, BIO *upto)\n\t{\n\tif (upto)\n\t\t{\n\t\tBIO *tbio;\n\t\tdo \n\t\t\t{\n\t\t\ttbio = BIO_pop(f);\n\t\t\tBIO_free(f);\n\t\t\tf = tbio;\n\t\t\t}\n\t\twhile (f != upto);\n\t\t}\n\telse\n\t\tBIO_free_all(f);\n\t}",
        "output": "1",
        "idx": 4524
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sraSpanInsertBefore(sraSpan *newspan, sraSpan *before) {\n  if(newspan && before) {\n    newspan->_next = before;\n    newspan->_prev = before->_prev;\n    before->_prev->_next = newspan;\n    before->_prev = newspan;\n  }\n}",
        "output": "0",
        "idx": 8931
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void* leak_malloc(size_t bytes)\n{\n\n\n    void* base = dlmalloc(bytes + sizeof(AllocationEntry));\n    if (base != NULL) {\n        pthread_mutex_lock(&gAllocationsMutex);\n\n            intptr_t backtrace[BACKTRACE_SIZE];\n            size_t numEntries = get_backtrace(backtrace, BACKTRACE_SIZE);\n\n            AllocationEntry* header = (AllocationEntry*)base;\n            header->entry = record_backtrace(backtrace, numEntries, bytes);\n            header->guard = GUARD;\n\n            base = (AllocationEntry*)base + 1;\n\n        pthread_mutex_unlock(&gAllocationsMutex);\n    }\n\n    return base;\n}",
        "output": "1",
        "idx": 3626
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cpStripToTile(uint8* out, uint8* in,\n    uint32 rows, uint32 cols, int outskew, int64 inskew)\n{\n\twhile (rows-- > 0) {\n\t\tuint32 j = cols;\n\t\twhile (j-- > 0)\n\t\t\t*out++ = *in++;\n\t\tout += outskew;\n\t\tin += inskew;\n\t}\n}",
        "output": "0",
        "idx": 5935
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)\n{\n\tspin_lock(&ctx->cancel_lock);\n\tif ((ctx->clockid == CLOCK_REALTIME ||\n\t     ctx->clockid == CLOCK_REALTIME_ALARM) &&\n\t    (flags & TFD_TIMER_ABSTIME) && (flags & TFD_TIMER_CANCEL_ON_SET)) {\n\t\tif (!ctx->might_cancel) {\n\t\t\tctx->might_cancel = true;\n\t\t\tspin_lock(&cancel_lock);\n\t\t\tlist_add_rcu(&ctx->clist, &cancel_list);\n\t\t\tspin_unlock(&cancel_lock);\n\t\t}\n\t} else {\n\t\t__timerfd_remove_cancel(ctx);\n\t}\n\tspin_unlock(&ctx->cancel_lock);\n}",
        "output": "0",
        "idx": 2145
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mwifiex_set_uap_rates(struct mwifiex_uap_bss_param *bss_cfg,\n\t\t      struct cfg80211_ap_settings *params)\n{\n\tstruct ieee_types_header *rate_ie;\n\tint var_offset = offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\tconst u8 *var_pos = params->beacon.head + var_offset;\n\tint len = params->beacon.head_len - var_offset;\n\tu8 rate_len = 0;\n\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_SUPP_RATES, var_pos, len);\n\tif (rate_ie) {\n\t\tmemcpy(bss_cfg->rates, rate_ie + 1, rate_ie->len);\n\t\trate_len = rate_ie->len;\n\t}\n\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t   params->beacon.tail,\n\t\t\t\t\t   params->beacon.tail_len);\n\tif (rate_ie)\n\t\tmemcpy(bss_cfg->rates + rate_len, rate_ie + 1, rate_ie->len);\n\n\treturn;\n}",
        "output": "1",
        "idx": 3234
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void lateeoi_list_add(struct irq_info *info)\n{\n\tstruct lateeoi_work *eoi = &per_cpu(lateeoi, info->eoi_cpu);\n\tstruct irq_info *elem;\n\tu64 now = get_jiffies_64();\n\tunsigned long delay;\n\tunsigned long flags;\n\n\tif (now < info->eoi_time)\n\t\tdelay = info->eoi_time - now;\n\telse\n\t\tdelay = 1;\n\n\tspin_lock_irqsave(&eoi->eoi_list_lock, flags);\n\n\tif (list_empty(&eoi->eoi_list)) {\n\t\tlist_add(&info->eoi_list, &eoi->eoi_list);\n\t\tmod_delayed_work_on(info->eoi_cpu, system_wq,\n\t\t\t\t    &eoi->delayed, delay);\n\t} else {\n\t\tlist_for_each_entry_reverse(elem, &eoi->eoi_list, eoi_list) {\n\t\t\tif (elem->eoi_time <= info->eoi_time)\n\t\t\t\tbreak;\n\t\t}\n\t\tlist_add(&info->eoi_list, &elem->eoi_list);\n\t}\n\n\tspin_unlock_irqrestore(&eoi->eoi_list_lock, flags);\n}",
        "output": "0",
        "idx": 2731
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int encode_open_downgrade(struct xdr_stream *xdr, const struct nfs_closeargs *arg)\n{\n\t__be32 *p;\n\n\tRESERVE_SPACE(4+NFS4_STATEID_SIZE+4);\n\tWRITE32(OP_OPEN_DOWNGRADE);\n\tWRITEMEM(arg->stateid->data, NFS4_STATEID_SIZE);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->open_flags);\n\treturn 0;\n}",
        "output": "1",
        "idx": 2178
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int xmkstemp(char **tmpname, const char *dir, const char *prefix)\n{\n\tchar *localtmp;\n\tconst char *tmpenv;\n\tmode_t old_mode;\n\tint fd, rc;\n\n\ttmpenv = dir ? dir : getenv(\"TMPDIR\");\n\tif (!tmpenv)\n\t\ttmpenv = _PATH_TMP;\n\n\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", tmpenv, prefix);\n\tif (rc < 0)\n\t\treturn -1;\n\n\told_mode = umask(077);\n\tfd = mkostemp(localtmp, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);\n\tumask(old_mode);\n\tif (fd == -1) {\n\t\tfree(localtmp);\n\t\tlocaltmp = NULL;\n\t}\n\t*tmpname = localtmp;\n\treturn fd;\n}",
        "output": "0",
        "idx": 6511
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){\n    long i;\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n        long a = *(long*)(src+i);\n        long b = *(long*)(dst+i);\n        *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] += src[i+0];\n}",
        "output": "1",
        "idx": 3556
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PyTypeObject* make_type(char *type, PyTypeObject* base, char**fields, int num_fields)\n{\n    PyObject *fnames, *result;\n    int i;\n    fnames = PyTuple_New(num_fields);\n    if (!fnames) return NULL;\n    for (i = 0; i < num_fields; i++) {\n        PyObject *field = PyUnicode_FromString(fields[i]);\n        if (!field) {\n            Py_DECREF(fnames);\n            return NULL;\n        }\n        PyTuple_SET_ITEM(fnames, i, field);\n    }\n    result = PyObject_CallFunction((PyObject*)&PyType_Type, \"s(O){sOss}\",\n                    type, base, \"_fields\", fnames, \"__module__\", \"_ast3\");\n    Py_DECREF(fnames);\n    return (PyTypeObject*)result;\n}",
        "output": "1",
        "idx": 7686
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileInfo, getPath)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar *path;\n\tint path_len;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n  \tpath = spl_filesystem_object_get_path(intern, &path_len TSRMLS_CC);\n\tRETURN_STRINGL(path, path_len, 1);\n}",
        "output": "0",
        "idx": 5507
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void free_bprm(struct linux_binprm *bprm)\n{\n\tfree_arg_pages(bprm);\n\tif (bprm->cred) {\n\t\tmutex_unlock(&current->signal->cred_guard_mutex);\n\t\tabort_creds(bprm->cred);\n\t}\n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tkfree(bprm);\n}",
        "output": "0",
        "idx": 1109
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_byte (SF_PRIVATE *psf, char x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 1)\n\t\tpsf->header [psf->headindex++] = x ;\n} ",
        "output": "1",
        "idx": 4916
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "chdlc_if_print(netdissect_options *ndo, const struct pcap_pkthdr *h, register const u_char *p)\n{\n\treturn chdlc_print(ndo, p, h->len);\n}",
        "output": "0",
        "idx": 6529
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "guestfs___first_line_of_file (guestfs_h *g, const char *filename)\n{\n  char **lines = NULL; \n  int64_t size;\n  char *ret;\n\n  size = guestfs_filesize (g, filename);\n  if (size == -1)\n    return NULL;\n  if (size > MAX_SMALL_FILE_SIZE) {\n    error (g, _(\"size of %s is unreasonably large (%\" PRIi64 \" bytes)\"),\n           filename, size);\n    return NULL;\n  }\n\n  lines = guestfs_head_n (g, 1, filename);\n  if (lines == NULL)\n    return NULL;\n  if (lines[0] == NULL) {\n    guestfs___free_string_list (lines);\n    return safe_strdup (g, \"\");\n  }\n\n  ret = lines[0];               \n\n  free (lines);\n\n  return ret;\n}",
        "output": "0",
        "idx": 5349
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static HashTable *php_zip_get_gc(zval *object, zval ***gc_data, int *gc_data_count TSRMLS_DC) \n{\n\t*gc_data = NULL;\n\t*gc_data_count = 0;\n\treturn zend_std_get_properties(object TSRMLS_CC);\n}",
        "output": "0",
        "idx": 5609
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int bson_check_field_name( bson *b, const char *string,\n                           const int length ) {\n\n    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 1, 1 );\n}",
        "output": "1",
        "idx": 7896
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ssh_packet_get_compress_state(struct sshbuf *m, struct ssh *ssh)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct sshbuf *b;\n\tint r;\n\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (state->compression_in_started) {\n\t\tif ((r = sshbuf_put_string(b, &state->compression_in_stream,\n\t\t    sizeof(state->compression_in_stream))) != 0)\n\t\t\tgoto out;\n\t} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)\n\t\tgoto out;\n\tif (state->compression_out_started) {\n\t\tif ((r = sshbuf_put_string(b, &state->compression_out_stream,\n\t\t    sizeof(state->compression_out_stream))) != 0)\n\t\t\tgoto out;\n\t} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)\n\t\tgoto out;\n\tr = sshbuf_put_stringb(m, b);\n out:\n\tsshbuf_free(b);\n\treturn r;\n}",
        "output": "1",
        "idx": 5576
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rtadv_read (struct thread *thread)\n{\n  int sock;\n  int len;\n  u_char buf[RTADV_MSG_SIZE];\n  struct sockaddr_in6 from;\n  ifindex_t ifindex = 0;\n  int hoplimit = -1;\n  struct zebra_vrf *zvrf = THREAD_ARG (thread);\n\n  sock = THREAD_FD (thread);\n  zvrf->rtadv.ra_read = NULL;\n\n  rtadv_event (zvrf, RTADV_READ, sock);\n\n  len = rtadv_recv_packet (sock, buf, sizeof (buf), &from, &ifindex, &hoplimit);\n\n  if (len < 0) \n    {\n      zlog_warn (\"router solicitation recv failed: %s.\", safe_strerror (errno));\n      return len;\n    }\n\n  rtadv_process_packet (buf, (unsigned)len, ifindex, hoplimit, zvrf->vrf_id);\n\n  return 0;\n}",
        "output": "0",
        "idx": 7903
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void Huff_transmit (huff_t *huff, int ch, byte *fout) {\n\tint i;\n\tif (huff->loc[ch] == NULL) { \n\t\tHuff_transmit(huff, NYT, fout);\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tadd_bit((char)((ch >> i) & 0x1), fout);\n\t\t}\n\t} else {\n\t\tsend(huff->loc[ch], NULL, fout);\n\t}\n}",
        "output": "1",
        "idx": 6232
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int i8042_start(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\n\tspin_lock_irq(&i8042_lock);\n\tport->exists = true;\n\tspin_unlock_irq(&i8042_lock);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 2371
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void handle_debug_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        uint8_t buf[64];\n        memcpy(buf, msg, sizeof(buf));\n\n        uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n        uint32_t msgSize = buf[8]        |\n                ((uint32_t)buf[7]) <<  8 |\n                ((uint32_t)buf[6]) << 16 |\n                ((uint32_t)buf[5]) << 24;\n\n        if (msgSize > 64 - 9) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n            return;\n        }\n\n        const MessagesMap_t *entry = message_map_entry(DEBUG_MSG, msgId, IN_MSG);\n        if (!entry) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n            return;\n        }\n\n        tiny_dispatch(entry, buf + 9, msgSize);\n    } else {\n        usb_rx_helper(msg, len, DEBUG_MSG);\n    }\n}",
        "output": "1",
        "idx": 7548
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_log_throttle(struct perf_event *event, int enable)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint ret;\n\n\tstruct {\n\t\tstruct perf_event_header\theader;\n\t\tu64\t\t\t\ttime;\n\t\tu64\t\t\t\tid;\n\t\tu64\t\t\t\tstream_id;\n\t} throttle_event = {\n\t\t.header = {\n\t\t\t.type = PERF_RECORD_THROTTLE,\n\t\t\t.misc = 0,\n\t\t\t.size = sizeof(throttle_event),\n\t\t},\n\t\t.time\t\t= perf_clock(),\n\t\t.id\t\t= primary_event_id(event),\n\t\t.stream_id\t= event->id,\n\t};\n\n\tif (enable)\n\t\tthrottle_event.header.type = PERF_RECORD_UNTHROTTLE;\n\n\tperf_event_header__init_id(&throttle_event.header, &sample, event);\n\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tthrottle_event.header.size, 1, 0);\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, throttle_event);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\tperf_output_end(&handle);\n}",
        "output": "1",
        "idx": 544
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)\n{\n\n\tif (timr->it.mmtimer.clock == TIMER_OFF) {\n\t\tcur_setting->it_interval.tv_nsec = 0;\n\t\tcur_setting->it_interval.tv_sec = 0;\n\t\tcur_setting->it_value.tv_nsec = 0;\n\t\tcur_setting->it_value.tv_sec =0;\n\t\treturn;\n\t}\n\n\tns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);\n\tns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);\n\treturn;\n}",
        "output": "1",
        "idx": 2090
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int yr_re_match(\n    RE* re,\n    const char* target)\n{\n  return yr_re_exec(\n      re->code,\n      (uint8_t*) target,\n      strlen(target),\n      0,\n      re->flags | RE_FLAGS_SCAN,\n      NULL,\n      NULL);\n}",
        "output": "0",
        "idx": 7861
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ext4_filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tint err;\n\n\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\terr = filemap_fault(vma, vmf);\n\tup_read(&EXT4_I(inode)->i_mmap_sem);\n\n\treturn err;\n}",
        "output": "0",
        "idx": 1447
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tsize_t newpos;\n\n\tJAS_DBGLOG(100, (\"mem_seek(%p, %ld, %d)\\n\", obj, offset, origin));\n\tswitch (origin) {\n\tcase SEEK_SET:\n\t\tnewpos = offset;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tnewpos = m->len_ - offset;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tnewpos = m->pos_ + offset;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\tif (newpos < 0) {\n\t\treturn -1;\n\t}\n\tm->pos_ = newpos;\n\n\treturn m->pos_;\n}",
        "output": "0",
        "idx": 7531
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mspack_fmap_free(void *mem)\n{\n    if(mem) {\n        free(mem);\n        mem = NULL;\n    }\n    return;\n}",
        "output": "0",
        "idx": 5339
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct dentry *dir;\n\tstruct fscrypt_info *ci;\n\tint dir_has_key, cached_with_key;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tdir = dget_parent(dentry);\n\tif (!d_inode(dir)->i_sb->s_cop->is_encrypted(d_inode(dir))) {\n\t\tdput(dir);\n\t\treturn 0;\n\t}\n\n\tci = d_inode(dir)->i_crypt_info;\n\tif (ci && ci->ci_keyring_key &&\n\t    (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t\t\t  (1 << KEY_FLAG_REVOKED) |\n\t\t\t\t\t  (1 << KEY_FLAG_DEAD))))\n\t\tci = NULL;\n\n\tspin_lock(&dentry->d_lock);\n\tcached_with_key = dentry->d_flags & DCACHE_ENCRYPTED_WITH_KEY;\n\tspin_unlock(&dentry->d_lock);\n\tdir_has_key = (ci != NULL);\n\tdput(dir);\n\n\tif ((!cached_with_key && d_is_negative(dentry)) ||\n\t\t\t(!cached_with_key && dir_has_key) ||\n\t\t\t(cached_with_key && !dir_has_key))\n\t\treturn 0;\n\treturn 1;\n}",
        "output": "1",
        "idx": 1524
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "show_tree(tree_t *t,                    \n          int    indent)                \n{\n  while (t)\n  {\n    if (t->markup == MARKUP_NONE)\n      printf(\"%*s\\\"%s\\\"\\n\", indent, \"\", t->data);\n    else\n      printf(\"%*s%s\\n\", indent, \"\", _htmlMarkups[t->markup]);\n\n    if (t->child)\n      show_tree(t->child, indent + 2);\n\n    t = t->next;\n  }\n}",
        "output": "1",
        "idx": 8496
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "Assign(asdl_seq * targets, expr_ty value, int lineno, int col_offset, int\n       end_lineno, int end_col_offset, PyArena *arena)\n{\n    stmt_ty p;\n    if (!value) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field value is required for Assign\");\n        return NULL;\n    }\n    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->kind = Assign_kind;\n    p->v.Assign.targets = targets;\n    p->v.Assign.value = value;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    p->end_lineno = end_lineno;\n    p->end_col_offset = end_col_offset;\n    return p;\n}",
        "output": "1",
        "idx": 7176
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hb_set_set (hb_set_t       *set,\n\t    const hb_set_t *other)\n{\n  set->set (*other);\n}",
        "output": "0",
        "idx": 7765
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "__u32 secure_ipv6_id(const __be32 daddr[4])\n{\n\tconst struct keydata *keyptr;\n\t__u32 hash[4];\n\n\tkeyptr = get_keyptr();\n\n\thash[0] = (__force __u32)daddr[0];\n\thash[1] = (__force __u32)daddr[1];\n\thash[2] = (__force __u32)daddr[2];\n\thash[3] = (__force __u32)daddr[3];\n\n\treturn half_md4_transform(hash, keyptr->secret);\n}",
        "output": "0",
        "idx": 717
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void handle_action(HttpRequest req, HttpResponse res) {\n        char *name = req->url;\n        Service_T s = Util_getService(++name);\n        if (! s) {\n                send_error(req, res, SC_NOT_FOUND, \"There is no service named \\\"%s\\\"\", name ? name : \"\");\n                return;\n        }\n        const char *action = get_parameter(req, \"action\");\n        if (action) {\n                if (is_readonly(req)) {\n                        send_error(req, res, SC_FORBIDDEN, \"You do not have sufficient privileges to access this page\");\n                        return;\n                }\n                Action_Type doaction = Util_getAction(action);\n                if (doaction == Action_Ignored) {\n                        send_error(req, res, SC_BAD_REQUEST, \"Invalid action \\\"%s\\\"\", action);\n                        return;\n                }\n                s->doaction = doaction;\n                const char *token = get_parameter(req, \"token\");\n                if (token) {\n                        FREE(s->token);\n                        s->token = Str_dup(token);\n                }\n                LogInfo(\"'%s' %s on user request\\n\", s->name, action);\n                Run.flags |= Run_ActionPending; \n                do_wakeupcall();\n        }\n        do_service(req, res, s);\n}",
        "output": "1",
        "idx": 6012
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "psf_bump_header_allocation (SF_PRIVATE * psf, sf_count_t needed)\n{\n\tsf_count_t newlen, smallest = INITAL_HEADER_SIZE ;\n\tvoid * ptr ;\n\n\tnewlen = (needed > psf->header.len) ? 2 * SF_MAX (needed, smallest) : 2 * psf->header.len ;\n\n\tif (newlen > 100 * 1024)\n\t{\tpsf_log_printf (psf, \"Request for header allocation of %D denined.\\n\", newlen) ;\n\t\treturn 1 ;\n\t\t}\n\n\tif ((ptr = realloc (psf->header.ptr, newlen)) == NULL)\n\t{\tpsf_log_printf (psf, \"realloc (%p, %D) failed\\n\", psf->header.ptr, newlen) ;\n\t\tpsf->error = SFE_MALLOC_FAILED ;\n\t\treturn 1 ;\n\t\t} ;\n\n\tpsf->header.ptr = ptr ;\n\tpsf->header.len = newlen ;\n\treturn 0 ;\n} ",
        "output": "0",
        "idx": 6911
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_lintr_assert(struct pci_vdev *dev)\n{\n\tassert(dev->lintr.pin > 0);\n\n\tpthread_mutex_lock(&dev->lintr.lock);\n\tif (dev->lintr.state == IDLE) {\n\t\tif (pci_lintr_permitted(dev)) {\n\t\t\tdev->lintr.state = ASSERTED;\n\t\t\tpci_irq_assert(dev);\n\t\t} else\n\t\t\tdev->lintr.state = PENDING;\n\t}\n\tpthread_mutex_unlock(&dev->lintr.lock);\n}",
        "output": "1",
        "idx": 7600
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION( locale_get_script ) \n{\n\tget_icu_value_src_php( LOC_SCRIPT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}",
        "output": "1",
        "idx": 3854
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u16 read_16(cdk_stream_t s)\n{\n\tbyte buf[2];\n\tsize_t nread = 0;\n\n\tassert(s != NULL);\n\n\tstream_read(s, buf, 2, &nread);\n\tif (nread != 2)\n\t\treturn (u16) - 1;\n\treturn buf[0] << 8 | buf[1];\n}",
        "output": "0",
        "idx": 6483
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char* cJSON_strdup(const char* str)\n{\n      size_t len;\n      char* copy;\n\n      len = strlen(str) + 1;\n      if (!(copy = (char*)cJSON_malloc(len))) return 0;\n      memcpy(copy,str,len);\n      return copy;\n}",
        "output": "0",
        "idx": 8311
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, -1);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\n\treturn rv;\n}",
        "output": "1",
        "idx": 4450
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t driver_override_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tssize_t len;\n\n\tdevice_lock(dev);\n\tlen = sprintf(buf, \"%s\\n\", pdev->driver_override);\n\tdevice_unlock(dev);\n\treturn len;\n}",
        "output": "0",
        "idx": 2319
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "init_util(void)\n{\n\tfilegen_register(statsdir, \"peerstats\",\t  &peerstats);\n\tfilegen_register(statsdir, \"loopstats\",\t  &loopstats);\n\tfilegen_register(statsdir, \"clockstats\",  &clockstats);\n\tfilegen_register(statsdir, \"rawstats\",\t  &rawstats);\n\tfilegen_register(statsdir, \"sysstats\",\t  &sysstats);\n\tfilegen_register(statsdir, \"protostats\",  &protostats);\n#ifdef AUTOKEY\n\tfilegen_register(statsdir, \"cryptostats\", &cryptostats);\n#endif\t\n#ifdef DEBUG_TIMING\n\tfilegen_register(statsdir, \"timingstats\", &timingstats);\n#endif\t\n\tstep_callback = &ntpd_time_stepped;\n#ifdef DEBUG\n\tatexit(&uninit_util);\n#endif \n}",
        "output": "1",
        "idx": 5338
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init acpi_custom_method_init(void)\n{\n\tif (acpi_debugfs_dir == NULL)\n\t\treturn -ENOENT;\n\n\tcm_dentry = debugfs_create_file(\"custom_method\", S_IWUSR,\n\t\t\t\t\tacpi_debugfs_dir, NULL, &cm_fops);\n\tif (cm_dentry == NULL)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 539
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t interprocess_token)\n{\n    OM_uint32 maj;\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (!ctx->established)\n        return GSS_S_UNAVAILABLE;\n\n    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,\n                                      interprocess_token);\n    if (ctx->gssc == GSS_C_NO_CONTEXT) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n    return maj;\n}",
        "output": "0",
        "idx": 137
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long jpc_bitstream_getbits(jpc_bitstream_t *bitstream, int n)\n{\n\tlong v;\n\tint u;\n\n\tassert(n >= 0 && n < 32);\n\n\tv = 0;\n\twhile (--n >= 0) {\n\t\tif ((u = jpc_bitstream_getbit(bitstream)) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 1) | u;\n\t}\n\treturn v;\n}",
        "output": "1",
        "idx": 5360
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ZEXPORT deflatePrime (strm, bits, value)\n    z_streamp strm;\n    int bits;\n    int value;\n{\n    deflate_state *s;\n    int put;\n\n    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;\n    s = strm->state;\n    if ((Bytef *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))\n        return Z_BUF_ERROR;\n    do {\n        put = Buf_size - s->bi_valid;\n        if (put > bits)\n            put = bits;\n        s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);\n        s->bi_valid += put;\n        _tr_flush_bits(s);\n        value >>= put;\n        bits -= put;\n    } while (bits);\n    return Z_OK;\n}",
        "output": "1",
        "idx": 6090
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline FILE *xfmkstemp(char **tmpname, const char *dir, const char *prefix)\n{\n\tint fd;\n\tFILE *ret;\n\n\tfd = xmkstemp(tmpname, dir, prefix);\n\tif (fd == -1)\n\t\treturn NULL;\n\n\tif (!(ret = fdopen(fd, \"w+\" UL_CLOEXECSTR))) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}",
        "output": "0",
        "idx": 6507
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ext4_io_end_t *ext4_init_io_end (struct inode *inode, gfp_t flags)\n{\n\text4_io_end_t *io = NULL;\n\n\tio = kmalloc(sizeof(*io), flags);\n\n\tif (io) {\n\t\tigrab(inode);\n\t\tio->inode = inode;\n\t\tio->flag = 0;\n\t\tio->offset = 0;\n\t\tio->size = 0;\n\t\tio->page = NULL;\n\t\tINIT_WORK(&io->work, ext4_end_io_work);\n\t\tINIT_LIST_HEAD(&io->list);\n\t}\n\n\treturn io;\n}",
        "output": "0",
        "idx": 3167
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "diff_buf_delete(buf_T *buf)\n{\n    int\t\ti;\n    tabpage_T\t*tp;\n\n    FOR_ALL_TABPAGES(tp)\n    {\n\ti = diff_buf_idx_tp(buf, tp);\n\tif (i != DB_COUNT)\n\t{\n\t    tp->tp_diffbuf[i] = NULL;\n\t    tp->tp_diff_invalid = TRUE;\n\t    if (tp == curtab)\n\t    {\n\t\tneed_diff_redraw = TRUE;\n\t\tredraw_later(VALID);\n\t    }\n\t}\n    }\n}",
        "output": "0",
        "idx": 8071
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mm_zalloc(struct mm_master *mm, u_int ncount, u_int size)\n{\n\tif (size == 0 || ncount == 0 || ncount > SIZE_MAX / size)\n\t\tfatal(\"%s: mm_zalloc(%u, %u)\", __func__, ncount, size);\n\n\treturn mm_malloc(mm, size * ncount);\n}",
        "output": "1",
        "idx": 5566
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int AES_decrypt(uint8_t *encr_message, uint64_t length, char *message, uint64_t msgLen) {\n\n    if (!message) {\n        LOG_ERROR(\"Null message in AES_encrypt\");\n        return -1;\n    }\n\n    if (!encr_message) {\n        LOG_ERROR(\"Null encr message in AES_encrypt\");\n        return -2;\n    }\n\n\n  if (length < SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE) {\n      LOG_ERROR(\"length < SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE\");\n      return -1;\n  }\n\n\n\n  uint64_t len = length - SGX_AESGCM_MAC_SIZE - SGX_AESGCM_IV_SIZE;\n\n  if (msgLen < len) {\n        LOG_ERROR(\"Output buffer not large enough\");\n        return -2;\n  }\n\n  sgx_status_t status = sgx_rijndael128GCM_decrypt(&AES_key,\n                                                   encr_message + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE, len,\n                                                   (unsigned char*) message,\n                                                   encr_message + SGX_AESGCM_MAC_SIZE, SGX_AESGCM_IV_SIZE,\n                                                   NULL, 0,\n                                                   (sgx_aes_gcm_128bit_tag_t *)encr_message);\n\n  return status;\n}",
        "output": "1",
        "idx": 8700
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void beforeSleep(struct aeEventLoop *eventLoop) {\n    REDIS_NOTUSED(eventLoop);\n    listNode *ln;\n    redisClient *c;\n\n    if (server.vm_enabled && listLength(server.io_ready_clients)) {\n        listIter li;\n\n        listRewind(server.io_ready_clients,&li);\n        while((ln = listNext(&li))) {\n            c = ln->value;\n            struct redisCommand *cmd;\n\n            listDelNode(server.io_ready_clients,ln);\n            c->flags &= (~REDIS_IO_WAIT);\n            server.vm_blocked_clients--;\n            aeCreateFileEvent(server.el, c->fd, AE_READABLE,\n                readQueryFromClient, c);\n            cmd = lookupCommand(c->argv[0]->ptr);\n            redisAssert(cmd != NULL);\n            call(c,cmd);\n            resetClient(c);\n            if (c->querybuf && sdslen(c->querybuf) > 0)\n                processInputBuffer(c);\n        }\n    }\n\n    while (listLength(server.unblocked_clients)) {\n        ln = listFirst(server.unblocked_clients);\n        redisAssert(ln != NULL);\n        c = ln->value;\n        listDelNode(server.unblocked_clients,ln);\n\n        if (c->querybuf && sdslen(c->querybuf) > 0)\n            processInputBuffer(c);\n    }\n\n    flushAppendOnlyFile();\n}",
        "output": "1",
        "idx": 3664
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init acpi_custom_method_init(void)\n{\n\tif (!acpi_debugfs_dir)\n\t\treturn -ENOENT;\n\n\tcm_dentry = debugfs_create_file(\"custom_method\", S_IWUSR,\n\t\t\t\t\tacpi_debugfs_dir, NULL, &cm_fops);\n\tif (!cm_dentry)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 398
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cp2112_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&dev->lock);\n\n\tbuf[0] = CP2112_GPIO_SET;\n\tbuf[1] = value ? 0xff : 0;\n\tbuf[2] = 1 << offset;\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_SET, buf,\n\t\t\t\t CP2112_GPIO_SET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0)\n\t\thid_err(hdev, \"error setting GPIO values: %d\\n\", ret);\n\n\tmutex_unlock(&dev->lock);\n}",
        "output": "0",
        "idx": 2107
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void unix_notinflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tspin_lock(&unix_gc_lock);\n\t\tBUG_ON(list_empty(&u->link));\n\n\t\tif (atomic_long_dec_and_test(&u->inflight))\n\t\t\tlist_del_init(&u->link);\n\t\tunix_tot_inflight--;\n\t\tspin_unlock(&unix_gc_lock);\n\t}\n}",
        "output": "1",
        "idx": 1024
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ext4_end_io_nolock(ext4_io_end_t *io)\n{\n\tstruct inode *inode = io->inode;\n\tloff_t offset = io->offset;\n\tssize_t size = io->size;\n\tint ret = 0;\n\n\text4_debug(\"ext4_end_io_nolock: io 0x%p from inode %lu,list->next 0x%p,\"\n\t\t   \"list->prev 0x%p\\n\",\n\t           io, inode->i_ino, io->list.next, io->list.prev);\n\n\tif (list_empty(&io->list))\n\t\treturn ret;\n\n\tif (io->flag != EXT4_IO_UNWRITTEN)\n\t\treturn ret;\n\n\tif (offset + size <= i_size_read(inode))\n\t\tret = ext4_convert_unwritten_extents(inode, offset, size);\n\n\tif (ret < 0) {\n\t\tprintk(KERN_EMERG \"%s: failed to convert unwritten\"\n\t\t\t\"extents to written extents, error is %d\"\n\t\t\t\" io is still on inode %lu aio dio list\\n\",\n                       __func__, ret, inode->i_ino);\n\t\treturn ret;\n\t}\n\n\tio->flag = 0;\n\treturn ret;\n}",
        "output": "1",
        "idx": 2236
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool ptrace_freeze_traced(struct task_struct *task)\n{\n\tbool ret = false;\n\n\tif (task->jobctl & JOBCTL_LISTENING)\n\t\treturn ret;\n\n\tspin_lock_irq(&task->sighand->siglock);\n\tif (task_is_traced(task) && !__fatal_signal_pending(task)) {\n\t\ttask->state = __TASK_TRACED;\n\t\tret = true;\n\t}\n\tspin_unlock_irq(&task->sighand->siglock);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 1131
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void * gdImageWBMPPtr (gdImagePtr im, int *size, int fg)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tgdImageWBMPCtx(im, fg, out);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\n\treturn rv;\n}",
        "output": "1",
        "idx": 4126
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \"\", name[200] = \"\", path[256];\n  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n    return -1;\n  } else {\n    FILE *fp;\n    size_t oft = strtoul(offset, NULL, 0);\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n    LOG(LL_DEBUG,\n        (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));\n    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \"\", \"\");\n      return (int) hm->body.len;\n    }\n  }\n}",
        "output": "1",
        "idx": 6612
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int cipso_v4_validate(const struct sk_buff *skb,\n\t\t\t\t    unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char err_offset = 0;\n\tu8 opt_len = opt[1];\n\tu8 opt_iter;\n\tu8 tag_len;\n\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto out;\n\t}\n\n\tif (get_unaligned_be32(&opt[2]) == 0) {\n\t\terr_offset = 2;\n\t\tgoto out;\n\t}\n\n\tfor (opt_iter = 6; opt_iter < opt_len;) {\n\t\ttag_len = opt[opt_iter + 1];\n\t\tif ((tag_len == 0) || (opt[opt_iter + 1] > (opt_len - opt_iter))) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto out;\n\t\t}\n\t\topt_iter += tag_len;\n\t}\n\nout:\n\t*option = opt + err_offset;\n\treturn err_offset;\n\n}",
        "output": "0",
        "idx": 3327
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs4_open_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\tif (data->rpc_status != 0 || !data->rpc_done)\n\t\tgoto out_free;\n\tif (data->o_res.rflags & NFS4_OPEN_RESULT_CONFIRM)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.open_flags);\nout_free:\n\tnfs4_opendata_put(data);\n}",
        "output": "1",
        "idx": 2150
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int install_relocation_handler(int num_cpus, size_t save_state_size)\n{\n\tstruct smm_loader_params smm_params = {\n\t\t.per_cpu_stack_size = CONFIG_SMM_STUB_STACK_SIZE,\n\t\t.num_concurrent_stacks = num_cpus,\n\t\t.per_cpu_save_state_size = save_state_size,\n\t\t.num_concurrent_save_states = 1,\n\t\t.handler = smm_do_relocation,\n\t};\n\n\tif (mp_state.ops.adjust_smm_params != NULL)\n\t\tmp_state.ops.adjust_smm_params(&smm_params, 0);\n\n\tif (smm_setup_relocation_handler(&smm_params))\n\t\treturn -1;\n\n\tadjust_smm_apic_id_map(&smm_params);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 8932
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void native_tss_update_io_bitmap(void)\n{\n\tstruct tss_struct *tss = this_cpu_ptr(&cpu_tss_rw);\n\tstruct thread_struct *t = &current->thread;\n\tu16 *base = &tss->x86_tss.io_bitmap_base;\n\n\tif (!test_thread_flag(TIF_IO_BITMAP)) {\n\t\tnative_tss_invalidate_io_bitmap();\n\t\treturn;\n\t}\n\n\tif (IS_ENABLED(CONFIG_X86_IOPL_IOPERM) && t->iopl_emul == 3) {\n\t\t*base = IO_BITMAP_OFFSET_VALID_ALL;\n\t} else {\n\t\tstruct io_bitmap *iobm = t->io_bitmap;\n\n\t\tif (tss->io_bitmap.prev_sequence != iobm->sequence)\n\t\t\ttss_copy_io_bitmap(tss, iobm);\n\n\t\t*base = IO_BITMAP_OFFSET_VALID_MAP;\n\t}\n\n\trefresh_tss_limit();\n}",
        "output": "0",
        "idx": 2697
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "DEFINE_TEST(test_read_too_many_filters)\n{\n\tconst char *name = \"test_read_too_many_filters.gz\";\n\tstruct archive *a;\n\tint r;\n\n\tassert((a = archive_read_new()) != NULL);\n\tr = archive_read_support_filter_gzip(a);\n\tif (r == ARCHIVE_WARN) {\n\t\tskipping(\"gzip reading not fully supported on this platform\");\n\t}\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_all(a));\n\textract_reference_file(name);\n\tassertEqualIntA(a, ARCHIVE_FATAL,\n\t    archive_read_open_filename(a, name, 200));\n\n\tassertEqualInt(ARCHIVE_OK, archive_read_close(a));\n\tassertEqualInt(ARCHIVE_OK, archive_read_free(a));\n}",
        "output": "0",
        "idx": 5171
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void spl_filesystem_tree_it_rewind(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\tspl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);\n\t\n\tobject->u.dir.index = 0;\n\tif (object->u.dir.dirp) {\n\t\tphp_stream_rewinddir(object->u.dir.dirp);\n\t}\n\tdo {\n\t\tspl_filesystem_dir_read(object TSRMLS_CC);\n\t} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));\n\tif (iterator->current) {\n\t\tzval_ptr_dtor(&iterator->current);\n\t\titerator->current = NULL;\n\t}\n}",
        "output": "1",
        "idx": 3938
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "crm_send_remote_msg_raw(void *session, const char *buf, size_t len, gboolean encrypted)\n{\n    int rc = -1;\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        rc = crm_send_tls(session, buf, len);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        rc = crm_send_plaintext(GPOINTER_TO_INT(session), buf, len);\n    }\n    return rc;\n}",
        "output": "0",
        "idx": 5265
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init xfrm6_tunnel_spi_init(void)\n{\n\txfrm6_tunnel_spi_kmem = kmem_cache_create(\"xfrm6_tunnel_spi\",\n\t\t\t\t\t\t  sizeof(struct xfrm6_tunnel_spi),\n\t\t\t\t\t\t  0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t\t  NULL);\n\tif (!xfrm6_tunnel_spi_kmem)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
        "output": "1",
        "idx": 2210
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void mark_key_instantiated(struct key *key, int reject_error)\n{\n\tsmp_store_release(&key->state,\n\t\t\t  (reject_error < 0) ? reject_error : KEY_IS_POSITIVE);\n}",
        "output": "0",
        "idx": 2495
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_user_command_name(int idx, int cmdidx)\n{\n    if (cmdidx == CMD_USER && idx < ucmds.ga_len)\n\treturn USER_CMD(idx)->uc_name;\n    if (cmdidx == CMD_USER_BUF)\n    {\n\tbuf_T *buf = prevwin_curwin()->w_buffer;\n\n\tif (idx < buf->b_ucmds.ga_len)\n\t    return USER_CMD_GA(&buf->b_ucmds, idx)->uc_name;\n    }\n    return NULL;\n}",
        "output": "0",
        "idx": 8007
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char x2c(char *hex) {\n        register char digit;\n        digit = ((hex[0] >= 'A') ? ((hex[0] & 0xdf) - 'A')+10 : (hex[0] - '0'));\n        digit *= 16;\n        digit += (hex[1] >= 'A' ? ((hex[1] & 0xdf) - 'A')+10 : (hex[1] - '0'));\n        return(digit);\n}",
        "output": "1",
        "idx": 6026
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mpeg4video_probe(AVProbeData *probe_packet)\n{\n    uint32_t temp_buffer = -1;\n    int VO = 0, VOL = 0, VOP = 0, VISO = 0, res = 0;\n    int i;\n\n    for (i = 0; i < probe_packet->buf_size; i++) {\n        temp_buffer = (temp_buffer << 8) + probe_packet->buf[i];\n        if ((temp_buffer & 0xffffff00) != 0x100)\n            continue;\n\n        if (temp_buffer == VOP_START_CODE)\n            VOP++;\n        else if (temp_buffer == VISUAL_OBJECT_START_CODE)\n            VISO++;\n        else if (temp_buffer < 0x120)\n            VO++;\n        else if (temp_buffer < 0x130)\n            VOL++;\n        else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) &&\n                 !(0x1B9 < temp_buffer && temp_buffer < 0x1C4))\n            res++;\n    }\n\n    if (VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0)\n        return AVPROBE_SCORE_EXTENSION;\n    return 0;\n}",
        "output": "1",
        "idx": 6058
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ext4_get_block_write(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create)\n{\n\thandle_t *handle = NULL;\n\tint ret = 0;\n\tunsigned max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tint dio_credits;\n\n\text4_debug(\"ext4_get_block_write: inode %lu, create flag %d\\n\",\n\t\t   inode->i_ino, create);\n\tcreate = EXT4_GET_BLOCKS_IO_CREATE_EXT;\n\n\tif (max_blocks > DIO_MAX_BLOCKS)\n\t\tmax_blocks = DIO_MAX_BLOCKS;\n\tdio_credits = ext4_chunk_trans_blocks(inode, max_blocks);\n\thandle = ext4_journal_start(inode, dio_credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\tret = ext4_get_blocks(handle, inode, iblock, max_blocks, bh_result,\n\t\t\t      create);\n\tif (ret > 0) {\n\t\tbh_result->b_size = (ret << inode->i_blkbits);\n\t\tret = 0;\n\t}\n\text4_journal_stop(handle);\nout:\n\treturn ret;\n}",
        "output": "1",
        "idx": 2246
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "define_function(foobar)\n{\n  int64_t arg = integer_argument(1);\n\n  switch (arg)\n  {\n    case 1:\n      return_string(\"foo\");\n      break;\n    case 2:\n      return_string(\"bar\");\n      break;\n  }\n\n  return_string(\"oops\")\n}",
        "output": "0",
        "idx": 7869
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "htmlGetText(tree_t *t)\t\t\n{\n  uchar\t\t*s,\t\t\n\t\t*s2,\t\t\n\t\t*tdata = NULL,\t\n\t\t*talloc = NULL;\t\n  size_t\tslen,\t\t\n\t\ttlen;\t\t\n\n\n  slen = 0;\n  s    = NULL;\n\n  while (t != NULL)\n  {\n    if (t->child)\n      tdata = talloc = htmlGetText(t->child);\n    else\n      tdata = t->data;\n\n    if (tdata != NULL)\n    {\n      tlen = strlen((char *)tdata);\n\n      if (s)\n        s2 = (uchar *)realloc(s, 1 + slen + tlen);\n      else\n        s2 = (uchar *)malloc(1 + tlen);\n\n      if (!s2)\n        break;\n\n      s = s2;\n\n      memcpy((char *)s + slen, (char *)tdata, tlen);\n\n      slen += tlen;\n\n      if (talloc)\n      {\n\tfree(talloc);\n\ttalloc = NULL;\n      }\n    }\n\n    t = t->next;\n  }\n\n  if (slen)\n    s[slen] = '\\0';\n\n  if (talloc)\n    free(talloc);\n\n  return (s);\n}",
        "output": "1",
        "idx": 8494
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void pid_ns_release_proc(struct pid_namespace *ns)\n{\n\tmntput(ns->proc_mnt);\n}",
        "output": "1",
        "idx": 646
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_inquire_sec_context_by_oid(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_OID desired_object,\n\t\tgss_buffer_set_t *data_set)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_UNAVAILABLE);\n\n\tret = gss_inquire_sec_context_by_oid(minor_status,\n\t\t\t    sc->ctx_handle,\n\t\t\t    desired_object,\n\t\t\t    data_set);\n\treturn (ret);\n}",
        "output": "0",
        "idx": 107
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "videobuf_vm_close(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tstruct videobuf_queue *q = map->q;\n\tint i;\n\n\tdprintk(2,\"vm_close %p [count=%u,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\n\tmap->count--;\n\tif (0 == map->count) {\n\t\tdprintk(1,\"munmap %p q=%p\\n\",map,q);\n\t\tmutex_lock(&q->lock);\n\t\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\t\tif (NULL == q->bufs[i])\n\t\t\t\tcontinue;\n\n\t\t\tif (q->bufs[i]->map != map)\n\t\t\t\tcontinue;\n\n\t\t\tq->ops->buf_release(q,q->bufs[i]);\n\n\t\t\tq->bufs[i]->map   = NULL;\n\t\t\tq->bufs[i]->baddr = 0;\n\t\t}\n\t\tmutex_unlock(&q->lock);\n\t\tkfree(map);\n\t}\n\treturn;\n}",
        "output": "0",
        "idx": 2989
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int update_prepare_order_info(rdpContext* context, ORDER_INFO* orderInfo, UINT32 orderType)\n{\n\tint length = 1;\n\torderInfo->fieldFlags = 0;\n\torderInfo->orderType = orderType;\n\torderInfo->controlFlags = ORDER_STANDARD;\n\torderInfo->controlFlags |= ORDER_TYPE_CHANGE;\n\tlength += 1;\n\tlength += PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType];\n\tlength += update_prepare_bounds(context, orderInfo);\n\treturn length;\n}",
        "output": "1",
        "idx": 4166
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_syscall_exit(void *ignore, struct pt_regs *regs, long ret)\n{\n\tstruct syscall_metadata *sys_data;\n\tstruct syscall_trace_exit *rec;\n\tstruct hlist_head *head;\n\tint syscall_nr;\n\tint rctx;\n\tint size;\n\n\tsyscall_nr = trace_get_syscall_nr(current, regs);\n\tif (syscall_nr < 0)\n\t\treturn;\n\tif (!test_bit(syscall_nr, enabled_perf_exit_syscalls))\n\t\treturn;\n\n\tsys_data = syscall_nr_to_meta(syscall_nr);\n\tif (!sys_data)\n\t\treturn;\n\n\thead = this_cpu_ptr(sys_data->exit_event->perf_events);\n\tif (hlist_empty(head))\n\t\treturn;\n\n\tsize = ALIGN(sizeof(*rec) + sizeof(u32), sizeof(u64));\n\tsize -= sizeof(u32);\n\n\trec = (struct syscall_trace_exit *)perf_trace_buf_prepare(size,\n\t\t\t\tsys_data->exit_event->event.type, regs, &rctx);\n\tif (!rec)\n\t\treturn;\n\n\trec->nr = syscall_nr;\n\trec->ret = syscall_get_return_value(current, regs);\n\tperf_trace_buf_submit(rec, size, rctx, 0, 1, regs, head, NULL);\n}",
        "output": "1",
        "idx": 2712
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static size_t read_test_file(char **buffer, char *basename)\n{\n    char *filename;\n    FILE *fp;\n    size_t exp_size, act_size;\n\n    filename = gdTestFilePath2(\"tiff\", basename);\n    fp = fopen(filename, \"rb\");\n    gdTestAssert(fp != NULL);\n\n\tfseek(fp, 0, SEEK_END);\n\texp_size = ftell(fp);\n\tfseek(fp, 0, SEEK_SET);\n\n    *buffer = malloc(exp_size);\n    gdTestAssert(*buffer != NULL);\n    act_size = fread(*buffer, sizeof(**buffer), exp_size, fp);\n    gdTestAssert(act_size == exp_size);\n\n    fclose(fp);\n    free(filename);\n\n    return act_size;\n}",
        "output": "0",
        "idx": 6181
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int can_open_delegated(struct nfs_delegation *delegation, fmode_t fmode)\n{\n\tif ((delegation->type & fmode) != fmode)\n\t\treturn 0;\n\tif (test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags))\n\t\treturn 0;\n\tnfs_mark_delegation_referenced(delegation);\n\treturn 1;\n}",
        "output": "0",
        "idx": 3069
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __account_cfs_rq_runtime(struct cfs_rq *cfs_rq, u64 delta_exec)\n{\n\tcfs_rq->runtime_remaining -= delta_exec;\n\texpire_cfs_rq_runtime(cfs_rq);\n\n\tif (likely(cfs_rq->runtime_remaining > 0))\n\t\treturn;\n\n\tif (!assign_cfs_rq_runtime(cfs_rq) && likely(cfs_rq->curr))\n\t\tresched_curr(rq_of(cfs_rq));\n}",
        "output": "1",
        "idx": 3222
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "grub_ext4_find_leaf (struct grub_ext2_data *data, char *buf,\n                     struct grub_ext4_extent_header *ext_block,\n                     grub_uint32_t fileblock)\n{\n  struct grub_ext4_extent_idx *index;\n\n  while (1)\n    {\n      int i;\n      grub_disk_addr_t block;\n\n      index = (struct grub_ext4_extent_idx *) (ext_block + 1);\n\n      if (grub_le_to_cpu16(ext_block->magic) != EXT4_EXT_MAGIC)\n        return 0;\n\n      if (ext_block->depth == 0)\n        return ext_block;\n\n      for (i = 0; i < grub_le_to_cpu16 (ext_block->entries); i++)\n        {\n          if (fileblock < grub_le_to_cpu32(index[i].block))\n            break;\n        }\n\n      if (--i < 0)\n        return 0;\n\n      block = grub_le_to_cpu16 (index[i].leaf_hi);\n      block = (block << 32) + grub_le_to_cpu32 (index[i].leaf);\n      if (grub_disk_read (data->disk,\n                          block << LOG2_EXT2_BLOCK_SIZE (data),\n                          0, EXT2_BLOCK_SIZE(data), buf)) {\n        return 0;\n      }\n\n      ext_block = (struct grub_ext4_extent_header *) buf;\n    }\n}",
        "output": "0",
        "idx": 8653
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rpki_rtr_print(netdissect_options *ndo, register const u_char *pptr, register u_int len)\n{\n    if (!ndo->ndo_vflag) {\n\tND_PRINT((ndo, \", RPKI-RTR\"));\n\treturn;\n    }\n    while (len) {\n\tu_int pdu_len = rpki_rtr_pdu_print(ndo, pptr, len, 1, 8);\n\tlen -= pdu_len;\n\tpptr += pdu_len;\n    }\n}",
        "output": "0",
        "idx": 6787
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void unlock_or_release_subpool(struct hugepage_subpool *spool)\n{\n\tbool free = (spool->count == 0) && (spool->used_hpages == 0);\n\n\tspin_unlock(&spool->lock);\n\n\tif (free)\n\t\tkfree(spool);\n}",
        "output": "0",
        "idx": 913
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool_t mqttSnClientIsShortTopicName(const char_t *topicName)\n{\n   bool_t res;\n\n   res = FALSE;\n\n   if(osStrlen(topicName) == 2)\n   {\n      if(strchr(topicName, '#') == NULL && strchr(topicName, '+') == NULL)\n      {\n         res = TRUE;\n      }\n   }\n\n   return res;\n}",
        "output": "1",
        "idx": 8664
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "isofs_export_encode_fh(struct inode *inode,\n\t\t       __u32 *fh32,\n\t\t       int *max_len,\n\t\t       struct inode *parent)\n{\n\tstruct iso_inode_info * ei = ISOFS_I(inode);\n\tint len = *max_len;\n\tint type = 1;\n\t__u16 *fh16 = (__u16*)fh32;\n\n\tif (parent && (len < 5)) {\n\t\t*max_len = 5;\n\t\treturn 255;\n\t} else if (len < 3) {\n\t\t*max_len = 3;\n\t\treturn 255;\n\t}\n\n\tlen = 3;\n\tfh32[0] = ei->i_iget5_block;\n \tfh16[2] = (__u16)ei->i_iget5_offset;  \n\tfh16[3] = 0;  \n\tfh32[2] = inode->i_generation;\n\tif (parent) {\n\t\tstruct iso_inode_info *eparent;\n\t\teparent = ISOFS_I(parent);\n\t\tfh32[3] = eparent->i_iget5_block;\n\t\tfh16[3] = (__u16)eparent->i_iget5_offset;  \n\t\tfh32[4] = parent->i_generation;\n\t\tlen = 5;\n\t\ttype = 2;\n\t}\n\t*max_len = len;\n\treturn type;\n}",
        "output": "0",
        "idx": 981
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rose_stop_timer(struct sock *sk)\n{\n\tdel_timer(&rose_sk(sk)->timer);\n}",
        "output": "1",
        "idx": 2056
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int copy_regset_from_user(struct task_struct *target,\n\t\t\t\t\tconst struct user_regset_view *view,\n\t\t\t\t\tunsigned int setno,\n\t\t\t\t\tunsigned int offset, unsigned int size,\n\t\t\t\t\tconst void __user *data)\n{\n\tconst struct user_regset *regset = &view->regsets[setno];\n\n\tif (!regset->set)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!access_ok(VERIFY_READ, data, size))\n\t\treturn -EIO;\n\n\treturn regset->set(target, regset, offset, size, NULL, data);\n}",
        "output": "0",
        "idx": 881
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int inet_sk_reselect_saddr(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\t__be32 old_saddr = inet->inet_saddr;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\t__be32 new_saddr;\n\n\tif (inet->opt && inet->opt->srr)\n\t\tdaddr = inet->opt->faddr;\n\n\trt = ip_route_connect(&fl4, daddr, 0, RT_CONN_FLAGS(sk),\n\t\t\t      sk->sk_bound_dev_if, sk->sk_protocol,\n\t\t\t      inet->inet_sport, inet->inet_dport, sk, false);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\n\tsk_setup_caps(sk, &rt->dst);\n\n\tnew_saddr = rt->rt_src;\n\n\tif (new_saddr == old_saddr)\n\t\treturn 0;\n\n\tif (sysctl_ip_dynaddr > 1) {\n\t\tprintk(KERN_INFO \"%s(): shifting inet->saddr from %pI4 to %pI4\\n\",\n\t\t       __func__, &old_saddr, &new_saddr);\n\t}\n\n\tinet->inet_saddr = inet->inet_rcv_saddr = new_saddr;\n\n\t__sk_prot_rehash(sk);\n\treturn 0;\n}",
        "output": "1",
        "idx": 320
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main(int argc, char *argv[])\n{\n   libettercap_init();\n   ef_globals_alloc();\n   select_text_interface();\n   libettercap_ui_init();\n   fprintf(stdout, \"\\n\" EC_COLOR_BOLD \"%s %s\" EC_COLOR_END \" copyright %s %s\\n\\n\", \n                      PROGRAM, EC_VERSION, EC_COPYRIGHT, EC_AUTHORS);\n \n   EF_GBL->lineno = 1;\n  \n   parse_options(argc, argv);\n\n   if (EF_GBL_OPTIONS->source_file) {\n      yyin = fopen(EF_GBL_OPTIONS->source_file, \"r\");\n      if (yyin == NULL)\n         FATAL_ERROR(\"Input file not found !\");\n   } else {\n      FATAL_ERROR(\"No source file.\");\n   }\n\n   setbuf(yyin, NULL);\n   setbuf(stdout, NULL);\n   setbuf(stderr, NULL);\n\n   \n   load_tables();\n   load_constants();\n\n   fprintf(stdout, \"\\n Parsing source file \\'%s\\' \", EF_GBL_OPTIONS->source_file);\n   fflush(stdout);\n\n   ef_debug(1, \"\\n\");\n\n   if (yyparse() == 0)\n      fprintf(stdout, \" done.\\n\\n\");\n   else\n      fprintf(stdout, \"\\n\\nThe script contains errors...\\n\\n\");\n  \n   if (write_output() != E_SUCCESS)\n      FATAL_ERROR(\"Cannot write output file (%s)\", EF_GBL_OPTIONS->output_file);\n   ef_globals_free();\n   return 0;\n}",
        "output": "1",
        "idx": 6562
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc,\n\t\t       struct ath_node *an)\n{\n\tstruct ath_atx_tid *tid;\n\tstruct ath_atx_ac *ac;\n\tstruct ath_txq *txq;\n\tbool buffered;\n\tint tidno;\n\n\tfor (tidno = 0, tid = &an->tid[tidno];\n\t     tidno < IEEE80211_NUM_TIDS; tidno++, tid++) {\n\n\t\tif (!tid->sched)\n\t\t\tcontinue;\n\n\t\tac = tid->ac;\n\t\ttxq = ac->txq;\n\n\t\tath_txq_lock(sc, txq);\n\n\t\tbuffered = ath_tid_has_buffered(tid);\n\n\t\ttid->sched = false;\n\t\tlist_del(&tid->list);\n\n\t\tif (ac->sched) {\n\t\t\tac->sched = false;\n\t\t\tlist_del(&ac->list);\n\t\t}\n\n\t\tath_txq_unlock(sc, txq);\n\n\t\tieee80211_sta_set_buffered(sta, tidno, buffered);\n\t}\n}",
        "output": "1",
        "idx": 2522
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "snmp_mib_find_next(uint32_t *oid)\n{\n  snmp_mib_resource_t *resource;\n\n  resource = NULL;\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource->next) {\n\n    if(snmp_oid_cmp_oid(resource->oid, oid) > 0) {\n      return resource;\n    }\n  }\n\n  return NULL;\n}",
        "output": "1",
        "idx": 7980
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned long stack_maxrandom_size(void)\n{\n\tunsigned long max = 0;\n\tif ((current->flags & PF_RANDOMIZE) &&\n\t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\tmax = ((-1UL) & STACK_RND_MASK) << PAGE_SHIFT;\n\t}\n\n\treturn max;\n}",
        "output": "0",
        "idx": 3863
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ion_handle_put(struct ion_handle *handle)\n{\n\tstruct ion_client *client = handle->client;\n\tint ret;\n\n\tmutex_lock(&client->lock);\n\tret = ion_handle_put_nolock(handle);\n\tmutex_unlock(&client->lock);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 1695
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn;\n\truntime = substream->runtime;\n\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (!snd_pcm_running(substream) ||\n\t    snd_pcm_update_hw_ptr0(substream, 1) < 0)\n\t\tgoto _end;\n\n#ifdef CONFIG_SND_PCM_TIMER\n\tif (substream->timer_running)\n\t\tsnd_timer_interrupt(substream->timer, 1);\n#endif\n _end:\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n\tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n}",
        "output": "1",
        "idx": 1226
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cib_send_tls(gnutls_session * session, xmlNode * msg)\n{\n    char *xml_text = NULL;\n\n#  if 0\n    const char *name = crm_element_name(msg);\n\n    if (safe_str_neq(name, \"cib_command\")) {\n        xmlNodeSetName(msg, \"cib_result\");\n    }\n#  endif\n    xml_text = dump_xml_unformatted(msg);\n    if (xml_text != NULL) {\n        char *unsent = xml_text;\n        int len = strlen(xml_text);\n        int rc = 0;\n\n        len++;                  \n        crm_trace(\"Message size: %d\", len);\n\n        while (TRUE) {\n            rc = gnutls_record_send(*session, unsent, len);\n            crm_debug(\"Sent %d bytes\", rc);\n\n            if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n                crm_debug(\"Retry\");\n\n            } else if (rc < 0) {\n                crm_debug(\"Connection terminated\");\n                break;\n\n            } else if (rc < len) {\n                crm_debug(\"Only sent %d of %d bytes\", rc, len);\n                len -= rc;\n                unsent += rc;\n            } else {\n                break;\n            }\n        }\n\n    }\n    free(xml_text);\n    return NULL;\n\n}",
        "output": "1",
        "idx": 3738
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int wait_for_key_construction(struct key *key, bool intr)\n{\n\tint ret;\n\n\tret = wait_on_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT,\n\t\t\t  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\tif (ret)\n\t\treturn -ERESTARTSYS;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n\t\tsmp_rmb();\n\t\treturn key->reject_error;\n\t}\n\treturn key_validate(key);\n}",
        "output": "1",
        "idx": 1738
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int fpregs_state_valid(struct fpu *fpu, unsigned int cpu)\n{\n\treturn fpu == this_cpu_read(fpu_fpregs_owner_ctx) && cpu == fpu->last_cpu;\n}",
        "output": "0",
        "idx": 4585
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void mb2_cache_entry_delete_block(struct mb2_cache *cache, u32 key,\n\t\t\t\t  sector_t block)\n{\n\tstruct hlist_bl_node *node;\n\tstruct hlist_bl_head *head;\n\tstruct mb2_cache_entry *entry;\n\n\thead = &cache->c_hash[hash_32(key, cache->c_bucket_bits)];\n\thlist_bl_lock(head);\n\thlist_bl_for_each_entry(entry, node, head, e_hash_list) {\n\t\tif (entry->e_key == key && entry->e_block == block) {\n\t\t\thlist_bl_del_init(&entry->e_hash_list);\n\t\t\thlist_bl_unlock(head);\n\t\t\tspin_lock(&cache->c_lru_list_lock);\n\t\t\tif (!list_empty(&entry->e_lru_list)) {\n\t\t\t\tlist_del_init(&entry->e_lru_list);\n\t\t\t\tcache->c_entry_count--;\n\t\t\t\tatomic_dec(&entry->e_refcnt);\n\t\t\t}\n\t\t\tspin_unlock(&cache->c_lru_list_lock);\n\t\t\tmb2_cache_entry_put(cache, entry);\n\t\t\treturn;\n\t\t}\n\t}\n\thlist_bl_unlock(head);\n}",
        "output": "0",
        "idx": 1615
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int json_c_get_random_seed()\n{\n#if HAVE_RDRAND\n    if (has_rdrand()) return get_rdrand_seed();\n#endif\n#if HAVE_DEV_RANDOM\n    if (has_dev_urandom()) return get_dev_random_seed();\n#endif\n#if HAVE_CRYPTGENRANDOM\n    return get_cryptgenrandom_seed();\n#endif\n    return get_time_seed();\n}",
        "output": "0",
        "idx": 5951
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sctp_generate_timeout_event(struct sctp_association *asoc,\n\t\t\t\t\tsctp_event_timeout_t timeout_type)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\tint error = 0;\n\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy: timer %d\\n\", __func__,\n\t\t\t timeout_type);\n\n\t\tif (!mod_timer(&asoc->timers[timeout_type], jiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(timeout_type),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   (void *)timeout_type, GFP_ATOMIC);\n\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\n\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_association_put(asoc);\n}",
        "output": "1",
        "idx": 2916
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"ablkcipher\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t alg->cra_ablkcipher.geniv ?: \"<default>\");\n\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "1",
        "idx": 840
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "smb_com_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t\t*file;\n\tsmb_llist_t\t*flist;\n\tint\t\trc;\n\n\tif (smb_flush_required == 0) {\n\t\trc = smbsr_encode_empty_result(sr);\n\t\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n\t}\n\n\tif (sr->smb_fid != 0xffff) {\n\t\tsmbsr_lookup_file(sr);\n\t\tif (sr->fid_ofile == NULL) {\n\t\t\tsmbsr_error(sr, NT_STATUS_INVALID_HANDLE,\n\t\t\t    ERRDOS, ERRbadfid);\n\t\t\treturn (SDRC_ERROR);\n\t\t}\n\t\tsmb_ofile_flush(sr, sr->fid_ofile);\n\t} else {\n\t\tflist = &sr->tid_tree->t_ofile_list;\n\t\tsmb_llist_enter(flist, RW_READER);\n\t\tfile = smb_llist_head(flist);\n\t\twhile (file) {\n\t\t\tmutex_enter(&file->f_mutex);\n\t\t\tsmb_ofile_flush(sr, file);\n\t\t\tmutex_exit(&file->f_mutex);\n\t\t\tfile = smb_llist_next(flist, file);\n\t\t}\n\t\tsmb_llist_exit(flist);\n\t}\n\n\trc = smbsr_encode_empty_result(sr);\n\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n}",
        "output": "0",
        "idx": 6859
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void handle_ld_nf(u32 insn, struct pt_regs *regs)\n{\n\tint rd = ((insn >> 25) & 0x1f);\n\tint from_kernel = (regs->tstate & TSTATE_PRIV) != 0;\n\tunsigned long *reg;\n\t                        \n\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);\n\n\tmaybe_flush_windows(0, 0, rd, from_kernel);\n\treg = fetch_reg_addr(rd, regs);\n\tif (from_kernel || rd < 16) {\n\t\treg[0] = 0;\n\t\tif ((insn & 0x780000) == 0x180000)\n\t\t\treg[1] = 0;\n\t} else if (test_thread_flag(TIF_32BIT)) {\n\t\tput_user(0, (int __user *) reg);\n\t\tif ((insn & 0x780000) == 0x180000)\n\t\t\tput_user(0, ((int __user *) reg) + 1);\n\t} else {\n\t\tput_user(0, (unsigned long __user *) reg);\n\t\tif ((insn & 0x780000) == 0x180000)\n\t\t\tput_user(0, (unsigned long __user *) reg + 1);\n\t}\n\tadvance(regs);\n}",
        "output": "1",
        "idx": 484
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\n\tif (submodule_url_is_relative(url)) {\n\t\tchar *decoded = url_decode(url);\n\t\tint has_nl = !!strchr(decoded, '\\n');\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\t}\n\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 5180
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, fmode_t mode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *pos, *ctx = NULL;\n\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(pos, &nfsi->open_files, list) {\n\t\tif (cred != NULL && pos->cred != cred)\n\t\t\tcontinue;\n\t\tif ((pos->mode & mode) == mode) {\n\t\t\tctx = get_nfs_open_context(pos);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn ctx;\n}",
        "output": "0",
        "idx": 3027
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_delete_sec_context(\n\t\t\t    OM_uint32 *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t output_token)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\tspnego_gss_ctx_id_t *ctx =\n\t\t    (spnego_gss_ctx_id_t *)context_handle;\n\n\t*minor_status = 0;\n\n\tif (context_handle == NULL)\n\t\treturn (GSS_S_FAILURE);\n\n\tif (*ctx == NULL)\n\t\treturn (GSS_S_COMPLETE);\n\n\t(void) gss_delete_sec_context(minor_status, &(*ctx)->ctx_handle,\n\t\t\t\t      output_token);\n\t(void) release_spnego_ctx(ctx);\n\n\treturn (ret);\n}",
        "output": "0",
        "idx": 93
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cJSON_strcasecmp(const char *s1,const char *s2)\n{\n\tif (!s1) return (s1==s2)?0:1;if (!s2) return 1;\n\tfor(; tolower(*s1) == tolower(*s2); ++s1, ++s2)\tif(*s1 == 0)\treturn 0;\n\treturn tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);\n}",
        "output": "0",
        "idx": 8345
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...) \n{\n\tva_list va;\n\tchar *message = NULL;\n\n\tva_start(va, format);\n\tzend_vspprintf(&message, 0, format, va);\n\n\tif (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {\n\t\tzend_throw_error(exception_ce, message);\n\t} else {\n\t\tzend_error(E_ERROR, \"%s\", message);\n\t}\n\n\tefree(message);\n\tva_end(va);\n}",
        "output": "1",
        "idx": 3820
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct ib_ucontext *hns_roce_alloc_ucontext(struct ib_device *ib_dev,\n\t\t\t\t\t\t   struct ib_udata *udata)\n{\n\tint ret = 0;\n\tstruct hns_roce_ucontext *context;\n\tstruct hns_roce_ib_alloc_ucontext_resp resp = {};\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\n\n\tresp.qp_tab_size = hr_dev->caps.num_qps;\n\n\tcontext = kmalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = hns_roce_uar_alloc(hr_dev, &context->uar);\n\tif (ret)\n\t\tgoto error_fail_uar_alloc;\n\n\tif (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RECORD_DB) {\n\t\tINIT_LIST_HEAD(&context->page_list);\n\t\tmutex_init(&context->page_mutex);\n\t}\n\n\tret = ib_copy_to_udata(udata, &resp, sizeof(resp));\n\tif (ret)\n\t\tgoto error_fail_copy_to_udata;\n\n\treturn &context->ibucontext;\n\nerror_fail_copy_to_udata:\n\thns_roce_uar_free(hr_dev, &context->uar);\n\nerror_fail_uar_alloc:\n\tkfree(context);\n\n\treturn ERR_PTR(ret);\n}",
        "output": "0",
        "idx": 2689
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr)\n{\n\tconsole_verbose();\n\n\tpr_crit(\"Bad mode in %s handler detected, code 0x%08x\\n\",\n\t\thandler[reason], esr);\n\n\tdie(\"Oops - bad mode\", regs, 0);\n\tlocal_irq_disable();\n\tpanic(\"bad mode\");\n}",
        "output": "1",
        "idx": 2290
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\n\tbox = 0;\n\tout = 0;\n\treturn -1;\n}",
        "output": "0",
        "idx": 7629
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n\n    *pred_rtrn = MATCH_EXACTLY;\n    if (expr->expr.op == EXPR_ACTION_DECL) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {\n            log_err(info->ctx,\n                    \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n            return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}",
        "output": "1",
        "idx": 7002
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rcomp;\n\n\tstrncpy(rcomp.type, \"compression\", sizeof(rcomp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "0",
        "idx": 1181
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool check_reg_sane_offset(struct bpf_verifier_env *env,\n\t\t\t\t  const struct bpf_reg_state *reg,\n\t\t\t\t  enum bpf_reg_type type)\n{\n\tbool known = tnum_is_const(reg->var_off);\n\ts64 val = reg->var_off.value;\n\ts64 smin = reg->smin_value;\n\n\tif (known && (val >= BPF_MAX_VAR_OFF || val <= -BPF_MAX_VAR_OFF)) {\n\t\tverbose(env, \"math between %s pointer and %lld is not allowed\\n\",\n\t\t\treg_type_str[type], val);\n\t\treturn false;\n\t}\n\n\tif (reg->off >= BPF_MAX_VAR_OFF || reg->off <= -BPF_MAX_VAR_OFF) {\n\t\tverbose(env, \"%s pointer offset %d is not allowed\\n\",\n\t\t\treg_type_str[type], reg->off);\n\t\treturn false;\n\t}\n\n\tif (smin == S64_MIN) {\n\t\tverbose(env, \"math between %s pointer and register with unbounded min value is not allowed\\n\",\n\t\t\treg_type_str[type]);\n\t\treturn false;\n\t}\n\n\tif (smin >= BPF_MAX_VAR_OFF || smin <= -BPF_MAX_VAR_OFF) {\n\t\tverbose(env, \"value %lld makes %s pointer be out of bounds\\n\",\n\t\t\tsmin, reg_type_str[type]);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
        "output": "0",
        "idx": 2619
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tunsigned long limit;\n\tshort sel;\n\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn 0;\n\n\tif (user_64bit_mode(regs) || v8086_mode(regs))\n\t\treturn -1L;\n\n\tif (!sel)\n\t\treturn 0;\n\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn 0;\n\n\tlimit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tlimit = (limit << 12) + 0xfff;\n\n\treturn limit;\n}",
        "output": "1",
        "idx": 3190
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "exif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,\n\t\t\t       unsigned int ds, ExifLong o, ExifLong s)\n{\n\tif ((o + s < o) || (o + s < s) || (o + s > ds) || (o > ds)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t  \"Bogus thumbnail offset (%u) or size (%u).\",\n\t\t\t  o, s);\n\t\treturn;\n\t}\n\n\tif (data->data) \n\t\texif_mem_free (data->priv->mem, data->data);\n\tif (!(data->data = exif_data_alloc (data, s))) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", s);\n\t\tdata->size = 0;\n\t\treturn;\n\t}\n\tdata->size = s;\n\tmemcpy (data->data, d + o, s);\n}",
        "output": "1",
        "idx": 7116
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_rename(const char *path)\n{\n\tchar *d = strdupa(path), *tmpname;\n\td = dirname(d);\n\tsize_t len = strlen(path) + 30;\n\n\ttmpname = alloca(len);\n\tsnprintf(tmpname, len, \"%s/%d\", d, (int)getpid());\n\tif (rename(path, tmpname) == 0 || errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at rename of %s\\n\", path);\n\t\texit(1);\n\t}\n}",
        "output": "0",
        "idx": 7299
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int dev_forward_skb(struct net_device *dev, struct sk_buff *skb)\n{\n\tskb_orphan(skb);\n\n\tif (!(dev->flags & IFF_UP) ||\n\t    (skb->len > (dev->mtu + dev->hard_header_len))) {\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\tskb_set_dev(skb, dev);\n\tskb->tstamp.tv64 = 0;\n\tskb->pkt_type = PACKET_HOST;\n\tskb->protocol = eth_type_trans(skb, dev);\n\treturn netif_rx(skb);\n}",
        "output": "0",
        "idx": 319
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseContentCompress(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprJson     *child;\n    int         ji;\n\n    for (ITERATE_CONFIG(route, prop, child, ji)) {\n        if (mprReadJson(route->config, sfmt(\"app.http.content.minify[@ = '%s']\", child->value))) {\n            httpAddRouteMapping(route, child->value, \"${1}.gz, min.${1}.gz, min.${1}\");\n        } else {\n            httpAddRouteMapping(route, child->value, \"${1}.gz\");\n        }\n    }\n}",
        "output": "0",
        "idx": 7017
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rpki_rtr_print(netdissect_options *ndo, register const u_char *pptr, register u_int len)\n{\n    u_int tlen, pdu_type, pdu_len;\n    const u_char *tptr;\n    const rpki_rtr_pdu *pdu_header;\n\n    tptr = pptr;\n    tlen = len;\n\n    if (!ndo->ndo_vflag) {\n\tND_PRINT((ndo, \", RPKI-RTR\"));\n\treturn;\n    }\n\n    while (tlen >= sizeof(rpki_rtr_pdu)) {\n\n        ND_TCHECK2(*tptr, sizeof(rpki_rtr_pdu));\n\n\tpdu_header = (const rpki_rtr_pdu *)tptr;\n        pdu_type = pdu_header->pdu_type;\n        pdu_len = EXTRACT_32BITS(pdu_header->length);\n        ND_TCHECK2(*tptr, pdu_len);\n\n        if (!pdu_type || !pdu_len) {\n            break;\n        }\n\n        if (tlen < pdu_len) {\n            goto trunc;\n        }\n\n\tif (rpki_rtr_pdu_print(ndo, tptr, 8))\n\t\tgoto trunc;\n\n        tlen -= pdu_len;\n        tptr += pdu_len;\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"\\n\\t%s\", tstr));\n}",
        "output": "1",
        "idx": 4846
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n{\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn -1;\n\n\tStream_Read(s, header->Signature, 8);\n\tStream_Read_UINT32(s, header->MessageType);\n\n\tif (strncmp((char*) header->Signature, NTLM_SIGNATURE, 8) != 0)\n\t\treturn -1;\n\n\treturn 1;\n}",
        "output": "1",
        "idx": 4204
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void sctp_generate_heartbeat_event(unsigned long data)\n{\n\tint error = 0;\n\tstruct sctp_transport *transport = (struct sctp_transport *) data;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct sock *sk = asoc->base.sk;\n\tstruct net *net = sock_net(sk);\n\n\tbh_lock_sock(sk);\n\tif (sock_owned_by_user(sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\n\t\tif (!mod_timer(&transport->hb_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_HEARTBEAT),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\n\tif (error)\n\t\tsk->sk_err = -error;\n\nout_unlock:\n\tbh_unlock_sock(sk);\n\tsctp_transport_put(transport);\n}",
        "output": "0",
        "idx": 4029
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseLanguages(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprJson     *child;\n    cchar       *path, *prefix, *suffix;\n    int         ji;\n\n    for (ITERATE_CONFIG(route, prop, child, ji)) {\n        if ((prefix = mprGetJson(child, \"prefix\")) != 0) {\n            httpAddRouteLanguageSuffix(route, child->name, child->value, HTTP_LANG_BEFORE);\n        }\n        if ((suffix = mprGetJson(child, \"suffix\")) != 0) {\n            httpAddRouteLanguageSuffix(route, child->name, child->value, HTTP_LANG_AFTER);\n        }\n        if ((path = mprGetJson(child, \"path\")) != 0) {\n            httpAddRouteLanguageDir(route, child->name, mprGetAbsPath(path));\n        }\n        if (smatch(mprGetJson(child, \"default\"), \"default\")) {\n            httpSetRouteDefaultLanguage(route, child->name);\n        }\n    }\n}",
        "output": "1",
        "idx": 5040
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sample_hbp_handler(struct perf_event *bp,\n\t\t\t       struct perf_sample_data *data,\n\t\t\t       struct pt_regs *regs)\n{\n\tprintk(KERN_INFO \"%s value is changed\\n\", ksym_name);\n\tdump_stack();\n\tprintk(KERN_INFO \"Dump stack from sample_hbp_handler\\n\");\n}",
        "output": "0",
        "idx": 713
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void oidc_scrub_headers(request_rec *r) {\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tif (cfg->scrub_request_headers != 0) {\n\n\t\toidc_scrub_request_headers(r, OIDC_DEFAULT_HEADER_PREFIX,\n\t\t\t\toidc_cfg_dir_authn_header(r));\n\n\t\tif ((strstr(cfg->claim_prefix, OIDC_DEFAULT_HEADER_PREFIX)\n\t\t\t\t!= cfg->claim_prefix)) {\n\t\t\toidc_scrub_request_headers(r, cfg->claim_prefix, NULL);\n\t\t}\n\t}\n}",
        "output": "1",
        "idx": 6388
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)\n{\n\tstruct pipe_buffer *bufs;\n\n\tif (nr_pages < pipe->nrbufs)\n\t\treturn -EBUSY;\n\n\tbufs = kcalloc(nr_pages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\n\tif (pipe->nrbufs) {\n\t\tunsigned int tail;\n\t\tunsigned int head;\n\n\t\ttail = pipe->curbuf + pipe->nrbufs;\n\t\tif (tail < pipe->buffers)\n\t\t\ttail = 0;\n\t\telse\n\t\t\ttail &= (pipe->buffers - 1);\n\n\t\thead = pipe->nrbufs - tail;\n\t\tif (head)\n\t\t\tmemcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));\n\t\tif (tail)\n\t\t\tmemcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));\n\t}\n\n\taccount_pipe_buffers(pipe, pipe->buffers, nr_pages);\n\tpipe->curbuf = 0;\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->buffers = nr_pages;\n\treturn nr_pages * PAGE_SIZE;\n}",
        "output": "0",
        "idx": 1557
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "perf_event_read_event(struct perf_event *event,\n\t\t\tstruct task_struct *task)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tstruct perf_read_event read_event = {\n\t\t.header = {\n\t\t\t.type = PERF_RECORD_READ,\n\t\t\t.misc = 0,\n\t\t\t.size = sizeof(read_event) + event->read_size,\n\t\t},\n\t\t.pid = perf_event_pid(event, task),\n\t\t.tid = perf_event_tid(event, task),\n\t};\n\tint ret;\n\n\tperf_event_header__init_id(&read_event.header, &sample, event);\n\tret = perf_output_begin(&handle, event, read_event.header.size, 0, 0);\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, read_event);\n\tperf_output_read(&handle, event);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\n}",
        "output": "1",
        "idx": 542
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode)\n{\n\tint result = parse_rock_ridge_inode_internal(de, inode, 0);\n\n\tif ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)\n\t    && (ISOFS_SB(inode->i_sb)->s_rock == 2)) {\n\t\tresult = parse_rock_ridge_inode_internal(de, inode, 14);\n\t}\n\treturn result;\n}",
        "output": "1",
        "idx": 2640
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_event_init_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\n\tmutex_lock(&swhash->hlist_mutex);\n\tswhash->online = true;\n\tif (swhash->hlist_refcount > 0) {\n\t\tstruct swevent_hlist *hlist;\n\n\t\thlist = kzalloc_node(sizeof(*hlist), GFP_KERNEL, cpu_to_node(cpu));\n\t\tWARN_ON(!hlist);\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tmutex_unlock(&swhash->hlist_mutex);\n}",
        "output": "1",
        "idx": 1018
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_bearer_cap_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_CAP_ANALOG_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_CAP_DIGITAL_MASK) {\n\t\tND_PRINT((ndo, \"D\"));\n\t}\n}",
        "output": "0",
        "idx": 6659
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __detach_mounts(struct dentry *dentry)\n{\n\tstruct mountpoint *mp;\n\tstruct mount *mnt;\n\n\tnamespace_lock();\n\tmp = lookup_mountpoint(dentry);\n\tif (!mp)\n\t\tgoto out_unlock;\n\n\tlock_mount_hash();\n\twhile (!hlist_empty(&mp->m_list)) {\n\t\tmnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);\n\t\tif (mnt->mnt.mnt_flags & MNT_UMOUNT) {\n\t\t\tstruct mount *p, *tmp;\n\t\t\tlist_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {\n\t\t\t\thlist_add_head(&p->mnt_umount.s_list, &unmounted);\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\telse umount_tree(mnt, 0);\n\t}\n\tunlock_mount_hash();\n\tput_mountpoint(mp);\nout_unlock:\n\tnamespace_unlock();\n}",
        "output": "0",
        "idx": 3911
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvm_set_guest_paused(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->arch.pv_time_enabled)\n\t\treturn -EINVAL;\n\tvcpu->arch.pvclock_set_guest_stopped_request = true;\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\treturn 0;\n}",
        "output": "0",
        "idx": 1251
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvaser_usb_leaf_set_opt_mode(const struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->id = CMD_SET_CTRL_MODE;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_ctrl_mode);\n\tcmd->u.ctrl_mode.tid = 0xff;\n\tcmd->u.ctrl_mode.channel = priv->channel;\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tcmd->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_SILENT;\n\telse\n\t\tcmd->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_NORMAL;\n\n\trc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len);\n\n\tkfree(cmd);\n\treturn rc;\n}",
        "output": "1",
        "idx": 3310
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int save_dev(blkid_dev dev, FILE *file)\n{\n\tstruct list_head *p;\n\n\tif (!dev || dev->bid_name[0] != '/')\n\t\treturn 0;\n\n\tDBG(SAVE, ul_debug(\"device %s, type %s\", dev->bid_name, dev->bid_type ?\n\t\t   dev->bid_type : \"(null)\"));\n\n\tfprintf(file, \"<device DEVNO=\\\"0x%04lx\\\" TIME=\\\"%ld.%ld\\\"\",\n\t\t\t(unsigned long) dev->bid_devno,\n\t\t\t(long) dev->bid_time,\n\t\t\t(long) dev->bid_utime);\n\n\tif (dev->bid_pri)\n\t\tfprintf(file, \" PRI=\\\"%d\\\"\", dev->bid_pri);\n\tlist_for_each(p, &dev->bid_tags) {\n\t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);\n\t\tfprintf(file, \" %s=\\\"%s\\\"\", tag->bit_name,tag->bit_val);\n\t}\n\tfprintf(file, \">%s</device>\\n\", dev->bid_name);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 4642
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ptrace_check_attach(struct task_struct *child, bool ignore_state)\n{\n\tint ret = -ESRCH;\n\n\tread_lock(&tasklist_lock);\n\tif ((child->ptrace & PT_PTRACED) && child->parent == current) {\n\t\tspin_lock_irq(&child->sighand->siglock);\n\t\tWARN_ON_ONCE(task_is_stopped(child));\n\t\tif (ignore_state || (task_is_traced(child) &&\n\t\t\t\t     !(child->jobctl & JOBCTL_LISTENING)))\n\t\t\tret = 0;\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\t}\n\tread_unlock(&tasklist_lock);\n\n\tif (!ret && !ignore_state)\n\t\tret = wait_task_inactive(child, TASK_TRACED) ? 0 : -ESRCH;\n\n\treturn ret;\n}",
        "output": "1",
        "idx": 816
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void IGDstartelt(void * d, const char * name, int l)\n{\n\tstruct IGDdatas * datas = (struct IGDdatas *)d;\n\tif(l >= MINIUPNPC_URL_MAXSIZE)\n\t\tl = MINIUPNPC_URL_MAXSIZE-1;\n\tmemcpy(datas->cureltname, name, l);\n\tdatas->cureltname[l] = '\\0';\n\tdatas->level++;\n\tif( (l==7) && !memcmp(name, \"service\", l) ) {\n\t\tdatas->tmp.controlurl[0] = '\\0';\n\t\tdatas->tmp.eventsuburl[0] = '\\0';\n\t\tdatas->tmp.scpdurl[0] = '\\0';\n\t\tdatas->tmp.servicetype[0] = '\\0';\n\t}\n}",
        "output": "0",
        "idx": 6397
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int setup_dev_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console)\n{\n\tchar path[MAXPATHLEN];\n\tstruct stat s;\n\tint ret;\n\n\tret = snprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\n\tif (access(path, F_OK)) {\n\t\tWARN(\"rootfs specified but no console found at '%s'\", path);\n\t\treturn 0;\n\t}\n\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\n\tif (stat(path, &s)) {\n\t\tSYSERROR(\"failed to stat '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif (chmod(console->name, s.st_mode)) {\n\t\tSYSERROR(\"failed to set mode '0%o' to '%s'\",\n\t\t\t s.st_mode, console->name);\n\t\treturn -1;\n\t}\n\n\tif (safe_mount(console->name, path, \"none\", MS_BIND, 0, rootfs->mount)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, path);\n\t\treturn -1;\n\t}\n\n\tINFO(\"console has been setup\");\n\treturn 0;\n}",
        "output": "0",
        "idx": 6031
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int rm_rf_child(int fd, const char *name, RemoveFlags flags) {\n\n\n        if (fd < 0)\n                return -EBADF;\n\n        if (!filename_is_valid(name))\n                return -EINVAL;\n\n        if ((flags & (REMOVE_ROOT|REMOVE_MISSING_OK)) != 0) \n                return -EINVAL;\n\n        if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))\n                return -EINVAL;\n\n        return rm_rf_inner_child(fd, name, -1, flags, NULL, true);\n}",
        "output": "0",
        "idx": 7705
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, fgets)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (spl_filesystem_file_read(intern, 0 TSRMLS_CC) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);\n} ",
        "output": "0",
        "idx": 5531
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PyMemoTable_Set(PyMemoTable *self, PyObject *key, Py_ssize_t value)\n{\n    PyMemoEntry *entry;\n\n    assert(key != NULL);\n\n    entry = _PyMemoTable_Lookup(self, key);\n    if (entry->me_key != NULL) {\n        entry->me_value = value;\n        return 0;\n    }\n    Py_INCREF(key);\n    entry->me_key = key;\n    entry->me_value = value;\n    self->mt_used++;\n\n    if (!(self->mt_used * 3 >= (self->mt_mask + 1) * 2))\n        return 0;\n    return _PyMemoTable_ResizeTable(self,\n        (self->mt_used > 50000 ? 2 : 4) * self->mt_used);\n}",
        "output": "1",
        "idx": 7160
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n{\n\tu8 *buf = NULL;\n\tint err;\n\n\tif (!seed && slen) {\n\t\tbuf = kmalloc(slen, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\tget_random_bytes(buf, slen);\n\t\tseed = buf;\n\t}\n\n\terr = tfm->seed(tfm, seed, slen);\n\n\tkfree(buf);\n\treturn err;\n}",
        "output": "1",
        "idx": 2836
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_i2c_read(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t       char *const argv[])\n{\n\tuint\tchip;\n\tuint\tdevaddr, length;\n\tint alen;\n\tu_char  *memaddr;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\n\tif (argc != 5)\n\t\treturn CMD_RET_USAGE;\n\n\tchip = hextoul(argv[1], NULL);\n\n\tdevaddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n\n\tlength = hextoul(argv[3], NULL);\n\n\tmemaddr = (u_char *)hextoul(argv[4], NULL);\n\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (!ret)\n\t\tret = dm_i2c_read(dev, devaddr, memaddr, length);\n#else\n\tret = i2c_read(chip, devaddr, alen, memaddr, length);\n#endif\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 7392
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_cipher rcipher;\n\n\tstrlcpy(rcipher.type, \"cipher\", sizeof(rcipher.type));\n\n\trcipher.blocksize = alg->cra_blocksize;\n\trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n\trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\n\t\t    sizeof(struct crypto_report_cipher), &rcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "1",
        "idx": 3036
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "nfs4_state_set_mode_locked(struct nfs4_state *state, fmode_t fmode)\n{\n\tif (state->state == fmode)\n\t\treturn;\n\tif ((fmode & FMODE_WRITE) != (state->state & FMODE_WRITE)) {\n\t\tif (fmode & FMODE_WRITE)\n\t\t\tlist_move(&state->open_states, &state->owner->so_states);\n\t\telse\n\t\t\tlist_move_tail(&state->open_states, &state->owner->so_states);\n\t}\n\tstate->state = fmode;\n}",
        "output": "0",
        "idx": 3085
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "TRIO_PUBLIC_STRING size_t trio_length TRIO_ARGS1((string), TRIO_CONST char* string)\n{\n\treturn strlen(string);\n}",
        "output": "1",
        "idx": 4186
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void check_file(char *basename)\n{\n    gdImagePtr im;\n    char *buffer;\n    size_t size;\n\n    size = read_test_file(&buffer, basename);\n    im = gdImageCreateFromTgaPtr(size, (void *) buffer);\n    gdTestAssert(im == NULL);\n    free(buffer);\n}",
        "output": "0",
        "idx": 6207
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void hsr_del_node(struct list_head *self_node_db)\n{\n\tstruct hsr_node *node;\n\n\trcu_read_lock();\n\tnode = list_first_or_null_rcu(self_node_db, struct hsr_node, mac_list);\n\trcu_read_unlock();\n\tif (node) {\n\t\tlist_del_rcu(&node->mac_list);\n\t\tkfree(node);\n\t}\n}",
        "output": "0",
        "idx": 4289
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ion_free_nolock(struct ion_client *client, struct ion_handle *handle)\n{\n\tbool valid_handle;\n\n\tBUG_ON(client != handle->client);\n\n\tvalid_handle = ion_handle_validate(client, handle);\n\n\tif (!valid_handle) {\n\t\tWARN(1, \"%s: invalid handle passed to free.\\n\", __func__);\n\t\treturn;\n\t}\n\tion_handle_put_nolock(handle);\n}",
        "output": "0",
        "idx": 1685
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int verify_replay(struct xfrm_usersa_info *p,\n\t\t\t\tstruct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_REPLAY_ESN_VAL];\n\n\tif ((p->flags & XFRM_STATE_ESN) && !rt)\n\t\treturn -EINVAL;\n\n\tif (!rt)\n\t\treturn 0;\n\n\tif (p->id.proto != IPPROTO_ESP)\n\t\treturn -EINVAL;\n\n\tif (p->replay_window != 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 772
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void handle_irq_for_port(evtchn_port_t port, struct evtchn_loop_ctrl *ctrl)\n{\n\tint irq;\n\tstruct irq_info *info;\n\n\tirq = get_evtchn_to_irq(port);\n\tif (irq == -1)\n\t\treturn;\n\n\tif (!ctrl->defer_eoi && !(++ctrl->count & 0xff)) {\n\t\tktime_t kt = ktime_get();\n\n\t\tif (!ctrl->timeout) {\n\t\t\tkt = ktime_add_ms(kt,\n\t\t\t\t\t  jiffies_to_msecs(event_loop_timeout));\n\t\t\tctrl->timeout = kt;\n\t\t} else if (kt > ctrl->timeout) {\n\t\t\tctrl->defer_eoi = true;\n\t\t}\n\t}\n\n\tinfo = info_for_irq(irq);\n\n\tif (ctrl->defer_eoi) {\n\t\tinfo->eoi_cpu = smp_processor_id();\n\t\tinfo->irq_epoch = __this_cpu_read(irq_epoch);\n\t\tinfo->eoi_time = get_jiffies_64() + event_eoi_delay;\n\t}\n\n\tgeneric_handle_irq(irq);\n}",
        "output": "0",
        "idx": 2739
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int su3000_power_ctrl(struct dvb_usb_device *d, int i)\n{\n\tstruct dw2102_state *state = (struct dw2102_state *)d->priv;\n\tint ret = 0;\n\n\tinfo(\"%s: %d, initialized %d\", __func__, i, state->initialized);\n\n\tif (i && !state->initialized) {\n\t\tmutex_lock(&d->data_mutex);\n\n\t\tstate->data[0] = 0xde;\n\t\tstate->data[1] = 0;\n\n\t\tstate->initialized = 1;\n\t\tret = dvb_usb_generic_rw(d, state->data, 2, NULL, 0, 0);\n\t\tmutex_unlock(&d->data_mutex);\n\t}\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 2187
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iakerb_gss_unwrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                  gss_buffer_t input_message_buffer,\n                  gss_buffer_t output_message_buffer, int *conf_state,\n                  gss_qop_t *qop_state)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_unwrap(minor_status, ctx->gssc, input_message_buffer,\n                           output_message_buffer, conf_state, qop_state);\n}",
        "output": "0",
        "idx": 139
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int discovery_stop(struct discovery_client *client)\n{\n\tstruct btd_adapter *adapter = client->adapter;\n\tstruct mgmt_cp_stop_discovery cp;\n\n\tif (g_slist_next(adapter->discovery_list)) {\n\t\tdiscovery_remove(client);\n\t\tupdate_discovery_filter(adapter);\n\t\treturn 0;\n\t}\n\n\tif (adapter->discovery_discoverable)\n\t\tset_discovery_discoverable(adapter, false);\n\n\tif (adapter->discovery_enable == 0x00) {\n\t\tdiscovery_remove(client);\n\t\tadapter->discovering = false;\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");\n\n\t\ttrigger_passive_scanning(adapter);\n\n\t\treturn 0;\n\t}\n\n\tcp.type = adapter->discovery_type;\n\tadapter->client = client;\n\n\tmgmt_send(adapter->mgmt, MGMT_OP_STOP_DISCOVERY,\n\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\tstop_discovery_complete, adapter, NULL);\n\n\treturn -EINPROGRESS;\n}",
        "output": "1",
        "idx": 8348
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void i8042_stop(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\n\tport->exists = false;\n\n\tsynchronize_irq(I8042_AUX_IRQ);\n\tsynchronize_irq(I8042_KBD_IRQ);\n\tport->serio = NULL;\n}",
        "output": "1",
        "idx": 1634
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *my_malloc(size_t size)\n{\n    malloc_called = 1;\n    return malloc(size);\n}",
        "output": "0",
        "idx": 6005
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int get_bitmap_file(struct mddev *mddev, void __user * arg)\n{\n\tmdu_bitmap_file_t *file = NULL; \n\tchar *ptr;\n\tint err;\n\n\tfile = kmalloc(sizeof(*file), GFP_NOIO);\n\tif (!file)\n\t\treturn -ENOMEM;\n\n\terr = 0;\n\tspin_lock(&mddev->lock);\n\tif (!mddev->bitmap_info.file)\n\t\tfile->pathname[0] = '\\0';\n\telse if ((ptr = file_path(mddev->bitmap_info.file,\n\t\t\t       file->pathname, sizeof(file->pathname))),\n\t\t IS_ERR(ptr))\n\t\terr = PTR_ERR(ptr);\n\telse\n\t\tmemmove(file->pathname, ptr,\n\t\t\tsizeof(file->pathname)-(ptr-file->pathname));\n\tspin_unlock(&mddev->lock);\n\n\tif (err == 0 &&\n\t    copy_to_user(arg, file, sizeof(*file)))\n\t\terr = -EFAULT;\n\n\tkfree(file);\n\treturn err;\n}",
        "output": "1",
        "idx": 2884
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "isis_print_id(const uint8_t *cp, int id_len)\n{\n    int i;\n    static char id[sizeof(\"xxxx.xxxx.xxxx.yy-zz\")];\n    char *pos = id;\n\n    for (i = 1; i <= SYSTEM_ID_LEN; i++) {\n        snprintf(pos, sizeof(id) - (pos - id), \"%02x\", *cp++);\n\tpos += strlen(pos);\n\tif (i == 2 || i == 4)\n\t    *pos++ = '.';\n\t}\n    if (id_len >= NODE_ID_LEN) {\n        snprintf(pos, sizeof(id) - (pos - id), \".%02x\", *cp++);\n\tpos += strlen(pos);\n    }\n    if (id_len == LSP_ID_LEN)\n        snprintf(pos, sizeof(id) - (pos - id), \"-%02x\", *cp);\n    return (id);\n}",
        "output": "1",
        "idx": 4826
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int nfs4_open_recover_helper(struct nfs4_opendata *opendata, mode_t openflags, struct nfs4_state **res)\n{\n\tstruct nfs4_state *newstate;\n\tint ret;\n\n\topendata->o_arg.open_flags = openflags;\n\tmemset(&opendata->o_res, 0, sizeof(opendata->o_res));\n\tmemset(&opendata->c_res, 0, sizeof(opendata->c_res));\n\tnfs4_init_opendata_res(opendata);\n\tret = _nfs4_proc_open(opendata);\n\tif (ret != 0)\n\t\treturn ret; \n\tnewstate = nfs4_opendata_to_nfs4_state(opendata);\n\tif (IS_ERR(newstate))\n\t\treturn PTR_ERR(newstate);\n\tnfs4_close_state(&opendata->path, newstate, openflags);\n\t*res = newstate;\n\treturn 0;\n}",
        "output": "1",
        "idx": 2116
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void faad_resetbits(bitfile *ld, int bits)\n{\n    uint32_t tmp;\n    int words = bits >> 5;\n    int remainder = bits & 0x1F;\n\n    ld->bytes_left = ld->buffer_size - words*4;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufa = tmp;\n\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words+1]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n\n    ld->bits_left = 32 - remainder;\n    ld->tail = &ld->start[words+2];\n\n    ld->error = 0;\n}",
        "output": "1",
        "idx": 7512
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int af9005_identify_state(struct usb_device *udev,\n\t\t\t\t struct dvb_usb_device_properties *props,\n\t\t\t\t struct dvb_usb_device_description **desc,\n\t\t\t\t int *cold)\n{\n\tint ret;\n\tu8 reply, *buf;\n\n\tbuf = kmalloc(FW_BULKOUT_SIZE + 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = af9005_boot_packet(udev, FW_CONFIG, &reply,\n\t\t\t\t buf, FW_BULKOUT_SIZE + 2);\n\tif (ret)\n\t\tgoto err;\n\tdeb_info(\"result of FW_CONFIG in identify state %d\\n\", reply);\n\tif (reply == 0x01)\n\t\t*cold = 1;\n\telse if (reply == 0x02)\n\t\t*cold = 0;\n\telse\n\t\treturn -EIO;\n\tdeb_info(\"Identify state cold = %d\\n\", *cold);\n\nerr:\n\tkfree(buf);\n\treturn ret;\n}",
        "output": "1",
        "idx": 3294
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *item )\n{\n\tcJSON_AddItemToObject( object, string, create_reference( item ) );\n}",
        "output": "1",
        "idx": 5892
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ntlm_read_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->Len > 0)\n\t{\n\t\tif ((fields->BufferOffset + fields->Len) > Stream_Length(s))\n\t\t\treturn -1;\n\n\t\tfields->Buffer = (PBYTE) malloc(fields->Len);\n\n\t\tif (!fields->Buffer)\n\t\t\treturn -1;\n\n\t\tStream_SetPosition(s, fields->BufferOffset);\n\t\tStream_Read(s, fields->Buffer, fields->Len);\n\t}\n\n\treturn 1;\n}",
        "output": "1",
        "idx": 4196
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\n\terr = security_sb_remount(sb, data);\n\tif (err)\n\t\treturn err;\n\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n\t\terr = do_remount_sb(sb, flags, data, 0);\n\tif (!err) {\n\t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;\n\t\tmnt->mnt.mnt_flags = mnt_flags;\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}",
        "output": "1",
        "idx": 2624
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void scsi_free_request(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    if (r->iov.iov_base) {\n        qemu_vfree(r->iov.iov_base);\n    }\n}",
        "output": "0",
        "idx": 5009
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void l2tp_eth_dev_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\n\tdev->netdev_ops\t\t= &l2tp_eth_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n}",
        "output": "1",
        "idx": 588
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main_configure(char *arg1, char *arg2) {\n    int cmdline_status;\n\n    cmdline_status=options_cmdline(arg1, arg2);\n    if(cmdline_status) \n        return cmdline_status;\n    options_apply();\n    str_canary_init(); \n    log_open(SINK_SYSLOG);\n    if(bind_ports())\n        return 1;\n\n#ifdef HAVE_CHROOT\n    if(change_root())\n        return 1;\n#endif \n\n    if(drop_privileges(1))\n        return 1;\n\n    if(log_open(SINK_OUTFILE))\n        return 1;\n#ifndef USE_FORK\n    num_clients=0; \n#endif\n    log_flush(LOG_MODE_CONFIGURED);\n    return 0;\n}",
        "output": "1",
        "idx": 8464
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ip_options_get_finish(struct net *net, struct ip_options **optp,\n\t\t\t\t struct ip_options *opt, int optlen)\n{\n\twhile (optlen & 3)\n\t\topt->__data[optlen++] = IPOPT_END;\n\topt->optlen = optlen;\n\tif (optlen && ip_options_compile(net, opt, NULL)) {\n\t\tkfree(opt);\n\t\treturn -EINVAL;\n\t}\n\tkfree(*optp);\n\t*optp = opt;\n\treturn 0;\n}",
        "output": "1",
        "idx": 350
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "next_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type,\n\t\t enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n\n  if (*state == CCS_RANGE)\n    return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;\n\n  if (*state == CCS_VALUE && *type != CCV_CLASS) {\n    if (*type == CCV_SB)\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n  }\n\n  *state = CCS_VALUE;\n  *type  = CCV_CLASS;\n  return 0;\n}",
        "output": "1",
        "idx": 6676
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char* get_private_subtags(const char* loc_name)\n{\n\tchar* \tresult =NULL;\n\tint \tsingletonPos = 0;\n\tint \tlen =0;\n\tconst char* \tmod_loc_name =NULL;\n\n\tif( loc_name && (len = strlen(loc_name)>0 ) ){\n\t\tmod_loc_name = loc_name ;\n\t\tlen   = strlen(mod_loc_name);\n\t\twhile( (singletonPos = getSingletonPos(mod_loc_name))!= -1){\n\n\t\t\tif( singletonPos!=-1){\n\t\t\t\tif( (*(mod_loc_name+singletonPos)=='x') || (*(mod_loc_name+singletonPos)=='X') ){\n\t\t\t\t\tif( singletonPos + 2 ==  len){\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tresult = estrndup(mod_loc_name + singletonPos+2  , (len -( singletonPos +2) ) );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif( singletonPos + 1 >=  len){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmod_loc_name = mod_loc_name + singletonPos +1;\n\t\t\t\t\t\tlen = strlen(mod_loc_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} \n\t}\n\n\treturn result;\n}",
        "output": "0",
        "idx": 5429
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "validate_event(struct pmu_hw_events *hw_events,\n\t       struct perf_event *event)\n{\n\tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n\tstruct pmu *leader_pmu = event->group_leader->pmu;\n\n\tif (is_software_event(event))\n\t\treturn 1;\n\n\tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n\t\treturn 1;\n\n\tif (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)\n\t\treturn 1;\n\n\treturn armpmu->get_event_idx(hw_events, event) >= 0;\n}",
        "output": "0",
        "idx": 3299
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jas_iccputuint(jas_stream_t *out, int n, jas_ulonglong val)\n{\n\tint i;\n\tint c;\n\tfor (i = n; i > 0; --i) {\n\t\tc = (val >> (8 * (i - 1))) & 0xff;\n\t\tif (jas_stream_putc(out, c) == EOF)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 7549
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "free_ice_connection_watch (GsmIceConnectionWatch *data)\n{\n        if (data->watch_id) {\n                g_source_remove (data->watch_id);\n                data->watch_id = 0;\n        }\n\n        if (data->protocol_timeout) {\n                g_source_remove (data->protocol_timeout);\n                data->protocol_timeout = 0;\n        }\n\n        g_free (data);\n}",
        "output": "0",
        "idx": 8731
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct task_struct * __cpuinit fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\tstruct pt_regs regs;\n\n\ttask = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n\t\t\t    &init_struct_pid, 0);\n\tif (!IS_ERR(task))\n\t\tinit_idle(task, cpu);\n\n\treturn task;\n}",
        "output": "1",
        "idx": 218
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void hugetlb_unreserve_pages(struct inode *inode, long offset, long freed)\n{\n\tstruct hstate *h = hstate_inode(inode);\n\tlong chg = region_truncate(&inode->i_mapping->private_list, offset);\n\tstruct hugepage_subpool *spool = subpool_inode(inode);\n\n\tspin_lock(&inode->i_lock);\n\tinode->i_blocks -= (blocks_per_huge_page(h) * freed);\n\tspin_unlock(&inode->i_lock);\n\n\thugepage_subpool_put_pages(spool, (chg - freed));\n\thugetlb_acct_memory(h, -(chg - freed));\n}",
        "output": "0",
        "idx": 895
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tfile_sb_list_del(file);\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
        "output": "1",
        "idx": 2378
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l_strnstart(netdissect_options *ndo, const char *tstr1, u_int tl1,\n    const char *str2, u_int l2)\n{\n\tif (!ND_TTEST2(*str2, tl1)) {\n\t\treturn 0;\n\t}\n\tif (tl1 > l2)\n\t\treturn 0;\n\n\treturn (strncmp(tstr1, str2, tl1) == 0 ? 1 : 0);\n}",
        "output": "0",
        "idx": 6687
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void xenvif_disconnect(struct xenvif *vif)\n{\n\tstruct net_device *dev = vif->dev;\n\tif (netif_carrier_ok(dev)) {\n\t\trtnl_lock();\n\t\tnetif_carrier_off(dev); \n\t\tif (netif_running(dev))\n\t\t\txenvif_down(vif);\n\t\trtnl_unlock();\n\t\txenvif_put(vif);\n\t}\n\n\tatomic_dec(&vif->refcnt);\n\twait_event(vif->waiting_to_free, atomic_read(&vif->refcnt) == 0);\n\n\tdel_timer_sync(&vif->credit_timeout);\n\n\tif (vif->irq)\n\t\tunbind_from_irqhandler(vif->irq, vif);\n\n\tunregister_netdev(vif->dev);\n\n\txen_netbk_unmap_frontend_rings(vif);\n\n\tfree_netdev(vif->dev);\n}",
        "output": "1",
        "idx": 820
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ntlm_write_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n{\n\tStream_Write(s, header->Signature, sizeof(NTLM_SIGNATURE));\n\tStream_Write_UINT32(s, header->MessageType);\n}",
        "output": "0",
        "idx": 5809
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n\t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n\t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n{\n    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n\t\t\t\t  iov_count);\n}",
        "output": "1",
        "idx": 76
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void perf_swevent_event(struct perf_event *event, u64 nr,\n\t\t\t       struct perf_sample_data *data,\n\t\t\t       struct pt_regs *regs)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tlocal64_add(nr, &event->count);\n\n\tif (!regs)\n\t\treturn;\n\n\tif (!is_sampling_event(event))\n\t\treturn;\n\n\tif (nr == 1 && hwc->sample_period == 1 && !event->attr.freq)\n\t\treturn perf_swevent_overflow(event, 1, data, regs);\n\n\tif (local64_add_negative(nr, &hwc->period_left))\n\t\treturn;\n\n\tperf_swevent_overflow(event, 0, data, regs);\n}",
        "output": "0",
        "idx": 677
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)\n{\n\tif (cfs_rq->load.weight)\n\t\treturn false;\n\n\tif (cfs_rq->avg.load_sum)\n\t\treturn false;\n\n\tif (cfs_rq->avg.util_sum)\n\t\treturn false;\n\n\tif (cfs_rq->avg.runnable_load_sum)\n\t\treturn false;\n\n\treturn true;\n}",
        "output": "1",
        "idx": 3052
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int install_permanent_handler(int num_cpus, uintptr_t smbase,\n\t\t\t\t\tsize_t smsize, size_t save_state_size)\n{\n\tstruct smm_loader_params smm_params = {\n\t\t.per_cpu_stack_size = CONFIG_SMM_MODULE_STACK_SIZE,\n\t\t.num_concurrent_stacks = num_cpus,\n\t\t.per_cpu_save_state_size = save_state_size,\n\t\t.num_concurrent_save_states = num_cpus,\n\t};\n\n\tif (mp_state.ops.adjust_smm_params != NULL)\n\t\tmp_state.ops.adjust_smm_params(&smm_params, 1);\n\n\tprintk(BIOS_DEBUG, \"Installing SMM handler to 0x%08lx\\n\", smbase);\n\n\tif (smm_load_module((void *)smbase, smsize, &smm_params))\n\t\treturn -1;\n\n\tadjust_smm_apic_id_map(&smm_params);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 8934
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "snmp_api_set_string(snmp_varbind_t *varbind, uint32_t *oid, char *string)\n{\n\n  snmp_api_replace_oid(varbind, oid);\n  varbind->value_type = BER_DATA_TYPE_OCTET_STRING;\n  varbind->value.string.string = string;\n  varbind->value.string.length = strlen(string);\n}",
        "output": "1",
        "idx": 7940
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cdf_read_sector(const cdf_info_t *info, void *buf, size_t offs, size_t len,\n    const cdf_header_t *h, cdf_secid_t id)\n{\n\tassert((size_t)CDF_SEC_SIZE(h) == len);\n\treturn cdf_read(info, (off_t)CDF_SEC_POS(h, id),\n\t    ((char *)buf) + offs, len);\n}",
        "output": "1",
        "idx": 3616
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "hb_set_intersect (hb_set_t       *set,\n\t\t  const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n\n  set->intersect (*other);\n}",
        "output": "1",
        "idx": 5548
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *print_string( cJSON *item )\n{\n\treturn print_string_ptr( item->valuestring );\n}",
        "output": "1",
        "idx": 5938
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int uas_switch_interface(struct usb_device *udev,\n\t\t\t\tstruct usb_interface *intf)\n{\n\tstruct usb_host_interface *alt;\n\n\talt = uas_find_uas_alt_setting(intf);\n\tif (!alt)\n\t\treturn -ENODEV;\n\n\treturn usb_set_interface(udev, alt->desc.bInterfaceNumber,\n\t\t\talt->desc.bAlternateSetting);\n}",
        "output": "0",
        "idx": 2415
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tchar str[1024];\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\n\ti=0;\n\tstr[0]=0;\n\twhile (1) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\n\tp->content_script_types = gf_strdup(str);\n\treturn GF_OK;\n}",
        "output": "1",
        "idx": 6916
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\n\tif (tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&(tsk->thread));\n\t}\n}",
        "output": "1",
        "idx": 1664
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n{\n        uint8* bufp = buf;\n        int32  bytes_read = 0;\n        uint16 strip, nstrips   = TIFFNumberOfStrips(in);\n        uint32 stripsize = TIFFStripSize(in);\n        uint32 rows = 0;\n        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n\n        for (strip = 0; strip < nstrips; strip++) {\n                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);\n                rows = bytes_read / scanline_size;\n                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))\n                        TIFFError(\"\", \"Strip %d: read %lu bytes, strip size %lu\",\n                                  (int)strip + 1, (unsigned long) bytes_read,\n                                  (unsigned long)stripsize);\n\n                if (bytes_read < 0 && !ignore) {\n                        TIFFError(\"\", \"Error reading strip %lu after %lu rows\",\n                                  (unsigned long) strip, (unsigned long)rows);\n                        return 0;\n                }\n                bufp += bytes_read;\n        }\n\n        return 1;\n} ",
        "output": "1",
        "idx": 4250
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION( locale_get_region )\n{\n\tget_icu_value_src_php( LOC_REGION_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}",
        "output": "0",
        "idx": 5421
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void unix_notinflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tspin_lock(&unix_gc_lock);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tBUG_ON(list_empty(&u->link));\n\n\t\tif (atomic_long_dec_and_test(&u->inflight))\n\t\t\tlist_del_init(&u->link);\n\t\tunix_tot_inflight--;\n\t}\n\tfp->f_cred->user->unix_inflight--;\n\tspin_unlock(&unix_gc_lock);\n}",
        "output": "0",
        "idx": 1503
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __pyx_tp_dealloc_17clickhouse_driver_14bufferedwriter_BufferedWriter(PyObject *o) {\n  #if CYTHON_USE_TP_FINALIZE\n  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {\n    if (PyObject_CallFinalizerFromDealloc(o)) return;\n  }\n  #endif\n  {\n    PyObject *etype, *eval, *etb;\n    PyErr_Fetch(&etype, &eval, &etb);\n    ++Py_REFCNT(o);\n    __pyx_pw_17clickhouse_driver_14bufferedwriter_14BufferedWriter_3__dealloc__(o);\n    --Py_REFCNT(o);\n    PyErr_Restore(etype, eval, etb);\n  }\n  (*Py_TYPE(o)->tp_free)(o);\n}",
        "output": "1",
        "idx": 8318
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)\n{\n\treturn &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;\n}",
        "output": "1",
        "idx": 2838
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pam_converse (int num_msg, PAM_CONVERSE_ARG2_TYPE **msg,\n  struct pam_response **resp, void *appdata_ptr)\n{\nint sep = 0;\nstruct pam_response *reply;\n\n\nif (  pam_arg_ended\n   || !(reply = malloc(sizeof(struct pam_response) * num_msg)))\n  return PAM_CONV_ERR;\n\nfor (int i = 0; i < num_msg; i++)\n  {\n  uschar *arg;\n  switch (msg[i]->msg_style)\n    {\n    case PAM_PROMPT_ECHO_ON:\n    case PAM_PROMPT_ECHO_OFF:\n      if (!(arg = string_nextinlist(&pam_args, &sep, NULL, 0)))\n\t{\n\targ = US\"\";\n\tpam_arg_ended = TRUE;\n\t}\n      reply[i].resp = strdup(CCS arg); \n      reply[i].resp_retcode = PAM_SUCCESS;\n      break;\n\n    case PAM_TEXT_INFO:    \n    case PAM_ERROR_MSG:\n      reply[i].resp_retcode = PAM_SUCCESS;\n      reply[i].resp = NULL;\n      break;\n\n    default:  \n      free(reply);\n      pam_conv_had_error = TRUE;\n      return PAM_CONV_ERR;\n    }\n  }\n\n*resp = reply;\nreturn PAM_SUCCESS;\n}",
        "output": "0",
        "idx": 8575
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int bmp_getint32(jas_stream_t *in, int_fast32_t *val)\n{\n\tint n;\n\tuint_fast32_t v;\n\tint c;\n\tfor (n = 4, v = 0;;) {\n\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t\tv |= (JAS_CAST(uint_fast32_t, c) << 24);\n\t\tif (--n <= 0) {\n\t\t\tbreak;\n\t\t}\n\t\tv >>= 8;\n\t}\n\tif (val) {\n\t\t*val = v;\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 7477
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "crm_parse_remote_buffer(char **msg_buf)\n{\n    char *buf = NULL;\n    char *start = NULL;\n    char *end = NULL;\n    xmlNode *xml = NULL;\n\n    if (*msg_buf == NULL) {\n        return NULL;\n    }\n\n    buf = *msg_buf;\n    *msg_buf = NULL;\n\n    start = buf;\n    end = strstr(start, REMOTE_MSG_TERMINATOR);\n\n    while (!xml && end) {\n\n        end[0] = '\\0';\n        end += strlen(REMOTE_MSG_TERMINATOR);\n\n        xml = string2xml(start);\n        if (xml == NULL) {\n            crm_err(\"Couldn't parse: '%.120s'\", start);\n        }\n        start = end;\n        end = strstr(start, REMOTE_MSG_TERMINATOR);\n    }\n\n    if (xml && start) {\n        *msg_buf = strdup(start);\n        free(buf);\n    } else if (!xml) {\n        *msg_buf = buf;\n    }\n\n    return xml;\n}",
        "output": "0",
        "idx": 5257
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "header_put_le_short (SF_PRIVATE *psf, int x)\n{\tpsf->header.ptr [psf->header.indx++] = x ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n} ",
        "output": "0",
        "idx": 6891
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline __must_check bool pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\treturn buf->ops->get(pipe, buf);\n}",
        "output": "0",
        "idx": 4363
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int CLASS parse_jpeg(int offset)\n{\n  int len, save, hlen, mark;\n  fseek(ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n    return 0;\n\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda)\n  {\n    order = 0x4d4d;\n    len = get2() - 2;\n    save = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9)\n    {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width = get2();\n    }\n    order = get2();\n    hlen = get4();\n    if (get4() == 0x48454150\n#ifdef LIBRAW_LIBRARY_BUILD\n\t&& (save+hlen) >= 0 && (save+hlen)<=ifp->size()\n#endif\n\t) \n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff(save + hlen, len - hlen, 0);\n    }\n    if (parse_tiff(save + 6))\n      apply_tiff();\n    fseek(ifp, save + len, SEEK_SET);\n  }\n  return 1;\n}",
        "output": "0",
        "idx": 5275
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_chroot(const char *path)\n{\n\tif (chroot(path) == 0) {\n\t\tfprintf(stderr, \"leak at chroot of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at chroot of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}",
        "output": "0",
        "idx": 7285
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)\n{\n\tPurpleXfer *xfer = data;\n\tstruct im_connection *ic = purple_ic_by_pa(xfer->account);\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\tPurpleBuddy *buddy;\n\tconst char *who;\n\n\tbuddy = purple_find_buddy(xfer->account, xfer->who);\n\twho = buddy ? purple_buddy_get_name(buddy) : xfer->who;\n\n\tpx->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);\n\n\tif (!px->ft) {\n\t\treturn FALSE;\n\t}\n\tpx->ft->data = px;\n\n\tpx->ft->accept = prpl_xfer_accept;\n\tpx->ft->canceled = prpl_xfer_canceled;\n\tpx->ft->free = prpl_xfer_free;\n\tpx->ft->write_request = prpl_xfer_write_request;\n\n\treturn FALSE;\n}",
        "output": "0",
        "idx": 7851
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void common_hrtimer_rearm(struct k_itimer *timr)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\n\tif (!timr->it_interval)\n\t\treturn;\n\n\ttimr->it_overrun += (unsigned int) hrtimer_forward(timer,\n\t\t\t\t\t\ttimer->base->get_time(),\n\t\t\t\t\t\ttimr->it_interval);\n\thrtimer_restart(timer);\n}",
        "output": "1",
        "idx": 2986
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_entry *l2e)\n{\n\tint\terror = 0;\n\tstruct cxio_rdev *rdev;\n\n\trdev = (struct cxio_rdev *)tdev->ulp;\n\tif (cxio_fatal_error(rdev)) {\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\terror = l2t_send(tdev, skb, l2e);\n\tif (error < 0)\n\t\tkfree_skb(skb);\n\treturn error;\n}",
        "output": "1",
        "idx": 1006
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static VTermState *vterm_state_new(VTerm *vt)\n{\n  VTermState *state = vterm_allocator_malloc(vt, sizeof(VTermState));\n\n  if (state == NULL)\n    return NULL;\n  state->vt = vt;\n\n  state->rows = vt->rows;\n  state->cols = vt->cols;\n\n  state->mouse_col     = 0;\n  state->mouse_row     = 0;\n  state->mouse_buttons = 0;\n\n  state->mouse_protocol = MOUSE_X10;\n\n  state->callbacks = NULL;\n  state->cbdata    = NULL;\n\n  vterm_state_newpen(state);\n\n  state->bold_is_highbright = 0;\n\n  return state;\n}",
        "output": "0",
        "idx": 8139
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb, int *profile, int *level)\n{\n\n    *profile = get_bits(gb, 4);\n    *level   = get_bits(gb, 4);\n\n    if (*profile == 0 && *level == 8) {\n        *level = 0;\n    }\n\n    return 0;\n}",
        "output": "0",
        "idx": 4757
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t   unsigned long size)\n{\n\tgfn_t end_gfn;\n\tpfn_t pfn;\n\n\tpfn     = gfn_to_pfn_memslot(slot, gfn);\n\tend_gfn = gfn + (size >> PAGE_SHIFT);\n\tgfn    += 1;\n\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn pfn;\n\n\twhile (gfn < end_gfn)\n\t\tgfn_to_pfn_memslot(slot, gfn++);\n\n\treturn pfn;\n}",
        "output": "1",
        "idx": 2706
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void lpc546xxEthWritePhyReg(uint8_t opcode, uint8_t phyAddr,\n   uint8_t regAddr, uint16_t data)\n{\n   uint32_t temp;\n\n   if(opcode == SMI_OPCODE_WRITE)\n   {\n      temp = ENET->MAC_MDIO_ADDR & ENET_MAC_MDIO_ADDR_CR_MASK;\n      temp |= ENET_MAC_MDIO_ADDR_MOC(1) | ENET_MAC_MDIO_ADDR_MB_MASK;\n      temp |= ENET_MAC_MDIO_ADDR_PA(phyAddr);\n      temp |= ENET_MAC_MDIO_ADDR_RDA(regAddr);\n\n      ENET->MAC_MDIO_DATA = data & ENET_MAC_MDIO_DATA_MD_MASK;\n\n      ENET->MAC_MDIO_ADDR = temp;\n      while((ENET->MAC_MDIO_ADDR & ENET_MAC_MDIO_ADDR_MB_MASK) != 0)\n      {\n      }\n   }\n   else\n   {\n   }\n}",
        "output": "1",
        "idx": 8604
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n\n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    if(reasonLen > 1<<20) {\n      rfbClientLog(\"VNC connection failed, but sent reason length of %u exceeds limit of 1MB\",(unsigned int)reasonLen);\n      return;\n    }\n    reason = malloc(reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n    free(reason);\n}",
        "output": "0",
        "idx": 8911
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\tstruct rt6_info *rt;\n\n\trt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);\n\tif (rt->dst.error == -EAGAIN) {\n\t\tip6_rt_put_flags(rt, flags);\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tif (!(flags & RT6_LOOKUP_F_DST_NOREF))\n\t\t\tdst_hold(&rt->dst);\n\t}\n\n\treturn &rt->dst;\n}",
        "output": "0",
        "idx": 4473
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jpc_ppm_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_ppm_t *ppm = &ms->parms.ppm;\n\n\tcstate = 0;\n\n\tppm->data = 0;\n\n\tif (ms->len < 1) {\n\t\tgoto error;\n\t}\n\tif (jpc_getuint8(in, &ppm->ind)) {\n\t\tgoto error;\n\t}\n\n\tppm->len = ms->len - 1;\n\tif (ppm->len > 0) {\n\t\tif (!(ppm->data = jas_malloc(ppm->len))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (JAS_CAST(uint, jas_stream_read(in, ppm->data, ppm->len)) != ppm->len) {\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tppm->data = 0;\n\t}\n\treturn 0;\n\nerror:\n\tjpc_ppm_destroyparms(ms);\n\treturn -1;\n}",
        "output": "1",
        "idx": 5396
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowstride)\n{\n\tnsc_encode_argb_to_aycocg(context, bmpdata, rowstride);\n\n\tif (context->ChromaSubsamplingLevel)\n\t{\n\t\tnsc_encode_subsampling(context);\n\t}\n}",
        "output": "1",
        "idx": 4224
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tktime_t now, remaining, iv;\n\tstruct timespec64 ts64;\n\tbool sig_none;\n\n\tsig_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE;\n\tiv = timr->it_interval;\n\n\tif (iv) {\n\t\tcur_setting->it_interval = ktime_to_timespec64(iv);\n\t} else if (!timr->it_active) {\n\t\tif (!sig_none)\n\t\t\treturn;\n\t}\n\n\tkc->clock_get(timr->it_clock, &ts64);\n\tnow = timespec64_to_ktime(ts64);\n\n\tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))\n\t\ttimr->it_overrun += kc->timer_forward(timr, now);\n\n\tremaining = kc->timer_remaining(timr, now);\n\tif (remaining <= 0) {\n\t\tif (!sig_none)\n\t\t\tcur_setting->it_value.tv_nsec = 1;\n\t} else {\n\t\tcur_setting->it_value = ktime_to_timespec64(remaining);\n\t}\n}",
        "output": "1",
        "idx": 1798
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  incXCcalls(L);\n  if (getCcalls(L) <= CSTACKERR)  \n    luaE_freeCI(L);\n  luaD_call(L, func, nResults);\n  decXCcalls(L);\n}",
        "output": "1",
        "idx": 8106
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void consume_one_event(unsigned cpu,\n\t\t\t      struct evtchn_fifo_control_block *control_block,\n\t\t\t      unsigned priority, unsigned long *ready,\n\t\t\t      bool drop)\n{\n\tstruct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);\n\tuint32_t head;\n\tevtchn_port_t port;\n\tevent_word_t *word;\n\n\thead = q->head[priority];\n\n\tif (head == 0) {\n\t\tvirt_rmb(); \n\t\thead = control_block->head[priority];\n\t}\n\n\tport = head;\n\tword = event_word_from_port(port);\n\thead = clear_linked(word);\n\n\tif (head == 0)\n\t\tclear_bit(priority, ready);\n\n\tif (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port)) {\n\t\tif (unlikely(drop))\n\t\t\tpr_warn(\"Dropping pending event for port %u\\n\", port);\n\t\telse\n\t\t\thandle_irq_for_port(port);\n\t}\n\n\tq->head[priority] = head;\n}",
        "output": "1",
        "idx": 1904
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "decode_sequence(const uint8_t *asn1, size_t len, const struct seq_info *seq,\n                void *val)\n{\n    krb5_error_code ret;\n    const uint8_t *contents;\n    size_t i, j, clen;\n    taginfo t;\n\n    assert(seq->n_fields > 0);\n    for (i = 0; i < seq->n_fields; i++) {\n        if (len == 0)\n            break;\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        for (; i < seq->n_fields; i++) {\n            if (check_atype_tag(seq->fields[i], &t))\n                break;\n            ret = omit_atype(seq->fields[i], val);\n            if (ret)\n                goto error;\n        }\n        if (i == seq->n_fields)\n            break;\n        ret = decode_atype(&t, contents, clen, seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    for (; i < seq->n_fields; i++) {\n        ret = omit_atype(seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    return 0;\n\nerror:\n    for (j = 0; j < i; j++)\n        free_atype(seq->fields[j], val);\n    for (j = 0; j < i; j++)\n        free_atype_ptr(seq->fields[j], val);\n    return ret;\n}",
        "output": "1",
        "idx": 202
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ifb_setup(struct net_device *dev)\n{\n\tdev->destructor = free_netdev;\n\tdev->netdev_ops = &ifb_netdev_ops;\n\n\tether_setup(dev);\n\tdev->tx_queue_len = TX_Q_LIMIT;\n\n\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n\n\tdev->flags |= IFF_NOARP;\n\tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n\trandom_ether_addr(dev->dev_addr);\n}",
        "output": "0",
        "idx": 745
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline Quantum GetPixelChannel(const Image *magick_restrict image,\n  const PixelChannel channel,const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[image->channel_map[channel].offset].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[channel].offset]);\n}",
        "output": "0",
        "idx": 7195
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "pci_emul_add_capability(struct pci_vdev *dev, u_char *capdata, int caplen)\n{\n\tint i, capoff, reallen;\n\tuint16_t sts;\n\n\tassert(caplen > 0);\n\n\treallen = roundup2(caplen, 4);\t\t\n\n\tsts = pci_get_cfgdata16(dev, PCIR_STATUS);\n\tif ((sts & PCIM_STATUS_CAPPRESENT) == 0)\n\t\tcapoff = CAP_START_OFFSET;\n\telse\n\t\tcapoff = dev->capend + 1;\n\n\tif (capoff + reallen > PCI_REGMAX + 1)\n\t\treturn -1;\n\n\tif ((sts & PCIM_STATUS_CAPPRESENT) == 0) {\n\t\tpci_set_cfgdata8(dev, PCIR_CAP_PTR, capoff);\n\t\tpci_set_cfgdata16(dev, PCIR_STATUS, sts|PCIM_STATUS_CAPPRESENT);\n\t} else\n\t\tpci_set_cfgdata8(dev, dev->prevcap + 1, capoff);\n\n\tfor (i = 0; i < caplen; i++)\n\t\tpci_set_cfgdata8(dev, capoff + i, capdata[i]);\n\n\tpci_set_cfgdata8(dev, capoff + 1, 0);\n\n\tdev->prevcap = capoff;\n\tdev->capend = capoff + reallen - 1;\n\treturn 0;\n}",
        "output": "1",
        "idx": 7610
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kgdb_hw_overflow_handler(struct perf_event *event,\n\t\tstruct perf_sample_data *data, struct pt_regs *regs)\n{\n\tstruct task_struct *tsk = current;\n\tint i;\n\n\tfor (i = 0; i < 4; i++)\n\t\tif (breakinfo[i].enabled)\n\t\t\ttsk->thread.debugreg6 |= (DR_TRAP0 << i);\n}",
        "output": "0",
        "idx": 665
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvaser_usb_leaf_simple_cmd_async(struct kvaser_usb_net_priv *priv,\n\t\t\t\t\t    u8 cmd_id)\n{\n\tstruct kvaser_cmd *cmd;\n\tint err;\n\n\tcmd = kmalloc(sizeof(*cmd), GFP_ATOMIC);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_simple);\n\tcmd->id = cmd_id;\n\tcmd->u.simple.channel = priv->channel;\n\n\terr = kvaser_usb_send_cmd_async(priv, cmd, cmd->len);\n\tif (err)\n\t\tkfree(cmd);\n\n\treturn err;\n}",
        "output": "1",
        "idx": 3308
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static BYTE get_bmf_bpp(UINT32 bmf, BOOL* pValid)\n{\n\tif (pValid)\n\t\t*pValid = TRUE;\n\tswitch (bmf)\n\t{\n\t\tcase 1:\n\t\t\treturn 1;\n\t\tcase 3:\n\t\t\treturn 8;\n\t\tcase 4:\n\t\t\treturn 16;\n\t\tcase 5:\n\t\t\treturn 24;\n\t\tcase 6:\n\t\t\treturn 32;\n\t\tdefault:\n\t\t\tWLog_WARN(TAG, \"Invalid bmf %\" PRIu32, bmf);\n\t\t\tif (pValid)\n\t\t\t\t*pValid = FALSE;\n\t\t\treturn 0;\n\t}\n}",
        "output": "0",
        "idx": 5773
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void adjust_branches(struct bpf_prog *prog, int pos, int delta)\n{\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint insn_cnt = prog->len;\n\tint i;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) != BPF_JMP ||\n\t\t    BPF_OP(insn->code) == BPF_CALL ||\n\t\t    BPF_OP(insn->code) == BPF_EXIT)\n\t\t\tcontinue;\n\n\t\tif (i < pos && i + insn->off + 1 > pos)\n\t\t\tinsn->off += delta;\n\t\telse if (i > pos && i + insn->off + 1 < pos)\n\t\t\tinsn->off -= delta;\n\t}\n}",
        "output": "1",
        "idx": 1070
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ext4_xattr_cache_insert(struct mb_cache *ext4_mb_cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext4_mb_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}",
        "output": "1",
        "idx": 1090
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "swabHorAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\tuint16* wp = (uint16*) cp0;\n\ttmsize_t wc = cc / 2;\n\n        TIFFSwabArrayOfShort(wp, wc);\n        horAcc16(tif, cp0, cc);\n}",
        "output": "1",
        "idx": 4266
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool cgm_bind_dir(const char *root, const char *dirname)\n{\n\tnih_local char *cgpath = NULL;\n\n\tcgpath = NIH_MUST( nih_strdup(NULL, root) );\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/sys/fs/cgroup\") );\n\n\tif (!dir_exists(cgpath)) {\n\t\tERROR(\"%s does not exist\", cgpath);\n\t\treturn false;\n\t}\n\n\tif (mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\")) {\n\t\tSYSERROR(\"Failed to mount tmpfs at %s\", cgpath);\n\t\treturn false;\n\t}\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/cgmanager\") );\n\n\tif (mkdir(cgpath, 0755) < 0) {\n\t\tSYSERROR(\"Failed to create %s\", cgpath);\n\t\treturn false;\n\t}\n\n\tif (mount(dirname, cgpath, \"none\", MS_BIND, 0)) {\n\t\tSYSERROR(\"Failed to bind mount %s to %s\", dirname, cgpath);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
        "output": "1",
        "idx": 4352
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\n\tstrncpy(extra_response->key, key, strlen(key) + 1);\n\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}",
        "output": "1",
        "idx": 2288
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "build_config(char *prefix, struct manager_ctx *manager, struct server *server)\n{\n    char *path    = NULL;\n    int path_size = strlen(prefix) + strlen(server->port) + 20;\n\n    path = ss_malloc(path_size);\n    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n    FILE *f = fopen(path, \"w+\");\n    if (f == NULL) {\n        if (verbose) {\n            LOGE(\"unable to open config file\");\n        }\n        ss_free(path);\n        return;\n    }\n    fprintf(f, \"{\\n\");\n    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n    if (server->method)\n        fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n    else if (manager->method)\n        fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", manager->method);\n    if (server->fast_open[0])\n        fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n    if (server->mode)\n        fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n    if (server->plugin)\n        fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n    if (server->plugin_opts)\n        fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n    fprintf(f, \"\\n}\\n\");\n    fclose(f);\n    ss_free(path);\n}",
        "output": "0",
        "idx": 8839
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat, u_int length)\n{\n\tif (length < 2) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tND_PRINT((ndo, \"%u.%u\", (EXTRACT_16BITS(dat) >> 8),\n\t    (EXTRACT_16BITS(dat) & 0xff)));\n}",
        "output": "0",
        "idx": 6673
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct cifs_ses *ses = sess_data->ses;\n\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (ses->server->sign && ses->server->ops->generate_signingkey) {\n\t\trc = ses->server->ops->generate_signingkey(ses);\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI,\n\t\t\t\t\"SMB3 session key generation failed\\n\");\n\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\tgoto keygen_exit;\n\t\t}\n\t}\n\tif (!ses->server->session_estab) {\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tcifs_dbg(FYI, \"SMB2/3 session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\n\nkeygen_exit:\n\tif (!ses->server->sign) {\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t}\n\treturn rc;\n}",
        "output": "1",
        "idx": 1448
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int store_icy(URLContext *h, int size)\n{\n    HTTPContext *s = h->priv_data;\n    uint64_t remaining;\n\n    if (s->icy_metaint < s->icy_data_read)\n        return AVERROR_INVALIDDATA;\n    remaining = s->icy_metaint - s->icy_data_read;\n\n    if (!remaining) {\n        uint8_t ch;\n        int len = http_read_stream_all(h, &ch, 1);\n        if (len < 0)\n            return len;\n        if (ch > 0) {\n            char data[255 * 16 + 1];\n            int ret;\n            len = ch * 16;\n            ret = http_read_stream_all(h, data, len);\n            if (ret < 0)\n                return ret;\n            data[len + 1] = 0;\n            if ((ret = av_opt_set(s, \"icy_metadata_packet\", data, 0)) < 0)\n                return ret;\n            update_metadata(s, data);\n        }\n        s->icy_data_read = 0;\n        remaining        = s->icy_metaint;\n    }\n\n    return FFMIN(size, remaining);\n}",
        "output": "0",
        "idx": 4841
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void xen_evtchn_handle_events(unsigned cpu)\n{\n\treturn evtchn_ops->handle_events(cpu);\n}",
        "output": "1",
        "idx": 1906
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "validate_event(struct pmu_hw_events *hw_events,\n\t       struct perf_event *event)\n{\n\tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n\tstruct hw_perf_event fake_event = event->hw;\n\tstruct pmu *leader_pmu = event->group_leader->pmu;\n\n\tif (is_software_event(event))\n\t\treturn 1;\n\n\tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n\t\treturn 1;\n\n\tif (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)\n\t\treturn 1;\n\n\treturn armpmu->get_event_idx(hw_events, &fake_event) >= 0;\n}",
        "output": "1",
        "idx": 2806
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cJSON_DeleteItemFromObject( cJSON *object, const char *string )\n{\n\tcJSON_Delete( cJSON_DetachItemFromObject( object, string ) );\n}",
        "output": "1",
        "idx": 5932
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "processBatchMultiRuleset(batch_t *pBatch)\n{\n\truleset_t *currRuleset;\n\tbatch_t snglRuleBatch;\n\tint i;\n\tint iStart;\t\n\tint iNew;\t\n\tDEFiRet;\n\n\tCHKiRet(batchInit(&snglRuleBatch, pBatch->nElem));\n\tsnglRuleBatch.pbShutdownImmediate = pBatch->pbShutdownImmediate;\n\n\twhile(1) { \n\t\tfor(iStart = 0 ; iStart < pBatch->nElem && pBatch->pElem[iStart].state == BATCH_STATE_DISC ; ++iStart)\n\t\t\t;\n\n\t\tif(iStart == pBatch->nElem)\n\t\t\tFINALIZE; \n\n\t\tcurrRuleset = batchElemGetRuleset(pBatch, iStart);\n\t\tiNew = 0;\n\t\tfor(i = iStart ; i < pBatch->nElem ; ++i) {\n\t\t\tif(batchElemGetRuleset(pBatch, i) == currRuleset) {\n\t\t\t\tbatchCopyElem(&(snglRuleBatch.pElem[iNew++]), &(pBatch->pElem[i]));\n\t\t\t\tpBatch->pElem[i].state = BATCH_STATE_DISC;\n\t\t\t}\n\t\t}\n\t\tsnglRuleBatch.nElem = iNew; \n\t\tbatchSetSingleRuleset(&snglRuleBatch, 1);\n\t\tprocessBatch(&snglRuleBatch);\n\t}\n\tbatchFree(&snglRuleBatch);\n\nfinalize_it:\n\tRETiRet;\n}",
        "output": "1",
        "idx": 3386
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API int r_socket_read(RSocket *s, unsigned char *buf, int len) {\n\tif (!s) {\n\t\treturn -1;\n\t}\n#if HAVE_LIB_SSL\n\tif (s->is_ssl) {\n\t\tif (s->bio) {\n\t\t\treturn BIO_read (s->bio, buf, len);\n\t\t}\n\t\treturn SSL_read (s->sfd, buf, len);\n\t}\n#endif\n#if __WINDOWS__\nrep:\n\t{\n\tint ret = recv (s->fd, (void *)buf, len, 0);\n\tif (ret == -1) {\n\t\tgoto rep;\n\t}\n\treturn ret;\n\t}\n#else\n\tint r = recv (s->fd, buf, len, 0);\n\tD { eprintf (\"READ \"); int i; for (i = 0; i<len; i++) { eprintf (\"%02x \", buf[i]); } eprintf (\"\\n\"); }\n\treturn r;\n#endif\n}",
        "output": "1",
        "idx": 6418
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void get_sem_elements(struct sem_data *p)\n{\n\tsize_t i;\n\n\tif (!p || !p->sem_nsems || p->sem_perm.id < 0)\n\t\treturn;\n\n\tp->elements = xcalloc(p->sem_nsems, sizeof(struct sem_elem));\n\n\tfor (i = 0; i < p->sem_nsems; i++) {\n\t\tstruct sem_elem *e = &p->elements[i];\n\t\tunion semun arg = { .val = 0 };\n\n\t\te->semval = semctl(p->sem_perm.id, i, GETVAL, arg);\n\t\tif (e->semval < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETVAL)\");\n\n\t\te->ncount = semctl(p->sem_perm.id, i, GETNCNT, arg);\n\t\tif (e->ncount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETNCNT)\");\n\n\t\te->zcount = semctl(p->sem_perm.id, i, GETZCNT, arg);\n\t\tif (e->zcount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETZCNT)\");\n\n\t\te->pid = semctl(p->sem_perm.id, i, GETPID, arg);\n\t\tif (e->pid < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETPID)\");\n\t}\n}",
        "output": "1",
        "idx": 4658
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_lnums_nested(int do_curwin)\n{\n    check_lnums_both(do_curwin, TRUE);\n}",
        "output": "0",
        "idx": 8103
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int masq_inet_event(struct notifier_block *this,\n\t\t\t   unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct net_device *dev = ((struct in_ifaddr *)ptr)->ifa_dev->dev;\n\tstruct netdev_notifier_info info;\n\n\tnetdev_notifier_info_init(&info, dev);\n\treturn masq_device_event(this, event, &info);\n}",
        "output": "1",
        "idx": 1156
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int linear_ioctl(struct dm_target *ti, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct linear_c *lc = (struct linear_c *) ti->private;\n\tstruct dm_dev *dev = lc->dev;\n\tint r = 0;\n\n\tif (lc->start ||\n\t    ti->len != i_size_read(dev->bdev->bd_inode) >> SECTOR_SHIFT)\n\t\tr = scsi_verify_blk_ioctl(NULL, cmd);\n\n\treturn r ? : __blkdev_driver_ioctl(dev->bdev, dev->mode, cmd, arg);\n}",
        "output": "0",
        "idx": 867
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void get_pid_creds(pid_t pid, uid_t *uid, gid_t *gid)\n{\n\tchar line[400];\n\tuid_t u;\n\tgid_t g;\n\tFILE *f;\n\n\t*uid = -1;\n\t*gid = -1;\n\tsprintf(line, \"/proc/%d/status\", pid);\n\tif ((f = fopen(line, \"r\")) == NULL) {\n\t\tfprintf(stderr, \"Error opening %s: %s\\n\", line, strerror(errno));\n\t\treturn;\n\t}\n\twhile (fgets(line, 400, f)) {\n\t\tif (strncmp(line, \"Uid:\", 4) == 0) {\n\t\t\tif (sscanf(line+4, \"%u\", &u) != 1) {\n\t\t\t\tfprintf(stderr, \"bad uid line for pid %u\\n\", pid);\n\t\t\t\tfclose(f);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t*uid = u;\n\t\t} else if (strncmp(line, \"Gid:\", 4) == 0) {\n\t\t\tif (sscanf(line+4, \"%u\", &g) != 1) {\n\t\t\t\tfprintf(stderr, \"bad gid line for pid %u\\n\", pid);\n\t\t\t\tfclose(f);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t*gid = g;\n\t\t}\n\t}\n\tfclose(f);\n}",
        "output": "0",
        "idx": 7313
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (inode_capable(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (inode_capable(inode, CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (inode_capable(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (inode_capable(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}",
        "output": "1",
        "idx": 2584
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void vhost_net_ubuf_put_wait_and_free(struct vhost_net_ubuf_ref *ubufs)\n{\n\tvhost_net_ubuf_put_and_wait(ubufs);\n\tkfree(ubufs);\n}",
        "output": "0",
        "idx": 3285
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sctp_skb_set_owner_r_frag(struct sk_buff *skb, struct sock *sk)\n{\n\tstruct sk_buff *frag;\n\n\tif (!skb->data_len)\n\t\tgoto done;\n\n\tfor (frag = skb_shinfo(skb)->frag_list; frag; frag = frag->next)\n\t\tsctp_skb_set_owner_r_frag(frag, sk);\n\ndone:\n\tsctp_skb_set_owner_r(skb, sk);\n}",
        "output": "0",
        "idx": 2981
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(locale_get_display_region)\n{\n    get_icu_disp_value_src_php( LOC_REGION_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}",
        "output": "0",
        "idx": 5425
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseRoutes(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    MprJson     *child;\n    HttpRoute   *newRoute;\n    cchar       *pattern;\n    int         ji;\n\n    if (route->loaded) {\n        mprLog(\"warn http config\", 1, \"Skip reloading routes - must reboot if routes are modified\");\n        return;\n    }\n    if (prop->type & MPR_JSON_STRING) {\n        httpAddRouteSet(route, prop->value);\n\n    } else if (prop->type & MPR_JSON_ARRAY) {\n        key = sreplace(key, \".routes\", \"\");\n        for (ITERATE_CONFIG(route, prop, child, ji)) {\n            if (child->type & MPR_JSON_STRING) {\n                httpAddRouteSet(route, child->value);\n\n            } else if (child->type & MPR_JSON_OBJ) {\n                newRoute = 0;\n                pattern = mprLookupJson(child, \"pattern\");\n                if (pattern) {\n                    newRoute = httpLookupRouteByPattern(route->host, pattern);\n                    if (!newRoute) {\n                        newRoute = httpCreateInheritedRoute(route);\n                        httpSetRouteHost(newRoute, route->host);\n                    }\n                } else {\n                    newRoute = route;\n                }\n                parseAll(newRoute, key, child);\n                if (newRoute->error) {\n                    break;\n                }\n                if (pattern) {\n                    httpFinalizeRoute(newRoute);\n                }\n            }\n        }\n    }\n}",
        "output": "1",
        "idx": 5016
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "__u32 secure_ipv6_id(const __be32 daddr[4])\n{\n\t__u32 hash[4];\n\n\tmemcpy(hash, daddr, 16);\n\tmd5_transform(hash, net_secret);\n\n\treturn hash[0];\n}",
        "output": "0",
        "idx": 785
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int http_read_header(URLContext *h, int *new_location)\n{\n    HTTPContext *s = h->priv_data;\n    char line[MAX_URL_SIZE];\n    int err = 0;\n\n    s->chunksize = UINT64_MAX;\n\n    for (;;) {\n        if ((err = http_get_line(s, line, sizeof(line))) < 0)\n            return err;\n\n        av_log(h, AV_LOG_TRACE, \"header='%s'\\n\", line);\n\n        err = process_line(h, line, s->line_count, new_location);\n        if (err < 0)\n            return err;\n        if (err == 0)\n            break;\n        s->line_count++;\n    }\n\n    if (s->seekable == -1 && s->is_mediagateway && s->filesize == 2000000000)\n        h->is_streamed = 1; \n\n    cookie_string(s->cookie_dict, &s->cookies);\n    av_dict_free(&s->cookie_dict);\n\n    return err;\n}",
        "output": "0",
        "idx": 4835
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_aead raead;\n\tstruct aead_alg *aead = &alg->cra_aead;\n\n\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"aead\");\n\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t aead->geniv ?: \"<built-in>\");\n\n\traead.blocksize = alg->cra_blocksize;\n\traead.maxauthsize = aead->maxauthsize;\n\traead.ivsize = aead->ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,\n\t\t    sizeof(struct crypto_report_aead), &raead))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "1",
        "idx": 846
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct btrfs_device *find_device(struct btrfs_fs_devices *fs_devices,\n\t\tu64 devid, const u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\n\tlist_for_each_entry(dev, &fs_devices->devices, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}",
        "output": "1",
        "idx": 3108
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void dhcps_send_ack(struct pbuf *packet_buffer)\n{\n\tdhcp_message_repository = (struct dhcp_msg *)packet_buffer->payload;\n\tdhcps_initialize_message(dhcp_message_repository);\n\tadd_offer_options(add_msg_type(&dhcp_message_repository->options[4],\n\t\t\t      \t\t\tDHCP_MESSAGE_TYPE_ACK));\n\tudp_sendto_if(dhcps_pcb, packet_buffer,\n\t\t   &dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);\n}",
        "output": "1",
        "idx": 8408
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cipso_v4_req_delattr(struct request_sock *req)\n{\n\tstruct ip_options *opt;\n\tstruct inet_request_sock *req_inet;\n\n\treq_inet = inet_rsk(req);\n\topt = req_inet->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn;\n\n\tcipso_v4_delopt(&req_inet->opt);\n}",
        "output": "1",
        "idx": 334
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static unsigned int check_time(gnutls_x509_crt_t crt, time_t now)\n{\nint status = 0;\ntime_t t;\n\n  t = gnutls_x509_crt_get_activation_time (crt);\n  if (t == (time_t) - 1 || now < t)\n    {\n      status |= GNUTLS_CERT_NOT_ACTIVATED;\n      status |= GNUTLS_CERT_INVALID;\n      return status;\n    }\n\n  t = gnutls_x509_crt_get_expiration_time (crt);\n  if (t == (time_t) - 1 || now > t)\n    {\n      status |= GNUTLS_CERT_EXPIRED;\n      status |= GNUTLS_CERT_INVALID;\n      return status;\n    }\n  \n  return 0;\n}",
        "output": "0",
        "idx": 6463
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *strdup(const char *s1)\n{\n\tchar *s2 = 0;\n\tif (s1) {\n\t\ts2 = malloc(strlen(s1) + 1);\n\t\tstrcpy(s2, s1);\n\t}\n\treturn s2;\n}",
        "output": "1",
        "idx": 5182
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct page *try_get_compound_head(struct page *page, int refs)\n{\n\tstruct page *head = compound_head(page);\n\tif (WARN_ON_ONCE(page_ref_count(head) < 0))\n\t\treturn NULL;\n\tif (unlikely(!page_cache_add_speculative(head, refs)))\n\t\treturn NULL;\n\treturn head;\n}",
        "output": "0",
        "idx": 4339
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void scsi_dma_restart_bh(void *opaque)\n{\n    SCSIDiskState *s = opaque;\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n\n    qemu_bh_delete(s->bh);\n    s->bh = NULL;\n\n    QTAILQ_FOREACH(req, &s->qdev.requests, next) {\n        r = DO_UPCAST(SCSIDiskReq, req, req);\n        if (r->status & SCSI_REQ_STATUS_RETRY) {\n            int status = r->status;\n            int ret;\n\n            r->status &=\n                ~(SCSI_REQ_STATUS_RETRY | SCSI_REQ_STATUS_RETRY_TYPE_MASK);\n\n            switch (status & SCSI_REQ_STATUS_RETRY_TYPE_MASK) {\n            case SCSI_REQ_STATUS_RETRY_READ:\n                scsi_read_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_WRITE:\n                scsi_write_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_FLUSH:\n                ret = scsi_disk_emulate_command(r);\n                if (ret == 0) {\n                    scsi_req_complete(&r->req, GOOD);\n                }\n            }\n        }\n    }\n}",
        "output": "0",
        "idx": 5007
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\tif (error < 0)\n\t\t\treturn 0;\n\t\tif (error == 0)\n\t\t\tacl = NULL;\n\t}\n\n\tinode->i_ctime = current_time(inode);\n\tset_cached_acl(inode, type, acl);\n\treturn 0;\n}",
        "output": "1",
        "idx": 1408
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void sem_unlock(struct sem_array *sma, int locknum)\n{\n\tif (locknum == -1) {\n\t\tspin_unlock(&sma->sem_perm.lock);\n\t} else {\n\t\tstruct sem *sem = sma->sem_base + locknum;\n\t\tspin_unlock(&sem->lock);\n\t}\n\trcu_read_unlock();\n}",
        "output": "0",
        "idx": 3225
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int ras_validate(jas_stream_t *in)\n{\n\tuchar buf[RAS_MAGICLEN];\n\tint i;\n\tint n;\n\tuint_fast32_t magic;\n\n\tassert(JAS_STREAM_MAXPUTBACK >= RAS_MAGICLEN);\n\n\tif ((n = jas_stream_read(in, buf, RAS_MAGICLEN)) < 0) {\n\t\treturn -1;\n\t}\n\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (n < RAS_MAGICLEN) {\n\t\treturn -1;\n\t}\n\n\tmagic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |\n\t  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |\n\t  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |\n\t  buf[3];\n\n\tif (magic != RAS_MAGIC) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
        "output": "1",
        "idx": 5420
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\n\t(void)mode;\t\n\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_POSIX1E, \"posix1e\");\n\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}",
        "output": "1",
        "idx": 3694
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\n\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tif (!cb->args[0]) {\n\t\tcb->args[0] = 1;\n\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\t}\n\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\n\treturn skb->len;\n}",
        "output": "1",
        "idx": 1750
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tty_set_termios_ldisc(struct tty_struct *tty, int num)\n{\n\tdown_write(&tty->termios_rwsem);\n\ttty->termios.c_line = num;\n\tup_write(&tty->termios_rwsem);\n\n\ttty->disc_data = NULL;\n\ttty->receive_room = 0;\n}",
        "output": "0",
        "idx": 1457
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void options_free() {\n    parse_global_option(CMD_FREE, NULL, NULL);\n}",
        "output": "1",
        "idx": 8454
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cms_copy_content(BIO *out, BIO *in, unsigned int flags)\n\t{\n\tunsigned char buf[4096];\n\tint r = 0, i;\n\tBIO *tmpout;\n\n\ttmpout = cms_get_text_bio(out, flags);\n\n\tif(!tmpout)\n\t\t{\n\t\tCMSerr(CMS_F_CMS_COPY_CONTENT,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\n\tfor (;;)\n\t{\n\t\ti=BIO_read(in,buf,sizeof(buf));\n\t\tif (i <= 0)\n\t\t\t{\n\t\t\tif (BIO_method_type(in) == BIO_TYPE_CIPHER)\n\t\t\t\t{\n\t\t\t\tif (!BIO_get_cipher_status(in))\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tif (i < 0)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\t\t}\n\t\t\t\t\n\t\tif (tmpout && (BIO_write(tmpout, buf, i) != i))\n\t\t\tgoto err;\n\t}\n\n\tif(flags & CMS_TEXT)\n\t\t{\n\t\tif(!SMIME_text(tmpout, out))\n\t\t\t{\n\t\t\tCMSerr(CMS_F_CMS_COPY_CONTENT,CMS_R_SMIME_TEXT_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\tr = 1;\n\n\terr:\n\tif (tmpout && (tmpout != out))\n\t\tBIO_free(tmpout);\n\treturn r;\n\n\t}",
        "output": "0",
        "idx": 6349
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer)\n{\n\tusb_kill_urb(mixer->urb);\n\tusb_kill_urb(mixer->rc_urb);\n}",
        "output": "1",
        "idx": 1696
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_Unpickler_MemoGet(UnpicklerObject *self, Py_ssize_t idx)\n{\n    if (idx < 0 || idx >= self->memo_size)\n        return NULL;\n\n    return self->memo[idx];\n}",
        "output": "1",
        "idx": 7154
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "findoprnd(ITEM *ptr, int32 *pos)\n{\n\tcheck_stack_depth();\n\n#ifdef BS_DEBUG\n\telog(DEBUG3, (ptr[*pos].type == OPR) ?\n\t\t \"%d  %c\" : \"%d  %d\", *pos, ptr[*pos].val);\n#endif\n\tif (ptr[*pos].type == VAL)\n\t{\n\t\tptr[*pos].left = 0;\n\t\t(*pos)--;\n\t}\n\telse if (ptr[*pos].val == (int32) '!')\n\t{\n\t\tptr[*pos].left = -1;\n\t\t(*pos)--;\n\t\tfindoprnd(ptr, pos);\n\t}\n\telse\n\t{\n\t\tITEM\t   *curitem = &ptr[*pos];\n\t\tint32\t\ttmp = *pos;\n\n\t\t(*pos)--;\n\t\tfindoprnd(ptr, pos);\n\t\tcuritem->left = *pos - tmp;\n\t\tfindoprnd(ptr, pos);\n\t}\n}",
        "output": "0",
        "idx": 6279
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void json_object_seed(size_t seed) {\n    uint32_t new_seed = (uint32_t)seed;\n\n    if (hashtable_seed == 0) {\n        if (__atomic_test_and_set(&seed_initialized, __ATOMIC_RELAXED) == 0) {\n            if (new_seed == 0)\n                new_seed = generate_seed();\n\n            __atomic_store_n(&hashtable_seed, new_seed, __ATOMIC_ACQ_REL);\n        } else {\n            do {\n#ifdef HAVE_SCHED_YIELD\n                sched_yield();\n#endif\n            } while(__atomic_load_n(&hashtable_seed, __ATOMIC_ACQUIRE) == 0);\n        }\n    }\n}",
        "output": "0",
        "idx": 5985
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t\t  OM_uint32 acc_negState, gss_OID supportedMech,\n\t\t  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t\t  OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 tmpmin;\n\tsize_t i;\n\n\tgeneric_gss_release_oid(&tmpmin, &sc->internal_mech);\n\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n\t\t\t       GSS_C_NO_BUFFER);\n\n\tfor (i = 0; i < sc->mech_set->count; i++) {\n\t\tif (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))\n\t\t\tbreak;\n\t}\n\tif (i == sc->mech_set->count)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->internal_mech = &sc->mech_set->elements[i];\n\n\tif (acc_negState != REQUEST_MIC)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\tsc->mech_complete = 0;\n\tsc->mic_reqd = 1;\n\t*negState = REQUEST_MIC;\n\t*tokflag = CONT_TOKEN_SEND;\n\treturn GSS_S_CONTINUE_NEEDED;\n}",
        "output": "1",
        "idx": 10
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "irc_ctcp_dcc_filename_without_quotes (const char *filename)\n{\n    int length;\n\n    length = strlen (filename);\n    if (length > 0)\n    {\n        if ((filename[0] == '\\\"') && (filename[length - 1] == '\\\"'))\n            return weechat_strndup (filename + 1, length - 2);\n    }\n    return strdup (filename);\n}",
        "output": "1",
        "idx": 6292
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1570
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE)) {\n\t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\t\tcomplete(&task->slow_task->completion);\n\t}\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n}",
        "output": "0",
        "idx": 4155
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void netbk_fatal_tx_err(struct xenvif *vif)\n{\n\tnetdev_err(vif->dev, \"fatal error; disabling device\\n\");\n\txenvif_carrier_off(vif);\n\txenvif_put(vif);\n}",
        "output": "0",
        "idx": 1155
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_pseudo_random(OM_uint32 *minor_status,\n\t\t\t gss_ctx_id_t context,\n\t\t\t int prf_key,\n\t\t\t const gss_buffer_t prf_in,\n\t\t\t ssize_t desired_output_len,\n\t\t\t gss_buffer_t prf_out)\n{\n\tOM_uint32 ret;\n\tret = gss_pseudo_random(minor_status,\n\t\t\t\tcontext,\n\t\t\t\tprf_key,\n\t\t\t\tprf_in,\n\t\t\t\tdesired_output_len,\n\t\t\t\tprf_out);\n        return (ret);\n}",
        "output": "1",
        "idx": 82
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int _mkp_stage_30(struct plugin *p,\n        struct client_session *cs,\n        struct session_request *sr)\n{\n    mk_ptr_t referer;\n    (void) p;\n    (void) cs;\n\n    PLUGIN_TRACE(\"[FD %i] Mandril validating URL\", cs->socket);\n\n    if (mk_security_check_url(sr->uri_processed) < 0) {\n        PLUGIN_TRACE(\"[FD %i] Close connection, blocked URL\", cs->socket);\n        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n\n    PLUGIN_TRACE(\"[FD %d] Mandril validating hotlinking\", cs->socket);\n    referer = mk_api->header_get(&sr->headers_toc, \"Referer\", strlen(\"Referer\"));\n    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {\n        PLUGIN_TRACE(\"[FD %i] Close connection, deny hotlinking.\", cs->socket);\n        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n\n    return MK_PLUGIN_RET_NOT_ME;\n}",
        "output": "0",
        "idx": 5351
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static u_int mp_dss_len(const  struct mp_dss *m, int csum)\n{\n        u_int len;\n\n        len = 4;\n        if (m->flags & MP_DSS_A) {\n                len += (m->flags & MP_DSS_a) ? 8 : 4;\n        }\n        if (m->flags & MP_DSS_M) {\n                len += (m->flags & MP_DSS_m) ? 14 : 10;\n\n                if (csum)\n                        len += 2;\n\t}\n\treturn len;\n}",
        "output": "1",
        "idx": 4836
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w){\n    long i;\n#if !HAVE_FAST_UNALIGNED\n    if((long)src2 & (sizeof(long)-1)){\n        for(i=0; i+7<w; i+=8){\n            dst[i+0] = src1[i+0]-src2[i+0];\n            dst[i+1] = src1[i+1]-src2[i+1];\n            dst[i+2] = src1[i+2]-src2[i+2];\n            dst[i+3] = src1[i+3]-src2[i+3];\n            dst[i+4] = src1[i+4]-src2[i+4];\n            dst[i+5] = src1[i+5]-src2[i+5];\n            dst[i+6] = src1[i+6]-src2[i+6];\n            dst[i+7] = src1[i+7]-src2[i+7];\n        }\n    }else\n#endif\n    for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long)){\n        long a = *(long*)(src1+i);\n        long b = *(long*)(src2+i);\n        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] = src1[i+0]-src2[i+0];\n}",
        "output": "0",
        "idx": 4969
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "qedi_dbg_info(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      u32 level, const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\n\tva_start(va, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\n\tif (!(qedi_dbg_log & level))\n\t\tgoto ret;\n\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_info(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tnfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_info(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\n\nret:\n\tva_end(va);\n}",
        "output": "1",
        "idx": 3184
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(RecursiveDirectoryIterator, getSubPathname)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar *sub_name;\n\tint len;\n\tchar slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (intern->u.dir.sub_path) {\n\t\tlen = spprintf(&sub_name, 0, \"%s%c%s\", intern->u.dir.sub_path, slash, intern->u.dir.entry.d_name);\n\t\tRETURN_STRINGL(sub_name, len, 0);\n\t} else {\n\t\tRETURN_STRING(intern->u.dir.entry.d_name, 1);\n\t}\n}",
        "output": "0",
        "idx": 5559
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateStringArray(const char **strings,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}",
        "output": "0",
        "idx": 8283
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sysName_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_string(varbind, oid, \"Contiki-NG - \"CONTIKI_TARGET_STRING);\n}",
        "output": "1",
        "idx": 7930
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int bprm_change_interp(char *interp, struct linux_binprm *bprm)\n{\n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tbprm->interp = kstrdup(interp, GFP_KERNEL);\n\tif (!bprm->interp)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
        "output": "0",
        "idx": 1111
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\n\tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\n\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n\t}\n\n\txfrm_probe_algs();\n\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL | __GFP_ZERO);\n\tif (!supp_skb) {\n\t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n\n\t\treturn -ENOBUFS;\n\t}\n\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,\n\t\t\tsock_net(sk));\n\treturn 0;\n}",
        "output": "0",
        "idx": 2907
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\n\t\treturn err;\n\t}\n\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err == 0) {\n\t\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\t\tif (bt_sk(sk)->skb_msg_name)\n\t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n\t\t\t\t\t\t&msg->msg_namelen);\n\t}\n\n\tskb_free_datagram(sk, skb);\n\n\treturn err ? : copied;\n}",
        "output": "0",
        "idx": 3393
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "__u32 secure_ip_id(__be32 daddr)\n{\n\tu32 hash[MD5_DIGEST_WORDS];\n\n\thash[0] = (__force __u32) daddr;\n\thash[1] = net_secret[13];\n\thash[2] = net_secret[14];\n\thash[3] = net_secret[15];\n\n\tmd5_transform(hash, net_secret);\n\n\treturn hash[0];\n}",
        "output": "0",
        "idx": 787
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct usb_serial\t*serial = port->serial;\n\tstruct usb_serial_port\t*wport;\n\n\twport = serial->port[1];\n\ttty_port_tty_set(&wport->port, tty);\n\n\treturn usb_serial_generic_open(tty, port);\n}",
        "output": "1",
        "idx": 1518
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int update_prepare_order_info(rdpContext* context, ORDER_INFO* orderInfo, UINT32 orderType)\n{\n\tint length = 1;\n\torderInfo->fieldFlags = 0;\n\torderInfo->orderType = orderType;\n\torderInfo->controlFlags = ORDER_STANDARD;\n\torderInfo->controlFlags |= ORDER_TYPE_CHANGE;\n\tlength += 1;\n\tlength += get_primary_drawing_order_field_bytes(orderInfo->orderType, NULL);\n\tlength += update_prepare_bounds(context, orderInfo);\n\treturn length;\n}",
        "output": "0",
        "idx": 5755
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sraSpanInsertAfter(sraSpan *newspan, sraSpan *after) {\n  if(newspan && after) {\n    newspan->_next = after->_next;\n    newspan->_prev = after;\n    after->_next->_prev = newspan;\n    after->_next = newspan;\n  }\n}",
        "output": "0",
        "idx": 8933
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, hasChildren)\n{\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\t\n\tRETURN_FALSE;\n} ",
        "output": "1",
        "idx": 3930
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tif (ctx->might_cancel) {\n\t\tctx->might_cancel = false;\n\t\tspin_lock(&cancel_lock);\n\t\tlist_del_rcu(&ctx->clist);\n\t\tspin_unlock(&cancel_lock);\n\t}\n}",
        "output": "0",
        "idx": 2147
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "vips_foreign_load_start( VipsImage *out, void *a, void *b )\n{\n\tVipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );\n\tVipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );\n\n\tif( !load->real ) {\n\t\tif( !(load->real = vips_foreign_load_temp( load )) )\n\t\t\treturn( NULL );\n\n#ifdef DEBUG\n\t\tprintf( \"vips_foreign_load_start: triggering ->load()\\n\" );\n#endif \n\n\t\tload->real->progress_signal = load->out;\n\n\t\tg_object_set_qdata( G_OBJECT( load->real ), \n\t\t\tvips__foreign_load_operation, load ); \n\n\t\tif( class->load( load ) ||\n\t\t\tvips_image_pio_input( load->real ) ) \n\t\t\treturn( NULL );\n\n\t\tif( !vips_foreign_load_iscompat( load->real, out ) )\n\t\t\treturn( NULL );\n\n\t\tvips_image_pipelinev( load->out, load->out->dhint, \n\t\t\tload->real, NULL );\n\t}\n\n\treturn( vips_region_new( load->real ) );\n}",
        "output": "1",
        "idx": 7330
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb)\n{\n\tstruct xfrm_algo *algo;\n\tstruct nlattr *nla;\n\n\tnla = nla_reserve(skb, XFRMA_ALG_AUTH,\n\t\t\t  sizeof(*algo) + (auth->alg_key_len + 7) / 8);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\talgo = nla_data(nla);\n\tstrcpy(algo->alg_name, auth->alg_name);\n\tmemcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8);\n\talgo->alg_key_len = auth->alg_key_len;\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 770
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int logi_dj_ll_raw_request(struct hid_device *hid,\n\t\t\t\t  unsigned char reportnum, __u8 *buf,\n\t\t\t\t  size_t count, unsigned char report_type,\n\t\t\t\t  int reqtype)\n{\n\tstruct dj_device *djdev = hid->driver_data;\n\tstruct dj_receiver_dev *djrcv_dev = djdev->dj_receiver_dev;\n\tu8 *out_buf;\n\tint ret;\n\n\tif (buf[0] != REPORT_TYPE_LEDS)\n\t\treturn -EINVAL;\n\n\tout_buf = kzalloc(DJREPORT_SHORT_LENGTH, GFP_ATOMIC);\n\tif (!out_buf)\n\t\treturn -ENOMEM;\n\n\tif (count > DJREPORT_SHORT_LENGTH - 2)\n\t\tcount = DJREPORT_SHORT_LENGTH - 2;\n\n\tout_buf[0] = REPORT_ID_DJ_SHORT;\n\tout_buf[1] = djdev->device_index;\n\tmemcpy(out_buf + 2, buf, count);\n\n\tret = hid_hw_raw_request(djrcv_dev->hdev, out_buf[0], out_buf,\n\t\tDJREPORT_SHORT_LENGTH, report_type, reqtype);\n\n\tkfree(out_buf);\n\treturn ret;\n}",
        "output": "0",
        "idx": 3643
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int net_get(int s, void *arg, int *len)\n{\n\tstruct net_hdr nh;\n\tint plen;\n\n\tif (net_read_exact(s, &nh, sizeof(nh)) == -1)\n        {\n\t\treturn -1;\n        }\n\n\tplen = ntohl(nh.nh_len);\n\tif (!(plen <= *len))\n\t\tprintf(\"PLEN %d type %d len %d\\n\",\n\t\t\tplen, nh.nh_type, *len);\n\tassert(plen <= *len); \n\n\t*len = plen;\n\tif ((*len) && (net_read_exact(s, arg, *len) == -1))\n        {\n            return -1;\n        }\n\n\treturn nh.nh_type;\n}",
        "output": "1",
        "idx": 4638
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_chainname_rulenum(const struct ip6t_entry *s, const struct ip6t_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ip6t_get_target_c(s);\n\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\n\t\tif (unconditional(s) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t    t->verdict < 0) {\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP6_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP6_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1769
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int rds_rdma_extra_size(struct rds_rdma_args *args)\n{\n\tstruct rds_iovec vec;\n\tstruct rds_iovec __user *local_vec;\n\tint tot_pages = 0;\n\tunsigned int nr_pages;\n\tunsigned int i;\n\n\tlocal_vec = (struct rds_iovec __user *)(unsigned long) args->local_vec_addr;\n\n\tif (args->nr_local == 0)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < args->nr_local; i++) {\n\t\tif (copy_from_user(&vec, &local_vec[i],\n\t\t\t\t   sizeof(struct rds_iovec)))\n\t\t\treturn -EFAULT;\n\n\t\tnr_pages = rds_pages_in_vec(&vec);\n\t\tif (nr_pages == 0)\n\t\t\treturn -EINVAL;\n\n\t\ttot_pages += nr_pages;\n\n\t\tif (tot_pages < 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn tot_pages * sizeof(struct scatterlist);\n}",
        "output": "0",
        "idx": 2633
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static Jsi_Value *jsi_hashFmtKey(Jsi_MapEntry* h, struct Jsi_MapOpts *opts, int flags)\n{\n    Jsi_HashEntry* hPtr = (Jsi_HashEntry*)h;\n    void *key = Jsi_HashKeyGet(hPtr);\n    if (opts->keyType == JSI_KEYS_ONEWORD)\n        return Jsi_ValueNewNumber(opts->interp, (Jsi_Number)(intptr_t)key);\n    char nbuf[100];\n    snprintf(nbuf, sizeof(nbuf), \"%p\", key);\n    return Jsi_ValueNewStringDup(opts->interp, nbuf);\n}",
        "output": "1",
        "idx": 8188
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void cjson_get_object_item_case_sensitive_should_not_crash_with_array(void) {\n    cJSON *array = NULL;\n    cJSON *found = NULL;\n    array = cJSON_Parse(\"[1]\");\n\n    found = cJSON_GetObjectItemCaseSensitive(array, \"name\");\n    TEST_ASSERT_NULL(found);\n\n    cJSON_Delete(array);\n}",
        "output": "0",
        "idx": 7901
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iakerb_gss_delete_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t output_token)\n{\n    iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n\n    if (output_token != GSS_C_NO_BUFFER) {\n        output_token->length = 0;\n        output_token->value = NULL;\n    }\n\n    *minor_status = 0;\n    *context_handle = GSS_C_NO_CONTEXT;\n    iakerb_release_context(iakerb_ctx);\n\n    return GSS_S_COMPLETE;\n}",
        "output": "0",
        "idx": 161
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void uwbd_start(struct uwb_rc *rc)\n{\n\trc->uwbd.task = kthread_run(uwbd, rc, \"uwbd\");\n\tif (rc->uwbd.task == NULL)\n\t\tprintk(KERN_ERR \"UWB: Cannot start management daemon; \"\n\t\t       \"UWB won't work\\n\");\n\telse\n\t\trc->uwbd.pid = rc->uwbd.task->pid;\n}",
        "output": "1",
        "idx": 1658
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int wrmsr_interception(struct vcpu_svm *svm)\n{\n\tstruct msr_data msr;\n\tu32 ecx = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\tu64 data = (svm->vcpu.arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(svm->vcpu.arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tif (svm_set_msr(&svm->vcpu, &msr)) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t} else {\n\t\ttrace_kvm_msr_write(ecx, data);\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}",
        "output": "1",
        "idx": 2700
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sas_eh_defer_cmd(struct scsi_cmnd *cmd)\n{\n\tstruct domain_device *dev = cmd_to_domain_dev(cmd);\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\tstruct sas_task *task = TO_SAS_TASK(cmd);\n\n\tif (!dev_is_sata(dev)) {\n\t\tsas_eh_finish_cmd(cmd);\n\t\treturn;\n\t}\n\n\tsas_end_task(cmd, task);\n\tlist_move_tail(&cmd->eh_entry, &ha->eh_ata_q);\n}",
        "output": "1",
        "idx": 1848
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool matchExpression(MprJson *obj, int operator, char *value)\n{\n    if (!(obj->type & MPR_JSON_VALUE)) {\n        return 0;\n    }\n    value = stok(value, \"'\\\"\", NULL);\n    switch (operator) {\n    case JSON_OP_EQ:\n        return smatch(obj->value, value);\n    case JSON_OP_NE:\n        return !smatch(obj->value, value);\n    case JSON_OP_LT:\n        return scmp(obj->value, value) < 0;\n    case JSON_OP_LE:\n        return scmp(obj->value, value) <= 0;\n    case JSON_OP_GT:\n        return scmp(obj->value, value) > 0;\n    case JSON_OP_GE:\n        return scmp(obj->value, value) >= 0;\n    case JSON_OP_MATCH:\n        return scontains(obj->value, value) != 0;\n    case JSON_OP_NMATCH:\n        return scontains(obj->value, value) == 0;\n    default:\n        return 0;\n    }\n}",
        "output": "1",
        "idx": 5106
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n{\n    char *buffer=NULL;\n    int   n=0;\n\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);\n\n    if(length == SIZE_MAX) {\n\trfbErr(\"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\", (unsigned int)length);\n\trfbCloseClient(cl);\n\treturn NULL;\n    }\n\n    if (length>0) {\n        buffer=malloc((size_t)length+1);\n        if (buffer!=NULL) {\n            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(cl);\n                if (buffer!=NULL) free(buffer);\n                return NULL;\n            }\n            buffer[length]=0;\n        }\n    }\n    return buffer;\n}",
        "output": "0",
        "idx": 8915
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int utf8s_to_utf16s(const u8 *s, int len, wchar_t *pwcs)\n{\n\tu16 *op;\n\tint size;\n\tunicode_t u;\n\n\top = pwcs;\n\twhile (*s && len > 0) {\n\t\tif (*s & 0x80) {\n\t\t\tsize = utf8_to_utf32(s, len, &u);\n\t\t\tif (size < 0)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (u >= PLANE_SIZE) {\n\t\t\t\tu -= PLANE_SIZE;\n\t\t\t\t*op++ = (wchar_t) (SURROGATE_PAIR |\n\t\t\t\t\t\t((u >> 10) & SURROGATE_BITS));\n\t\t\t\t*op++ = (wchar_t) (SURROGATE_PAIR |\n\t\t\t\t\t\tSURROGATE_LOW |\n\t\t\t\t\t\t(u & SURROGATE_BITS));\n\t\t\t} else {\n\t\t\t\t*op++ = (wchar_t) u;\n\t\t\t}\n\t\t\ts += size;\n\t\t\tlen -= size;\n\t\t} else {\n\t\t\t*op++ = *s++;\n\t\t\tlen--;\n\t\t}\n\t}\n\treturn op - pwcs;\n}",
        "output": "1",
        "idx": 642
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(DirectoryIterator, isDot)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_BOOL(spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n}",
        "output": "1",
        "idx": 4036
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_visual_pos(void)\n{\n    if (VIsual.lnum > curbuf->b_ml.ml_line_count)\n    {\n\tVIsual.lnum = curbuf->b_ml.ml_line_count;\n\tVIsual.col = 0;\n\tVIsual.coladd = 0;\n    }\n    else\n    {\n\tint len = (int)STRLEN(ml_get(VIsual.lnum));\n\n\tif (VIsual.col > len)\n\t{\n\t    VIsual.col = len;\n\t    VIsual.coladd = 0;\n\t}\n    }\n}",
        "output": "0",
        "idx": 8039
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int key_default_cmp(const struct key *key,\n\t\t    const struct key_match_data *match_data)\n{\n\treturn strcmp(key->description, match_data->raw_data) == 0;\n}",
        "output": "0",
        "idx": 3687
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI) & 0xff;\n\tmax_irr = apic_find_highest_irr(apic);\n\tif (max_irr < 0)\n\t\tmax_irr = 0;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n\t\t\t\tsizeof(u32));\n}",
        "output": "0",
        "idx": 3429
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "juniper_monitor_print(netdissect_options *ndo,\n                      const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        struct juniper_monitor_header {\n            uint8_t pkt_type;\n            uint8_t padding;\n            uint8_t iif[2];\n            uint8_t service_id[4];\n        };\n        const struct juniper_monitor_header *mh;\n\n        l2info.pictype = DLT_JUNIPER_MONITOR;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n\n        p+=l2info.header_len;\n        mh = (const struct juniper_monitor_header *)p;\n\n        ND_TCHECK(*mh);\n        if (ndo->ndo_eflag)\n            ND_PRINT((ndo, \"service-id %u, iif %u, pkt-type %u: \",\n                   EXTRACT_32BITS(&mh->service_id),\n                   EXTRACT_16BITS(&mh->iif),\n                   mh->pkt_type));\n\n        ip_heuristic_guess (ndo, p, l2info.length);\n\n        return l2info.header_len;\n\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_services]\"));\n\treturn l2info.header_len;\n}",
        "output": "0",
        "idx": 6619
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ceph_x_verify_authorizer_reply(struct ceph_auth_client *ac,\n\t\t\t\t\t  struct ceph_authorizer *a, size_t len)\n{\n\tstruct ceph_x_authorizer *au = (void *)a;\n\tstruct ceph_x_ticket_handler *th;\n\tint ret = 0;\n\tstruct ceph_x_authorize_reply reply;\n\tvoid *preply = &reply;\n\tvoid *p = au->reply_buf;\n\tvoid *end = p + sizeof(au->reply_buf);\n\n\tth = get_ticket_handler(ac, au->service);\n\tif (IS_ERR(th))\n\t\treturn PTR_ERR(th);\n\tret = ceph_x_decrypt(&th->session_key, &p, end, &preply, sizeof(reply));\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != sizeof(reply))\n\t\treturn -EPERM;\n\n\tif (au->nonce + 1 != le64_to_cpu(reply.nonce_plus_one))\n\t\tret = -EPERM;\n\telse\n\t\tret = 0;\n\tdout(\"verify_authorizer_reply nonce %llx got %llx ret %d\\n\",\n\t     au->nonce, le64_to_cpu(reply.nonce_plus_one), ret);\n\treturn ret;\n}",
        "output": "0",
        "idx": 3667
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void hugetlb_vm_op_close(struct vm_area_struct *vma)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct resv_map *reservations = vma_resv_map(vma);\n\tunsigned long reserve;\n\tunsigned long start;\n\tunsigned long end;\n\n\tif (reservations) {\n\t\tstart = vma_hugecache_offset(h, vma, vma->vm_start);\n\t\tend = vma_hugecache_offset(h, vma, vma->vm_end);\n\n\t\treserve = (end - start) -\n\t\t\tregion_count(&reservations->regions, start, end);\n\n\t\tkref_put(&reservations->refs, resv_map_release);\n\n\t\tif (reserve) {\n\t\t\thugetlb_acct_memory(h, -reserve);\n\t\t\thugetlb_put_quota(vma->vm_file->f_mapping, reserve);\n\t\t}\n\t}\n}",
        "output": "1",
        "idx": 686
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)\n{\n\tint n;\n\tconst char *bufptr;\n\n\tif (cnt < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_write\");\n\t}\n\n\tbufptr = buf;\n\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif (jas_stream_putc(stream, *bufptr) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t++bufptr;\n\t\t++n;\n\t}\n\n\treturn n;\n}",
        "output": "0",
        "idx": 7541
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int DSA_verify(int type, const unsigned char *dgst, int dgst_len,\n\t     const unsigned char *sigbuf, int siglen, DSA *dsa)\n\t{\n\tDSA_SIG *s;\n\tconst unsigned char *p = sigbuf;\n\tunsigned char *der = NULL;\n\tint derlen = -1;\n\tint ret=-1;\n\n\ts = DSA_SIG_new();\n\tif (s == NULL) return(ret);\n\tif (d2i_DSA_SIG(&s,&p,siglen) == NULL) goto err;\n\tderlen = i2d_DSA_SIG(s, &der);\n\tif (derlen != siglen || memcmp(sigbuf, der, derlen))\n\t\tgoto err;\n\tret=DSA_do_verify(dgst,dgst_len,s,dsa);\nerr:\n\tif (derlen > 0)\n\t\t{\n\t\tOPENSSL_cleanse(der, derlen);\n\t\tOPENSSL_free(der);\n\t\t}\n\tDSA_SIG_free(s);\n\treturn(ret);\n\t}",
        "output": "0",
        "idx": 6357
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xen_netbk_fill_frags(struct xen_netbk *netbk, struct sk_buff *skb)\n{\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\tint nr_frags = shinfo->nr_frags;\n\tint i;\n\n\tfor (i = 0; i < nr_frags; i++) {\n\t\tskb_frag_t *frag = shinfo->frags + i;\n\t\tstruct xen_netif_tx_request *txp;\n\t\tstruct page *page;\n\t\tu16 pending_idx;\n\n\t\tpending_idx = frag_get_pending_idx(frag);\n\n\t\ttxp = &netbk->pending_tx_info[pending_idx].req;\n\t\tpage = virt_to_page(idx_to_kaddr(netbk, pending_idx));\n\t\t__skb_fill_page_desc(skb, i, page, txp->offset, txp->size);\n\t\tskb->len += txp->size;\n\t\tskb->data_len += txp->size;\n\t\tskb->truesize += txp->size;\n\n\t\tget_page(netbk->mmap_pages[pending_idx]);\n\t\txen_netbk_idx_release(netbk, pending_idx);\n\t}\n}",
        "output": "1",
        "idx": 836
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct ipv6_txoptions *ipv6_update_options(struct sock *sk,\n\t\t\t\t\t   struct ipv6_txoptions *opt)\n{\n\tif (inet_sk(sk)->is_icsk) {\n\t\tif (opt &&\n\t\t    !((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE)) &&\n\t\t    inet_sk(sk)->inet_daddr != LOOPBACK4_IPV6) {\n\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\t\t\ticsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;\n\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\t}\n\t}\n\topt = xchg(&inet6_sk(sk)->opt, opt);\n\tsk_dst_reset(sk);\n\n\treturn opt;\n}",
        "output": "1",
        "idx": 962
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void rds_inc_info_copy(struct rds_incoming *inc,\n\t\t       struct rds_info_iterator *iter,\n\t\t       __be32 saddr, __be32 daddr, int flip)\n{\n\tstruct rds_info_message minfo;\n\n\tminfo.seq = be64_to_cpu(inc->i_hdr.h_sequence);\n\tminfo.len = be32_to_cpu(inc->i_hdr.h_len);\n\n\tif (flip) {\n\t\tminfo.laddr = daddr;\n\t\tminfo.faddr = saddr;\n\t\tminfo.lport = inc->i_hdr.h_dport;\n\t\tminfo.fport = inc->i_hdr.h_sport;\n\t} else {\n\t\tminfo.laddr = saddr;\n\t\tminfo.faddr = daddr;\n\t\tminfo.lport = inc->i_hdr.h_sport;\n\t\tminfo.fport = inc->i_hdr.h_dport;\n\t}\n\n\tminfo.flags = 0;\n\n\trds_info_copy(iter, &minfo, sizeof(minfo));\n}",
        "output": "0",
        "idx": 1889
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "main_get_appheader (xd3_stream *stream, main_file *ifile,\n\t\t    main_file *output, main_file *sfile)\n{\n  uint8_t *apphead;\n  usize_t appheadsz;\n  int ret;\n\n  if (! option_use_appheader) { return; }\n\n  ret = xd3_get_appheader (stream, & apphead, & appheadsz);\n\n  if (ret != 0) { return; }\n\n  if (appheadsz > 0)\n    {\n      const int kMaxArgs = 4;\n      char *start = (char*)apphead;\n      char *slash;\n      int   place = 0;\n      char *parsed[kMaxArgs];\n\n      memset (parsed, 0, sizeof (parsed));\n\n      while ((slash = strchr (start, '/')) != NULL && place < (kMaxArgs-1))\n\t{\n\t  *slash = 0;\n\t  parsed[place++] = start;\n\t  start = slash + 1;\n\t}\n\n      parsed[place++] = start;\n\n      if (place == 2 || place == 4)\n\t{\n\t  main_get_appheader_params (output, parsed, 1, \"output\", ifile);\n\t}\n\n      if (place == 4)\n\t{\n\t  main_get_appheader_params (sfile, parsed+2, 0, \"source\", ifile);\n\t}\n    }\n\n  option_use_appheader = 0;\n  return;\n}",
        "output": "0",
        "idx": 7099
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\n\tstrlcpy(extra_response->key, key, sizeof(extra_response->key));\n\tstrlcpy(extra_response->value, NOTUNDERSTOOD,\n\t\tsizeof(extra_response->value));\n\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}",
        "output": "0",
        "idx": 3239
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "snmp_api_set_time_ticks(snmp_varbind_t *varbind, uint32_t *oid, uint32_t integer)\n{\n\n  snmp_api_replace_oid(varbind, oid);\n  varbind->value_type = SNMP_DATA_TYPE_TIME_TICKS;\n  varbind->value.integer = integer;\n}",
        "output": "1",
        "idx": 7938
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ikev1_hash_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len _U_,\n\t\t const u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t\t uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_HASH)));\n\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_HASH)));\n\treturn NULL;\n}",
        "output": "0",
        "idx": 6805
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, ftell)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\t\n\tlong ret = php_stream_tell(intern->u.file.stream);\n\n\tif (ret == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_LONG(ret);\n\t}\n} ",
        "output": "1",
        "idx": 4030
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n{\n    pair_t *pair;\n    size_t hash;\n    bucket_t *bucket;\n\n    hash = hash_str(key);\n    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return NULL;\n\n    return &pair->list;\n}",
        "output": "0",
        "idx": 5967
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int http_open(URLContext *h, const char *uri, int flags,\n                     AVDictionary **options)\n{\n    HTTPContext *s = h->priv_data;\n    int ret;\n\n    if( s->seekable == 1 )\n        h->is_streamed = 0;\n    else\n        h->is_streamed = 1;\n\n    s->filesize = -1;\n    s->location = av_strdup(uri);\n    if (!s->location)\n        return AVERROR(ENOMEM);\n    if (options)\n        av_dict_copy(&s->chained_options, *options, 0);\n\n    if (s->headers) {\n        int len = strlen(s->headers);\n        if (len < 2 || strcmp(\"\\r\\n\", s->headers + len - 2)) {\n            av_log(h, AV_LOG_WARNING,\n                   \"No trailing CRLF found in HTTP header.\\n\");\n            ret = av_reallocp(&s->headers, len + 3);\n            if (ret < 0)\n                return ret;\n            s->headers[len]     = '\\r';\n            s->headers[len + 1] = '\\n';\n            s->headers[len + 2] = '\\0';\n        }\n    }\n\n    if (s->listen) {\n        return http_listen(h, uri, flags, options);\n    }\n    ret = http_open_cnx(h, options);\n    if (ret < 0)\n        av_dict_free(&s->chained_options);\n    return ret;\n}",
        "output": "1",
        "idx": 3450
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "file_ms_alloc(int flags)\n{\n\tstruct magic_set *ms;\n\tsize_t i, len;\n\n\tif ((ms = CAST(struct magic_set *, calloc((size_t)1,\n\t    sizeof(struct magic_set)))) == NULL)\n\t\treturn NULL;\n\n\tif (magic_setflags(ms, flags) == -1) {\n\t\terrno = EINVAL;\n\t\tgoto free;\n\t}\n\n\tms->o.buf = ms->o.pbuf = NULL;\n\tlen = (ms->c.len = 10) * sizeof(*ms->c.li);\n\n\tif ((ms->c.li = CAST(struct level_info *, malloc(len))) == NULL)\n\t\tgoto free;\n\n\tms->event_flags = 0;\n\tms->error = -1;\n\tfor (i = 0; i < MAGIC_SETS; i++)\n\t\tms->mlist[i] = NULL;\n\tms->file = \"unknown\";\n\tms->line = 0;\n\tms->indir_max = FILE_INDIR_MAX;\n\tms->name_max = FILE_NAME_MAX;\n\tms->elf_shnum_max = FILE_ELF_SHNUM_MAX;\n\tms->elf_phnum_max = FILE_ELF_PHNUM_MAX;\n\tms->elf_notes_max = FILE_ELF_NOTES_MAX;\n\treturn ms;\nfree:\n\tfree(ms);\n\treturn NULL;\n}",
        "output": "0",
        "idx": 6119
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "snmp_ber_decode_integer(unsigned char *buf, uint32_t *buff_len, uint32_t *num)\n{\n  uint8_t i, len, type;\n\n  buf = snmp_ber_decode_type(buf, buff_len, &type);\n\n  if(buf == NULL || type != BER_DATA_TYPE_INTEGER) {\n    return NULL;\n  }\n\n  buf = snmp_ber_decode_length(buf, buff_len, &len);\n\n  if(buf == NULL || len > 4) {\n    return NULL;\n  }\n\n  if(*buff_len < len) {\n    return NULL;\n  }\n\n  *num = (uint32_t)(*buf++ & 0xFF);\n  (*buff_len)--;\n  for(i = 1; i < len; ++i) {\n    *num <<= 8;\n    *num |= (uint8_t)(*buf++ & 0xFF);\n    (*buff_len)--;\n  }\n\n  return buf;\n}",
        "output": "1",
        "idx": 7968
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "get_line_and_copy(linenr_T lnum, char_u *buf)\n{\n    char_u *line = ml_get(lnum);\n\n    vim_strncpy(buf, line, LSIZE - 1);\n    return buf;\n}",
        "output": "0",
        "idx": 8059
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void test_symlink(const char *path)\n{\n\tchar *d = strdupa(path), *tmpname;\n\td = dirname(d);\n\tsize_t len = strlen(path) + 30;\n\ttmpname = alloca(len);\n\tsnprintf(tmpname, len, \"%s/%d\", d, (int)getpid());\n\n\tif (symlink(tmpname, path) == 0) {\n\t\tfprintf(stderr, \"leak at symlink of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at symlink of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n\tif (symlink(path, tmpname) == 0) {\n\t\tfprintf(stderr, \"leak at symlink (2) of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at symlink (2) of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}",
        "output": "0",
        "idx": 7275
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fanout_release(struct sock *sk)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct packet_fanout *f;\n\n\tmutex_lock(&fanout_mutex);\n\tf = po->fanout;\n\tif (f) {\n\t\tpo->fanout = NULL;\n\n\t\tif (atomic_dec_and_test(&f->sk_ref)) {\n\t\t\tlist_del(&f->list);\n\t\t\tdev_remove_pack(&f->prot_hook);\n\t\t\tfanout_release_data(f);\n\t\t\tkfree(f);\n\t\t}\n\n\t\tif (po->rollover)\n\t\t\tkfree_rcu(po->rollover, rcu);\n\t}\n\tmutex_unlock(&fanout_mutex);\n}",
        "output": "0",
        "idx": 2159
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void tokenadd(struct jv_parser* p, char c) {\n  assert(p->tokenpos <= p->tokenlen);\n  if (p->tokenpos == p->tokenlen) {\n    p->tokenlen = p->tokenlen*2 + 256;\n    p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen);\n  }\n  assert(p->tokenpos < p->tokenlen);\n  p->tokenbuf[p->tokenpos++] = c;\n}",
        "output": "1",
        "idx": 5504
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void *hashtable_get(hashtable_t *hashtable, const char *key)\n{\n    pair_t *pair;\n    size_t hash;\n    bucket_t *bucket;\n\n    hash = hash_str(key);\n    bucket = &hashtable->buckets[hash & hashmask(hashtable->order)];\n\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return NULL;\n\n    return pair->value;\n}",
        "output": "0",
        "idx": 5977
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "handle_associated_event(struct cpu_hw_events *cpuc,\n\tint idx, struct perf_sample_data *data, struct pt_regs *regs)\n{\n\tstruct perf_event *event = cpuc->events[idx];\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tmipspmu_event_update(event, hwc, idx);\n\tdata->period = event->hw.last_period;\n\tif (!mipspmu_event_set_period(event, hwc, idx))\n\t\treturn;\n\n\tif (perf_event_overflow(event, 0, data, regs))\n\t\tmipspmu->disable_event(idx);\n}",
        "output": "1",
        "idx": 428
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static MprJson *queryRange(MprJson *obj, char *property, cchar *rest, MprJson *value, int flags)\n{\n    MprJson     *child, *result;\n    ssize       start, end;\n    char        *e, *s, ibuf[16];\n    int         index;\n\n    result = mprCreateJson(MPR_JSON_ARRAY);\n    if (!(obj->type & MPR_JSON_ARRAY)) {\n        return result;\n    }\n    if ((s = stok(property, \": \\t\", &e)) == 0) {\n        return result;\n    }\n    start = (ssize) stoi(s);\n    end = (ssize) stoi(e);\n    if (start < 0) {\n        start = obj->length + start;\n    }\n    if (end < 0) {\n        end = obj->length + end;\n    }\n    for (ITERATE_JSON(obj, child, index)) {\n        if (index < start) continue;\n        if (index > end) break;\n        if (rest == 0) {\n            if (flags & MPR_JSON_REMOVE) {\n                appendItem(result, mprRemoveJsonChild(obj, child));\n            } else {\n                appendItem(result, queryLeaf(obj, itosbuf(ibuf, sizeof(ibuf), index, 10), value, flags));\n            }\n        } else {\n            appendItems(result, queryCore(child, rest, value, flags));\n        }\n    }\n    return result;\n}",
        "output": "0",
        "idx": 7077
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int xsave_state(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\n\talternative_input_2(\n\t\t\"1:\"XSAVE,\n\t\tXSAVEOPT,\n\t\tX86_FEATURE_XSAVEOPT,\n\t\tXSAVES,\n\t\tX86_FEATURE_XSAVES,\n\t\t[fx] \"D\" (fx), \"a\" (lmask), \"d\" (hmask) :\n\t\t\"memory\");\n\tasm volatile(\"2:\\n\\t\"\n\t\t     xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\n\treturn err;\n}",
        "output": "0",
        "idx": 3871
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __net_random_once_deferred(struct work_struct *w)\n{\n\tstruct __net_random_once_work *work =\n\t\tcontainer_of(w, struct __net_random_once_work, work);\n\tif (!static_key_enabled(work->key))\n\t\tstatic_key_slow_inc(work->key);\n\tkfree(work);\n}",
        "output": "1",
        "idx": 2570
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,\n\t\t\t\t\t\tint id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);\n\n\tif (IS_ERR(ipcp))\n\t\treturn ERR_CAST(ipcp);\n\n\treturn container_of(ipcp, struct sem_array, sem_perm);\n}",
        "output": "1",
        "idx": 2260
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\nbox = 0;\nout = 0;\n\treturn -1;\n}",
        "output": "1",
        "idx": 5442
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "local void init_block(s)\n    deflate_state *s;\n{\n    int n; \n\n    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;\n    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;\n    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;\n\n    s->dyn_ltree[END_BLOCK].Freq = 1;\n    s->opt_len = s->static_len = 0L;\n    s->last_lit = s->matches = 0;\n}",
        "output": "1",
        "idx": 6094
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)\n{\n\tint ret;\n\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,\n\t\t\t      indx, &data, 1, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}",
        "output": "1",
        "idx": 1454
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t  const struct isakmp_gen *ext,\n\t\t  u_int item_len _U_,\n\t\t  const u_char *ep,\n\t\t  uint32_t phase _U_, uint32_t doi _U_,\n\t\t  uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" n len=%u\", ntohs(e.len) - 4));\n\tif (ntohs(e.len) > 4) {\n\t\tif (ndo->ndo_vflag > 2) {\n\t\t\tND_PRINT((ndo, \" \"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\t\tgoto trunc;\n\t\t} else if (ndo->ndo_vflag > 1) {\n\t\t\tND_PRINT((ndo, \" \"));\n\t\t\tif (!ike_show_somedata(ndo, (const u_char *)(ext + 1), ep))\n\t\t\t\tgoto trunc;\n\t\t}\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\treturn NULL;\n}",
        "output": "0",
        "idx": 6601
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n\t\t       gss_ctx_id_t context_handle,\n\t\t       gss_buffer_t input_message_buffer,\n\t\t       gss_buffer_t input_assoc_buffer,\n\t\t       gss_buffer_t output_payload_buffer,\n\t\t       int *conf_state,\n\t\t       gss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_NO_CONTEXT);\n\n\tret = gss_unwrap_aead(minor_status,\n\t\t\t      sc->ctx_handle,\n\t\t\t      input_message_buffer,\n\t\t\t      input_assoc_buffer,\n\t\t\t      output_payload_buffer,\n\t\t\t      conf_state,\n\t\t\t      qop_state);\n\treturn (ret);\n}",
        "output": "0",
        "idx": 83
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char *jsi_GetHomeDir(Jsi_Interp *interp) {\n    const char *str = NULL;\n    if (interp->homeDir)\n        return interp->homeDir;\n#ifdef __WIN32\n    str = getenv(\"USERPROFILE\"); \n#else\n        \n    if ((str = getenv(\"HOME\")) == NULL) {\n        struct passwd pwd, *pw;\n        char buf[20000];\n        if (getpwuid_r(getuid(), &pwd, buf, sizeof(buf), &pw) == 0 && pw->pw_dir)        \n            str = pw->pw_dir;\n    }\n#endif\n    if (!str) {\n        Jsi_LogBug(\"no home dir\");\n        str = \"/\";\n    }\n#ifdef JSI_LITE_ONLY\n    return str;\n#else\n    return (interp->homeDir = Jsi_KeyAdd(interp, str));\n#endif\n}",
        "output": "1",
        "idx": 8186
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static av_cold int xpm_decode_close(AVCodecContext *avctx)\n{\n    XPMDecContext *x = avctx->priv_data;\n    av_freep(&x->pixels);\n\n    av_freep(&x->buf);\n    x->buf_size = 0;\n\n    return 0;\n}",
        "output": "0",
        "idx": 4867
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_pseudo_random(OM_uint32 *minor_status,\n\t\t\t gss_ctx_id_t context,\n\t\t\t int prf_key,\n\t\t\t const gss_buffer_t prf_in,\n\t\t\t ssize_t desired_output_len,\n\t\t\t gss_buffer_t prf_out)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context;\n\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_NO_CONTEXT);\n\n\tret = gss_pseudo_random(minor_status,\n\t\t\t\tsc->ctx_handle,\n\t\t\t\tprf_key,\n\t\t\t\tprf_in,\n\t\t\t\tdesired_output_len,\n\t\t\t\tprf_out);\n        return (ret);\n}",
        "output": "0",
        "idx": 95
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct ion_handle *ion_handle_get_by_id(struct ion_client *client,\n\t\t\t\t\t\tint id)\n{\n\tstruct ion_handle *handle;\n\n\tmutex_lock(&client->lock);\n\thandle = idr_find(&client->idr, id);\n\tif (handle)\n\t\tion_handle_get(handle);\n\tmutex_unlock(&client->lock);\n\n\treturn handle ? handle : ERR_PTR(-EINVAL);\n}",
        "output": "1",
        "idx": 1154
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC cchar *httpGetParam(HttpConn *conn, cchar *var, cchar *defaultValue)\n{\n    cchar       *value;\n\n    value = mprReadJson(httpGetParams(conn), var);\n    return (value) ? value : defaultValue;\n}",
        "output": "0",
        "idx": 6999
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tint i;\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));\n\tfor (i = 0; i < 3; i++)\n\t\tkvm_pit_load_count(kvm, i, ps->channels[i].count, 0);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn 0;\n}",
        "output": "0",
        "idx": 1481
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "netsnmp_mibindex_lookup( const char *dirname )\n{\n    int i;\n    static char tmpbuf[300];\n\n    for (i=0; i<_mibindex; i++) {\n        if ( _mibindexes[i] &&\n             strcmp( _mibindexes[i], dirname ) == 0) {\n             snprintf(tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes/%d\",\n                      get_persistent_directory(), i);\n             tmpbuf[sizeof(tmpbuf)-1] = 0;\n             DEBUGMSGTL((\"mibindex\", \"lookup: %s (%d) %s\\n\", dirname, i, tmpbuf ));\n             return tmpbuf;\n        }\n    }\n    DEBUGMSGTL((\"mibindex\", \"lookup: (none)\\n\"));\n    return NULL;\n}",
        "output": "1",
        "idx": 7798
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void free_pipe_info(struct pipe_inode_info *pipe)\n{\n\tint i;\n\n\taccount_pipe_buffers(pipe, pipe->buffers, 0);\n\tfree_uid(pipe->user);\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\t\tif (buf->ops)\n\t\t\tbuf->ops->release(pipe, buf);\n\t}\n\tif (pipe->tmp_page)\n\t\t__free_page(pipe->tmp_page);\n\tkfree(pipe->bufs);\n\tkfree(pipe);\n}",
        "output": "0",
        "idx": 1559
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateObject(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}",
        "output": "0",
        "idx": 8297
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void lxc_execute_bind_init(struct lxc_conf *conf)\n{\n\tint ret;\n\tchar path[PATH_MAX], destpath[PATH_MAX], *p;\n\n\tp = choose_init(conf->rootfs.mount);\n\tif (p) {\n\t\tfree(p);\n\t\treturn;\n\t}\n\n\tret = snprintf(path, PATH_MAX, SBINDIR \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long searching for lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(path)) {\n\t\tINFO(\"%s does not exist on host\", path);\n\t\treturn;\n\t}\n\n\tret = snprintf(destpath, PATH_MAX, \"%s%s\", conf->rootfs.mount, \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long for container's lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(destpath)) {\n\t\tFILE * pathfile = fopen(destpath, \"wb\");\n\t\tif (!pathfile) {\n\t\t\tSYSERROR(\"Failed to create mount target '%s'\", destpath);\n\t\t\treturn;\n\t\t}\n\t\tfclose(pathfile);\n\t}\n\n\tret = safe_mount(path, destpath, \"none\", MS_BIND, NULL, conf->rootfs.mount);\n\tif (ret < 0)\n\t\tSYSERROR(\"Failed to bind lxc.init.static into container\");\n\tINFO(\"lxc.init.static bound into container at %s\", path);\n}",
        "output": "0",
        "idx": 6045
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void write_version(\n    FILE       *fp,\n    const char *fname,\n    const char *dirname,\n    xref_t     *xref)\n{\n    long  start;\n    char *c, *new_fname, data;\n    FILE *new_fp;\n    \n    start = ftell(fp);\n\n    if ((c = strstr(fname, \".pdf\")))\n      *c = '\\0';\n    new_fname = malloc(strlen(fname) + strlen(dirname) + 16);\n    snprintf(new_fname, strlen(fname) + strlen(dirname) + 16,\n             \"%s/%s-version-%d.pdf\", dirname, fname, xref->version);\n\n    if (!(new_fp = fopen(new_fname, \"w\")))\n    {\n        ERR(\"Could not create file '%s'\\n\", new_fname);\n        fseek(fp, start, SEEK_SET);\n        free(new_fname);\n        return;\n    }\n    \n    fseek(fp, 0, SEEK_SET);\n    while (fread(&data, 1, 1, fp))\n      fwrite(&data, 1, 1, new_fp);\n\n    fprintf(new_fp, \"\\r\\nstartxref\\r\\n%ld\\r\\n%%%%EOF\", xref->start);\n\n    fclose(new_fp);\n    free(new_fname);\n    fseek(fp, start, SEEK_SET);\n}",
        "output": "1",
        "idx": 7466
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(locale_get_display_variant)\n{\n    get_icu_disp_value_src_php( LOC_VARIANT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}",
        "output": "0",
        "idx": 5405
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __init proc_root_init(void)\n{\n\tint err;\n\n\tproc_init_inodecache();\n\terr = register_filesystem(&proc_fs_type);\n\tif (err)\n\t\treturn;\n\terr = pid_ns_prepare_proc(&init_pid_ns);\n\tif (err) {\n\t\tunregister_filesystem(&proc_fs_type);\n\t\treturn;\n\t}\n\n\tproc_symlink(\"mounts\", NULL, \"self/mounts\");\n\n\tproc_net_init();\n\n#ifdef CONFIG_SYSVIPC\n\tproc_mkdir(\"sysvipc\", NULL);\n#endif\n\tproc_mkdir(\"fs\", NULL);\n\tproc_mkdir(\"driver\", NULL);\n\tproc_mkdir(\"fs/nfsd\", NULL); \n#if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE)\n\tproc_mkdir(\"openprom\", NULL);\n#endif\n\tproc_tty_init();\n#ifdef CONFIG_PROC_DEVICETREE\n\tproc_device_tree_init();\n#endif\n\tproc_mkdir(\"bus\", NULL);\n\tproc_sys_init();\n}",
        "output": "0",
        "idx": 835
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t\tunsigned int dataoff, unsigned int *timeouts)\n{\n\treturn nf_generic_should_process(nf_ct_protonum(ct));\n}",
        "output": "0",
        "idx": 3699
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void main_init() { \n#ifdef USE_SYSTEMD\n    int i;\n\n    systemd_fds=sd_listen_fds(1);\n    if(systemd_fds<0)\n        fatal(\"systemd initialization failed\");\n    listen_fds_start=SD_LISTEN_FDS_START;\n    for(i=0; i<systemd_fds; ++i)\n        set_nonblock(listen_fds_start+i, 1);\n#else\n    systemd_fds=0; \n    listen_fds_start=3; \n#endif\n    if(ssl_init()) \n        fatal(\"TLS initialization failed\");\n    if(sthreads_init()) \n        fatal(\"Threads initialization failed\");\n    options_defaults();\n    options_apply();\n#ifndef USE_FORK\n    get_limits(); \n#endif\n    fds=s_poll_alloc();\n    if(pipe_init(signal_pipe, \"signal_pipe\"))\n        fatal(\"Signal pipe initialization failed: \"\n            \"check your personal firewall\");\n    if(pipe_init(terminate_pipe, \"terminate_pipe\"))\n        fatal(\"Terminate pipe initialization failed: \"\n            \"check your personal firewall\");\n    stunnel_info(LOG_NOTICE);\n    if(systemd_fds>0)\n        s_log(LOG_INFO, \"Systemd socket activation: %d descriptors received\",\n            systemd_fds);\n}",
        "output": "1",
        "idx": 8466
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void voutf(struct GlobalConfig *config,\n                  const char *prefix,\n                  const char *fmt,\n                  va_list ap)\n{\n  size_t width = (79 - strlen(prefix));\n  if(!config->mute) {\n    size_t len;\n    char *ptr;\n    char *print_buffer;\n\n    print_buffer = curlx_mvaprintf(fmt, ap);\n    if(!print_buffer)\n      return;\n    len = strlen(print_buffer);\n\n    ptr = print_buffer;\n    while(len > 0) {\n      fputs(prefix, config->errors);\n\n      if(len > width) {\n        size_t cut = width-1;\n\n        while(!ISSPACE(ptr[cut]) && cut) {\n          cut--;\n        }\n        if(0 == cut)\n          cut = width-1;\n\n        (void)fwrite(ptr, cut + 1, 1, config->errors);\n        fputs(\"\\n\", config->errors);\n        ptr += cut + 1; \n        len -= cut;\n      }\n      else {\n        fputs(ptr, config->errors);\n        len = 0;\n      }\n    }\n    curl_free(print_buffer);\n  }\n}",
        "output": "1",
        "idx": 6038
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int command_read(struct pci_dev *dev, int offset, u16 *value, void *data)\n{\n\tint ret = pci_read_config_word(dev, offset, value);\n\tconst struct pci_cmd_info *cmd = data;\n\n\t*value &= PCI_COMMAND_GUEST;\n\t*value |= cmd->val & ~PCI_COMMAND_GUEST;\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 3883
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "qemuProcessHandleMonitorEOF(qemuMonitorPtr mon,\n                            virDomainObjPtr vm,\n                            void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv;\n    struct qemuProcessEvent *processEvent;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"Received EOF on %p '%s'\", vm, vm->def->name);\n\n    priv = vm->privateData;\n    if (priv->beingDestroyed) {\n        VIR_DEBUG(\"Domain is being destroyed, EOF is expected\");\n        goto cleanup;\n    }\n\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n\n    processEvent->eventType = QEMU_PROCESS_EVENT_MONITOR_EOF;\n    processEvent->vm = virObjectRef(vm);\n\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        qemuProcessEventFree(processEvent);\n        goto cleanup;\n    }\n\n    virObjectLock(mon);\n    qemuMonitorUnregister(mon);\n    virObjectUnlock(mon);\n\n    qemuDomainDestroyNamespace(driver, vm);\n\n cleanup:\n    virObjectUnlock(vm);\n}",
        "output": "0",
        "idx": 7889
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "init_syntax_once ()\n{\n   register int c;\n   static int done;\n\n   if (done)\n     return;\n\n   bzero (re_syntax_table, sizeof re_syntax_table);\n\n   for (c = 'a'; c <= 'z'; c++)\n     re_syntax_table[c] = Sword;\n\n   for (c = 'A'; c <= 'Z'; c++)\n     re_syntax_table[c] = Sword;\n\n   for (c = '0'; c <= '9'; c++)\n     re_syntax_table[c] = Sword;\n\n   re_syntax_table['_'] = Sword;\n\n   done = 1;\n}",
        "output": "1",
        "idx": 2
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char* ensure(printbuffer *p,int needed)\n{\n\tchar *newbuffer;int newsize;\n\tif (!p || !p->buffer) return 0;\n\tneeded+=p->offset;\n\tif (needed<=p->length) return p->buffer+p->offset;\n\n\tnewsize=pow2gt(needed);\n\tnewbuffer=(char*)cJSON_malloc(newsize);\n\tif (!newbuffer) {cJSON_free(p->buffer);p->length=0,p->buffer=0;return 0;}\n\tif (newbuffer) memcpy(newbuffer,p->buffer,p->length);\n\tcJSON_free(p->buffer);\n\tp->length=newsize;\n\tp->buffer=newbuffer;\n\treturn newbuffer+p->offset;\n}",
        "output": "0",
        "idx": 8331
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline ut16 r_read_at_le16(const void *src, size_t offset) {\n\tif (!src) {\n\t\treturn UT16_MAX;\n\t}\n\tconst ut8 *s = (const ut8*)src + offset;\n\treturn r_read_le16 (s);\n}",
        "output": "0",
        "idx": 8605
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "zend_function *spl_filesystem_object_get_method_check(zval **object_ptr, char *method, int method_len, const struct _zend_literal *key TSRMLS_DC) \n{\n\tspl_filesystem_object *fsobj = zend_object_store_get_object(*object_ptr TSRMLS_CC);\n\t\n\tif (fsobj->u.dir.entry.d_name[0] == '\\0' && fsobj->orig_path == NULL) {\n\t\tmethod = \"_bad_state_ex\";\n\t\tmethod_len = sizeof(\"_bad_state_ex\") - 1;\n\t\tkey = NULL;\n\t}\n\t\n\treturn zend_get_std_object_handlers()->get_method(object_ptr, method, method_len, key TSRMLS_CC);\n}",
        "output": "1",
        "idx": 4024
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void cipso_v4_sock_delattr(struct sock *sk)\n{\n\tint hdr_delta;\n\tstruct ip_options_rcu *opt;\n\tstruct inet_sock *sk_inet;\n\n\tsk_inet = inet_sk(sk);\n\topt = rcu_dereference_protected(sk_inet->inet_opt, 1);\n\tif (opt == NULL || opt->opt.cipso == 0)\n\t\treturn;\n\n\thdr_delta = cipso_v4_delopt(&sk_inet->inet_opt);\n\tif (sk_inet->is_icsk && hdr_delta > 0) {\n\t\tstruct inet_connection_sock *sk_conn = inet_csk(sk);\n\t\tsk_conn->icsk_ext_hdr_len -= hdr_delta;\n\t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n\t}\n}",
        "output": "0",
        "idx": 473
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_2read_into_buffer(CYTHON_UNUSED struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self) {\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  __Pyx_RefNannySetupContext(\"read_into_buffer\", 0);\n\n  __Pyx_Raise(__pyx_builtin_NotImplementedError, 0, 0, 0);\n  __PYX_ERR(0, 23, __pyx_L1_error)\n\n\n  __pyx_L1_error:;\n  __Pyx_AddTraceback(\"clickhouse_driver.bufferedreader.BufferedReader.read_into_buffer\", __pyx_clineno, __pyx_lineno, __pyx_filename);\n  __pyx_r = NULL;\n  __Pyx_XGIVEREF(__pyx_r);\n  __Pyx_RefNannyFinishContext();\n  return __pyx_r;\n}",
        "output": "1",
        "idx": 8304
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline int fpregs_state_valid(struct fpu *fpu, unsigned int cpu)\n{\n\treturn fpu == this_cpu_read_stable(fpu_fpregs_owner_ctx) && cpu == fpu->last_cpu;\n}",
        "output": "1",
        "idx": 3306
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ext4_xattr_put_super(struct super_block *sb)\n{\n\tmb_cache_shrink(sb->s_bdev);\n}",
        "output": "1",
        "idx": 1078
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "FunctionDef(identifier name, arguments_ty args, asdl_seq * body, asdl_seq *\n            decorator_list, expr_ty returns, int lineno, int col_offset, int\n            end_lineno, int end_col_offset, PyArena *arena)\n{\n    stmt_ty p;\n    if (!name) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field name is required for FunctionDef\");\n        return NULL;\n    }\n    if (!args) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field args is required for FunctionDef\");\n        return NULL;\n    }\n    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->kind = FunctionDef_kind;\n    p->v.FunctionDef.name = name;\n    p->v.FunctionDef.args = args;\n    p->v.FunctionDef.body = body;\n    p->v.FunctionDef.decorator_list = decorator_list;\n    p->v.FunctionDef.returns = returns;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    p->end_lineno = end_lineno;\n    p->end_col_offset = end_col_offset;\n    return p;\n}",
        "output": "1",
        "idx": 7180
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}",
        "output": "0",
        "idx": 8313
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void generateScaffold(int argc, char **argv)\n{\n    char    *plural;\n\n    if (argc < 1) {\n        usageError();\n        return;\n    }\n    if (getConfigValue(\"app.esp.generate.controller\", 0) == 0) {\n        fail(\"No suitable package installed to generate scaffolds\");\n        return;\n    }\n    app->controller = sclone(argv[0]);\n    if (!identifier(app->controller)) {\n        fail(\"Cannot generate scaffold. Controller name must be a valid C identifier\");\n        return;\n    }\n    stok(sclone(app->controller), \"-\", &plural);\n    if (plural) {\n        app->table = sjoin(app->controller, plural, NULL);\n    } else {\n        app->table = app->table ? app->table : app->controller;\n    }\n    generateScaffoldController(argc, argv);\n    generateClientController(argc, argv);\n    generateScaffoldViews(argc, argv);\n    generateClientModel(argc, argv);\n    generateScaffoldMigration(argc, argv);\n    migrate(0, 0);\n}",
        "output": "1",
        "idx": 4980
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int perf_swevent_add(struct perf_event *event, int flags)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct hlist_head *head;\n\n\tif (is_sampling_event(event)) {\n\t\thwc->last_period = hwc->sample_period;\n\t\tperf_swevent_set_period(event);\n\t}\n\n\thwc->state = !(flags & PERF_EF_START);\n\n\thead = find_swevent_head(swhash, event);\n\tif (WARN_ON_ONCE(!head))\n\t\treturn -EINVAL;\n\n\thlist_add_head_rcu(&event->hlist_entry, head);\n\tperf_event_update_userpage(event);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1495
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "R_API st64 r_buf_read_at(RBuffer *b, ut64 addr, ut8 *buf, ut64 len) {\n\tr_return_val_if_fail (b && buf, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\n\tr = r_buf_read (b, buf, len);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}",
        "output": "1",
        "idx": 6490
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void enc624j600WritePhyReg(NetInterface *interface, uint8_t address,\n   uint16_t data)\n{\n   enc624j600WriteReg(interface, ENC624J600_REG_MIREGADR, MIREGADR_R8 | address);\n   enc624j600WriteReg(interface, ENC624J600_REG_MIWR, data);\n\n   while((enc624j600ReadReg(interface, ENC624J600_REG_MISTAT) & MISTAT_BUSY) != 0)\n   {\n   }\n}",
        "output": "1",
        "idx": 8554
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "obj2ast_withitem(PyObject* obj, withitem_ty* out, PyArena* arena)\n{\n    PyObject* tmp = NULL;\n    expr_ty context_expr;\n    expr_ty optional_vars;\n\n    if (_PyObject_HasAttrId(obj, &PyId_context_expr)) {\n        int res;\n        tmp = _PyObject_GetAttrId(obj, &PyId_context_expr);\n        if (tmp == NULL) goto failed;\n        res = obj2ast_expr(tmp, &context_expr, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    } else {\n        PyErr_SetString(PyExc_TypeError, \"required field \\\"context_expr\\\" missing from withitem\");\n        return 1;\n    }\n    if (exists_not_none(obj, &PyId_optional_vars)) {\n        int res;\n        tmp = _PyObject_GetAttrId(obj, &PyId_optional_vars);\n        if (tmp == NULL) goto failed;\n        res = obj2ast_expr(tmp, &optional_vars, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    } else {\n        optional_vars = NULL;\n    }\n    *out = withitem(context_expr, optional_vars, arena);\n    return 0;\nfailed:\n    Py_XDECREF(tmp);\n    return 1;\n}",
        "output": "1",
        "idx": 7718
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static grub_err_t read_foo (struct grub_disk *disk, grub_disk_addr_t sector, grub_size_t size, char *buf) {\n\tif (!disk) {\n\t\teprintf (\"oops. no disk\\n\");\n\t\treturn 1;\n\t}\n\tconst int blocksize = 512; \n\tRIOBind *iob = disk->data;\n\tif (bio) {\n\t\tiob = bio;\n\t}\n\tif (iob->read_at (iob->io, delta+(blocksize*sector), (ut8*)buf, size*blocksize) == -1) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 8659
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int af9005_identify_state(struct usb_device *udev,\n\t\t\t\t struct dvb_usb_device_properties *props,\n\t\t\t\t struct dvb_usb_device_description **desc,\n\t\t\t\t int *cold)\n{\n\tint ret;\n\tu8 reply, *buf;\n\n\tbuf = kmalloc(FW_BULKOUT_SIZE + 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = af9005_boot_packet(udev, FW_CONFIG, &reply,\n\t\t\t\t buf, FW_BULKOUT_SIZE + 2);\n\tif (ret)\n\t\tgoto err;\n\tdeb_info(\"result of FW_CONFIG in identify state %d\\n\", reply);\n\tif (reply == 0x01)\n\t\t*cold = 1;\n\telse if (reply == 0x02)\n\t\t*cold = 0;\n\telse\n\t\tret = -EIO;\n\tif (!ret)\n\t\tdeb_info(\"Identify state cold = %d\\n\", *cold);\n\nerr:\n\tkfree(buf);\n\treturn ret;\n}",
        "output": "0",
        "idx": 4567
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void keyring_describe(const struct key *keyring, struct seq_file *m)\n{\n\tif (keyring->description)\n\t\tseq_puts(m, keyring->description);\n\telse\n\t\tseq_puts(m, \"[anon]\");\n\n\tif (key_is_instantiated(keyring)) {\n\t\tif (keyring->keys.nr_leaves_on_tree != 0)\n\t\t\tseq_printf(m, \": %lu\", keyring->keys.nr_leaves_on_tree);\n\t\telse\n\t\t\tseq_puts(m, \": empty\");\n\t}\n}",
        "output": "1",
        "idx": 1732
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "f_settabvar(typval_T *argvars, typval_T *rettv)\n{\n    tabpage_T\t*save_curtab;\n    tabpage_T\t*tp;\n    char_u\t*varname, *tabvarname;\n    typval_T\t*varp;\n\n    rettv->vval.v_number = 0;\n\n    if (check_restricted() || check_secure())\n\treturn;\n\n    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));\n    varname = tv_get_string_chk(&argvars[1]);\n    varp = &argvars[2];\n\n    if (varname != NULL && varp != NULL && tp != NULL)\n    {\n\tsave_curtab = curtab;\n\tgoto_tabpage_tp(tp, FALSE, FALSE);\n\n\ttabvarname = alloc((unsigned)STRLEN(varname) + 3);\n\tif (tabvarname != NULL)\n\t{\n\t    STRCPY(tabvarname, \"t:\");\n\t    STRCPY(tabvarname + 2, varname);\n\t    set_var(tabvarname, varp, TRUE);\n\t    vim_free(tabvarname);\n\t}\n\n\tif (valid_tabpage(save_curtab))\n\t    goto_tabpage_tp(save_curtab, FALSE, FALSE);\n    }\n}",
        "output": "1",
        "idx": 5848
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int cp2112_gpio_get_all(struct gpio_chip *chip)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\n\tmutex_lock(&dev->lock);\n\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,\n\t\t\t\t CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_GET_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO values: %d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto exit;\n\t}\n\n\tret = buf[1];\n\nexit:\n\tmutex_unlock(&dev->lock);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 2111
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static pdf_creator_t *new_creator(int *n_elements)\n{\n    pdf_creator_t *daddy;\n\n    static const pdf_creator_t creator_template[] = \n    {\n        {\"Title\",        \"\"},\n        {\"Author\",       \"\"},\n        {\"Subject\",      \"\"},\n        {\"Keywords\",     \"\"},\n        {\"Creator\",      \"\"},\n        {\"Producer\",     \"\"},\n        {\"CreationDate\", \"\"},\n        {\"ModDate\",      \"\"},\n        {\"Trapped\",      \"\"},\n    };\n\n    daddy = malloc(sizeof(creator_template));\n    memcpy(daddy, creator_template, sizeof(creator_template));\n\n    if (n_elements)\n      *n_elements = sizeof(creator_template) / sizeof(creator_template[0]);\n\n    return daddy;\n}",
        "output": "1",
        "idx": 7468
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void sanitize_dead_code(struct bpf_verifier_env *env)\n{\n\tstruct bpf_insn_aux_data *aux_data = env->insn_aux_data;\n\tstruct bpf_insn nop = BPF_MOV64_REG(BPF_REG_0, BPF_REG_0);\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tconst int insn_cnt = env->prog->len;\n\tint i;\n\n\tfor (i = 0; i < insn_cnt; i++) {\n\t\tif (aux_data[i].seen)\n\t\t\tcontinue;\n\t\tmemcpy(insn + i, &nop, sizeof(nop));\n\t}\n}",
        "output": "0",
        "idx": 2567
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static size_t consume_init_expr (ut8 *buf, ut8 *max, ut8 eoc, void *out, ut32 *offset) {\n\tut32 i = 0;\n\twhile (buf + i < max && buf[i] != eoc) {\n\t\ti++;\n\t}\n\tif (buf[i] != eoc) {\n\t\treturn 0;\n\t}\n\tif (offset) {\n\t\t*offset += i + 1;\n\t}\n\treturn i + 1;\n}",
        "output": "0",
        "idx": 8629
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int mp_pack(lua_State *L) {\n    int nargs = lua_gettop(L);\n    int i;\n    mp_buf *buf;\n\n    if (nargs == 0)\n        return luaL_argerror(L, 0, \"MessagePack pack needs input.\");\n\n    if (!lua_checkstack(L, nargs))\n        return luaL_argerror(L, 0, \"Too many arguments for MessagePack pack.\");\n\n    buf = mp_buf_new(L);\n    for(i = 1; i <= nargs; i++) {\n        luaL_checkstack(L, 1, \"in function mp_check\");\n        lua_pushvalue(L, i);\n\n        mp_encode_lua_type(L,buf,0);\n\n        lua_pushlstring(L,(char*)buf->b,buf->len);\n\n        buf->free += buf->len;\n        buf->len = 0;\n    }\n    mp_buf_free(L, buf);\n\n    lua_concat(L, nargs);\n    return 1;\n}",
        "output": "0",
        "idx": 5103
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *transport)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 *fl6 = &transport->fl.u.ip6;\n\n\tpr_debug(\"%s: skb:%p, len:%d, src:%pI6 dst:%pI6\\n\", __func__, skb,\n\t\t skb->len, &fl6->saddr, &fl6->daddr);\n\n\tIP6_ECN_flow_xmit(sk, fl6->flowlabel);\n\n\tif (!(transport->param_flags & SPP_PMTUD_ENABLE))\n\t\tskb->local_df = 1;\n\n\tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);\n\n\treturn ip6_xmit(sk, skb, fl6, np->opt, np->tclass);\n}",
        "output": "0",
        "idx": 3305
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void uwbd_start(struct uwb_rc *rc)\n{\n\tstruct task_struct *task = kthread_run(uwbd, rc, \"uwbd\");\n\tif (IS_ERR(task)) {\n\t\trc->uwbd.task = NULL;\n\t\tprintk(KERN_ERR \"UWB: Cannot start management daemon; \"\n\t\t       \"UWB won't work\\n\");\n\t} else {\n\t\trc->uwbd.task = task;\n\t\trc->uwbd.pid = rc->uwbd.task->pid;\n\t}\n}",
        "output": "0",
        "idx": 2399
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main(int argc, char *argv[])\n{\n\tint ret;\n\tstruct lxc_lock *lock;\n\n\tlock = lxc_newlock(NULL, NULL);\n\tif (!lock) {\n\t\tfprintf(stderr, \"%d: failed to get unnamed lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tret = lxclock(lock, 0);\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to take unnamed lock (%d)\\n\", __LINE__, ret);\n\t\texit(1);\n\t}\n\n\tret = lxcunlock(lock);\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to put unnamed lock (%d)\\n\", __LINE__, ret);\n\t\texit(1);\n\t}\n\tlxc_putlock(lock);\n\n\tlock = lxc_newlock(\"/var/lib/lxc\", mycontainername);\n\tif (!lock) {\n\t\tfprintf(stderr, \"%d: failed to get lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tstruct stat sb;\n\tchar *pathname = RUNTIME_PATH \"/lxc/lock/var/lib/lxc/\";\n\tret = stat(pathname, &sb);\n\tif (ret != 0) {\n\t\tfprintf(stderr, \"%d: filename %s not created\\n\", __LINE__,\n\t\t\tpathname);\n\t\texit(1);\n\t}\n\tlxc_putlock(lock);\n\n\ttest_two_locks();\n\n\tfprintf(stderr, \"all tests passed\\n\");\n\n\texit(ret);\n}",
        "output": "0",
        "idx": 6021
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool new_idmap_permitted(const struct file *file, \n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, current_fsuid()))\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (gid_eq(gid, current_fsgid()))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\n\tif (ns_capable(ns->parent, cap_setid) &&\n\t    file_ns_capable(file, ns->parent, cap_setid))\n\t\treturn true;\n\n\treturn false;\n}",
        "output": "0",
        "idx": 1313
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tint phy_addr;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct mii_ioctl_data *miidata = if_mii(rq);\n\n\tphy_addr = np->phy_addr;\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tmiidata->phy_id = phy_addr;\n\t\tbreak;\n\tcase SIOCGMIIREG:\n\t\tmiidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);\n\t\tbreak;\n\tcase SIOCSMIIREG:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}",
        "output": "0",
        "idx": 929
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(FilesystemIterator, getFlags)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_LONG(intern->flags & (SPL_FILE_DIR_KEY_MODE_MASK | SPL_FILE_DIR_CURRENT_MODE_MASK | SPL_FILE_DIR_OTHERS_MASK));\n} ",
        "output": "0",
        "idx": 5579
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "count_new_keys(int n_key_data, krb5_key_data *key_data)\n{\n    int n;\n\n    for (n = 1; n < n_key_data; n++) {\n        if (key_data[n - 1].key_data_kvno != key_data[n].key_data_kvno)\n            return n;\n    }\n    return n_key_data;\n}",
        "output": "0",
        "idx": 17
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "rndr_quote(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tif (!text || !text->size)\n\t\treturn 0;\n\n\tBUFPUTSL(ob, \"<q>\");\n\tbufput(ob, text->data, text->size);\n\tBUFPUTSL(ob, \"</q>\");\n\n\treturn 1;\n}",
        "output": "1",
        "idx": 8258
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int opl3_load_patch(int dev, int format, const char __user *addr,\n\t\tint count, int pmgr_flag)\n{\n\tstruct sbi_instrument ins;\n\n\tif (count <sizeof(ins))\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Patch record too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&ins, addr, sizeof(ins)))\n\t\treturn -EFAULT;\n\n\tif (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR)\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Invalid instrument number %d\\n\", ins.channel);\n\t\treturn -EINVAL;\n\t}\n\tins.key = format;\n\n\treturn store_instr(ins.channel, &ins);\n}",
        "output": "0",
        "idx": 391
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx)\n{\n\tstruct xenvif *vif;\n\tstruct pending_tx_info *pending_tx_info;\n\tpending_ring_idx_t index;\n\n\tif (netbk->mmap_pages[pending_idx] == NULL)\n\t\treturn;\n\n\tpending_tx_info = &netbk->pending_tx_info[pending_idx];\n\n\tvif = pending_tx_info->vif;\n\n\tmake_tx_response(vif, &pending_tx_info->req, XEN_NETIF_RSP_OKAY);\n\n\tindex = pending_index(netbk->pending_prod++);\n\tnetbk->pending_ring[index] = pending_idx;\n\n\txenvif_put(vif);\n\n\tnetbk->mmap_pages[pending_idx]->mapping = 0;\n\tput_page(netbk->mmap_pages[pending_idx]);\n\tnetbk->mmap_pages[pending_idx] = NULL;\n}",
        "output": "1",
        "idx": 830
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "getlogin_r (name, name_len)\n     char *name;\n     size_t name_len;\n{\n  char tty_pathname[2 + 2 * NAME_MAX];\n  char *real_tty_path = tty_pathname;\n  int result = 0;\n  struct utmp *ut, line, buffer;\n\n  {\n    int d = __open (\"/dev/tty\", 0);\n    if (d < 0)\n      return errno;\n\n    result = __ttyname_r (d, real_tty_path, sizeof (tty_pathname));\n    (void) __close (d);\n\n    if (result != 0)\n      {\n\t__set_errno (result);\n\treturn result;\n      }\n  }\n\n  real_tty_path += 5;\t\t\n\n  __setutent ();\n  strncpy (line.ut_line, real_tty_path, sizeof line.ut_line);\n  if (__getutline_r (&line, &buffer, &ut) < 0)\n    {\n      if (errno == ESRCH)\n\tresult = ENOENT;\n      else\n\tresult = errno;\n    }\n  else\n    {\n      size_t needed = strlen (ut->ut_line) + 1;\n\n      if (needed < name_len)\n\t{\n\t  __set_errno (ERANGE);\n\t  result = ERANGE;\n\t}\n      else\n\t{\n\t  memcpy (name, ut->ut_line, needed);\n\t  result = 0;\n\t}\n    }\n  __endutent ();\n\n  return result;\n}",
        "output": "1",
        "idx": 4
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct net *get_net_ns_by_id(struct net *net, int id)\n{\n\tstruct net *peer;\n\n\tif (id < 0)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tspin_lock_bh(&net->nsid_lock);\n\tpeer = idr_find(&net->netns_ids, id);\n\tif (peer)\n\t\tpeer = maybe_get_net(peer);\n\tspin_unlock_bh(&net->nsid_lock);\n\trcu_read_unlock();\n\n\treturn peer;\n}",
        "output": "0",
        "idx": 2597
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(DirectoryIterator, key)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (intern->u.dir.dirp) {\n\t\tRETURN_LONG(intern->u.dir.index);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}",
        "output": "1",
        "idx": 3988
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct task_struct *dup_task_struct(struct task_struct *orig)\n{\n\tstruct task_struct *tsk;\n\tstruct thread_info *ti;\n\tunsigned long *stackend;\n\n\tint err;\n\n\tprepare_to_copy(orig);\n\n\ttsk = alloc_task_struct();\n\tif (!tsk)\n\t\treturn NULL;\n\n\tti = alloc_thread_info(tsk);\n\tif (!ti) {\n\t\tfree_task_struct(tsk);\n\t\treturn NULL;\n\t}\n\n \terr = arch_dup_task_struct(tsk, orig);\n\tif (err)\n\t\tgoto out;\n\n\ttsk->stack = ti;\n\n\terr = prop_local_init_single(&tsk->dirties);\n\tif (err)\n\t\tgoto out;\n\n\tsetup_thread_stack(tsk, orig);\n\tclear_user_return_notifier(tsk);\n\tclear_tsk_need_resched(tsk);\n\tstackend = end_of_stack(tsk);\n\t*stackend = STACK_END_MAGIC;\t\n\n#ifdef CONFIG_CC_STACKPROTECTOR\n\ttsk->stack_canary = get_random_int();\n#endif\n\n\tatomic_set(&tsk->usage,2);\n\tatomic_set(&tsk->fs_excl, 0);\n#ifdef CONFIG_BLK_DEV_IO_TRACE\n\ttsk->btrace_seq = 0;\n#endif\n\ttsk->splice_pipe = NULL;\n\n\taccount_kernel_stack(ti, 1);\n\n\treturn tsk;\n\nout:\n\tfree_thread_info(ti);\n\tfree_task_struct(tsk);\n\treturn NULL;\n}",
        "output": "0",
        "idx": 347
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_hash rhash;\n\tstruct shash_alg *salg = __crypto_shash_alg(alg);\n\n\tstrncpy(rhash.type, \"shash\", sizeof(rhash.type));\n\n\trhash.blocksize = alg->cra_blocksize;\n\trhash.digestsize = salg->digestsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_HASH,\n\t\t    sizeof(struct crypto_report_hash), &rhash))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
        "output": "0",
        "idx": 1191
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sysDescr_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_string(varbind, oid, CONTIKI_VERSION_STRING);\n}",
        "output": "1",
        "idx": 7934
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main(int argc, char **argv, char **envp)\n{\n#ifdef DYNLOAD\n    if (!uc_dyn_load(NULL, 0)) {\n        printf(\"Error dynamically loading shared library.\\n\");\n        printf(\"Please check that unicorn.dll/unicorn.so is available as well as\\n\");\n        printf(\"any other dependent dll/so files.\\n\");\n        printf(\"The easiest way is to place them in the same directory as this app.\\n\");\n        return 1;\n    }\n#endif\n    \n    test_arm();\n    printf(\"==========================\\n\");\n    test_thumb();\n\n#ifdef DYNLOAD\n    uc_dyn_free();\n#endif\n    \n    return 0;\n}",
        "output": "1",
        "idx": 8740
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cstrchr(char_u *s, int c)\n{\n    char_u\t*p;\n    int\t\tcc;\n\n    if (!rex.reg_ic || (!enc_utf8 && mb_char2len(c) > 1))\n\treturn vim_strchr(s, c);\n\n    if (enc_utf8 && c > 0x80)\n\tcc = utf_fold(c);\n    else\n\t if (MB_ISUPPER(c))\n\tcc = MB_TOLOWER(c);\n    else if (MB_ISLOWER(c))\n\tcc = MB_TOUPPER(c);\n    else\n\treturn vim_strchr(s, c);\n\n    if (has_mbyte)\n    {\n\tfor (p = s; *p != NUL; p += (*mb_ptr2len)(p))\n\t{\n\t    if (enc_utf8 && c > 0x80)\n\t    {\n\t\tif (utf_fold(utf_ptr2char(p)) == cc)\n\t\t    return p;\n\t    }\n\t    else if (*p == c || *p == cc)\n\t\treturn p;\n\t}\n    }\n    else\n\tfor (p = s; *p != NUL; ++p)\n\t    if (*p == c || *p == cc)\n\t\treturn p;\n\n    return NULL;\n}",
        "output": "1",
        "idx": 5806
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n  CallInfo *ci = L->ci;\n  const char *msg;\n  va_list argp;\n  luaC_checkGC(L);  \n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);  \n  va_end(argp);\n  if (isLua(ci))  \n    luaG_addinfo(L, msg, ci_func(ci)->p->source, getcurrentline(ci));\n  luaG_errormsg(L);\n}",
        "output": "1",
        "idx": 8118
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "raptor_libxml_resolveEntity(void* user_data, \n                            const xmlChar *publicId, const xmlChar *systemId) {\n  raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  return libxml2_resolveEntity(sax2->xc, publicId, systemId);\n}",
        "output": "1",
        "idx": 3598
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __init clear_bss(void)\n{\n\tmemset(__bss_start, 0,\n\t       (unsigned long) __bss_stop - (unsigned long) __bss_start);\n}",
        "output": "0",
        "idx": 2971
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void start_cfs_bandwidth(struct cfs_bandwidth *cfs_b)\n{\n\tu64 overrun;\n\n\tlockdep_assert_held(&cfs_b->lock);\n\n\tif (cfs_b->period_active)\n\t\treturn;\n\n\tcfs_b->period_active = 1;\n\toverrun = hrtimer_forward_now(&cfs_b->period_timer, cfs_b->period);\n\tcfs_b->runtime_expires += (overrun + 1) * ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n\thrtimer_start_expires(&cfs_b->period_timer, HRTIMER_MODE_ABS_PINNED);\n}",
        "output": "1",
        "idx": 3232
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "dbcs_ptr2len(\n    char_u\t*p)\n{\n    int\t\tlen;\n\n    len = MB_BYTE2LEN(*p);\n    if (len == 2 && p[1] == NUL)\n\tlen = 1;\n    return len;\n}",
        "output": "1",
        "idx": 5814
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xen_irq_lateeoi_locked(struct irq_info *info)\n{\n\tevtchn_port_t evtchn;\n\tunsigned int cpu;\n\n\tevtchn = info->evtchn;\n\tif (!VALID_EVTCHN(evtchn) || !list_empty(&info->eoi_list))\n\t\treturn;\n\n\tcpu = info->eoi_cpu;\n\tif (info->eoi_time && info->irq_epoch == per_cpu(irq_epoch, cpu)) {\n\t\tlateeoi_list_add(info);\n\t\treturn;\n\t}\n\n\tinfo->eoi_time = 0;\n\tunmask_evtchn(evtchn);\n}",
        "output": "0",
        "idx": 2729
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void php_mb_regex_free_cache(php_mb_regex_t **pre)\n{\n\tonig_free(*pre);\n}",
        "output": "0",
        "idx": 5603
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hns_xgmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ARRAY_SIZE(g_xgmac_stats_string);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 1572
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iakerb_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n                       int iov_count)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_get_mic_iov(minor_status, ctx->gssc, qop_req, iov,\n                                iov_count);\n}",
        "output": "0",
        "idx": 151
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct page *alloc_huge_page(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long addr, int avoid_reserve)\n{\n\tstruct hugepage_subpool *spool = subpool_vma(vma);\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct page *page;\n\tlong chg;\n\n\tchg = vma_needs_reservation(h, vma, addr);\n\tif (chg < 0)\n\t\treturn ERR_PTR(-VM_FAULT_OOM);\n\tif (chg)\n\t\tif (hugepage_subpool_get_pages(spool, chg))\n\t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n\n\tspin_lock(&hugetlb_lock);\n\tpage = dequeue_huge_page_vma(h, vma, addr, avoid_reserve);\n\tspin_unlock(&hugetlb_lock);\n\n\tif (!page) {\n\t\tpage = alloc_buddy_huge_page(h, NUMA_NO_NODE);\n\t\tif (!page) {\n\t\t\thugepage_subpool_put_pages(spool, chg);\n\t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n\t\t}\n\t}\n\n\tset_page_private(page, (unsigned long)spool);\n\n\tvma_commit_reservation(h, vma, addr);\n\n\treturn page;\n}",
        "output": "0",
        "idx": 905
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int mpeg4video_probe(AVProbeData *probe_packet)\n{\n    uint32_t temp_buffer = -1;\n    int VO = 0, VOL = 0, VOP = 0, VISO = 0, res = 0;\n    int i;\n\n    for (i = 0; i < probe_packet->buf_size; i++) {\n        temp_buffer = (temp_buffer << 8) + probe_packet->buf[i];\n        if (temp_buffer & 0xfffffe00)\n            continue;\n        if (temp_buffer < 2)\n            continue;\n\n        if (temp_buffer == VOP_START_CODE)\n            VOP++;\n        else if (temp_buffer == VISUAL_OBJECT_START_CODE)\n            VISO++;\n        else if (temp_buffer >= 0x100 && temp_buffer < 0x120)\n            VO++;\n        else if (temp_buffer >= 0x120 && temp_buffer < 0x130)\n            VOL++;\n        else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) &&\n                 !(0x1B9 < temp_buffer && temp_buffer < 0x1C4))\n            res++;\n    }\n\n    if (VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0)\n        return AVPROBE_SCORE_EXTENSION;\n    return 0;\n}",
        "output": "0",
        "idx": 8513
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "unsigned int munlock_vma_page(struct page *page)\n{\n\tunsigned int nr_pages;\n\tstruct zone *zone = page_zone(page);\n\n\tBUG_ON(!PageLocked(page));\n\n\tspin_lock_irq(&zone->lru_lock);\n\n\tnr_pages = hpage_nr_pages(page);\n\tif (!TestClearPageMlocked(page))\n\t\tgoto unlock_out;\n\n\t__mod_zone_page_state(zone, NR_MLOCK, -nr_pages);\n\n\tif (__munlock_isolate_lru_page(page, true)) {\n\t\tspin_unlock_irq(&zone->lru_lock);\n\t\t__munlock_isolated_page(page);\n\t\tgoto out;\n\t}\n\t__munlock_isolation_failed(page);\n\nunlock_out:\n\tspin_unlock_irq(&zone->lru_lock);\n\nout:\n\treturn nr_pages - 1;\n}",
        "output": "0",
        "idx": 3497
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static pfunc check_literal(struct jv_parser* p) {\n  if (p->tokenpos == 0) return 0;\n\n  const char* pattern = 0;\n  int plen;\n  jv v;\n  switch (p->tokenbuf[0]) {\n  case 't': pattern = \"true\"; plen = 4; v = jv_true(); break;\n  case 'f': pattern = \"false\"; plen = 5; v = jv_false(); break;\n  case 'n': pattern = \"null\"; plen = 4; v = jv_null(); break;\n  }\n  if (pattern) {\n    if (p->tokenpos != plen) return \"Invalid literal\";\n    for (int i=0; i<plen; i++)\n      if (p->tokenbuf[i] != pattern[i])\n        return \"Invalid literal\";\n    TRY(value(p, v));\n  } else {\n    p->tokenbuf[p->tokenpos] = 0;\n    char* end = 0;\n    double d = jvp_strtod(&p->dtoa, p->tokenbuf, &end);\n    if (end == 0 || *end != 0)\n      return \"Invalid numeric literal\";\n    TRY(value(p, jv_number(d)));\n  }\n  p->tokenpos = 0;\n  return 0;\n}",
        "output": "0",
        "idx": 7715
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int hns_ppe_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)\n\t\treturn ETH_PPE_STATIC_NUM;\n\treturn 0;\n}",
        "output": "0",
        "idx": 2267
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __inline__ int scm_check_creds(struct ucred *creds)\n{\n\tconst struct cred *cred = current_cred();\n\tkuid_t uid = make_kuid(cred->user_ns, creds->uid);\n\tkgid_t gid = make_kgid(cred->user_ns, creds->gid);\n\n\tif (!uid_valid(uid) || !gid_valid(gid))\n\t\treturn -EINVAL;\n\n\tif ((creds->pid == task_tgid_vnr(current) ||\n\t     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&\n\t    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||\n\t      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&\n\t    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||\n\t      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {\n\t       return 0;\n\t}\n\treturn -EPERM;\n}",
        "output": "0",
        "idx": 1239
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int open_if_safe(int dirfd, const char *nextpath)\n{\n\tint newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);\n\tif (newfd >= 0) \n\t\treturn newfd;\n\n\tif (errno == ELOOP)\n\t\treturn newfd;\n\n\tif (errno == EPERM || errno == EACCES) {\n\t\tnewfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);\n\t\tif (newfd >= 0) {\n\t\t\tint ret = check_symlink(newfd);\n\t\t\tif (ret < 0) {\n\t\t\t\tclose(newfd);\n\t\t\t\tnewfd = ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newfd;\n}",
        "output": "0",
        "idx": 6057
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "struct vfsmount *collect_mounts(struct path *path)\n{\n\tstruct mount *tree;\n\tnamespace_lock();\n\ttree = copy_tree(real_mount(path->mnt), path->dentry,\n\t\t\t CL_COPY_ALL | CL_PRIVATE);\n\tnamespace_unlock();\n\tif (IS_ERR(tree))\n\t\treturn ERR_CAST(tree);\n\treturn &tree->mnt;\n}",
        "output": "1",
        "idx": 2814
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_1_6_dummy(kadm5_principal_ent_t entry, long mask,\n                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)\n{\n    int i;\n    char *password = *passptr;\n\n    if (password == NULL || !(mask & KADM5_ATTRIBUTES) ||\n        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))\n        return;\n\n    for (i = 0; (unsigned char) password[i] == i + 1; i++);\n    if (password[i] != '\\0' || i != 255)\n        return;\n\n    *passptr = NULL;\n}",
        "output": "0",
        "idx": 11
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "f_luaeval(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n\n    if (check_restricted() || check_secure())\n\treturn;\n\n    str = tv_get_string_buf(&argvars[0], buf);\n    do_luaeval(str, argvars + 1, rettv);\n}",
        "output": "0",
        "idx": 8169
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\tuint8_t value;\n\n\tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t0, reg, &value, 1, 1000);\n\treturn ret >= 0 ? value : ret;\n}",
        "output": "1",
        "idx": 1420
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "sf_open\t(const char *path, int mode, SF_INFO *sfinfo)\n{\tSF_PRIVATE \t*psf ;\n\n\tassert (sizeof (sf_count_t) == 8) ;\n\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;\n\n\tpsf_log_printf (psf, \"File : %s\\n\", path) ;\n\n\tif (copy_filename (psf, path) != 0)\n\t{\tsf_errno = psf->error ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf->file.mode = mode ;\n\tif (strcmp (path, \"-\") == 0)\n\t\tpsf->error = psf_set_stdio (psf) ;\n\telse\n\t\tpsf->error = psf_fopen (psf) ;\n\n\treturn psf_open_file (psf, sfinfo) ;\n} ",
        "output": "1",
        "idx": 4952
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *strdup(const char *s1)\n{\n\tchar *s2 = 0;\n\tif (s1) {\n\t\tsize_t len = strlen(s1) + 1;\n\t\ts2 = malloc(len);\n\t\tmemcpy(s2, s1, len);\n\t}\n\treturn s2;\n}",
        "output": "0",
        "idx": 7215
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "FstringParser_Finish(FstringParser *state, struct compiling *c,\n                     const node *n)\n{\n    asdl_seq *seq;\n\n    FstringParser_check_invariants(state);\n\n    if(state->expr_list.size == 0) {\n        if (!state->last_str) {\n            state->last_str = PyUnicode_FromStringAndSize(NULL, 0);\n            if (!state->last_str)\n                goto error;\n        }\n        return make_str_node_and_del(&state->last_str, c, n);\n    }\n\n    if (state->last_str) {\n        expr_ty str = make_str_node_and_del(&state->last_str, c, n);\n        if (!str || ExprList_Append(&state->expr_list, str) < 0)\n            goto error;\n    }\n    assert(state->last_str == NULL);\n\n    seq = ExprList_Finish(&state->expr_list, c->c_arena);\n    if (!seq)\n        goto error;\n\n    if (seq->size == 1)\n        return seq->elements[0];\n\n    return JoinedStr(seq, LINENO(n), n->n_col_offset, c->c_arena);\n\nerror:\n    FstringParser_Dealloc(state);\n    return NULL;\n}",
        "output": "1",
        "idx": 7776
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "COMPAT_SYSCALL_DEFINE6(mbind, compat_ulong_t, start, compat_ulong_t, len,\n\t\t       compat_ulong_t, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode, compat_ulong_t, flags)\n{\n\tlong err = 0;\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tnodemask_t bm;\n\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\n\tif (nmask) {\n\t\terr = compat_get_bitmap(nodes_addr(bm), nmask, nr_bits);\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\terr |= copy_to_user(nm, nodes_addr(bm), alloc_size);\n\t}\n\n\tif (err)\n\t\treturn -EFAULT;\n\n\treturn sys_mbind(start, len, mode, nm, nr_bits+1, flags);\n}",
        "output": "1",
        "idx": 1544
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void __exit exit_ext2_fs(void)\n{\n\tunregister_filesystem(&ext2_fs_type);\n\tdestroy_inodecache();\n\texit_ext2_xattr();\n}",
        "output": "1",
        "idx": 1100
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static CYTHON_INLINE PyObject* __Pyx_decode_c_string(\n         const char* cstring, Py_ssize_t start, Py_ssize_t stop,\n         const char* encoding, const char* errors,\n         PyObject* (*decode_func)(const char *s, Py_ssize_t size, const char *errors)) {\n    Py_ssize_t length;\n    if (unlikely((start < 0) | (stop < 0))) {\n        size_t slen = strlen(cstring);\n        if (unlikely(slen > (size_t) PY_SSIZE_T_MAX)) {\n            PyErr_SetString(PyExc_OverflowError,\n                            \"c-string too long to convert to Python\");\n            return NULL;\n        }\n        length = (Py_ssize_t) slen;\n        if (start < 0) {\n            start += length;\n            if (start < 0)\n                start = 0;\n        }\n        if (stop < 0)\n            stop += length;\n    }\n    if (unlikely(stop <= start))\n        return PyUnicode_FromUnicode(NULL, 0);\n    length = stop - start;\n    cstring += start;\n    if (decode_func) {\n        return decode_func(cstring, length, errors);\n    } else {\n        return PyUnicode_Decode(cstring, length, encoding, errors);\n    }\n}",
        "output": "1",
        "idx": 8286
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileInfo, setInfoClass)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_class_entry *ce = spl_ce_SplFileInfo;\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling  TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n\t\tintern->info_class = ce;\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}",
        "output": "0",
        "idx": 5469
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "list_table_status(MYSQL *mysql,const char *db,const char *wild)\n{\n  char query[1024],*end;\n  MYSQL_RES *result;\n  MYSQL_ROW row;\n\n  end=strxmov(query,\"show table status from `\",db,\"`\",NullS);\n  if (wild && wild[0])\n    strxmov(end,\" like '\",wild,\"'\",NullS);\n  if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n  {\n    fprintf(stderr,\"%s: Cannot get status for db: %s, table: %s: %s\\n\",\n\t    my_progname,db,wild ? wild : \"\",mysql_error(mysql));\n    if (mysql_errno(mysql) == ER_PARSE_ERROR)\n      fprintf(stderr,\"This error probably means that your MySQL server doesn't support the\\n\\'show table status' command.\\n\");\n    return 1;\n  }\n\n  printf(\"Database: %s\",db);\n  if (wild)\n    printf(\"  Wildcard: %s\",wild);\n  putchar('\\n');\n\n  print_res_header(result);\n  while ((row=mysql_fetch_row(result)))\n    print_res_row(result,row);\n  print_res_top(result);\n  mysql_free_result(result);\n  return 0;\n}",
        "output": "1",
        "idx": 5244
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)\n{\n\tconst char *s = name;\n\n\twhile (1) {\n\t\tconst char *s0 = s;\n\t\tchar *dirname;\n\n\t\twhile (1) {\n\t\t\tif (*s == 0) {\n\t\t\t\tif (last && s != s0)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\treturn dir;\n\t\t\t}\n\t\t\tif (*s == '/')\n\t\t\t\tbreak;\n\t\t\ts++;\n\t\t}\n\n\t\tdirname = g_strndup (s0, s - s0);\n\t\twhile (*s == '/')\n\t\t\ts++;\n\n\t\tif (strcmp (dirname, \".\") != 0) {\n\t\t\tGsfInput *subdir =\n\t\t\t\tgsf_infile_child_by_name (GSF_INFILE (dir),\n\t\t\t\t\t\t\t  dirname);\n\t\t\tif (subdir) {\n\t\t\t\tdir = GSF_IS_INFILE_TAR (subdir)\n\t\t\t\t\t? GSF_INFILE_TAR (subdir)\n\t\t\t\t\t: dir;\n\t\t\t\tg_object_unref (subdir);\n\t\t\t} else\n\t\t\t\tdir = tar_create_dir (dir, dirname);\n\t\t}\n\n\t\tg_free (dirname);\n\t}\n}",
        "output": "0",
        "idx": 8563
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void opl3_setup_voice(int dev, int voice, int chn)\n{\n\tstruct channel_info *info =\n\t&synth_devs[dev]->chn_info[chn];\n\n\topl3_set_instr(dev, voice, info->pgm_num);\n\n\tdevc->voc[voice].bender = 0;\n\tdevc->voc[voice].bender_range = info->bender_range;\n\tdevc->voc[voice].volume = info->controllers[CTL_MAIN_VOLUME];\n\tdevc->voc[voice].panning = (info->controllers[CTL_PAN] * 2) - 128;\n}",
        "output": "1",
        "idx": 276
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main()\n{\n    gdImagePtr im, clone;\n    int style[] = {0, 0, 0};\n\n    im = gdImageCreate(8, 8);\n    gdImageSetStyle(im, style, sizeof(style)/sizeof(style[0]));\n\n    clone = gdImageClone(im);\n    gdTestAssert(clone != NULL);\n\n    gdTestAssert(clone->styleLength == im->styleLength);\n    gdTestAssert(clone->stylePos == im->stylePos);\n    gdTestAssert(!memcmp(clone->style, im->style, sizeof(style)/sizeof(style[0])));\n\n    gdImageDestroy(clone);\n    gdImageDestroy(im);\n\n    return gdNumFailures();\n}",
        "output": "0",
        "idx": 6233
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "smtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args,\n    const char *domain)\n{\n\tchar   *p, *e;\n\n\tif (line == NULL)\n\t\treturn (0);\n\n\tif (*line != '<')\n\t\treturn (0);\n\n\te = strchr(line, '>');\n\tif (e == NULL)\n\t\treturn (0);\n\t*e++ = '\\0';\n\twhile (*e == ' ')\n\t\te++;\n\t*args = e;\n\n\tif (!text_to_mailaddr(maddr, line + 1))\n\t\treturn (0);\n\n\tp = strchr(maddr->user, ':');\n\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\n\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\treturn (1);\n\n\tif (maddr->user[0] == '\\0' || !valid_localpart(maddr->user))\n\t\treturn (0);\n\n\tif (maddr->domain[0] == '\\0') {\n\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\tsizeof(maddr->domain));\n\t}\n\n\tif (!valid_domainpart(maddr->domain))\n\t\treturn (0);\n\n\treturn (1);\n}",
        "output": "0",
        "idx": 7815
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "win_goto(win_T *wp)\n{\n#ifdef FEAT_CONCEAL\n    win_T\t*owp = curwin;\n#endif\n\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (popup_is_popup(wp))\n    {\n\temsg(_(e_not_allowed_to_enter_popup_window));\n\treturn;\n    }\n#endif\n    if (text_or_buf_locked())\n    {\n\tbeep_flush();\n\treturn;\n    }\n\n    if (wp->w_buffer != curbuf)\n\treset_VIsual_and_resel();\n    else if (VIsual_active)\n\twp->w_cursor = curwin->w_cursor;\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n    win_enter(wp, TRUE);\n\n#ifdef FEAT_CONCEAL\n    if (win_valid(owp) && owp->w_p_cole > 0 && !msg_scrolled)\n\tredrawWinline(owp, owp->w_cursor.lnum);\n    if (curwin->w_p_cole > 0 && !msg_scrolled)\n\tneed_cursor_line_redraw = TRUE;\n#endif\n}",
        "output": "0",
        "idx": 8057
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void perf_event_task_sched_out(struct task_struct *task, struct task_struct *next)\n{\n\tperf_sw_event(PERF_COUNT_SW_CONTEXT_SWITCHES, 1, NULL, 0);\n\n\t__perf_event_task_sched_out(task, next);\n}",
        "output": "0",
        "idx": 671
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,\n\t\t\t\t int op_flag,\n\t\t\t\t unsigned int size,\n\t\t\t\t unsigned int __user *tlv)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tint change = 0;\n\tvoid *new_data;\n\n\tif (op_flag > 0) {\n\t\tif (size > 1024 * 128)\t\n\t\t\treturn -EINVAL;\n\n\t\tnew_data = memdup_user(tlv, size);\n\t\tif (IS_ERR(new_data))\n\t\t\treturn PTR_ERR(new_data);\n\t\tchange = ue->tlv_data_size != size;\n\t\tif (!change)\n\t\t\tchange = memcmp(ue->tlv_data, new_data, size);\n\t\tkfree(ue->tlv_data);\n\t\tue->tlv_data = new_data;\n\t\tue->tlv_data_size = size;\n\t} else {\n\t\tif (! ue->tlv_data_size || ! ue->tlv_data)\n\t\t\treturn -ENXIO;\n\t\tif (size < ue->tlv_data_size)\n\t\t\treturn -ENOSPC;\n\t\tif (copy_to_user(tlv, ue->tlv_data, ue->tlv_data_size))\n\t\t\treturn -EFAULT;\n\t}\n\treturn change;\n}",
        "output": "1",
        "idx": 2600
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(DirectoryIterator, valid)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_BOOL(intern->u.dir.entry.d_name[0] != '\\0');\n}",
        "output": "0",
        "idx": 5535
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void dwc3_gadget_giveback(struct dwc3_ep *dep, struct dwc3_request *req,\n\t\tint status)\n{\n\tstruct dwc3\t\t\t*dwc = dep->dwc;\n\n\tdwc3_gadget_del_and_unmap_request(dep, req, status);\n\n\tspin_unlock(&dwc->lock);\n\tusb_gadget_giveback_request(&dep->endpoint, &req->request);\n\tspin_lock(&dwc->lock);\n}",
        "output": "0",
        "idx": 4069
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "char *suhosin_encrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key TSRMLS_DC)\n{\n\tchar *buf, *buf2, *d, *d_url;\n\tint l;\n\n\tbuf = estrndup(name, name_len);\n\t\n\t\n\tname_len = php_url_decode(buf, name_len);\n\tnormalize_varname(buf);\n\tname_len = strlen(buf);\n\t\n\tif (SUHOSIN_G(cookie_plainlist)) {\n\t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {\nencrypt_return_plain:\n\t\t\tefree(buf);\n\t\t\treturn estrndup(value, value_len);\n\t\t}\n\t} else if (SUHOSIN_G(cookie_cryptlist)) {\n\t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {\n\t\t\tgoto encrypt_return_plain;\n\t\t}\n\t}\n\t\n\tbuf2 = estrndup(value, value_len);\n\t\n\tvalue_len = php_url_decode(buf2, value_len);\n\t\n\td = suhosin_encrypt_string(buf2, value_len, buf, name_len, key TSRMLS_CC);\n\td_url = php_url_encode(d, strlen(d), &l);\n\tefree(d);\n\tefree(buf);\n\tefree(buf2);\n\treturn d_url;\n}",
        "output": "0",
        "idx": 5045
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "const char *cJSON_GetErrorPtr(void) {return global_ep;}",
        "output": "0",
        "idx": 8255
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void acpi_ns_terminate(void)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ns_terminate);\n\n#ifdef ACPI_EXEC_APP\n\t{\n\t\tunion acpi_operand_object *prev;\n\t\tunion acpi_operand_object *next;\n\n\n\t\tnext = acpi_gbl_module_code_list;\n\t\twhile (next) {\n\t\t\tprev = next;\n\t\t\tnext = next->method.mutex;\n\t\t\tprev->method.mutex = NULL;\t\n\t\t\tacpi_ut_remove_reference(prev);\n\t\t}\n\t}\n#endif\n\n\tacpi_ns_delete_namespace_subtree(acpi_gbl_root_node);\n\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);\n\tif (ACPI_FAILURE(status)) {\n\t\treturn_VOID;\n\t}\n\n\tacpi_ns_delete_node(acpi_gbl_root_node);\n\t(void)acpi_ut_release_mutex(ACPI_MTX_NAMESPACE);\n\n\tACPI_DEBUG_PRINT((ACPI_DB_INFO, \"Namespace freed\\n\"));\n\treturn_VOID;\n}",
        "output": "1",
        "idx": 1564
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void kvm_unpin_pages(struct kvm *kvm, pfn_t pfn, unsigned long npages)\n{\n\tunsigned long i;\n\n\tfor (i = 0; i < npages; ++i)\n\t\tkvm_release_pfn_clean(pfn + i);\n}",
        "output": "0",
        "idx": 3627
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline __u32 dccp_v6_init_sequence(struct sk_buff *skb)\n{\n\treturn secure_dccpv6_sequence_number(ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\t\t     ipv6_hdr(skb)->saddr.s6_addr32,\n\t\t\t\t\t     dccp_hdr(skb)->dccph_dport,\n\t\t\t\t\t     dccp_hdr(skb)->dccph_sport     );\n\n}",
        "output": "1",
        "idx": 614
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void addReply(redisClient *c, robj *obj) {\n    if (_installWriteEvent(c) != REDIS_OK) return;\n    redisAssert(!server.ds_enabled || obj->storage == REDIS_VM_MEMORY);\n\n    if (obj->encoding == REDIS_ENCODING_RAW) {\n        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK)\n            _addReplyObjectToList(c,obj);\n    } else {\n        obj = getDecodedObject(obj);\n        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK)\n            _addReplyObjectToList(c,obj);\n        decrRefCount(obj);\n    }\n}",
        "output": "0",
        "idx": 5117
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void set_task_blockstep(struct task_struct *task, bool on)\n{\n\tunsigned long debugctl;\n\n\tlocal_irq_disable();\n\tdebugctl = get_debugctlmsr();\n\tif (on) {\n\t\tdebugctl |= DEBUGCTLMSR_BTF;\n\t\tset_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t} else {\n\t\tdebugctl &= ~DEBUGCTLMSR_BTF;\n\t\tclear_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t}\n\tif (task == current)\n\t\tupdate_debugctlmsr(debugctl);\n\tlocal_irq_enable();\n}",
        "output": "0",
        "idx": 1125
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline bool is_nmi(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK);\n}",
        "output": "0",
        "idx": 2053
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << NM_VECTOR) | (1u << DB_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (enable_ept)\n\t\teb &= ~(1u << PF_VECTOR); \n\tif (vcpu->fpu_active)\n\t\teb &= ~(1u << NM_VECTOR);\n\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}",
        "output": "1",
        "idx": 920
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)\n{\n\tunsigned long val;\n\tvoid *ptr = NULL;\n\n\tif (!atomic_pool) {\n\t\tWARN(1, \"coherent pool not initialised!\\n\");\n\t\treturn NULL;\n\t}\n\n\tval = gen_pool_alloc(atomic_pool, size);\n\tif (val) {\n\t\tphys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);\n\n\t\t*ret_page = phys_to_page(phys);\n\t\tptr = (void *)val;\n\t\tif (flags & __GFP_ZERO)\n\t\t\tmemset(ptr, 0, size);\n\t}\n\n\treturn ptr;\n}",
        "output": "1",
        "idx": 2850
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SPL_METHOD(SplFileObject, fread)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tlong length = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &length) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (length <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n\t\tRETURN_FALSE;\n\t}\n\tif (length > INT_MAX) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be no more than %d\", INT_MAX);\n\t\tRETURN_FALSE;\n\t}\n\n\tZ_STRVAL_P(return_value) = emalloc(length + 1);\n\tZ_STRLEN_P(return_value) = php_stream_read(intern->u.file.stream, Z_STRVAL_P(return_value), length);\n\n\tZ_STRVAL_P(return_value)[Z_STRLEN_P(return_value)] = 0;\n\tZ_TYPE_P(return_value) = IS_STRING;\n}",
        "output": "0",
        "idx": 5575
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int can_open_cached(struct nfs4_state *state, int mode)\n{\n\tint ret = 0;\n\tswitch (mode & (FMODE_READ|FMODE_WRITE|O_EXCL)) {\n\t\tcase FMODE_READ:\n\t\t\tret |= test_bit(NFS_O_RDONLY_STATE, &state->flags) != 0;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_WRONLY_STATE, &state->flags) != 0;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_RDWR_STATE, &state->flags) != 0;\n\t}\n\treturn ret;\n}",
        "output": "1",
        "idx": 2144
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "bool capable_wrt_inode_uidgid(const struct inode *inode, int cap)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\n\treturn ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid) &&\n\t\tkgid_has_mapping(ns, inode->i_gid);\n}",
        "output": "0",
        "idx": 3565
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int perf_event_overflow(struct perf_event *event,\n\t\t\t  struct perf_sample_data *data,\n\t\t\t  struct pt_regs *regs)\n{\n\treturn __perf_event_overflow(event, 1, data, regs);\n}",
        "output": "0",
        "idx": 679
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n\n\tpayload = NULL;\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\tret = key_update(key_ref, payload, plen);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkfree(payload);\nerror:\n\treturn ret;\n}",
        "output": "1",
        "idx": 1606
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int bpf_adj_branches(struct bpf_prog *prog, u32 pos, u32 delta,\n\t\t\t    const bool probe_pass)\n{\n\tu32 i, insn_cnt = prog->len + (probe_pass ? delta : 0);\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint ret = 0;\n\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tu8 code;\n\n\t\tif (probe_pass && i == pos) {\n\t\t\ti += delta + 1;\n\t\t\tinsn++;\n\t\t}\n\t\tcode = insn->code;\n\t\tif (BPF_CLASS(code) != BPF_JMP ||\n\t\t    BPF_OP(code) == BPF_EXIT)\n\t\t\tcontinue;\n\t\tif (BPF_OP(code) == BPF_CALL) {\n\t\t\tif (insn->src_reg != BPF_PSEUDO_CALL)\n\t\t\t\tcontinue;\n\t\t\tret = bpf_adj_delta_to_imm(insn, pos, delta, i,\n\t\t\t\t\t\t   probe_pass);\n\t\t} else {\n\t\t\tret = bpf_adj_delta_to_off(insn, pos, delta, i,\n\t\t\t\t\t\t   probe_pass);\n\t\t}\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 4087
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int xfrm_alloc_replay_state_esn(struct xfrm_replay_state_esn **replay_esn,\n\t\t\t\t       struct xfrm_replay_state_esn **preplay_esn,\n\t\t\t\t       struct nlattr *rta)\n{\n\tstruct xfrm_replay_state_esn *p, *pp, *up;\n\tint klen, ulen;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tup = nla_data(rta);\n\tklen = xfrm_replay_state_esn_len(up);\n\tulen = nla_len(rta) >= klen ? klen : sizeof(*up);\n\n\tp = kzalloc(klen, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpp = kzalloc(klen, GFP_KERNEL);\n\tif (!pp) {\n\t\tkfree(p);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(p, up, ulen);\n\tmemcpy(pp, up, ulen);\n\n\t*replay_esn = p;\n\t*preplay_esn = pp;\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 1063
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int assign_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct task_group *tg = cfs_rq->tg;\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(tg);\n\tu64 amount = 0, min_amount;\n\n\tmin_amount = sched_cfs_bandwidth_slice() - cfs_rq->runtime_remaining;\n\n\traw_spin_lock(&cfs_b->lock);\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\tamount = min_amount;\n\telse {\n\t\tstart_cfs_bandwidth(cfs_b);\n\n\t\tif (cfs_b->runtime > 0) {\n\t\t\tamount = min(cfs_b->runtime, min_amount);\n\t\t\tcfs_b->runtime -= amount;\n\t\t\tcfs_b->idle = 0;\n\t\t}\n\t}\n\traw_spin_unlock(&cfs_b->lock);\n\n\tcfs_rq->runtime_remaining += amount;\n\n\treturn cfs_rq->runtime_remaining > 0;\n}",
        "output": "0",
        "idx": 4445
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jpeg_error_handler(j_common_ptr)\n{\n  return;\n}",
        "output": "1",
        "idx": 8490
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cJSON *cJSON_CreateFloat( double num )\n{\n\tcJSON *item = cJSON_New_Item();\n\tif ( item ) {\n\t\titem->type = cJSON_Number;\n\t\titem->valuefloat = num;\n\t\titem->valueint = num;\n\t}\n\treturn item;\n}",
        "output": "1",
        "idx": 5872
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,\n                        const AVFrame *src, int field)\n{\n    int plane;\n    for (plane = 0; plane < 4 && src->data[plane] && src->linesize[plane]; plane++)\n        av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,\n                            src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,\n                            get_width(fm, src, plane), get_height(fm, src, plane) / 2);\n}",
        "output": "0",
        "idx": 4925
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "jp2_box_t *jp2_box_create0()\n{\n\tjp2_box_t *box;\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(box, 0, sizeof(jp2_box_t));\n\tbox->type = 0;\n\tbox->len = 0;\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\treturn box;\n}",
        "output": "0",
        "idx": 7613
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int hugepage_subpool_get_pages(struct hugepage_subpool *spool,\n\t\t\t\t      long delta)\n{\n\tint ret = 0;\n\n\tif (!spool)\n\t\treturn 0;\n\n\tspin_lock(&spool->lock);\n\tif ((spool->used_hpages + delta) <= spool->max_hpages) {\n\t\tspool->used_hpages += delta;\n\t} else {\n\t\tret = -ENOMEM;\n\t}\n\tspin_unlock(&spool->lock);\n\n\treturn ret;\n}",
        "output": "0",
        "idx": 901
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void __detach_mounts(struct dentry *dentry)\n{\n\tstruct mountpoint *mp;\n\tstruct mount *mnt;\n\n\tnamespace_lock();\n\tmp = lookup_mountpoint(dentry);\n\tif (!mp)\n\t\tgoto out_unlock;\n\n\tlock_mount_hash();\n\twhile (!hlist_empty(&mp->m_list)) {\n\t\tmnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);\n\t\tumount_tree(mnt, 0);\n\t}\n\tunlock_mount_hash();\n\tput_mountpoint(mp);\nout_unlock:\n\tnamespace_unlock();\n}",
        "output": "1",
        "idx": 2820
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_pickle_PicklerMemoProxy_copy_impl(PicklerMemoProxyObject *self)\n{\n    Py_ssize_t i;\n    PyMemoTable *memo;\n    PyObject *new_memo = PyDict_New();\n    if (new_memo == NULL)\n        return NULL;\n\n    memo = self->pickler->memo;\n    for (i = 0; i < memo->mt_allocated; ++i) {\n        PyMemoEntry entry = memo->mt_table[i];\n        if (entry.me_key != NULL) {\n            int status;\n            PyObject *key, *value;\n\n            key = PyLong_FromVoidPtr(entry.me_key);\n            value = Py_BuildValue(\"nO\", entry.me_value, entry.me_key);\n\n            if (key == NULL || value == NULL) {\n                Py_XDECREF(key);\n                Py_XDECREF(value);\n                goto error;\n            }\n            status = PyDict_SetItem(new_memo, key, value);\n            Py_DECREF(key);\n            Py_DECREF(value);\n            if (status < 0)\n                goto error;\n        }\n    }\n    return new_memo;\n\n  error:\n    Py_XDECREF(new_memo);\n    return NULL;\n}",
        "output": "1",
        "idx": 7158
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static pyc_object *get_set_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (set size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_SET;\n\treturn ret;\n}",
        "output": "1",
        "idx": 6444
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static __u8 *sp_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 112 && rdesc[104] == 0x26 && rdesc[105] == 0x80 &&\n\t\t\trdesc[106] == 0x03) {\n\t\thid_info(hdev, \"fixing up Sunplus Wireless Desktop report descriptor\\n\");\n\t\trdesc[105] = rdesc[110] = 0x03;\n\t\trdesc[106] = rdesc[111] = 0x21;\n\t}\n\treturn rdesc;\n}",
        "output": "0",
        "idx": 3655
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)\n{\n\tu32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size;\n\tint err;\n\n\tsmap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,\n\t\t\t\t\t smap->map.numa_node);\n\tif (!smap->elems)\n\t\treturn -ENOMEM;\n\n\terr = pcpu_freelist_init(&smap->freelist);\n\tif (err)\n\t\tgoto free_elems;\n\n\tpcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,\n\t\t\t       smap->map.max_entries);\n\treturn 0;\n\nfree_elems:\n\tbpf_map_area_free(smap->elems);\n\treturn err;\n}",
        "output": "1",
        "idx": 1996
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n{\n\tint n;\n\tint c;\n\tchar *bufptr;\n\n\tif (cnt < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_read\");\n\t}\n\n\tbufptr = buf;\n\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif ((c = jas_stream_getc(stream)) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t*bufptr++ = c;\n\t\t++n;\n\t}\n\n\treturn n;\n}",
        "output": "0",
        "idx": 7535
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static inline void tss_invalidate_io_bitmap(void)\n{\n\tPVOP_VCALL0(cpu.invalidate_io_bitmap);\n}",
        "output": "0",
        "idx": 2693
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseTarget(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    cchar   *name, *args;\n\n    if (prop->type & MPR_JSON_OBJ) {\n        name = mprGetJson(prop, \"operation\");\n        args = mprGetJson(prop, \"args\");\n    } else {\n        name = \"run\";\n        args = prop->value;\n    }\n    httpSetRouteTarget(route, name, args);\n}",
        "output": "1",
        "idx": 5044
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void parseContentKeep(HttpRoute *route, cchar *key, MprJson *prop)\n{\n    if (mprGetJson(prop, \"[@=c]\")) {\n        route->keepSource = 1;\n    }\n}",
        "output": "1",
        "idx": 5068
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int sqlite3CheckObjectName(\n  Parse *pParse,            \n  const char *zName,        \n  const char *zType,        \n  const char *zTblName      \n){\n  sqlite3 *db = pParse->db;\n  if( sqlite3WritableSchema(db) || db->init.imposterTable ){\n    return SQLITE_OK;\n  }\n  if( db->init.busy ){\n    if( sqlite3_stricmp(zType, db->init.azInit[0])\n     || sqlite3_stricmp(zName, db->init.azInit[1])\n     || sqlite3_stricmp(zTblName, db->init.azInit[2])\n    ){\n      if( sqlite3Config.bExtraSchemaChecks ){\n        sqlite3ErrorMsg(pParse, \"\"); \n        return SQLITE_ERROR;\n      }\n    }\n  }else{\n    if( pParse->nested==0 \n     && 0==sqlite3StrNICmp(zName, \"sqlite_\", 7)\n    ){\n      sqlite3ErrorMsg(pParse, \"object name reserved for internal use: %s\",\n                      zName);\n      return SQLITE_ERROR;\n    }\n  }\n  return SQLITE_OK;\n}",
        "output": "1",
        "idx": 7632
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int xmkstemp(char **tmpname, char *dir)\n{\n\tchar *localtmp;\n\tchar *tmpenv;\n\tmode_t old_mode;\n\tint fd, rc;\n\n\tif (dir != NULL)\n\t\ttmpenv = dir;\n\telse\n\t\ttmpenv = getenv(\"TMPDIR\");\n\n\tif (tmpenv)\n\t\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", tmpenv,\n\t\t\t  program_invocation_short_name);\n\telse\n\t\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", _PATH_TMP,\n\t\t\t  program_invocation_short_name);\n\n\tif (rc < 0)\n\t\treturn -1;\n\n\told_mode = umask(077);\n\tfd = mkostemp(localtmp, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);\n\tumask(old_mode);\n\tif (fd == -1) {\n\t\tfree(localtmp);\n\t\tlocaltmp = NULL;\n\t}\n\t*tmpname = localtmp;\n\treturn fd;\n}",
        "output": "1",
        "idx": 4650
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int encrypt(struct blkcipher_desc *desc,\n\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t   unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, 64);\n\n\tsalsa20_ivsetup(ctx, walk.iv);\n\n\tif (likely(walk.nbytes == nbytes))\n\t{\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr, nbytes);\n\t\treturn blkcipher_walk_done(desc, &walk, 0);\n\t}\n\n\twhile (walk.nbytes >= 64) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr,\n\t\t\t\t      walk.nbytes - (walk.nbytes % 64));\n\t\terr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\n\t}\n\n\tif (walk.nbytes) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr, walk.nbytes);\n\t\terr = blkcipher_walk_done(desc, &walk, 0);\n\t}\n\n\treturn err;\n}",
        "output": "1",
        "idx": 1778
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void ip4_datagram_release_cb(struct sock *sk)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct ip_options_rcu *inet_opt;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct dst_entry *dst;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\n\trcu_read_lock();\n\n\tdst = __sk_dst_get(sk);\n\tif (!dst || !dst->obsolete || dst->ops->check(dst, 0)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tinet_opt = rcu_dereference(inet->inet_opt);\n\tif (inet_opt && inet_opt->opt.srr)\n\t\tdaddr = inet_opt->opt.faddr;\n\trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n\t\t\t\t   inet->inet_saddr, inet->inet_dport,\n\t\t\t\t   inet->inet_sport, sk->sk_protocol,\n\t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n\n\tdst = !IS_ERR(rt) ? &rt->dst : NULL;\n\tsk_dst_set(sk, dst);\n\n\trcu_read_unlock();\n}",
        "output": "0",
        "idx": 3567
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cstrchr(char_u *s, int c)\n{\n    char_u\t*p;\n    int\t\tcc;\n\n    if (!rex.reg_ic || (!enc_utf8 && mb_char2len(c) > 1))\n\treturn vim_strchr(s, c);\n\n    if (enc_utf8 && c > 0x80)\n\tcc = utf_fold(c);\n    else\n\t if (MB_ISUPPER(c))\n\tcc = MB_TOLOWER(c);\n    else if (MB_ISLOWER(c))\n\tcc = MB_TOUPPER(c);\n    else\n\treturn vim_strchr(s, c);\n\n    if (has_mbyte)\n    {\n\tfor (p = s; *p != NUL; p += (*mb_ptr2len)(p))\n\t{\n\t    if (enc_utf8 && c > 0x80)\n\t    {\n\t\tint uc = utf_ptr2char(p);\n\n\t\tif ((uc < 0x80 || uc != *p) && utf_fold(uc) == cc)\n\t\t    return p;\n\t    }\n\t    else if (*p == c || *p == cc)\n\t\treturn p;\n\t}\n    }\n    else\n\tfor (p = s; *p != NUL; ++p)\n\t    if (*p == c || *p == cc)\n\t\treturn p;\n\n    return NULL;\n}",
        "output": "0",
        "idx": 8113
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void xen_invalidate_io_bitmap(void)\n{\n\tstruct physdev_set_iobitmap iobitmap = {\n\t\t.bitmap = 0,\n\t\t.nr_ports = 0,\n\t};\n\n\tnative_tss_invalidate_io_bitmap();\n\tHYPERVISOR_physdev_op(PHYSDEVOP_set_iobitmap, &iobitmap);\n}",
        "output": "0",
        "idx": 2699
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "num_stmts(const node *n)\n{\n    int i, l;\n    node *ch;\n\n    switch (TYPE(n)) {\n        case single_input:\n            if (TYPE(CHILD(n, 0)) == NEWLINE)\n                return 0;\n            else\n                return num_stmts(CHILD(n, 0));\n        case file_input:\n            l = 0;\n            for (i = 0; i < NCH(n); i++) {\n                ch = CHILD(n, i);\n                if (TYPE(ch) == stmt)\n                    l += num_stmts(ch);\n            }\n            return l;\n        case stmt:\n            return num_stmts(CHILD(n, 0));\n        case compound_stmt:\n            return 1;\n        case simple_stmt:\n            return NCH(n) / 2; \n        case suite:\n            if (NCH(n) == 1)\n                return num_stmts(CHILD(n, 0));\n            else {\n                l = 0;\n                for (i = 2; i < (NCH(n) - 1); i++)\n                    l += num_stmts(CHILD(n, i));\n                return l;\n            }\n        default: {\n            char buf[128];\n\n            sprintf(buf, \"Non-statement found: %d %d\",\n                    TYPE(n), NCH(n));\n            Py_FatalError(buf);\n        }\n    }\n    Py_UNREACHABLE();\n}",
        "output": "1",
        "idx": 7206
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void controloptions (lua_State *L, int opt, const char **fmt,\n                            Header *h) {\n  switch (opt) {\n    case  ' ': return;  \n    case '>': h->endian = BIG; return;\n    case '<': h->endian = LITTLE; return;\n    case '!': {\n      int a = getnum(L, fmt, MAXALIGN);\n      if (!isp2(a))\n        luaL_error(L, \"alignment %d is not a power of 2\", a);\n      h->align = a;\n      return;\n    }\n    default: {\n      const char *msg = lua_pushfstring(L, \"invalid format option '%c'\", opt);\n      luaL_argerror(L, 1, msg);\n    }\n  }\n}",
        "output": "1",
        "idx": 3648
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int kvaser_usb_leaf_flush_queue(struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->id = CMD_FLUSH_QUEUE;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_flush_queue);\n\tcmd->u.flush_queue.channel = priv->channel;\n\tcmd->u.flush_queue.flags = 0x00;\n\n\trc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len);\n\n\tkfree(cmd);\n\treturn rc;\n}",
        "output": "1",
        "idx": 3312
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "set_vterm_palette(VTerm *vterm, long_u *rgb)\n{\n    int\t\tindex = 0;\n    VTermState\t*state = vterm_obtain_state(vterm);\n\n    for (; index < 16; index++)\n    {\n\tVTermColor\tcolor;\n\tcolor.red = (unsigned)(rgb[index] >> 16);\n\tcolor.green = (unsigned)(rgb[index] >> 8) & 255;\n\tcolor.blue = (unsigned)rgb[index] & 255;\n\tvterm_state_set_palette_color(state, index, &color);\n    }\n}",
        "output": "0",
        "idx": 8163
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "search_impl(i_ctx_t *i_ctx_p, bool forward)\n{\n    os_ptr op = osp;\n    os_ptr op1 = op - 1;\n    uint size = r_size(op);\n    uint count;\n    byte *pat;\n    byte *ptr;\n    byte ch;\n    int incr = forward ? 1 : -1;\n\n    check_read_type(*op1, t_string);\n    check_read_type(*op, t_string);\n    if (size > r_size(op1)) {\t\n        make_false(op);\n        return 0;\n    }\n    count = r_size(op1) - size;\n    ptr = op1->value.bytes;\n    if (size == 0)\n        goto found;\n    if (!forward)\n        ptr += count;\n    pat = op->value.bytes;\n    ch = pat[0];\n    do {\n        if (*ptr == ch && (size == 1 || !memcmp(ptr, pat, size)))\n            goto found;\n        ptr += incr;\n    }\n    while (count--);\n    make_false(op);\n    return 0;\nfound:\n    op->tas.type_attrs = op1->tas.type_attrs;\n    op->value.bytes = ptr;\n    r_set_size(op, size);\n    push(2);\n    op[-1] = *op1;\n    r_set_size(op - 1, ptr - op[-1].value.bytes);\n    op1->value.bytes = ptr + size;\n    r_set_size(op1, count + (!forward ? (size - 1) : 0));\n    make_true(op);\n    return 0;\n}",
        "output": "1",
        "idx": 8122
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void unix_inflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tspin_lock(&unix_gc_lock);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tif (atomic_long_inc_return(&u->inflight) == 1) {\n\t\t\tBUG_ON(!list_empty(&u->link));\n\t\t\tlist_add_tail(&u->link, &gc_inflight_list);\n\t\t} else {\n\t\t\tBUG_ON(list_empty(&u->link));\n\t\t}\n\t\tunix_tot_inflight++;\n\t}\n\tfp->f_cred->user->unix_inflight++;\n\tspin_unlock(&unix_gc_lock);\n}",
        "output": "0",
        "idx": 1505
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int __init ip6_tunnel_init(void)\n{\n\tint  err;\n\n\terr = register_pernet_device(&ip6_tnl_net_ops);\n\tif (err < 0)\n\t\tgoto out_pernet;\n\n\terr = xfrm6_tunnel_register(&ip4ip6_handler, AF_INET);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip4ip6\\n\");\n\t\tgoto out_ip4ip6;\n\t}\n\n\terr = xfrm6_tunnel_register(&ip6ip6_handler, AF_INET6);\n\tif (err < 0) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip6ip6\\n\");\n\t\tgoto out_ip6ip6;\n\t}\n\n\treturn 0;\n\nout_ip6ip6:\n\txfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET);\nout_ip4ip6:\n\tunregister_pernet_device(&ip6_tnl_net_ops);\nout_pernet:\n\treturn err;\n}",
        "output": "0",
        "idx": 3141
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void timer_enter_running(Timer *t) {\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        int r;\n\n        assert(t);\n\n        if (unit_stop_pending(UNIT(t)))\n                return;\n\n        r = manager_add_job(UNIT(t)->manager, JOB_START, UNIT_TRIGGER(UNIT(t)),\n                            JOB_REPLACE, true, &error, NULL);\n        if (r < 0)\n                goto fail;\n\n        dual_timestamp_get(&t->last_trigger);\n\n        if (t->stamp_path)\n                touch_file(t->stamp_path, true, t->last_trigger.realtime, UID_INVALID, GID_INVALID, MODE_INVALID);\n\n        timer_set_state(t, TIMER_RUNNING);\n        return;\n\nfail:\n        log_unit_warning(UNIT(t), \"Failed to queue unit startup job: %s\", bus_error_message(&error, r));\n        timer_enter_dead(t, TIMER_FAILURE_RESOURCES);\n}",
        "output": "0",
        "idx": 7681
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n\t\tret = -ENOKEY;\n\t\tgoto error2;\n\t}\n\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error2;\n\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\n\ncan_read_key:\n\tret = -EOPNOTSUPP;\n\tif (key->type->read) {\n\t\tdown_read(&key->sem);\n\t\tret = key_validate(key);\n\t\tif (ret == 0)\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\tup_read(&key->sem);\n\t}\n\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}",
        "output": "0",
        "idx": 2427
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int stv06xx_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_interface_cache *intfc;\n\tstruct usb_host_interface *alt;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\tintfc = gspca_dev->dev->actconfig->intf_cache[0];\n\n\tif (intfc->num_altsetting < 2)\n\t\treturn -ENODEV;\n\n\talt = &intfc->altsetting[1];\n\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\talt->endpoint[0].desc.wMaxPacketSize =\n\t\tcpu_to_le16(sd->sensor->max_packet_size[gspca_dev->curr_mode]);\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 4615
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int stv06xx_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\talt->endpoint[0].desc.wMaxPacketSize =\n\t\tcpu_to_le16(sd->sensor->max_packet_size[gspca_dev->curr_mode]);\n\n\treturn 0;\n}",
        "output": "1",
        "idx": 3326
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t qrtr_tun_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct qrtr_tun *tun = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tssize_t ret;\n\tvoid *kbuf;\n\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(kbuf, len, from)) {\n\t\tkfree(kbuf);\n\t\treturn -EFAULT;\n\t}\n\n\tret = qrtr_endpoint_post(&tun->ep, kbuf, len);\n\n\tkfree(kbuf);\n\treturn ret < 0 ? ret : len;\n}",
        "output": "0",
        "idx": 4469
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nfs_set_open_stateid(struct nfs4_state *state, nfs4_stateid *stateid, fmode_t fmode)\n{\n\twrite_seqlock(&state->seqlock);\n\tnfs_set_open_stateid_locked(state, stateid, fmode);\n\twrite_sequnlock(&state->seqlock);\n}",
        "output": "0",
        "idx": 3041
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void fanout_release(struct sock *sk)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct packet_fanout *f;\n\n\tf = po->fanout;\n\tif (!f)\n\t\treturn;\n\n\tmutex_lock(&fanout_mutex);\n\tpo->fanout = NULL;\n\n\tif (atomic_dec_and_test(&f->sk_ref)) {\n\t\tlist_del(&f->list);\n\t\tdev_remove_pack(&f->prot_hook);\n\t\tfanout_release_data(f);\n\t\tkfree(f);\n\t}\n\tmutex_unlock(&fanout_mutex);\n\n\tif (po->rollover)\n\t\tkfree_rcu(po->rollover, rcu);\n}",
        "output": "1",
        "idx": 1478
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "init_ext2_xattr(void)\n{\n\treturn 0;\n}",
        "output": "1",
        "idx": 1124
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}",
        "output": "0",
        "idx": 8275
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void follow_dotdot(struct nameidata *nd)\n{\n\tif (!nd->root.mnt)\n\t\tset_root(nd);\n\n\twhile(1) {\n\t\tstruct dentry *old = nd->path.dentry;\n\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tnd->path.dentry = dget_parent(nd->path.dentry);\n\t\t\tdput(old);\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up(&nd->path))\n\t\t\tbreak;\n\t}\n\tfollow_mount(&nd->path);\n\tnd->inode = nd->path.dentry->d_inode;\n}",
        "output": "1",
        "idx": 2900
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "void xacct_add_tsk(struct taskstats *stats, struct task_struct *p)\n{\n\tstats->coremem = jiffies_to_usecs(p->acct_rss_mem1) * PAGE_SIZE / MB;\n\tstats->virtmem = jiffies_to_usecs(p->acct_vm_mem1) * PAGE_SIZE / MB;\n\tif (p->mm) {\n\t\tstats->hiwater_rss   = p->mm->hiwater_rss * PAGE_SIZE / KB;\n\t\tstats->hiwater_vm    = p->mm->hiwater_vm * PAGE_SIZE / KB;\n\t}\n\tstats->read_char\t= p->rchar;\n\tstats->write_char\t= p->wchar;\n\tstats->read_syscalls\t= p->syscr;\n\tstats->write_syscalls\t= p->syscw;\n}",
        "output": "1",
        "idx": 2068
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n{\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn -1;\n\n\tStream_Read(s, header->Signature, 8);\n\tStream_Read_UINT32(s, header->MessageType);\n\n\tif (strncmp((char*) header->Signature, NTLM_SIGNATURE, 8) != 0)\n\t\treturn -1;\n\n\treturn 1;\n}",
        "output": "0",
        "idx": 5799
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_isBidi (const uint32_t *label, size_t llen)\n{\n  while (llen-- > 0) {\n    int bc = uc_bidi_category (*label++);\n\n    if (bc == UC_BIDI_R || bc == UC_BIDI_AL || bc == UC_BIDI_AN)\n      return 1;\n  }\n\n  return 0;\n}",
        "output": "1",
        "idx": 6258
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int hugepage_madvise(struct vm_area_struct *vma,\n\t\t     unsigned long *vm_flags, int advice)\n{\n\tswitch (advice) {\n\tcase MADV_HUGEPAGE:\n\t\tif (*vm_flags & (VM_HUGEPAGE | VM_NO_THP))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_NOHUGEPAGE;\n\t\t*vm_flags |= VM_HUGEPAGE;\n\t\tif (unlikely(khugepaged_enter_vma_merge(vma)))\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\tcase MADV_NOHUGEPAGE:\n\t\tif (*vm_flags & (VM_NOHUGEPAGE | VM_NO_THP))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_HUGEPAGE;\n\t\t*vm_flags |= VM_NOHUGEPAGE;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 445
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static char *__filterShell(const char *arg) {\n\tr_return_val_if_fail (arg, NULL);\n\tchar *a = malloc (strlen (arg) + 1);\n\tif (!a) {\n\t\treturn NULL;\n\t}\n\tchar *b = a;\n\twhile (*arg) {\n\t\tswitch (*arg) {\n\t\tcase '@':\n\t\tcase '`':\n\t\tcase '|':\n\t\tcase ';':\n\t\tcase '\\n':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*b++ = *arg;\n\t\t\tbreak;\n\t\t}\n\t\targ++;\n\t}\n\t*b = 0;\n\treturn a;\n}",
        "output": "1",
        "idx": 6546
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PUBLIC int mprWriteJson(MprJson *obj, cchar *key, cchar *value)\n{\n    if (setProperty(obj, sclone(key), createJsonValue(value)) == 0) {\n        return MPR_ERR_CANT_WRITE;\n    }\n    return 0;\n}",
        "output": "0",
        "idx": 7079
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "xml_unload_external_entity(const char *URI, xmlCharEncoding enc)    {\n    return NULL;\n}",
        "output": "0",
        "idx": 5289
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_SSL_check_hostname (X509 *cert, const char *host)\n{\n\tint rv;\n\n\trv = _SSL_check_subject_altname (cert, host);\n\tif (rv == 0 || rv == -2)\n\t\treturn rv;\n\n\treturn _SSL_check_common_name (cert, host);\n}",
        "output": "0",
        "idx": 6161
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ikev2_gen_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext)\n{\n\tstruct isakmp_gen e;\n\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tikev2_pay_print(ndo, NPSTR(tpay), e.critical);\n\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}",
        "output": "0",
        "idx": 6809
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t _epoll_write(oe_fd_t* epoll_, const void* buf, size_t count)\n{\n    ssize_t ret = -1;\n    epoll_t* epoll = _cast_epoll(epoll_);\n\n    oe_errno = 0;\n\n    if (oe_syscall_write_ocall(&ret, epoll->host_fd, buf, count) != OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}",
        "output": "1",
        "idx": 8012
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tint result;\n\thandle_t *handle = NULL;\n\tstruct super_block *sb = file_inode(vma->vm_file)->i_sb;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\n\tif (write) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\n\t\t\t\t\t\tEXT4_DATA_TRANS_BLOCKS(sb));\n\t}\n\n\tif (IS_ERR(handle))\n\t\tresult = VM_FAULT_SIGBUS;\n\telse\n\t\tresult = __dax_fault(vma, vmf, ext4_get_block_dax,\n\t\t\t\t\t\text4_end_io_unwritten);\n\n\tif (write) {\n\t\tif (!IS_ERR(handle))\n\t\t\text4_journal_stop(handle);\n\t\tsb_end_pagefault(sb);\n\t}\n\n\treturn result;\n}",
        "output": "1",
        "idx": 990
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int hashtable_init(hashtable_t *hashtable)\n{\n    size_t i;\n\n    hashtable->size = 0;\n    hashtable->order = 3;\n    hashtable->buckets = jsonp_malloc(hashsize(hashtable->order) * sizeof(bucket_t));\n    if(!hashtable->buckets)\n        return -1;\n\n    list_init(&hashtable->list);\n\n    for(i = 0; i < hashsize(hashtable->order); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n\n    return 0;\n}",
        "output": "0",
        "idx": 5971
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "mark_trusted_task_done (GObject      *source_object,\n                        GAsyncResult *res,\n                        gpointer      user_data)\n{\n    MarkTrustedJob *job = user_data;\n\n    g_object_unref (job->file);\n\n    if (job->done_callback)\n    {\n        job->done_callback (!job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n\n    finalize_common ((CommonJob *) job);\n}",
        "output": "1",
        "idx": 6284
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n\t\t\t   iov_count);\n}",
        "output": "1",
        "idx": 92
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "gss_delete_sec_context (minor_status,\n                        context_handle,\n                        output_token)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_buffer_t\t\toutput_token;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n\n    status = val_del_sec_ctx_args(minor_status, context_handle, output_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n\n    ctx = (gss_union_ctx_id_t) *context_handle;\n    if (GSSINT_CHK_LOOP(ctx))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    status = gssint_delete_internal_sec_context(minor_status,\n\t\t\t\t\t\tctx->mech_type,\n\t\t\t\t\t\t&ctx->internal_ctx_id,\n\t\t\t\t\t\toutput_token);\n    if (status)\n\treturn status;\n\n    free(ctx->mech_type->elements);\n    free(ctx->mech_type);\n    free(*context_handle);\n    *context_handle = GSS_C_NO_CONTEXT;\n\n    return (GSS_S_COMPLETE);\n}",
        "output": "1",
        "idx": 188
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void ieee80211_if_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->netdev_ops = &ieee80211_dataif_ops;\n\tdev->destructor = free_netdev;\n}",
        "output": "0",
        "idx": 767
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void nsc_rle_decode(BYTE* in, BYTE* out, UINT32 originalSize)\n{\n\tUINT32 len;\n\tUINT32 left;\n\tBYTE value;\n\tleft = originalSize;\n\n\twhile (left > 4)\n\t{\n\t\tvalue = *in++;\n\n\t\tif (left == 5)\n\t\t{\n\t\t\t*out++ = value;\n\t\t\tleft--;\n\t\t}\n\t\telse if (value == *in)\n\t\t{\n\t\t\tin++;\n\n\t\t\tif (*in < 0xFF)\n\t\t\t{\n\t\t\t\tlen = (UINT32) * in++;\n\t\t\t\tlen += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tin++;\n\t\t\t\tlen = *((UINT32*) in);\n\t\t\t\tin += 4;\n\t\t\t}\n\n\t\t\tFillMemory(out, len, value);\n\t\t\tout += len;\n\t\t\tleft -= len;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*out++ = value;\n\t\t\tleft--;\n\t\t}\n\t}\n\n\t*((UINT32*)out) = *((UINT32*)in);\n}",
        "output": "1",
        "idx": 4218
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int update_discovery_filter(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_start_service_discovery *sd_cp;\n\tGSList *l;\n\n\n\tDBG(\"\");\n\n\tif (discovery_filter_to_mgmt_cp(adapter, &sd_cp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"discovery_filter_to_mgmt_cp returned error\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (l = adapter->discovery_list; l; l = g_slist_next(l)) {\n\t\tstruct discovery_client *client = l->data;\n\n\t\tif (!client->discovery_filter)\n\t\t\tcontinue;\n\n\t\tif (client->discovery_filter->discoverable)\n\t\t\tbreak;\n\t}\n\n\tset_discovery_discoverable(adapter, l ? true : false);\n\n\tif (filters_equal(adapter->current_discovery_filter, sd_cp) &&\n\t    adapter->discovering != 0) {\n\t\tDBG(\"filters were equal, deciding to not restart the scan.\");\n\t\tg_free(sd_cp);\n\t\treturn 0;\n\t}\n\n\tg_free(adapter->current_discovery_filter);\n\tadapter->current_discovery_filter = sd_cp;\n\n\ttrigger_start_discovery(adapter, 0);\n\n\treturn -EINPROGRESS;\n}",
        "output": "1",
        "idx": 8350
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "BGD_DECLARE(void) gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality)\n{\n\t_gdImageJpegCtx(im, outfile, quality);\n}",
        "output": "0",
        "idx": 6223
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "check_dn_in_container(krb5_context context, const char *dn,\n                      char *const *subtrees, unsigned int ntrees)\n{\n    unsigned int i;\n    size_t dnlen = strlen(dn), stlen;\n\n    for (i = 0; i < ntrees; i++) {\n        if (subtrees[i] == NULL || *subtrees[i] == '\\0')\n            return 0;\n        stlen = strlen(subtrees[i]);\n        if (dnlen >= stlen &&\n            strcasecmp(dn + dnlen - stlen, subtrees[i]) == 0 &&\n            (dnlen == stlen || dn[dnlen - stlen - 1] == ','))\n            return 0;\n    }\n\n    k5_setmsg(context, EINVAL, _(\"DN is out of the realm subtree\"));\n    return EINVAL;\n}",
        "output": "0",
        "idx": 295
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static cchar *getPakVersion(cchar *name, cchar *version)\n{\n    MprDirEntry     *dp;\n    MprList         *files;\n\n    if (!version || smatch(version, \"*\")) {\n        name = ssplit(sclone(name), \"#\", (char**) &version);\n        if (*version == '\\0') {\n            files = mprGetPathFiles(mprJoinPath(app->paksCacheDir, name), MPR_PATH_RELATIVE);\n            mprSortList(files, (MprSortProc) reverseSortFiles, 0);\n            if ((dp = mprGetFirstItem(files)) != 0) {\n                version = mprGetPathBase(dp->name);\n            }\n            if (version == 0) {\n                fail(\"Cannot find pak: %s\", name);\n                return 0;\n            }\n        }\n    }\n    return version;\n}",
        "output": "0",
        "idx": 6967
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int floppy_raw_cmd_ioctl(int type, int drive, int cmd,\n\t\t\t\tvoid __user *param)\n{\n\tint ret;\n\n\tpr_warn_once(\"Note: FDRAWCMD is deprecated and will be removed from the kernel in the near future.\\n\");\n\n\tif (type)\n\t\treturn -EINVAL;\n\tif (lock_fdc(drive))\n\t\treturn -EINTR;\n\tset_floppy(drive);\n\tret = raw_cmd_ioctl(cmd, param);\n\tif (ret == -EINTR)\n\t\treturn -EINTR;\n\tprocess_fd_request();\n\treturn ret;\n}",
        "output": "0",
        "idx": 2931
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static struct sk_buff *xfrm_state_netlink(struct sk_buff *in_skb,\n\t\t\t\t\t  struct xfrm_state *x, u32 seq)\n{\n\tstruct xfrm_dump_info info;\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = seq;\n\tinfo.nlmsg_flags = 0;\n\n\tif (dump_one_state(x, 0, &info)) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\treturn skb;\n}",
        "output": "1",
        "idx": 768
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void handle_irq_for_port(evtchn_port_t port)\n{\n\tint irq;\n\n\tirq = get_evtchn_to_irq(port);\n\tif (irq != -1)\n\t\tgeneric_handle_irq(irq);\n}",
        "output": "1",
        "idx": 1902
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "int main(void)\n{\n\tFILE *f;\n\tchar *tmpname;\n\tf = xfmkstemp(&tmpname, NULL);\n\tunlink(tmpname);\n\tfree(tmpname);\n\tfclose(f);\n\treturn EXIT_FAILURE;\n}",
        "output": "1",
        "idx": 4648
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static bool tailmatch(const char *little, const char *bigone)\n{\n  size_t littlelen = strlen(little);\n  size_t biglen = strlen(bigone);\n\n  if(littlelen > biglen)\n    return FALSE;\n\n  return Curl_raw_equal(little, bigone+biglen-littlelen) ? TRUE : FALSE;\n}",
        "output": "1",
        "idx": 3596
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void handle_runtime(HttpRequest req, HttpResponse res) {\n        LOCK(Run.mutex)\n        do_runtime(req, res);\n        END_LOCK;\n}",
        "output": "0",
        "idx": 8417
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "flush_signal_handlers(struct task_struct *t, int force_default)\n{\n\tint i;\n\tstruct k_sigaction *ka = &t->sighand->action[0];\n\tfor (i = _NSIG ; i != 0 ; i--) {\n\t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n\t\t\tka->sa.sa_handler = SIG_DFL;\n\t\tka->sa.sa_flags = 0;\n#ifdef SA_RESTORER\n\t\tka->sa.sa_restorer = NULL;\n#endif\n\t\tsigemptyset(&ka->sa.sa_mask);\n\t\tka++;\n\t}\n}",
        "output": "0",
        "idx": 1237
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "_client_protocol_timeout (GsmXSMPClient *client)\n{\n        g_debug (\"GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d\",\n                 client->priv->description,\n                 IceConnectionStatus (client->priv->ice_connection));\n\n        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);\n        gsm_client_disconnected (GSM_CLIENT (client));\n\n        return FALSE;\n}",
        "output": "1",
        "idx": 6214
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static ssize_t drop_sync(QIOChannel *ioc, size_t size)\n{\n    ssize_t ret = 0;\n    char small[1024];\n    char *buffer;\n\n    buffer = sizeof(small) < size ? small : g_malloc(MIN(65536, size));\n    while (size > 0) {\n        ssize_t count = read_sync(ioc, buffer, MIN(65536, size));\n\n        if (count <= 0) {\n            goto cleanup;\n        }\n        assert(count <= size);\n        size -= count;\n        ret += count;\n    }\n\n cleanup:\n    if (buffer != small) {\n        g_free(buffer);\n    }\n    return ret;\n}",
        "output": "1",
        "idx": 3772
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "cib_send_plaintext(int sock, xmlNode * msg)\n{\n    char *xml_text = dump_xml_unformatted(msg);\n\n    if (xml_text != NULL) {\n        int rc = 0;\n        char *unsent = xml_text;\n        int len = strlen(xml_text);\n\n        len++;                  \n        crm_trace(\"Message on socket %d: size=%d\", sock, len);\n  retry:\n        rc = write(sock, unsent, len);\n        if (rc < 0) {\n            switch (errno) {\n                case EINTR:\n                case EAGAIN:\n                    crm_trace(\"Retry\");\n                    goto retry;\n                default:\n                    crm_perror(LOG_ERR, \"Could only write %d of the remaining %d bytes\", rc, len);\n                    break;\n            }\n\n        } else if (rc < len) {\n            crm_trace(\"Only sent %d of %d remaining bytes\", rc, len);\n            len -= rc;\n            unsent += rc;\n            goto retry;\n\n        } else {\n            crm_trace(\"Sent %d bytes: %.100s\", rc, xml_text);\n        }\n    }\n    free(xml_text);\n    return NULL;\n\n}",
        "output": "1",
        "idx": 3750
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static pyc_object *get_none_object(void) {\n\tpyc_object *ret;\n\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_NONE;\n\tret->data = strdup (\"None\");\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t}\n\treturn ret;\n}",
        "output": "1",
        "idx": 6432
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void snd_usb_mixer_free(struct usb_mixer_interface *mixer)\n{\n\tsnd_usb_mixer_disconnect(mixer);\n\n\tkfree(mixer->id_elems);\n\tif (mixer->urb) {\n\t\tkfree(mixer->urb->transfer_buffer);\n\t\tusb_free_urb(mixer->urb);\n\t}\n\tusb_free_urb(mixer->rc_urb);\n\tkfree(mixer->rc_setup_packet);\n\tkfree(mixer);\n}",
        "output": "0",
        "idx": 2451
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)\n{\n\tstruct skcipher_tfm *tfm = private;\n\tint err;\n\n\terr = crypto_skcipher_setkey(tfm->skcipher, key, keylen);\n\ttfm->has_key = !err;\n\n\treturn err;\n}",
        "output": "0",
        "idx": 1541
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "PHP_FUNCTION(curl_unescape)\n{\n\tchar       *str = NULL, *out = NULL;\n\tsize_t     str_len = 0;\n\tint        out_len;\n\tzval       *zid;\n\tphp_curl   *ch;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rs\", &zid, &str, &str_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif ((ch = (php_curl*)zend_fetch_resource(Z_RES_P(zid), le_curl_name, le_curl)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (str_len > INT_MAX) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif ((out = curl_easy_unescape(ch->cp, str, str_len, &out_len))) {\n\t\tRETVAL_STRINGL(out, out_len);\n\t\tcurl_free(out);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}",
        "output": "1",
        "idx": 4068
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify)\n{\n\tGIOChannel *handle, *ssl_handle;\n\n\thandle = net_connect_ip(ip, port, my_ip);\n\tif (handle == NULL)\n\t\treturn NULL;\n\tssl_handle  = irssi_ssl_get_iochannel(handle, cert, pkey, cafile, capath, verify);\n\tif (ssl_handle == NULL)\n\t\tg_io_channel_unref(handle);\n\treturn ssl_handle;\n}",
        "output": "1",
        "idx": 3366
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void scsi_free_request(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    qemu_vfree(r->iov.iov_base);\n}",
        "output": "1",
        "idx": 3582
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "ossl_cipher_initialize(VALUE self, VALUE str)\n{\n    EVP_CIPHER_CTX *ctx;\n    const EVP_CIPHER *cipher;\n    char *name;\n\n    name = StringValueCStr(str);\n    GetCipherInit(self, ctx);\n    if (ctx) {\n\tossl_raise(rb_eRuntimeError, \"Cipher already inititalized!\");\n    }\n    AllocCipher(self, ctx);\n    if (!(cipher = EVP_get_cipherbyname(name))) {\n\tossl_raise(rb_eRuntimeError, \"unsupported cipher algorithm (%\"PRIsVALUE\")\", str);\n    }\n    if (EVP_CipherInit_ex(ctx, cipher, NULL, NULL, NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n\n    return self;\n}",
        "output": "0",
        "idx": 8507
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct cifs_ses *ses = sess_data->ses;\n\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (ses->server->ops->generate_signingkey) {\n\t\trc = ses->server->ops->generate_signingkey(ses);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI,\n\t\t\t\t\"SMB3 session key generation failed\\n\");\n\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\treturn rc;\n\t\t}\n\t}\n\tif (!ses->server->session_estab) {\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tcifs_dbg(FYI, \"SMB2/3 session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn rc;\n}",
        "output": "0",
        "idx": 2119
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "iakerb_gss_pseudo_random(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                         int prf_key, const gss_buffer_t prf_in,\n                         ssize_t desired_output_len, gss_buffer_t prf_out)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_pseudo_random(minor_status, ctx->gssc, prf_key, prf_in,\n                                  desired_output_len, prf_out);\n}",
        "output": "0",
        "idx": 141
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void check_registration_keywords(hook_user_register_check_t *hdata)\n{\n\tif (hdata->approved || !anope_flags_compat)\n\t{\n\t\treturn;\n\t}\n\n\tif (!strcasecmp(hdata->account, \"LIST\") || !strcasecmp(hdata->account, \"CLEAR\") || !strcasecmp(hdata->account, \"MODIFY\"))\n\t{\n\t\tcommand_fail(hdata->si, fault_badparams, \"The nick \\2%s\\2 is reserved and cannot be registered.\", hdata->account);\n\t\thdata->approved = 1;\n\t}\n}",
        "output": "0",
        "idx": 7135
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void handle_run(HttpRequest req, HttpResponse res) {\n        const char *action = get_parameter(req, \"action\");\n        if (action) {\n                if (is_readonly(req)) {\n                        send_error(req, res, SC_FORBIDDEN, \"You do not have sufficient privileges to access this page\");\n                        return;\n                }\n                if (IS(action, \"validate\")) {\n                        LogInfo(\"The Monit http server woke up on user request\\n\");\n                        do_wakeupcall();\n                } else if (IS(action, \"stop\")) {\n                        LogInfo(\"The Monit http server stopped on user request\\n\");\n                        send_error(req, res, SC_SERVICE_UNAVAILABLE, \"The Monit http server is stopped\");\n                        Engine_stop();\n                        return;\n                }\n        }\n        LOCK(Run.mutex)\n        do_runtime(req, res);\n        END_LOCK;\n}",
        "output": "1",
        "idx": 6006
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static void stellaris_enet_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n    k->init = stellaris_enet_init;\n    dc->unrealize = stellaris_enet_unrealize;\n    dc->props = stellaris_enet_properties;\n    dc->vmsd = &vmstate_stellaris_enet;\n}",
        "output": "0",
        "idx": 5319
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static int checkout_verify_paths(\n\tgit_repository *repo,\n\tint action,\n\tgit_diff_delta *delta)\n{\n\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS | GIT_PATH_REJECT_DOT_GIT_NTFS;\n\n\tif (action & CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot remove invalid path '%s'\", delta->old_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (action & ~CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->new_file.path, delta->new_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot checkout to invalid path '%s'\", delta->new_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "output": "0",
        "idx": 6843
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "inline static jas_int_asl(int x, int n)\n{\n\tassert(n >= 0);\n\treturn x << n;\n}",
        "output": "0",
        "idx": 7481
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "njs_typed_array_set_value(njs_vm_t *vm, njs_typed_array_t *array,\n    uint32_t index, njs_value_t *setval)\n{\n    double              num;\n    njs_int_t           ret;\n    njs_array_buffer_t  *buffer;\n\n    ret = njs_value_to_number(vm, setval, &num);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    buffer = njs_typed_array_writable(vm, array);\n    if (njs_slow_path(buffer == NULL)) {\n        return NJS_ERROR;\n    }\n\n    njs_typed_array_prop_set(vm, array, index, num);\n\n    njs_set_number(setval, num);\n\n    return NJS_OK;\n}",
        "output": "1",
        "idx": 8888
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static enum AVPixelFormat h263_get_format(AVCodecContext *avctx)\n{\n    if (avctx->bits_per_raw_sample > 8) {\n        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n        return avctx->pix_fmt;\n    }\n\n    if (avctx->codec->id == AV_CODEC_ID_MSS2)\n        return AV_PIX_FMT_YUV420P;\n\n    if (CONFIG_GRAY && (avctx->flags & AV_CODEC_FLAG_GRAY)) {\n        if (avctx->color_range == AVCOL_RANGE_UNSPECIFIED)\n            avctx->color_range = AVCOL_RANGE_MPEG;\n        return AV_PIX_FMT_GRAY8;\n    }\n\n    return avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);\n}",
        "output": "1",
        "idx": 3410
    },
    {
        "instruction": "Detect whether the following code contains vulnerabilities.",
        "input": "static EjsObj *http_info(Ejs *ejs, EjsHttp *hp, int argc, EjsObj **argv)\n{\n    EjsObj  *obj;\n    char    *key, *next, *value;\n\n    if (hp->conn && hp->conn->sock) {\n        obj = ejsCreateEmptyPot(ejs);\n        for (key = stok(mprGetSocketState(hp->conn->sock), \",\", &next); key; key = stok(NULL, \",\", &next)) {\n            stok(key, \"=\", &value);\n            ejsSetPropertyByName(ejs, obj, EN(key), ejsCreateStringFromAsc(ejs, value));\n        }\n        return obj;\n    }\n    return ESV(null);\n}",
        "output": "1",
        "idx": 4964
    }
]